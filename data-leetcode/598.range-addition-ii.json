[
    {
        "title": "Validate Binary Search Tree",
        "question_content": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\n\n\tThe left subtree of a node contains only nodes with keys less than the node's key.\n\tThe right subtree of a node contains only nodes with keys greater than the node's key.\n\tBoth the left and right subtrees must also be binary search trees.\n\n&nbsp;\nExample 1:\n\nInput: root = [2,1,3]\nOutput: true\n\nExample 2:\n\nInput: root = [5,1,4,null,null,3,6]\nOutput: false\nExplanation: The root node's value is 5 but its right child's value is 4.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 104].\n\t-231 <= Node.val <= 231 - 1",
        "solutions": [
            {
                "id": 32112,
                "title": "learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-java-solution",
                "content": "I will show you all how to tackle various tree questions using iterative inorder traversal. First one is the standard iterative inorder traversal using stack. Hope everyone agrees with this solution. \\n\\nQuestion : [Binary Tree Inorder Traversal][1]\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(root != null || !stack.empty()){\\n            while(root != null){\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            list.add(root.val);\\n            root = root.right;\\n            \\n        }\\n        return list;\\n    }\\n\\nNow, we can use this structure to find the Kth smallest element in BST.\\n\\nQuestion : [Kth Smallest Element in a BST][2]\\n\\n     public int kthSmallest(TreeNode root, int k) {\\n         Stack<TreeNode> stack = new Stack<>();\\n         while(root != null || !stack.isEmpty()) {\\n             while(root != null) {\\n                 stack.push(root);    \\n                 root = root.left;   \\n             } \\n             root = stack.pop();\\n             if(--k == 0) break;\\n             root = root.right;\\n         }\\n         return root.val;\\n     }\\n\\nWe can also use this structure to solve BST validation question. \\n\\nQuestion : [Validate Binary Search Tree][3]\\n\\n    public boolean isValidBST(TreeNode root) {\\n       if (root == null) return true;\\n       Stack<TreeNode> stack = new Stack<>();\\n       TreeNode pre = null;\\n       while (root != null || !stack.isEmpty()) {\\n          while (root != null) {\\n             stack.push(root);\\n             root = root.left;\\n          }\\n          root = stack.pop();\\n          if(pre != null && root.val <= pre.val) return false;\\n          pre = root;\\n          root = root.right;\\n       }\\n       return true;\\n    }\\n\\n\\n\\n  [1]: https://leetcode.com/problems/binary-tree-inorder-traversal/\\n  [2]: https://leetcode.com/problems/kth-smallest-element-in-a-bst/\\n  [3]: https://leetcode.com/problems/validate-binary-search-tree/",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "I will show you all how to tackle various tree questions using iterative inorder traversal. First one is the standard iterative inorder traversal using stack. Hope everyone agrees with this solution. \\n\\nQuestion : [Binary Tree Inorder Traversal][1]\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(root != null || !stack.empty()){\\n            while(root != null){\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            list.add(root.val);\\n            root = root.right;\\n            \\n        }\\n        return list;\\n    }\\n\\nNow, we can use this structure to find the Kth smallest element in BST.\\n\\nQuestion : [Kth Smallest Element in a BST][2]\\n\\n     public int kthSmallest(TreeNode root, int k) {\\n         Stack<TreeNode> stack = new Stack<>();\\n         while(root != null || !stack.isEmpty()) {\\n             while(root != null) {\\n                 stack.push(root);    \\n                 root = root.left;   \\n             } \\n             root = stack.pop();\\n             if(--k == 0) break;\\n             root = root.right;\\n         }\\n         return root.val;\\n     }\\n\\nWe can also use this structure to solve BST validation question. \\n\\nQuestion : [Validate Binary Search Tree][3]\\n\\n    public boolean isValidBST(TreeNode root) {\\n       if (root == null) return true;\\n       Stack<TreeNode> stack = new Stack<>();\\n       TreeNode pre = null;\\n       while (root != null || !stack.isEmpty()) {\\n          while (root != null) {\\n             stack.push(root);\\n             root = root.left;\\n          }\\n          root = stack.pop();\\n          if(pre != null && root.val <= pre.val) return false;\\n          pre = root;\\n          root = root.right;\\n       }\\n       return true;\\n    }\\n\\n\\n\\n  [1]: https://leetcode.com/problems/binary-tree-inorder-traversal/\\n  [2]: https://leetcode.com/problems/kth-smallest-element-in-a-bst/\\n  [3]: https://leetcode.com/problems/validate-binary-search-tree/",
                "codeTag": "Unknown"
            },
            {
                "id": 32109,
                "title": "my-simple-java-solution-in-3-lines",
                "content": "    public class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n        }\\n        \\n        public boolean isValidBST(TreeNode root, long minVal, long maxVal) {\\n            if (root == null) return true;\\n            if (root.val >= maxVal || root.val <= minVal) return false;\\n            return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);\\n        }\\n    }\\n\\nBasically what I am doing is recursively iterating over the tree while defining interval `<minVal, maxVal>` for each node which value must fit in.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32104,
                "title": "c-in-order-traversal-and-please-do-not-rely-on-buggy-int-max-int-min-solutions-any-more",
                "content": "    class Solution {\\n    public:\\n        bool isValidBST(TreeNode* root) {\\n            TreeNode* prev = NULL;\\n            return validate(root, prev);\\n        }\\n        bool validate(TreeNode* node, TreeNode* &prev) {\\n            if (node == NULL) return true;\\n            if (!validate(node->left, prev)) return false;\\n            if (prev != NULL && prev->val >= node->val) return false;\\n            prev = node;\\n            return validate(node->right, prev);\\n        }\\n    };\\n\\n> Update:\\n> \\n> If we use in-order traversal to serialize a binary search tree, we can\\n> get a list of values in ascending order. It can be proved with the\\n> definition of BST. And here I use the reference of TreeNode\\n> pointer `prev` as a global variable to mark the address of previous node in the\\n> list.\\n> \\n> \\u201cIn-order Traversal\\u201d:\\n> [https://en.wikipedia.org/wiki/Tree_traversal#In-order]()\\n\\nIf you know what `INT_MAX` or `INT_MIN` is, then it is no excuse for your carelessness.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isValidBST(TreeNode* root) {\\n            TreeNode* prev = NULL;\\n            return validate(root, prev);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32141,
                "title": "c-simple-recursive-solution",
                "content": "    bool isValidBST(TreeNode* root) {\\n        return isValidBST(root, NULL, NULL);\\n    }\\n    \\n    bool isValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {\\n        if(!root) return true;\\n        if(minNode && root->val <= minNode->val || maxNode && root->val >= maxNode->val)\\n            return false;\\n        return isValidBST(root->left, minNode, root) && isValidBST(root->right, root, maxNode);\\n    }",
                "solutionTags": [],
                "code": "    bool isValidBST(TreeNode* root) {\\n        return isValidBST(root, NULL, NULL);\\n    }\\n    \\n    bool isValidBST(TreeNode* root, TreeNode* minNode, TreeNode* maxNode) {\\n        if(!root) return true;\\n        if(minNode && root->val <= minNode->val || maxNode && root->val >= maxNode->val)\\n            return false;\\n        return isValidBST(root->left, minNode, root) && isValidBST(root->right, root, maxNode);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3169560,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n\\nbool isPossible(TreeNode* root, long long l, long long r){\\n    if(root == nullptr)  return true;\\n    if(root->val < r and root->val > l)\\n        return isPossible(root->left, l, root->val) and \\n                                isPossible(root->right, root->val, r);\\n    else return false;\\n}\\n\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        long long int min = -1000000000000, max = 1000000000000;\\n        return isPossible(root, min, max);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        prev = float(\\'-inf\\')\\n        def inorder(node):\\n            nonlocal prev\\n            if not node:\\n                return True\\n            if not (inorder(node.left) and prev < node.val):\\n                return False\\n            prev = node.val\\n            return inorder(node.right)\\n        return inorder(root)\\n```\\n\\n```Java []\\nclass Solution {\\n    private long minVal = Long.MIN_VALUE;\\n    public boolean isValidBST(TreeNode root) {\\n        if (root == null) return true; \\n        if (!isValidBST(root.left)) return false;\\n        \\n        if (minVal >= root.val) return false; \\n\\n        minVal = root.val;\\n\\n        if (!isValidBST(root.right)) return false;\\n\\n        return true;\\n    } \\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n\\nbool isPossible(TreeNode* root, long long l, long long r){\\n    if(root == nullptr)  return true;\\n    if(root->val < r and root->val > l)\\n        return isPossible(root->left, l, root->val) and \\n                                isPossible(root->right, root->val, r);\\n    else return false;\\n}\\n\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        long long int min = -1000000000000, max = 1000000000000;\\n        return isPossible(root, min, max);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        prev = float(\\'-inf\\')\\n        def inorder(node):\\n            nonlocal prev\\n            if not node:\\n                return True\\n            if not (inorder(node.left) and prev < node.val):\\n                return False\\n            prev = node.val\\n            return inorder(node.right)\\n        return inorder(root)\\n```\n```Java []\\nclass Solution {\\n    private long minVal = Long.MIN_VALUE;\\n    public boolean isValidBST(TreeNode root) {\\n        if (root == null) return true; \\n        if (!isValidBST(root.left)) return false;\\n        \\n        if (minVal >= root.val) return false; \\n\\n        minVal = root.val;\\n\\n        if (!isValidBST(root.right)) return false;\\n\\n        return true;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786520,
                "title": "general-tree-traversal-problems-interview-prep",
                "content": "Please feel free to suggest similar problems in the comment section.\\n\\nThere are three types of Tree traversal: Inorder, Preorder and Postorder\\n\\n* **Inorder:** left, root, right\\n* **Preorder:** root, left child, right child **OR**  root, right child, left child\\t\\t\\t\\n* **Postorder:** left child, right child, root **OR** right child, left child, root\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\n**INORDER TRAVERSAL**\\n\\n**98. Validate Binary Search Tree**\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        output =[]\\n        self.inorder(root, output)\\n        \\n        for i in range(1, len(output)):\\n\\t\\t\\tif output[i-1]>= output[i]:\\n\\t\\t\\t\\treturn False\\n        \\n        return True\\n    \\n    # Time complexity of inorder traversal is O(n)\\n    # Fun fact: Inorder traversal leads to a sorted array if it is \\n    # a Valid Binary Search. Tree.\\n    def inorder(self, root, output):\\n        if root is None:\\n            return\\n        \\n        self.inorder(root.left, output)\\n        output.append(root.val)\\n        self.inorder(root.right, output)\\n        \\n```\\n**94. Binary Tree Inorder Traversal**\\n\\n\\n```\\n# Recursive: runtime-16ms\\n\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        self.inorder(root, output)\\n        return output\\n        \\n    def inorder(self, root, output):\\n        if root is None:\\n            return\\n        \\n        self.inorder(root.left, output)\\n        output.append(root.val)\\n        self.inorder(root.right, output)\\n\\n\\n# Iterative Runtime: 20 ms, faster than 70.13%\\n\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        stack=[]\\n        \\n        while stack or root:\\n            \\n            if root:\\n                stack.append(root)\\n                root =root.left\\n                \\n            else:\\n                temp =stack.pop()\\n                output.append(temp.val)\\n                root= temp.right\\n           \\n        return output\\n```\\n\\n**PREORDER TRAVERSAL**\\n\\n**589. N-ary Tree Preorder Traversal**\\n\\n\\n```\\n## Recursive Solution: Runtime: 36 ms, faster than 97.16%\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        output =[]\\n        \\n        # perform dfs on the root and get the output stack\\n        self.dfs(root, output)\\n        \\n        # return the output of all the nodes.\\n        return output\\n    \\n    def dfs(self, root, output):\\n        \\n        # If root is none return \\n        if root is None:\\n            return\\n        \\n        # for preorder we first add the root val\\n        output.append(root.val)\\n        \\n        # Then add all the children to the output\\n        for child in root.children:\\n            self.dfs(child, output)\\n       \\n\\t   \\n\\t   \\n# Iterative Solution- Runtime: 40 ms, faster than 91.86% \\n\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        if root is None:\\n            return []\\n        \\n        stack = [root]\\n        output = []\\n        \\n        # Till there is element in stack the loop runs.\\n        while stack:\\n            \\n            #pop the last element from the stack and store it into temp.\\n            temp = stack.pop()\\n            \\n            # append. the value of temp to output\\n            output.append(temp.val)\\n            \\n            #add the children of the temp into the stack in reverse order.\\n            # children of 1 = [3,2,4], if not reveresed then 4 will be popped out first from the stack.\\n            # if reversed then stack = [4,2,3]. Here 3 will pop out first.\\n            # This continues till the stack is empty.\\n            stack.extend(temp.children[::-1])\\n        \\n        #return the output\\n        return output\\n        \\n```\\n\\n\\n\\n**144. Binary Tree Preorder Traversal**\\n\\n\\n```\\n# Recursive solution\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        self.dfs(root, output)\\n        return output\\n    \\n    def dfs(self, root, output):\\n        if root is None:\\n            return\\n        \\n        output.append(root.val)\\n        self.dfs(root.left, output)\\n        self.dfs(root.right, output)\\n       \\n\\t   \\n# Iterative Solution- Runtime: 12 ms, faster than 97.82%\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        stack = [root]\\n        \\n        while stack:\\n            temp=stack.pop()\\n            if temp:\\n                output.append(temp.val)\\n                stack.append(temp.right)\\n                stack.append(temp.left)\\n        \\n        return output\\n```\\n**257. Binary Tree Paths** : Runtime: 16 ms, faster than 93.92% of Python \\nhttps://leetcode.com/problems/binary-tree-paths/\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[str]\\n        \"\"\"\\n        if root is None:\\n            return []\\n        \\n        result = []\\n        self.dfs(root, \"\", result)\\n        return result\\n\\n    def dfs(self, root, path, result):\\n        if not root.left and not root.right:\\n            result.append(path + str(root.val))\\n        \\n        if root.left:\\n            self.dfs(root.left, path + str(root.val) + \"->\" , result)\\n        if root.right:\\n            self.dfs(root.right, path + str(root.val) + \"->\", result)\\n        \\n```\\n\\n\\n**POSTORDER TRAVERSAL**\\n\\n**590. N-ary Tree Postorder Traversal**\\n```\\n# Recursive : Runtime: 40 ms, faster than 89.79% \\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        self.dfs(root, output)\\n        return output\\n    \\n    def dfs(self, root, output):\\n        if root is None:\\n            return\\n        for child in root.children:\\n            self.dfs(child, output)\\n        \\n        output.append(root.val)\\n \\n \\n # Iterative Solution: Runtime: 48 ms, faster than 62.81%\\n \\n `\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        stack = [root]\\n        \\n        while stack:\\n            root = stack.pop()\\n            if root:\\n                output.append(root.val)\\n                stack += root.children\\n                \\n        return output[::-1]`\\n        \\n```\\n\\n**145. Binary Tree Postorder Traversal**\\n\\n```\\n# Recursive solution\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        self.dfs(root, output)\\n        return output\\n    \\n    def dfs(self, root, output):\\n        if root is None:\\n            return\\n        self.dfs(root.left, output)\\n        self.dfs(root.right, output) \\n        output.append(root.val)\\n\\t\\t\\n\\t\\t\\n# Iterative solution: Runtime: 12 ms, faster than 98.10%\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        stack =[root]\\n        \\n        if not root:\\n            return None\\n        \\n        # iterate only when there is elements inside the stack.\\n        while stack:\\n            \\n            # pop the element from stack and stored it into temp\\n            temp=stack.pop()\\n            \\n            #append the value of temp to output\\n            output.append(temp.val)\\n            \\n            #Now traverse through left node and add the node to stack\\n            if temp.left:\\n                stack.append(temp.left)\\n                \\n            #else traverse through right node and add to stack\\n            if temp.right:\\n                stack.append(temp.right)\\n         \\n        # After iterating through the stack,  print the result in reverse order.  \\n        return output[::-1]\\n    \\n    \\n# Example: Iteration 1 : #stack=[1] - first iteration, temp =1, \\n                #output[1]\\n                #temp.left is Null\\n                #temp.right is [2]\\n                # stack =[2]\\n\\n```\\n\\n**LEVEL ORDER TRAVERSAL**\\n\\n**102. Binary Tree Level Order Traversal**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output =[]\\n        self.dfs(root, 0, output)\\n        return output\\n    \\n    def dfs(self, root, level, output):\\n        \\n        if not root:\\n            return\\n        \\n        if len(output) < level+1:\\n            output.append([])\\n            \\n        output[level].append(root.val)    \\n        self.dfs(root.left, level+1, output)\\n        self.dfs(root.right, level+1, output)\\n        \\n```\\n\\n**107. Binary Tree Level Order Traversal II**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def levelOrderBottom(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output = []\\n        self.dfs(root, 0, output)\\n        return output[::-1]\\n    \\n    def dfs(self, root, level, output):\\n        if root is None:\\n             return\\n            \\n        if len(output) < level+1:\\n            output.append([])\\n            \\n        output[level].append(root.val)\\n        self.dfs(root.left, level+1, output)\\n        self.dfs(root.right, level+1, output)\\n```\\n\\n**429. N-ary Tree Level Order Traversal**\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output=[]\\n        self.dfs(root, 0, output)\\n        return output\\n    \\n    def dfs(self, root, level ,output):\\n        if root is None:\\n            return\\n        if len(output)< level+1:\\n            output.append([])\\n        \\n        output[level].append(root.val)\\n        for child in root.children:\\n            self.dfs(child, level+1, output)\\n      \\n```\\n\\n**103. Binary Tree Zigzag Level Order Traversal**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output=[]\\n        self.dfs(root, 0, output)\\n        \\n        for i in range(len(output)):\\n            if i % 2 !=0:\\n                output[i].reverse()\\n            else:\\n                continue\\n        return output\\n    \\n    def dfs(self, root, level, output):\\n        if root is None:\\n            return\\n        \\n        if len(output) < level+1:\\n            output.append([])\\n        \\n        output[level].append(root.val)\\n        self.dfs(root.left, level+1, output)\\n        self.dfs(root.right, level+1, output)\\n        \\n```\\n\\n\\n**BINARY TREE CONSTRUCTION**\\n\\n\\n**105. Construct Binary Tree from Preorder and Inorder Traversal**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if not inorder or not preorder:\\n            return None\\n        \\n        #pattern is preorder=[root, left, right]\\n        #inorder = [left, root, right],  so find index and value using root.\\n        \\n        root = TreeNode(preorder[0])\\n        \\n        root_index= 0\\n        \\n        #iterate through inorder list and find the list index of the root.\\n        for i in range(len(inorder)):\\n            if inorder[i]== root.val:\\n                root_index = i\\n            else:\\n                continue\\n                \\n        #slice the inorder list into left and right.     \\n        left_inorder = inorder[:root_index]\\n        right_inorder = inorder[root_index+1:]\\n        \\n        #slice the preorder list into left and right.\\n        left_preorder = preorder[1:len(left_inorder)+1]\\n        right_preorder = preorder[len(left_preorder)+1:]\\n        \\n        #append by updating preorder and inorder lists\\n        root.left = self.buildTree(left_preorder, left_inorder)\\n        root.right = self.buildTree(right_preorder, right_inorder)\\n        \\n        return root\\n```\\n\\n**106. Construct Binary Tree from Inorder and Postorder Traversal**\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        \"\"\"\\n        :type inorder: List[int]\\n        :type postorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        # PATTERN\\n        # inorder: l, root, right\\n        # postorder: l,r,root\\n        # the last element of postorder is root\\n        \\n        if not inorder or not postorder:\\n            return None\\n        \\n        root_index=0\\n        \\n        # Build the data structure based on root value\\n        root = TreeNode(postorder.pop())\\n        \\n        for i in range(len(inorder)):\\n            if inorder[i]==root.val:\\n                root_index=i\\n            else:\\n                continue\\n        \\n        left_in=inorder[:root_index]\\n        right_in = inorder[root_index+1:]\\n        \\n        root.right = self.buildTree(right_in, postorder)\\n        root.left = self.buildTree(left_in,  postorder)\\n\\n        return root\\n   \\n```\\n\\n**889. Construct Binary Tree from Preorder and Postorder Traversal:** \\nRuntime: 40 ms, faster than 80.14%\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def constructFromPrePost(self, pre, post):\\n        \"\"\"\\n        :type pre: List[int]\\n        :type post: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not pre:\\n            return None\\n        \\n        root = TreeNode(post.pop())\\n        \\n        if len(pre) == 1:\\n            return root\\n        \\n        # Find the index of the root value from pre\\n        for i in range(len(pre)):\\n            if pre[i]==post[-1]:\\n                root_index= i\\n            else:\\n                continue\\n        \\n        root.right = self.constructFromPrePost(pre[root_index:], post) \\n        root.left = self.constructFromPrePost(pre[1:root_index],post) \\n        \\n        return root \\n   \\n# Explanation:   root=1, root_index = 0, root.right=(pre(1,2,3,4,5,6,7))  [1, 2,3,4,5,6,7]                           vii\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t# root = 3, root_index= 4, root.right=(pre(3,6,7))  [3,4,5,6,7]                               v\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root=7, root_index=2, root.right= pre(7), now len(pre) == 1, return 7 ---[7]        i\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root =6, root_index=1, root.left= pre(6), now len(pre)==1, return 6 -----[6,7]      ii \\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t# root =2, root_index= 1, root.right= pre(2,4,5)   [2,3,4,5,6,7]                               vi \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root = 5, root_index=2, root.right= pre(5)  now len(pre)==1, return 5 ----[5,6,7]   iii\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root = 4, root_index=1, root.right= pre(4)  now len(pre)==1, return 4-----[4,5,6,7]  iv\\n\\n```\\n=========================================================\\nHope you\\'ve found the solutions useful. Please do UPVOTE, it only motivates me to write more such posts. Thanks!",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        output =[]\\n        self.inorder(root, output)\\n        \\n        for i in range(1, len(output)):\\n\\t\\t\\tif output[i-1]>= output[i]:\\n\\t\\t\\t\\treturn False\\n        \\n        return True\\n    \\n    # Time complexity of inorder traversal is O(n)\\n    # Fun fact: Inorder traversal leads to a sorted array if it is \\n    # a Valid Binary Search. Tree.\\n    def inorder(self, root, output):\\n        if root is None:\\n            return\\n        \\n        self.inorder(root.left, output)\\n        output.append(root.val)\\n        self.inorder(root.right, output)\\n        \\n```\n```\\n# Recursive: runtime-16ms\\n\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        self.inorder(root, output)\\n        return output\\n        \\n    def inorder(self, root, output):\\n        if root is None:\\n            return\\n        \\n        self.inorder(root.left, output)\\n        output.append(root.val)\\n        self.inorder(root.right, output)\\n\\n\\n# Iterative Runtime: 20 ms, faster than 70.13%\\n\\nclass Solution(object):\\n    def inorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        stack=[]\\n        \\n        while stack or root:\\n            \\n            if root:\\n                stack.append(root)\\n                root =root.left\\n                \\n            else:\\n                temp =stack.pop()\\n                output.append(temp.val)\\n                root= temp.right\\n           \\n        return output\\n```\n```\\n## Recursive Solution: Runtime: 36 ms, faster than 97.16%\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        output =[]\\n        \\n        # perform dfs on the root and get the output stack\\n        self.dfs(root, output)\\n        \\n        # return the output of all the nodes.\\n        return output\\n    \\n    def dfs(self, root, output):\\n        \\n        # If root is none return \\n        if root is None:\\n            return\\n        \\n        # for preorder we first add the root val\\n        output.append(root.val)\\n        \\n        # Then add all the children to the output\\n        for child in root.children:\\n            self.dfs(child, output)\\n       \\n\\t   \\n\\t   \\n# Iterative Solution- Runtime: 40 ms, faster than 91.86% \\n\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def preorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        if root is None:\\n            return []\\n        \\n        stack = [root]\\n        output = []\\n        \\n        # Till there is element in stack the loop runs.\\n        while stack:\\n            \\n            #pop the last element from the stack and store it into temp.\\n            temp = stack.pop()\\n            \\n            # append. the value of temp to output\\n            output.append(temp.val)\\n            \\n            #add the children of the temp into the stack in reverse order.\\n            # children of 1 = [3,2,4], if not reveresed then 4 will be popped out first from the stack.\\n            # if reversed then stack = [4,2,3]. Here 3 will pop out first.\\n            # This continues till the stack is empty.\\n            stack.extend(temp.children[::-1])\\n        \\n        #return the output\\n        return output\\n        \\n```\n```\\n# Recursive solution\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        self.dfs(root, output)\\n        return output\\n    \\n    def dfs(self, root, output):\\n        if root is None:\\n            return\\n        \\n        output.append(root.val)\\n        self.dfs(root.left, output)\\n        self.dfs(root.right, output)\\n       \\n\\t   \\n# Iterative Solution- Runtime: 12 ms, faster than 97.82%\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def preorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        stack = [root]\\n        \\n        while stack:\\n            temp=stack.pop()\\n            if temp:\\n                output.append(temp.val)\\n                stack.append(temp.right)\\n                stack.append(temp.left)\\n        \\n        return output\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def binaryTreePaths(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[str]\\n        \"\"\"\\n        if root is None:\\n            return []\\n        \\n        result = []\\n        self.dfs(root, \"\", result)\\n        return result\\n\\n    def dfs(self, root, path, result):\\n        if not root.left and not root.right:\\n            result.append(path + str(root.val))\\n        \\n        if root.left:\\n            self.dfs(root.left, path + str(root.val) + \"->\" , result)\\n        if root.right:\\n            self.dfs(root.right, path + str(root.val) + \"->\", result)\\n        \\n```\n```\\n# Recursive : Runtime: 40 ms, faster than 89.79% \\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        self.dfs(root, output)\\n        return output\\n    \\n    def dfs(self, root, output):\\n        if root is None:\\n            return\\n        for child in root.children:\\n            self.dfs(child, output)\\n        \\n        output.append(root.val)\\n \\n \\n # Iterative Solution: Runtime: 48 ms, faster than 62.81%\\n \\n `\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def postorder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[int]\\n        \"\"\"\\n        output =[]\\n        stack = [root]\\n        \\n        while stack:\\n            root = stack.pop()\\n            if root:\\n                output.append(root.val)\\n                stack += root.children\\n                \\n        return output[::-1]`\\n        \\n```\n```\\n# Recursive solution\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        self.dfs(root, output)\\n        return output\\n    \\n    def dfs(self, root, output):\\n        if root is None:\\n            return\\n        self.dfs(root.left, output)\\n        self.dfs(root.right, output) \\n        output.append(root.val)\\n\\t\\t\\n\\t\\t\\n# Iterative solution: Runtime: 12 ms, faster than 98.10%\\n\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def postorderTraversal(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        output = []\\n        stack =[root]\\n        \\n        if not root:\\n            return None\\n        \\n        # iterate only when there is elements inside the stack.\\n        while stack:\\n            \\n            # pop the element from stack and stored it into temp\\n            temp=stack.pop()\\n            \\n            #append the value of temp to output\\n            output.append(temp.val)\\n            \\n            #Now traverse through left node and add the node to stack\\n            if temp.left:\\n                stack.append(temp.left)\\n                \\n            #else traverse through right node and add to stack\\n            if temp.right:\\n                stack.append(temp.right)\\n         \\n        # After iterating through the stack,  print the result in reverse order.  \\n        return output[::-1]\\n    \\n    \\n# Example: Iteration 1 : #stack=[1] - first iteration, temp =1, \\n                #output[1]\\n                #temp.left is Null\\n                #temp.right is [2]\\n                # stack =[2]\\n\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output =[]\\n        self.dfs(root, 0, output)\\n        return output\\n    \\n    def dfs(self, root, level, output):\\n        \\n        if not root:\\n            return\\n        \\n        if len(output) < level+1:\\n            output.append([])\\n            \\n        output[level].append(root.val)    \\n        self.dfs(root.left, level+1, output)\\n        self.dfs(root.right, level+1, output)\\n        \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def levelOrderBottom(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output = []\\n        self.dfs(root, 0, output)\\n        return output[::-1]\\n    \\n    def dfs(self, root, level, output):\\n        if root is None:\\n             return\\n            \\n        if len(output) < level+1:\\n            output.append([])\\n            \\n        output[level].append(root.val)\\n        self.dfs(root.left, level+1, output)\\n        self.dfs(root.right, level+1, output)\\n```\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val=None, children=None):\\n        self.val = val\\n        self.children = children\\n\"\"\"\\n\\nclass Solution(object):\\n    def levelOrder(self, root):\\n        \"\"\"\\n        :type root: Node\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output=[]\\n        self.dfs(root, 0, output)\\n        return output\\n    \\n    def dfs(self, root, level ,output):\\n        if root is None:\\n            return\\n        if len(output)< level+1:\\n            output.append([])\\n        \\n        output[level].append(root.val)\\n        for child in root.children:\\n            self.dfs(child, level+1, output)\\n      \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def zigzagLevelOrder(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        output=[]\\n        self.dfs(root, 0, output)\\n        \\n        for i in range(len(output)):\\n            if i % 2 !=0:\\n                output[i].reverse()\\n            else:\\n                continue\\n        return output\\n    \\n    def dfs(self, root, level, output):\\n        if root is None:\\n            return\\n        \\n        if len(output) < level+1:\\n            output.append([])\\n        \\n        output[level].append(root.val)\\n        self.dfs(root.left, level+1, output)\\n        self.dfs(root.right, level+1, output)\\n        \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def buildTree(self, preorder, inorder):\\n        \"\"\"\\n        :type preorder: List[int]\\n        :type inorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\n        if not inorder or not preorder:\\n            return None\\n        \\n        #pattern is preorder=[root, left, right]\\n        #inorder = [left, root, right],  so find index and value using root.\\n        \\n        root = TreeNode(preorder[0])\\n        \\n        root_index= 0\\n        \\n        #iterate through inorder list and find the list index of the root.\\n        for i in range(len(inorder)):\\n            if inorder[i]== root.val:\\n                root_index = i\\n            else:\\n                continue\\n                \\n        #slice the inorder list into left and right.     \\n        left_inorder = inorder[:root_index]\\n        right_inorder = inorder[root_index+1:]\\n        \\n        #slice the preorder list into left and right.\\n        left_preorder = preorder[1:len(left_inorder)+1]\\n        right_preorder = preorder[len(left_preorder)+1:]\\n        \\n        #append by updating preorder and inorder lists\\n        root.left = self.buildTree(left_preorder, left_inorder)\\n        root.right = self.buildTree(right_preorder, right_inorder)\\n        \\n        return root\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def buildTree(self, inorder, postorder):\\n        \"\"\"\\n        :type inorder: List[int]\\n        :type postorder: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        # PATTERN\\n        # inorder: l, root, right\\n        # postorder: l,r,root\\n        # the last element of postorder is root\\n        \\n        if not inorder or not postorder:\\n            return None\\n        \\n        root_index=0\\n        \\n        # Build the data structure based on root value\\n        root = TreeNode(postorder.pop())\\n        \\n        for i in range(len(inorder)):\\n            if inorder[i]==root.val:\\n                root_index=i\\n            else:\\n                continue\\n        \\n        left_in=inorder[:root_index]\\n        right_in = inorder[root_index+1:]\\n        \\n        root.right = self.buildTree(right_in, postorder)\\n        root.left = self.buildTree(left_in,  postorder)\\n\\n        return root\\n   \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def constructFromPrePost(self, pre, post):\\n        \"\"\"\\n        :type pre: List[int]\\n        :type post: List[int]\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not pre:\\n            return None\\n        \\n        root = TreeNode(post.pop())\\n        \\n        if len(pre) == 1:\\n            return root\\n        \\n        # Find the index of the root value from pre\\n        for i in range(len(pre)):\\n            if pre[i]==post[-1]:\\n                root_index= i\\n            else:\\n                continue\\n        \\n        root.right = self.constructFromPrePost(pre[root_index:], post) \\n        root.left = self.constructFromPrePost(pre[1:root_index],post) \\n        \\n        return root \\n   \\n# Explanation:   root=1, root_index = 0, root.right=(pre(1,2,3,4,5,6,7))  [1, 2,3,4,5,6,7]                           vii\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t# root = 3, root_index= 4, root.right=(pre(3,6,7))  [3,4,5,6,7]                               v\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root=7, root_index=2, root.right= pre(7), now len(pre) == 1, return 7 ---[7]        i\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root =6, root_index=1, root.left= pre(6), now len(pre)==1, return 6 -----[6,7]      ii \\n\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t# root =2, root_index= 1, root.right= pre(2,4,5)   [2,3,4,5,6,7]                               vi \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root = 5, root_index=2, root.right= pre(5)  now len(pre)==1, return 5 ----[5,6,7]   iii\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t# root = 4, root_index=1, root.right= pre(4)  now len(pre)==1, return 4-----[4,5,6,7]  iv\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32178,
                "title": "clean-python-solution",
                "content": "Use recursion. Pass down two parameters: `lessThan` (which means that all nodes in the the current subtree must be smaller than this value) and `largerThan` (all must be larger than it). Compare root of the current subtree with these two values. Then, recursively check the left and right subtree of the current one. Take care of the values passed down.\\n\\n\\n    class Solution(object):\\n        def isValidBST(self, root, lessThan = float('inf'), largerThan = float('-inf')):\\n            if not root:\\n                return True\\n            if root.val <= largerThan or root.val >= lessThan:\\n                return False\\n            return self.isValidBST(root.left, min(lessThan, root.val), largerThan) and \\\\\\n                   self.isValidBST(root.right, lessThan, max(root.val, largerThan))",
                "solutionTags": [],
                "code": "Use recursion. Pass down two parameters: `lessThan` (which means that all nodes in the the current subtree must be smaller than this value) and `largerThan` (all must be larger than it). Compare root of the current subtree with these two values. Then, recursively check the left and right subtree of the current one. Take care of the values passed down.\\n\\n\\n    class Solution(object):\\n        def isValidBST(self, root, lessThan = float('inf'), largerThan = float('-inf')):\\n            if not root:\\n                return True\\n            if root.val <= largerThan or root.val >= lessThan:\\n                return False\\n            return self.isValidBST(root.left, min(lessThan, root.val), largerThan) and \\\\\\n                   self.isValidBST(root.right, lessThan, max(root.val, largerThan))",
                "codeTag": "Java"
            },
            {
                "id": 32138,
                "title": "another-passed-java-solution",
                "content": "    public class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return helper(root, null, null);\\n        }\\n        \\n        boolean helper(TreeNode root, Integer min, Integer max) {\\n            if (root == null)\\n                return true;\\n            \\n            if ((min != null && root.val <= min) || (max != null && root.val >= max))\\n                return false;\\n            \\n            return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n        }\\n    }\\n\\nMy original solution was calling helper(root, Integer.MIN_VALUE, Integer.MAX_VALUE), but it failed when a tree node is either Integer.MIN_VALUE or Integer.MAX_VALUE. The correct solution is don't check with them.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return helper(root, null, null);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 974511,
                "title": "c-the-simplest-o-n-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n   \\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        \\n        inOrder(root);\\n        for (int i=1; i<tree.size(); i++)\\n            if (tree[i] <= tree[i-1])\\n                return false;\\n        return true;\\n    }\\nprivate:\\n    vector<int> tree;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n   \\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        \\n        inOrder(root);\\n        for (int i=1; i<tree.size(); i++)\\n            if (tree[i] <= tree[i-1])\\n                return false;\\n        return true;\\n    }\\nprivate:\\n    vector<int> tree;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32153,
                "title": "python-version-based-on-inorder-traversal",
                "content": "    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param root, a tree node\\n        # @return a boolean\\n        # 7:38\\n        def isValidBST(self, root):\\n            output = []\\n            self.inOrder(root, output)\\n            \\n            for i in range(1, len(output)):\\n                if output[i-1] >= output[i]:\\n                    return False\\n    \\n            return True\\n    \\n        def inOrder(self, root, output):\\n            if root is None:\\n                return\\n            \\n            self.inOrder(root.left, output)\\n            output.append(root.val)\\n            self.inOrder(root.right, output)",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "    # Definition for a  binary tree node\\n    # class TreeNode:\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution:\\n        # @param root, a tree node\\n        # @return a boolean\\n        # 7:38\\n        def isValidBST(self, root):\\n            output = []\\n            self.inOrder(root, output)\\n            \\n            for i in range(1, len(output)):\\n                if output[i-1] >= output[i]:\\n                    return False\\n    \\n            return True\\n    \\n        def inOrder(self, root, output):\\n            if root is None:\\n                return\\n            \\n            self.inOrder(root.left, output)\\n            output.append(root.val)\\n            self.inOrder(root.right, output)",
                "codeTag": "Java"
            },
            {
                "id": 234410,
                "title": "c-recursive-and-iterative",
                "content": "For the recursive solution, we set a lower bound and a upper bound for the tree. When we recurse on the left subtree, the upper bound becomes the value of its root. When we recurse on the right subtree, the lower bound becomes the value of its root.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return valid(root, LONG_MIN, LONG_MAX);\\n    }\\nprivate:\\n    bool valid(TreeNode* root, long min, long max) {\\n        if (!root) {\\n            return true;\\n        }\\n        if (root -> val <= min || root -> val >= max) {\\n            return false;\\n        }\\n        return valid(root -> left, min, root -> val) && valid(root -> right, root -> val, max);\\n    }\\n};\\n```\\n\\nNote we use `LONG_MIN` and `LONG_MAX` to handle edge cases like `[INT_MAX]`.\\n\\nThe iterative idea is to apply iterative inorder traversal to the tree and check whether the current value is always larger than the previous one.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        long pre = LONG_MIN;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            while (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            }\\n            root = todo.top();\\n            todo.pop();\\n            if (root -> val <= pre) {\\n                return false;\\n            }\\n            pre = root -> val;\\n            root = root -> right;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return valid(root, LONG_MIN, LONG_MAX);\\n    }\\nprivate:\\n    bool valid(TreeNode* root, long min, long max) {\\n        if (!root) {\\n            return true;\\n        }\\n        if (root -> val <= min || root -> val >= max) {\\n            return false;\\n        }\\n        return valid(root -> left, min, root -> val) && valid(root -> right, root -> val, max);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        long pre = LONG_MIN;\\n        stack<TreeNode*> todo;\\n        while (root || !todo.empty()) {\\n            while (root) {\\n                todo.push(root);\\n                root = root -> left;\\n            }\\n            root = todo.top();\\n            todo.pop();\\n            if (root -> val <= pre) {\\n                return false;\\n            }\\n            pre = root -> val;\\n            root = root -> right;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974147,
                "title": "python-js-java-go-c-o-n-by-dfs-and-rule-w-hint",
                "content": "O( n ) sol. by divide-and-conquer.\\n\\n[\\u672C\\u984C\\u5C0D\\u61C9\\u7684\\u4E2D\\u6587\\u89E3\\u984C\\u6587\\u7AE0](https://vocus.cc/article/650988e9fd897800019a383f)\\n\\n---\\n\\n**Hint**:\\n\\nThink of BST rule:\\n**Left sub-tree** nodes\\' value **< current** node value\\n**Right sub-tree** nodes\\' value **> current** node value\\n\\n---\\n\\n**Algorithm**:\\n\\nStep_#1:\\nSet upper bound as maximum integer, and lower bound as minimum integer in run-time environment.\\n\\nStep_#2:\\nStart DFS traversal from root node, and check whether each level follow BST rules or not.\\nUpdate lower bound and upper bound before going down to next level.\\n\\nStep_#3:\\nOnce we find the violation, reject and early return False.\\nOtherwise, accept and return True if all tree nodes follow BST rule.\\n\\n---\\n\\nPython\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        \\n        # Use maximal system integer to represent infinity\\n        INF = sys.maxsize\\n        \\n        def helper(node, lower, upper):\\n            \\n            if not node:\\n\\t\\t\\t\\t# empty node or empty tree\\n                return True\\n            \\n            if lower < node.val < upper:\\n\\t\\t\\t\\t# check if all tree nodes follow BST rule\\n                return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\\n            \\n            else:\\n\\t\\t\\t\\t# early reject when we find violation\\n                return False\\n            \\n        # ----------------------------------\\n        \\n        return helper( node=root, lower=-INF, upper=INF )\\n```\\n\\n---\\n\\nJava\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        \\n        return checker( -INF, INF, root);\\n    }\\n    \\n    private boolean checker( long lower, long upper, TreeNode node ){\\n        \\n        if( node == null ){\\n            return true;\\n        }\\n        \\n        if( (lower < node.val) && ( node.val < upper ) ){\\n            return checker(lower, node.val, node.left) && checker(node.val, upper, node.right);\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private long INF = Long.MAX_VALUE;\\n\\n}\\n```\\n\\n</details>\\n\\n---\\n\\nC++\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\t\\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isValidBST(TreeNode* root) {\\n\\n\\t\\t\\treturn validate(root, std::numeric_limits<long>::min(), std::numeric_limits<long>::max() );\\n\\t\\t}\\n\\n\\tprivate:\\n\\t\\tbool validate(TreeNode* node, long lower, long upper){\\n\\n\\t\\t\\tif( node == NULL ){\\n\\n\\t\\t\\t\\t// empty node or empty tree is valid always\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif( (lower < node->val) && (node->val < upper) ){\\n\\n\\t\\t\\t\\t// check if all tree nodes follow BST rule\\n\\t\\t\\t\\treturn validate(node->left, lower, node->val) && validate(node->right, node->val, upper);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\t// early reject when we find violation\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\n\\t\\t}\\n\\t};\\n```\\n\\n</details>\\n\\n,or\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\t\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        \\n        prev = NULL;\\n        \\n        return validate(root );\\n    }\\n    \\nprivate:\\n    TreeNode *prev;\\n    bool validate(TreeNode* node){\\n        \\n        if( node == NULL ){\\n            \\n            // empty node or empty tree is valid always\\n            return true;\\n        }\\n        \\n        \\n        if( !validate(node->left ) ){\\n            return false;\\n        }\\n        \\n        if( prev != NULL && (node->val <= prev -> val) ){\\n            return false;\\n        }\\n        prev = node;\\n        \\n        return validate(node->right);\\n        \\n    }\\n};\\n```\\n\\n</details>\\n\\n\\n\\n---\\nGo\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\t\\n```\\nfunc isValidBST(root *TreeNode) bool {\\n    \\n    return validate( root, math.MinInt, math.MaxInt)\\n}\\n\\nfunc validate(node *TreeNode, lower int, upper int)bool{\\n    \\n    if node == nil{\\n        \\n        //empty node or empty tree is always valid\\n        return true\\n    }\\n    \\n    if( (lower < node.Val) && (node.Val < upper) ){\\n        \\n        // check if all tree nodes follow BST rule\\n        return validate( node.Left, lower, node.Val ) && validate( node.Right, node.Val, upper )\\n    }else{\\n        \\n        // early reject when we find violation\\n        return false\\n    }\\n    \\n}\\n```\\n\\n</details>\\n\\n---\\n\\nJavascript\\n\\n<details>\\n\\t<summary>Click to show source code\\n\\t</summary>\\n\\t\\n```\\nvar isValidBST = function(root) {\\n    \\n    return validate(root, -Infinity, Infinity);\\n};\\n\\n\\nvar validate = function(node, lower,upper){\\n    \\n    if ( node == null ){\\n        \\n        // empty node or empty tree\\n        return true;\\n    }\\n    \\n    if( (lower < node.val) && ( node.val < upper ) ){\\n        \\n        // check if all tree nodes follow BST rule\\n        return validate( node.left, lower, node.val) && validate( node.right, node.val, upper);\\n    }else{\\n        \\n        // early reject when we find violation\\n        return false;\\n    }\\n    \\n}\\n```\\n\\n</details>\\n\\n---\\n\\nShare anotehr implementation with well-ordered property of BST\\'s inorder traversal\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def checker(node):\\n            \\n            if not node:\\n\\t\\t\\t\\t## Base case\\n                # empty node or empty tree\\n                yield True\\n                \\n            else:\\n                ## General cases:\\n\\n                yield from checker(node.left)\\n\\n                if checker.prev and (checker.prev.val >= node.val):\\n                    # previous node should be smaller then current node\\n                    # find violation\\n                    yield False\\n\\n                checker.prev = node\\n\\n                yield from checker(node.right)\\n                \\n            return\\n        # ---------------------------------------\\n        \\n        # use the property that inorder traversla of BST outputs sorted ascending sequence naturally\\n        checker.prev = None\\n        return all( checker(root) )\\n```\\n\\n---\\n\\nRelative leetcode challenge\\n\\n[Leetcode #99 Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/)\\n\\n[Leetcode #700 Search in a Binary Search Tree](https://leetcode.com/problems/search-in-a-binary-search-tree/)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        \\n        # Use maximal system integer to represent infinity\\n        INF = sys.maxsize\\n        \\n        def helper(node, lower, upper):\\n            \\n            if not node:\\n\\t\\t\\t\\t# empty node or empty tree\\n                return True\\n            \\n            if lower < node.val < upper:\\n\\t\\t\\t\\t# check if all tree nodes follow BST rule\\n                return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\\n            \\n            else:\\n\\t\\t\\t\\t# early reject when we find violation\\n                return False\\n            \\n        # ----------------------------------\\n        \\n        return helper( node=root, lower=-INF, upper=INF )\\n```\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        \\n        return checker( -INF, INF, root);\\n    }\\n    \\n    private boolean checker( long lower, long upper, TreeNode node ){\\n        \\n        if( node == null ){\\n            return true;\\n        }\\n        \\n        if( (lower < node.val) && ( node.val < upper ) ){\\n            return checker(lower, node.val, node.left) && checker(node.val, upper, node.right);\\n        }\\n        \\n        return false;\\n    }\\n    \\n    private long INF = Long.MAX_VALUE;\\n\\n}\\n```\n```\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isValidBST(TreeNode* root) {\\n\\n\\t\\t\\treturn validate(root, std::numeric_limits<long>::min(), std::numeric_limits<long>::max() );\\n\\t\\t}\\n\\n\\tprivate:\\n\\t\\tbool validate(TreeNode* node, long lower, long upper){\\n\\n\\t\\t\\tif( node == NULL ){\\n\\n\\t\\t\\t\\t// empty node or empty tree is valid always\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif( (lower < node->val) && (node->val < upper) ){\\n\\n\\t\\t\\t\\t// check if all tree nodes follow BST rule\\n\\t\\t\\t\\treturn validate(node->left, lower, node->val) && validate(node->right, node->val, upper);\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\t// early reject when we find violation\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\n\\n\\t\\t}\\n\\t};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        \\n        prev = NULL;\\n        \\n        return validate(root );\\n    }\\n    \\nprivate:\\n    TreeNode *prev;\\n    bool validate(TreeNode* node){\\n        \\n        if( node == NULL ){\\n            \\n            // empty node or empty tree is valid always\\n            return true;\\n        }\\n        \\n        \\n        if( !validate(node->left ) ){\\n            return false;\\n        }\\n        \\n        if( prev != NULL && (node->val <= prev -> val) ){\\n            return false;\\n        }\\n        prev = node;\\n        \\n        return validate(node->right);\\n        \\n    }\\n};\\n```\n```\\nfunc isValidBST(root *TreeNode) bool {\\n    \\n    return validate( root, math.MinInt, math.MaxInt)\\n}\\n\\nfunc validate(node *TreeNode, lower int, upper int)bool{\\n    \\n    if node == nil{\\n        \\n        //empty node or empty tree is always valid\\n        return true\\n    }\\n    \\n    if( (lower < node.Val) && (node.Val < upper) ){\\n        \\n        // check if all tree nodes follow BST rule\\n        return validate( node.Left, lower, node.Val ) && validate( node.Right, node.Val, upper )\\n    }else{\\n        \\n        // early reject when we find violation\\n        return false\\n    }\\n    \\n}\\n```\n```\\nvar isValidBST = function(root) {\\n    \\n    return validate(root, -Infinity, Infinity);\\n};\\n\\n\\nvar validate = function(node, lower,upper){\\n    \\n    if ( node == null ){\\n        \\n        // empty node or empty tree\\n        return true;\\n    }\\n    \\n    if( (lower < node.val) && ( node.val < upper ) ){\\n        \\n        // check if all tree nodes follow BST rule\\n        return validate( node.left, lower, node.val) && validate( node.right, node.val, upper);\\n    }else{\\n        \\n        // early reject when we find violation\\n        return false;\\n    }\\n    \\n}\\n```\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def checker(node):\\n            \\n            if not node:\\n\\t\\t\\t\\t## Base case\\n                # empty node or empty tree\\n                yield True\\n                \\n            else:\\n                ## General cases:\\n\\n                yield from checker(node.left)\\n\\n                if checker.prev and (checker.prev.val >= node.val):\\n                    # previous node should be smaller then current node\\n                    # find violation\\n                    yield False\\n\\n                checker.prev = node\\n\\n                yield from checker(node.right)\\n                \\n            return\\n        # ---------------------------------------\\n        \\n        # use the property that inorder traversla of BST outputs sorted ascending sequence naturally\\n        checker.prev = None\\n        return all( checker(root) )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32101,
                "title": "my-java-inorder-iteration-solution",
                "content": "the idea is to do a inorder Traversal and keep the value of the\\n\\n    public boolean isValidBST (TreeNode root){\\n    \\t\\t   Stack<TreeNode> stack = new Stack<TreeNode> ();\\n    \\t\\t   TreeNode cur = root ;\\n    \\t\\t   TreeNode pre = null ;\\t\\t   \\n    \\t\\t   while (!stack.isEmpty() || cur != null) {\\t\\t\\t   \\n    \\t\\t\\t   if (cur != null) {\\n    \\t\\t\\t\\t   stack.push(cur);\\n    \\t\\t\\t\\t   cur = cur.left ;\\n    \\t\\t\\t   } else {\\t\\t\\t\\t   \\n    \\t\\t\\t\\t   TreeNode p = stack.pop() ;\\n    \\t\\t\\t\\t   if (pre != null && p.val <= pre.val) {\\t\\t\\t\\t\\t   \\n    \\t\\t\\t\\t\\t   return false ;\\n    \\t\\t\\t\\t   }\\t\\t\\t\\t   \\n    \\t\\t\\t\\t   pre = p ;\\t\\t\\t\\t\\t   \\n    \\t\\t\\t\\t   cur = p.right ;\\n    \\t\\t\\t   }\\n    \\t\\t   }\\n    \\t\\t   return true ; \\n    \\t   }",
                "solutionTags": [],
                "code": "the idea is to do a inorder Traversal and keep the value of the\\n\\n    public boolean isValidBST (TreeNode root){\\n    \\t\\t   Stack<TreeNode> stack = new Stack<TreeNode> ();\\n    \\t\\t   TreeNode cur = root ;\\n    \\t\\t   TreeNode pre = null ;\\t\\t   \\n    \\t\\t   while (!stack.isEmpty() || cur != null) {\\t\\t\\t   \\n    \\t\\t\\t   if (cur != null) {\\n    \\t\\t\\t\\t   stack.push(cur);\\n    \\t\\t\\t\\t   cur = cur.left ;\\n    \\t\\t\\t   } else {\\t\\t\\t\\t   \\n    \\t\\t\\t\\t   TreeNode p = stack.pop() ;\\n    \\t\\t\\t\\t   if (pre != null && p.val <= pre.val) {\\t\\t\\t\\t\\t   \\n    \\t\\t\\t\\t\\t   return false ;\\n    \\t\\t\\t\\t   }\\t\\t\\t\\t   \\n    \\t\\t\\t\\t   pre = p ;\\t\\t\\t\\t\\t   \\n    \\t\\t\\t\\t   cur = p.right ;\\n    \\t\\t\\t   }\\n    \\t\\t   }\\n    \\t\\t   return true ; \\n    \\t   }",
                "codeTag": "Unknown"
            },
            {
                "id": 146601,
                "title": "python3-100-using-easy-recursion",
                "content": "If you just want a solution scroll down, otherwise here\\'s an explanation.\\n\\nLet\\'s start with a simple definition of the nodes of a binary search tree!\\nA parent node is greater than its left child but smaller than its right.\\n```\\n    2\\n   / \\\\\\n  1   3 // valid tree!\\n```\\n\\n```\\n    5\\n   / \\\\\\n  1   4  // not valid here!\\n     / \\\\\\n    3   6\\n```\\n\\nOne solution would be to check every parent as we work down the tree but it creates a lot of complicated logic. So why don\\'t we check every child on the way up! All we have to do is keep track of the mininum and maximum valid values on the way down.\\n\\nTo prevent some extra checks let\\'s start with -infinity and infinity.\\n```\\ndef isValidBST(self, root):\\n    return check_bst(root, float(\"-inf\"), float(\"inf\"))\\n```\\n\\nSo let\\'s walk it out!\\n```\\n    2 \\n   / \\\\\\n  1   3 \\n\\t\\n1 // -inf < 1 < 2, so it\\'s still valid\\n3 //  2 < 3 < inf, so it\\'s still a valid tree\\n2 // -inf < 2 < inf, so it\\'s a valid tree!\\n```\\n\\nAnd what about an invalid tree?\\n\\n```\\n    5 \\n   / \\\\\\n  1   4 \\n\\t\\n1 // -inf < 1 < 5, so it\\'s still a valid tree\\n4 // 5 > 4 < inf, this tree is not a valid binary tree!\\t\\n```\\n\\nSo here\\'s one way we could implement this logic!\\n\\n```\\ndef isValidBST(self, root):\\n    return check_bst(root, float(\"-inf\"), float(\"inf\"))\\n\\t\\ndef check_bst(self, node, left, right):\\n    if not node:\\n        return True\\n\\n    if not left < node.val < right:\\n        return False\\n\\n    return (check_bst(node.left, left, node.val)\\n            and check_bst(node.right, node.val, right))\\n```",
                "solutionTags": [],
                "code": "```\\n    2\\n   / \\\\\\n  1   3 // valid tree!\\n```\n```\\n    5\\n   / \\\\\\n  1   4  // not valid here!\\n     / \\\\\\n    3   6\\n```\n```\\ndef isValidBST(self, root):\\n    return check_bst(root, float(\"-inf\"), float(\"inf\"))\\n```\n```\\n    2 \\n   / \\\\\\n  1   3 \\n\\t\\n1 // -inf < 1 < 2, so it\\'s still valid\\n3 //  2 < 3 < inf, so it\\'s still a valid tree\\n2 // -inf < 2 < inf, so it\\'s a valid tree!\\n```\n```\\n    5 \\n   / \\\\\\n  1   4 \\n\\t\\n1 // -inf < 1 < 5, so it\\'s still a valid tree\\n4 // 5 > 4 < inf, this tree is not a valid binary tree!\\t\\n```\n```\\ndef isValidBST(self, root):\\n    return check_bst(root, float(\"-inf\"), float(\"inf\"))\\n\\t\\ndef check_bst(self, node, left, right):\\n    if not node:\\n        return True\\n\\n    if not left < node.val < right:\\n        return False\\n\\n    return (check_bst(node.left, left, node.val)\\n            and check_bst(node.right, node.val, right))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2409071,
                "title": "python-one-liner-96-6-with-detailed-explantion-recursion-simple",
                "content": "There are two steps:\\n1. set a range (at first we set it to (-infinity, infinity)\\n2. see if every node is in their own range\\n![image](https://assets.leetcode.com/users/images/864f8660-dcc9-4ae5-82a6-4edbf8190755_1660181425.0985472.png)\\nHere\\'s the one line code:\\n```\\nclass Solution:\\n    def isValidBST(self, node: Optional[TreeNode],low=-inf, high=inf) -> bool:\\n            return (not node) or ((low < node.val < high) and self.isValidBST(node.left, low, node.val)  and self.isValidBST(node.right, node.val, high))\\n```\\n\\nHere\\'s the code for better understand:\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def helper(node, low, high):\\n            if not node:\\n                return True\\n            if not (low < node.val < high):\\n                return False\\n            return helper(node.left, low, node.val) and helper(node.right, node.val, high)\\n        \\n        return helper(root, -inf, inf)\\n```\\n**Please UPVOTE if you LIKE!!**\\n![image](https://assets.leetcode.com/users/images/6be7315b-0f00-463e-b813-977d576b9e0b_1660180800.7504048.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, node: Optional[TreeNode],low=-inf, high=inf) -> bool:\\n            return (not node) or ((low < node.val < high) and self.isValidBST(node.left, low, node.val)  and self.isValidBST(node.right, node.val, high))\\n```\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def helper(node, low, high):\\n            if not node:\\n                return True\\n            if not (low < node.val < high):\\n                return False\\n            return helper(node.left, low, node.val) and helper(node.right, node.val, high)\\n        \\n        return helper(root, -inf, inf)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32193,
                "title": "1-ms-java-solution-using-recursion",
                "content": "    public class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValid(root, null, null);\\n    }\\n    \\n    public boolean isValid(TreeNode root, Integer min, Integer max) {\\n        if(root == null) return true;\\n        if(min != null && root.val <= min) return false;\\n        if(max != null && root.val >= max) return false;\\n        \\n        return isValid(root.left, min, root.val) && isValid(root.right, root.val, max);\\n    }}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValid(root, null, null);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 258511,
                "title": "easy-java-0ms-solution",
                "content": "The trick is to do an inorder traversal of the tree and check that the value of each node visited is greater than the value of the previous node.\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    TreeNode prev = null;\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null) {\\n            return true;\\n        }\\n        \\n        if(isValidBST(root.left) && (prev == null || root.val > prev.val)) {\\n            prev = root;\\n            return isValidBST(root.right);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    TreeNode prev = null;\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null) {\\n            return true;\\n        }\\n        \\n        if(isValidBST(root.left) && (prev == null || root.val > prev.val)) {\\n            prev = root;\\n            return isValidBST(root.right);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 959657,
                "title": "c-recursive-solution-passing-all-test-cases",
                "content": "### Keep in Mind\\n * Passing `NULL` to `int` will cast `NULL` to `0` in integer. \\n * So, It will give wrong result for [0, null, -1].\\n * If someone will pass `INT_MIN` as default value, then It\\'ll fail for case - [-2147483648] and vice-versa.\\n *  That\\'s why pointers are used here.\\n *  One can use **TreeNode** addresses as pointers.\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return isValid(root, NULL, NULL);\\n    }\\n    \\n    bool isValid(TreeNode* root, int* lower, int* upper){\\n        if(!root)\\n            return true;\\n\\n        if(upper && root -> val >= *upper)\\n            return false;\\n        if(lower && root -> val <= *lower)\\n            return false;\\n        \\n        return isValid(root -> left, lower, &(root -> val)) && isValid(root -> right, &(root -> val), upper);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return isValid(root, NULL, NULL);\\n    }\\n    \\n    bool isValid(TreeNode* root, int* lower, int* upper){\\n        if(!root)\\n            return true;\\n\\n        if(upper && root -> val >= *upper)\\n            return false;\\n        if(lower && root -> val <= *lower)\\n            return false;\\n        \\n        return isValid(root -> left, lower, &(root -> val)) && isValid(root -> right, &(root -> val), upper);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410354,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n***Watch this video for the better explanation of the code.***\\n**Also you can SUBSCRIBE \\uD83E\\uDC83 this channel for the daily leetcode challange solution.**\\nhttps://www.youtube.com/watch?v=geBeUvcMMwo\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> & ans){\\n        if(root==NULL  ) return;\\n        helper(root->left, ans);\\n        ans.push_back(root->val);\\n         helper(root->right, ans);\\n     \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n       for(int i=0; i<ans.size()-1; i++){\\n           if( ans[i]>= ans[i+1] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**PYTHON**\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       \\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root,long minval,long maxval){\\n        if(root == null) return true;\\n        if(root.val >= maxval || root.val <= minval) return false;\\n        \\n        return isValidBST(root.left,minval,root.val) && isValidBST(root.right,root.val,maxval);\\n    }\\n}\\n```\\n**Please UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> & ans){\\n        if(root==NULL  ) return;\\n        helper(root->left, ans);\\n        ans.push_back(root->val);\\n         helper(root->right, ans);\\n     \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n       for(int i=0; i<ans.size()-1; i++){\\n           if( ans[i]>= ans[i+1] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       \\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root,long minval,long maxval){\\n        if(root == null) return true;\\n        if(root.val >= maxval || root.val <= minval) return false;\\n        \\n        return isValidBST(root.left,minval,root.val) && isValidBST(root.right,root.val,maxval);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529937,
                "title": "javascript-97-faster-simple-recursion",
                "content": "```\\nvar isValidBST = function(root, min=null, max=null) {\\n    if (!root) return true;\\n    if (min && root.val <= min.val) return false;\\n    if (max && root.val >= max.val) return false;\\n    return isValidBST(root.left, min, root) && isValidBST(root.right, root, max);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar isValidBST = function(root, min=null, max=null) {\\n    if (!root) return true;\\n    if (min && root.val <= min.val) return false;\\n    if (max && root.val >= max.val) return false;\\n    return isValidBST(root.left, min, root) && isValidBST(root.right, root, max);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1282793,
                "title": "faster-than-100-cpp-solution-don-t-repeat-my-mistake-int-min-int-max",
                "content": "You might be doing the same mistake that I did, using **INT_MAX**, **INT_MIN**.\\nMy first solution : \\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return fun(root, INT_MAX, INT_MIN);\\n    }\\n    \\n    bool fun(TreeNode* root, int max, int min){\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val > min && root->val < max){\\n\\t\\t\\t//checking recursively the left and right-subtree, are they BST??\\n\\t\\t\\t// if both subtree are BST, then Parent tree is also BST\\n            return fun(root->left, root->val, min) && fun(root->right, max, root->val);\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nBut I did a silly mistake here, The constraint given is from -2^31 to 2^31-1, and INT_MAX = 2^31-1 and INT_MIN = -2^31.\\nIn this case, it will fail.\\n\\nBetter approach is, that will never fail at any constartint is using the reference for minNode, and maxNode. Actually this is the basic concept here to be used, first one is dependent on the constraint.\\nFollowing this approach, we came up to this solution:\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return fun(root, NULL, NULL);\\n    }\\n    \\n    bool fun(TreeNode* root, TreeNode* max, TreeNode* min){\\n        if(root==NULL){\\n            return true;\\n        }\\n\\t\\t// Using the same above logic\\n\\t\\t//Just check if max or min-node is NULL, then follow it as true\\n        if((min==NULL || root->val > min->val) && (max==NULL || root->val < max->val)){\\n            return fun(root->left, root, min) && fun(root->right, max, root);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return fun(root, INT_MAX, INT_MIN);\\n    }\\n    \\n    bool fun(TreeNode* root, int max, int min){\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val > min && root->val < max){\\n\\t\\t\\t//checking recursively the left and right-subtree, are they BST??\\n\\t\\t\\t// if both subtree are BST, then Parent tree is also BST\\n            return fun(root->left, root->val, min) && fun(root->right, max, root->val);\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return fun(root, NULL, NULL);\\n    }\\n    \\n    bool fun(TreeNode* root, TreeNode* max, TreeNode* min){\\n        if(root==NULL){\\n            return true;\\n        }\\n\\t\\t// Using the same above logic\\n\\t\\t//Just check if max or min-node is NULL, then follow it as true\\n        if((min==NULL || root->val > min->val) && (max==NULL || root->val < max->val)){\\n            return fun(root->left, root, min) && fun(root->right, max, root);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724888,
                "title": "java-dfs-recursion-clean-0-ms",
                "content": "### **Please Upvote** :D\\n``` java []\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    public boolean isValid(TreeNode root, long min, long max) {\\n        if (root == null) return true;\\n        if (root.val >= max || root.val <= min) {\\n            return false;\\n        }\\n        return isValid(root.left, min, root.val) && isValid(root.right, root.val, max);\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "``` java []\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    public boolean isValid(TreeNode root, long min, long max) {\\n        if (root == null) return true;\\n        if (root.val >= max || root.val <= min) {\\n            return false;\\n        }\\n        return isValid(root.left, min, root.val) && isValid(root.right, root.val, max);\\n    }\\n}\\n\\n// TC: O(n), SC: O(h)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974185,
                "title": "python-simple-dfs-explained",
                "content": "We need to check that some property holds for every node of our tree, so as usual any recursion method should work here. Let us use function `dfs(node, low, high)`, where:\\n1. `node` is node we are currently in\\n2. `low` and `high` are bounds we expect to value of this node be in.\\n\\nNow, let us go to the main algorithm:\\n1. If we have `None` node, we are happy: empty tree is BST\\n2. Next we check if `low < node.val < high` and if it is not true, we can immedietly return `False`.\\n3. Finally, we check conditions for left children: its value should be in `(low, node.val)` and for right children: `(node.val, high)`. If one of this `dfs` return False, we need to return False.\\n\\n**Complexity**: time complexity is `O(n)` to traverse every node of our tree. Space complexity is `O(h)`, where `h` is height of our tree.\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root):\\n        def dfs(node, low, high):\\n            if not node: return True\\n            if not low < node.val < high: return False\\n            return dfs(node.left, low, node.val) and dfs(node.right, node.val, high)\\n        \\n        return dfs(root, -float(\"inf\"), float(\"inf\"))\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root):\\n        def dfs(node, low, high):\\n            if not node: return True\\n            if not low < node.val < high: return False\\n            return dfs(node.left, low, node.val) and dfs(node.right, node.val, high)\\n        \\n        return dfs(root, -float(\"inf\"), float(\"inf\"))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32117,
                "title": "my-javascript-solution",
                "content": "This is a very classic BST problem, we just need to scan every single node in the tree and see if the node's value matches the BST rules, that is all the values in node's left subtree are less than the value in node, and all the values in node's right subtree are greater than the value in node, if we found a node that doesn't satisfy the rules, simply return false from the recursion.\\n```\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isValidBST = function(root) {\\n    if (!root) {\\n        return true; // Sanity check for passing test case '[]'\\n    }\\n\\n    function helper(root, min, max) {\\n        if (!root) {\\n            return true; // We hit the end of the path\\n        }\\n        \\n        if ((min !== null && root.val <= min) || (max !== null && root.val >= max)) {\\n            return false; // current node's val doesn't satisfy the BST rules\\n        }\\n        \\n        // Continue to scan left and right\\n        return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n    }\\n    \\n    return helper(root, null, null);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar isValidBST = function(root) {\\n    if (!root) {\\n        return true; // Sanity check for passing test case '[]'\\n    }\\n\\n    function helper(root, min, max) {\\n        if (!root) {\\n            return true; // We hit the end of the path\\n        }\\n        \\n        if ((min !== null && root.val <= min) || (max !== null && root.val >= max)) {\\n            return false; // current node's val doesn't satisfy the BST rules\\n        }\\n        \\n        // Continue to scan left and right\\n        return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n    }\\n    \\n    return helper(root, null, null);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32347,
                "title": "c-easy-to-read-in-order-traversal-solution",
                "content": "Ensure that every next node of in-order traversal is larger than previous one. Using boolean flag to start with the left most node.\\n\\n    class Solution {\\n        bool first = true;\\n        int prev = 0;\\n    public:\\n        bool isValidBST(TreeNode *root) {\\n            if(root == NULL) return true;\\n            \\n            return (\\n                isValidBST(root->left)\\n                && check(root->val)\\n                && isValidBST(root->right));\\n        }\\n        \\n        bool check(int val)\\n        {\\n            if(first)\\n            {\\n                first = false;\\n                prev = val;\\n                return true;\\n            }\\n            \\n            if(prev >= val) return false;\\n            \\n            prev = val;\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n        bool first = true;\\n        int prev = 0;\\n    public:\\n        bool isValidBST(TreeNode *root) {\\n            if(root == NULL) return true;\\n            \\n            return (\\n                isValidBST(root->left)\\n                && check(root->val)\\n                && isValidBST(root->right));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3053617,
                "title": "c-inorder-ascending-order",
                "content": "# Intuition\\nThe inorder traversal of BST is in ascending order.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStore the elements of inorder traversal of BST in an array. If it doesn\\'t follow strictly increasing order, return false.\\nReturn true otherwise. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<int> numbers;//declare it globally, it contains the inorder traversal of BST\\n\\nvoid inorderpush(TreeNode* root){\\n    if(root==nullptr){\\n        return;\\n    }\\n    inorderpush(root->left);\\n    numbers.push_back(root->val);//inserts the element in array\\n    inorderpush(root->right);\\n}\\n\\nbool isValidBST(TreeNode* root) {\\n    inorderpush(root);\\n\\n    for(int i=0;i<numbers.size()-1;i++){\\n        if(numbers[i+1]<=numbers[i]){\\n            return false;//if array is not strictly increasing\\n        }\\n    }\\n    return true; //if array is strictly increasing   \\n    }\\n};\\n```\\n**Please upvote if it helps. Happy Coding!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<int> numbers;//declare it globally, it contains the inorder traversal of BST\\n\\nvoid inorderpush(TreeNode* root){\\n    if(root==nullptr){\\n        return;\\n    }\\n    inorderpush(root->left);\\n    numbers.push_back(root->val);//inserts the element in array\\n    inorderpush(root->right);\\n}\\n\\nbool isValidBST(TreeNode* root) {\\n    inorderpush(root);\\n\\n    for(int i=0;i<numbers.size()-1;i++){\\n        if(numbers[i+1]<=numbers[i]){\\n            return false;//if array is not strictly increasing\\n        }\\n    }\\n    return true; //if array is strictly increasing   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642757,
                "title": "2-solutions-easy-to-understand-simple-recursive-iterative-python-solution",
                "content": "```\\n    def iterative(self, root):\\n        if not root: return True\\n        stack = [(root, -float(\\'inf\\'), float(\\'inf\\'))]\\n        while len(stack):\\n            node, left, right = stack.pop()\\n            if node.val <= left or node.val >= right: return False\\n            if node.left: stack.append((node.left, left, node.val))\\n            if node.right: stack.append((node.right, node.val, right))\\n        return True\\n        \\n        \\n        \\n        \\n    def recursive(self, root): \\n        def rec(node, left, right):\\n            if node:\\n                if node.val <= left or node.val >= right: return False\\n                return rec(node.left, left, node.val) and rec(node.right, node.val, right)\\n            return True\\n        return rec(root, -float(\\'inf\\'), float(\\'inf\\') )\\n        \\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    def iterative(self, root):\\n        if not root: return True\\n        stack = [(root, -float(\\'inf\\'), float(\\'inf\\'))]\\n        while len(stack):\\n            node, left, right = stack.pop()\\n            if node.val <= left or node.val >= right: return False\\n            if node.left: stack.append((node.left, left, node.val))\\n            if node.right: stack.append((node.right, node.val, right))\\n        return True\\n        \\n        \\n        \\n        \\n    def recursive(self, root): \\n        def rec(node, left, right):\\n            if node:\\n                if node.val <= left or node.val >= right: return False\\n                return rec(node.left, left, node.val) and rec(node.right, node.val, right)\\n            return True\\n        return rec(root, -float(\\'inf\\'), float(\\'inf\\') )\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1278481,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    boolean isBST(TreeNode root,long min,long max)\\n    {\\n        if(root == null)\\n            return true;\\n        \\n        //System.out.println(root.val + \" \"+min + \" \"+max);\\n        if(root.val <= min || root.val >= max)\\n            return false;\\n        \\n        boolean left = isBST(root.left,min,root.val);\\n        boolean right = isBST(root.right,root.val,max);\\n        return left && right;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    boolean isBST(TreeNode root,long min,long max)\\n    {\\n        if(root == null)\\n            return true;\\n        \\n        //System.out.println(root.val + \" \"+min + \" \"+max);\\n        if(root.val <= min || root.val >= max)\\n            return false;\\n        \\n        boolean left = isBST(root.left,min,root.val);\\n        boolean right = isBST(root.right,root.val,max);\\n        return left && right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114459,
                "title": "3-python-solutions-clamping-window-in-order-traversal",
                "content": "*Solution 1:\\n\\n```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        return self.isValidNode(root,float('-inf'), float('inf'))\\n    \\n    def isValidNode(self, root, l, r):\\n        if not root:\\n            return True\\n        return l<root.val<r and self.isValidNode(root.left, l, root.val) and self.isValidNode(root.right, root.val, r)\\n```\\n\\n\\n\\n\\n*Solution 2:\\n\\n```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        order = []\\n        self.inorderT(root, order)\\n        for i in range(1, len(order)):\\n            if order[i] <= order[i-1]:\\n                return False\\n        return True\\n    \\n    def inorderT(self, root, order):\\n        if root is None:\\n            return\\n        self.inorderT(root.left, order)\\n        order.append(root.val)\\n        self.inorderT(root.right, order)\\n```\\n\\n\\n\\n*Solution 3:\\n\\n```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        order = []\\n        stack = []\\n        cur = root\\n        while stack or cur:\\n            while cur:\\n                stack.append(cur)\\n                cur = cur.left\\n            cur = stack.pop()\\n            order.append(cur.val)\\n            cur = cur.right\\n        print(order)\\n        \\n        for i in range(1, len(order)):\\n            if order[i] <= order[i-1]:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return True\\n        return self.isValidNode(root,float('-inf'), float('inf'))\\n    \\n    def isValidNode(self, root, l, r):\\n        if not root:\\n            return True\\n        return l<root.val<r and self.isValidNode(root.left, l, root.val) and self.isValidNode(root.right, root.val, r)\\n```\n```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        order = []\\n        self.inorderT(root, order)\\n        for i in range(1, len(order)):\\n            if order[i] <= order[i-1]:\\n                return False\\n        return True\\n    \\n    def inorderT(self, root, order):\\n        if root is None:\\n            return\\n        self.inorderT(root.left, order)\\n        order.append(root.val)\\n        self.inorderT(root.right, order)\\n```\n```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        order = []\\n        stack = []\\n        cur = root\\n        while stack or cur:\\n            while cur:\\n                stack.append(cur)\\n                cur = cur.left\\n            cur = stack.pop()\\n            order.append(cur.val)\\n            cur = cur.right\\n        print(order)\\n        \\n        for i in range(1, len(order)):\\n            if order[i] <= order[i-1]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440997,
                "title": "easy-to-understand-concise-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodes;\\n    void inorder(TreeNode* root) {\\n        if (root->left) inorder(root->left);\\n        nodes.push_back(root->val);\\n        if (root->right) inorder(root->right);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        inorder(root);\\n        for (int i = 0; i < nodes.size() - 1; i++) {\\n            if (nodes[i] >= nodes[i+1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodes;\\n    void inorder(TreeNode* root) {\\n        if (root->left) inorder(root->left);\\n        nodes.push_back(root->val);\\n        if (root->right) inorder(root->right);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        inorder(root);\\n        for (int i = 0; i < nodes.size() - 1; i++) {\\n            if (nodes[i] >= nodes[i+1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621513,
                "title": "javascript-intuitive-solution-using-inorder-traversal",
                "content": "```javascript\\nvar isValidBST = function(root) {\\n    \\n    function inOrder(node) {\\n        if(!node) return [];\\n        return [...inOrder(node.left), node.val, ...inOrder(node.right)]\\n    }\\n    \\n    const sortedArr = inOrder(root);\\n    \\n    for(let i = 0; i < sortedArr.length; i++) {\\n        if(sortedArr[i+1] <= sortedArr[i]) return false;\\n    }\\n    return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar isValidBST = function(root) {\\n    \\n    function inOrder(node) {\\n        if(!node) return [];\\n        return [...inOrder(node.left), node.val, ...inOrder(node.right)]\\n    }\\n    \\n    const sortedArr = inOrder(root);\\n    \\n    for(let i = 0; i < sortedArr.length; i++) {\\n        if(sortedArr[i+1] <= sortedArr[i]) return false;\\n    }\\n    return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2409583,
                "title": "python-easily-understood-faster-than-96-recursion",
                "content": "Method: `recursion`\\n```\\ndef isValidBST(self, root: Optional[TreeNode]) -> bool:\\n\\tdef check_validate(root, lower, upper):\\n\\t\\tif not root:\\n\\t\\t\\treturn True\\n\\t\\tif lower >= root.val or upper <= root.val:\\n\\t\\t\\treturn False\\n\\t\\telse:\\n\\t\\t\\treturn check_validate(root.left, lower, root.val) and check_validate(\\n\\t\\t\\t\\troot.right, root.val, upper\\n\\t\\t\\t)\\n\\n\\treturn check_validate(root, -math.inf, math.inf)\\n```\\n\\n**Time Complexity**: `O(n)`\\n**Space Complexity**: `O(n)`\\n<br/>\\nUsing `in-order`, much more easy-understanding\\n```\\nlast = -math.inf\\nended = False\\ndef isValidBST(self, root: Optional[TreeNode]) -> bool:\\n\\tdef check_validate(cur):\\n\\t\\tif self.ended:\\n\\t\\t\\treturn \\n\\t\\tif cur.left:\\n\\t\\t\\tcheck_validate(cur.left)\\n\\n\\t\\tif not(cur.val > self.last):\\n\\t\\t\\tself.ended = True\\n\\t\\t\\treturn\\n\\n\\t\\tself.last = cur.val\\n\\t\\tif cur.right:\\n\\t\\t\\tcheck_validate(cur.right)\\n\\tcheck_validate(root)\\n\\treturn not self.ended\\n```\\n\\n**Time Complexity**: `O(n)`\\n**Space Complexity**: `O(n)`\\n<br/>\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\ndef isValidBST(self, root: Optional[TreeNode]) -> bool:\\n\\tdef check_validate(root, lower, upper):\\n\\t\\tif not root:\\n\\t\\t\\treturn True\\n\\t\\tif lower >= root.val or upper <= root.val:\\n\\t\\t\\treturn False\\n\\t\\telse:\\n\\t\\t\\treturn check_validate(root.left, lower, root.val) and check_validate(\\n\\t\\t\\t\\troot.right, root.val, upper\\n\\t\\t\\t)\\n\\n\\treturn check_validate(root, -math.inf, math.inf)\\n```\n```\\nlast = -math.inf\\nended = False\\ndef isValidBST(self, root: Optional[TreeNode]) -> bool:\\n\\tdef check_validate(cur):\\n\\t\\tif self.ended:\\n\\t\\t\\treturn \\n\\t\\tif cur.left:\\n\\t\\t\\tcheck_validate(cur.left)\\n\\n\\t\\tif not(cur.val > self.last):\\n\\t\\t\\tself.ended = True\\n\\t\\t\\treturn\\n\\n\\t\\tself.last = cur.val\\n\\t\\tif cur.right:\\n\\t\\t\\tcheck_validate(cur.right)\\n\\tcheck_validate(root)\\n\\treturn not self.ended\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1047111,
                "title": "simple-js-dfs",
                "content": "```\\nvar isValidBST = function(root, min = -Infinity, max = Infinity) {\\n    if(root === null)\\n        return true;\\n    if(root.val <= min || root.val >= max)\\n        return false;\\n    return isValidBST(root.right, root.val, max) && isValidBST(root.left, min, root.val)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValidBST = function(root, min = -Infinity, max = Infinity) {\\n    if(root === null)\\n        return true;\\n    if(root.val <= min || root.val >= max)\\n        return false;\\n    return isValidBST(root.right, root.val, max) && isValidBST(root.left, min, root.val)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 970452,
                "title": "c-dfs-recursion-time-o-n-space-o-n",
                "content": "**DFS Recusive Approach**\\nThe reason why we update min and max at every step is because:\\n1. For every left node, the max value it can have it less than its parent\\'s and the min value it can have is the left most node for that particular subtree.\\n2. For every right node, the max value it can have it less than the right most node of that particular subtree  and the min value it can have is the root value.\\n\\nTime Complexity: O (n)\\nSpace Complexity: O (n) (For the recursion Stack)\\n```\\nclass Solution {\\npublic:\\n    bool isValidBSTHelper (TreeNode* currentNode, TreeNode* min, TreeNode* max) {\\n        if (currentNode==NULL) return true;               \\n        if (min && currentNode->val <= min->val) return false;\\n        if (max && currentNode->val >= max->val) return false;\\n\\n        return isValidBSTHelper (currentNode->left, min, currentNode) && isValidBSTHelper (currentNode->right, currentNode, max);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return isValidBSTHelper (root, NULL, NULL);\\n    }\\n};\\n```\\nThis is a [nice intuitive solution](https://leetcode.com/problems/validate-binary-search-tree/discuss/990894/C%2B%2B-faster-than-90.55-of-C%2B%2B-and-less-than-87.48-of-C%2B%2B)\\n\\n**Iterative Inorder Stack Solution**\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        stack <TreeNode*> s;        \\n        TreeNode* pre=NULL;\\n        \\n        while (root || !s.empty()) {\\n            while (root) {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top(), s.pop();\\n            \\n            if (pre!=NULL && root->val<=pre->val) return false;\\n            pre=root;\\n            root=root->right;\\n        }\\n        return true;\\n    }\\n};\\n```\\nVery nice article https://leetcode.com/problems/validate-binary-search-tree/discuss/32112/Learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-(Java-Solution)\\n",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBSTHelper (TreeNode* currentNode, TreeNode* min, TreeNode* max) {\\n        if (currentNode==NULL) return true;               \\n        if (min && currentNode->val <= min->val) return false;\\n        if (max && currentNode->val >= max->val) return false;\\n\\n        return isValidBSTHelper (currentNode->left, min, currentNode) && isValidBSTHelper (currentNode->right, currentNode, max);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return isValidBSTHelper (root, NULL, NULL);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        stack <TreeNode*> s;        \\n        TreeNode* pre=NULL;\\n        \\n        while (root || !s.empty()) {\\n            while (root) {\\n                s.push(root);\\n                root=root->left;\\n            }\\n            root=s.top(), s.pop();\\n            \\n            if (pre!=NULL && root->val<=pre->val) return false;\\n            pre=root;\\n            root=root->right;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3574931,
                "title": "beats-100-only-3-lines-code-diagram-image-best-explaination-c-python-java",
                "content": "# Diagram Data Flow\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![code2flow_4fd67K (1).png](https://assets.leetcode.com/users/images/c309b924-df01-4309-a316-8c0e521925f5_1685354802.071912.png)\\n\\n# Approach\\n**Before we start properties to verify BST are:**\\n- Top root node should have range -infinity to +infinity\\n- When we move to left of BST its value must be in -infinity and\\nthe value of its parent root !\\n- When move to right its value lies in more the parent root value and + infinity .\\n- We just checked this condition recursively and DONE ! \\n- Let -infinity and + infinity to given constaints in questions.\\n- Done\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(H)\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    bool solve(TreeNode*root,long long int lb,long long int ub)\\n    {\\n        if(root==nullptr)return true;\\n        if((root->val<ub&&root->val>lb)&&(solve(root->left,lb,root->val))&&(solve(root->right,root->val,ub))) return true;\\n        else return false;\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        long long int lb=-2147483649;\\n        long long int ub=2147483648;\\n        bool ans =solve(root,lb,ub);\\n        return ans;\\n        \\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/3c08567f-214c-420d-9996-ba6ba915f4cf_1685355329.144175.jpeg)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool solve(TreeNode*root,long long int lb,long long int ub)\\n    {\\n        if(root==nullptr)return true;\\n        if((root->val<ub&&root->val>lb)&&(solve(root->left,lb,root->val))&&(solve(root->right,root->val,ub))) return true;\\n        else return false;\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        long long int lb=-2147483649;\\n        long long int ub=2147483648;\\n        bool ans =solve(root,lb,ub);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206020,
                "title": "c-solution-using-long-max-and-long-min",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isValidBSTHelper(TreeNode* root, long min, long max) {\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}   \\n\\t\\t\\tif(root->val > min && root->val < max) {\\n\\t\\t\\t\\treturn isValidBSTHelper(root->left, min, root->val) && isValidBSTHelper(root->right, root->val, max);\\n\\t\\t\\t}    \\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t\\tbool isValidBST(TreeNode* root) {\\n\\t\\t\\treturn isValidBSTHelper(root, LONG_MIN, LONG_MAX);\\n\\t\\t} \\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isValidBSTHelper(TreeNode* root, long min, long max) {\\n\\t\\t\\tif(root == NULL){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 32382,
                "title": "accepted-java-solution",
                "content": "import java.util.Stack;\\n\\npublic class Solution {\\n\\nStack<Integer> stack = new Stack<Integer>();\\n\\npublic void inOrder(TreeNode root){\\n\\n    if(root != null){\\n        inOrder(root.left);\\n        stack.push(root.val);\\n        inOrder(root.right);\\n    }\\n}\\npublic boolean isValidBST(TreeNode root){\\n\\n    if(root == null){\\n        return true;\\n    }\\n\\n    inOrder(root);\\n    int i = stack.pop();\\n\\n    while(!stack.isEmpty()){\\n        int j = stack.pop();\\n        if(i <= j){\\n            return false;\\n        }\\n        i = j;\\n    }\\n\\n    return true;\\n}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\nStack<Integer> stack = new Stack<Integer>();\\n\\npublic void inOrder(TreeNode root){\\n\\n    if(root != null){\\n        inOrder(root.left);\\n        stack.push(root.val);\\n        inOrder(root.right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 32196,
                "title": "1ms-java-solution-o-n-time-and-o-1-space-using-integer-object-and-null-pointer",
                "content": "    public class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return isValidBSTHelper(root, null, null);\\n        }\\n    \\n        private boolean isValidBSTHelper(TreeNode root, Integer leftBound, Integer rightBound) {\\n            // recursively pass left and right bounds from higher level to lower level\\n            if (root == null) {\\n                return true;\\n            }\\n            if (leftBound != null && root.val <= leftBound || rightBound != null && root.val >= rightBound) {\\n                return false;\\n            }\\n            return isValidBSTHelper(root.left, leftBound, root.val) && isValidBSTHelper(root.right, root.val, rightBound);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return isValidBSTHelper(root, null, null);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32378,
                "title": "python-easy-to-understand-iterative-and-recursive-solutions",
                "content": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        return self.valid(root, -sys.maxsize, sys.maxsize)\\n    \\n    def valid(self, root, l, r):\\n        if not root:\\n            return True\\n        if not (l < root.val < r):\\n            return False\\n        return self.valid(root.left, l, root.val) and self.valid(root.right, root.val, r)\\n        \\n    def isValidBST3(self, root):\\n        pre, stack = None, []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                return True\\n            node = stack.pop()\\n            if pre and pre.val >= node.val:\\n                return False\\n            pre = node\\n            root = node.right\\n        \\n    def isValidBST2(self, root):\\n        ret, stack = [], []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                break\\n            node = stack.pop()\\n            ret.append(node.val)\\n            root = node.right\\n        for i in range(len(ret)-1):\\n            if ret[i] >= ret[i+1]:\\n                return False\\n        return True\\n                \\n    def isValidBST1(self, root):\\n        ret = []\\n        self.dfs(root, ret)\\n        for i in range(len(ret)-1):\\n            if ret[i] >= ret[i+1]:\\n                return False\\n        return True\\n             \\n    def dfs(self, root, ret):\\n        if root:\\n            self.dfs(root.left, ret)\\n            ret.append(root.val)\\n            self.dfs(root.right, ret)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        return self.valid(root, -sys.maxsize, sys.maxsize)\\n    \\n    def valid(self, root, l, r):\\n        if not root:\\n            return True\\n        if not (l < root.val < r):\\n            return False\\n        return self.valid(root.left, l, root.val) and self.valid(root.right, root.val, r)\\n        \\n    def isValidBST3(self, root):\\n        pre, stack = None, []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                return True\\n            node = stack.pop()\\n            if pre and pre.val >= node.val:\\n                return False\\n            pre = node\\n            root = node.right\\n        \\n    def isValidBST2(self, root):\\n        ret, stack = [], []\\n        while True:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            if not stack:\\n                break\\n            node = stack.pop()\\n            ret.append(node.val)\\n            root = node.right\\n        for i in range(len(ret)-1):\\n            if ret[i] >= ret[i+1]:\\n                return False\\n        return True\\n                \\n    def isValidBST1(self, root):\\n        ret = []\\n        self.dfs(root, ret)\\n        for i in range(len(ret)-1):\\n            if ret[i] >= ret[i+1]:\\n                return False\\n        return True\\n             \\n    def dfs(self, root, ret):\\n        if root:\\n            self.dfs(root.left, ret)\\n            ret.append(root.val)\\n            self.dfs(root.right, ret)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704624,
                "title": "simple-python-solution-to-validate-binary-search-tree-using-recursion",
                "content": "**IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def valid(node, left, right):\\n            if not node:\\n                return True\\n            if not (node.val<right and node.val>left):\\n                return False\\n            \\n            return (valid(node.left, left, node.val) and \\n                    valid(node.right, node.val, right))\\n        \\n        return valid(root, float(-inf), float(inf))\\n```\\n**Visit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation:  https://www.python-techs.com/**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def valid(node, left, right):\\n            if not node:\\n                return True\\n            if not (node.val<right and node.val>left):\\n                return False\\n            \\n            return (valid(node.left, left, node.val) and \\n                    valid(node.right, node.val, right))\\n        \\n        return valid(root, float(-inf), float(inf))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409238,
                "title": "java-easy-solution-100-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n    private boolean flag=true;\\n    TreeNode prev=null;\\n    public boolean isValidBST(TreeNode root) {\\n        inorder(root);\\n        return flag;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null) return;\\n        \\n        inorder(root.left);\\n        \\n        if(prev!=null && root.val<=prev.val){\\n            flag=false;\\n            return;\\n        }\\n        prev=root;\\n        \\n        inorder(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private boolean flag=true;\\n    TreeNode prev=null;\\n    public boolean isValidBST(TreeNode root) {\\n        inorder(root);\\n        return flag;\\n    }\\n    public void inorder(TreeNode root){\\n        if(root==null) return;\\n        \\n        inorder(root.left);\\n        \\n        if(prev!=null && root.val<=prev.val){\\n            flag=false;\\n            return;\\n        }\\n        prev=root;\\n        \\n        inorder(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504455,
                "title": "easy-0-ms-100-fully-explained-java-c-python-js-c-python3-dfs",
                "content": "# **Java Solution:**\\n```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Validate Binary Search Tree.\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);   \\n    } \\n    public boolean isValidBST(TreeNode root, double minimum, double maximum){\\n        // Base case: root is null...\\n        if(root == null) return true;\\n        // If the value of root is less or equal to minimum...\\n        // Or If the value of root is greater or equal to maximum...\\n        if(root.val <= minimum || root.val >= maximum) return false;\\n        // Recursively call the function for the left and right subtree...\\n        return isValidBST(root.left, minimum, root.val) && isValidBST(root.right, root.val, maximum);\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        // Base case...\\n        if(root == NULL) return true;\\n        return check(root, LONG_MIN, LONG_MAX);\\n    }\\n    bool check(TreeNode* root, long minimum, long maximum){\\n        // If root is NULl...\\n        if(root == NULL) return true;\\n        // If the value of root is less or equal to minimum \\n        // Or If the value of root is greater or equal to maximum\\n        if(root->val <= minimum || root->val >= maximum) return false;\\n        // Recursively call the function for the left and right subtree...\\n        return check(root->left, minimum, root->val) && check(root->right, root->val, maximum);\\n    }\\n};\\n```\\n\\n# **Python/Python3 Solution:**\\n```\\nclass Solution(object):\\n    def isValidBST(self, root, maximum = float(\\'-inf\\'), minimum = float(\\'inf\\')):\\n        # Base case: root is null...\\n        if not root: return True\\n        # If the value of root is less thsn minimum Or greater than maximum...\\n        if not maximum < root.val < minimum: return False\\n        # Recursively call the function for the left and right subtree...\\n        return self.isValidBST(root.left, maximum, root.val) and self.isValidBST(root.right, root.val, minimum)\\n```\\n            \\n# **JavaScript Solution:**\\n```\\nvar isValidBST = function(root, minimum, maximum) {\\n    // Base case: root is null...\\n    if(root == null) return true;\\n    // If the value of root is less or equal to minimum...\\n    // Or If the value of root is greater or equal to maximum...\\n    if(root.val <= minimum || root.val >= maximum) return false;\\n    // Recursively call the function for the left and right subtree...\\n    return isValidBST(root.left, minimum, root.val) && isValidBST(root.right, root.val, maximum);\\n};\\n```\\n\\n# **C Language:**\\n```\\nbool check(struct TreeNode* root, long minimum, long maximum){\\n    // If root is NULl...\\n    if(root == NULL) return true;\\n    // If the value of root is less or equal to minimum \\n    // Or If the value of root is greater or equal to maximum\\n    if(root->val <= minimum || root->val >= maximum) return false;\\n    // Recursively call the function for the left and right subtree...\\n    return check(root->left, minimum, root->val) && check(root->right, root->val, maximum);\\n}\\nbool isValidBST(struct TreeNode* root){\\n    // Base case...\\n    if(root == NULL) return true;\\n    return check(root, LONG_MIN, LONG_MAX);\\n}\\n```\\n\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Validate Binary Search Tree.\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);   \\n    } \\n    public boolean isValidBST(TreeNode root, double minimum, double maximum){\\n        // Base case: root is null...\\n        if(root == null) return true;\\n        // If the value of root is less or equal to minimum...\\n        // Or If the value of root is greater or equal to maximum...\\n        if(root.val <= minimum || root.val >= maximum) return false;\\n        // Recursively call the function for the left and right subtree...\\n        return isValidBST(root.left, minimum, root.val) && isValidBST(root.right, root.val, maximum);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        // Base case...\\n        if(root == NULL) return true;\\n        return check(root, LONG_MIN, LONG_MAX);\\n    }\\n    bool check(TreeNode* root, long minimum, long maximum){\\n        // If root is NULl...\\n        if(root == NULL) return true;\\n        // If the value of root is less or equal to minimum \\n        // Or If the value of root is greater or equal to maximum\\n        if(root->val <= minimum || root->val >= maximum) return false;\\n        // Recursively call the function for the left and right subtree...\\n        return check(root->left, minimum, root->val) && check(root->right, root->val, maximum);\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isValidBST(self, root, maximum = float(\\'-inf\\'), minimum = float(\\'inf\\')):\\n        # Base case: root is null...\\n        if not root: return True\\n        # If the value of root is less thsn minimum Or greater than maximum...\\n        if not maximum < root.val < minimum: return False\\n        # Recursively call the function for the left and right subtree...\\n        return self.isValidBST(root.left, maximum, root.val) and self.isValidBST(root.right, root.val, minimum)\\n```\n```\\nvar isValidBST = function(root, minimum, maximum) {\\n    // Base case: root is null...\\n    if(root == null) return true;\\n    // If the value of root is less or equal to minimum...\\n    // Or If the value of root is greater or equal to maximum...\\n    if(root.val <= minimum || root.val >= maximum) return false;\\n    // Recursively call the function for the left and right subtree...\\n    return isValidBST(root.left, minimum, root.val) && isValidBST(root.right, root.val, maximum);\\n};\\n```\n```\\nbool check(struct TreeNode* root, long minimum, long maximum){\\n    // If root is NULl...\\n    if(root == NULL) return true;\\n    // If the value of root is less or equal to minimum \\n    // Or If the value of root is greater or equal to maximum\\n    if(root->val <= minimum || root->val >= maximum) return false;\\n    // Recursively call the function for the left and right subtree...\\n    return check(root->left, minimum, root->val) && check(root->right, root->val, maximum);\\n}\\nbool isValidBST(struct TreeNode* root){\\n    // Base case...\\n    if(root == NULL) return true;\\n    return check(root, LONG_MIN, LONG_MAX);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409094,
                "title": "java-0ms-100-faster-beginner-friendly",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n\\n```\\npublic boolean isValidBST(TreeNode root) {\\n        return isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    private boolean isValid(TreeNode node, long l, long h) {\\n        if (node == null) { // Base Case\\n            return true;\\n        }\\n\\t\\t// intially head can be anything between -inf to +inf\\n\\t\\t//after head left node should be l to previous head node value and right node should be head node value to h\\n        return node.val > l && node.val < h && isValid(node.left, l, node.val) && isValid(node.right, node.val, h);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\npublic boolean isValidBST(TreeNode root) {\\n        return isValid(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    private boolean isValid(TreeNode node, long l, long h) {\\n        if (node == null) { // Base Case\\n            return true;\\n        }\\n\\t\\t// intially head can be anything between -inf to +inf\\n\\t\\t//after head left node should be l to previous head node value and right node should be head node value to h\\n        return node.val > l && node.val < h && isValid(node.left, l, node.val) && isValid(node.right, node.val, h);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 783930,
                "title": "easy-to-understand-2-lines-solution-o-n-with-examples-and-explanation-javascript",
                "content": "Short and sweet:\\n\\n```ts\\nfunction isValidBST(root: TreeNode|null, min = -Infinity, max = Infinity): boolean {\\n  if(!root) return true;\\n  return !(root.val <= min || root.val >= max) && isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\\n};\\n```\\n\\nHow it works?\\n- If the root is `null`, then is a valid BST.\\n- If the root is NOT null, then we check for the following:\\n  - check if the current node\\'s value is within boundaries (min/max). The intial boundaries are -/+ Infinity so any value would be valid.\\n  - However, for the children we start restricting the boundaries. If we go to the left subtree, then we set the current node as the `max` boundary. Similarly, if we go the right subtree, then we set the current node\\'s value as the `min`.\\n\\nLet\\'s do some examples:\\n\\n**Example 1**:\\n\\n`[20,10,30,null,18,null,null,9,19]`\\n\\n![image](https://assets.leetcode.com/users/images/c25f0c88-4a57-40ba-8bea-06f02a0cf64c_1597065536.6765602.png)\\n\\nThe recursion call will be the following:\\n\\n- isValidBST(root: 20, min = -Infinity, max = Infinity)\\n\\t- isValidBST(root: 10, min = -Infinity, max = 20)\\n\\t\\t- isValidBST(root: 18, min = 10, max = 20)\\n\\t\\t\\t- isValidBST(root: 9, min = 10, max = 18): `false`, though `9 < 18 < 19`, 9 is lower than the `min=10`, so it will return false.\\n\\n\\n**Example 2**:\\n\\n`[20,10,30,null,18,null,null,17,19]`\\n\\n![image](https://assets.leetcode.com/users/images/6d31c54b-a7c0-4269-a727-b211fccc14bc_1597065014.7532413.png)\\n\\nThe recursion call will be the following:\\n- isValidBST(root: 20, min: -Infinity, max: Infinity): `true`\\n\\t- isValidBST(root: 10, min = -Infinity, max = 20): `true`\\n\\t\\t- isValidBST(root: 18, min = 10, max = 20): `true`\\n\\t\\t\\t- isValidBST(root: 17, min = 10, max = 18): `true`\\n\\t\\t\\t- isValidBST(root: 19, min = 18, max = 20): `true`\\n\\t- isValidBST(root: 30, min = 20, max = Infinity): `true`\\n\\nEach one returns true so it\\'s a valid BST.\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nfunction isValidBST(root: TreeNode|null, min = -Infinity, max = Infinity): boolean {\\n  if(!root) return true;\\n  return !(root.val <= min || root.val >= max) && isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 509816,
                "title": "go-4ms",
                "content": "```\\nfunc isValidBST(root *TreeNode) bool {\\n    return RecValidate(root, nil, nil)\\n}\\n\\nfunc RecValidate(n, min, max *TreeNode) bool {\\n    if n == nil {\\n        return true\\n    }\\n    if min != nil && n.Val <= min.Val {\\n        return false\\n    }\\n    if max != nil && n.Val >= max.Val {\\n        return false\\n    }\\n    return RecValidate(n.Left, min, n) && RecValidate(n.Right, n, max)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isValidBST(root *TreeNode) bool {\\n    return RecValidate(root, nil, nil)\\n}\\n\\nfunc RecValidate(n, min, max *TreeNode) bool {\\n    if n == nil {\\n        return true\\n    }\\n    if min != nil && n.Val <= min.Val {\\n        return false\\n    }\\n    if max != nil && n.Val >= max.Val {\\n        return false\\n    }\\n    return RecValidate(n.Left, min, n) && RecValidate(n.Right, n, max)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32356,
                "title": "4-line-c-simple-solution-easy-understanding",
                "content": "     bool isValidBST(TreeNode* root) {\\n        return dfs_valid(root, LONG_MIN, LONG_MAX);\\n    }\\n    bool dfs_valid(TreeNode *root, long low, long high) {\\n        if (!root) return true;\\n        return low < root->val && root->val < high && dfs_valid(root->left, low, root->val)\\n                && dfs_valid(root->right, root->val, high);\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "     bool isValidBST(TreeNode* root) {\\n        return dfs_valid(root, LONG_MIN, LONG_MAX);\\n    }\\n    bool dfs_valid(TreeNode *root, long low, long high) {\\n        if (!root) return true;\\n        return low < root->val && root->val < high && dfs_valid(root->left, low, root->val)\\n                && dfs_valid(root->right, root->val, high);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3213726,
                "title": "python-inorder-traversal-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        arr = []\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left)\\n            arr.append(root.val)\\n            inorder(root.right)\\n        inorder(root)\\n        return True if arr == list(sorted(set(arr))) else False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        arr = []\\n        def inorder(root):\\n            if root is None: return None\\n            inorder(root.left)\\n            arr.append(root.val)\\n            inorder(root.right)\\n        inorder(root)\\n        return True if arr == list(sorted(set(arr))) else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508434,
                "title": "c-python-simple-o-n-solution",
                "content": "**C++ :**\\n\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root -> left);\\n        bTree.push_back(root -> val);\\n        inorder(root -> right);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        // An empty tree\\n        if(!root)\\n            return true;\\n        \\n        // A leaf\\n        if(!root -> right && !root -> left)\\n            return true;\\n        \\n        // Inorder traversal to get the tree\\'s values sorted\\n        inorder(root);\\n        \\n        for(int i = 0; i < bTree.size() - 1; ++i)\\n            if(bTree[i] >= bTree[i + 1])\\n                return false;\\n        return true;\\n        \\n    }\\n    \\n    private:\\n        vector<int> bTree;\\n};\\n```\\n\\n**Python :**\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.tree = []\\n     \\n    def inorder(self, root: Optional[TreeNode]) -> None:\\n        if not root:\\n            return\\n        \\n        self.inorder(root.left);\\n        self.tree.append(root.val);\\n        self.inorder(root.right);\\n        \\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n        \\n        if not root.right and not root.left:\\n            return True\\n        \\n        self.inorder(root)\\n        \\n        for i in range(len(self.tree) - 1):\\n            if self.tree[i] >= self.tree[i + 1]:\\n                return False\\n        return True;\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root -> left);\\n        bTree.push_back(root -> val);\\n        inorder(root -> right);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        // An empty tree\\n        if(!root)\\n            return true;\\n        \\n        // A leaf\\n        if(!root -> right && !root -> left)\\n            return true;\\n        \\n        // Inorder traversal to get the tree\\'s values sorted\\n        inorder(root);\\n        \\n        for(int i = 0; i < bTree.size() - 1; ++i)\\n            if(bTree[i] >= bTree[i + 1])\\n                return false;\\n        return true;\\n        \\n    }\\n    \\n    private:\\n        vector<int> bTree;\\n};\\n```\n```\\nclass Solution:\\n    def __init__(self):\\n        self.tree = []\\n     \\n    def inorder(self, root: Optional[TreeNode]) -> None:\\n        if not root:\\n            return\\n        \\n        self.inorder(root.left);\\n        self.tree.append(root.val);\\n        self.inorder(root.right);\\n        \\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        if not root:\\n            return True\\n        \\n        if not root.right and not root.left:\\n            return True\\n        \\n        self.inorder(root)\\n        \\n        for i in range(len(self.tree) - 1):\\n            if self.tree[i] >= self.tree[i + 1]:\\n                return False\\n        return True;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32136,
                "title": "three-solutions-in-c",
                "content": "**Solution 1.** \\n\\nBF, O(n^2).\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if(!root) return true;\\n        if(!isValid(root->left, root->val, true) || !isValid(root->right, root->val, false)) return false;\\n        return isValidBST(root->left) && isValidBST(root->right);\\n    }\\n    \\n    bool isValid(TreeNode* root, int bound, bool isLeft){\\n        return !root || (isLeft ? root->val < bound : root->val > bound ) && isValid(root->left, bound, isLeft) && isValid(root->right, bound, isLeft);\\n    }\\n};\\n```\\n***\\n**Solution 2.** \\n\\nIn-order, recursive, O(n), refered from [here](https://discuss.leetcode.com/topic/4659/c-in-order-traversal-and-please-do-not-rely-on-buggy-int_max-int_min-solutions-any-more).\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* pre = NULL;\\n        return isValid(root, pre);\\n    }\\n    \\n    bool isValid(TreeNode* root, TreeNode* &pre){\\n        if(!root) return true;\\n        if(!isValid(root->left, pre)) return false;\\n        if(pre && root->val <= pre->val) return false;\\n        pre = root;\\n        return isValid(root->right, pre);\\n    }\\n};\\n```\\n***\\n**Solution 3.** \\n\\nIn-order, iterative, O(n), refered from [here](https://discuss.leetcode.com/topic/46016/learn-one-iterative-inorder-traversal-apply-it-to-multiple-tree-questions-java-solution).\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        stack<TreeNode*>s;\\n        TreeNode* pre = NULL;\\n        while(root || !s.empty()){\\n            while(root){\\n                s.push(root);\\n                root = root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n            if(pre && root->val <= pre->val) return false;\\n            pre = root;\\n            root = root->right;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if(!root) return true;\\n        if(!isValid(root->left, root->val, true) || !isValid(root->right, root->val, false)) return false;\\n        return isValidBST(root->left) && isValidBST(root->right);\\n    }\\n    \\n    bool isValid(TreeNode* root, int bound, bool isLeft){\\n        return !root || (isLeft ? root->val < bound : root->val > bound ) && isValid(root->left, bound, isLeft) && isValid(root->right, bound, isLeft);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* pre = NULL;\\n        return isValid(root, pre);\\n    }\\n    \\n    bool isValid(TreeNode* root, TreeNode* &pre){\\n        if(!root) return true;\\n        if(!isValid(root->left, pre)) return false;\\n        if(pre && root->val <= pre->val) return false;\\n        pre = root;\\n        return isValid(root->right, pre);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        stack<TreeNode*>s;\\n        TreeNode* pre = NULL;\\n        while(root || !s.empty()){\\n            while(root){\\n                s.push(root);\\n                root = root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n            if(pre && root->val <= pre->val) return false;\\n            pre = root;\\n            root = root->right;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247077,
                "title": "java-recursive-solution-0ms-without-using-long-max-value-and-long-min-value",
                "content": "# Approach\\nFor this problem, we need to choose one biggest value > `Integer.MAX_VALUE`\\nand one smallest value < `Integer.MIN_VALUE` as the maximum and minimum, respectively. They could not be equal, otherwise cases like\\n```\\nroot = [2147483647]\\nroot = [2147483647, 2147483647]\\n```\\nwill be failed.\\n\\n`Long.MAX_VALUE` and `Long.MIN_VALUE` are luckily the two that meet our needs. However, if unluckily in the future the LeetCode admin adds them into the test cases, cases like\\n```\\nroot = [9223372036854775807]\\nroot = [9223372036854775807, 9223372036854775807]\\n```\\nwill be failed again.\\n\\nTherefore, it is better to avoid using them. We can simply replace the `int` or `long` with `TreeNode`, and set them to `null` when calling the helper function, as shown in the code below.\\n\\n# Reference\\nhttps://algs4.cs.princeton.edu/32bst/BST.java.html\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, null, null);\\n    }\\n\\n    private boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        if (min != null && root.val <= min.val) {\\n            return false;\\n        }\\n\\n        if (max != null && root.val >= max.val) {\\n            return false;\\n        }\\n        return isValidBST(root.left, min, root) \\n                && isValidBST(root.right, root, max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nroot = [2147483647]\\nroot = [2147483647, 2147483647]\\n```\n```\\nroot = [9223372036854775807]\\nroot = [9223372036854775807, 9223372036854775807]\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, null, null);\\n    }\\n\\n    private boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {\\n        if (root == null) {\\n            return true;\\n        }\\n\\n        if (min != null && root.val <= min.val) {\\n            return false;\\n        }\\n\\n        if (max != null && root.val >= max.val) {\\n            return false;\\n        }\\n        return isValidBST(root.left, min, root) \\n                && isValidBST(root.right, root, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736338,
                "title": "easy-c-solution-dfs-recursion",
                "content": "# Solution via in-order traversal [we need to check whether that returned elements are in ascending order]\\n\\n```\\nclass Solution {\\npublic:\\n    long int num = LONG_MIN;\\n\\n    bool isValidBST(TreeNode* root) {\\n        if (!root) return true;\\n        \\n        bool ans = isValidBST(root->left);\\n        \\n        if (root->val > num) {\\n            num = root->val;\\n        } else return false;\\n\\n        return ans && isValidBST(root->right);\\n    }\\n};\\n```\\n\\n# Solution via recursion\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root, long int min = LONG_MIN, long int max = LONG_MAX) {\\n        if (!root) return true;\\n\\n        if (root->val > min && root->val < max) {\\n            return true && isValidBST(root->left, min, root->val) && isValidBST(root->right, root->val, max);\\n        }\\n\\n        return false;\\n    }\\n};\\n```\\n\\n\\n*If the above approaches helped you, then please upvote the solution!*\\n\\n## My GitHub: https://github.com/crimsonKn1ght",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long int num = LONG_MIN;\\n\\n    bool isValidBST(TreeNode* root) {\\n        if (!root) return true;\\n        \\n        bool ans = isValidBST(root->left);\\n        \\n        if (root->val > num) {\\n            num = root->val;\\n        } else return false;\\n\\n        return ans && isValidBST(root->right);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root, long int min = LONG_MIN, long int max = LONG_MAX) {\\n        if (!root) return true;\\n\\n        if (root->val > min && root->val < max) {\\n            return true && isValidBST(root->left, min, root->val) && isValidBST(root->right, root->val, max);\\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847783,
                "title": "dfs-solution-easy-to-understand",
                "content": "```\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        self.answer = True\\n        \\n        def dfs(root, left, right):\\n            if root:\\n                if left >= root.val or root.val >= right:\\n                    self.answer = False\\n                    return\\n                dfs(root.left, left, root.val)\\n                dfs(root.right, root.val, right)\\n        dfs(root, float(\"-inf\"), float(\\'inf\\'))\\n        return self.answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        self.answer = True\\n        \\n        def dfs(root, left, right):\\n            if root:\\n                if left >= root.val or root.val >= right:\\n                    self.answer = False\\n                    return\\n                dfs(root.left, left, root.val)\\n                dfs(root.right, root.val, right)\\n        dfs(root, float(\"-inf\"), float(\\'inf\\'))\\n        return self.answer\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 286092,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public bool IsValidBST(TreeNode root) {\\n        return DFS(root, long.MinValue, long.MaxValue);\\n    }\\n\\n    private bool DFS(TreeNode root, long min, long max) {\\n        if (root == null) return true;\\n        if (min < root.val && root.val < max) {\\n            var leftResult = DFS(root.left, min, root.val);\\n            var rightResult = DFS(root.right, root.val, max);\\n\\n            if (leftResult && rightResult) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool IsValidBST(TreeNode root) {\\n        return DFS(root, long.MinValue, long.MaxValue);\\n    }\\n\\n    private bool DFS(TreeNode root, long min, long max) {\\n        if (root == null) return true;\\n        if (min < root.val && root.val < max) {\\n            var leftResult = DFS(root.left, min, root.val);\\n            var rightResult = DFS(root.right, root.val, max);\\n\\n            if (leftResult && rightResult) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 232839,
                "title": "swift",
                "content": "```swift\\nfunc isValidBST(_ root: TreeNode?) -> Bool {\\n   return isBst(root, min: Int.min, max: Int.max)\\n}\\n    \\nprivate func isBst(_ node: TreeNode?, min: Int, max: Int) -> Bool {\\n\\tif node == nil { return true }\\n\\tif node!.val <= min || node!.val >= max { return false }\\n\\treturn isBst(node?.left, min: min, max: node!.val) &&\\n\\t\\t   isBst(node?.right, min: node!.val, max: max)\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nfunc isValidBST(_ root: TreeNode?) -> Bool {\\n   return isBst(root, min: Int.min, max: Int.max)\\n}\\n    \\nprivate func isBst(_ node: TreeNode?, min: Int, max: Int) -> Bool {\\n\\tif node == nil { return true }\\n\\tif node!.val <= min || node!.val >= max { return false }\\n\\treturn isBst(node?.left, min: min, max: node!.val) &&\\n\\t\\t   isBst(node?.right, min: node!.val, max: max)\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 207438,
                "title": "javascript",
                "content": "```\\nvar isValidBST = function(root) {\\n    if(!root) \\n        return true\\n    return dfs(root, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)\\n    \\n    function dfs(root, min, max){\\n        if(!root) \\n            return true\\n        if(root.val <= min || root.val >= max)\\n            return false\\n        return dfs(root.left, min, root.val) && dfs(root.right, root.val, max)\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isValidBST = function(root) {\\n    if(!root) \\n        return true\\n    return dfs(root, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)\\n    \\n    function dfs(root, min, max){\\n        if(!root) \\n            return true\\n        if(root.val <= min || root.val >= max)\\n            return false\\n        return dfs(root.left, min, root.val) && dfs(root.right, root.val, max)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32306,
                "title": "1-ms-java-solution",
                "content": "    public class Solution {\\n        private TreeNode prev = null;\\n        \\n        public boolean isValidBST(TreeNode root) {\\n            if(root == null){\\n                return true;\\n            }\\n            if(!isValidBST(root.left)) return false;\\n            if(prev != null && root.val <= prev.val) return false;\\n            prev = root;\\n            return isValidBST(root.right);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        private TreeNode prev = null;\\n        \\n        public boolean isValidBST(TreeNode root) {\\n            if(root == null){\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 32370,
                "title": "python-inorder-non-recursive-solution-using-stack",
                "content": "    class Solution(object):\\n        def isValidBST(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: bool\\n            \"\"\"\\n            # using inorder - binary search tree will be ascending order\\n            stack = []\\n            cur = root\\n            pre = None\\n            while len(stack) or cur:\\n                if cur:\\n                    stack.append(cur)\\n                    cur = cur.left\\n                else:\\n                    p = stack.pop()\\n                    if pre and p.val <= pre.val:\\n                        return False\\n                    pre = p\\n                    cur = p.right\\n            return True",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "    class Solution(object):\\n        def isValidBST(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: bool\\n            \"\"\"\\n            # using inorder - binary search tree will be ascending order\\n            stack = []\\n            cur = root\\n            pre = None\\n            while len(stack) or cur:\\n                if cur:\\n                    stack.append(cur)\\n                    cur = cur.left\\n                else:\\n                    p = stack.pop()\\n                    if pre and p.val <= pre.val:\\n                        return False\\n                    pre = p\\n                    cur = p.right\\n            return True",
                "codeTag": "Java"
            },
            {
                "id": 32502,
                "title": "test-cases-missing",
                "content": "There should be a test case where some nodes have values equal to Integer.MIN_VALUE and Integer.MAX_VALUE;\\n\\nThis solution is accepted and shouldn't be:\\n\\n    public boolean isValidBST(TreeNode root) {\\n        if (root == null) return true;\\n        return isValidBST(root.left,Integer.MIN_VALUE, root.val) \\n               && isValidBST(root.right,root.val,Integer.MAX_VALUE);\\n    }\\n\\n    public boolean isValidBST(TreeNode root, int smallest, int largest) {\\n        if (root == null) return true;\\n        if (root.val > smallest && root.val < largest)\\n            return isValidBST(root.left,smallest, root.val) \\n                   && isValidBST(root.right,root.val,largest);\\n        else\\n            return false;\\n    }",
                "solutionTags": [],
                "code": "There should be a test case where some nodes have values equal to Integer.MIN_VALUE and Integer.MAX_VALUE;\\n\\nThis solution is accepted and shouldn't be:\\n\\n    public boolean isValidBST(TreeNode root) {\\n        if (root == null) return true;\\n        return isValidBST(root.left,Integer.MIN_VALUE, root.val) \\n               && isValidBST(root.right,root.val,Integer.MAX_VALUE);\\n    }\\n\\n    public boolean isValidBST(TreeNode root, int smallest, int largest) {\\n        if (root == null) return true;\\n        if (root.val > smallest && root.val < largest)\\n            return isValidBST(root.left,smallest, root.val) \\n                   && isValidBST(root.right,root.val,largest);\\n        else\\n            return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3770870,
                "title": "superb-lgic-bst",
                "content": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def BST(root,mx,mi):\\n            if not root:\\n                return True\\n            elif root.val>=mx or root.val<=mi:\\n                return False\\n            else:\\n                return BST(root.left,root.val,mi) and BST(root.right,mx,root.val)\\n        return BST(root,float(\\'inf\\'),float(\\'-inf\\'))\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def BST(root,mx,mi):\\n            if not root:\\n                return True\\n            elif root.val>=mx or root.val<=mi:\\n                return False\\n            else:\\n                return BST(root.left,root.val,mi) and BST(root.right,mx,root.val)\\n        return BST(root,float(\\'inf\\'),float(\\'-inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390380,
                "title": "intuitive-c-solution-inorder-traversal",
                "content": "##### Let\\'s connect on Linkedin https://www.linkedin.com/in/arthur-asanaliev/\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> nodes;\\n    void inorder(TreeNode* root) {\\n        if (root->left) inorder(root->left);\\n        nodes.push_back(root->val);\\n        if (root->right) inorder(root->right);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        inorder(root);\\n        for (int i = 0; i < nodes.size() - 1; i++) {\\n            if (nodes[i] >= nodes[i+1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> nodes;\\n    void inorder(TreeNode* root) {\\n        if (root->left) inorder(root->left);\\n        nodes.push_back(root->val);\\n        if (root->right) inorder(root->right);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        inorder(root);\\n        for (int i = 0; i < nodes.size() - 1; i++) {\\n            if (nodes[i] >= nodes[i+1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251741,
                "title": "simple-brute-force-solution-o-n-time-o-n-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf you clearly understand the question, it states that you just need to check whether the BST is valid or not, and when we traverse a BST using INORDER, the output stream will be a sorted list.\\n\\n# Simple Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can traverse the BST using Inorder and store each output element in a list, and check whether the list is sorted or not.\\n\\n**FOR EXAMPLE:**\\nIf the BST looks something like this:\\n![djanj.png](https://assets.leetcode.com/users/images/4435e6a0-5248-45a0-97bf-a83d668f8569_1677843929.3729975.png)\\n\\nThe **INORDER** traversal will be - [1, 3, 4, 6, 7, 8, 10, 13, 14]\\nAnd if a tree is a BST the inorder will be sorted;\\n\\nThe above tree is a valid BST, and we can check that using the above inorder list.\\n\\n\\n# Complexity\\n- Time complexity: O(N) for traversing tree and O(N) for checking if resultant list is sorted or not,  N = Number of Nodes in a tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) in worst case if tree is skewed, and O(N) space for storing each element in a list.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    // Travserse entire tree using inorder, and store each element inside the res.\\n    void inorder(TreeNode* root, vector<int>&res) {\\n        if(!root) return;\\n        inorder(root->left, res);\\n        res.push_back(root->val);\\n        inorder(root->right, res);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> res;\\n        inorder(root, res);\\n        for(int i=1; i<res.size(); ++i) {\\n            // Checking if res[i-1] >= res[i] then return false;\\n            // That means the input tree is not a valid BST;\\n            if(res[i-1]>=res[i]) return false;\\n        }\\n        return true;\\n        // Follow up: solve this without using any extra space.\\n        // Hint: You can use ranges, for each element.\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    // Travserse entire tree using inorder, and store each element inside the res.\\n    void inorder(TreeNode* root, vector<int>&res) {\\n        if(!root) return;\\n        inorder(root->left, res);\\n        res.push_back(root->val);\\n        inorder(root->right, res);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> res;\\n        inorder(root, res);\\n        for(int i=1; i<res.size(); ++i) {\\n            // Checking if res[i-1] >= res[i] then return false;\\n            // That means the input tree is not a valid BST;\\n            if(res[i-1]>=res[i]) return false;\\n        }\\n        return true;\\n        // Follow up: solve this without using any extra space.\\n        // Hint: You can use ranges, for each element.\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1926224,
                "title": "100-fastest-swift-solution-time-o-n-space-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\n \\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the tree.\\n    //   - space: O(n), where n is the number of nodes in the tree.\\n\\n    private var prev: Int?\\n    \\n    func isValidBST(_ root: TreeNode?) -> Bool {\\n        inorder(root)\\n    }\\n    \\n    private func inorder(_ root: TreeNode?) -> Bool {\\n        guard let root = root else { return true }\\n        \\n        guard inorder(root.left) else { return false }\\n        \\n        if let prev = prev, root.val <= prev { return false }\\n        \\n        prev = root.val\\n        return inorder(root.right)\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\n \\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the tree.\\n    //   - space: O(n), where n is the number of nodes in the tree.\\n\\n    private var prev: Int?\\n    \\n    func isValidBST(_ root: TreeNode?) -> Bool {\\n        inorder(root)\\n    }\\n    \\n    private func inorder(_ root: TreeNode?) -> Bool {\\n        guard let root = root else { return true }\\n        \\n        guard inorder(root.left) else { return false }\\n        \\n        if let prev = prev, root.val <= prev { return false }\\n        \\n        prev = root.val\\n        return inorder(root.right)\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682393,
                "title": "easy-c-inorder-traversal-o-n",
                "content": "The inorder traversal of a BST is always sorted.\\nAlgortihm\\n1) Obtain the Inorder traversal of Binary Tree\\n2) Check if Inorder traversal is sorted\\n3) If sorted then return TRUE\\n4) If  NOT sorted then return FALSE\\n\\nInorder Traversal Explained\\n![image](https://assets.leetcode.com/users/images/6bf52f7d-5b1f-4bc1-bdab-c88511f090c6_1641889707.5851665.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    void check(TreeNode* root, vector <int>& res){\\n        if(root == NULL) return;\\n        \\n        check(root->left,res);\\n        res.push_back(root->val);\\n        check(root->right,res);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector <int> res;\\n        check(root,res);\\n        for(int i = 1; i <res.size(); i++){\\n            if(res[i] <= res[i-1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\nUpvote if you understood.\\nThank you!",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void check(TreeNode* root, vector <int>& res){\\n        if(root == NULL) return;\\n        \\n        check(root->left,res);\\n        res.push_back(root->val);\\n        check(root->right,res);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector <int> res;\\n        check(root,res);\\n        for(int i = 1; i <res.size(); i++){\\n            if(res[i] <= res[i-1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150778,
                "title": "java-solution-both-recursive-and-non-recursive-good-way-to-build-concept-on-tree",
                "content": "I found this to be a good problem to improve concepts on tree, especially BST.\\nApproach 1: Employ BST property and iterative inorder traversal.\\nWe remember that in BST, an iterative inorder traversal is basically an ascending sorted list. Now, we also know that no two elements in the tree are equal.\\n\\nHence the simple logic that at any given point of time, the previous element should not be greater than or equal to the current element. For the first element, previous element is just \"null\".\\n\\nFor boundary conditions, we need to understand that Integer.MAX_VALUE and Integer.MIN_VALUE are all valid values, so cannot be used as sentinel markers. \\n\\nCode below:\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode prev = null;\\n        TreeNode curr = root;\\n        \\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            // Inorder visit of node\\n            curr = stack.pop();\\n\\t\\t\\t// Checking BST property\\n            if (prev != null && prev.val >= curr.val) {\\n                return false;\\n            }\\n            prev = curr;\\n            curr = curr.right;\\n        }\\n        // At this stage, all nodes have been visited, and we know the tree is BST\\n        return true;\\n        \\n    }\\n}\\n```\\n\\nNow the interviewer can ask for any alternative approach to solve this problem, like a recursive approach without any global/member variable. In this case, we need to think about invariant here are the bounds of each node.\\nIf a node is a left child in a BST, it\\'s max value is bound by its parent. Similarly, if it right child, then its min value is bound by its parent.\\n\\nOne trick here is how do we intuitively pass unbounded limits since MIN and MAX values are already taken? In Java, Integer object comes to the rescue, and the value \"null\" indicates unbounded value.\\n\\nRest of the code is pretty intuitive:\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, null, null);\\n    }\\n    \\n    private boolean helper(TreeNode node, Integer minVal, Integer maxVal) {\\n        if (node == null) {\\n            return true;\\n        }\\n        \\n        // Preorder traversal: check if the current node respects the bounds\\n        if (minVal != null && node.val <= minVal) {\\n            return false;\\n        }\\n        \\n        if (maxVal != null && node.val >= maxVal) {\\n            return false;\\n        }\\n        \\n        // Traverse left and right children, note that current node applies to min and max bounds based on which\\n        // child we select\\n        boolean left = helper(node.left, minVal, node.val);\\n        boolean right = helper(node.right, node.val, maxVal);\\n        return left == true && right == true;\\n    }\\n}\\n```\\n\\nBoth the algorithms take O(n) time complexity since they intend to visit all nodes to ensure the tree is BST, and O(h) space which signifies the stack size (explicit stack or recursion stack). Skewed tree with only left/right child will take worst case space of (n) following basic tree property.\\n",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode prev = null;\\n        TreeNode curr = root;\\n        \\n        while (curr != null || !stack.isEmpty()) {\\n            while (curr != null) {\\n                stack.push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            // Inorder visit of node\\n            curr = stack.pop();\\n\\t\\t\\t// Checking BST property\\n            if (prev != null && prev.val >= curr.val) {\\n                return false;\\n            }\\n            prev = curr;\\n            curr = curr.right;\\n        }\\n        // At this stage, all nodes have been visited, and we know the tree is BST\\n        return true;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, null, null);\\n    }\\n    \\n    private boolean helper(TreeNode node, Integer minVal, Integer maxVal) {\\n        if (node == null) {\\n            return true;\\n        }\\n        \\n        // Preorder traversal: check if the current node respects the bounds\\n        if (minVal != null && node.val <= minVal) {\\n            return false;\\n        }\\n        \\n        if (maxVal != null && node.val >= maxVal) {\\n            return false;\\n        }\\n        \\n        // Traverse left and right children, note that current node applies to min and max bounds based on which\\n        // child we select\\n        boolean left = helper(node.left, minVal, node.val);\\n        boolean right = helper(node.right, node.val, maxVal);\\n        return left == true && right == true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594360,
                "title": "simple-readable-java-recursion-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, null, null);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root, Integer min, Integer max) {\\n        if (root == null) \\n            return true; \\n        if ((max != null && root.val >= max) || (min != null && root.val <= min)) \\n            return false; \\n        return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, null, null);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root, Integer min, Integer max) {\\n        if (root == null) \\n            return true; \\n        if ((max != null && root.val >= max) || (min != null && root.val <= min)) \\n            return false; \\n        return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32369,
                "title": "output-in-submit-and-run-code-are-different",
                "content": "I submit my code and got return as wrong answer since it does not pass case [0,-1]. It shows my output is false but it should be true. Then I run code by check customized case [0,-1]. It shows my output is true. Is there anything wrong?\\n\\n    # Definition for a binary tree node.\\n    # class TreeNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution(object):\\n        global pre\\n        pre = None\\n        def isValidBST(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: bool\\n            \"\"\"\\n            global pre\\n            if (root == None):\\n                return True\\n            if ((not self.isValidBST(root.left)) or (pre != None and pre.val >= root.val)):\\n                return False\\n            pre = root\\n            if (not self.isValidBST(root.right)):\\n                return False\\n            return True",
                "solutionTags": [],
                "code": "I submit my code and got return as wrong answer since it does not pass case [0,-1]. It shows my output is false but it should be true. Then I run code by check customized case [0,-1]. It shows my output is true. Is there anything wrong?\\n\\n    # Definition for a binary tree node.\\n    # class TreeNode(object):\\n    #     def __init__(self, x):\\n    #         self.val = x\\n    #         self.left = None\\n    #         self.right = None\\n    \\n    class Solution(object):\\n        global pre\\n        pre = None\\n        def isValidBST(self, root):\\n            \"\"\"\\n            :type root: TreeNode\\n            :rtype: bool\\n            \"\"\"\\n            global pre\\n            if (root == None):\\n                return True\\n            if ((not self.isValidBST(root.left)) or (pre != None and pre.val >= root.val)):\\n                return False\\n            pre = root\\n            if (not self.isValidBST(root.right)):\\n                return False\\n            return True",
                "codeTag": "Java"
            },
            {
                "id": 32300,
                "title": "morris-traversal-o-1-space-no-recursion-o-n-time-with-explanation-java",
                "content": "    // inorder traversal to see if the value is monotonically increased\\n    // use morris traversal to gain O(1) space, No recursion and O(n) time\\n    // main idea: the key part of tree traversal is how to go back to parent,\\n    //            one way is to use recursion and store parent in function stack,\\n    //            another way is to use explicit stack to store parent,\\n    //            morris traversal modify the original tree and \\n    //            let the right child of the predecessor of the root to point back to itself\\n    //            in order to go back to the root and then restore the pointer(set it to null again)\\n    //            the overall time complexity is still O(n), since the tree is traversed\\n    //            no more than twice(there is not overlap between the path of finding predecessor).\\n    public boolean isValidBST(TreeNode root) {\\n        TreeNode curr = root;\\n        TreeNode prev = null;\\n        TreeNode pred = null; // predecessor\\n        \\n        while (curr != null) {\\n            if (curr.left == null) {\\n                if (prev != null) {\\n                    if (curr.val <= prev.val) {\\n                        return false;\\n                    }\\n                }\\n                prev = curr;\\n                curr = curr.right;\\n            } else {\\n                pred = curr.left;\\n                while (pred.right != null && pred.right != curr) { // find predecessor\\n                    pred = pred.right;\\n                }\\n                if (pred.right == curr) {\\n                    pred.right = null;\\n                    if (prev != null) {\\n                        if (curr.val <= prev.val) {\\n                            return false;\\n                        }\\n                    }\\n                    prev = curr;\\n                    curr = curr.right;\\n                } else {\\n                    pred.right = curr;\\n                    curr = curr.left;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    // inorder traversal to see if the value is monotonically increased\\n    // use morris traversal to gain O(1) space, No recursion and O(n) time\\n    // main idea: the key part of tree traversal is how to go back to parent,\\n    //            one way is to use recursion and store parent in function stack,\\n    //            another way is to use explicit stack to store parent,\\n    //            morris traversal modify the original tree and \\n    //            let the right child of the predecessor of the root to point back to itself\\n    //            in order to go back to the root and then restore the pointer(set it to null again)\\n    //            the overall time complexity is still O(n), since the tree is traversed\\n    //            no more than twice(there is not overlap between the path of finding predecessor).\\n    public boolean isValidBST(TreeNode root) {\\n        TreeNode curr = root;\\n        TreeNode prev = null;\\n        TreeNode pred = null; // predecessor\\n        \\n        while (curr != null) {\\n            if (curr.left == null) {\\n                if (prev != null) {\\n                    if (curr.val <= prev.val) {\\n                        return false;\\n                    }\\n                }\\n                prev = curr;\\n                curr = curr.right;\\n            } else {\\n                pred = curr.left;\\n                while (pred.right != null && pred.right != curr) { // find predecessor\\n                    pred = pred.right;\\n                }\\n                if (pred.right == curr) {\\n                    pred.right = null;\\n                    if (prev != null) {\\n                        if (curr.val <= prev.val) {\\n                            return false;\\n                        }\\n                    }\\n                    prev = curr;\\n                    curr = curr.right;\\n                } else {\\n                    pred.right = curr;\\n                    curr = curr.left;\\n                }\\n            }\\n        }\\n        \\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3272265,
                "title": "best-o-n-solution",
                "content": "# Approach\\nBest Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(h)$$ --> h is height of the BST\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if (root->left == NULL && root->right == NULL)\\n            return true;        \\n        return checkBST(root, NULL, NULL); \\n    }\\n\\n    bool checkBST(TreeNode* root, TreeNode* min, TreeNode* max) {\\n        if (root == NULL)\\n            return true;\\n        if ((min != NULL && root->val <= min->val) || (max != NULL && root->val >= max->val))\\n            return false;\\n        return checkBST(root->left, min, root) &&\\n               checkBST(root->right, root, max);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if (root->left == NULL && root->right == NULL)\\n            return true;        \\n        return checkBST(root, NULL, NULL); \\n    }\\n\\n    bool checkBST(TreeNode* root, TreeNode* min, TreeNode* max) {\\n        if (root == NULL)\\n            return true;\\n        if ((min != NULL && root->val <= min->val) || (max != NULL && root->val >= max->val))\\n            return false;\\n        return checkBST(root->left, min, root) &&\\n               checkBST(root->right, root, max);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568142,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n***Watch this video for the better explanation of the code.***\\n**Also you can SUBSCRIBE \\uD83E\\uDC83 this channel for the daily leetcode challange solution.**\\nhttps://www.youtube.com/watch?v=geBeUvcMMwo\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> & ans){\\n        if(root==NULL  ) return;\\n        helper(root->left, ans);\\n        ans.push_back(root->val);\\n         helper(root->right, ans);\\n     \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n       for(int i=0; i<ans.size()-1; i++){\\n           if( ans[i]>= ans[i+1] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**PYTHON**\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       \\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root,long minval,long maxval){\\n        if(root == null) return true;\\n        if(root.val >= maxval || root.val <= minval) return false;\\n        \\n        return isValidBST(root.left,minval,root.val) && isValidBST(root.right,root.val,maxval);\\n    }\\n}\\n```\\n**Please UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> & ans){\\n        if(root==NULL  ) return;\\n        helper(root->left, ans);\\n        ans.push_back(root->val);\\n         helper(root->right, ans);\\n     \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n       for(int i=0; i<ans.size()-1; i++){\\n           if( ans[i]>= ans[i+1] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       \\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root,long minval,long maxval){\\n        if(root == null) return true;\\n        if(root.val >= maxval || root.val <= minval) return false;\\n        \\n        return isValidBST(root.left,minval,root.val) && isValidBST(root.right,root.val,maxval);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 350343,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        return self.helper(root, float(\\'-inf\\'), float(\\'inf\\'))\\n    \\n    def helper(self, node, minVal, maxVal):\\n        if node == None:\\n            return True\\n        \\n        if node.val <= minVal or node.val >= maxVal:\\n            return False\\n        \\n        left = self.helper(node.left, minVal, node.val)\\n        right = self.helper(node.right, node.val, maxVal)\\n        \\n        return left and right         \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        return self.helper(root, float(\\'-inf\\'), float(\\'inf\\'))\\n    \\n    def helper(self, node, minVal, maxVal):\\n        if node == None:\\n            return True\\n        \\n        if node.val <= minVal or node.val >= maxVal:\\n            return False\\n        \\n        left = self.helper(node.left, minVal, node.val)\\n        right = self.helper(node.right, node.val, maxVal)\\n        \\n        return left and right         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110589,
                "title": "python-solution-with-linear-time-complexity-100-working",
                "content": "\\n        def dfs(lower,upper,node):\\n            if not node:\\n                return True\\n            elif node.val<=lower or node.val>=upper:\\n                return False\\n            else:\\n                return dfs(lower,node.val,node.left) and dfs(node.val,upper,node.right)\\n        return dfs(float(\\'-inf\\'),float(\\'inf\\'),root) \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n        def dfs(lower,upper,node):\\n            if not node:\\n                return True\\n            elif node.val<=lower or node.val>=upper:\\n                return False\\n            else:\\n                return dfs(lower,node.val,node.left) and dfs(node.val,upper,node.right)\\n        return dfs(float(\\'-inf\\'),float(\\'inf\\'),root) \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2409055,
                "title": "c-long-long-man",
                "content": "1. if you go left, set bounds to min to root->val\\n2. if you go right, set boudns to root->val to max\\n3. use long long to get away from overflow and underflows\\n**4. check out the twitch channel.  Link in profile.**\\n```\\nclass Solution {  \\n    bool dfs(TreeNode* root, long long mn, long long mx) {\\n        if(!root) return true;\\n        \\n        if(root->val <= mn || root->val >= mx) return false;\\n        \\n        bool left = dfs(root->left, mn, root->val);\\n        bool right = dfs(root->right, root->val, mx);\\n        \\n        return left && right;\\n    }\\n    \\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return dfs(root, LONG_MIN, LONG_MAX);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {  \\n    bool dfs(TreeNode* root, long long mn, long long mx) {\\n        if(!root) return true;\\n        \\n        if(root->val <= mn || root->val >= mx) return false;\\n        \\n        bool left = dfs(root->left, mn, root->val);\\n        bool right = dfs(root->right, root->val, mx);\\n        \\n        return left && right;\\n    }\\n    \\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return dfs(root, LONG_MIN, LONG_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2366749,
                "title": "python-recursion-and-recursive-stack-space-o-1-space",
                "content": "Without using a list just use prev variable to store the previous node value and check if the Tree nodes are in ascending order during the inorder traversal. You dont have to create extra space for list.\\n    \\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        self.flag = True\\n        self.prev = float(\"-inf\")\\n        self.inorder(root)\\n        return self.flag\\n\\n        \\n    def inorder(self,root):\\n        #base condition\\n        if root==None:\\n            return\\n        \\n\\n        self.inorder(root.left)\\n        \\n        if root.val<=self.prev:\\n            self.flag = False            \\n        self.prev = root.val\\n        \\n        self.inorder(root.right)",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "Without using a list just use prev variable to store the previous node value and check if the Tree nodes are in ascending order during the inorder traversal. You dont have to create extra space for list.\\n    \\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        self.flag = True\\n        self.prev = float(\"-inf\")\\n        self.inorder(root)\\n        return self.flag\\n\\n        \\n    def inorder(self,root):\\n        #base condition\\n        if root==None:\\n            return\\n        \\n\\n        self.inorder(root.left)\\n        \\n        if root.val<=self.prev:\\n            self.flag = False            \\n        self.prev = root.val\\n        \\n        self.inorder(root.right)",
                "codeTag": "Python3"
            },
            {
                "id": 344672,
                "title": "c-clear-recursive-solution-without-using-longlong-double",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root, TreeNode* nmin = nullptr, TreeNode* nmax = nullptr) {\\n        if(!root) \\n            return true;\\n        if(nmin && root->val <= nmin->val)\\n            return false;\\n        if(nmax && root->val >= nmax->val)\\n            return false;\\n        return isValidBST(root->left, nmin, root) && isValidBST(root->right, root, nmax);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root, TreeNode* nmin = nullptr, TreeNode* nmax = nullptr) {\\n        if(!root) \\n            return true;\\n        if(nmin && root->val <= nmin->val)\\n            return false;\\n        if(nmax && root->val >= nmax->val)\\n            return false;\\n        return isValidBST(root->left, nmin, root) && isValidBST(root->right, root, nmax);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229282,
                "title": "neat-java-recursive-solution",
                "content": "``` java\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, null, null);\\n    }\\n    \\n    public boolean isValidBST(TreeNode x, TreeNode min, TreeNode max) {\\n        if (x == null) return true;\\n        if (max != null && x.val >= max.val) return false;\\n        if (min != null && x.val <= min.val) return false;\\n        return isValidBST(x.left, min, x) && isValidBST(x.right, x ,max);\\n    }\\n}\\n\\n```\\n![image](https://assets.leetcode.com/users/jayomg/image_1548896395.png)\\n",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, null, null);\\n    }\\n    \\n    public boolean isValidBST(TreeNode x, TreeNode min, TreeNode max) {\\n        if (x == null) return true;\\n        if (max != null && x.val >= max.val) return false;\\n        if (min != null && x.val <= min.val) return false;\\n        return isValidBST(x.left, min, x) && isValidBST(x.right, x ,max);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32371,
                "title": "java-solution-after-adding-test-cases",
                "content": "Actually, not too much needs to be changed if you got AC code when extra test cases are not added. The only difference is add if-else condition for node's value equals INT_MAX and INT_MIN. \\n\\n    public class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            if (root == null) {\\n                return true;\\n            }\\n            if (root.left == null && root.right == null) {\\n                return true;\\n            }\\n            return check(root, Integer.MAX_VALUE, Integer.MIN_VALUE);\\n        }\\n        \\n        public boolean check(TreeNode node, int max, int min) {\\n            if (node == null) {\\n                return true;\\n            }\\n            if (node.val > max || node.val < min) {\\n                return false;\\n            }\\n    \\n            // if node's value is INT_MIN, it should not have left child any more\\n            if (node.val == Integer.MIN_VALUE && node.left != null) {\\n                return false;\\n            }\\n            \\n            // if node's value is INT_MAX, it should not have right child any more\\n            if (node.val == Integer.MAX_VALUE && node.right != null) {\\n                return false;\\n            }\\n    \\n            return check(node.left, node.val - 1, min) && check(node.right, max, node.val + 1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            if (root == null) {\\n                return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3972693,
                "title": "4-best-c-solutions-recursive-iterative-and-inorder-approach-beats-100",
                "content": "# Code\\n```\\n// Recursive solution - Using LONG_MIN anmd LONG_MAX\\nclass Solution {\\npublic: \\n    bool solve(TreeNode* root, long min, long max){\\n        if(root == NULL)   \\n            return true;\\n        \\n        if(root->val <= min || root->val >= max)  \\n            return false;\\n        \\n        return solve(root->left, min, root->val) && solve(root->right, root->val, max);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return solve(root, LONG_MIN, LONG_MAX);\\n    }\\n};\\n\\n// Recursion solution - Using nodes\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return solve(root, NULL, NULL);\\n    }\\n    \\n    bool solve(TreeNode* root, TreeNode* max, TreeNode* min){\\n        if(root==NULL){\\n            return true;\\n        }\\n\\t\\t\\n        if((min==NULL || root->val > min->val) && (max==NULL || root->val < max->val)){\\n            return solve(root->left, root, min) && solve(root->right, max, root);\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n// Iterative solution\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if(root == NULL)\\n            return true;\\n        \\n        stack<TreeNode*> s;\\n        TreeNode *pre = NULL;\\n\\n        while(root != NULL || !s.empty()){\\n            while(root != NULL){\\n                s.push(root);\\n                root = root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n            if(pre != NULL && root->val <= pre->val){\\n                return false;\\n            }\\n            pre = root;\\n            root = root->right;\\n        }\\n        return true;\\n    }\\n};\\n\\n// Check if inorder is sorted\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *root, vector<int> &ans){\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left, ans);\\n        ans.push_back(root->val);\\n        inorder(root->right, ans);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root, ans);\\n\\n        for(int i=1; i<ans.size(); i++){\\n            if(ans[i] <= ans[i-1])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n// Recursive solution - Using LONG_MIN anmd LONG_MAX\\nclass Solution {\\npublic: \\n    bool solve(TreeNode* root, long min, long max){\\n        if(root == NULL)   \\n            return true;\\n        \\n        if(root->val <= min || root->val >= max)  \\n            return false;\\n        \\n        return solve(root->left, min, root->val) && solve(root->right, root->val, max);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return solve(root, LONG_MIN, LONG_MAX);\\n    }\\n};\\n\\n// Recursion solution - Using nodes\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return solve(root, NULL, NULL);\\n    }\\n    \\n    bool solve(TreeNode* root, TreeNode* max, TreeNode* min){\\n        if(root==NULL){\\n            return true;\\n        }\\n\\t\\t\\n        if((min==NULL || root->val > min->val) && (max==NULL || root->val < max->val)){\\n            return solve(root->left, root, min) && solve(root->right, max, root);\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n// Iterative solution\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        if(root == NULL)\\n            return true;\\n        \\n        stack<TreeNode*> s;\\n        TreeNode *pre = NULL;\\n\\n        while(root != NULL || !s.empty()){\\n            while(root != NULL){\\n                s.push(root);\\n                root = root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n            if(pre != NULL && root->val <= pre->val){\\n                return false;\\n            }\\n            pre = root;\\n            root = root->right;\\n        }\\n        return true;\\n    }\\n};\\n\\n// Check if inorder is sorted\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *root, vector<int> &ans){\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left, ans);\\n        ans.push_back(root->val);\\n        inorder(root->right, ans);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        inorder(root, ans);\\n\\n        for(int i=1; i<ans.size(); i++){\\n            if(ans[i] <= ans[i-1])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982339,
                "title": "optimized-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        \\n        return check(root, LONG_MIN, LONG_MAX);\\n    }\\n\\n    bool check(TreeNode* root, long minval, long maxval ){\\n\\n        if(root==NULL) return true;\\n\\n        if(root->val >= maxval || root->val <= minval) return false;\\n\\n        return check(root->left,minval, root->val) && check(root->right, root->val, maxval);\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        \\n        return check(root, LONG_MIN, LONG_MAX);\\n    }\\n\\n    bool check(TreeNode* root, long minval, long maxval ){\\n\\n        if(root==NULL) return true;\\n\\n        if(root->val >= maxval || root->val <= minval) return false;\\n\\n        return check(root->left,minval, root->val) && check(root->right, root->val, maxval);\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410074,
                "title": "c-6-different-solutions-recursive-iteratively-in-order-traversal-check-previous",
                "content": "I came up with a few different approaches. Please let me know if you came up with another idea.\\n\\n**Solution 1: recursive with numeric limits**\\n\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        return isValidBST(root, numeric_limits<long>::min(), numeric_limits<long>::max());\\n    }\\n    \\n    bool isValidBST(TreeNode* node, long min, long max) {\\n        if (!node) return true;\\n        \\n        return\\n            (min < node->val && node->val < max) &&\\n            isValidBST(node->left, min, node->val) &&\\n            isValidBST(node->right, node->val, max);\\n    }\\n```\\n\\n**Solution 2: recursive with lower bound and upper bound node**\\n\\nIn this version we don\\'t need to make any assumptions about ```TreeNode::val```, all we care about is that they are compareable. In the following solutions we always only compare values to each other and don\\'t make any futher assumptions about there type.\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        return isValidBST(root, nullptr, nullptr);\\n    }\\n    \\n    bool isValidBST(TreeNode* node, TreeNode* lb, TreeNode* ub) {\\n        if (!node) return true;\\n        \\n        if (lb && !(lb->val < node->val)) return false;\\n        if (ub && !(node->val < ub->val)) return false;\\n        \\n        return\\n            isValidBST(node->left, lb, node) &&\\n            isValidBST(node->right, node, ub);\\n    }\\n```\\n\\n**Solution 3: interative with lower bound and upper bound node**\\n\\nWe might as well do this iteratively. We could also use a ```stack``` instead of a ```queue```.\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        if (!root) return true;\\n\\n        queue<array<TreeNode*, 3>> q;\\n        q.push({root, nullptr, nullptr});\\n        \\n        while (!empty(q)) {\\n            auto [node, lb, ub] = q.front(); q.pop();\\n            \\n            if (lb && lb->val >= node->val) return false;\\n            if (ub && ub->val <= node->val) return false;\\n            \\n            if (node->left) q.push({node->left, lb, node});\\n            if (node->right) q.push({node->right, node, ub});\\n        }\\n        \\n        return true;\\n    }\\n```\\n\\n**Solution 4: inorder traversal w/ previous node recursively**\\n\\nA different approach is to compare a node with a previous node in an inorder traversal. The values need to be asceding.\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = nullptr;\\n        return isValidBST(root, &prev);\\n    }\\n    \\n    bool isValidBST(TreeNode* root, TreeNode** prev) {\\n        if (!root) return true;\\n        \\n        if (root->left && !isValidBST(root->left, prev)) return false;\\n        \\n        // visit\\n        if (*prev && root->val <= (*prev)->val) return false;\\n        *prev = root;\\n     \\n        if (root->right && !isValidBST(root->right, prev)) return false;\\n        \\n        return true;\\n    }\\n```\\n\\n**Solution 5: inorder traversal w/ previous node iteratively**\\n\\nLike solution 4, but iteratively.\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        \\n        TreeNode* prev = nullptr;\\n        \\n        while (true) {\\n            while (root) {\\n                st.push(root);\\n                root = root->left;\\n            }\\n            \\n            if (empty(st)) break;\\n            root = st.top(); st.pop();\\n            \\n            // Visit.\\n            if (prev && prev->val >= root->val) return false;\\n            prev = root;\\n            \\n            root = root->right;\\n        }\\n        \\n        return true;\\n    }\\n```\\n\\n**Solution 6: serialise the BST and check if sequence is monotonic increasing**\\n\\nNote that ```std::is_sorted``` can\\'t be used here. This uses extra memory for the serialised sequence, which feels a bit unnecassary, but oh well, sue me. :)\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> values;\\n        stack<TreeNode*> st;\\n        \\n        while (true) {\\n            while (root) {\\n                st.push(root);\\n                root = root->left;\\n            }\\n            \\n            if (empty(st)) break;\\n            root = st.top(); st.pop();\\n\\n            // Visit.\\n            values.push_back(root->val);\\n            \\n            root = root->right;\\n        }\\n\\n        // NB. std::is_sorted can\\'t be used, because while [2,2,2] is sorted it\\'s not\\n        // strictly increasing, which is what we need to test for here.\\n        return adjacent_find(begin(values), end(values), greater_equal<>()) == end(values);\\n    }\\n```\\n\\n**Bonus Solution: custom STL iterator**\\n\\nWe can turn this into a one liner:\\n\\n```\\n    bool isValidBST(TreeNode* root) {\\n        // NB. std::is_sorted can\\'t be used, because while [2,2,2] is sorted it\\'s not\\n        // strictly increasing, which is what we need to test for here.\\n        return adjacent_find(begin(root), end(root), greater_equal<>()) == end(root);\\n    }\\n```\\n\\n... if we implement a custom iterator for ```TreeNode```. This avoids the extra memory for the ```vector<int>``` from solution 6, but this iterator is quite a have object and expensive to copy. It would take more work to make this effiecient, but it works. So to make the above could work we need something like this:\\n\\n```\\n// TODO(heder): Can we turn this into a \"lean\" iterator? This one is quite \"fat\", as it has\\n// a stack<> member.\\nstruct Iterator \\n{\\n    using iterator_category = std::forward_iterator_tag;\\n    using difference_type   = std::ptrdiff_t;\\n    using value_type        = int;\\n    using pointer           = value_type*;\\n    using reference         = value_type&;\\n    \\n    // TODO(heder): Keep the root pointer around so we know if the iterator is\\n    // from the same tree?\\n    Iterator(TreeNode* root) : curr_(root) {\\n        gotoLeftMost(curr_);\\n    }\\n    \\n    reference operator*() const { return curr_->val; }\\n    pointer operator->() { return &(curr_->val); }\\n\\n    // Prefix increment\\n    Iterator& operator++() {\\n        if (curr_) {\\n            gotoLeftMost(curr_->right);\\n        }\\n        return *this;\\n    }  \\n\\n    // Postfix increment\\n    Iterator operator++(int) { Iterator tmp = *this; ++(*this); return tmp; }\\n\\n    friend bool operator== (const Iterator& a, const Iterator& b) {\\n        return a.curr_ == b.curr_;\\n    };\\n    friend bool operator!= (const Iterator& a, const Iterator& b) { return !(a == b); }\\n    \\nprivate:\\n    stack<TreeNode*> st_;\\n    TreeNode* curr_;\\n    \\n    void gotoLeftMost(TreeNode* node) {\\n        while (node) {\\n            st_.push(node);\\n            node = node->left;\\n        }\\n        \\n        if (empty(st_)) {\\n            curr_ = nullptr;\\n        } else {\\n            curr_ = st_.top();\\n            st_.pop();\\n        }\\n    }\\n};\\n\\nstruct Iterator begin(TreeNode* root) {\\n    return Iterator(root);\\n}\\n\\nstruct Iterator end(TreeNode* root) {\\n    return Iterator(nullptr);\\n}\\n```\\n\\nComments on how to improve any of the solutions are welcome.",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n    bool isValidBST(TreeNode* root) {\\n        return isValidBST(root, numeric_limits<long>::min(), numeric_limits<long>::max());\\n    }\\n    \\n    bool isValidBST(TreeNode* node, long min, long max) {\\n        if (!node) return true;\\n        \\n        return\\n            (min < node->val && node->val < max) &&\\n            isValidBST(node->left, min, node->val) &&\\n            isValidBST(node->right, node->val, max);\\n    }\\n```\n```TreeNode::val```\n```\\n    bool isValidBST(TreeNode* root) {\\n        return isValidBST(root, nullptr, nullptr);\\n    }\\n    \\n    bool isValidBST(TreeNode* node, TreeNode* lb, TreeNode* ub) {\\n        if (!node) return true;\\n        \\n        if (lb && !(lb->val < node->val)) return false;\\n        if (ub && !(node->val < ub->val)) return false;\\n        \\n        return\\n            isValidBST(node->left, lb, node) &&\\n            isValidBST(node->right, node, ub);\\n    }\\n```\n```stack```\n```queue```\n```\\n    bool isValidBST(TreeNode* root) {\\n        if (!root) return true;\\n\\n        queue<array<TreeNode*, 3>> q;\\n        q.push({root, nullptr, nullptr});\\n        \\n        while (!empty(q)) {\\n            auto [node, lb, ub] = q.front(); q.pop();\\n            \\n            if (lb && lb->val >= node->val) return false;\\n            if (ub && ub->val <= node->val) return false;\\n            \\n            if (node->left) q.push({node->left, lb, node});\\n            if (node->right) q.push({node->right, node, ub});\\n        }\\n        \\n        return true;\\n    }\\n```\n```\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = nullptr;\\n        return isValidBST(root, &prev);\\n    }\\n    \\n    bool isValidBST(TreeNode* root, TreeNode** prev) {\\n        if (!root) return true;\\n        \\n        if (root->left && !isValidBST(root->left, prev)) return false;\\n        \\n        // visit\\n        if (*prev && root->val <= (*prev)->val) return false;\\n        *prev = root;\\n     \\n        if (root->right && !isValidBST(root->right, prev)) return false;\\n        \\n        return true;\\n    }\\n```\n```\\n    bool isValidBST(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        \\n        TreeNode* prev = nullptr;\\n        \\n        while (true) {\\n            while (root) {\\n                st.push(root);\\n                root = root->left;\\n            }\\n            \\n            if (empty(st)) break;\\n            root = st.top(); st.pop();\\n            \\n            // Visit.\\n            if (prev && prev->val >= root->val) return false;\\n            prev = root;\\n            \\n            root = root->right;\\n        }\\n        \\n        return true;\\n    }\\n```\n```std::is_sorted```\n```\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> values;\\n        stack<TreeNode*> st;\\n        \\n        while (true) {\\n            while (root) {\\n                st.push(root);\\n                root = root->left;\\n            }\\n            \\n            if (empty(st)) break;\\n            root = st.top(); st.pop();\\n\\n            // Visit.\\n            values.push_back(root->val);\\n            \\n            root = root->right;\\n        }\\n\\n        // NB. std::is_sorted can\\'t be used, because while [2,2,2] is sorted it\\'s not\\n        // strictly increasing, which is what we need to test for here.\\n        return adjacent_find(begin(values), end(values), greater_equal<>()) == end(values);\\n    }\\n```\n```\\n    bool isValidBST(TreeNode* root) {\\n        // NB. std::is_sorted can\\'t be used, because while [2,2,2] is sorted it\\'s not\\n        // strictly increasing, which is what we need to test for here.\\n        return adjacent_find(begin(root), end(root), greater_equal<>()) == end(root);\\n    }\\n```\n```TreeNode```\n```vector<int>```\n```\\n// TODO(heder): Can we turn this into a \"lean\" iterator? This one is quite \"fat\", as it has\\n// a stack<> member.\\nstruct Iterator \\n{\\n    using iterator_category = std::forward_iterator_tag;\\n    using difference_type   = std::ptrdiff_t;\\n    using value_type        = int;\\n    using pointer           = value_type*;\\n    using reference         = value_type&;\\n    \\n    // TODO(heder): Keep the root pointer around so we know if the iterator is\\n    // from the same tree?\\n    Iterator(TreeNode* root) : curr_(root) {\\n        gotoLeftMost(curr_);\\n    }\\n    \\n    reference operator*() const { return curr_->val; }\\n    pointer operator->() { return &(curr_->val); }\\n\\n    // Prefix increment\\n    Iterator& operator++() {\\n        if (curr_) {\\n            gotoLeftMost(curr_->right);\\n        }\\n        return *this;\\n    }  \\n\\n    // Postfix increment\\n    Iterator operator++(int) { Iterator tmp = *this; ++(*this); return tmp; }\\n\\n    friend bool operator== (const Iterator& a, const Iterator& b) {\\n        return a.curr_ == b.curr_;\\n    };\\n    friend bool operator!= (const Iterator& a, const Iterator& b) { return !(a == b); }\\n    \\nprivate:\\n    stack<TreeNode*> st_;\\n    TreeNode* curr_;\\n    \\n    void gotoLeftMost(TreeNode* node) {\\n        while (node) {\\n            st_.push(node);\\n            node = node->left;\\n        }\\n        \\n        if (empty(st_)) {\\n            curr_ = nullptr;\\n        } else {\\n            curr_ = st_.top();\\n            st_.pop();\\n        }\\n    }\\n};\\n\\nstruct Iterator begin(TreeNode* root) {\\n    return Iterator(root);\\n}\\n\\nstruct Iterator end(TreeNode* root) {\\n    return Iterator(nullptr);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2408926,
                "title": "daily-leetcoding-challenge-august-day-11",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 11.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/validate-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 4 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Traversal with Valid Range\n\n  \n**Approach 2:** Iterative Traversal with Valid Range\n\n  \n**Approach 3:** Recursive Inorder Traversal\n\n  \n**Approach 4:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/validate-binary-search-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1573371,
                "title": "c-easy-solution-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool solve(TreeNode* root, long long int min,long long int max){\\n        if(!root)return true;\\n        \\n        if(root->val>=max || root->val<=min)return false;\\n        \\n        return solve(root->left,min,root->val) and solve(root->right,root->val,max);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        if(!root)return true;\\n        \\n        return solve(root,-1e18,1e18);\\n    }\\n};\\n```\\n\\nHope you like it.\\n\\nPlease upvote it :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool solve(TreeNode* root, long long int min,long long int max){\\n        if(!root)return true;\\n        \\n        if(root->val>=max || root->val<=min)return false;\\n        \\n        return solve(root->left,min,root->val) and solve(root->right,root->val,max);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        if(!root)return true;\\n        \\n        return solve(root,-1e18,1e18);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 974349,
                "title": "validate-binary-search-tree-4-line-compressed-code",
                "content": "```\\npublic boolean isValidBST(TreeNode root) {\\n        return isValid(root,Long.MIN_VALUE,Long.MAX_VALUE);       \\n    }\\n    public boolean isValid(TreeNode root,long least,long max){\\n        if(root==null) return true;\\n        if(root.left!=null&&(root.left.val>=root.val||root.left.val<=least)) return false;\\n        if(root.right!=null&&(root.right.val<=root.val||root.right.val>=max)) return false;\\n        return isValid(root.left,least,root.val)&&isValid(root.right,root.val,max);\\n    }\\n```\\nfor video explanation leet code soln\\nhttps://leetcode.com/problems/validate-binary-search-tree/solution/\\n\\n**If you like it please upvote ,it inspires me **",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic boolean isValidBST(TreeNode root) {\\n        return isValid(root,Long.MIN_VALUE,Long.MAX_VALUE);       \\n    }\\n    public boolean isValid(TreeNode root,long least,long max){\\n        if(root==null) return true;\\n        if(root.left!=null&&(root.left.val>=root.val||root.left.val<=least)) return false;\\n        if(root.right!=null&&(root.right.val<=root.val||root.right.val>=max)) return false;\\n        return isValid(root.left,least,root.val)&&isValid(root.right,root.val,max);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3221320,
                "title": "java-solution-0-ms-beats-100",
                "content": "# Java Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    public boolean isValidBST(TreeNode root, long minVal, long maxVal) {\\n        if (root == null) return true;\\n        if (root.val >= maxVal || root.val <= minVal) return false;\\n        return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    public boolean isValidBST(TreeNode root, long minVal, long maxVal) {\\n        if (root == null) return true;\\n        if (root.val >= maxVal || root.val <= minVal) return false;\\n        return isValidBST(root.left, minVal, root.val) && isValidBST(root.right, root.val, maxVal);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2413874,
                "title": "easiest-3-lines-recursive-solution",
                "content": "**Easiest 3 lines recursive solution using C++.\\nSelf Explanatory**\\n```\\n    bool isBST(TreeNode* root,long min, long max){\\n        if(root==NULL) return true;\\n        if(root->val <= min || root->val >= max) return false;\\n        return isBST(root->left,min,root->val) and isBST(root->right,root->val,max);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return isBST(root, LONG_MIN, LONG_MAX);\\n     }\\n```\\n**Please UPVOTE if you like**",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n    bool isBST(TreeNode* root,long min, long max){\\n        if(root==NULL) return true;\\n        if(root->val <= min || root->val >= max) return false;\\n        return isBST(root->left,min,root->val) and isBST(root->right,root->val,max);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return isBST(root, LONG_MIN, LONG_MAX);\\n     }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2284839,
                "title": "c-easy-solution-inorder-approach-accepted",
                "content": "```\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n//function to get inorder traversal of the tree\\nvoid inorder(TreeNode* root, vector<int> &in){\\n\\tif(root){\\n\\t\\tinorder(root->left, in);\\n\\t\\tin.push_back(root->val);\\n\\t\\tinorder(root->right, in);\\n\\t}\\n}\\n\\n//once we get the inorder traversal, we\\'ll check if it\\'s strictly increasing or not \\nbool isValidBST(TreeNode* root) {\\n\\tvector<int> in;\\n\\tinorder(root, in);\\n\\tfor(int i=1; i<in.size(); i++)\\n\\t\\tif(in[i] <= in[i-1]) return false;        \\n\\n\\treturn true;\\n}\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n//function to get inorder traversal of the tree\\nvoid inorder(TreeNode* root, vector<int> &in){\\n\\tif(root){\\n\\t\\tinorder(root->left, in);\\n\\t\\tin.push_back(root->val);\\n\\t\\tinorder(root->right, in);\\n\\t}\\n}\\n\\n//once we get the inorder traversal, we\\'ll check if it\\'s strictly increasing or not \\nbool isValidBST(TreeNode* root) {\\n\\tvector<int> in;\\n\\tinorder(root, in);\\n\\tfor(int i=1; i<in.size(); i++)\\n\\t\\tif(in[i] <= in[i-1]) return false;        \\n\\n\\treturn true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2185300,
                "title": "python3-pre-order-recursive-shortest-code",
                "content": "```\\nclass Solution(object):\\n    def isValidBST(self, root, lessThan = float(\\'inf\\'), largerThan = float(\\'-inf\\')):\\n        if not root:\\n            return True\\n        if root.val <= largerThan or root.val >= lessThan:\\n            return False\\n        return self.isValidBST(root.left, min(lessThan, root.val), largerThan) and self.isValidBST(root.right, lessThan, max(root.val, largerThan))\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def isValidBST(self, root, lessThan = float(\\'inf\\'), largerThan = float(\\'-inf\\')):\\n        if not root:\\n            return True\\n        if root.val <= largerThan or root.val >= lessThan:\\n            return False\\n        return self.isValidBST(root.left, min(lessThan, root.val), largerThan) and self.isValidBST(root.right, lessThan, max(root.val, largerThan))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136196,
                "title": "c-using-2-approaches-inorder-vs-lower-upper-bound",
                "content": "# Approach 1: Recursive Traversal with Valid Range\\nThe idea above could be implemented as a recursion. One compares the node value with its upper and lower limits if they are available. Then one repeats the same step recursively for left and right subtrees.\\n\\n![image](https://assets.leetcode.com/users/images/a0d82e09-5323-4657-973c-6683c032a638_1654891625.0223632.png)\\n![image](https://assets.leetcode.com/users/images/8e604d74-3b9f-4b0c-9d69-6f76a9f8c450_1654891642.1756604.png)\\n![image](https://assets.leetcode.com/users/images/ce2197cb-2fdc-4780-9b43-fb9c6dbbed7e_1654891653.190994.png)\\n![image](https://assets.leetcode.com/users/images/0b868fbe-193f-431a-b1bc-b86c633e6afa_1654891663.4470136.png)\\n```\\nclass Solution {\\npublic:\\n    bool validate(TreeNode* root, TreeNode* low, TreeNode* high) {\\n        // Empty trees are valid BSTs.\\n        if (root == nullptr) {\\n            return true;\\n        }\\n\\n        // The current node\\'s value must be between low and high.\\n        if ((low != nullptr and root->val <= low->val) or\\n            (high != nullptr and root->val >= high->val)) {\\n            return false;\\n        }\\n\\n        // The left and right subtree must also be valid.\\n        return validate(root->right, root, high) and\\n               validate(root->left, low, root);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return validate(root, nullptr, nullptr);\\n    }\\n};\\n```\\n\\n# Complexity Analysis:-\\nTime complexity : O(N) since we visit each node exactly once.\\nSpace complexity : O(N) since we keep up to the entire tree.\\n\\n# Approach 2: Recursive Inorder Traversal\\n**Algorithm**\\nLet\\'s use the order of nodes in the inorder traversal Left -> Node -> Right.\\n![image](https://assets.leetcode.com/users/images/3e730632-50e2-41f7-8e4a-4156e66edaa5_1654891858.3544605.png)\\nHere the nodes are enumerated in the order you visit them, and you could follow 1-2-3-4-5 to compare different strategies.\\n\\nLeft -> Node -> Right order of inorder traversal means for BST that each element should be smaller than the next one.\\nHence the algorithm with O(N) time complexity and O(N) space complexity could be simple:\\nCompute inorder traversal list inorder.\\nCheck if each element in inorder is smaller than the next one.\\n![image](https://assets.leetcode.com/users/images/ca8fe881-77ad-4de0-bb88-3f52665e6637_1654891906.4635844.png)\\n# *Do we need to keep the whole inorder traversal list?*\\n***Actually, no. The last added inorder element is enough to ensure at each step that the tree is BST (or not). Hence one could merge both steps into one and reduce the used space.***\\n\\n```\\nclass Solution {\\nprivate:\\n    TreeNode* prev = nullptr;\\n\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return inorder(root);\\n    }\\n\\n    bool inorder(TreeNode* root) {\\n        if (root == nullptr) {\\n            return true;\\n        }\\n        if (!inorder(root->left)) {\\n            return false;\\n        }\\n        if (prev != nullptr && root->val <= prev->val) {\\n            return false;\\n        }\\n        prev = root;\\n        return inorder(root->right);\\n    }\\n};\\n```\\n# Complexity Analysis:-\\nTime complexity : O(N) in the worst case when the tree is a BST or the \"bad\" element is a rightmost leaf.\\nSpace complexity : O(N) for the space on the run-time stack.\\n\\n# Guys Please Don\\'t forget to upvote me.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool validate(TreeNode* root, TreeNode* low, TreeNode* high) {\\n        // Empty trees are valid BSTs.\\n        if (root == nullptr) {\\n            return true;\\n        }\\n\\n        // The current node\\'s value must be between low and high.\\n        if ((low != nullptr and root->val <= low->val) or\\n            (high != nullptr and root->val >= high->val)) {\\n            return false;\\n        }\\n\\n        // The left and right subtree must also be valid.\\n        return validate(root->right, root, high) and\\n               validate(root->left, low, root);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return validate(root, nullptr, nullptr);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    TreeNode* prev = nullptr;\\n\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return inorder(root);\\n    }\\n\\n    bool inorder(TreeNode* root) {\\n        if (root == nullptr) {\\n            return true;\\n        }\\n        if (!inorder(root->left)) {\\n            return false;\\n        }\\n        if (prev != nullptr && root->val <= prev->val) {\\n            return false;\\n        }\\n        prev = root;\\n        return inorder(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1633608,
                "title": "python-solution-easy-to-understand-inorder-traverse-explanation",
                "content": "Since the inorder traversal of a binary search tree is always in ascending order, it can be used to easily validate the BST.\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def inorder(root,arr):\\n            if not root:\\n                return\\n            inorder(root.left,arr)\\n            arr.append(root.val)\\n            inorder(root.right,arr)\\n        arr=[]\\n        inorder(root,arr)\\n        #checking whether all elements in the arr are present in ascending order\\n        #if not, then its not a valid BST\\n        for i in range(1, len(arr)): \\n            if arr[i]<=arr[i-1]:\\n                return False\\n        return True\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def inorder(root,arr):\\n            if not root:\\n                return\\n            inorder(root.left,arr)\\n            arr.append(root.val)\\n            inorder(root.right,arr)\\n        arr=[]\\n        inorder(root,arr)\\n        #checking whether all elements in the arr are present in ascending order\\n        #if not, then its not a valid BST\\n        for i in range(1, len(arr)): \\n            if arr[i]<=arr[i-1]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1548797,
                "title": "inorder-must-be-sorted-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> tree;\\n void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n   \\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        \\n        inOrder(root);\\n        for (int i=1; i<tree.size(); i++)\\n            if (tree[i] <= tree[i-1])\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> tree;\\n void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n   \\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        \\n        inOrder(root);\\n        for (int i=1; i<tree.size(); i++)\\n            if (tree[i] <= tree[i-1])\\n                return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1129042,
                "title": "python-morris-o-1-space-approach",
                "content": "For when the Interviewer asks for a space optimal i.e. O(1) BST traversal as a follow-up question.\\nThis is standard in-order morris traversal as a generator. The values yielded by Morris generator with BST should be strictly increasing in this problem.\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        def morris(root):\\n            if not root: return None\\n            curr = root\\n            while curr:\\n                if not curr.left:\\n                    yield curr.val\\n                    curr = curr.right\\n                else:\\n                    prev = curr.left\\n                    while prev.right != None and prev.right != curr:\\n                        prev = prev.right\\n                    if prev.right == None:\\n                        prev.right = curr\\n                        curr = curr.left\\n                    elif prev.right == curr:\\n                        prev.right = None\\n                        yield curr.val\\n                        curr = curr.right\\n        prev = -math.inf\\n        for val in morris(root):\\n            if val <= prev: return False\\n            prev = val\\n        return True\\n```\\nNote: Morris traversal has an O(N) time complexity, since we visit every node in the worst case. It has a O(1) space complexity, since we merely modify (change and restore) pointers during traversal and do not make use of any stack memory.\\n---\\n<img src=\"https://assets.leetcode.com/users/images/46a0cb74-af6c-48ec-8d80-6b298cbe5e4f_1616909821.403881.png\" width=700>\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        def morris(root):\\n            if not root: return None\\n            curr = root\\n            while curr:\\n                if not curr.left:\\n                    yield curr.val\\n                    curr = curr.right\\n                else:\\n                    prev = curr.left\\n                    while prev.right != None and prev.right != curr:\\n                        prev = prev.right\\n                    if prev.right == None:\\n                        prev.right = curr\\n                        curr = curr.left\\n                    elif prev.right == curr:\\n                        prev.right = None\\n                        yield curr.val\\n                        curr = curr.right\\n        prev = -math.inf\\n        for val in morris(root):\\n            if val <= prev: return False\\n            prev = val\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 794511,
                "title": "c-simple-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isBST(TreeNode* root, long top, long bottom)\\n    {\\n        if (!root)\\n            return true;\\n        if (root->val >= top)\\n            return false; \\n        if (root->val <= bottom)\\n            return false;\\n        return isBST(root->left, root->val, bottom) && isBST(root->right, top, root->val);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        if ((!root->left) && (!root->right))\\n            return true;\\n        return isBST(root, 2147483648, -2147483649);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isBST(TreeNode* root, long top, long bottom)\\n    {\\n        if (!root)\\n            return true;\\n        if (root->val >= top)\\n            return false; \\n        if (root->val <= bottom)\\n            return false;\\n        return isBST(root->left, root->val, bottom) && isBST(root->right, top, root->val);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        if ((!root->left) && (!root->right))\\n            return true;\\n        return isBST(root, 2147483648, -2147483649);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 634809,
                "title": "beats-100-maintain-min-max-ranges-java",
                "content": "Make sure to use LONG for min max ranges since there are inputs in test cases having long values.\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBSTUtil(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    boolean isValidBSTUtil(TreeNode root,long min,long max){\\n        if(root == null)\\n            return true;\\n        if(root.val <= min || root.val >= max)\\n            return false;\\n        return isValidBSTUtil(root.left,min,root.val) &&\\n            isValidBSTUtil(root.right,root.val,max);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBSTUtil(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    boolean isValidBSTUtil(TreeNode root,long min,long max){\\n        if(root == null)\\n            return true;\\n        if(root.val <= min || root.val >= max)\\n            return false;\\n        return isValidBSTUtil(root.left,min,root.val) &&\\n            isValidBSTUtil(root.right,root.val,max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581741,
                "title": "c-shortest-solution",
                "content": "This solution uses min/max borders\\n```\\npublic bool IsValidBST(TreeNode root, int? min = null, int? max = null) {\\n\\tif (root == null) return true;\\n\\tif (root.val <= min || root.val >= max) return false;\\n\\treturn IsValidBST(root.left, min, root.val) && IsValidBST(root.right, root.val, max);\\n}\\n```\\n\\nThe same in one line\\n```\\npublic bool IsValidBST(TreeNode root, int? min = null, int? max = null) => root == null || !(root.val <= min) && !(root.val >= max)\\n                                                   && IsValidBST(root.left, min, root.val) && IsValidBST(root.right, root.val, max);\\n```\\n\\nAnother solution, doesn\\'t use borders, just a value of a previous node\\n\\n```\\npublic class Solution {\\n    int? previousNode;\\n    public bool IsValidBST(TreeNode root) {\\n        if (root == null) return true;\\n        if (!IsValidBST(root.left) || root.val <= previousNode) return false;\\n        previousNode = root.val;\\n        return IsValidBST(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\npublic bool IsValidBST(TreeNode root, int? min = null, int? max = null) {\\n\\tif (root == null) return true;\\n\\tif (root.val <= min || root.val >= max) return false;\\n\\treturn IsValidBST(root.left, min, root.val) && IsValidBST(root.right, root.val, max);\\n}\\n```\n```\\npublic bool IsValidBST(TreeNode root, int? min = null, int? max = null) => root == null || !(root.val <= min) && !(root.val >= max)\\n                                                   && IsValidBST(root.left, min, root.val) && IsValidBST(root.right, root.val, max);\\n```\n```\\npublic class Solution {\\n    int? previousNode;\\n    public bool IsValidBST(TreeNode root) {\\n        if (root == null) return true;\\n        if (!IsValidBST(root.left) || root.val <= previousNode) return false;\\n        previousNode = root.val;\\n        return IsValidBST(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32203,
                "title": "javascript-recursive-o-n",
                "content": "At each function call, we check if the current node value is contained between an upper and lower bounds.\\n\\nThe upper bound is reduced each time we dive in the left branch, and the lower bound is increased each time we dive in the right branch.\\n\\nindeed, all the nodes of the left branch must be lower than the current node (including the ones in right branches as long as they are deeper), and vice versa.\\n\\n```js\\nvar isValidBST = function(root, upperBound=Infinity, lowerBound=-Infinity) {\\n  if (!root) { return true; }\\n  if (root.val >= upperBound || root.val <= lowerBound) return false;\\n \\n  return isValidBST(root.left, Math.min(upperBound, root.val), lowerBound) &&\\n         isValidBST(root.right, upperBound, Math.max(lowerBound, root.val));\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar isValidBST = function(root, upperBound=Infinity, lowerBound=-Infinity) {\\n  if (!root) { return true; }\\n  if (root.val >= upperBound || root.val <= lowerBound) return false;\\n \\n  return isValidBST(root.left, Math.min(upperBound, root.val), lowerBound) &&\\n         isValidBST(root.right, upperBound, Math.max(lowerBound, root.val));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32234,
                "title": "python-simple-and-clean-recursive-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        def valid(node, lower, upper):\\n            if not node:\\n                return True\\n            if lower is not None and node.val <= lower:\\n                return False\\n            if upper is not None and node.val >= upper:\\n                return False\\n            return valid(node.left, lower, node.val) and valid(node.right, node.val, upper)\\n        return valid(root, None, None)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        def valid(node, lower, upper):\\n            if not node:\\n                return True\\n            if lower is not None and node.val <= lower:\\n                return False\\n            if upper is not None and node.val >= upper:\\n                return False\\n            return valid(node.left, lower, node.val) and valid(node.right, node.val, upper)\\n        return valid(root, None, None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32295,
                "title": "java-solution-with-recursion",
                "content": "    public class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       return isValidBST(root,null,null);\\n       \\n    }\\n    private boolean isValidBST(TreeNode root, Integer max, Integer min){\\n           if(root==null)   return true;\\n           if(max!=null&&root.val>=max)\\n             return false;\\n           if(min!=null&&root.val<=min)\\n             return false;\\n           return isValidBST(root.left,root.val,min)&&isValidBST(root.right,max,root.val); \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       return isValidBST(root,null,null);\\n       \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 32312,
                "title": "clean-small-c-code-3-line-implementation-16ms",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        bool val(TreeNode* root,long long int minrange,long long int maxrange)\\n        {\\n            if(root==NULL)return true;\\n            if(root->val>minrange&&root->val<maxrange&&val(root->left,minrange,root->val)&&val(root->right,root->val,maxrange))return true;\\n            return false;\\n        }\\n        bool isValidBST(TreeNode* root) {\\n            return val(root,-2147483650,2147483650);\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool val(TreeNode* root,long long int minrange,long long int maxrange)\\n        {\\n            if(root==NULL)return true;\\n            if(root->val>minrange&&root->val<maxrange&&val(root->left,minrange,root->val)&&val(root->right,root->val,maxrange))return true;\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 32314,
                "title": "very-short-and-concise-java-solution-easy-to-understand",
                "content": "        public boolean isValidBST(TreeNode root) {\\n            return validateRange(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n        }\\n     \\n        private boolean validateRange(TreeNode root, long min, long max) {\\n            if (root == null) return true;\\n            if (!(root.val > min && root.val < max)) return false;\\n            return validateRange(root.left, min, (long) root.val) \\n            && validateRange(root.right, (long) root.val, max);\\n        }\\n\\nWe take advantages on the constraint of the range for the value in a BST.",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "        public boolean isValidBST(TreeNode root) {\\n            return validateRange(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n        }\\n     \\n        private boolean validateRange(TreeNode root, long min, long max) {\\n            if (root == null) return true;\\n            if (!(root.val > min && root.val < max)) return false;\\n            return validateRange(root.left, min, (long) root.val) \\n            && validateRange(root.right, (long) root.val, max);\\n        }\\n\\nWe take advantages on the constraint of the range for the value in a BST.",
                "codeTag": "Unknown"
            },
            {
                "id": 32426,
                "title": "simple-and-10-lines-c-recurive-solution",
                "content": "    class Solution {\\n        public:\\n            bool isValidBST(TreeNode *root) {\\n                long long min = LLONG_MIN, max = LLONG_MAX;\\n                return isValidBST(root, min, max);\\n            }\\n            bool isValidBST(TreeNode *node, long long min, long long max){\\n                if(node == NULL)\\n                    return true;\\n                if(node->val <= min || node->val >= max)\\n                    return false;\\n                if(!isValidBST(node->left, min, node->val) || !isValidBST(node->right, node->val, max))\\n                    return false;\\n                return true;\\n            }\\n        };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n            bool isValidBST(TreeNode *root) {\\n                long long min = LLONG_MIN, max = LLONG_MAX;\\n                return isValidBST(root, min, max);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3487254,
                "title": "simple-dfs-solution-c",
                "content": "# Intuition & Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince all the nodes in the left-sub-tree should be less than the current node, and all the nodes in the right-sub-tree should be greater than the current node, we can iterate down to check if each node satisfies the condition, that is it should be in a range (min, max) where max for nodes in left-sub-tree and min for right-sub-tree is the parent node vlaue.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) - as we need to visit all nodes once\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) - as we do not use any extra space\\n**But**, if we consider the space occupied in the memory by the stacking-recursive function call (function-call stack), we can it is O(n)\\n\\n## Please upvote if you like the approach\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool IsValidBST(TreeNode root) {\\n        return Evaluate(root, long.MinValue, long.MaxValue);\\n    }\\n\\n    private bool Evaluate(TreeNode node, long min, long max)\\n    {\\n        if (node == null)\\n        {\\n            return true;\\n        }\\n\\n        return (\\n            node.val > min &&\\n            node.val < max &&\\n            Evaluate(node.left, min, node.val) &&\\n            Evaluate(node.right, node.val, max)\\n        );\\n    }\\n}\\n```\\n\\n## Please upvote if you like the approach",
                "solutionTags": [
                    "C#",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool IsValidBST(TreeNode root) {\\n        return Evaluate(root, long.MinValue, long.MaxValue);\\n    }\\n\\n    private bool Evaluate(TreeNode node, long min, long max)\\n    {\\n        if (node == null)\\n        {\\n            return true;\\n        }\\n\\n        return (\\n            node.val > min &&\\n            node.val < max &&\\n            Evaluate(node.left, min, node.val) &&\\n            Evaluate(node.right, node.val, max)\\n        );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356533,
                "title": "java-easy-solution-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static boolean isValid(TreeNode root,TreeNode min ,TreeNode max){\\n        if(root==null){\\n            return true;\\n        }\\n        if(min!=null && root.val<=min.val){\\n            return false;\\n        }\\n        if(max!=null && root.val>=max.val){\\n            return false;\\n        }\\n        return isValid(root.left,min,root)&&isValid(root.right,root,max);\\n\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n    if(isValid(root,null,null)){\\n          return true;\\n      }\\n      else{\\n           return false;\\n    \\n      }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static boolean isValid(TreeNode root,TreeNode min ,TreeNode max){\\n        if(root==null){\\n            return true;\\n        }\\n        if(min!=null && root.val<=min.val){\\n            return false;\\n        }\\n        if(max!=null && root.val>=max.val){\\n            return false;\\n        }\\n        return isValid(root.left,min,root)&&isValid(root.right,root,max);\\n\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n    if(isValid(root,null,null)){\\n          return true;\\n      }\\n      else{\\n           return false;\\n    \\n      }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3249901,
                "title": "python3-simple-solution-uwu",
                "content": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode], min_val=float(\\'-inf\\'), max_val=float(\\'inf\\')) -> bool:\\n        if not root:\\n            return True\\n\\n        if root.val <= min_val or root.val >= max_val:\\n            return False\\n\\n        left_valid = self.isValidBST(root.left, min_val, root.val)\\n        right_valid = self.isValidBST(root.right, root.val, max_val)\\n\\n        return left_valid and right_valid\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode], min_val=float(\\'-inf\\'), max_val=float(\\'inf\\')) -> bool:\\n        if not root:\\n            return True\\n\\n        if root.val <= min_val or root.val >= max_val:\\n            return False\\n\\n        left_valid = self.isValidBST(root.left, min_val, root.val)\\n        right_valid = self.isValidBST(root.right, root.val, max_val)\\n\\n        return left_valid and right_valid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020203,
                "title": "0ms-easy-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode pre=null;\\n    public boolean isValidBST(TreeNode root) {\\n    \\n     if(root!=null){\\n         if(!isValidBST(root.left)) return false;\\n         if(pre!=null && root.val<=pre.val) return false;\\n         pre=root;\\n         return isValidBST(root.right);\\n     }   \\n     return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode pre=null;\\n    public boolean isValidBST(TreeNode root) {\\n    \\n     if(root!=null){\\n         if(!isValidBST(root.left)) return false;\\n         if(pre!=null && root.val<=pre.val) return false;\\n         pre=root;\\n         return isValidBST(root.right);\\n     }   \\n     return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2708912,
                "title": "java-easy-solution-using-recursion",
                "content": "\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n      return checker(root, null, null);  \\n    }\\n    public boolean checker(TreeNode root, Integer min, Integer max) {\\n        if(root == null) return true;\\n\\n        if((min != null && root.val <= min) || (max != null && root.val >= max))\\n        return false;\\n\\n        return checker(root.left, min, root.val) && checker(root.right, root.val, max);\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n      return checker(root, null, null);  \\n    }\\n    public boolean checker(TreeNode root, Integer min, Integer max) {\\n        if(root == null) return true;\\n\\n        if((min != null && root.val <= min) || (max != null && root.val >= max))\\n        return false;\\n\\n        return checker(root.left, min, root.val) && checker(root.right, root.val, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2431031,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n***Watch this video for the better explanation of the code.***\\n**Also you can SUBSCRIBE \\uD83E\\uDC83 this channel for the daily leetcode challange solution.**\\nhttps://www.youtube.com/watch?v=geBeUvcMMwo\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> & ans){\\n        if(root==NULL  ) return;\\n        helper(root->left, ans);\\n        ans.push_back(root->val);\\n         helper(root->right, ans);\\n     \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n       for(int i=0; i<ans.size()-1; i++){\\n           if( ans[i]>= ans[i+1] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**PYTHON**\\n\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       \\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root,long minval,long maxval){\\n        if(root == null) return true;\\n        if(root.val >= maxval || root.val <= minval) return false;\\n        \\n        return isValidBST(root.left,minval,root.val) && isValidBST(root.right,root.val,maxval);\\n    }\\n}\\n```\\n**Please UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> & ans){\\n        if(root==NULL  ) return;\\n        helper(root->left, ans);\\n        ans.push_back(root->val);\\n         helper(root->right, ans);\\n     \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> ans;\\n        helper(root, ans);\\n       for(int i=0; i<ans.size()-1; i++){\\n           if( ans[i]>= ans[i+1] ) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def valid_bst(root, min_val, max_val):\\n            if root is None:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return valid_bst(root.left, min_val, root.val) and valid_bst(root.right, root.val, max_val)\\n        return valid_bst(root, -2**31-1, 2**31)\\n```\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n       \\n        return isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root,long minval,long maxval){\\n        if(root == null) return true;\\n        if(root.val >= maxval || root.val <= minval) return false;\\n        \\n        return isValidBST(root.left,minval,root.val) && isValidBST(root.right,root.val,maxval);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2409352,
                "title": "c-2-methods-inorder-and-recursion-better-than-96-27-comments",
                "content": "Method 1: using InOrder Traversal\\n```\\nprivate:\\n\\tvector<int> tree;\\npublic:\\n\\tvoid inOrder(TreeNode* root) {\\n\\t// if root value is null\\n\\t\\tif (!root)\\n\\t\\t\\treturn;\\n\\t\\tinOrder(root->left);\\n\\t\\ttree.push_back(root->val);\\n\\t\\tinOrder(root->right);\\n\\t}\\n\\n\\tbool isValidBST(TreeNode* root) {\\n\\t\\tif (!root)\\n\\t\\t\\treturn true;\\n\\t\\t\\t\\n\\t\\t// getting the inorder traversal of the tree\\n\\t\\tinOrder(root);\\n\\t\\tfor (int i=1; i<tree.size(); i++)\\n\\t\\t\\tif (tree[i] <= tree[i-1])\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true; \\n\\t}\\n```\\n![image](https://assets.leetcode.com/users/images/245bf7a5-b24a-4d1e-96cf-bba40d32fb61_1660189798.6316102.png)\\n\\nMethod 2: using Recursion\\n```\\nbool helper(TreeNode* root, long long low, long long high){\\n\\t\\tif(!root)   return true;\\n\\t\\tif(root->val<=low || root->val>=high)   return false;\\n\\t\\treturn helper(root->left, low, root->val) && \\n\\t\\t\\t\\thelper(root->right, root->val, high);            \\n\\t}\\n\\n\\tbool isValidBST(TreeNode* root) {\\n\\t\\tif(!root)   return true;\\n\\t\\t// used long long \\n\\t\\treturn helper(root, -21474836470, 21474836470);\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\nprivate:\\n\\tvector<int> tree;\\npublic:\\n\\tvoid inOrder(TreeNode* root) {\\n\\t// if root value is null\\n\\t\\tif (!root)\\n\\t\\t\\treturn;\\n\\t\\tinOrder(root->left);\\n\\t\\ttree.push_back(root->val);\\n\\t\\tinOrder(root->right);\\n\\t}\\n\\n\\tbool isValidBST(TreeNode* root) {\\n\\t\\tif (!root)\\n\\t\\t\\treturn true;\\n\\t\\t\\t\\n\\t\\t// getting the inorder traversal of the tree\\n\\t\\tinOrder(root);\\n\\t\\tfor (int i=1; i<tree.size(); i++)\\n\\t\\t\\tif (tree[i] <= tree[i-1])\\n\\t\\t\\t\\treturn false;\\n\\t\\treturn true; \\n\\t}\\n```\n```\\nbool helper(TreeNode* root, long long low, long long high){\\n\\t\\tif(!root)   return true;\\n\\t\\tif(root->val<=low || root->val>=high)   return false;\\n\\t\\treturn helper(root->left, low, root->val) && \\n\\t\\t\\t\\thelper(root->right, root->val, high);            \\n\\t}\\n\\n\\tbool isValidBST(TreeNode* root) {\\n\\t\\tif(!root)   return true;\\n\\t\\t// used long long \\n\\t\\treturn helper(root, -21474836470, 21474836470);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2045697,
                "title": "js-simple-explained-in-order-traversal",
                "content": "# 98. Validate Binary Search Tree\\uD83D\\uDE80\\n***\\n### Solution Developed In:\\n![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E)\\n\\n## The Question\\nFor this article we will be covering Leetcode \\'[98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)\\' question. This question is rated as a **Medium** question.\\n\\nQuestion:\\n\\n> Given the `root` of a binary tree, determine if it is a valid binary search tree (BST).\\n> \\n> **A valid BST** is defined as follows:\\n> - The left subtree of a node contains only nodes with keys **less than** the `node`\\'s key.\\n> - The right subtree of a node contains only nodes with keys **greater than** the `node`\\'s key.\\n> - Both the left and right subtrees must also be binary search trees.\\n\\n\\n![BST](https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg)\\n\\nExample:\\n```\\nInput: root = [2,1,3]\\nOutput: true\\n\\n```\\n\\n## Explaining The Question\\nThis Question is rated **Medium**. Which I believe is accurate. This question is fantastic for learning about [Binary Search Trees](https://en.wikipedia.org/wiki/Binary_search_tree) and [In order Tree Traversal](https://en.wikipedia.org/wiki/Tree_traversal). \\n\\nWhat we\\'re being asked is to validate if the given Binary Search Tree is valid or not. Meaning it comply with the rules of a Binary Search Tree. Meaning all the lesser values are on the left and all the greater values are on the right.\\n \\nMany of the solutions to this questions has you focus on the `min` and `max` values throughout the tree. This is a very common approach to solving this problem. As it checks if a min or max value is violated anywhere in the tree. Now, while this is a great approach, I think their is a simpler and better way to solve it. \\n\\nThe solution I am going to explain will have transferable knowledge to lots of other issues.\\n1. [99. Recover Binary Search Tree](https://leetcode.com/problems/recover-binary-search-tree/)\\n\\n##  Recommended Knowledge\\n1. [Binary Tree](https://en.wikipedia.org/wiki/Binary_tree)\\n2. [Depth First Search](https://en.wikipedia.org/wiki/Depth-first_search)\\n3. [In-order traversal](https://en.wikipedia.org/wiki/Tree_traversal#In-order)\\n4. [Binary Search Tree](https://en.wikipedia.org/wiki/Binary_search_tree)\\n\\n## What do we know?\\n1. We have been given a ***Binary Search Tree***. It could be valid or not.\\n2. We need to validate it. \\n3. Their is always going to be at least 2 nodes. \\n\\n## How we\\'re going to do it:\\n\\nBasically, what we\\'re going to do is to traverse the Binary Tree in ***In-Order***. What this mean\\'s is that the ***NEXT*** node we visit should always be ***greater*** than the previous node. If it isn\\'t, then we know the tree is instantly invalid.\\n\\n1. Set a `flag` to `true`, this flag will be used to let us know if the tree is valid or not. By default its always valid. Until we find a node that is less than the previous node.\\n2. We will declare a previous node pointer, as we\\'re going to be keeping track of our previous node in the in-order traversal of the tree. \\n3. We will perform the in-order traversal of the tree, asking at each point in the traversal, \\'Is the current node less than the previous node?\\' If it is, then we know the tree is invalid. So we set the `flag` to `false`.\\n4. If no bad nodes are found, then we know the tree is valid and the flag remains untouched. \\n\\n## Big O Notation:\\n* Time Complexity:   *O(**n**)* | Where ***n*** is the number of nodes in our ***Binary Search Tree*** | As we\\'re going to traverse all of the nodes within the tree.\\n* Space Complexity: *O(**h**)* | Where ***h*** is the height of the ***Binary Search Tree*** | Because we\\'re going to store the height of the tree within the [Call Stack](https://en.wikipedia.org/wiki/Call_stack) due to the [in-order traversal](https://en.wikipedia.org/wiki/Tree_traversal#In-order).\\n\\n\\'***Could this be improved?***\\' Yes! [Morris Traversal](https://en.wikipedia.org/wiki/Tree_traversal#Morris_traversal) could do this problem in ***O(1) space complexity***. But [Morris Traversal](https://en.wikipedia.org/wiki/Tree_traversal#Morris_traversal) is tricky and tough to read. For the sake of simplicity, I don\\'t use it here. \\n\\n## Leetcode Results:\\n\\nSee Submission Link: \\n\\n* Runtime: 67 ms, faster than ***94.56%*** of JavaScript online submissions for Validate Binary Search Tree\\n* Memory Usage: 46.8 MB, less than ***22.46%*** of JavaScript online submissions for Validate Binary Search Tree\\n\\n[![LeetCode](https://img.shields.io/badge/LeetCode-000000?style=for-the-badge&logo=LeetCode&logoColor=#d16c06)](https://leetcode.com/submissions/detail/700878043/)\\n\\n\\n***\\n\\n# The Solution\\n```\\nvar isValidBST = function (root) {\\n    // This is the flag that will be returned\\n    // In the event we find a node that violates the BST property, we inverted the flag.\\n    let is_bst_valid = true;\\n\\n    // We will also be tracking the previous node.\\n    // This will be used to check if the current node is greater than the previous node.\\n    // As a valid BST, the previous node must be less than the current node.\\n    let prev_node = new TreeNode(-Infinity, null, null);\\n\\n    // We will traverse the tree in-order.\\n    // As a BST traversed in-order would result in something akin to a sorted array.\\n    // [1,2,3,4,5,6,7,8,9]\\n    // In the event we see something like this:\\n    // [1,2,3,4,*99,6,7,8,9,10]\\n    // We know it\\'s not a valid BST.\\n    const in_order_traverse = (node) => {\\n        \\n        // Empty tree. Base case.\\n        if (!node || !is_bst_valid) {\\n            return;\\n        }\\n\\n        // Get my left nodes.\\n        in_order_traverse(node.left);\\n\\n        // The in order section\\n        // Check if the current node is greater than the previous node.\\n        // If not, it\\'s a invalid tree\\n        if (node.val <= prev_node.val) {\\n            is_bst_valid = false;\\n        }\\n\\n        // Update the previous node.\\n        prev_node = node;\\n        in_order_traverse(node.right);\\n    };\\n\\n    in_order_traverse(root);\\n\\n    // Return the flag\\n    return is_bst_valid;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nInput: root = [2,1,3]\\nOutput: true\\n\\n```\n```\\nvar isValidBST = function (root) {\\n    // This is the flag that will be returned\\n    // In the event we find a node that violates the BST property, we inverted the flag.\\n    let is_bst_valid = true;\\n\\n    // We will also be tracking the previous node.\\n    // This will be used to check if the current node is greater than the previous node.\\n    // As a valid BST, the previous node must be less than the current node.\\n    let prev_node = new TreeNode(-Infinity, null, null);\\n\\n    // We will traverse the tree in-order.\\n    // As a BST traversed in-order would result in something akin to a sorted array.\\n    // [1,2,3,4,5,6,7,8,9]\\n    // In the event we see something like this:\\n    // [1,2,3,4,*99,6,7,8,9,10]\\n    // We know it\\'s not a valid BST.\\n    const in_order_traverse = (node) => {\\n        \\n        // Empty tree. Base case.\\n        if (!node || !is_bst_valid) {\\n            return;\\n        }\\n\\n        // Get my left nodes.\\n        in_order_traverse(node.left);\\n\\n        // The in order section\\n        // Check if the current node is greater than the previous node.\\n        // If not, it\\'s a invalid tree\\n        if (node.val <= prev_node.val) {\\n            is_bst_valid = false;\\n        }\\n\\n        // Update the previous node.\\n        prev_node = node;\\n        in_order_traverse(node.right);\\n    };\\n\\n    in_order_traverse(root);\\n\\n    // Return the flag\\n    return is_bst_valid;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1828680,
                "title": "java-recursive-approach-100-faster",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        //for every node, maintain upper bound and lowerbound\\n        //helper func(root, lower bound, upper bound) - for recursion\\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    boolean helper(TreeNode root, long min, long max){\\n        if(root==null)\\n            return true;\\n        if(root.val<=min || root.val>=max)\\n            return false;\\n        //update the lower bound for right subtree and upper bound for left subtree\\n        return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n    }\\n}\\n```\\nPlease upvote if it helps!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        //for every node, maintain upper bound and lowerbound\\n        //helper func(root, lower bound, upper bound) - for recursion\\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    boolean helper(TreeNode root, long min, long max){\\n        if(root==null)\\n            return true;\\n        if(root.val<=min || root.val>=max)\\n            return false;\\n        //update the lower bound for right subtree and upper bound for left subtree\\n        return helper(root.left, min, root.val) && helper(root.right, root.val, max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628160,
                "title": "java-solution-inorder-traversal",
                "content": "We have used here the concept that if it a BST then while traversing it in inoder we will get an increasing order array or list whatever you have used in inorder to collect.\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        helper(root,list);\\n        System.out.println(list);\\n        for(int i =0;i<list.size()-1;i++){\\n            if(list.get(i+1)<=list.get(i)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public List<Integer> helper(TreeNode root,ArrayList<Integer> list){\\n        if(root==null){\\n            return new ArrayList<>();\\n        }\\n        \\n       helper(root.left,list);\\n        \\n        list.add(root.val);\\n      helper(root.right,list);\\n        \\n        \\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        helper(root,list);\\n        System.out.println(list);\\n        for(int i =0;i<list.size()-1;i++){\\n            if(list.get(i+1)<=list.get(i)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    public List<Integer> helper(TreeNode root,ArrayList<Integer> list){\\n        if(root==null){\\n            return new ArrayList<>();\\n        }\\n        \\n       helper(root.left,list);\\n        \\n        list.add(root.val);\\n      helper(root.right,list);\\n        \\n        \\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382524,
                "title": "c-fast-well-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> res; // to store inorder order traversal\\n    void solve(TreeNode* root) {\\n        if(root == NULL) return; // Base Condition\\n        solve(root->left); // Left subtree\\n        res.push_back(root->val); // Keep pushing elements in in-order manner\\n        solve(root->right); // Right subtree\\n    }\\n    bool isValidBST(TreeNode* root) {   \\n        solve(root); // fill the vector in in-order manner\\n        for(int i=1; i<res.size(); i++) {\\n            if(res[i] <= res[i-1]) // If this occurs, BST condition violates\\n                return false; // Not a valid BST\\n        }\\n        return true; // All fine if u reached here, BST is valid\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> res; // to store inorder order traversal\\n    void solve(TreeNode* root) {\\n        if(root == NULL) return; // Base Condition\\n        solve(root->left); // Left subtree\\n        res.push_back(root->val); // Keep pushing elements in in-order manner\\n        solve(root->right); // Right subtree\\n    }\\n    bool isValidBST(TreeNode* root) {   \\n        solve(root); // fill the vector in in-order manner\\n        for(int i=1; i<res.size(); i++) {\\n            if(res[i] <= res[i-1]) // If this occurs, BST condition violates\\n                return false; // Not a valid BST\\n        }\\n        return true; // All fine if u reached here, BST is valid\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218926,
                "title": "intuition-explained-dfs-solution",
                "content": "This is a good problem that is based on a fundamental tree principle, which is the inorder traversal. The important take away of the inorder traversal is that it returns the values of a valid binary tree in sorted order. Keeping that in mind if a binary tree is invalid then it\\'s inordere traversal will also be unsorted. \\nThat is what we are doing in the solution we first store the inorder values of the binary tree using the inorder traversal into the inorder vector and then check if the vector is sorted or not and based on that we return true or false.\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> &inorder) {\\n        \\n        if(root == NULL) \\n            return;\\n        helper(root->left, inorder);\\n        inorder.push_back(root->val);\\n        helper(root->right, inorder);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        \\n        vector<int> inorder;\\n        helper(root, inorder);\\n        \\n        int n = inorder.size();\\n        \\n        for(int i=1;i<n;i++) {\\n            if(inorder[i-1]  >= inorder[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root, vector<int> &inorder) {\\n        \\n        if(root == NULL) \\n            return;\\n        helper(root->left, inorder);\\n        inorder.push_back(root->val);\\n        helper(root->right, inorder);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        \\n        vector<int> inorder;\\n        helper(root, inorder);\\n        \\n        int n = inorder.size();\\n        \\n        for(int i=1;i<n;i++) {\\n            if(inorder[i-1]  >= inorder[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1045913,
                "title": "python-bfs",
                "content": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return False\\n        queue = collections.deque([(root, float(\"-inf\"), float(\"inf\"))])\\n        \\n        while queue:\\n            currNode, min, max = queue.popleft()\\n            \\n            if currNode.val <= min or currNode.val >= max:\\n                return False\\n            \\n            if currNode.left:\\n                queue.append((currNode.left, min, currNode.val))\\n            if currNode.right:\\n                queue.append((currNode.right, currNode.val, max))\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        if not root:\\n            return False\\n        queue = collections.deque([(root, float(\"-inf\"), float(\"inf\"))])\\n        \\n        while queue:\\n            currNode, min, max = queue.popleft()\\n            \\n            if currNode.val <= min or currNode.val >= max:\\n                return False\\n            \\n            if currNode.left:\\n                queue.append((currNode.left, min, currNode.val))\\n            if currNode.right:\\n                queue.append((currNode.right, currNode.val, max))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044174,
                "title": "python-3-inorder-traversal-increasing-order-check-91",
                "content": "```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        q = []\\n        def dfs(node):\\n            if not node:\\n                return \\n            dfs(node.left)\\n            q.append(node.val)\\n            dfs(node.right)\\n        dfs(root)\\n        \\n        for i in range(1,len(q)):\\n            if q[i-1]>=q[i]:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: TreeNode) -> bool:\\n        q = []\\n        def dfs(node):\\n            if not node:\\n                return \\n            dfs(node.left)\\n            q.append(node.val)\\n            dfs(node.right)\\n        dfs(root)\\n        \\n        for i in range(1,len(q)):\\n            if q[i-1]>=q[i]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976329,
                "title": "my-simple-recursive-approach-in-python",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        \\n        def check(root, low_range=float(\\'-inf\\'), high_range=float(\\'inf\\')):\\n            if not root:\\n                return True\\n            elif not low_range < root.val < high_range:\\n                return False\\n            \\n            return check(root.left, low_range, root.val) and check(root.right, root.val, high_range)\\n        \\n        return check(root)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: bool\\n        \"\"\"\\n        \\n        def check(root, low_range=float(\\'-inf\\'), high_range=float(\\'inf\\')):\\n            if not root:\\n                return True\\n            elif not low_range < root.val < high_range:\\n                return False\\n            \\n            return check(root.left, low_range, root.val) and check(root.right, root.val, high_range)\\n        \\n        return check(root)\\n",
                "codeTag": "Java"
            },
            {
                "id": 885601,
                "title": "easy-js-solution",
                "content": "```\\n\\n/*\\nUse DFS to traverse all nodes.\\nAt each node, we check if it is a valid BST tree.\\nFor a tree to be a valid BST, its left subtree and right subtree must be valid BSTs and\\nits node value should be less than some value and greater than some value. These \\'some\\' values are updated at every node and passed to the next node.\\n*/\\nvar isValidBST = function(root) {\\n    return isValidBSTHelper(root, -Infinity, Infinity);\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nconst isValidBSTHelper = (root, low, high) => {\\n    if (!root) {\\n        return true;\\n    }\\n    return root.val > low && root.val < high &&\\n        isValidBSTHelper(root.left, low, root.val) &&\\n        isValidBSTHelper(root.right, root.val, high);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/*\\nUse DFS to traverse all nodes.\\nAt each node, we check if it is a valid BST tree.\\nFor a tree to be a valid BST, its left subtree and right subtree must be valid BSTs and\\nits node value should be less than some value and greater than some value. These \\'some\\' values are updated at every node and passed to the next node.\\n*/\\nvar isValidBST = function(root) {\\n    return isValidBSTHelper(root, -Infinity, Infinity);\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nconst isValidBSTHelper = (root, low, high) => {\\n    if (!root) {\\n        return true;\\n    }\\n    return root.val > low && root.val < high &&\\n        isValidBSTHelper(root.left, low, root.val) &&\\n        isValidBSTHelper(root.right, root.val, high);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 819530,
                "title": "c-upper-and-lower-bound",
                "content": "\\nCan\\'t use INT_MIN and INT_MAX because of one beautiful test case :(\\n```\\nclass Solution {\\npublic:\\n    \\n    bool traverse(TreeNode* root,long long int lowerb,long long int upperb){\\n        if(!root){\\n            return true;\\n        }\\n        if(root->val<=lowerb || root->val>=upperb){\\n            return false;\\n        }\\n        return traverse(root->left,lowerb,root->val) && traverse(root->right,root->val,upperb);\\n        \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        \\n        return traverse(root,LLONG_MIN,LLONG_MAX);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool traverse(TreeNode* root,long long int lowerb,long long int upperb){\\n        if(!root){\\n            return true;\\n        }\\n        if(root->val<=lowerb || root->val>=upperb){\\n            return false;\\n        }\\n        return traverse(root->left,lowerb,root->val) && traverse(root->right,root->val,upperb);\\n        \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        \\n        return traverse(root,LLONG_MIN,LLONG_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 265189,
                "title": "inorder-preorder-and-postorder-solution",
                "content": "In interview, it\\'s possible to be asked to implement this question in all of three tree traversal methods. If you like my solution, please upvote!\\n\\nPreorder maintains a interval in the search function\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    \\n    private boolean helper(TreeNode root, long lo, long hi) {\\n        if (root == null) return true;\\n        if (root.val >= hi || root.val <= lo) return false;\\n        return helper(root.left, lo, root.val) && helper(root.right, root.val, hi);\\n    }\\n}\\n```\\n\\nInorder maintains a previous node to compare with the current node\\n```\\nclass Solution {\\n    private TreeNode prev;\\n    \\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root);\\n    }\\n    \\n    private boolean helper(TreeNode root) {\\n        if (root == null) return true;\\n        if (!helper(root.left)) return false;\\n        if (prev != null && prev.val >= root.val) return false;\\n        prev = root;\\n        return helper(root.right);\\n    }\\n}\\n```\\n\\nPostorder should return a interval which represents the lower and upper bound of the subtree\\n```\\nclass Solution {\\n    private boolean ans;\\n    \\n    public boolean isValidBST(TreeNode root) {\\n        ans = true;\\n        postorder(root);\\n        return ans;\\n    }\\n    \\n    private int[] postorder(TreeNode root) {\\n        if (root == null) return null;\\n        int[] left = postorder(root.left);\\n        int[] right = postorder(root.right);\\n        if (left != null && left[1] >= root.val) ans = false;\\n        if (right != null && right[0] <= root.val) ans = false; \\n        int[] tmp = new int[2];\\n        tmp[0] = left == null ? root.val : left[0];\\n        tmp[1] = right == null ? root.val : right[1];\\n        return tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    \\n    private boolean helper(TreeNode root, long lo, long hi) {\\n        if (root == null) return true;\\n        if (root.val >= hi || root.val <= lo) return false;\\n        return helper(root.left, lo, root.val) && helper(root.right, root.val, hi);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private TreeNode prev;\\n    \\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root);\\n    }\\n    \\n    private boolean helper(TreeNode root) {\\n        if (root == null) return true;\\n        if (!helper(root.left)) return false;\\n        if (prev != null && prev.val >= root.val) return false;\\n        prev = root;\\n        return helper(root.right);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private boolean ans;\\n    \\n    public boolean isValidBST(TreeNode root) {\\n        ans = true;\\n        postorder(root);\\n        return ans;\\n    }\\n    \\n    private int[] postorder(TreeNode root) {\\n        if (root == null) return null;\\n        int[] left = postorder(root.left);\\n        int[] right = postorder(root.right);\\n        if (left != null && left[1] >= root.val) ans = false;\\n        if (right != null && right[0] <= root.val) ans = false; \\n        int[] tmp = new int[2];\\n        tmp[0] = left == null ? root.val : left[0];\\n        tmp[1] = right == null ? root.val : right[1];\\n        return tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32114,
                "title": "pyhton-beats-99-77-iterative",
                "content": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        stack = [None]\\n        prev = -float(\"inf\")\\n        while stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            x = stack.pop()\\n            if x:\\n                if x.val <= prev:\\n                    return False\\n                prev = x.val\\n                root = x.right\\n                \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def isValidBST(self, root):\\n        stack = [None]\\n        prev = -float(\"inf\")\\n        while stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            x = stack.pop()\\n            if x:\\n                if x.val <= prev:\\n                    return False\\n                prev = x.val\\n                root = x.right\\n                \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 32350,
                "title": "share-my-java-inorder-simple-solution",
                "content": "    public class Solution {\\n        long tmp =Long.MIN_VALUE;\\n        public boolean isValidBST(TreeNode root) {\\n            if(root != null){\\n                boolean left = isValidBST(root.left);\\n                if(root.val<=tmp)\\n                    return false;\\n                tmp = root.val;\\n                boolean right = isValidBST(root.right);\\n                if(!left || !right)\\n                    return false;\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        long tmp =Long.MIN_VALUE;\\n        public boolean isValidBST(TreeNode root) {\\n            if(root != null){\\n                boolean left = isValidBST(root.left);\\n                if(root.val<=tmp)\\n                    return false;\\n                tmp = root.val;\\n                boolean right = isValidBST(root.right);\\n                if(!left || !right)\\n                    return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 32421,
                "title": "simple-java-recursion-solution",
                "content": "    public class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return isValidBST(root,null,null); \\n            \\n        }\\n        public boolean isValidBST(TreeNode root, TreeNode min, TreeNode max) {\\n            if(root==null) return true;\\n            if(min!=null && root.val<=min.val) return false;\\n            if(max!=null && root.val>=max.val) return false;\\n            if(!isValidBST(root.left, min, root)) return false;\\n            if(!isValidBST(root.right, root, max)) return false;\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isValidBST(TreeNode root) {\\n            return isValidBST(root,null,null); \\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3344154,
                "title": "beats-100-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBs(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n\\n        public boolean isValidBs(TreeNode root, long min, long max){\\n        if(root == null)return true;\\n        if(root.val<= min || root.val >= max) return false;\\n        boolean left= isValidBs(root.left,min,root.val);\\n        boolean right = isValidBs(root.right,root.val,max);\\n        return left && right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBs(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n\\n        public boolean isValidBs(TreeNode root, long min, long max){\\n        if(root == null)return true;\\n        if(root.val<= min || root.val >= max) return false;\\n        boolean left= isValidBs(root.left,min,root.val);\\n        boolean right = isValidBs(root.right,root.val,max);\\n        return left && right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168283,
                "title": "without-inorder-easy-solution-o-n",
                "content": "\\n```\\nclass Solution {\\npublic:\\n\\n    bool isbst(TreeNode* root, long min, long max){\\n        // Base Case\\n        if( root == NULL) return true;\\n        \\n        if(root->val > min && root->val < max){\\n            bool left = isbst(root->left,min,root->val);\\n            bool right = isbst(root->right, root->val, max);\\n\\n            return left && right;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        return isbst(root, LONG_MIN,LONG_MAX);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isbst(TreeNode* root, long min, long max){\\n        // Base Case\\n        if( root == NULL) return true;\\n        \\n        if(root->val > min && root->val < max){\\n            bool left = isbst(root->left,min,root->val);\\n            bool right = isbst(root->right, root->val, max);\\n\\n            return left && right;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        return isbst(root, LONG_MIN,LONG_MAX);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823221,
                "title": "best-solution-java",
                "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public static boolean check(TreeNode root , TreeNode min , TreeNode max){\\n        if(root == null ) return true;\\n        \\n        if(min!= null  && root.val<=min.val) return false;\\n        else if(max!=null && root.val>=max.val) return false;\\n        \\n        return check(root.left,min,root ) && check(root.right , root,max);\\n        }\\n    \\n    public boolean isValidBST(TreeNode root) {\\n       return check(root,null,null);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public static boolean check(TreeNode root , TreeNode min , TreeNode max){\\n        if(root == null ) return true;\\n        \\n        if(min!= null  && root.val<=min.val) return false;\\n        else if(max!=null && root.val>=max.val) return false;\\n        \\n        return check(root.left,min,root ) && check(root.right , root,max);\\n        }\\n    \\n    public boolean isValidBST(TreeNode root) {\\n       return check(root,null,null);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803203,
                "title": "java-solution",
                "content": "The idea is to check every node for lower and upper bound\\n```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    public boolean helper(TreeNode root, long l, long r){\\n        if(root==null)return true;\\n\\n        if(root.val<=l || root.val>=r)return false;\\n\\n        return helper(root.right,root.val,r) && helper(root.left,l,root.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return helper(root,Long.MIN_VALUE,Long.MAX_VALUE);\\n    }\\n    public boolean helper(TreeNode root, long l, long r){\\n        if(root==null)return true;\\n\\n        if(root.val<=l || root.val>=r)return false;\\n\\n        return helper(root.right,root.val,r) && helper(root.left,l,root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410319,
                "title": "dfs-post-order-full-visual-explanation-with-image",
                "content": "Take the time to read the post, it explains the intuition fully. Practice makes perfect :)\\n\\nIf you found this post helpful, please upvote <3\\n\\n<hr />\\n\\n# Terminology\\nFirst, let\\'s recall what is a `binary search tree`.\\n\\nBinary search tree is simply a binary tree where all values to the **left are smaller** than the current node\\'s value, and all values to the **right are bigger** than the current node\\'s value.\\n\\nSome examples of BSTs:\\n\\n![image](https://assets.leetcode.com/users/images/7c25afb7-1d9f-4ef4-a557-d08c948e309e_1660204948.035542.png)\\n\\nNow with this understanding, let\\'s tackle the problem.\\n\\n# Intuition\\n\\nKnowing what is a BST, we need to think about the **local constraints** for each subtree.\\n\\nWhenever we are working with binary trees (or any recursive data structure) we should think how to \"validate\" a subtree (subproblem), and return that answer to the parent to recursively continue the process.\\n\\n\\nLet\\'s take the previous tree as an example:\\n\\n**EDIT:** the arrows may confuse some readers. The current value must be smaller than the green arrow, and bigger than blue arrow.\\n\\n![image](https://assets.leetcode.com/users/images/621eb95b-9e0a-48c6-9a09-6a7ad11fd986_1660205256.1745734.png)\\n\\n\\nWe know that the current subtree of value 4, must bigger than 3, but also smaller than the parent that branched left (because all values on the left are smaller), which is 5.\\n\\nLet\\'s call them `parent_minimum` and `parent_maximum` values.\\n\\nLet\\'s take the another example:\\n\\n![image](https://assets.leetcode.com/users/images/8e00a212-89e9-489c-ad28-4cdee52174b6_1660205364.6228054.png)\\n\\nWe know that the subtree with value 6 must be smaller than 7, because 7 is located to the right of that subtree. But also 6 must be greater than 5, because 5 is located to the left, hence the values is smaller.\\n\\nWith this idea we have everything to write the code\\n\\n# Algorithm\\nThe algorithm will run a post order DFS traversal, to first validate left and right subtrees.\\n\\nIf both subtrees are valid, we will check the constraints discussed above.\\n\\nWhenever we branch left, the current node value is the `parent_maximum`, because all values to the left must be smaller.\\n\\nWhenever we branch right, the current node value is the `parent_minimum`, because all values to the right must be greater.\\n\\n# Code\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def is_valid_root(node, parent_maximum, parent_minimum):\\n            if not node: return True\\n            \\n            # Check left side\\n            if not is_valid_root(node.left, node.val, parent_minimum): return False\\n            \\n            # Check right side\\n            if not is_valid_root(node.right, parent_maximum ,node.val): return False\\n            \\n            # Check constraints with current node\\n            if node.val >= parent_maximum or node.val <= parent_minimum: return False\\n            \\n            # Otherwise we are good\\n            return True\\n            \\n        \\n        return is_valid_root(root, float(\\'inf\\'), float(\\'-inf\\'))\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        \\n        def is_valid_root(node, parent_maximum, parent_minimum):\\n            if not node: return True\\n            \\n            # Check left side\\n            if not is_valid_root(node.left, node.val, parent_minimum): return False\\n            \\n            # Check right side\\n            if not is_valid_root(node.right, parent_maximum ,node.val): return False\\n            \\n            # Check constraints with current node\\n            if node.val >= parent_maximum or node.val <= parent_minimum: return False\\n            \\n            # Otherwise we are good\\n            return True\\n            \\n        \\n        return is_valid_root(root, float(\\'inf\\'), float(\\'-inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410270,
                "title": "c-3-approach",
                "content": "In this question we are given an Binary Tree and we have to create a program that check given Binary Tree is Binary Search Tree or not \\nA valid BST mean:\\n* Value of root should be greater than all left nodes\\n* Value of root should be lesser than all right nodes\\n## Approach1:\\n1.  Get maximum from leftsubtree and store it in leftmax variable.\\n2.  Get minimum from rightsubtree and store it in rightmin variable \\n3. leftmax should be smaller than node value and rightmin should be greater than node value if it is then we made two recursive call to check left subtree and right subtree for that node.\\n4. if this won\\'t happen or condition is false then our BST isn\\'t valid BST. \\n5. The reason why we use long long and LONG_MAX or LONG_MIN because of its constraint -2^31 <= Node.val <= 2^31 - 1 at testcase no. 72 that is [2147483647] that why our INT_MIN and INT_MAX won\\'t work for that testcase so we use long long , LONG_MAX , LONG_MIN.\\n5. Reason why we create min,max function it can work only for int , if value is not in integer range so it won\\'t work .\\n```\\nclass Solution {\\npublic:\\n\\n  long long functionmin(long long  a,long long b)\\n    {\\n        if(a>b)\\n        {\\n            return b;\\n        }\\n        else\\n        {\\n            return a;\\n        }\\n    }\\n    long long functionmax(long long a,long long b)\\n    {\\n\\n        if(a>b)\\n        {\\n            return a;\\n        }\\n        else\\n        {\\n            return b;\\n        }\\n    }\\n    \\n    long long Minimum(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return LONG_MAX;\\n        }\\n        return functionmin(root->val,functionmin(Minimum(root->left),Minimum(root->right)));\\n        \\n    }\\n    long long Maximum(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return LONG_MIN;\\n        }\\n        return functionmax(root->val,functionmax(Maximum(root->left),Maximum(root->right)));\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        long long  leftmax=Maximum(root->left);\\n        long long  rightmin=Minimum(root->right);\\n       \\n        return (root->val>leftmax)&&(root->val<rightmin)&&isValidBST(root->left)&&isValidBST(root->right);\\n        \\n        \\n    }\\n};\\n\\n```\\n\\n## Approach2\\n\\n1. This is similar as first approach but its Time Complexity is lesser than first appraoch because in this appraoch we\\'ll not call minimum and maximum function at every recursive call.\\n2. We\\'re creating a class that hold minimum ,maximum and isBst of tree .\\n3. Leftoutput and rightoutput contain max,min,isbst for respective subtrees.\\n4. Leftoutput->isBst and Rightoutput->isBst should be true , Rightoutput.minimum value should be greater than root value and Leftoutput.maximum value should be lesse than root value whether it is true or false ,we store it in output.bst and we also calculate  minimum and maximum for output.\\n```\\nclass Solution {\\npublic:\\n      long long min(long long  a,long long b)\\n    {\\n        if(a>b)\\n        {\\n            return b;\\n        }\\n        else\\n        {\\n            return a;\\n        }\\n    }\\n    long long max(long long a,long long b)\\n    {\\n\\n        if(a>b)\\n        {\\n            return a;\\n        }\\n        else\\n        {\\n            return b;\\n        }\\n    }\\n    class CheckBst\\n    {\\n        public:\\n        long long maximum;\\n        long long minimum;\\n        bool isbst;\\n    };\\n    CheckBst Helper(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            CheckBst output;\\n            output.maximum=LONG_MIN;\\n            output.minimum=LONG_MAX;\\n            output.isbst=true;\\n            return output;\\n        }\\n        CheckBst leftoutput=Helper(root->left);\\n        CheckBst rightoutput=Helper(root->right);\\n        CheckBst output;\\n        output.isbst=(leftoutput.isbst)&&(rightoutput.isbst)&&(leftoutput.maximum<root->val)&&(rightoutput.minimum>root->val);\\n        output.maximum=max(root->val,max(leftoutput.maximum,rightoutput.maximum));\\n        output.minimum=min(root->val,min(leftoutput.minimum,rightoutput.minimum));\\n        return output;\\n        \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        \\nCheckBst ans=Helper(root);\\n        return ans.isbst;\\n    }\\n};\\n```\\n\\n## Approach3\\n![image](https://assets.leetcode.com/users/images/60971896-df7f-478d-bbaa-63eba83be334_1660201230.3960164.jpeg =250x)`\\ncheck  \\u261D\\uFE0F image to understand more\\n1. Range of value of left node is between -\\u221E to root value\\n2. Range of value of right node is between  root value to \\u221E\\n3. Root value should be within the range of maxi and mini if it\\'s value out of the  bound then we we return false \\n```\\n\\nclass Solution {\\npublic:\\n\\n  \\n    bool isValidBST(TreeNode* root,long long maxi=LONG_MAX,long long mini=LONG_MIN) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        if(root->val>=maxi||root->val<=mini)\\n        {\\n            return false;\\n        }\\n        \\n        return isValidBST(root->left,root->val,mini)&&(isValidBST(root->right,maxi,root->val));          \\n        \\n    }\\n};\\n\\n```\\n\\nIf it helpful for you then make sure you upvote it\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n  long long functionmin(long long  a,long long b)\\n    {\\n        if(a>b)\\n        {\\n            return b;\\n        }\\n        else\\n        {\\n            return a;\\n        }\\n    }\\n    long long functionmax(long long a,long long b)\\n    {\\n\\n        if(a>b)\\n        {\\n            return a;\\n        }\\n        else\\n        {\\n            return b;\\n        }\\n    }\\n    \\n    long long Minimum(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return LONG_MAX;\\n        }\\n        return functionmin(root->val,functionmin(Minimum(root->left),Minimum(root->right)));\\n        \\n    }\\n    long long Maximum(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return LONG_MIN;\\n        }\\n        return functionmax(root->val,functionmax(Maximum(root->left),Maximum(root->right)));\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        long long  leftmax=Maximum(root->left);\\n        long long  rightmin=Minimum(root->right);\\n       \\n        return (root->val>leftmax)&&(root->val<rightmin)&&isValidBST(root->left)&&isValidBST(root->right);\\n        \\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n      long long min(long long  a,long long b)\\n    {\\n        if(a>b)\\n        {\\n            return b;\\n        }\\n        else\\n        {\\n            return a;\\n        }\\n    }\\n    long long max(long long a,long long b)\\n    {\\n\\n        if(a>b)\\n        {\\n            return a;\\n        }\\n        else\\n        {\\n            return b;\\n        }\\n    }\\n    class CheckBst\\n    {\\n        public:\\n        long long maximum;\\n        long long minimum;\\n        bool isbst;\\n    };\\n    CheckBst Helper(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            CheckBst output;\\n            output.maximum=LONG_MIN;\\n            output.minimum=LONG_MAX;\\n            output.isbst=true;\\n            return output;\\n        }\\n        CheckBst leftoutput=Helper(root->left);\\n        CheckBst rightoutput=Helper(root->right);\\n        CheckBst output;\\n        output.isbst=(leftoutput.isbst)&&(rightoutput.isbst)&&(leftoutput.maximum<root->val)&&(rightoutput.minimum>root->val);\\n        output.maximum=max(root->val,max(leftoutput.maximum,rightoutput.maximum));\\n        output.minimum=min(root->val,min(leftoutput.minimum,rightoutput.minimum));\\n        return output;\\n        \\n    }\\n    bool isValidBST(TreeNode* root) {\\n        \\nCheckBst ans=Helper(root);\\n        return ans.isbst;\\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n\\n  \\n    bool isValidBST(TreeNode* root,long long maxi=LONG_MAX,long long mini=LONG_MIN) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        if(root->val>=maxi||root->val<=mini)\\n        {\\n            return false;\\n        }\\n        \\n        return isValidBST(root->left,root->val,mini)&&(isValidBST(root->right,maxi,root->val));          \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2197682,
                "title": "python-recursive-and-iterative-solutions",
                "content": "Recursive solution:\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def helper(root, min_val=float(\"-inf\"), max_val=float(\"inf\")):\\n            if root is None:\\n                return True\\n            \\n            return (min_val < root.val < max_val and helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val))\\n        return helper(root)\\n```\\n\\nIterative Solution:\\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        queue = deque()\\n        queue.append((root, float(\"-inf\"), float(\"inf\")))\\n        \\n        while queue:\\n            node, min_val, max_val = queue.popleft()\\n            if node:\\n                if min_val >= node.val or node.val >= max_val:\\n                    return False\\n                if node.left:\\n                    queue.append((node.left, min_val, node.val))\\n                \\n                if node.right:\\n                    queue.append((node.right, node.val, max_val))\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def helper(root, min_val=float(\"-inf\"), max_val=float(\"inf\")):\\n            if root is None:\\n                return True\\n            \\n            return (min_val < root.val < max_val and helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val))\\n        return helper(root)\\n```\n```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        queue = deque()\\n        queue.append((root, float(\"-inf\"), float(\"inf\")))\\n        \\n        while queue:\\n            node, min_val, max_val = queue.popleft()\\n            if node:\\n                if min_val >= node.val or node.val >= max_val:\\n                    return False\\n                if node.left:\\n                    queue.append((node.left, min_val, node.val))\\n                \\n                if node.right:\\n                    queue.append((node.right, node.val, max_val))\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965947,
                "title": "c-with-explanation-inordertravrsal-recursion-98-validate-binary-search-tree",
                "content": "If The **Inorder** **traversal** of the given **BST** gives values in **Sorted** **order** then the given **BST** **will** **be** **valid** else BST will be invalid  \\n\\n\\t class Solution {\\n\\t\\tpublic:\\n\\t\\t   void inorder(TreeNode*root,vector<int>&ans)\\n\\t\\t   {\\n\\t\\t\\t   if(!root) return;\\n\\t\\t\\t   inorder(root->left,ans);\\n\\t\\t\\t   ans.push_back(root->val);\\n\\t\\t\\t   inorder(root->right,ans);\\n\\t\\t   }\\n\\t\\t\\tbool isValidBST(TreeNode* root) {\\n\\t\\t\\t\\tvector<int>v;\\n\\t\\t\\t\\tinorder(root,v);\\n\\t\\t\\t\\tfor(int i=1;i<v.size();i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(v[i]<=v[i-1]) // if not in order  \\n\\t\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// if we can be able to come out of loop it means all elements are in order  \\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t   void inorder(TreeNode*root,vector<int>&ans)\\n\\t\\t   {\\n\\t\\t\\t   if(!root) return;\\n\\t\\t\\t   inorder(root->left,ans);\\n\\t\\t\\t   ans.push_back(root->val);\\n\\t\\t\\t   inorder(root->right,ans);\\n\\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 1570606,
                "title": "python-3-simple-recursion",
                "content": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def helper(root, low, high):\\n            if root is None:\\n                return True\\n            \\n            if root.val <= low or root.val >= high:\\n                return False\\n            \\n            return helper(root.left, low, root.val) and helper(root.right, root.val, high)\\n        \\n        return helper(root, -math.inf, math.inf)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        def helper(root, low, high):\\n            if root is None:\\n                return True\\n            \\n            if root.val <= low or root.val >= high:\\n                return False\\n            \\n            return helper(root.left, low, root.val) and helper(root.right, root.val, high)\\n        \\n        return helper(root, -math.inf, math.inf)",
                "codeTag": "Java"
            },
            {
                "id": 1548781,
                "title": "c-solution-inorder-vector-method",
                "content": "```\\n    void getOrder(TreeNode* root, vector<int> &inOrder){\\n        if(!root) return;\\n        getOrder(root->left, inOrder);\\n        inOrder.push_back(root->val);\\n        getOrder(root->right, inOrder);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> inOrder;\\n        getOrder(root, inOrder);\\n        if(inOrder.size() == 1) return true;\\n        for(int i = 1; i < inOrder.size(); i++) {\\n            if(inOrder[i] <= inOrder[i-1]) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void getOrder(TreeNode* root, vector<int> &inOrder){\\n        if(!root) return;\\n        getOrder(root->left, inOrder);\\n        inOrder.push_back(root->val);\\n        getOrder(root->right, inOrder);\\n    }\\n    bool isValidBST(TreeNode* root) {\\n        vector<int> inOrder;\\n        getOrder(root, inOrder);\\n        if(inOrder.size() == 1) return true;\\n        for(int i = 1; i < inOrder.size(); i++) {\\n            if(inOrder[i] <= inOrder[i-1]) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1519922,
                "title": "python-o-nlogn-o-n-multiple-simple-solutions",
                "content": "## Solution 1 - O(nlogn)\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def inorderTraversal(self, root, inorder):\\n        if root:\\n            self.inorderTraversal(root.left, inorder)\\n            inorder.append(root.val)\\n            self.inorderTraversal(root.right, inorder)\\n            \\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        inorder = []\\n        self.inorderTraversal(root, inorder)\\n        \"\"\"\\n            Since inorder traversal of BST gives a sorted array so if inorder traversal of given BST is not sorted then it is not a valid BST.\\n            To overcome duplicates we need to verify the length of inorder array and inorder hash set as BST can\\'t have duplicates.\\n        \"\"\"\\n        return inorder == sorted(inorder) and len(inorder) == len(set(inorder))\\n```\\n\\n## Solution 2 - O(n)\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def isValidBST(self, root: Optional[TreeNode], left=-sys.maxsize, right=sys.maxsize) -> bool:\\n        if not root:\\n            return True\\n        if left >= root.val or right <= root.val:\\n            return False\\n        return self.isValidBST(root.left, left, root.val) and self.isValidBST(root.right, root.val, right)\\n```\\n\\n***If you liked the above solutions then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Binary Search Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def inorderTraversal(self, root, inorder):\\n        if root:\\n            self.inorderTraversal(root.left, inorder)\\n            inorder.append(root.val)\\n            self.inorderTraversal(root.right, inorder)\\n            \\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        inorder = []\\n        self.inorderTraversal(root, inorder)\\n        \"\"\"\\n            Since inorder traversal of BST gives a sorted array so if inorder traversal of given BST is not sorted then it is not a valid BST.\\n            To overcome duplicates we need to verify the length of inorder array and inorder hash set as BST can\\'t have duplicates.\\n        \"\"\"\\n        return inorder == sorted(inorder) and len(inorder) == len(set(inorder))\\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def isValidBST(self, root: Optional[TreeNode], left=-sys.maxsize, right=sys.maxsize) -> bool:\\n        if not root:\\n            return True\\n        if left >= root.val or right <= root.val:\\n            return False\\n        return self.isValidBST(root.left, left, root.val) and self.isValidBST(root.right, root.val, right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505663,
                "title": "java-solution-easy-short-clean",
                "content": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return valid(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    private boolean valid(TreeNode root, long min, long max){\\n        if(root == null)    return true;\\n        if(root.val>min && root.val<max)    \\n            return(valid(root.left, min, root.val) && valid(root.right, root.val, max));\\n        return false;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return valid(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n    private boolean valid(TreeNode root, long min, long max){\\n        if(root == null)    return true;\\n        if(root.val>min && root.val<max)    \\n            return(valid(root.left, min, root.val) && valid(root.right, root.val, max));\\n        return false;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346591,
                "title": "c-3-solutions-efficient-simple-easy-to-understand",
                "content": "**1st Approach: Direct Implementation of Definition of BST using Recursion**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidBSTUtil(TreeNode* root, long long int maximum, long long int minimum){\\n        if(root == NULL)\\n            return true;\\n        if(root->val >= maximum || root->val <= minimum)\\n            return false;\\n        if(isValidBSTUtil(root->left, root->val, minimum) \\n           && isValidBSTUtil(root->right, maximum, root->val)){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return isValidBSTUtil(root, LONG_MAX, LONG_MIN);\\n    }\\n};\\n```\\n\\n**2nd Approach: Using Inorder Traversal and Extra Space**\\n\\n```\\nclass Solution {\\n    vector<int> tree;\\npublic:\\n   void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n   \\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        \\n        inOrder(root);\\n        for (int i=1; i<tree.size(); i++)\\n            if (tree[i] <= tree[i-1])\\n                return false;\\n        return true;\\n    }\\n};\\n```\\n\\n**3rd Approach: Similar to 2nd Approach without storing all values**\\n\\n```\\nclass Solution {\\npublic:\\n    bool validateBST(TreeNode* root, TreeNode* &prev){\\n        if(root == NULL) return true;\\n        if(!(validateBST(root->left, prev))) return false;\\n        if(prev != NULL && prev->val >= root->val) return false;\\n        prev = root;\\n        return validateBST(root->right, prev);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = NULL;\\n        return validateBST(root, prev);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBSTUtil(TreeNode* root, long long int maximum, long long int minimum){\\n        if(root == NULL)\\n            return true;\\n        if(root->val >= maximum || root->val <= minimum)\\n            return false;\\n        if(isValidBSTUtil(root->left, root->val, minimum) \\n           && isValidBSTUtil(root->right, maximum, root->val)){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        return isValidBSTUtil(root, LONG_MAX, LONG_MIN);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    vector<int> tree;\\npublic:\\n   void inOrder(TreeNode* root) {\\n        if (!root)\\n            return;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n    }\\n   \\n    bool isValidBST(TreeNode* root) {\\n        if (!root)\\n            return true;\\n        \\n        inOrder(root);\\n        for (int i=1; i<tree.size(); i++)\\n            if (tree[i] <= tree[i-1])\\n                return false;\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool validateBST(TreeNode* root, TreeNode* &prev){\\n        if(root == NULL) return true;\\n        if(!(validateBST(root->left, prev))) return false;\\n        if(prev != NULL && prev->val >= root->val) return false;\\n        prev = root;\\n        return validateBST(root->right, prev);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = NULL;\\n        return validateBST(root, prev);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1187373,
                "title": "90-faster-inorder-traversal-c",
                "content": "***Do upvote if you found the solution helpful to keep me motivated*** \\u270C\\uD83D\\uDE0A\\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root , vector<int> &v)\\n    {\\n        if(root == NULL)\\n            return;\\n        solve(root->left,v);\\n        v.push_back(root->val);\\n        solve(root->right,v);\\n    }\\n\\t\\n    bool isValidBST(TreeNode* root) {\\n     vector<int> v;\\n     solve(root,v);\\n     for(int i=0 ; i<v.size()-1 ;i++)\\n     {\\n         if(v[i] >= v[i+1])\\n          return false;\\n     }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root , vector<int> &v)\\n    {\\n        if(root == NULL)\\n            return;\\n        solve(root->left,v);\\n        v.push_back(root->val);\\n        solve(root->right,v);\\n    }\\n\\t\\n    bool isValidBST(TreeNode* root) {\\n     vector<int> v;\\n     solve(root,v);\\n     for(int i=0 ; i<v.size()-1 ;i++)\\n     {\\n         if(v[i] >= v[i+1])\\n          return false;\\n     }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1151410,
                "title": "python-recursion-easy-to-understand",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def isValidBST(self, root: TreeNode) -> bool:\\n        def helper(root, min_val, max_val):\\n            if not root:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val)\\n        return helper(root, -float(\\'inf\\'), float(\\'inf\\'))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    def isValidBST(self, root: TreeNode) -> bool:\\n        def helper(root, min_val, max_val):\\n            if not root:\\n                return True\\n            if root.val <= min_val or root.val >= max_val:\\n                return False\\n            return helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val)\\n        return helper(root, -float(\\'inf\\'), float(\\'inf\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144855,
                "title": "easy-inorder-traversal-using-vector-c",
                "content": "**Observation**: Inorder traversal (left subtree, root, right subtree) of a Binary Search Tree would always give the node values in an increasing order.\\nHence we store the values of the nodes in a vector and check if the vector is strictly increasing. If not, return false, else return true.\\n\\n```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root, vector<int>& res){\\n        if(root==NULL) return;\\n        inOrder(root->left, res);\\n        res.push_back(root->val);\\n        inOrder(root->right, res);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL) return true;\\n        vector<int> res;\\n        inOrder(root, res);\\n        for(int i=0; i<res.size()-1; i++){\\n            if(res[i]>=res[i+1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* root, vector<int>& res){\\n        if(root==NULL) return;\\n        inOrder(root->left, res);\\n        res.push_back(root->val);\\n        inOrder(root->right, res);\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        if(root==NULL) return true;\\n        vector<int> res;\\n        inOrder(root, res);\\n        for(int i=0; i<res.size()-1; i++){\\n            if(res[i]>=res[i+1]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052667,
                "title": "pair-approach-helpful-in-many-lc-problems",
                "content": "`Please give a upvote if you like else comment for any doubts.`\\n\\n**Approach:** The idea is to use traverse the tree recursively and in each recursive calls return a pair of minimum element, maximum element and the current subtree is BST or not. After each Left and Right recursive calls ends check if the root having these LST and RST follows the BST property or not. If found to be true then return the corresponding pairs to it\\'s parent.\\n\\nBelow is the implementation of the same:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // From each recursive calls return the\\n    // minimum, maximum and isBST flag for\\n    // each subtree\\n    pair<pair<long long int, long long int>, bool> dfs(TreeNode *root) {\\n        \\n        // If root is NULL then it is BST\\n        // return the MAX, MIN, true\\n        // and MAX is return as minimum value \\n        // to validate the BST property for node\\n        // having at least 1 leaf node`\\n        if(root == NULL) {\\n            return {{LLONG_MAX, LLONG_MIN}, true};\\n        }\\n        \\n        // Left and Right Calls\\n        pair<pair<long long int, long long int>, bool> P1 = dfs(root->left);\\n        pair<pair<long long int, long long int>, bool> P2 = dfs(root->right);\\n        \\n        // Find the if the current root is BST\\n        // LST and RST is also BST\\n        bool ans = P1.second && P2.second\\n                    && (root->val > P1.first.second\\n                        && root->val < P2.first.first);\\n        \\n        // Find the current minimum in the subtree\\n        // rooted at current root with minimum of\\n        // LST and RST and current root->value\\n        long long int minimum = min(1LL*root->val,\\n                                    min(P1.first.first,\\n                                        P2.first.first));\\n        \\n        // Find the current maximum in the subtree\\n        // rooted at current root with minimum of\\n        // LST and RST and current root->value\\n        long long int maximum = max(1LL*root->val,\\n                                    max(P1.first.second,\\n                                        P2.first.second));\\n        \\n        // Return the corresponding pair for\\n        // each recursive calls\\n        return {{minimum, maximum}, ans};\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        \\n        if(root->left == NULL\\n           and root->right == NULL) return true;\\n        \\n        pair<pair<long long int, long long int>, bool> P = dfs(root);\\n        return P.second;\\n    }\\n};\\n```\\n*Time Complexity: O(N)\\nAuxiliary Space: O(H), where H is the maximum height of the tree.*",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // From each recursive calls return the\\n    // minimum, maximum and isBST flag for\\n    // each subtree\\n    pair<pair<long long int, long long int>, bool> dfs(TreeNode *root) {\\n        \\n        // If root is NULL then it is BST\\n        // return the MAX, MIN, true\\n        // and MAX is return as minimum value \\n        // to validate the BST property for node\\n        // having at least 1 leaf node`\\n        if(root == NULL) {\\n            return {{LLONG_MAX, LLONG_MIN}, true};\\n        }\\n        \\n        // Left and Right Calls\\n        pair<pair<long long int, long long int>, bool> P1 = dfs(root->left);\\n        pair<pair<long long int, long long int>, bool> P2 = dfs(root->right);\\n        \\n        // Find the if the current root is BST\\n        // LST and RST is also BST\\n        bool ans = P1.second && P2.second\\n                    && (root->val > P1.first.second\\n                        && root->val < P2.first.first);\\n        \\n        // Find the current minimum in the subtree\\n        // rooted at current root with minimum of\\n        // LST and RST and current root->value\\n        long long int minimum = min(1LL*root->val,\\n                                    min(P1.first.first,\\n                                        P2.first.first));\\n        \\n        // Find the current maximum in the subtree\\n        // rooted at current root with minimum of\\n        // LST and RST and current root->value\\n        long long int maximum = max(1LL*root->val,\\n                                    max(P1.first.second,\\n                                        P2.first.second));\\n        \\n        // Return the corresponding pair for\\n        // each recursive calls\\n        return {{minimum, maximum}, ans};\\n    }\\n    \\n    bool isValidBST(TreeNode* root) {\\n        \\n        if(root->left == NULL\\n           and root->right == NULL) return true;\\n        \\n        pair<pair<long long int, long long int>, bool> P = dfs(root);\\n        return P.second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 562349,
                "title": "simple-javascript-solution-recursive-clean",
                "content": "Runtime: 52 ms, faster than 99.19% of JavaScript online submissions for Validate Binary Search Tree.\\nMemory Usage: 37.1 MB, less than 100.00% of JavaScript online submissions for Validate Binary Search Tree.\\n```\\nfunction isValidBST(root, min, max) {\\n  if (!root) { \\n    return true;\\n  }\\n\\n  if (min !== undefined && root.val <= min) {\\n    return false;\\n  }\\n\\n  if (max !== undefined && root.val >= max) { \\n    return false;\\n  }\\n \\n  return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max); \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction isValidBST(root, min, max) {\\n  if (!root) { \\n    return true;\\n  }\\n\\n  if (min !== undefined && root.val <= min) {\\n    return false;\\n  }\\n\\n  if (max !== undefined && root.val >= max) { \\n    return false;\\n  }\\n \\n  return isValidBST(root.left, min, root.val) && isValidBST(root.right, root.val, max); \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 520381,
                "title": "c-really-easy-in-order-traversal-solution-90-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        // base case\\n        if (root == nullptr) {\\n            return true;\\n        }\\n        \\n        // visit the left sub-tree\\n        if (!isValidBST(root->left)) {\\n            return false;\\n        }\\n        \\n        // an in-order traversal of a valid binary search tree\\n        // will always process nodes in-order. if the pervious\\n        // node is larger than current value, this condition\\n        // fails and we can assume that the tree isn\\'t a valid BST\\n        if (previous && previous->val >= root->val) {\\n            return false;\\n        }\\n        \\n        // set the previous node to the current node\\n        previous = root;\\n        \\n        // visit the right sub-tree\\n        return isValidBST(root->right);\\n    }\\nprivate:\\n    TreeNode* previous = nullptr;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        // base case\\n        if (root == nullptr) {\\n            return true;\\n        }\\n        \\n        // visit the left sub-tree\\n        if (!isValidBST(root->left)) {\\n            return false;\\n        }\\n        \\n        // an in-order traversal of a valid binary search tree\\n        // will always process nodes in-order. if the pervious\\n        // node is larger than current value, this condition\\n        // fails and we can assume that the tree isn\\'t a valid BST\\n        if (previous && previous->val >= root->val) {\\n            return false;\\n        }\\n        \\n        // set the previous node to the current node\\n        previous = root;\\n        \\n        // visit the right sub-tree\\n        return isValidBST(root->right);\\n    }\\nprivate:\\n    TreeNode* previous = nullptr;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 452792,
                "title": "inorder-traversal-c-solution-both-iterative-and-recursive",
                "content": "You can check if binary tree to be a BST by checking if the the inorder traversal is in sorted (ascending) order. \\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = NULL;\\n        return isBST_inorder_iterative(root); \\n    }\\n    \\n    bool isBST_inorder_recurse(TreeNode* p, TreeNode* &prev) {\\n        if(p == NULL) return true;\\n        \\n        if(!isBST_inorder_recurse(p->left, prev)) return false;\\n        if(prev != NULL && prev->val >= p->val) return false;\\n        prev = p;\\n        return isBST_inorder_recurse(p->right, prev);\\n        \\n    }\\n    \\n    bool isBST_inorder_iterative(TreeNode* p) {\\n        if(p == NULL) return true;\\n        stack<TreeNode*> st;\\n        TreeNode *curr = p;\\n        TreeNode *prev = NULL;\\n        \\n        while(curr != NULL || !st.empty()) {\\n            \\n            while(curr != NULL) {\\n                st.push(curr);\\n                curr = curr->left;\\n            }\\n            curr = st.top(); st.pop();\\n            if(prev != NULL && prev->val >= curr->val) return false;\\n            prev = curr;\\n            curr = curr->right;\\n        }\\n        return true;\\n    }\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        TreeNode* prev = NULL;\\n        return isBST_inorder_iterative(root); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 357687,
                "title": "javascript-inorder-traverse-solution",
                "content": "```\\nvar isValidBST = function(root, lower = -Infinity, upper = Infinity) {\\n    let arr = []; \\n    var traverse = function(root) {\\n        if (!root) return; \\n        traverse(root.left); \\n        arr.push(root.val);\\n        traverse(root.right);\\n    }; \\n    \\n    traverse(root);\\n    \\n    for (let i = 0; i < arr.length-1; i++) {\\n        if (arr[i] >= arr[i+1]) return false;\\n    };\\n    \\n    return true;\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isValidBST = function(root, lower = -Infinity, upper = Infinity) {\\n    let arr = []; \\n    var traverse = function(root) {\\n        if (!root) return; \\n        traverse(root.left); \\n        arr.push(root.val);\\n        traverse(root.right);\\n    }; \\n    \\n    traverse(root);\\n    \\n    for (let i = 0; i < arr.length-1; i++) {\\n        if (arr[i] >= arr[i+1]) return false;\\n    };\\n    \\n    return true;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 258041,
                "title": "a-golang-solution",
                "content": "```\\nfunc isValidBST(root *TreeNode) bool {     \\n        return validate(root, math.MinInt64, math.MaxInt64)\\n}\\n        \\nfunc validate(root *TreeNode, min, max int) bool {\\n        if root == nil {   \\n                return true\\n        }                  \\n        \\n        if root.Val <= min || root.Val >= max {\\n                return false\\n        }\\n                                                                                                                                                                                                            \\n        return validate(root.Left, min, root.Val) && validate(root.Right, root.Val, max)\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isValidBST(root *TreeNode) bool {     \\n        return validate(root, math.MinInt64, math.MaxInt64)\\n}\\n        \\nfunc validate(root *TreeNode, min, max int) bool {\\n        if root == nil {   \\n                return true\\n        }                  \\n        \\n        if root.Val <= min || root.Val >= max {\\n                return false\\n        }\\n                                                                                                                                                                                                            \\n        return validate(root.Left, min, root.Val) && validate(root.Right, root.Val, max)\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 197536,
                "title": "c-4ms-100-simple-recursive-soln",
                "content": "I used a ```long``` instead of ```int``` to handle the edge cases with nodes in the tree that are already INT_MIN or INT_MAX.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return isValidRecur(root, LONG_MIN, LONG_MAX);\\n    }\\n    \\n    bool isValidRecur(TreeNode* root, long min, long max) {\\n        if (!root)\\n            return true;\\n        int val = root->val;\\n        if (val <= min || val >= max)\\n            return false;\\n        return isValidRecur(root->left, min, val) &&\\n               isValidRecur(root->right, val, max);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```long```\n```int```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isValidBST(TreeNode* root) {\\n        return isValidRecur(root, LONG_MIN, LONG_MAX);\\n    }\\n    \\n    bool isValidRecur(TreeNode* root, long min, long max) {\\n        if (!root)\\n            return true;\\n        int val = root->val;\\n        if (val <= min || val >= max)\\n            return false;\\n        return isValidRecur(root->left, min, val) &&\\n               isValidRecur(root->right, val, max);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141734,
                "title": "concise-java-solutions",
                "content": "```\\n    public boolean isValidBST(TreeNode root) {\\n        List<Integer> inorder = inorder(root);\\n        return isSorted(inorder);\\n    }\\n    \\n    public List<Integer> inorder(TreeNode node){\\n        if(node == null) return new ArrayList<>();\\n        List<Integer> res = new ArrayList<>();\\n        res.addAll(inorder(node.left));\\n        res.add(node.val);\\n        res.addAll(inorder(node.right));\\n        return res;\\n    }\\n    \\n    public boolean isSorted(List<Integer> l){\\n        for(int i=1; i<l.size(); i++){\\n            if(l.get(i) <= l.get(i-1)) return false;\\n        }\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isValidBST(TreeNode root) {\\n        List<Integer> inorder = inorder(root);\\n        return isSorted(inorder);\\n    }\\n    \\n    public List<Integer> inorder(TreeNode node){\\n        if(node == null) return new ArrayList<>();\\n        List<Integer> res = new ArrayList<>();\\n        res.addAll(inorder(node.left));\\n        res.add(node.val);\\n        res.addAll(inorder(node.right));\\n        return res;\\n    }\\n    \\n    public boolean isSorted(List<Integer> l){\\n        for(int i=1; i<l.size(); i++){\\n            if(l.get(i) <= l.get(i-1)) return false;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32195,
                "title": "golang-concise-solution-using-dfs",
                "content": "We need to take care of not only the relation between a parent, but also the grandparent.\\nActually all nodes have their own both minimum and maximum value constraint.\\nThis article explains the common mistake we might make.\\nhttp://www.geeksforgeeks.org/a-program-to-check-if-a-binary-tree-is-bst-or-not/\\n\\n```\\nfunc isValidBST(root *TreeNode) bool {\\n\\tif root == nil {\\n\\t\\treturn true\\n\\t}\\n\\tres, v := true, root.Val\\n\\tdoValidateBST(&res, root.Left, &v, nil)\\n\\tdoValidateBST(&res, root.Right, nil, &v)\\n\\treturn res\\n}\\n\\nfunc doValidateBST(res *bool, node *TreeNode, upperBound, lowerBound *int) {\\n\\tif node == nil || !*res {\\n\\t\\treturn\\n\\t}\\n\\tif (upperBound != nil && node.Val >= *upperBound) ||\\n\\t\\t(lowerBound != nil && node.Val <= *lowerBound) {\\n\\t\\t*res = false\\n\\t\\treturn\\n\\t}\\n\\n\\tv := node.Val\\n\\tdoValidateBST(res, node.Left, &v, lowerBound)\\n\\tdoValidateBST(res, node.Right, upperBound, &v)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isValidBST(root *TreeNode) bool {\\n\\tif root == nil {\\n\\t\\treturn true\\n\\t}\\n\\tres, v := true, root.Val\\n\\tdoValidateBST(&res, root.Left, &v, nil)\\n\\tdoValidateBST(&res, root.Right, nil, &v)\\n\\treturn res\\n}\\n\\nfunc doValidateBST(res *bool, node *TreeNode, upperBound, lowerBound *int) {\\n\\tif node == nil || !*res {\\n\\t\\treturn\\n\\t}\\n\\tif (upperBound != nil && node.Val >= *upperBound) ||\\n\\t\\t(lowerBound != nil && node.Val <= *lowerBound) {\\n\\t\\t*res = false\\n\\t\\treturn\\n\\t}\\n\\n\\tv := node.Val\\n\\tdoValidateBST(res, node.Left, &v, lowerBound)\\n\\tdoValidateBST(res, node.Right, upperBound, &v)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 32220,
                "title": "ruby-recursive-solution",
                "content": "```\\ndef is_valid_bst(root, min = -Float::INFINITY, max = Float::INFINITY)\\n    return true unless root\\n    if root.val <= min || root.val >= max\\n        return false\\n    else\\n        is_valid_bst(root.left, min, root.val) && is_valid_bst(root.right, root.val, max)\\n    end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef is_valid_bst(root, min = -Float::INFINITY, max = Float::INFINITY)\\n    return true unless root\\n    if root.val <= min || root.val >= max\\n        return false\\n    else\\n        is_valid_bst(root.left, min, root.val) && is_valid_bst(root.right, root.val, max)\\n    end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 32402,
                "title": "simple-java-solution-recursive-validation",
                "content": "    public class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, (long)Integer.MIN_VALUE, (long)Integer.MAX_VALUE);\\n    }\\n    \\n    public boolean isValidBST(TreeNode root, long min, long max) {\\n        if(root == null) return true;\\n        long val = root.val;\\n        return (val >= min && val <= max && isValidBST(root.left, min, val -1) && isValidBST(root.right, val+1, max));\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(root, (long)Integer.MIN_VALUE, (long)Integer.MAX_VALUE);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 32411,
                "title": "8ms-c-solution",
                "content": "    bool isValidBST(struct TreeNode* root) {\\n\\tif (NULL == root)\\n\\t\\treturn true;\\n\\n\\tif (NULL != root->left)\\n\\t{\\n\\t\\tstruct TreeNode* current = root->left;\\n\\t\\twhile (current->right != NULL)\\n\\t\\t{\\n\\t\\t\\tcurrent = current->right;\\n\\t\\t}\\n\\t\\tif (current->val >= root->val)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tif (NULL != root->right)\\n\\t{\\n\\t\\tstruct TreeNode* current = root->right;\\n\\t\\twhile (NULL != current->left)\\n\\t\\t{\\n\\t\\t\\tcurrent = current->left;\\n\\t\\t}\\n\\t\\tif ( current->val <= root->val)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tif ( !isValidBST(root->left))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif (!isValidBST(root->right))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn true;\\n}",
                "solutionTags": [],
                "code": "    bool isValidBST(struct TreeNode* root) {\\n\\tif (NULL == root)\\n\\t\\treturn true;\\n\\n\\tif (NULL != root->left)\\n\\t{\\n\\t\\tstruct TreeNode* current = root->left;\\n\\t\\twhile (current->right != NULL)\\n\\t\\t{\\n\\t\\t\\tcurrent = current->right;\\n\\t\\t}\\n\\t\\tif (current->val >= root->val)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\n\\t}\\n\\n\\tif (NULL != root->right)\\n\\t{\\n\\t\\tstruct TreeNode* current = root->right;\\n\\t\\twhile (NULL != current->left)\\n\\t\\t{\\n\\t\\t\\tcurrent = current->left;\\n\\t\\t}\\n\\t\\tif ( current->val <= root->val)\\n\\t\\t{\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n\\n\\tif ( !isValidBST(root->left))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\tif (!isValidBST(root->right))\\n\\t{\\n\\t\\treturn false;\\n\\t}\\n\\n\\treturn true;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 32419,
                "title": "my-c-solution-12ms-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        bool isValidBST(TreeNode* root) {\\n            if(root==NULL)\\n            return true;\\n            if(root->left==NULL && root->right==NULL)\\n            return true;\\n            bool left=true;\\n            bool right=true;\\n            if(root->left)\\n            {\\n                left=isValidBST(root->left);\\n                TreeNode* rightest=root->left;\\n                while(rightest->right)\\n                {\\n                    rightest=rightest->right;\\n                }\\n                left=left&&(root->val>rightest->val);\\n            }\\n            if(root->right)\\n            {\\n                right=isValidBST(root->right);\\n                TreeNode* leftest=root->right;\\n                while(leftest->left)\\n                leftest=leftest->left;\\n                right=right&&(root->val<leftest->val);\\n            }\\n            return left&&right;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isValidBST(TreeNode* root) {\\n            if(root==NULL)\\n            return true;\\n            if(root->left==NULL && root->right==NULL)\\n            return true;\\n            bool left=true;\\n            bool right=true;\\n            if(root->left)\\n            {\\n                left=isValidBST(root->left);\\n                TreeNode* rightest=root->left;\\n                while(rightest->right)\\n                {\\n                    rightest=rightest->right;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 32490,
                "title": "my-recursive-solution-no-passing-bounds",
                "content": "Inorder traversal, check valid in left->root->right order.\\nThe traversal should in strict ascending order.\\n\\n 1. leftchild subproblem is not valid, return false.\\n 2. current value is not greater than last value (if exists), return false. Otherwise, update the last.\\n 3. check rightchild subproblem\\n\\n\\nclass Solution \\n{\\npublic:\\n\\n    TreeNode* last = NULL;\\n    bool isValidBST(TreeNode *root) \\n    {\\n        if(root == NULL)\\n            return true;\\n        else\\n        {\\n            bool leftRes = isValidBST(root->left);\\n            //short cut\\n            if(leftRes == false)\\n                return false;\\n            if(last && last->val >= root->val)\\n                return false;\\n            last = root;\\n            return isValidBST(root->right);\\n        }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution \\n{\\npublic:\\n\\n    TreeNode* last = NULL;\\n    bool isValidBST(TreeNode *root) \\n    {\\n        if(root == NULL)\\n            return true;\\n        else\\n        {\\n            bool leftRes = isValidBST(root->left);\\n            //short cut\\n            if(leftRes == false)\\n                return false;\\n            if(last && last->val >= root->val)\\n                return false;\\n            last = root;\\n            return isValidBST(root->right);\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1575626,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1570656,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1568573,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1892160,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1572391,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1835136,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1568018,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1574053,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1570321,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1567009,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1575626,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1570656,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1568573,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1892160,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1572391,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1835136,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1568018,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1574053,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1570321,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1567009,
                "content": [
                    {
                        "username": "Prathamesh_Gawas",
                        "content": "Why is [5,4,6,null,null,3,7] not a validate binary tree?"
                    },
                    {
                        "username": "dilshanth1996s",
                        "content": "[@hbhutta](/hbhutta) As per the list 5 is the root node so what are things come to right should be greater than 5, but in this list 3 is right sub tree of 5 that is reason which is not validate binary search tree"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Because 3 is less than 5, but it lies in the right subtree of 5. It shouldnt be there considering it a BST."
                    },
                    {
                        "username": "akimov-ivan-se",
                        "content": "Because 3 is less then 5, but should be greater"
                    },
                    {
                        "username": "bt21ece035",
                        "content": " -> 3<5\n      but  by defination bst any node on right side of tree should be greater than root\n"
                    },
                    {
                        "username": "idobleicher",
                        "content": "[@onkar_AZ](/onkar_AZ) That\\'s not true because if you flip the 3 and 4 it\\'s still will fail."
                    },
                    {
                        "username": "hbhutta",
                        "content": "[@hbhutta](/hbhutta) I also just failed on that test case, passed 61 cases but failed on the 62nd. "
                    },
                    {
                        "username": "hbhutta",
                        "content": "The left child of 6 (which is 3) should be greater than 5, but it is not "
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [5,4,6,null,null,3,7] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i).The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii)The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n\\nIn this binary tree, the value of the node with value 4 is greater than the value of its left child with value 3, which violates the first property of a BST. Therefore, [5,4,6,null,null,3,7] is not a valid BST."
                    },
                    {
                        "username": "Lord-of-Bugs",
                        "content": "I feel like you might have been confused by the array-version of the BST. What [5,4,6,null,null,3,7] really converts to in BST is this: 5 is the root, 4 and 6 are the left and right child of 5, null and null are the left and right child of 4, and lastly 3 and 7 are the left and right child of 6, respectively. It\\'s now hopefully more clear that 3 shouldn\\'t be placed as a left child of 6 since even though it satisfies 3 < 6, it does not belong in the right subtree of the root 5 for 3 < 5."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 3< 5 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\" \\n\\n3 < 5"
                    },
                    {
                        "username": "ashblue",
                        "content": "I really wish the examples would have been clear that the parent tree values should be resepected. Maybe I just read things incorrectly but this confused the hell out of me."
                    },
                    {
                        "username": "Kwuuk",
                        "content": "[@Dragoon572](/Dragoon572) Can you give an example of a tree which the instructions were ambiguous about?"
                    },
                    {
                        "username": "Dragoon572",
                        "content": "My understanding is that the given instructions are incomplete and therefore incorrect, but I\\'m second guessing this notion because if that\\'s true, why hasn\\'t this problem been downvoted to oblivion? lol"
                    },
                    {
                        "username": "user7312022",
                        "content": "Here are a few test cases you can check your code against before submission. Hope it helps!\\n\\n[2,1,3]\\n[5,1,4,null,null,3,6]\\n[0]\\n[1,1]\\n[0,-1]\\n[5,14,null,1]\\n[5,4,6,null,null,3,7]\\n[10,5,15,null,null,6,20]\\n[32,26,47,19,null,null,56,null,27]\\n[3,null,30,10,null,null,15,null,45]\\n[120,70,140,50,100,130,160,20,55,75,110,119,135,150,200]"
                    },
                    {
                        "username": "dvakar",
                        "content": "[3,1,5,0,2,4,6,null,null,null,3]"
                    },
                    {
                        "username": "nishantk3101",
                        "content": "[2147483647] test this too"
                    },
                    {
                        "username": "darktugrenok",
                        "content": "Tests without results? Looks useless"
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "Inorder Traversal of Valid BST is always strictly increasing array"
                    },
                    {
                        "username": "Sofonyas",
                        "content": "muchas gracias"
                    },
                    {
                        "username": "uralbekxd",
                        "content": "Thank you, this helped me a lot"
                    },
                    {
                        "username": "Pretro",
                        "content": "the implementation given indicates clearly that the value of any treenode should be int, why we have test case where the value of node larger than the Integer.MAX????"
                    },
                    {
                        "username": "sumit20",
                        "content": "Yes, It\\'s really stupid. One reason could be, they don\\'t want people to use (a single global variable + sorting property) "
                    },
                    {
                        "username": "nikogoga87",
                        "content": "If you are new to binary trees (Like me) and are struggling to solve the tough edge cases, I really suggest you go through the editorial and reading through it. Once you have a basic idea of what to do, try to solve it. If you still can\\'t, then have a look at the solutions and try to understand what they\\'re doing and code it yourself. This is a tough one to crack yourself so don\\'t feel bad if you don\\'t at first. Once you spend some time to understand the solution it will all make sense."
                    },
                    {
                        "username": "SonataArctica",
                        "content": "Why is \\n[10,5,15,null,null,6,20]\\nNot a valid BST?\\nLooks fine to me but the test case says it is false"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The binary tree [10,5,15,null,null,6,20] is not a valid binary search tree (BST) because it does not satisfy the BST property:\\n\\n(i) The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n(ii) The right subtree of a node contains only nodes with keys greater than the node\\'s node\\'s key.\\nIn this binary tree, the value of the node with value 15 is less than the value of its right child with value 20, which violates the second property of a BST. Therefore, [10,5,15,null,null,6,20] is not a valid BST."
                    },
                    {
                        "username": "McOussKing",
                        "content": "The issue here is that 6 < 10. In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "ileetcoder",
                        "content": "[0,-1]\\n\\nI thought the node in BST has to have both left & right child pointers. What kind of test case is this?"
                    },
                    {
                        "username": "inrobot",
                        "content": "[@pheonixarmvel](/pheonixarmvel)  Still leetcode expects that [0, -1] to be valid binary tree, which is wrong."
                    },
                    {
                        "username": "pheonixarmvel",
                        "content": "The left child of 0 is -1 and the right child does not exist, [0,-1,NULL] is the same test case but in order to save space the test case is [0,-1]"
                    },
                    {
                        "username": "RagiMudde",
                        "content": "[9963,9923,9996,9900,null,null,null,9895,null,9894,null,9879,null,9852,null,9845,null,9843,null,9784,null,9772,null,9767,null,9766,null,9757,null,9723,null,9714,null,9670,null,9663,null,9646,null,9590,null,9590,null,9578,null,9544,null,9482,null,9479,null,9414,null,9412,null,9411,null,9389,null,9364,null,9351,null,9351,null,9344,null,9332,null,9331,null,9272,null,9253,null,9226,null,9192,null,9185,null,9146,null,9124,null,9064,null,9061,null,8987,null,8963,null,8911,null,8905,null,8903,null,8879,null,8847,null,8834,null,8834,null,8825,null,8819,null,8798,null,8787,null,8772,null,8763,null,8761,null,8759,null,8716,null,8706,null,8705,null,8700,null,8681,null,8648,null,8633,null,8605,null,8599,null,8594,null,8585,null,8558,null,8533,null,8491,null,8480,null,8424,null,8419,null,8418,null,8408,null,8371,null,8366,null,8341,null,8316,null,8303,null,8238,null,8200,null,8198,null,8183,null,8178,null,8176,null,8113,null,8092,null,8064,null,8029,null,8022,null,7977,null,7957,null,7952,null,7931,null,7923,null,7912,null,7877,null,7832,null,7830,null,7785,null,7730,null,7726,null,7717,null,7699,null,7686,null,7672,null,7633,null,7625,null,7608,null,7597,null,7575,null,7548,null,7547,null,7512,null,7499,null,7482,null,7403,null,7388,null,7366,null,7324,null,7324,null,7321,null,7306,null,7301,null,7299,null,7295,null,7210,null,7167,null,7134,null,7127,null,7117,null,7075,null,7060,null,6999,null,6993,null,6988,null,6941,null,6918,null,6890,null,6883,null,6830,null,6812,null,6764,null,6757,null,6749,null,6747,null,6732,null,6686,null,6657,null,6636,null,6610,null,6607,null,6606,null,6575,null,6573,null,6565,null,6518,null,6510,null,6463,null,6445,null,6425,null,6410,null,6402,null,6392,null,6370,null,6368,null,6346,null,6334,null,6315,null,6285,null,6284,null,6240,null,6223,null,6197,null,6160,null,6158,null,6148,null,6131,null,6060,null,6032,null,6003,null,5956,null,5937,null,5919,null,5913,null,5904,null,5894,null,5869,null,5854,null,5854,null,5817,null,5806,null,5794,null,5794,null,5770,null,5728,null,5722,null,5717,null,5688,null,5673,null,5663,null,5649,null,5639,null,5605,null,5604,null,5594,null,5573,null,5561,null,5545,null,5540,null,5536,null,5530,null,5529,null,5516,null,5507,null,5471,null,5435,null,5377,null,5365,null,5356,null,5317,null,5291,null,5238,null,5175,null,5153,null,5112,null,5111,null,5091,null,5085,null,5080,null,5079,null,5045,null,5041,null,5039,null,5034,null,5000,null,4983,null,4941,null,4925,null,4911,null,4899,null,4890,null,4884,null,4879,null,4874,null,4862,null,4859,null,4829,null,4821,null,4803,null,4801,null,4782,null,4765,null,4760,null,4756,null,4738,null,4716,null,4687,null,4678,null,4675,null,4627,null,4556,null,4553,null,4485,null,4431,null,4420,null,4412,null,4398,null,4394,null,4347,null,4344,null,4336,null,4286,null,4246,null,4245,null,4187,null,4172,null,4167,null,4145,null,4124,null,4098,null,4081,null,4080,null,4073,null,4006,null,3928,null,3914,null,3913,null,3907,null,3903,null,3893,null,3892,null,3891,null,3860,null,3844,null,3841,null,3794,null,3790,null,3769,null,3760,null,3751,null,3750,null,3746,null,3723,null,3723,null,3718,null,3713,null,3713,null,3710,null,3682,null,3679,null,3665,null,3644,null,3639,null,3636,null,3632,null,3621,null,3615,null,3554,null,3538,null,3505,null,3490,null,3466,null,3408,null,3395,null,3392,null,3340,null,3321,null,3301,null,3262,null,3195,null,3187,null,3172,null,3165,null,3104,null,3103,null,2955,null,2933,null,2927,null,2888,null,2881,null,2851,null,2845,null,2839,null,2835,null,2827,null,2803,null,2798,null,2776,null,2736,null,2733,null,2709,null,2702,null,2698,null,2684,null,2669,null,2661,null,2633,null,2632,null,2628,null,2627,null,2617,null,2609,null,2606,null,2587,null,2558,null,2516,null,2485,null,2463,null,2437,null,2367,null,2365,null,2351,null,2312,null,2289,null,2286,null,2286,null,2273,null,2255,null,2252,null,2208,null,2205,null,2194,null,2190,null,2089,null,2075,null,2056,null,2037,null,2031,null,2021,null,2017,null,1952,null,1857,null,1849,null,1826,null,1806,null,1802,null,1797,null,1792,null,1770,null,1760,null,1755,null,1734,null,1734,null,1716,null,1701,null,1675,null,1668,null,1667,null,1659,null,1652,null,1633,null,1630,null,1604,null,1596,null,1595,null,1575,null,1573,null,1562,null,1556,null,1548,null,1535,null,1533,null,1507,null,1506,null,1499,null,1467,null,1440,null,1407,null,1396,null,1353,null,1343,null,1342,null,1318,null,1304,null,1253,null,1182,null,1165,null,1153,null,1118,null,1076,null,1045,null,1012,null,961,null,955,null,950,null,937,null,936,null,923,null,883,null,849,null,839,null,838,null,823,null,820,null,815,null,801,null,800,null,791,null,758,null,738,null,734,null,718,null,712,null,709,null,656,null,649,null,627,null,611,null,610,null,609,null,602,null,597,null,548,null,514,null,507,null,487,null,441,null,401,null,375,null,372,null,367,null,337,null,327,null,316,null,306,null,298,null,265,null,219,null,217,null,198,null,191,null,188,null,163,null,87,null,84,null,40,null,-5,null,-17,null,-39,null,-69,null,-72,null,-143,null,-145,null,-169,null,-180,null,-206,null,-213,null,-213,null,-244,null,-245,null,-254,null,-302,null,-303,null,-317,null,-319,null,-343,null,-349,null,-375,null,-398,null,-416,null,-417,null,-417,null,-448,null,-495,null,-567,null,-580,null,-588,null,-590,null,-593,null,-618,null,-624,null,-668,null,-730,null,-736,null,-750,null,-756,null,-765,null,-766,null,-809,null,-817,null,-834,null,-843,null,-858,null,-871,null,-921,null,-921,null,-923,null,-932,null,-936,null,-954,null,-991,null,-991,null,-1010,null,-1065,null,-1117,null,-1166,null,-1203,null,-1232,null,-1261,null,-1268,null,-1330,null,-1331,null,-1332,null,-1362,null,-1379,null,-1434,null,-1473,null,-1501,null,-1502,null,-1503,null,-1523,null,-1538,null,-1546,null,-1640,null,-1641,null,-1656,null,-1686,null,-1688,null,-1721,null,-1741,null,-1790,null,-1817,null,-1831,null,-1843,null,-1846,null,-1862,null,-1863,null,-1881,null,-1887,null,-1913,null,-1915,null,-1932,null,-1939,null,-1941,null,-1984,null,-1984,null,-2002,null,-2013,null,-2073,null,-2083,null,-2089,null,-2102,null,-2103,null,-2155,null,-2168,null,-2173,null,-2176,null,-2182,null,-2198,null,-2239,null,-2251,null,-2266,null,-2301,null,-2323,null,-2380,null,-2405,null,-2414,null,-2427,null,-2433,null,-2448,null,-2459,null,-2466,null,-2467,null,-2477,null,-2483,null,-2489,null,-2492,null,-2540,null,-2554,null,-2582,null,-2596,null,-2597,null,-2601,null,-2603,null,-2651,null,-2652,null,-2671,null,-2681,null,-2685,null,-2689,null,-2693,null,-2701,null,-2710,null,-2755,null,-2755,null,-2765,null,-2775,null,-2791,null,-2822,null,-2826,null,-2836,null,-2842,null,-2862,null,-2880,null,-2942,null,-2970,null,-2986,null,-3016,null,-3023,null,-3040,null,-3064,null,-3075,null,-3087,null,-3123,null,-3160,null,-3179,null,-3215,null,-3215,null,-3224,null,-3230,null,-3241,null,-3279,null,-3286,null,-3288,null,-3289,null,-3307,null,-3343,null,-3361,null,-3367,null,-3387,null,-3395,null,-3409,null,-3427,null,-3431,null,-3447,null,-3464,null,-3508,null,-3541,null,-3566,null,-3581,null,-3659,null,-3711,null,-3720,null,-3730,null,-3735,null,-3752,null,-3760,null,-3760,null,-3776,null,-3793,null,-3825,null,-3851,null,-3854,null,-3860,null,-3874,null,-3897,null,-3960,null,-3968,null,-4032,null,-4034,null,-4048,null,-4077,null,-4122,null,-4141,null,-4154,null,-4186,null,-4372,null,-4411,null,-4511,null,-4516,null,-4530,null,-4545,null,-4548,null,-4548,null,-4554,null,-4580,null,-4582,null,-4596,null,-4613,null,-4622,null,-4665,null,-4668,null,-4669,null,-4669,null,-4678,null,-4682,null,-4726,null,-4769,null,-4778,null,-4794,null,-4797,null,-4800,null,-4812,null,-4829,null,-4838,null,-4874,null,-4895,null,-4905,null,-4907,null,-4958,null,-4971,null,-5007,null,-5025,null,-5033,null,-5057,null,-5062,null,-5063,null,-5065,null,-5072,null,-5086,null,-5101,null,-5144,null,-5149,null,-5170,null,-5179,null,-5188,null,-5193,null,-5194,null,-5201,null,-5247,null,-5269,null,-5295,null,-5338,null,-5373,null,-5380,null,-5400,null,-5401,null,-5410,null,-5413,null,-5426,null,-5427,null,-5546,null,-5549,null,-5581,null,-5622,null,-5633,null,-5645,null,-5664,null,-5664,null,-5666,null,-5672,null,-5674,null,-5675,null,-5678,null,-5720,null,-5722,null,-5785,null,-5799,null,-5804,null,-5821,null,-5823,null,-5823,null,-5867,null,-5872,null,-5891,null,-5891,null,-5892,null,-5892,null,-5923,null,-5939,null,-5949,null,-5954,null,-5956,null,-5982,null,-5999,null,-6008,null,-6027,null,-6049,null,-6053,null,-6061,null,-6069,null,-6078,null,-6092,null,-6099,null,-6145,null,-6166,null,-6186,null,-6231,null,-6252,null,-6254,null,-6328,null,-6382,null,-6396,null,-6401,null,-6406,null,-6410,null,-6417,null,-6427,null,-6428,null,-6449,null,-6465,null,-6481,null,-6487,null,-6512,null,-6522,null,-6523,null,-6543,null,-6582,null,-6591,null,-6625,null,-6629,null,-6663,null,-6678,null,-6687,null,-6740,null,-6743,null,-6761,null,-6774,null,-6788,null,-6809,null,-6818,null,-6833,null,-6866,null,-6878,null,-6892,null,-6940,null,-6959,null,-6977,null,-7066,null,-7126,null,-7153,null,-7155,null,-7188,null,-7230,null,-7248,null,-7268,null,-7323,null,-7336,null,-7395,null,-7396,null,-7397,null,-7425,null,-7444,null,-7488,null,-7494,null,-7522,null,-7551,null,-7591,null,-7602,null,-7603,null,-7611,null,-7659,null,-7692,null,-7697,null,-7768,null,-7776,null,-7780,null,-7805,null,-7828,null,-7836,null,-7867,null,-7910,null,-7928,null,-7934,null,-7936,null,-7955,null,-7960,null,-7989,null,-8007,null,-8087,null,-8093,null,-8103,null,-8104,null,-8115,null,-8223,null,-8229,null,-8230,null,-8279,null,-8286,null,-8326,null,-8365,null,-8397,null,-8511,null,-8530,null,-8552,null,-8555,null,-8659,null,-8679,null,-8687,null,-8737,null,-8748,null,-8754,null,-8763,null,-8763,null,-8785,null,-8807,null,-8815,null,-8891,null,-8898,null,-8901,null,-8903,null,-8915,null,-8920,null,-8967,null,-8976,null,-9002,null,-9007,null,-9037,null,-9039,null,-9042,null,-9066,null,-9137,null,-9153,null,-9159,null,-9161,null,-9186,null,-9193,null,-9204,null,-9234,null,-9343,null,-9343,null,-9362,null,-9364,null,-9408,null,-9411,null,-9434,null,-9436,null,-9488,null,-9506,null,-9517,null,-9518,null,-9594,null,-9643,null,-9646,null,-9655,null,-9684,null,-9745,null,-9769,null,-9769,null,-9792,null,-9815,null,-9816,null,-9823,null,-9828,null,-9833,null,-9833,null,-9849,null,-9879,null,-9885,null,-9912,null,-9914,null,-9927]"
                    },
                    {
                        "username": "PKYO123",
                        "content": "That is all."
                    }
                ]
            },
            {
                "id": 1573325,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1576712,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1567857,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1569782,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1569395,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1572371,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1795787,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1574415,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1573251,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 2053693,
                "content": [
                    {
                        "username": "garvitkhamesra",
                        "content": "When I run my test for the testcase [0], it returns me correct answer but when I submit it, it fails.\\n![image](https://assets.leetcode.com/users/garvitkhamesra/image_1578333547.png)\\nCan anyone help me with this?\\n"
                    },
                    {
                        "username": "knowchirag",
                        "content": "How did you get that visualize option??\\n"
                    },
                    {
                        "username": "jusAnotherGuy",
                        "content": "Same question here with the following javascript code:\n\n`let prev = Number.NEGATIVE_INFINITY`\n`var isValidBST = function (root) {`\n   `    return inorder(root)==true`\n`};`\n`var inorder = function (root) {`\n    `    if (!root) return true`\n   `     if (!inorder(root.left)) return false`\n    `   if (root.val <= prev) return false`\n   `     prev = root.val`\n   `     return inorder(root.right)`\n`}`\n\n"
                    },
                    {
                        "username": "MilkyCarl",
                        "content": "I encountered the following test case and my programme returned true.\\n[5,4,6,null,null,3,7]\\nBut the expected output is false. I wonder why this tree is not a BST?\\n4<5,6>5,3<6,7>6,looks fine to me.\\nPlease help, thank you!"
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "3 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "chentao169",
                        "content": "Given a binary tree, determine if it is a valid binary search tree (BST).\\n\\nAssume a BST is defined as follows:\\n\\nThe left subtree of a node contains only nodes with keys less than the node's key.\\nThe right subtree of a node contains only nodes with keys greater than the node's key.\\nBoth the left and right subtrees must also be binary search trees.\\n[LeetCode :validate binary search tree][1]\\n\\nThis problem would be solved easily by using recursion. But, I wanna know how to use iteration to solve it.\\nThanks.\\n\\n\\n  [1]: http://oj.leetcode.com/problems/validate-binary-search-tree/"
                    },
                    {
                        "username": "Jammooly",
                        "content": "[10,5,15,null,null,6,20]\\n Isn\\'t this test case supposed to be true?\\n Why is it false?\\n"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "z3493021",
                        "content": "Can somebody explain why [10,5,15,null,null,6,20] is a false case but not true?"
                    },
                    {
                        "username": "onkar_AZ",
                        "content": "The given list, [10, 5, 15, null, null, 6, 20], does not represent a valid Binary Search Tree (BST) because it violates the property of a BST. In a BST, for any given node, all the values in its left subtree must be less than the node\\'s value, and all the values in its right subtree must be greater than the node\\'s value.\\n\\nLet\\'s analyze the given list step by step:\\n\\nThe root node has a value of 10.\\nThe left child of the root node has a value of 5, which is valid since it is less than 10.\\nThe right child of the root node has a value of 15, which is valid since it is greater than 10.\\nThe left child of the right child of the root node has a value of 6. Here lies the problem. This violates the BST property since 6 is less than the root node\\'s value of 10, but it is on the right side of the root node.\\nThe right child of the right child of the root node has a value of 20, which is valid since it is greater than 15.\\nSince the property of a BST is violated at step 4, where 6 is on the right side of the root node, the given list does not represent a valid BST."
                    },
                    {
                        "username": "aadil_rashid",
                        "content": "once you draw the tree structure, you will find that 10 is our root, and 5 and 15 are it\\'s left and right child, also 5 has both children none and 15 has 6 and 20 as it\\'s left and right child, here if we will see 6 with respect to 10, (our root node), it comes out that 6 comes on right sub-tree of 10, which should not be the case in BST, right sub tree should have values greater that root, that\\'s why it\\'s **False** case"
                    },
                    {
                        "username": "pratapsinghshreshth123",
                        "content": "Because 6 < 10 and In a BST, all nodes in the right-side of the root must be greater than it."
                    },
                    {
                        "username": "nathaly12toledo",
                        "content": "6 is less than the root node\\'s value. Yet 2 it is located on the right side/right tree. According to the rule, \"The right subtree of a node contains only nodes with keys greater than the node\\'s key\""
                    },
                    {
                        "username": "mrsujeet",
                        "content": "I observed the definition for BST is wrongly mentioned. As per description and example given, all the nodes on the left subtree should be always having values less than current node value but that is not case, there could be possible a node having value equal to node value. According one test case is failing when left node have same value as root node value."
                    },
                    {
                        "username": "EACast",
                        "content": "Testcase: [32,26,47,19,null,null,56,null,27]\\nis supposed to be false????? Doesn\\'t make sense.\\n\\n26,19, 27 are all to the left and less than 32\\n47, 56 are to the right of node and are all greater than 32"
                    },
                    {
                        "username": "Ryanwwwww",
                        "content": "[@greenchalk](/greenchalk) The reason might be the [null, 27] is the left and right of the 56. Sometimes it is hard to understand the shape of the tree by Array. The above is just what I thought. I dont know if it is true."
                    },
                    {
                        "username": "greenchalk",
                        "content": "[@carrtesy](/carrtesy)  Why would 27 need to be smaller than 26? I'm having the same issue, cant comprehend why its expecting false."
                    },
                    {
                        "username": "carrtesy",
                        "content": "that might be because of 27, which should be less than 26. "
                    },
                    {
                        "username": "uc117",
                        "content": "Hello everyone, I was wondering if anyone can help me understand why many recursive solutions check the root node against min (-infinity) and max (infinity) values? Also I\\'m doing this in Python. \\n\\nAnd then we pass these inifinties down to other subtrees to compare against later (when checking left child and right child) ? \\n\\nI think I am lacking a clear appraoch to this problem. \\n\\nThank you"
                    },
                    {
                        "username": "escrowdis",
                        "content": "I\\'ve tested the out-of-boundary numbers to `TreeNode::val` and they passed. If overflow is restricted, then the first test case may return false as others. It looks like truncate the overflow bits to keep inside int which may lead to incorrect result in this problem. Did I miss something or it\\'s just not taking care of overflow in this situation?\\n\\nThank you for your time.\\n\\n- return true\\n\\t- [2147483648]\\n\\t- [2147483648001,2147483648000]\\n- return false\\n\\t- [2147483648000,2147483647] \\n\\t- [2147483648000,2147483648001] \\n\\nPS: INT_MAX = 2147483647, INT_MIN = -2147483648"
                    },
                    {
                        "username": "GFK_drums",
                        "content": "try a long"
                    },
                    {
                        "username": "abhijeet5000kumar",
                        "content": "##### Exclusive Tip : Use LLONG_MIN instead of INT_MIN "
                    }
                ]
            },
            {
                "id": 1852868,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1852078,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1747915,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1732816,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1726671,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1575322,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1574073,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1573486,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1573344,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1573316,
                "content": [
                    {
                        "username": "Sagar_Ojha",
                        "content": "root =\\n[-2147483648,-2147483648]\\n\\nmy code stuck here?"
                    },
                    {
                        "username": "prakhar4392",
                        "content": "same here... have you resolved it?"
                    },
                    {
                        "username": "PsiKai",
                        "content": "### Array notation of binary tree\n\nStruggling with a test case.  I think it's because I'm wrongly visualizing the binary tree from the array notation in more complex cases.\n\nI would assume the array:\n\n```js\nroot  =\n[32,26,47,19,null,null,56,null,27]\n```\n\nWould represent this visualization:\n\n```\n            32\n       /            \\\n      26             47\n    /    \\          /  \\\n  19    null      null  56\n  / \\\nnull 27\n```\nBut when I construct the tree from `TreeNode`s as I am interpreting it in the example above, I get the correct answer passing it into my solution.  \n\nAm I missing something about how this tree would be constructed?  Can you provide the correct way it should be visualized if I am wrong?  This is testcase 80 out of 82, so I've been doing something right along the way, but this notation issue is a blocker for me."
                    },
                    {
                        "username": "Im_ti_az",
                        "content": "Your visualization is correct. I checked it here: https://ideone.com/x2XbNC"
                    },
                    {
                        "username": "vghoghari82",
                        "content": "If someone has doubt, I hope it helps:\\nin BST all values in right must be greater than root (even sub-tree) and all values in left must be less than root (same even in sub-tree)\\nand you need to check this for all sub nodes in Tree"
                    },
                    {
                        "username": "prashant_71200",
                        "content": "class Solution {\\npublic:\\n   \\nvoid inOrder(TreeNode* root, vector<int>&res)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        inOrder(root->left,res);\\n        res.push_back(root->val);\\n        inOrder(root->right,res);\\n\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n         vector<int> res;\\n          inOrder(root,res);\\n\\n          for(int i=1;i<res.size();i++)\\n          {\\n              if(res[i-1]>res[i]);\\n              {\\n                  return false;\\n              }\\n          }\\n          return true;\\n    }\\n};\\n\\n\\ncan anyone tell what wrong in this code inorder of bst is in sorted order but it fail for [2 1 3] why ??\\n\\n"
                    },
                    {
                        "username": "shiv1312",
                        "content": " in if condition check also for equal condition\\nif(res[i-1]>=res[i])\\n{\\nreturn false;\\n}"
                    },
                    {
                        "username": "crazyfedor69",
                        "content": "i feel so stupid.. need 2 day to resolve.."
                    },
                    {
                        "username": "phudinhtruongk18",
                        "content": "i am taking 2 weeks"
                    },
                    {
                        "username": "andrsam",
                        "content": "Why binary search tree [10,5,15,null,null,6,20] not valid?"
                    },
                    {
                        "username": "Day_Tripper",
                        "content": "Because 6 is to the right side of 10 which contadicts the definition of a BST."
                    },
                    {
                        "username": "saty18",
                        "content": "\\n[10,5,15,null,null,6,20] - Any idea why this test case is not a valid binary search tree. As far as I can see the properties are fine"
                    },
                    {
                        "username": "KPVPAPARAO",
                        "content": "[10,5,15,null,null,6,20] - is a valid BST where as Leetcode expected answer is false?... am i missing anything here?"
                    },
                    {
                        "username": "mvo13",
                        "content": "root is 10, and 6 is at the bottom but on the right side of root => Invalid BST"
                    },
                    {
                        "username": "lookquincy",
                        "content": "have anyone met this test case?\\n\\n\\n![image](https://assets.leetcode.com/users/lookquincy/image_1578970523.png)\\n\\nisn\\'t this test case wrong?"
                    },
                    {
                        "username": "omartarek32",
                        "content": "how should this test case [10,5,15,null,null,6,20] return false?!\\n\\n\\n\\t\\t\\t\\t    10\\n\\t\\t\\t\\t  /\\t    \\\\\\n\\t            5        15\\n\\t                    /    \\\\\\n\\t\\t               6      20"
                    },
                    {
                        "username": "ZenMasterV",
                        "content": "For a BST we should be able to find the smallest node in the tree by traversing the leftmost link and vice versa to find the largest, if we were to delete 5 and tray to find the smallest value we\\'d get 10 which is false. Think of a BST as a chart with a bell curve where the main root is the average "
                    },
                    {
                        "username": "charan_bandaru",
                        "content": "In BST, the left node values should be less and right node values should be greater when compared to the root value i.e 6 is less than 10 , hence it should place in the left side, here it\\'s in the right side , so it\\'s considered as false.\\n"
                    },
                    {
                        "username": "glps452john2",
                        "content": "6 is smaller than 10."
                    }
                ]
            },
            {
                "id": 1572959,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572839,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572790,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572762,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572687,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572514,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572308,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572210,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1572132,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1571827,
                "content": [
                    {
                        "username": "RaviTeja51",
                        "content": "Test Case #39, [0,-1] , it is a valid binary tree and when I ran it the Run Test console I got true, but when I submitted the code for the same test case I got answer as false."
                    },
                    {
                        "username": "user991_22",
                        "content": "Thank you for your solution. I found a simple explaination with python code here as well- https://simplyexplained.tech/how-to-check-if-a-binary-tree-is-a-binary-search-tree-bst"
                    },
                    {
                        "username": "davis_benny",
                        "content": "Inorder Solution\\n\\nhttps://youtu.be/cLZa4zzt1E8\\n\\n\\nWell Explained !"
                    },
                    {
                        "username": "robotliu0327",
                        "content": "## [10,5,15,null,null,6,20] False?\\ncan anybody tell me [10,5,15,null,null,6,20] output is False? Any help is thanks!"
                    },
                    {
                        "username": "greenchalk",
                        "content": "So its actually very simple, the \"main node\" is the first node in your tree. So part of the rules state that all nodes on the right hand side must be greater than \\'main node\\' (10) and all nodes on the left side must be less than \\'main node\\' (10). Basically you will have left values to be less than main node and right nodes greater than main node"
                    },
                    {
                        "username": "PiJ",
                        "content": "How come it expects this test case to be a correct BST\\n[2147483647]\\nThis is not a BST but leetcode expects the program to return true for this test case !!"
                    },
                    {
                        "username": "JoshuaRogan",
                        "content": "is [10,5,15,null,null,6,20] a valid BST or am I missing something"
                    },
                    {
                        "username": "gnimgnot",
                        "content": "[1,1] is not BST?\\nI assume \"left <= root <= right\" is BST, am I wrong?"
                    },
                    {
                        "username": "codepractice1",
                        "content": "What is the tree resulting from this input? [10,5,15,null,null,6,20] Are nulls ignored or what? Where would they go otherwise?"
                    },
                    {
                        "username": "khavish",
                        "content": "My code is failing for the following test case\\n[10,5,15,null,null,6,20]\\n\\nOutput:\\ntrue\\nExpected:\\nfalse\\n\\nCan someone please clarify why it is not valid "
                    },
                    {
                        "username": "asingingbird",
                        "content": "Same input but different output in Submission and Run Code Status. What happened ?\\n\\n![0_1514952176495_QQ\\u622a\\u56fe20180103115706.png](/assets/uploads/files/1514952174862-qq\\u622a\\u56fe20180103115706-resized.png) \\n\\n![0_1514952188397_QQ\\u622a\\u56fe20180103115735.png](/assets/uploads/files/1514952187955-qq\\u622a\\u56fe20180103115735-resized.png)"
                    }
                ]
            },
            {
                "id": 1570413,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 1574701,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 1574503,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2066892,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2066748,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2064698,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2062539,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2050515,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2050467,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2031246,
                "content": [
                    {
                        "username": "austmatt",
                        "content": "They say the answer is False, but isn\\'t this a valid BST? All left nodes are < parent node and all right nodes > parent node, for all nodes. Does it have to do with the 3 being a child on the right hand side of 5 (though it is a valid child of 6)?\\n\\n[5,4,6,null,null,3,7]"
                    },
                    {
                        "username": "zxak",
                        "content": "Solution and explanation\\n\\nhttps://thefellowprogrammer.blogspot.com/2020/12/validate-binary-search-tree.html"
                    },
                    {
                        "username": "supercxman",
                        "content": "![image](https://assets.leetcode.com/users/images/e7d6407b-e5af-4d7b-8e91-6166a4bc98b3_1603129028.4786007.png)\\n\\nCan not pass one of the test cases.\\nShould the correct answer be True instead of False? Confused!\\n"
                    },
                    {
                        "username": "deve1212",
                        "content": "root =\\n[5,4,6,null,null,3,7]\\nhow this is false any idea"
                    },
                    {
                        "username": "gkay140",
                        "content": "[1,null,1]\\n\\nwhy this is not a valid BST ?"
                    },
                    {
                        "username": "aftabmk",
                        "content": "For those wondereing upper limit 2^31 hence use LONG_MAX instead INT_MAX."
                    },
                    {
                        "username": "priyankjagad59",
                        "content": " lst = []\n def dfs(node):\n            if not node:\n                return True\n            dfs(node.left)\n            if (len(lst)!=0 and node.val<lst[-1]):\n                return False\n            lst.append(node.val) \n            dfs(node.right)\n        return dfs(root)\n\nMy code is giving false for input [2,1,3] why?"
                    },
                    {
                        "username": "rahulkotteiitm2",
                        "content": "lass Solution:\\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\\n        return self.isvalid(root)\\n\\n\\n    def isvalid(self,node):\\n        if node is None:\\n            return True\\n\\n        if not (node.left.val <= node.val <= node.right.val):\\n            return False\\n        return self.isvalid(node.left) and self.isvalid(node.right)\\n\\nwhat is wrong with the above code? I dont get it"
                    },
                    {
                        "username": "Pratik_coder_110",
                        "content": "use LONG_MAX and LONG_MIN instead of INT_MIN,INT_MAX . Thank me later"
                    },
                    {
                        "username": "raghav_hehe",
                        "content": "can anyone please tell me what is wrong with this code\\n\\npublic boolean isValidBST(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        if(root.left==null && root.right!=null){\\n            if(root.val<root.right.val){\\n                return true;\\n            }      \\n        }\\n        if(root.right==null && root.left!=null){\\n            if(root.val>root.left.val){\\n                return true;\\n            }      \\n        }\\n\\n        if(root.val>root.left.val && root.val<root.right.val){\\n            return isValidBST(root.left) && isValidBST(root.right); \\n        }\\n        return false; \\n    }"
                    }
                ]
            },
            {
                "id": 2030796,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2027691,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2016068,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2013386,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2011238,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2009408,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2008817,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 2004491,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 1969500,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 1967746,
                "content": [
                    {
                        "username": "G0V1ND",
                        "content": "`Inorder Traversal in BST is always a strictly increasing array.`"
                    },
                    {
                        "username": "srivatsasrinivas1729",
                        "content": "Did you really have to include INT_MAX and INT_MIN as possible values? The single node with INT_MAX as the value is such a \"gotcha\". Let us use infinity in peace, dude."
                    },
                    {
                        "username": "willsapgreen",
                        "content": "Why the following tree is BST?\\nroot =\\n[2147483647]\\n       ^ this 7 is in the 2\\'s (the root) left subtree, isn\\'t it?\\nThank you"
                    },
                    {
                        "username": "Ahdivio",
                        "content": "why not user inorder traversal and check if the list prepared is sorted ?"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "`   public bool IsValidBST(\n        TreeNode root,\n        int? max = null,\n        int? min = null)\n    {\n        if (root == null)\n        {\n            return true;\n        }\n\n        if (\n            // if current node is a right node relative to the parent node\n            // then it should be greater than the parent node value\n            max != null && root.val >= max\n            ||\n            // if current node is a left node relative to the parent node\n            // then it should be greater than the parent node value\n            min != null && root.val <= min)\n        {\n            // return false if it violates any of these conditions\n            return false;\n        }\n\n        var result = IsValidBST(\n            // when we pass root value in the max parameter\n            // we say that this is the rule for left element\n            // because: left node < parent node\n            root.left,\n            root.val,\n            min)\n           && IsValidBST(\n               // when we pass root value in the min parameter\n               // we say that this is the rule for right node\n               // because: right node > parent node\n               root.right,\n               max,\n               root.val);\n\n        return result;\n    }`"
                    },
                    {
                        "username": "washimakram112001",
                        "content": "can anyone say why it is not working...\\nclass Solution {\\npublic:\\n    bool bst(TreeNode *root,int mini,int maxi){\\n        if(root==NULL) return 1;\\n        if(root->val>=maxi || root->val<=mini) return 0;\\n        return bst(root->left,mini,root->val) && bst(root->right,root->val,maxi);\\n    }\\n\\n    bool isValidBST(TreeNode* root) {\\n        return bst(root,INT_MIN,INT_MAX);\\n    }\\n};"
                    },
                    {
                        "username": "red1mist",
                        "content": "Use LONG_MAX and LONG_MIN"
                    },
                    {
                        "username": "jiaweiguo429",
                        "content": "Who ever use Integer.MAX_VALUE and Integer.MIN_VALUE to test the code??? Ridiculous"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "### Using Inorder Traversal\\nThe ***Inorder Traversal*** of a ***BST*** always gives a ***(strictly increasing) sorted list***.\\nSo to validate if a given tree ***is BST or not***, First find its ***Inorder Traversal***, and check if it ***is sorted or not***."
                    },
                    {
                        "username": "Stepash_ka",
                        "content": "Hi there, can someone please point out, this test fails \n\nroot =\n[5,4,6,null,null,3,7]\n\nExpected output is false, but from what I see it meets the criteria"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think, 3 < 5 (root) but is not in the left subtree or side of 5. So it is not a valid BST."
                    },
                    {
                        "username": "utkarsh821",
                        "content": "why break is giving address sanitizer when used inside while loop in morris traversal in this question?"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "I think you need to remove the threads that you created in Morris Traversal, but if break out of the loop those threads are never removed, so it is giving runntime error."
                    }
                ]
            },
            {
                "id": 1956270,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1956125,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1950307,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1922696,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1912121,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1910894,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1879552,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1873506,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1871866,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1864697,
                "content": [
                    {
                        "username": "nananiel",
                        "content": "When [5,2,6] is valid, [2,1,3] is valid,  [6,3,7] also true, how can\\nthis test case [5,2,6,1,3,3,7] be false? \\nAnyone knows why?  \\n"
                    },
                    {
                        "username": "codepiyush1",
                        "content": "# Intuition\\nC++, DFS(Preorder) Approach . EASY. Checking in range\\n\\n# Approach\\n\\n1. Define a recursive function `rec` that takes three arguments: `root` (a pointer to the current node), `low` (the minimum value allowed in the subtree), and `high` (the maximum value allowed in the subtree).\\n\\n2. If `root` is null (indicating an empty subtree), return `true` to indicate that the subtree is a valid BST.\\n\\n3. Recursively call `rec` for the left subtree with the updated `low` and `root->val` as the new range. Assign the result to `l`.\\n\\n4. Recursively call `rec` for the right subtree with the updated `root->val` and `high` as the new range. Assign the result to `r`.\\n\\n5. Check the following conditions:\\n   a. `l` is true (indicating the left subtree is a valid BST).\\n   b. `r` is true (indicating the right subtree is a valid BST).\\n   c. The value of the current node, `root->val`, is greater than `low`.\\n   d. The value of the current node, `root->val`, is less than `high`.\\n\\n6. If all the above conditions are satisfied, return `true`; otherwise, return `false` to indicate that the subtree is not a valid BST.\\n\\n7. Define a function `isValidBST` that takes a single argument `root` (a pointer to the root of the binary tree).\\n\\n8. If `root` is null (indicating an empty tree), return `true` to indicate that an empty tree is a valid BST.\\n\\n9. Call the `rec` function with the `root`, `LONG_MIN`, and `LONG_MAX` as the initial range.\\n\\n10. Return the result obtained from the `rec` function, which indicates whether the entire binary tree is a valid BST.\\n\\n----------------------------\\n# Complexity\\n- Time complexity:\\nT.C=O(n) have to visit all nodes.\\n\\n- Space complexity:\\nS.C=O(h) recursive stack space . h=height in worst case go upto n. When skewed tree.\\n---------------------------\\nPlease Upvote. If understand the concept.\\nSolution link:\\nhttps://leetcode.com/problems/validate-binary-search-tree/solutions/3717470/c-dfs-preorder-approach-easy-checking-in-range/"
                    },
                    {
                        "username": "guru_1826",
                        "content": "input root : [2147483647]\\nwhat kind of Input is it??"
                    },
                    {
                        "username": "prakhar432",
                        "content": "the test case for root = [2147483647] was  a very clever one XD. Got tricked on that"
                    },
                    {
                        "username": "__gajju0910__",
                        "content": "bhai node.val int me hai, values long long me kyu?\\nwhy are u confusing?\\n"
                    },
                    {
                        "username": "codetwod",
                        "content": "HINT: inorder traversal of BST is sorted."
                    },
                    {
                        "username": "dnthem",
                        "content": "Running my soluton on [0] and, [5,1] both return false but on my machine they both return true. Not sure whta is the problem here?\n\n let oldVal = undefined;\n/**\n * @param {TreeNode} root\n * @return {boolean}\n */\nvar isValidBST = function(root) {\n    if (root === null) return true;\n    return isValidBST(root.left) && check(root.val) && isValidBST(root.right);\n};\n\nfunction check(val) {\n    if (!oldVal || oldVal < val)\n    {\n        oldVal = val;\n        return true;\n    }\n    return false;\n}"
                    },
                    {
                        "username": "jameslyddon",
                        "content": "If anyone\\'s confused as to why something like [10,5,15,null,null,6,20]  isn\\'t a valid BST it\\'s because EVERY value to the right of a node has to be larger, not just the immediate child. So this is invalid because 6 is less than 10 (the original root) but in 10\\'s right sub-tree.\\n\\nPut another way, all values in the left sub-tree must be smaller than the root and all values in the right sub-tree must be larger than the root. For this to be valid 6 would need to be in the left sub-tree i.e. [10,5,15,null,6,null,20]"
                    },
                    {
                        "username": "devdk2208",
                        "content": "Use long long and INT64_MIN and INT64_MAX wherever required"
                    },
                    {
                        "username": "rahuls73528",
                        "content": "Why it is not passing every testcase ? \\n\\nclass Solution {\\n    public boolean validate(TreeNode root , long l , long r){\\n        if(root == null) return true;\\n        if(root.val<l || root.val>r) return false;\\n        boolean isLeftValid = validate(root.left, l, root.val -1);\\n        boolean isRightValid = validate(root.right, root.val +1 , r);\\n        return isRightValid && isLeftValid;\\n    }\\n    public boolean isValidBST(TreeNode root) {\\n        return validate(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1847227,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1842621,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1826913,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1826564,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1823971,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1820379,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1809953,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1794525,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1792486,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1782253,
                "content": [
                    {
                        "username": "rikkyhermanto",
                        "content": "why not put on constrain, \"There should be no duplicate values in the tree\"?"
                    },
                    {
                        "username": "pamiok17",
                        "content": "you guys need to add a few more tree examples."
                    },
                    {
                        "username": "rajesh503",
                        "content": "/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBST(Integer.MIN_VALUE, root, Integer.MAX_VALUE);\\n    }\\n    private boolean isValidBST(int minValue, TreeNode root, int maxValue) {\\n        if (root == null) {\\n            return true;\\n        }\\n        if (root.val >= maxValue || root.val <= minValue) {\\n            return false;\\n        }\\n        boolean leftResult = isValidBST(minValue, root.left, root.val);\\n        if (!leftResult) {\\n            return false;\\n        }\\n        return isValidBST(root.val, root.right, maxValue);\\n    }\\n}\\n\\nWhy is my code failing for test case: [2147483647]? thought this value is within integer? and input value range is also -2^31 to 2^31 -1 which is withing integer range? "
                    },
                    {
                        "username": "greenchalk",
                        "content": "Can anyone help me put?  My answer is true, expected answer is false. Cant see the problem with this tree, other than most children only have one node.\\n\\n[32,26,47,19,null,null,56,null,27]\\n"
                    },
                    {
                        "username": "tongdosa",
                        "content": "because: 27 is the right of 19, and 19 is the left of 26, but 27 > 26 => false"
                    },
                    {
                        "username": "gkgarry911",
                        "content": "Hi, Why the test case : \\nroot = [-2147483648,-2147483648] is failed.  \\nMaybe because I used the Integer MIN_VALUE and MAX_VALUE.\\nand during the logic I have added +1 for limit the uperbound range and same with lowerbound (-1).\\n `boolean left = isValidBST(root.left, min, root.val-1);`\\n `boolean right = isValidBST(root.right, root.val+1, max);` \\n\\nthis test case is failed since Output  : true. \\nwhile expected : false. \\n\\nkindly provide any solution."
                    },
                    {
                        "username": "jasiukiewicztymon",
                        "content": "Very unclever description for somebody who starts with binary trees..."
                    },
                    {
                        "username": "bortengineer",
                        "content": "The definition of BST in the problem description is incorrect. For example, [1, 1] should be a valid BST (left subtree should be allowed to have elements equal to the root node). "
                    },
                    {
                        "username": "Shiv_45",
                        "content": "Why This solution can\\'t pass all the testcases. as i am getting runtime error\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        if(root == null){\\n            return true;\\n        }\\n        int left = root.left.val;\\n        int right = root.right.val;\\n\\n        if(root.val < right && root.val > left){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }  \\n    }\\n}"
                    },
                    {
                        "username": "girish_the_great",
                        "content": "You are not checking for root.left == nullptr, and root.right == nullptr.\\nDereferencing nullptr."
                    },
                    {
                        "username": "rafal111",
                        "content": "This is so frustrating when you discover that problem is a bit different than \"description\" says. Maybe I\\'m just dumb to understand, but really be more descriptive, on problems. It\\'s silly that we need to analyse testcases to understand what exactly task is about.  "
                    },
                    {
                        "username": "girish_the_great",
                        "content": "Which part of the problem looks incorrect? Don\\'t look too much at the string depiction of the test cases, instead look at the diagrams."
                    },
                    {
                        "username": "GlebSa",
                        "content": "What should I do with null nodes (not leaf), where is the description of this? (\\u256F\\xB0\\u76CA\\xB0)\\u256F"
                    }
                ]
            },
            {
                "id": 1780545,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1777949,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1766315,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1761810,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1751961,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1728296,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1722428,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1714172,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1713120,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            },
            {
                "id": 1711864,
                "content": [
                    {
                        "username": "Harsh_Bansal_13",
                        "content": "what is optimised t.c of this question\\n"
                    },
                    {
                        "username": "tmartin8080",
                        "content": "Are there any solutions that consider the \"Contraints\" section?"
                    },
                    {
                        "username": "ashish_vishwakarma",
                        "content": "\\nclass Solution {\\n    public boolean isValidBST(TreeNode root) {\\n        int mainRoot = root.val;\\n        return isValidBSTUtil(root);\\n    }\\n\\n    public boolean isValidBSTUtil(TreeNode root){\\n        if(root == null) return true;\\n\\n        int rootVal = root.val;\\n        int leftVal = root.left != null?root.left.val: Integer.MIN_VALUE;\\n        int rightVal = root.right != null?root.right.val: Integer.MAX_VALUE;\\n        if(rootVal > leftVal && rootVal < rightVal){\\n            isValidBSTUtil(root.left);\\n            isValidBSTUtil(root.right);\\n        }\\n        else return false;\\n\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "ysabhishekmishra",
                        "content": "class Solution {\\npublic:\\n    bool isValidBST(TreeNode* root,int max=INT_MAX,int min=INT_MIN) {\\n        if(root==NULL){\\n            return true;\\n        }\\n        if(root->val<min || root->val>max){\\n            return false;\\n        }\\n        int isleftok=isValidBST(root->left,root->val-1,min);\\n        int isrightok=isValidBST(root->right,max,root->val+1);\\n        return isleftok && isrightok;\\n    }\\n};\\n\\n\\n//can anyone say whats wrong in this because not all TC are passing"
                    },
                    {
                        "username": "Abhi_Rauthan",
                        "content": "[@Abhishek Mishra](/ysabhishekmishra) This solution not passing all time complexity because read the constraints the maximum value root->val can take if you do +1 it will be an integer overflow in some cases similary when will you do -1 then in some cases it will be an integer underflow you can take long int then its passing all test cases."
                    },
                    {
                        "username": "DonjonMaster",
                        "content": "If it\\'s not a binary search tree, don\\'t call it a damn binary search tree. It\\'s a binary tree. This problem adds an extra rule that violates the normal definition of a binary search tree. Please rename the problem."
                    },
                    {
                        "username": "nishantsparaskar",
                        "content": "class Solution {\\n    public boolean isValidBST(TreeNode root) {\\n \\n//If tree is having node then tree is consider as BST\\nif(root == null)\\n{\\n    return  true;\\n}\\n\\nif(root.left != null )  // check left first is not null\\n{\\n    if(root.left.val >= root.val)  //check left  is greater than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean left = isValidBST(root.left);//check left  is greater than root.val\\n}\\n//else return true and go to below code for checking right side tree\\n\\n if(root.right != null )  // check right  side  is not null\\n{\\n    if(root.right.val <= root.val)//check right  is lesser than root.val i.e not valid BST\\n    { \\n     return false ;\\n    }\\n     boolean right = isValidBST(root.right);\\n}\\n//else return true and no invalid tree found so correct BST\\n     \\nreturn true;   \\n    }"
                    },
                    {
                        "username": "karthikmurakonda",
                        "content": "i see many people asking about [5,4,6,null,null,3,7].\\njust 10min ago interviewer asked me this question. i wrote pseudo code  which fails this test case. He did say nothing about this.\\n\\nbut in the end when i asked for feedback he said me to check on example test cases always after writing code. i guess i won\\'t be selected :("
                    },
                    {
                        "username": "211918",
                        "content": " `bool isBST(TreeNode* root, int mini, int maxi){\\n         if(!root){\\n            return true;\\n         }\\n\\n        if(root->val>mini && root->val<maxi){\\n            bool l= isBST(root->left, mini,root->val);\\n            bool r= isBST(root->right,root->val,maxi);\\n\\n            return l&&r;        \\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n    bool isValidBST(TreeNode* root) {\\n       return isBST(root, INT_MIN, INT_MAX);\\n    }`\\n\\nWhat\\'s wrong in this code?? 74/82 Testcases Passed\\n\\n"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "did you found the bug in your code?? i have the similar code by Lovebabbar so ... what is the bug?"
                    },
                    {
                        "username": "nurdaaaa03",
                        "content": "That\\'s the solution for this problem.\\nRecursively and iterative.\\nclass Solution {\\n    ArrayList<Integer> list = new ArrayList<>();\\n    public boolean isValidBST(TreeNode root){\\n        inorder(root);\\n        for (int i = 0; i < list.size(); i++) {\\n            if (list.get(i) >= list.get(i+1)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public void inorder(TreeNode root){\\n        if (root == null){\\n            return;\\n        }\\n        inorder(root.left);\\n        list.add(root.val);\\n        inorder(root.right);\\n    }\\n}\\n----------------------------------------------------------------------------------------------\\npublic boolean isValidBST (TreeNode root){\\n       Stack<TreeNode> stack = new Stack<TreeNode> ();\\n       TreeNode cur = root ;\\n       TreeNode pre = null ;       \\n       while (!stack.isEmpty() || cur != null) {         \\n         if (cur != null) {\\n           stack.push(cur);\\n           cur = cur.left ;\\n         } else {           \\n           TreeNode p = stack.pop() ;\\n           if (pre != null && p.val <= pre.val) {             \\n             return false ;\\n           }           \\n           pre = p ;             \\n           cur = p.right ;\\n         }\\n       }\\n       return true ; \\n }"
                    },
                    {
                        "username": "taabish_khan22",
                        "content": "Could someone explain the space complexity?"
                    }
                ]
            }
        ]
    },
    {
        "title": "House Robber",
        "question_content": "<p>You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and <b>it will automatically contact the police if two adjacent houses were broken into on the same night</b>.</p>\n\n<p>Given an integer array <code>nums</code> representing the amount of money of each house, return <em>the maximum amount of money you can rob tonight <b>without alerting the police</b></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3,1]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,7,9,3,1]\n<strong>Output:</strong> 12\n<strong>Explanation:</strong> Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 100</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 400</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 156523,
                "title": "from-good-to-great-how-to-approach-most-of-dp-problems",
                "content": "There is some frustration when people publish their perfect fine-grained algorithms without sharing any information abut how they were derived. This is an attempt to change the situation. There is not much more explanation but it\\'s rather an example of higher level improvements. Converting a solution to the next step shouldn\\'t be as hard as attempting to come up with perfect algorithm at first attempt.\\n\\nThis particular problem and most of others can be approached using the following sequence:\\n1. Find recursive relation\\n2. Recursive (top-down)\\n3. Recursive + memo (top-down) \\n4. Iterative + memo (bottom-up) \\n5. Iterative + N variables (bottom-up)\\n\\n**Step 1.** Figure out recursive relation. \\nA robber has 2 options: a) rob current house `i`; b) don\\'t rob current house. \\nIf an option \"a\" is selected it means she can\\'t rob previous `i-1` house but can safely proceed to the one before previous `i-2` and gets all cumulative loot that follows.\\nIf an option \"b\" is selected the robber gets all the possible loot from robbery of `i-1` and all the following buildings.\\nSo it boils down to calculating what is more profitable: \\n* robbery of current house + loot from houses before the previous\\n* loot from the previous house robbery and any loot captured before that\\n\\n`rob(i) = Math.max( rob(i - 2) + currentHouseValue, rob(i - 1) )`\\n\\n**Step 2.** Recursive (top-down)\\nConverting the recurrent relation from Step 1 shound\\'t be very hard.\\n```\\npublic int rob(int[] nums) {\\n    return rob(nums, nums.length - 1);\\n}\\nprivate int rob(int[] nums, int i) {\\n    if (i < 0) {\\n        return 0;\\n    }\\n    return Math.max(rob(nums, i - 2) + nums[i], rob(nums, i - 1));\\n}\\n```\\nThis algorithm will process the same `i` multiple times and it needs improvement. Time complexity: [to fill]\\n\\n**Step 3.** Recursive + memo (top-down).\\n```\\nint[] memo;\\npublic int rob(int[] nums) {\\n    memo = new int[nums.length + 1];\\n    Arrays.fill(memo, -1);\\n    return rob(nums, nums.length - 1);\\n}\\n\\nprivate int rob(int[] nums, int i) {\\n    if (i < 0) {\\n        return 0;\\n    }\\n    if (memo[i] >= 0) {\\n        return memo[i];\\n    }\\n    int result = Math.max(rob(nums, i - 2) + nums[i], rob(nums, i - 1));\\n    memo[i] = result;\\n    return result;\\n}\\n```\\nMuch better, this should run in `O(n)` time. Space complexity is `O(n)` as well, because of the recursion stack, let\\'s try to get rid of it.\\n\\n**Step 4.** Iterative + memo (bottom-up) \\n```\\npublic int rob(int[] nums) {\\n    if (nums.length == 0) return 0;\\n    int[] memo = new int[nums.length + 1];\\n    memo[0] = 0;\\n    memo[1] = nums[0];\\n    for (int i = 1; i < nums.length; i++) {\\n        int val = nums[i];\\n        memo[i+1] = Math.max(memo[i], memo[i-1] + val);\\n    }\\n    return memo[nums.length];\\n}\\n```\\n\\n**Step 5.** Iterative + 2 variables (bottom-up)\\nWe can notice that in the previous step we use only `memo[i]` and `memo[i-1]`, so going just 2 steps back. We can hold them in 2 variables instead. This optimization is met in Fibonacci sequence creation and some other problems [to paste links].\\n\\n```\\n/* the order is: prev2, prev1, num  */\\npublic int rob(int[] nums) {\\n    if (nums.length == 0) return 0;\\n    int prev1 = 0;\\n    int prev2 = 0;\\n    for (int num : nums) {\\n        int tmp = prev1;\\n        prev1 = Math.max(prev2 + num, prev1);\\n        prev2 = tmp;\\n    }\\n    return prev1;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic int rob(int[] nums) {\\n    return rob(nums, nums.length - 1);\\n}\\nprivate int rob(int[] nums, int i) {\\n    if (i < 0) {\\n        return 0;\\n    }\\n    return Math.max(rob(nums, i - 2) + nums[i], rob(nums, i - 1));\\n}\\n```\n```\\nint[] memo;\\npublic int rob(int[] nums) {\\n    memo = new int[nums.length + 1];\\n    Arrays.fill(memo, -1);\\n    return rob(nums, nums.length - 1);\\n}\\n\\nprivate int rob(int[] nums, int i) {\\n    if (i < 0) {\\n        return 0;\\n    }\\n    if (memo[i] >= 0) {\\n        return memo[i];\\n    }\\n    int result = Math.max(rob(nums, i - 2) + nums[i], rob(nums, i - 1));\\n    memo[i] = result;\\n    return result;\\n}\\n```\n```\\npublic int rob(int[] nums) {\\n    if (nums.length == 0) return 0;\\n    int[] memo = new int[nums.length + 1];\\n    memo[0] = 0;\\n    memo[1] = nums[0];\\n    for (int i = 1; i < nums.length; i++) {\\n        int val = nums[i];\\n        memo[i+1] = Math.max(memo[i], memo[i-1] + val);\\n    }\\n    return memo[nums.length];\\n}\\n```\n```\\n/* the order is: prev2, prev1, num  */\\npublic int rob(int[] nums) {\\n    if (nums.length == 0) return 0;\\n    int prev1 = 0;\\n    int prev2 = 0;\\n    for (int num : nums) {\\n        int tmp = prev1;\\n        prev1 = Math.max(prev2 + num, prev1);\\n        prev2 = tmp;\\n    }\\n    return prev1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55693,
                "title": "c-1ms-o-1-space-very-simple-solution",
                "content": "    #define max(a, b) ((a)>(b)?(a):(b))\\n    int rob(int num[], int n) {\\n        int a = 0;\\n        int b = 0;\\n        \\n        for (int i=0; i<n; i++)\\n        {\\n            if (i%2==0)\\n            {\\n                a = max(a+num[i], b);\\n            }\\n            else\\n            {\\n                b = max(a, b+num[i]);\\n            }\\n        }\\n        \\n        return max(a, b);\\n    }",
                "solutionTags": [],
                "code": "    #define max(a, b) ((a)>(b)?(a):(b))\\n    int rob(int num[], int n) {\\n        int a = 0;\\n        int b = 0;\\n        \\n        for (int i=0; i<n; i++)\\n        {\\n            if (i%2==0)\\n            {\\n                a = max(a+num[i], b);\\n            }\\n            else\\n            {\\n                b = max(a, b+num[i]);\\n            }\\n        }\\n        \\n        return max(a, b);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1605797,
                "title": "c-python-4-simple-solutions-w-explanation-optimization-from-brute-force-to-dp",
                "content": "We are given an array of money in each house `A` and we need to return the maximum amount we can rob without robbing from any two adjacent houses.\\n\\n---\\n\\n\\u274C ***Solution - I (Brute-Force)***\\n\\nLet\\'s try solving with brute-force approach. For each house, we have two choices -\\n1. **Dont rob** the house and **move to next house**.\\n2. **Rob** the house and **move to the house after next house** (We dont move directly to next house because we can rob adjacent houses).\\n\\nSo, we will just try with both these choices and choose the one the yields the maximum amount of loot.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rob(vector<int>& A, int i = 0) {\\n        return i < size(A) ? max(rob(A, i+1), A[i] + rob(A, i+2)) : 0;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def rob(self, A, i = 0):\\n        return max(self.rob(A, i+1), A[i] + self.rob(A, i+2)) if i < len(A) else 0\\n```\\n\\n***Time Complexity :*** <code>O(2<sup>N</sup>)</code>, where `N` is the number of elements in `A`. At each index, we have two choices of either robbing or not robbing the current house. Thus this leads to time complexity of <code>2\\\\*2*2...n times \\u2248 O(2<sup>N</sup>)</code>\\n***Space Complexity :*** <code>O(N)</code>, required by implicit recursive stack. The max depth of recursion can go upto `N`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Dynamic Programming - Memoization)***\\n\\nIn the above solution, we were performing many redundant repeated computations. This can be observed by drawing out the recursive tree for above function and observing that `rob(i)` is called multiple times. But `rob(i)` is nothing but the maximum amount of loot we can get starting at index `i` and this amount remains the same at each call.\\n\\nSo, instead of re-computing multiple times, we can store the result of a function call and directly reuse it on future calls instead of recomputing from scratch. This calls for **dynamic programming**, or memoization to be more specific. Here, we can use a linear `dp` array where `dp[i]` will denote the maximum amount of loot we can get starting at `i` index. Initially all elements of `dp` are initialized to `-1` denoting they haven\\'t been computed yet, Each time, we will save the computed result in this `dp` for an index `i` and directly return it if a future call is made to this index.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rob(vector<int>& A) {\\n        vector<int> dp(size(A),-1);\\n        return rob(A, dp, 0);\\n    }\\n    int rob(vector<int>& A, vector<int>& dp, int i) {\\n        if(i >= size(A)) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        return dp[i] = max(rob(A, dp, i+1), A[i] + rob(A, dp, i+2));\\n    }\\n};\\n```\\n\\n<blockquote>\\n<details>\\n<summary>One-Liner</summary>\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int dp[101]{[0 ... 100] = -1};\\n    int rob(vector<int>& A, int i = 0) {\\n        return i < size(A) ? dp[i] != -1 ? dp[i] : dp[i] = max(rob(A, i+1), A[i] + rob(A, i+2)) : 0;\\n    }\\n};\\n```\\n\\n</details>\\n</blockquote>\\n\\n**Python**\\n```python\\nclass Solution:\\n    def rob(self, A):\\n        @cache\\n        def rob(i):\\n            return max(rob(i+1), A[i] + rob(i+2)) if i < len(A) else 0\\n        return rob(0)\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, We calculate the result for each index only once & there are `N` indices. Thus overall time complexity is `O(N)`.\\n***Space Complexity :*** <code>O(N)</code>, required for `dp` and implicit recursive stack. \\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Dynamic Programming - Tabulation)***\\n\\nWe can implement the same logic as above in an iterate approach as well. Here, we again use a `dp` array to save the results of computation. In this case, `dp[i]` will denote maximum loot that we can get by considering till `i`th index. At every index,\\n* We can keep same loot as we had at previous index - `dp[i-1]`\\n* Or, we can rob the current house and add it to the loot we have at `i-2`th index - `A[i] + dp[i-2]`\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rob(vector<int>& A) {\\n        if(size(A) == 1) return A[0];\\n        vector<int> dp(A);\\n        dp[1] = max(A[0], A[1]);\\n        for(int i = 2; i < size(A); i++)\\n            dp[i] = max(dp[i-1], A[i] + dp[i-2]);\\n        return dp.back();\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def rob(self, A):\\n        if len(A) == 1: return A[0]\\n        dp = [*A]\\n        dp[1] = max(A[0], A[1])\\n        for i in range(2, len(A)):\\n            dp[i] = max(dp[i-1], A[i] + dp[i-2])\\n        return dp[-1]\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>, just single iteration is performed from `2` to `N` to compute each `dp[i]`.\\n***Space Complexity :*** <code>O(N)</code>, required for `dp`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Space-Optimzed Dynamic Programming)***\\n\\nWe can observe that the above dp solution relied only on the previous two indices in `dp` to compute the value of current `dp[i]`. So, we dont really need to maintain the whole `dp` array and can instead just maintain the values of previous index (denoted as **`prev`** below) and previous-to-previous index (denoted as **`prev2`**) and we can calculate the value for current index (**`cur`**) using just these two variables and roll-forward each time.\\n\\n\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    int rob(vector<int>& A) {\\n        int prev2 = 0, prev = 0, cur = 0;\\n        for(auto i : A) {\\n            cur = max(prev, i + prev2);\\n            prev2 = prev;\\n            prev = cur;\\n        }\\n        return cur;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def rob(self, A):\\n        prev2, prev, cur = 0,0,0\\n        for i in A:\\n            cur = max(prev, i + prev2)\\n            prev2 = prev\\n            prev = cur\\n        return cur\\n```\\n\\n***Time Complexity :*** <code>O(N)</code>\\n***Space Complexity :*** <code>O(1)</code>, only constant extra space is used.\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int rob(vector<int>& A, int i = 0) {\\n        return i < size(A) ? max(rob(A, i+1), A[i] + rob(A, i+2)) : 0;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rob(self, A, i = 0):\\n        return max(self.rob(A, i+1), A[i] + self.rob(A, i+2)) if i < len(A) else 0\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rob(vector<int>& A) {\\n        vector<int> dp(size(A),-1);\\n        return rob(A, dp, 0);\\n    }\\n    int rob(vector<int>& A, vector<int>& dp, int i) {\\n        if(i >= size(A)) return 0;\\n        if(dp[i] != -1) return dp[i];\\n        return dp[i] = max(rob(A, dp, i+1), A[i] + rob(A, dp, i+2));\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int dp[101]{[0 ... 100] = -1};\\n    int rob(vector<int>& A, int i = 0) {\\n        return i < size(A) ? dp[i] != -1 ? dp[i] : dp[i] = max(rob(A, i+1), A[i] + rob(A, i+2)) : 0;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rob(self, A):\\n        @cache\\n        def rob(i):\\n            return max(rob(i+1), A[i] + rob(i+2)) if i < len(A) else 0\\n        return rob(0)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rob(vector<int>& A) {\\n        if(size(A) == 1) return A[0];\\n        vector<int> dp(A);\\n        dp[1] = max(A[0], A[1]);\\n        for(int i = 2; i < size(A); i++)\\n            dp[i] = max(dp[i-1], A[i] + dp[i-2]);\\n        return dp.back();\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rob(self, A):\\n        if len(A) == 1: return A[0]\\n        dp = [*A]\\n        dp[1] = max(A[0], A[1])\\n        for i in range(2, len(A)):\\n            dp[i] = max(dp[i-1], A[i] + dp[i-2])\\n        return dp[-1]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int rob(vector<int>& A) {\\n        int prev2 = 0, prev = 0, cur = 0;\\n        for(auto i : A) {\\n            cur = max(prev, i + prev2);\\n            prev2 = prev;\\n            prev = cur;\\n        }\\n        return cur;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def rob(self, A):\\n        prev2, prev, cur = 0,0,0\\n        for i in A:\\n            cur = max(prev, i + prev2)\\n            prev2 = prev\\n            prev = cur\\n        return cur\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55696,
                "title": "python-solution-3-lines",
                "content": "Based on the recursive formula:\\n\\n>     f(0) = nums[0]\\n>     f(1) = max(num[0], num[1])\\n>     f(k) = max( f(k-2) + nums[k], f(k-1) )\\n\\n    class Solution:\\n        \\n        def rob(self, nums):\\n            \\n            last, now = 0, 0\\n            \\n            for i in nums: last, now = now, max(last + i, now)\\n                    \\n            return now",
                "solutionTags": [],
                "code": "Based on the recursive formula:\\n\\n>     f(0) = nums[0]\\n>     f(1) = max(num[0], num[1])\\n>     f(k) = max( f(k-2) + nums[k], f(k-1) )\\n\\n    class Solution:\\n        \\n        def rob(self, nums):\\n            \\n            last, now = 0, 0\\n            \\n            for i in nums: last, now = now, max(last + i, now)\\n                    \\n            return now",
                "codeTag": "Java"
            },
            {
                "id": 55681,
                "title": "java-o-n-solution-space-o-1",
                "content": "    public int rob(int[] num) {\\n        int[][] dp = new int[num.length + 1][2];\\n        for (int i = 1; i <= num.length; i++) {\\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);\\n            dp[i][1] = num[i - 1] + dp[i - 1][0];\\n        }\\n        return Math.max(dp[num.length][0], dp[num.length][1]);\\n    }\\n\\ndp[i][1] means we rob the current house and dp[i][0] means we don't,\\n\\nso it is easy to convert this to O(1) space\\n\\n    public int rob(int[] num) {\\n        int prevNo = 0;\\n        int prevYes = 0;\\n        for (int n : num) {\\n            int temp = prevNo;\\n            prevNo = Math.max(prevNo, prevYes);\\n            prevYes = n + temp;\\n        }\\n        return Math.max(prevNo, prevYes);\\n    }",
                "solutionTags": [],
                "code": "    public int rob(int[] num) {\\n        int[][] dp = new int[num.length + 1][2];\\n        for (int i = 1; i <= num.length; i++) {\\n            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);\\n            dp[i][1] = num[i - 1] + dp[i - 1][0];\\n        }\\n        return Math.max(dp[num.length][0], dp[num.length][1]);\\n    }\\n\\ndp[i][1] means we rob the current house and dp[i][0] means we don't,\\n\\nso it is easy to convert this to O(1) space\\n\\n    public int rob(int[] num) {\\n        int prevNo = 0;\\n        int prevYes = 0;\\n        for (int n : num) {\\n            int temp = prevNo;\\n            prevNo = Math.max(prevNo, prevYes);\\n            prevYes = n + temp;\\n        }\\n        return Math.max(prevNo, prevYes);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1605133,
                "title": "c-discussing-all-solutions-dp-with-constant-space",
                "content": "This is a classic 1D-DP problem where at every step we have a choice to make ...\\nSo the first and foremost thing in any DP problem is to find the reccurence relation !!\\n    At every ith house robber has 2 options: *a) rob current house i.* *b) don\\'t rob current house.*\\n* In case he is robbing the (i)th house, the money he can get till the i-th house == money robbed till (i-2)th house + money robbed at (i)th house....let\\'s say total money robbed in this case equals to X.\\n* In case he is not robbing, money robbed till i-th house==money robbed till (i-1)th house...lets say total money robbed in this case equals to Y.\\n* So , the maxm money he gets till i-th house is the max(X,Y).\\n\\nExample of case (a) --> nums={2,3,2} ... Here, the robber will rob the house at index-2 as nums[index-2] + nums[index-0] > nums[index-1]\\nExample of case (b)--> nums={2,7,3} ... here maximum money robbed till index-2 will not be equal to nums[index-2] + nums[index-0]... as nums[index-1] is greater than the sum of money at both those houses ...\\n\\n*We can achieve the desired solution to this problem via mutliple ways, let\\'s start with the simpler ones and then will look forward to optimize the **Time and Space Complexities***\\n\\n\\n1. **Simple Recursion**\\n\\n* Time  Complexcity  :  O ( 2^n )   Gives us TLE\\n* Space Complexcity : O( 1 )\\n```\\nclass Solution {\\npublic:\\n    int rec(vector<int>& nums,int idx){\\n        if(idx>=nums.size())return 0;\\n        return max(nums[idx]+rec(nums,idx+2),rec(nums,idx+1));\\n    }\\n    int rob(vector<int>& nums) {\\n        return rec(nums,0);\\n    }\\n};\\n```\\n\\n\\n2. **Memoization**\\n\\n* Time  Complexcity  :  O (n)\\n* Space Complexcity : O(n)\\n    \\n ```   \\nclass Solution {\\npublic:\\n   int rec(vector<int>& nums,int idx,vector<int>&dp){\\n        if(idx >= nums.size()) return 0;\\n        if(dp[idx] != -1) return dp[idx];\\n        return dp[idx] = max(rec(nums, idx+1, dp), nums[idx] + rec(nums, idx+2, dp));\\n   }\\n   int rob(vector<int>& nums) {\\n       vector<int>dp(nums.size()+1,-1);\\n       return rec(nums,0,dp);\\n   }\\n};\\n```\\n\\n\\n3. **Dynamic Programming**\\n\\n* Time Complexity : O(n)\\n* Space Complexity : O(n)    \\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        vector<int>dp(nums.size());\\n        dp[0]=nums[0];\\n        dp[1]=max(nums[0],nums[1]);\\n        for(int i=2;i<nums.size();i++){\\n            dp[i]=max(dp[i-1],dp[i-2]+nums[i]);\\n        }\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\\n\\n4.**Dynamic Programming**  (improved version)\\n \\n* Time Complexity : O(n)\\n* Space complexity : O(1)\\n\\nWe can optimize the space now,\\nas we can see we only need to know the answer till (i-1)th idx and (i-2)th idx to have an answer for the (i)th idx. And we don\\'t really care about the whole dp-vector, so there is no point maintaining one... 3 variables will do the job, prev_ans (for i-1), prev_ans2(for i-2) and curr_ans !!\\n\\n* dp[i - 2] - previous answer(till i-2 idx) -> prev_ans2\\n* dp[i - 1] - previous answer(till i-1 idx) -> prev_ans\\n* dp[i] - current answer(can be prev_ans or prev_ans2+nums[i]) -> curr_ans\\nSo we will get rid of the dp-vector and thus our SC will get reduced down to O(1)\\n(It is very similar to fibonacci series Space optimization)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        \\n        int prev_ans2=nums[0], prev_ans=max(nums[0],nums[1]),curr_ans=prev_ans;\\n        \\n        for(int i = 2; i < n; i++){\\n            curr_ans = max(prev_ans, prev_ans2 + nums[i]);\\n            prev_ans2 = prev_ans;\\n            prev_ans = curr_ans;\\n        }\\n        return curr_ans;\\n    }\\n};    \\n```\\nWell, Thanks for reading it out !!",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rec(vector<int>& nums,int idx){\\n        if(idx>=nums.size())return 0;\\n        return max(nums[idx]+rec(nums,idx+2),rec(nums,idx+1));\\n    }\\n    int rob(vector<int>& nums) {\\n        return rec(nums,0);\\n    }\\n};\\n```\n```   \\nclass Solution {\\npublic:\\n   int rec(vector<int>& nums,int idx,vector<int>&dp){\\n        if(idx >= nums.size()) return 0;\\n        if(dp[idx] != -1) return dp[idx];\\n        return dp[idx] = max(rec(nums, idx+1, dp), nums[idx] + rec(nums, idx+2, dp));\\n   }\\n   int rob(vector<int>& nums) {\\n       vector<int>dp(nums.size()+1,-1);\\n       return rec(nums,0,dp);\\n   }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==1)return nums[0];\\n        vector<int>dp(nums.size());\\n        dp[0]=nums[0];\\n        dp[1]=max(nums[0],nums[1]);\\n        for(int i=2;i<nums.size();i++){\\n            dp[i]=max(dp[i-1],dp[i-2]+nums[i]);\\n        }\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 1) return nums[0];\\n        \\n        int prev_ans2=nums[0], prev_ans=max(nums[0],nums[1]),curr_ans=prev_ans;\\n        \\n        for(int i = 2; i < n; i++){\\n            curr_ans = max(prev_ans, prev_ans2 + nums[i]);\\n            prev_ans2 = prev_ans;\\n            prev_ans = curr_ans;\\n        }\\n        return curr_ans;\\n    }\\n};    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 55695,
                "title": "java-dp-solution-o-n-runtime-and-o-1-space-with-inline-comment",
                "content": "    public int rob(int[] num) {\\n        int rob = 0; //max monney can get if rob current house\\n        int notrob = 0; //max money can get if not rob current house\\n        for(int i=0; i<num.length; i++) {\\n            int currob = notrob + num[i]; //if rob current value, previous house must not be robbed\\n            notrob = Math.max(notrob, rob); //if not rob ith house, take the max value of robbed (i-1)th house and not rob (i-1)th house\\n            rob = currob;\\n        }\\n        return Math.max(rob, notrob);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public int rob(int[] num) {\\n        int rob = 0; //max monney can get if rob current house\\n        int notrob = 0; //max money can get if not rob current house\\n        for(int i=0; i<num.length; i++) {\\n            int currob = notrob + num[i]; //if rob current value, previous house must not be robbed\\n            notrob = Math.max(notrob, rob); //if not rob ith house, take the max value of robbed (i-1)th house and not rob (i-1)th house\\n            rob = currob;\\n        }\\n        return Math.max(rob, notrob);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 55761,
                "title": "java-0ms-solution-using-dynamic-programming",
                "content": "    public int rob(int[] nums) {  \\n        if(nums.length==0) return 0;\\n        if(nums.length==1) return nums[0];\\n\\n        //Initialize an arrays to store the money\\n    \\tint[] mark = new int[nums.length];\\n\\n        //We can infer the formula from problem:mark[i]=max(num[i]+mark[i-2],mark[i-1])\\n        //so initialize two nums at first.\\n    \\tmark[0] = nums[0];\\n    \\tmark[1] = Math.max(nums[0], nums[1]);\\n\\n        //Using Dynamic Programming to mark the max money in loop.\\n    \\tfor(int i=2;i<nums.length;i++){\\n    \\t\\tmark[i] = Math.max(nums[i]+mark[i-2], mark[i-1]);\\n    \\t}\\n\\t\\treturn mark[nums.length-1];\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int rob(int[] nums) {  \\n        if(nums.length==0) return 0;\\n        if(nums.length==1) return nums[0];\\n\\n        //Initialize an arrays to store the money\\n    \\tint[] mark = new int[nums.length];\\n\\n        //We can infer the formula from problem:mark[i]=max(num[i]+mark[i-2],mark[i-1])\\n        //so initialize two nums at first.\\n    \\tmark[0] = nums[0];\\n    \\tmark[1] = Math.max(nums[0], nums[1]);\\n\\n        //Using Dynamic Programming to mark the max money in loop.\\n    \\tfor(int i=2;i<nums.length;i++){\\n    \\t\\tmark[i] = Math.max(nums[i]+mark[i-2], mark[i-1]);\\n    \\t}\\n\\t\\treturn mark[nums.length-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 55977,
                "title": "python-dp-solution-4-line-o-n-time-o-1-space-easy-to-understand-with-detailed-explanation",
                "content": "The idea is the store the max sum we can get for each house use it to calculate the following houses until we get the final result.\\n\\nIn the path that the robber chose to rob with max money, it is guaranteed that either the last house (num[-1]) or the 2nd last house (num[-2]) will be robbed. So we can compare the max sum path that includes num[-1] with the max sum path that includes num[-2] and return the larger one.\\n\\nTo get the sums of the two paths, we scan from left to right. A sliding window of size 4, `[max_3_house_before, max_2_house_before, adjacent, cur]`, is used to calculate the max sum till the current house. The last element, `cur`, of the window is the money of the current house we are scanning. The 1st element, `max_3_house_before`, stores the max sum till the house that is 3 steps before the current one. The 2nd element, `max_2_house_before`, stores the max sum till the house that is 2 steps before the current one. The 3rd element, `adjacent`, stores the max sum till the house that are one step before the current one. To reach the current house, we either came from the house that is 3 steps before or from the one that is 2 steps before because visiting two adjacent houses is not allowed. So we can get the max sum till the current house by `max(cur+max_3_house_before, cur+max_2_house_before)`. \\n\\nBefore scanning the next house we update the window by moving one house forward: `max_3_house_before, max_2_house_before, adjacent = max_2_house_before, adjacent, max(max_3_house_before+cur, max_2_house_before+cur)`.\\n\\nWhen we finished the scanning, the max sum exists in either `max_2_house_before` or `adjacent`. So we return `max(max_2_house_before, adjacent)`.\\n\\nFor example: `num = [1,7,9,4]`, at the beginning,  `max_3_house_before, max_2_house_before, adjacent` are initialized to 0, so it is like putting 3 zeros before the input list `[0, 0, 0, 1, 7, 9, 4]`. Here are steps for calculating the max sum for each house(the sliding window is marked by parentheses):\\n\\n> [(0, 0, 0, **1**), 7, 9, 4], cur = max(0+1, 0+1)\\n\\n> -> [ (0, 0, 1, **7**), 9, 4], cur = max(0+7, 0+7)\\n\\n> -> [(0, 1, 7, **9**), 4], cur =  max(0+9, 1+9)\\n\\n> -> [(1, 7, 10, **4**)], cur = max(1+4, 7+4)\\n\\n> -> [7, 10, 11],  10 is the max sum of path that includes num[-2], 11 is the max sum of path that includes num[-1], so return max(10, 11)\\n\\nCode:\\n\\n        class Solution:\\n            # @param num, a list of integer\\n            # @return an integer\\n            def rob(self, num):\\n                max_3_house_before, max_2_house_before, adjacent = 0, 0, 0\\n                for cur in num:\\n                    max_3_house_before, max_2_house_before, adjacent = \\\\\\n                    max_2_house_before, adjacent, max(max_3_house_before+cur, max_2_house_before+cur)\\n                return max(max_2_house_before, adjacent)\\n\\nThere is a better solution using only 2 variables [here][1] but I found out myself too dumb and was able to understand it after I stared at it for 30min:(\\n\\n\\n  [1]: https://leetcode.com/discuss/30102/4-line-python-o-1-space-o-n-time-with-explaination-simplest",
                "solutionTags": [
                    "Python"
                ],
                "code": "The idea is the store the max sum we can get for each house use it to calculate the following houses until we get the final result.\\n\\nIn the path that the robber chose to rob with max money, it is guaranteed that either the last house (num[-1]) or the 2nd last house (num[-2]) will be robbed. So we can compare the max sum path that includes num[-1] with the max sum path that includes num[-2] and return the larger one.\\n\\nTo get the sums of the two paths, we scan from left to right. A sliding window of size 4, `[max_3_house_before, max_2_house_before, adjacent, cur]`, is used to calculate the max sum till the current house. The last element, `cur`, of the window is the money of the current house we are scanning. The 1st element, `max_3_house_before`, stores the max sum till the house that is 3 steps before the current one. The 2nd element, `max_2_house_before`, stores the max sum till the house that is 2 steps before the current one. The 3rd element, `adjacent`, stores the max sum till the house that are one step before the current one. To reach the current house, we either came from the house that is 3 steps before or from the one that is 2 steps before because visiting two adjacent houses is not allowed. So we can get the max sum till the current house by `max(cur+max_3_house_before, cur+max_2_house_before)`. \\n\\nBefore scanning the next house we update the window by moving one house forward: `max_3_house_before, max_2_house_before, adjacent = max_2_house_before, adjacent, max(max_3_house_before+cur, max_2_house_before+cur)`.\\n\\nWhen we finished the scanning, the max sum exists in either `max_2_house_before` or `adjacent`. So we return `max(max_2_house_before, adjacent)`.\\n\\nFor example: `num = [1,7,9,4]`, at the beginning,  `max_3_house_before, max_2_house_before, adjacent` are initialized to 0, so it is like putting 3 zeros before the input list `[0, 0, 0, 1, 7, 9, 4]`. Here are steps for calculating the max sum for each house(the sliding window is marked by parentheses):\\n\\n> [(0, 0, 0, **1**), 7, 9, 4], cur = max(0+1, 0+1)\\n\\n> -> [ (0, 0, 1, **7**), 9, 4], cur = max(0+7, 0+7)\\n\\n> -> [(0, 1, 7, **9**), 4], cur =  max(0+9, 1+9)\\n\\n> -> [(1, 7, 10, **4**)], cur = max(1+4, 7+4)\\n\\n> -> [7, 10, 11],  10 is the max sum of path that includes num[-2], 11 is the max sum of path that includes num[-1], so return max(10, 11)\\n\\nCode:\\n\\n        class Solution:\\n            # @param num, a list of integer\\n            # @return an integer\\n            def rob(self, num):\\n                max_3_house_before, max_2_house_before, adjacent = 0, 0, 0\\n                for cur in num:\\n                    max_3_house_before, max_2_house_before, adjacent = \\\\\\n                    max_2_house_before, adjacent, max(max_3_house_before+cur, max_2_house_before+cur)\\n                return max(max_2_house_before, adjacent)\\n\\nThere is a better solution using only 2 variables [here][1] but I found out myself too dumb and was able to understand it after I stared at it for 30min:(\\n\\n\\n  [1]: https://leetcode.com/discuss/30102/4-line-python-o-1-space-o-n-time-with-explaination-simplest",
                "codeTag": "Java"
            },
            {
                "id": 55838,
                "title": "dp-o-n-time-o-1-space-with-easy-to-understand-explanation",
                "content": "For every house k, there are two options: either to rob it (include this house: i) or not rob it (exclude this house: e). \\n\\n1. Include this house:\\ni = num[k] + e (money of this house + money robbed excluding the previous house)\\n\\n2. Exclude this house:\\ne = max(i, e) (max of money robbed including the previous house or money robbed excluding the previous house)\\n(note that i and e of the previous step, that's why we use tmp here to store the previous i when calculating e, to make O(1) space)\\n\\nHere is the code:\\n\\n    public class Solution {\\n        public int rob(int[] num) {\\n            int i = 0;\\n            int e = 0;\\n            for (int k = 0; k<num.length; k++) {\\n                int tmp = i;\\n                i = num[k] + e;\\n                e = Math.max(tmp, e);\\n            }\\n            return Math.max(i,e);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int rob(int[] num) {\\n            int i = 0;\\n            int e = 0;\\n            for (int k = 0; k<num.length; k++) {\\n                int tmp = i;\\n                i = num[k] + e;\\n                e = Math.max(tmp, e);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1605334,
                "title": "java-dp-with-and-without-space-explained",
                "content": "**Intution:** At every i-th house we have two choices to make, i.e., rob the i-th house or don\\'t rob it.\\n* Case1 : **Don\\'t rob the i-th house -** then we can rob the i-1 th house...so we will have max money robbed till i-1 th house\\n*  Case 2 : **Rob the i-th house -** then we cann\\'t rob the i-1 th house but we can rob i-2 th house....so we will have max money robbed till i-2 th house + money of i-th house.\\n**Example:** \\n1.) If the array is [1,5,3] then robber will rob the 1st index house because arr[1] > arr[0]+arr[2] (i.e., at last index, arr[i-1] > arr[i-2]+arr[i])\\n2.) If the array is [1,2,3] then robber will rob the 0th and 2nd index house because arr[0]+arr[2] > arr[1] (i.e., at last index, arr[i-2] + arr[i] > arr[i-1])\\n   \\n\\n**Approach 1: Dynamic Programming** \\nT.C : O(n)\\nS.C : O(n)\\n```\\n   class Solution {\\n    public int rob(int[] nums) {\\n        \\n        int n = nums.length;\\n        int dp[] = new int[n];\\n        dp[0]=nums[0];\\n        if(n==1){\\n            return nums[0];\\n        }\\n        \\n        dp[1] = Math.max(nums[0],nums[1]);\\n        \\n        for(int i=2;i<n;i++){\\n            dp[i] = Math.max(nums[i]+dp[i-2],dp[i-1]);\\n        }\\n        \\n        return dp[n-1];\\n\\n    }\\n}\\n```\\n\\n\\n**Approach 2: Modified Dynammic Programming**\\nT.C : O(n)\\nS.C : O(1)\\n\\n**Explanation:** We actually don\\'t need to have full dp array to store the previous values beacause we need only two previous values that is max robbery till i-2 th index and i-1 th index which we can store using two variables dp2 and dp1 resepectively.\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        if(n == 1) return nums[0];\\n        \\n        int dp2=nums[0], dp1=Math.max(nums[0],nums[1]),dp=dp1;\\n        \\n        for(int i = 2; i < n; i++){\\n            dp = Math.max(dp1, dp2 + nums[i]);\\n            dp2 = dp1;\\n            dp1 = dp;\\n        }\\n        return dp;\\n\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n   class Solution {\\n    public int rob(int[] nums) {\\n        \\n        int n = nums.length;\\n        int dp[] = new int[n];\\n        dp[0]=nums[0];\\n        if(n==1){\\n            return nums[0];\\n        }\\n        \\n        dp[1] = Math.max(nums[0],nums[1]);\\n        \\n        for(int i=2;i<n;i++){\\n            dp[i] = Math.max(nums[i]+dp[i-2],dp[i-1]);\\n        }\\n        \\n        return dp[n-1];\\n\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        int n = nums.length;\\n        \\n        if(n == 1) return nums[0];\\n        \\n        int dp2=nums[0], dp1=Math.max(nums[0],nums[1]),dp=dp1;\\n        \\n        for(int i = 2; i < n; i++){\\n            dp = Math.max(dp1, dp2 + nums[i]);\\n            dp2 = dp1;\\n            dp1 = dp;\\n        }\\n        return dp;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846004,
                "title": "python-4-lines-easy-dp-solution-explained",
                "content": "Nice and easy dynamic programming problem! Let `dp1` be maximum gain we can get, using last `i-1` houses and `dp2` maximum gain we can get, using `i` houses. How we need to update these numbers if we go from `i` to `i+1`? So `dp1` and `dp2` should mean gain for `i` and `i+1` houses.\\n\\n1. `dp1 = dp2`, gain to rob `i+1-1` houses is gain to rob `i` houses.\\n2. `dp2 = max(dp1 + num, dp2)`: we have 2 choices: either rob house number `i+1`, then we can rob `i`th house, so we have total gain `dp1 + num`, or we do not rob `i+1`th house, then we can gain `dp2`.\\n\\n**Complexity**: time complexity is `O(n)`, space complexity is `O(1)`.\\n\\n```\\nclass Solution:\\n    def rob(self, nums):\\n        dp1, dp2 = 0, 0\\n        for num in nums:\\n            dp1, dp2 = dp2, max(dp1 + num, dp2)          \\n        return dp2 \\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums):\\n        dp1, dp2 = 0, 0\\n        for num in nums:\\n            dp1, dp2 = dp2, max(dp1 + num, dp2)          \\n        return dp2 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 55736,
                "title": "c-my-solution-dp",
                "content": "    class Solution {\\n    public:\\n        int rob(vector<int>& nums) {\\n            const int n = nums.size();\\n            if (n == 0) return 0;\\n            if (n == 1) return nums[0];\\n            if (n == 2) return max(nums[0], nums[1]);\\n            vector<int> f(n, 0);\\n            f[0] = nums[0];\\n            f[1] = max(nums[0], nums[1]);\\n            for (int i = 2; i < n; ++i)\\n                f[i] = max(f[i-2] + nums[i], f[i-1]);\\n            return f[n-1];\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int rob(vector<int>& nums) {\\n            const int n = nums.size();\\n            if (n == 0) return 0;\\n            if (n == 1) return nums[0];\\n            if (n == 2) return max(nums[0], nums[1]);\\n            vector<int> f(n, 0);\\n            f[0] = nums[0];\\n            f[1] = max(nums[0], nums[1]);\\n            for (int i = 2; i < n; ++i)\\n                f[i] = max(f[i-2] + nums[i], f[i-1]);\\n            return f[n-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 346376,
                "title": "python-dynamic-programming-20-ms",
                "content": "```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        length = len(nums)\\n        if length==0:\\n            return 0\\n        if length==1:\\n            return nums[0]\\n        if length==2:\\n            return max(nums)\\n\\t\\t\\t\\n        dp = [0]*length # assign dp array\\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\\n        \\n        for i in range(2, length):\\n            dp[i] = max(dp[i-2]+nums[i], dp[i-1])\\n        print(dp)\\n        \\n        return max(dp)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        length = len(nums)\\n        if length==0:\\n            return 0\\n        if length==1:\\n            return nums[0]\\n        if length==2:\\n            return max(nums)\\n\\t\\t\\t\\n        dp = [0]*length # assign dp array\\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\\n        \\n        for i in range(2, length):\\n            dp[i] = max(dp[i-2]+nums[i], dp[i-1])\\n        print(dp)\\n        \\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846111,
                "title": "c-four-simple-approch",
                "content": "**Recoursive Solution**   \\n```\\nTime  Complexcity  :  O ( 2^N )   Give you TLE\\nSpace Complexcity : O( 1 )\\n``` \\n\\n```\\nclass Solution {\\npublic:\\n    int Fun(vector<int>& nums,int index){\\n        if(index>=nums.size())return 0;\\n        return max(nums[index]+Fun(nums,index+2),Fun(nums,index+1));\\n    }\\n    int rob(vector<int>& nums) {\\n        return Fun(nums,0);\\n    }\\n};\\n```\\n\\n**Recoursion with Memo**\\n```\\nTime  Complexcity  :  O ( N )\\nSpace Complexcity : O( N )\\n``` \\n\\n```\\nclass Solution {\\npublic:\\n    int DP(vector<int>& nums,int index,vector<int>&dp){\\n        if(index>=nums.size())return 0;\\n        if(dp[index]!=-1)return dp[index];\\n        return dp[index] = max(nums[index]+DP(nums,index+2,dp),DP(nums,index+1,dp));\\n    }\\n    int rob(vector<int>& nums) {\\n        vector<int>dp(nums.size()+1,-1);\\n        return DP(nums,0,dp);\\n    }\\n};\\n\\n```\\n\\n**Bottom Up Dp Or Tabulation**\\n```\\nTime  Complexcity  :  O ( N )\\nSpace Complexcity : O( N )\\n``` \\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        if (nums.size() == 1) return nums[0];\\n\\n        vector<int> dp[nums.size()];\\n        dp[0] = nums[0], dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\\n\\n**Most Efficent One**\\n```\\nTime  Complexcity  :  O ( N )\\nSpace Complexcity : O( 1 )\\n``` \\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int sum1 = 0,sum2 = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(!(i&1))sum1=max(sum1+nums[i],sum2);\\n            else sum2 = max(sum2+nums[i],sum1);\\n        }\\n        return max(sum1,sum2);\\n    }\\n};\\n```\\n\\n\\nIf you Like This Please **Upvote** it\\nAny doubt comments there\\nThank you  **:)**",
                "solutionTags": [],
                "code": "```\\nTime  Complexcity  :  O ( 2^N )   Give you TLE\\nSpace Complexcity : O( 1 )\\n```\n```\\nclass Solution {\\npublic:\\n    int Fun(vector<int>& nums,int index){\\n        if(index>=nums.size())return 0;\\n        return max(nums[index]+Fun(nums,index+2),Fun(nums,index+1));\\n    }\\n    int rob(vector<int>& nums) {\\n        return Fun(nums,0);\\n    }\\n};\\n```\n```\\nTime  Complexcity  :  O ( N )\\nSpace Complexcity : O( N )\\n```\n```\\nclass Solution {\\npublic:\\n    int DP(vector<int>& nums,int index,vector<int>&dp){\\n        if(index>=nums.size())return 0;\\n        if(dp[index]!=-1)return dp[index];\\n        return dp[index] = max(nums[index]+DP(nums,index+2,dp),DP(nums,index+1,dp));\\n    }\\n    int rob(vector<int>& nums) {\\n        vector<int>dp(nums.size()+1,-1);\\n        return DP(nums,0,dp);\\n    }\\n};\\n\\n```\n```\\nTime  Complexcity  :  O ( N )\\nSpace Complexcity : O( N )\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.empty()) return 0;\\n        if (nums.size() == 1) return nums[0];\\n\\n        vector<int> dp[nums.size()];\\n        dp[0] = nums[0], dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\n```\\nTime  Complexcity  :  O ( N )\\nSpace Complexcity : O( 1 )\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int sum1 = 0,sum2 = 0;\\n        for(int i=0;i<nums.size();i++){\\n            if(!(i&1))sum1=max(sum1+nums[i],sum2);\\n            else sum2 = max(sum2+nums[i],sum1);\\n        }\\n        return max(sum1,sum2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 263528,
                "title": "python-bottom-up-dp-from-o-n-to-o-1-space-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Bottom up DP**\\n- Let `dp[i]` is the maximum of amount money we can rob in `houses[0..i]`.\\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1: return nums[0]\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\\n        return dp[n-1]\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 100` is number of houses.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Bottom up DP (Space Optimzed)**\\n- Since our `dp` only access 3 do states: current dp `dp`, previous dp `dp1`, previous of previous dp `dp2`. So we can optimize to `O(1)` in Space Complexity.\\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        dp, dp1, dp2 = 0, 0, 0\\n        for i in range(len(nums)):\\n            dp = max(dp1, dp2 + nums[i])\\n            dp2 = dp1\\n            dp1 = dp\\n        return dp1\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 100` is number of houses.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1: return nums[0]\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\\n        return dp[n-1]\\n```\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        dp, dp1, dp2 = 0, 0, 0\\n        for i in range(len(nums)):\\n            dp = max(dp1, dp2 + nums[i])\\n            dp2 = dp1\\n            dp1 = dp\\n        return dp1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55679,
                "title": "o-1-space-java-and-c",
                "content": "Since we are not allowed to rob two adjacent houses, we keep two variables `pre` and `cur`. During the `i`-th loop, `pre` records the maximum profit that we do not rob the `i - 1`-th house and thus the current house (the `i`-th house) can be robbed while `cur` records the profit that we have robbed the `i - 1`-th house. \\n\\nThe code is as follows.\\n\\n* Java\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int pre = 0, cur = 0;\\n        for (int num : nums) {\\n            final int temp = Integer.max(pre + num, cur);\\n            pre = cur;\\n            cur = temp;\\n        }\\n        return cur;\\n    }\\n}\\n```\\n\\n* C++\\n```\\nclass Solution {\\npublic: \\n    int rob(vector<int>& nums) {\\n        int n = nums.size(), pre = 0, cur = 0;\\n        for (int i = 0; i < n; i++) {\\n            int temp = max(pre + nums[i], cur);\\n            pre = cur;\\n            cur = temp;\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int pre = 0, cur = 0;\\n        for (int num : nums) {\\n            final int temp = Integer.max(pre + num, cur);\\n            pre = cur;\\n            cur = temp;\\n        }\\n        return cur;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic: \\n    int rob(vector<int>& nums) {\\n        int n = nums.size(), pre = 0, cur = 0;\\n        for (int i = 0; i < n; i++) {\\n            int temp = max(pre + nums[i], cur);\\n            pre = cur;\\n            cur = temp;\\n        }\\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55953,
                "title": "3-lines-solution-in-javascript",
                "content": "    return nums.reduce(function(p, n) { \\n        return [p[1], Math.max(p[0] + n, p[1])]; \\n    }, [0,0])[1];\\n\\nvariable p records previous 2 max values: p[1] is the previous one and p[0] is the one before previous one. p is initialized as [0,0]. variable n is the value at each position.",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "    return nums.reduce(function(p, n) { \\n        return [p[1], Math.max(p[0] + n, p[1])]; \\n    }, [0,0])[1];\\n\\nvariable p records previous 2 max values: p[1] is the previous one and p[0] is the one before previous one. p is initialized as [0,0]. variable n is the value at each position.",
                "codeTag": "Unknown"
            },
            {
                "id": 650881,
                "title": "c-using-dp-easy-concise-and-clean-code",
                "content": "***Pls upvote if you find this helpful :)***\\n\\nBasic idea is to break the problem into subproblems by solving it for 1 house,2 houses and then so on. So we can observe logically that value with n houses is max(value with n-1 houses,value with n-2 houses+value of nth house).Therefore we create dp array and fill it with similar logic to find the value with n houses.\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==0)return 0;\\n        int n=nums.size();\\n        vector<int> dp(n+1,0);\\n        dp[1]=nums[0];\\n        for(int i=2;i<=n;i++){\\n            dp[i]=max(dp[i-1],dp[i-2]+nums[i-1]);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if(nums.size()==0)return 0;\\n        int n=nums.size();\\n        vector<int> dp(n+1,0);\\n        dp[1]=nums[0];\\n        for(int i=2;i<=n;i++){\\n            dp[i]=max(dp[i-1],dp[i-2]+nums[i-1]);\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55907,
                "title": "simplest-java-solution",
                "content": "    public class Solution {\\n    \\n        public int rob(int[] num) {\\n            int last = 0;\\n            int now = 0;\\n            int tmp;\\n            for (int n :num) {\\n                tmp = now;\\n                now = Math.max(last + n, now);\\n                last = tmp;\\n            }\\n            return now;        \\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n        public int rob(int[] num) {\\n            int last = 0;\\n            int now = 0;\\n            int tmp;\\n            for (int n :num) {\\n                tmp = now;\\n                now = Math.max(last + n, now);\\n                last = tmp;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 299056,
                "title": "python-o-n-time-o-1-space-4-lines",
                "content": "The idea is from *ldthu* whose original answer was written in Java. https://leetcode.com/problems/house-robber/discuss/55838/DP-O(N)-time-O(1)-space-with-easy-to-understand-explanation\\n\\n\\nAt each house there are two options: either to rob it or not to rob it. \\n\\n**Option 1**: If rob, then **rob = not_rob + nums[i]**\\n(max money if rob the current house = max money if not rob                    the last house + amount of the current house)\\n**Option 2**: If not rob, then **not_rob = max(rob, not_rob)**\\n                (max money if not rob the current house = max money at the                    last house, either rob or not rob)\\n\\n**Varibles:** rob = max money if rob the current house\\n\\t\\t  not_rob = max money if not rob the current house. \\n\\t\\t  Both variables are initially set to 0\\n\\n**Complexity:**\\ntime = O(n)\\nSpace = O(1)\\n\\nHere is the code:\\n```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        rob, not_rob = 0, 0\\n        for num in nums:\\n            rob, not_rob = not_rob + num, max(rob, not_rob)\\n        return max(rob, not_rob)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        rob, not_rob = 0, 0\\n        for num in nums:\\n            rob, not_rob = not_rob + num, max(rob, not_rob)\\n        return max(rob, not_rob)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282624,
                "title": "easy-to-read-javascript-o-n-time-o-1-space-iterative",
                "content": "```\\nvar rob = function(nums) {\\n    /*\\n    Runtime: 56 ms, faster than 100.00% of JavaScript online submissions for House Robber.\\n    Memory Usage: 33.8 MB, less than 25.89% of JavaScript online submissions for House Robber.\\n    \\n    O(n) time, O(1) space\\n\\t\\n\\t- Bottom up strategy\\n\\t- Iterative\\n\\t- Memoization\\n\\t\\n\\tTrick: At index [i], you only need to know the maximum profit at [i - 1] and [i - 2]. This is a slight variation on fibonacci.\\n    */\\n    \\n    if (!nums.length) return 0;\\n    if (nums.length === 1) return nums[0];\\n    if (nums.length === 2) return Math.max(nums[0], nums[1]);\\n    \\n    let maxAtTwoBefore = nums[0];\\n    let maxAtOneBefore = Math.max(nums[0], nums[1]);\\n    \\n    for (let i = 2; i < nums.length; i++) {\\n        const maxAtCurrent = Math.max(nums[i] + maxAtTwoBefore, maxAtOneBefore);\\n        \\n        maxAtTwoBefore = maxAtOneBefore;\\n        maxAtOneBefore = maxAtCurrent;\\n    }\\n    \\n    return maxAtOneBefore;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization",
                    "Iterator"
                ],
                "code": "```\\nvar rob = function(nums) {\\n    /*\\n    Runtime: 56 ms, faster than 100.00% of JavaScript online submissions for House Robber.\\n    Memory Usage: 33.8 MB, less than 25.89% of JavaScript online submissions for House Robber.\\n    \\n    O(n) time, O(1) space\\n\\t\\n\\t- Bottom up strategy\\n\\t- Iterative\\n\\t- Memoization\\n\\t\\n\\tTrick: At index [i], you only need to know the maximum profit at [i - 1] and [i - 2]. This is a slight variation on fibonacci.\\n    */\\n    \\n    if (!nums.length) return 0;\\n    if (nums.length === 1) return nums[0];\\n    if (nums.length === 2) return Math.max(nums[0], nums[1]);\\n    \\n    let maxAtTwoBefore = nums[0];\\n    let maxAtOneBefore = Math.max(nums[0], nums[1]);\\n    \\n    for (let i = 2; i < nums.length; i++) {\\n        const maxAtCurrent = Math.max(nums[i] + maxAtTwoBefore, maxAtOneBefore);\\n        \\n        maxAtTwoBefore = maxAtOneBefore;\\n        maxAtOneBefore = maxAtCurrent;\\n    }\\n    \\n    return maxAtOneBefore;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805852,
                "title": "c-apni-bhasha-mein-easy-explanation-dp-1d-interview-prep",
                "content": "# Approach & Intuition\\n- Explained in the code.\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n        LOGIC\\n\\n        KARNA KYA HAIN\\u2753\\n        1. Main chor hu mujhe chori karni hain.\\n        2. Mujhe jyada se jyada lootna hain bina police ko pata lage.\\n        3. Dikkat hain ki main 2 adjacent house se chori nahin kar sakta kyoki\\n        udhar security system laga hain.\\n        4. Mujhe houseAmount array is given now I want to loot as much as I can \\n        without informing the police.\\n\\n        APPROACH & INTUITION\\n        1. Ab chor ke paas 2 choice hain:-\\n        - Kisi ghar ki chori kare to agle ghar ko chodke aage ke gharo mein\\n        chori kare.\\n        - Ya to current ghar chod de aur aage ke gharo se chori kare.\\n        2. So its a type of \\uD83D\\uDCA1Pick/Non-Pick\\uD83D\\uDCA1variant.\\n        3. So Pick/non-pick mein we will use RECURSION\\n        4. What do we do in RECURSION\\u2753\\n        - Visualize it in the form of indexes.\\n        - Do all stuff on these indexes according to statement.\\n        - Count means SUM , minimize means min , maximize means max\\n        5. What is the relation here\\u2753\\n        pick = f(i-2)+currentHomeAmount \\n        =>current ghar liya to pichle ghar ko\\n        chod diya .\\n        notPick = f(i-1)+0 \\n        => current ghar ko chodke pichla ghar liya\\n        BASE CASE:- \\n        ind <0 hua to matlab hamne chori nahin ki abhi tak -return 0\\n        ind 0 hua to matlab hamne pehle ghar ki chori kari abhi tak-return nums[0]\\n        6.Ab inme se max nikalna hain.\\n        7. Now there will overlapping-subproblems\\n        8. RECUSRSION -> MEMOIZATION -> TABULATION -> SpaceOPTIMIZATION\\n        9. RECUSRION to Memoization\\n        - Check the changing parameter(house no)\\n        - Declare dp array of size n\\n        - Store the max result as dp[i]\\n        - Check if dp[ind] is not looted before.\\n        10. Memoization to Tabulation\\n        - Declare the dp array size.\\n        - Declare the base cases.\\n        - Iterate till last house\\n        - Replace f(ind) with dp[ind]\\n        11. Tabulation to Space Optimization\\n        - Try to find do we need a dp array?\\n        - Try to find if there is any pattern found amond dp[i],dp[i-1],..\\n        - Gneralize this in terms of variables\\n\\n//==============================================================================================\\n        \\n       \\t//Recursive Solution\\n           int Recursion(int i, vector<int> &nums)\\n       \\t    {\\n       \\t        if (i == 0)\\n       \\t            return nums[i];\\n       \\t        if (i < 0)\\n       \\t            return 0;\\n       \\t        int pick = nums[i] + Recursion(i - 2, nums);\\n       \\t        int nonPick = 0 + Recursion(i - 1, nums);\\n       \\t        return max(pick, nonPick);\\n       \\t    }\\n       \\tint rob(vector<int> &nums)\\n       \\t{\\n       \\t    int n = nums.size() - 1;\\n       \\t    return Recursion(n, nums);\\n       \\t}\\n\\n       \\t//Memoization\\n \\t        int Memoization(int i, vector<int> &nums, vector<int> &dp)\\n       \\t        {\\n       \\t            if (i == 0)\\n       \\t                return nums[0];\\n       \\t            if (i < 0)\\n       \\t                return 0;\\n       \\t            if (dp[i] != -1)\\n       \\t                return dp[i];\\n       \\t            int pick = nums[i] + Memoization(i - 2, nums, dp);\\n       \\t            int nonPick = 0 + Memoization(i - 1, nums, dp);\\n       \\t            return dp[i] = max(pick, nonPick);\\n       \\t        }\\n       \\t    int rob(vector<int> &nums)\\n       \\t    {\\n       \\t        int n = nums.size();\\n       \\t        vector<int> dp(n, -1);\\n       \\t        return Memoization(n-1, nums, dp);\\n       \\t    }\\n\\n       \\t//Tabulation(Unoptimized)\\n int rob(vector<int> &nums)\\n        {\\n            int n = nums.size();\\n            vector<int> dp(n, -1);\\n            dp[0] = nums[0];\\n            for (int i = 1; i < n; i++)\\n            {\\n                int pick = nums[i];\\n                if (i > 1)\\n                    pick = pick + dp[i - 2];\\n                int notPick = 0 + dp[i - 1];\\n                dp[i] = max(pick, notPick);\\n            }\\n            return dp[n - 1];\\n        }\\n\\n   \\t//Tabulation(Optimized)\\n    int rob(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int prev1 = nums[0];\\n        int prev = 0;\\n        int curri = 0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            int pick = nums[i];\\n            if (i > 1)\\n                pick = pick + prev;\\n            int notPick = 0 + prev1;\\n            curri = max(pick, notPick);\\n            prev = prev1;\\n            prev1 = curri;\\n        }\\n        return prev1;\\n    }\\n};\\n```\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        LOGIC\\n\\n        KARNA KYA HAIN\\u2753\\n        1. Main chor hu mujhe chori karni hain.\\n        2. Mujhe jyada se jyada lootna hain bina police ko pata lage.\\n        3. Dikkat hain ki main 2 adjacent house se chori nahin kar sakta kyoki\\n        udhar security system laga hain.\\n        4. Mujhe houseAmount array is given now I want to loot as much as I can \\n        without informing the police.\\n\\n        APPROACH & INTUITION\\n        1. Ab chor ke paas 2 choice hain:-\\n        - Kisi ghar ki chori kare to agle ghar ko chodke aage ke gharo mein\\n        chori kare.\\n        - Ya to current ghar chod de aur aage ke gharo se chori kare.\\n        2. So its a type of \\uD83D\\uDCA1Pick/Non-Pick\\uD83D\\uDCA1variant.\\n        3. So Pick/non-pick mein we will use RECURSION\\n        4. What do we do in RECURSION\\u2753\\n        - Visualize it in the form of indexes.\\n        - Do all stuff on these indexes according to statement.\\n        - Count means SUM , minimize means min , maximize means max\\n        5. What is the relation here\\u2753\\n        pick = f(i-2)+currentHomeAmount \\n        =>current ghar liya to pichle ghar ko\\n        chod diya .\\n        notPick = f(i-1)+0 \\n        => current ghar ko chodke pichla ghar liya\\n        BASE CASE:- \\n        ind <0 hua to matlab hamne chori nahin ki abhi tak -return 0\\n        ind 0 hua to matlab hamne pehle ghar ki chori kari abhi tak-return nums[0]\\n        6.Ab inme se max nikalna hain.\\n        7. Now there will overlapping-subproblems\\n        8. RECUSRSION -> MEMOIZATION -> TABULATION -> SpaceOPTIMIZATION\\n        9. RECUSRION to Memoization\\n        - Check the changing parameter(house no)\\n        - Declare dp array of size n\\n        - Store the max result as dp[i]\\n        - Check if dp[ind] is not looted before.\\n        10. Memoization to Tabulation\\n        - Declare the dp array size.\\n        - Declare the base cases.\\n        - Iterate till last house\\n        - Replace f(ind) with dp[ind]\\n        11. Tabulation to Space Optimization\\n        - Try to find do we need a dp array?\\n        - Try to find if there is any pattern found amond dp[i],dp[i-1],..\\n        - Gneralize this in terms of variables\\n\\n//==============================================================================================\\n        \\n       \\t//Recursive Solution\\n           int Recursion(int i, vector<int> &nums)\\n       \\t    {\\n       \\t        if (i == 0)\\n       \\t            return nums[i];\\n       \\t        if (i < 0)\\n       \\t            return 0;\\n       \\t        int pick = nums[i] + Recursion(i - 2, nums);\\n       \\t        int nonPick = 0 + Recursion(i - 1, nums);\\n       \\t        return max(pick, nonPick);\\n       \\t    }\\n       \\tint rob(vector<int> &nums)\\n       \\t{\\n       \\t    int n = nums.size() - 1;\\n       \\t    return Recursion(n, nums);\\n       \\t}\\n\\n       \\t//Memoization\\n \\t        int Memoization(int i, vector<int> &nums, vector<int> &dp)\\n       \\t        {\\n       \\t            if (i == 0)\\n       \\t                return nums[0];\\n       \\t            if (i < 0)\\n       \\t                return 0;\\n       \\t            if (dp[i] != -1)\\n       \\t                return dp[i];\\n       \\t            int pick = nums[i] + Memoization(i - 2, nums, dp);\\n       \\t            int nonPick = 0 + Memoization(i - 1, nums, dp);\\n       \\t            return dp[i] = max(pick, nonPick);\\n       \\t        }\\n       \\t    int rob(vector<int> &nums)\\n       \\t    {\\n       \\t        int n = nums.size();\\n       \\t        vector<int> dp(n, -1);\\n       \\t        return Memoization(n-1, nums, dp);\\n       \\t    }\\n\\n       \\t//Tabulation(Unoptimized)\\n int rob(vector<int> &nums)\\n        {\\n            int n = nums.size();\\n            vector<int> dp(n, -1);\\n            dp[0] = nums[0];\\n            for (int i = 1; i < n; i++)\\n            {\\n                int pick = nums[i];\\n                if (i > 1)\\n                    pick = pick + dp[i - 2];\\n                int notPick = 0 + dp[i - 1];\\n                dp[i] = max(pick, notPick);\\n            }\\n            return dp[n - 1];\\n        }\\n\\n   \\t//Tabulation(Optimized)\\n    int rob(vector<int> &nums)\\n    {\\n        int n = nums.size();\\n        int prev1 = nums[0];\\n        int prev = 0;\\n        int curri = 0;\\n        for (int i = 1; i < n; i++)\\n        {\\n            int pick = nums[i];\\n            if (i > 1)\\n                pick = pick + prev;\\n            int notPick = 0 + prev1;\\n            curri = max(pick, notPick);\\n            prev = prev1;\\n            prev1 = curri;\\n        }\\n        return prev1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846002,
                "title": "python-dynamic-programming-easy-solution-faster-than-95",
                "content": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        # edge cases:\\n        if len(nums) == 0: return 0\\n        if len(nums) == 1: return nums[0]\\n        if len(nums) == 2: return max(nums)\\n        \\n        # dynamic programming - decide each problem by its sub-problems:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2])\\n        \\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        # edge cases:\\n        if len(nums) == 0: return 0\\n        if len(nums) == 1: return nums[0]\\n        if len(nums) == 2: return max(nums)\\n        \\n        # dynamic programming - decide each problem by its sub-problems:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2])\\n        \\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491888,
                "title": "javascript-from-noob-to-pro",
                "content": "The best way to start DP related problem is to think about the problem first and build a recursive strategy. This is because recursion is easier and you can apply memoization rather quickly compared to tabulation. And you will get a solution anyway after which you can optimize the solution. In any interview, getting a solution is the key.\\n\\nLet\\'s take the sample here:\\n\\n```\\n[ 2, 7, 9, 3, 1 ]\\n```\\n\\nLet\\'s say we start at house with amount 2. Then we can do two things:\\n\\n- Skip the house and move on\\n- Rob the house and skip next house\\n\\nWe can make this generic by saying at any starting house. And we want to start at the very first house (only start the logic, to rob or not is a different thing) since we want to maximize the robbery. So Let\\'s turn this into the most naive recursive solution.\\n\\n```javascript\\n// O(2^n) time | O(2^n) space\\nvar rob = function(nums, idx = 0) {\\n    if (idx >= nums.length) {\\n        return 0;\\n    }\\n    \\n    const sumIfSkipped = rob(nums, idx + 1);\\n    const sumIfRobbed = nums[idx] + rob(nums, idx + 2);\\n    \\n    return Math.max(sumIfSkipped, sumIfRobbed);\\n};\\n```\\n\\nYou know what happened when I submit this solution? You guessed it right, it timed out. The reason is, we are doing the same work multiple times, at each index. To speed it up, let\\'s add memoization to it.\\n\\n```javascript\\n// O(n) time | O(n) space\\nvar rob = function(nums, idx = 0, memo = {}) {\\n    if (idx in memo) {\\n        return memo[idx];\\n    }\\n    \\n    if (idx >= nums.length) {\\n        return 0;\\n    }\\n    \\n    const sumIfSkipped = rob(nums, idx + 1, memo);\\n    const sumIfRobbed = nums[idx] + rob(nums, idx + 2, memo);\\n    \\n    return memo[idx] = Math.max(sumIfSkipped, sumIfRobbed);\\n};\\n```\\n\\nThis is better, from exponential (2 to the power of n) to 2 times n in complexity. The results of my run are as follows:\\n\\n![image](https://assets.leetcode.com/users/images/c469eb53-70b2-49ec-8122-3b47e9f85bb1_1632851070.6599624.png)\\n\\nIt was fast, but I think we can certainly do better. And that is by using iteration instead of recursion. We start by observing the existing code, and we make two observations:\\n\\n- If we decide to skip the house at index i, then we are computing max robbery possible starting from house at index i+1.\\n- If we decide to rob the house at index i, then we are computing max robbery possible starting from house at index i+2.\\n\\nSo at every house, we are doing two lookups. To make this easier, let\\'s construct a DP table and iterate the given array from right to left. This is why tabulation is also called as bottom-up approach.\\n\\n```javascript\\n// O(n) time | O(n) space\\nvar rob = function(nums) {\\n    const table = new Array(nums.length + 2);\\n    \\n    table[nums.length + 0] = 0;\\n    table[nums.length + 1] = 0;\\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        const sumIfSkipped = table[i + 1];\\n        const sumIfRobbed = nums[i] + table[i + 2];\\n        \\n        table[i] = Math.max(sumIfSkipped, sumIfRobbed);\\n    }\\n    \\n    return table[0];\\n}\\n```\\n\\nThe complexity is the same as the previous solution with memoization, but this is even faster, since we are skipping the stack frames and recursive function calls. The results of my run are as follows:\\n\\n![image](https://assets.leetcode.com/users/images/f0849698-cb8a-4204-8e69-dbe196864630_1632851628.583106.png)\\n\\nWe aren\\'t done yet! If you notice, we are only making two lookups, and we can reduce the space complexity if we get rid of the table and use two variables for that. This way, we will get the solution to O(1) space, which will super impress your interviewer.\\n\\n```javascript\\n// O(n) time | O(1) space\\nvar rob = function(nums) {\\n    let robbedIdxPlus1 = 0;\\n    let robbedIdxPlus2 = 0;\\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        const sumIfSkipped = robbedIdxPlus1;\\n        const sumIfRobbed = nums[i] + robbedIdxPlus2;\\n        \\n        const maxRobbedAtIdx = Math.max(sumIfSkipped, sumIfRobbed);\\n        \\n        robbedIdxPlus2 = robbedIdxPlus1;\\n        robbedIdxPlus1 = maxRobbedAtIdx;\\n    }\\n    \\n    return robbedIdxPlus1;\\n}\\n```\\n\\nAnd the results? Here is an even faster submission:\\n\\n![image](https://assets.leetcode.com/users/images/32293b77-c7ce-47c3-862b-fe738c069134_1632851778.8733077.png)\\n\\nAre we done? I think so. If you find an even better way, be sure to let me know in the comments!",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n[ 2, 7, 9, 3, 1 ]\\n```\n```javascript\\n// O(2^n) time | O(2^n) space\\nvar rob = function(nums, idx = 0) {\\n    if (idx >= nums.length) {\\n        return 0;\\n    }\\n    \\n    const sumIfSkipped = rob(nums, idx + 1);\\n    const sumIfRobbed = nums[idx] + rob(nums, idx + 2);\\n    \\n    return Math.max(sumIfSkipped, sumIfRobbed);\\n};\\n```\n```javascript\\n// O(n) time | O(n) space\\nvar rob = function(nums, idx = 0, memo = {}) {\\n    if (idx in memo) {\\n        return memo[idx];\\n    }\\n    \\n    if (idx >= nums.length) {\\n        return 0;\\n    }\\n    \\n    const sumIfSkipped = rob(nums, idx + 1, memo);\\n    const sumIfRobbed = nums[idx] + rob(nums, idx + 2, memo);\\n    \\n    return memo[idx] = Math.max(sumIfSkipped, sumIfRobbed);\\n};\\n```\n```javascript\\n// O(n) time | O(n) space\\nvar rob = function(nums) {\\n    const table = new Array(nums.length + 2);\\n    \\n    table[nums.length + 0] = 0;\\n    table[nums.length + 1] = 0;\\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        const sumIfSkipped = table[i + 1];\\n        const sumIfRobbed = nums[i] + table[i + 2];\\n        \\n        table[i] = Math.max(sumIfSkipped, sumIfRobbed);\\n    }\\n    \\n    return table[0];\\n}\\n```\n```javascript\\n// O(n) time | O(1) space\\nvar rob = function(nums) {\\n    let robbedIdxPlus1 = 0;\\n    let robbedIdxPlus2 = 0;\\n    \\n    for (let i = nums.length - 1; i >= 0; i--) {\\n        const sumIfSkipped = robbedIdxPlus1;\\n        const sumIfRobbed = nums[i] + robbedIdxPlus2;\\n        \\n        const maxRobbedAtIdx = Math.max(sumIfSkipped, sumIfRobbed);\\n        \\n        robbedIdxPlus2 = robbedIdxPlus1;\\n        robbedIdxPlus1 = maxRobbedAtIdx;\\n    }\\n    \\n    return robbedIdxPlus1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 378700,
                "title": "python-multiple-solutions",
                "content": "Since we can\\'t rob two adjacent houses we need to check what is the maximum gain starting at the first and second house. From there we check what is the maximum gain we can make by robing houses at distance `2` and `3` from our current position. \\n\\nAnother way to look at it is we can take all the gains we made to arrive at two houses `i - 2` before the current house and whatever is there in the current house or we can take all the gains we made up to the previous house.\\n\\nThis is a dynamic programming problem. If we go with the above without caching previous computations we will end up with an `O(n^2)` algorithm. We have multiple strategies to cache intermediate results (see below).\\n# Recursive\\nWe create a chache in the object initializer. Our entry point function just call the recursive function for the first and second house. We check whether we are past the end of the array or if we already computed the max gain for positions that are distance `2` or `3` from our current position.\\n\\n## Top down\\n\\nLook Before You Leap (LBYL) --> We check whether the position is already in the cache using `if` and return that otherwise we compute it\\n\\nTop down --> We start at the first house, end at last house\\n\\n```python\\nclass Solution:\\n    def __init__(self):\\n        self.cache = {}\\n        \\n    def rob_rec(self, nums, start):\\n        if start >= len(nums):\\n            return 0\\n        \\n        if start in self.cache:\\n            return self.cache[start]\\n        \\n        self.cache[start] = nums[start] + max(self.rob_rec(nums, start+2), self.rob_rec(nums, start+3))\\n        return self.cache[start]\\n        \\n    def rob(self, nums: List[int]) -> int:\\n        return max(self.rob_rec(nums, 0), self.rob_rec(nums, 1))\\n```\\n\\n## Botom up\\n\\nEasier to Ask Forgiveness than Permission (EAFP) --> We use a `try...except` and suppose the value is already there and if not compute it\\n\\nBottom up --> We start at the last house and go back to the first\\n\\n```python\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.cache = {}\\n    \\n    def rob_rec(self, nums, current):\\n        if current < 0: # Beyond array boundary\\n            return 0\\n        \\n        try:\\n            return self.cache[current]\\n        except:\\n        \\n            self.cache[current] = max(self.rob_rec(nums, current - 1),\\n                                      nums[current] + self.rob_rec(nums, current - 2))\\n        return self.cache[current]\\n    \\n    def rob(self, nums: List[int]) -> int:\\n        return self.rob_rec(nums, len(nums) - 1)\\n```\\n\\nTime `O(n)` / Space `O(n)`\\n\\n# Reversing the list\\nHere the idea is that there is only one way to rob the last two houses, i.e. take what is there. So we already have our max gain for those two positions. We can work our way backward from there until we rach the first and second house and return the maximum gain between those two.\\n\\n```python\\nfrom itertools import islice\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        nums.append(0)\\n        nums.reverse()\\n        for idx, num in enumerate(islice(nums, 3, None), 3):\\n            nums[idx] = max(num + nums[idx - 2], num + nums[idx - 3])\\n            \\n        return max(nums[-1], nums[-2])\\n```\\n\\nTime `O(n)` / Space `O(1)`\\n\\n# Rolling window\\nHere the idea is we need only to remeber what is the maximum gain at the next 3 houses from current position. We start at the end of the array and walk our way back to the first and second house.\\n\\n## Botom up\\n\\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:        \\n        house_1 = 0\\n        house_2 = 0\\n        house_3 = 0\\n        for num in reversed(nums):\\n            temp = house_1\\n            house_1 = max(num + house_2, num + house_3)\\n            house_3 = house_2\\n            house_2 = temp\\n            \\n        return max(house_1, house_2)\\n```\\n\\n## Top down\\n\\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        prev1, prev2 = 0, 0\\n        for num in nums:\\n            prev1, prev2 = max(prev2 + num, prev1), prev1\\n            \\n        return prev1\\n```\\n\\nTime `O(n)` / Space `O(1)`",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def __init__(self):\\n        self.cache = {}\\n        \\n    def rob_rec(self, nums, start):\\n        if start >= len(nums):\\n            return 0\\n        \\n        if start in self.cache:\\n            return self.cache[start]\\n        \\n        self.cache[start] = nums[start] + max(self.rob_rec(nums, start+2), self.rob_rec(nums, start+3))\\n        return self.cache[start]\\n        \\n    def rob(self, nums: List[int]) -> int:\\n        return max(self.rob_rec(nums, 0), self.rob_rec(nums, 1))\\n```\n```python\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.cache = {}\\n    \\n    def rob_rec(self, nums, current):\\n        if current < 0: # Beyond array boundary\\n            return 0\\n        \\n        try:\\n            return self.cache[current]\\n        except:\\n        \\n            self.cache[current] = max(self.rob_rec(nums, current - 1),\\n                                      nums[current] + self.rob_rec(nums, current - 2))\\n        return self.cache[current]\\n    \\n    def rob(self, nums: List[int]) -> int:\\n        return self.rob_rec(nums, len(nums) - 1)\\n```\n```python\\nfrom itertools import islice\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        nums.append(0)\\n        nums.reverse()\\n        for idx, num in enumerate(islice(nums, 3, None), 3):\\n            nums[idx] = max(num + nums[idx - 2], num + nums[idx - 3])\\n            \\n        return max(nums[-1], nums[-2])\\n```\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:        \\n        house_1 = 0\\n        house_2 = 0\\n        house_3 = 0\\n        for num in reversed(nums):\\n            temp = house_1\\n            house_1 = max(num + house_2, num + house_3)\\n            house_3 = house_2\\n            house_2 = temp\\n            \\n        return max(house_1, house_2)\\n```\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        prev1, prev2 = 0, 0\\n        for num in nums:\\n            prev1, prev2 = max(prev2 + num, prev1), prev1\\n            \\n        return prev1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55737,
                "title": "well-commented-java-o-n-time-constant-space",
                "content": "    public class Solution {\\n        public int rob(int[] nums) {\\n            // If we get invalid input, return 0\\n            if (nums == null || nums.length == 0) return 0;\\n            \\n            // Keep track of whether or not we robbed the previous house\\n            int robbedPrevious = 0;\\n            int didNotRobPrevious = 0;\\n            \\n            for (int i = 0; i < nums.length; i++) {\\n                \\n                // If we don't rob the current house, take the max of robbing and not robbing the previous house\\n                int currentNotRobbed = Math.max(robbedPrevious, didNotRobPrevious);\\n                \\n                // If we rob the current house, add the current money robbed to what we got from not robbing previous\\n                int currentIsRobbed = didNotRobPrevious + nums[i];\\n                \\n                // Update our values for the next iteration\\n                didNotRobPrevious = currentNotRobbed;\\n                robbedPrevious = currentIsRobbed;\\n            }\\n            \\n            // Return the maximum we could have robbed provided we looked at both options\\n            return Math.max(robbedPrevious, didNotRobPrevious);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n        public int rob(int[] nums) {\\n            // If we get invalid input, return 0\\n            if (nums == null || nums.length == 0) return 0;\\n            \\n            // Keep track of whether or not we robbed the previous house\\n            int robbedPrevious = 0;\\n            int didNotRobPrevious = 0;\\n            \\n            for (int i = 0; i < nums.length; i++) {\\n                \\n                // If we don't rob the current house, take the max of robbing and not robbing the previous house\\n                int currentNotRobbed = Math.max(robbedPrevious, didNotRobPrevious);\\n                \\n                // If we rob the current house, add the current money robbed to what we got from not robbing previous\\n                int currentIsRobbed = didNotRobPrevious + nums[i];\\n                \\n                // Update our values for the next iteration\\n                didNotRobPrevious = currentNotRobbed;\\n                robbedPrevious = currentIsRobbed;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 710200,
                "title": "all-3-approaches-recursion-memoization-dp",
                "content": "DP made easy - for DP problems please dont write top-down directly\\n1. Write recursive solution\\n2. Convert that into Top-Down or Bottom-Up(Memoization)\\n\\n```\\n// Recursion Time - O(n^2) Space - O(n)\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        return getMaxAmount(nums, nums.length - 1);\\n    }\\n    \\n    \\n    public int getMaxAmount(int[] nums, int n) {\\n       if(n < 0) return 0; \\n       if(n == 0) return nums[0];\\n       if(n == 1) return Integer.max(nums[1], nums[0]);\\n       return Integer.max(nums[n] + getMaxAmount(nums, n-2), getMaxAmount(nums, n-1));\\n    }\\n}\\n\\n\\n// DP - Memoization Time - O(n^2) Space - O(n)\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        int dp[] = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return getMaxAmount(nums, nums.length - 1, dp);\\n    }\\n    \\n    \\n    public int getMaxAmount(int[] nums, int n, int[] dp) {\\n       if(n < 0) return 0; \\n       if(n == 0) return nums[0];\\n       if(n == 1) return Integer.max(nums[1], nums[0]);\\n       if(dp[n] != -1) return dp[n]; \\n       dp[n] = Integer.max(nums[n] + getMaxAmount(nums, n-2, dp), getMaxAmount(nums, n-1, dp));\\n       return dp[n]; \\n    }\\n}\\n\\n// DP - Top Down Time - O(n) Space - O(n)\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        return getMaxAmount(nums);\\n    }\\n    \\n    \\n    public int getMaxAmount(int[] nums) {\\n       int dp[] = new int[nums.length];\\n       dp[0] = nums[0];\\n       dp[1] = Integer.max(nums[1], nums[0]); \\n       for(int i = 2; i < nums.length; i++) {\\n           if(dp[i] > 0) return dp[i]; \\n            dp[i] = Integer.max(nums[i] + dp[i-2], dp[i-1]);\\n       }\\n       return dp[nums.length-1]; \\n    }\\n}\\n\\n// Optimised DP \\n// Time O(n)\\n// Space O(1)\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        return getMaxAmount(nums);\\n    }\\n    \\n     public int getMaxAmount(int[] nums) { \\n        nums[1] = Math.max(nums[1], nums[0]);\\n        for(int i = 2; i < nums.length; i++) {\\n            nums[i] = Math.max(nums[i] + nums[i-2], nums[i-1]);\\n           System.out.println(nums[i]); \\n        }  \\n         return nums[nums.length-1]; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n// Recursion Time - O(n^2) Space - O(n)\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        return getMaxAmount(nums, nums.length - 1);\\n    }\\n    \\n    \\n    public int getMaxAmount(int[] nums, int n) {\\n       if(n < 0) return 0; \\n       if(n == 0) return nums[0];\\n       if(n == 1) return Integer.max(nums[1], nums[0]);\\n       return Integer.max(nums[n] + getMaxAmount(nums, n-2), getMaxAmount(nums, n-1));\\n    }\\n}\\n\\n\\n// DP - Memoization Time - O(n^2) Space - O(n)\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        int dp[] = new int[nums.length];\\n        Arrays.fill(dp, -1);\\n        return getMaxAmount(nums, nums.length - 1, dp);\\n    }\\n    \\n    \\n    public int getMaxAmount(int[] nums, int n, int[] dp) {\\n       if(n < 0) return 0; \\n       if(n == 0) return nums[0];\\n       if(n == 1) return Integer.max(nums[1], nums[0]);\\n       if(dp[n] != -1) return dp[n]; \\n       dp[n] = Integer.max(nums[n] + getMaxAmount(nums, n-2, dp), getMaxAmount(nums, n-1, dp));\\n       return dp[n]; \\n    }\\n}\\n\\n// DP - Top Down Time - O(n) Space - O(n)\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        return getMaxAmount(nums);\\n    }\\n    \\n    \\n    public int getMaxAmount(int[] nums) {\\n       int dp[] = new int[nums.length];\\n       dp[0] = nums[0];\\n       dp[1] = Integer.max(nums[1], nums[0]); \\n       for(int i = 2; i < nums.length; i++) {\\n           if(dp[i] > 0) return dp[i]; \\n            dp[i] = Integer.max(nums[i] + dp[i-2], dp[i-1]);\\n       }\\n       return dp[nums.length-1]; \\n    }\\n}\\n\\n// Optimised DP \\n// Time O(n)\\n// Space O(1)\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        return getMaxAmount(nums);\\n    }\\n    \\n     public int getMaxAmount(int[] nums) { \\n        nums[1] = Math.max(nums[1], nums[0]);\\n        for(int i = 2; i < nums.length; i++) {\\n            nums[i] = Math.max(nums[i] + nums[i-2], nums[i-1]);\\n           System.out.println(nums[i]); \\n        }  \\n         return nums[nums.length-1]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871646,
                "title": "first-missing-positive-c-two-solutions-o-n-time-100",
                "content": "<b>The problem</b>\\nHonestly, it was surpising to me to find out that this problem is marked as hard.\\nWhen I saw the problem, I thought it was probably easy or medium difficulty.\\nI had done some similar problems previously, that required me to use the original array and negate numbers at indices according to some other values.\\nI guess it can appear hard to solve it in linear time, if you miss the clue.\\n\\n<b>Approach</b>\\nThe main thing here is to really understand the question. They are looking for the first positive integer, of <b>ALL</b> positive integers, that does not exist in the given array.\\nThis implies that the first missing number can be in range from ```1``` to ```N``` (size of the input).\\nNow we only have to figure out which one is the first in the sequence that is not present in the array.\\n\\n<b>Solution 1</b>\\nCreate a new array of input size, with all values set to ```-1```.\\nFor each value in the original array, set ```newArray[value - 1]``` to ```1```, if the value is within the ```1``` - ```N``` range.\\nNow we go through the new array and look for the first ```-1``` value. The missing number is ```index + 1```, since we are looking only for positive numbers and we start count from 1, while index is zero based.\\n```\\nclass Solution { // Time and Space: O(N)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tvector<int> sequence(size, -1); // Init array with same size to all -1s\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tif (nums[i] > 0 && nums[i] <= size)\\n\\t\\t\\t\\tsequence[nums[i] - 1] = 1; // Set numbers at indices to positive\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // First that has value -1 is the missing one\\n\\t\\t\\tif (sequence[i] == -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```\\n\\n<b>Solution 2</b>\\nVery similar to first solution, but we use the original array instead of creating a new one. So the space complexity is constant.\\nSince we don\\'t need to look at the negative values in the array, we set them to ```0```. Then we use the original array to negate all the numbers at indices for which the value exists in the array.\\nIt is a little tricky, and my solution might require some polishing, but overall, it isn\\'t difficult.\\n```\\nclass Solution { // Time: O(N), Space: O(1)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tbool hasOne = false;\\n\\n\\t\\tfor (int& n : nums) { // Set all negatives to 0\\n\\t\\t\\tif (n < 0)\\n\\t\\t\\t\\tn = 0;\\n\\t\\t\\telse if (n == 1)\\n\\t\\t\\t\\thasOne = true;\\n\\t\\t}\\n\\n\\t\\tif (!hasOne) // One is the first missing\\n\\t\\t\\treturn 1;\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // Negate all numbers at indices by found values\\n            int currNum = abs(nums[i]);\\n\\t\\t\\tif (currNum > 0 && currNum <= size)\\n\\t\\t\\t\\tif (nums[currNum - 1] == 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] = -1;\\n\\t\\t\\t\\telse if (nums[currNum - 1] > 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] *= -1; // Negate it\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) // Find first non negative number\\n\\t\\t\\tif (nums[i] > -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```\\n\\nAny suggestions or advice on how to improve the solutions are always welcome. Thank you!\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```1```\n```N```\n```-1```\n```newArray[value - 1]```\n```1```\n```1```\n```N```\n```-1```\n```index + 1```\n```\\nclass Solution { // Time and Space: O(N)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tvector<int> sequence(size, -1); // Init array with same size to all -1s\\n\\t\\tfor (int i = 0; i < size; i++) {\\n\\t\\t\\tif (nums[i] > 0 && nums[i] <= size)\\n\\t\\t\\t\\tsequence[nums[i] - 1] = 1; // Set numbers at indices to positive\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // First that has value -1 is the missing one\\n\\t\\t\\tif (sequence[i] == -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\t\\t}\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```\n```0```\n```\\nclass Solution { // Time: O(N), Space: O(1)\\npublic:\\n\\tint firstMissingPositive(vector<int>& nums) {\\n\\t\\tint size = nums.size();\\n\\t\\tbool hasOne = false;\\n\\n\\t\\tfor (int& n : nums) { // Set all negatives to 0\\n\\t\\t\\tif (n < 0)\\n\\t\\t\\t\\tn = 0;\\n\\t\\t\\telse if (n == 1)\\n\\t\\t\\t\\thasOne = true;\\n\\t\\t}\\n\\n\\t\\tif (!hasOne) // One is the first missing\\n\\t\\t\\treturn 1;\\n\\n\\t\\tfor (int i = 0; i < size; i++) { // Negate all numbers at indices by found values\\n            int currNum = abs(nums[i]);\\n\\t\\t\\tif (currNum > 0 && currNum <= size)\\n\\t\\t\\t\\tif (nums[currNum - 1] == 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] = -1;\\n\\t\\t\\t\\telse if (nums[currNum - 1] > 0)\\n\\t\\t\\t\\t\\tnums[currNum - 1] *= -1; // Negate it\\n\\t\\t}\\n\\n\\t\\tfor (int i = 0; i < size; i++) // Find first non negative number\\n\\t\\t\\tif (nums[i] > -1)\\n\\t\\t\\t\\treturn i + 1;\\n\\n\\t\\treturn size + 1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55793,
                "title": "short-0ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        int rob(vector<int>& nums) {\\n            int x = 0, y = 0;\\n            for (int i = 0; i < nums.size(); ++i) {\\n                if (i & 1) {\\n                    x = max(x + nums[i], y);\\n                } else {\\n                    y = max(y + nums[i], x);\\n                }\\n            }\\n            return max(x, y);\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int rob(vector<int>& nums) {\\n            int x = 0, y = 0;\\n            for (int i = 0; i < nums.size(); ++i) {\\n                if (i & 1) {\\n                    x = max(x + nums[i], y);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 55959,
                "title": "4-line-python-o-1-space-o-n-time-with-explaination-simplest",
                "content": "    class Solution:\\n        # @param num, a list of integer\\n        # @return an integer\\n        def rob(self, num):\\n            # DP O(n) time, O(1) space\\n            # ik: max include house k\\n            # ek: max exclude house k, (Note: ek is also the maximum for house 1,...,k-1)\\n            # i[k+1]: num[k] + ek #can't include house k\\n            # e[k+1]: max(ik, ek) # can either include house k or exclude house k\\n            i, e = 0, 0\\n            for n in num: #from k-1 to k\\n                i, e = n+e, max(i,e)\\n            return max(i,e)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param num, a list of integer\\n        # @return an integer\\n        def rob(self, num):\\n            # DP O(n) time, O(1) space\\n            # ik: max include house k\\n            # ek: max exclude house k, (Note: ek is also the maximum for house 1,...,k-1)\\n            # i[k+1]: num[k] + ek #can't include house k\\n            # e[k+1]: max(ik, ek) # can either include house k or exclude house k\\n            i, e = 0, 0\\n            for n in num: #from k-1 to k\\n                i, e = n+e, max(i,e)\\n            return max(i,e)",
                "codeTag": "Java"
            },
            {
                "id": 2909861,
                "title": "c-3-approachs-memoization-tabulation-space-optimization",
                "content": "# Intuition\\nApproach that clicks into my mind is use recursion since we have to find all the ways to get maximum sum.\\n\\n# Approach\\nFor each house, we have two options- \\ni) Either rob that house, add its money to the sum and move to next-to-next house.\\nii) Or don\\'t rob that house and move to next one.\\nand At last find maximum sum.\\n\\n# Memoization\\n```\\nint rec(vector<int> &nums, int idx, vector<int> &dp)\\n{\\n    if(idx>=nums.size()) return 0;\\n    \\n    if(dp[idx]!=-1) dp[idx];\\n    \\n    return dp[idx] = max(rec(nums, idx+1, dp), nums[idx]+rec(nums, idx+2, dp));\\n}\\n\\nint rob(vector<int>& nums) \\n{\\n    vector<int> dp(nums.size()+1, -1);\\n    return rec(nums, 0, dp);\\n    \\n}\\n```\\n### Complexity\\n- Time complexity:\\nO(N) (recursion)\\n\\n- Space complexity:\\nO(N) (dp) + O(N) (recursion auxiliary space)\\n\\n# Tabulation\\n\\n```\\nint rob(vector<int>& nums)\\n{\\n    if(nums.size()==1) return nums[0];\\n    \\n    vector<int> dp(nums.size());\\n    \\n    dp[0] = nums[0];\\n    dp[1] = max(dp[0], nums[1]);\\n    \\n    for(int i=2; i<nums.size(); i++)\\n    {\\n        dp[i] = max(dp[i-1], dp[i-2]+nums[i]);\\n    }\\n    return dp[nums.size()-1];\\n}\\n```\\n### Complexity\\n- Time complexity:\\nO(N) (loop)\\n\\n- Space complexity:\\nO(N) (dp)\\n\\n# Space Optimization\\n```\\nint rob(vector<int>& nums)\\n{\\n    if(nums.size()==1) return nums[0];\\n    \\n    int pre2 = nums[0];\\n    int pre1 = max(nums[0], nums[1]);\\n    int cur;\\n    \\n    for(int i=2; i<nums.size(); i++)\\n    {\\n        cur = max(pre1, pre2+nums[i]);\\n        pre2 = pre1;\\n        pre1 = cur;\\n    }\\n    return pre1;\\n}\\n```\\n### Complexity\\n- Time complexity:\\nO(N) (loop)\\n\\n- Space complexity:\\nO(1) \\n\\n\\n    \\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint rec(vector<int> &nums, int idx, vector<int> &dp)\\n{\\n    if(idx>=nums.size()) return 0;\\n    \\n    if(dp[idx]!=-1) dp[idx];\\n    \\n    return dp[idx] = max(rec(nums, idx+1, dp), nums[idx]+rec(nums, idx+2, dp));\\n}\\n\\nint rob(vector<int>& nums) \\n{\\n    vector<int> dp(nums.size()+1, -1);\\n    return rec(nums, 0, dp);\\n    \\n}\\n```\n```\\nint rob(vector<int>& nums)\\n{\\n    if(nums.size()==1) return nums[0];\\n    \\n    vector<int> dp(nums.size());\\n    \\n    dp[0] = nums[0];\\n    dp[1] = max(dp[0], nums[1]);\\n    \\n    for(int i=2; i<nums.size(); i++)\\n    {\\n        dp[i] = max(dp[i-1], dp[i-2]+nums[i]);\\n    }\\n    return dp[nums.size()-1];\\n}\\n```\n```\\nint rob(vector<int>& nums)\\n{\\n    if(nums.size()==1) return nums[0];\\n    \\n    int pre2 = nums[0];\\n    int pre1 = max(nums[0], nums[1]);\\n    int cur;\\n    \\n    for(int i=2; i<nums.size(); i++)\\n    {\\n        cur = max(pre1, pre2+nums[i]);\\n        pre2 = pre1;\\n        pre1 = cur;\\n    }\\n    return pre1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 831866,
                "title": "easy-js-solution",
                "content": "```\\n/*\\nAt each house, we can choose to either rob or skip\\nIf we choose to rob, we can\\'t rob the next house\\nIf we choose to skip, we can rob the next house\\n\\ndp[i] is the maximum amount of money we can rob without alerting the police at house i\\ndp[i] = max(dp[i-2] + nums[i], dp[i-1])\\n*/\\nvar rob = function(nums) {\\n    if (nums === null || nums.length === 0) {\\n        return 0;\\n    }\\n    let dp = new Array(nums.length);\\n    dp[0] = nums[0];\\n    dp[1] = Math.max(nums[0], nums[1]);\\n    for (let i = 2; i < nums.length; i++) {\\n        dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);\\n    }\\n    return dp[nums.length - 1];\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nAt each house, we can choose to either rob or skip\\nIf we choose to rob, we can\\'t rob the next house\\nIf we choose to skip, we can rob the next house\\n\\ndp[i] is the maximum amount of money we can rob without alerting the police at house i\\ndp[i] = max(dp[i-2] + nums[i], dp[i-1])\\n*/\\nvar rob = function(nums) {\\n    if (nums === null || nums.length === 0) {\\n        return 0;\\n    }\\n    let dp = new Array(nums.length);\\n    dp[0] = nums[0];\\n    dp[1] = Math.max(nums[0], nums[1]);\\n    for (let i = 2; i < nums.length; i++) {\\n        dp[i] = Math.max(dp[i-2] + nums[i], dp[i-1]);\\n    }\\n    return dp[nums.length - 1];\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2909981,
                "title": "recursion-memoization-tabulation-space-optimization",
                "content": "**1. Recursion: [Not accepted : TLE]**\\n```\\nclass Solution {\\npublic:\\n    int f(int ind,vector<int>& nums){\\n        if(ind==0) return nums[ind];    \\n        if(ind<0) return 0;\\n        int pick=nums[ind]+ f(ind-2,nums);\\n        int notPick=f(ind-1,nums);\\n        return max(pick,notPick); \\n    }\\n    int rob(vector<int>& nums){\\n        int n=nums.size();\\n        return f(n-1,nums);\\n    }\\n};\\n```\\n**TC: O(2^N)** , where N is the number of elements in A. At each index, we have two choices of either robbing or not robbing the current house. Thus this leads to time complexity of 2*2*2...n times \\u2248 O(2^N)\\n**SC: O(N)** , It is recursive stack space.\\n\\n**2. Memoization/Top-down DP: [accepted]**\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums){\\n        int n=nums.size();\\n        vector<int> dp(n,-1);\\n        return f(n-1,nums,dp);\\n    }\\n    int f(int ind,vector<int>& nums, vector<int>& dp){\\n        if(ind==0) return nums[ind];\\n        if(ind<0) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        int pick= nums[ind]+ f(ind-2,nums,dp);\\n        int notPick= f(ind-1,nums,dp);\\n        return dp[ind]=max(pick,notPick);\\n    }\\n};\\n```\\n**TC:** O(N) \\n**SC:** O(N)+O(N), one is recursive stack space and anothe O(N) is for dp array.\\n\\n**3. Tabulation/Buttom Up DP:**\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums){\\n        int n=nums.size();\\n        vector<int> dp(n);\\n        dp[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            int pick=nums[i];\\n            if(i>1) pick+=dp[i-2];\\n            int notPick=dp[i-1];\\n            dp[i]=max(pick,notPick);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\n**TC:** O(N) \\n**SC:** O(N), for dp array.\\n\\n**4. Space Optimization:**\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        int prev=nums[0], prev2=0;\\n        for(int i=1;i<n;i++){\\n            int pick=nums[i]+prev2;\\n            int notPick=prev;\\n            int cur=max(pick,notPick);\\n            prev2=prev;\\n            prev=cur;\\n        }\\n        return prev;\\n    }\\n};\\n```\\n**TC:** O(N) \\n**SC:** O(1)\\n\\n***Do an upvote if this is helpful!***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int ind,vector<int>& nums){\\n        if(ind==0) return nums[ind];    \\n        if(ind<0) return 0;\\n        int pick=nums[ind]+ f(ind-2,nums);\\n        int notPick=f(ind-1,nums);\\n        return max(pick,notPick); \\n    }\\n    int rob(vector<int>& nums){\\n        int n=nums.size();\\n        return f(n-1,nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums){\\n        int n=nums.size();\\n        vector<int> dp(n,-1);\\n        return f(n-1,nums,dp);\\n    }\\n    int f(int ind,vector<int>& nums, vector<int>& dp){\\n        if(ind==0) return nums[ind];\\n        if(ind<0) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        int pick= nums[ind]+ f(ind-2,nums,dp);\\n        int notPick= f(ind-1,nums,dp);\\n        return dp[ind]=max(pick,notPick);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums){\\n        int n=nums.size();\\n        vector<int> dp(n);\\n        dp[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            int pick=nums[i];\\n            if(i>1) pick+=dp[i-2];\\n            int notPick=dp[i-1];\\n            dp[i]=max(pick,notPick);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        int prev=nums[0], prev2=0;\\n        for(int i=1;i<n;i++){\\n            int pick=nums[i]+prev2;\\n            int notPick=prev;\\n            int cur=max(pick,notPick);\\n            prev2=prev;\\n            prev=cur;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55976,
                "title": "java-o-n-dp-solution-with-13-lines-clean-code",
                "content": "     public int rob(int[] num) {\\n    \\t\\tint n = num.length;\\n    \\t\\tif (n < 2)\\n    \\t\\t\\treturn n == 0 ? 0 : num[0];\\n    \\t\\tint[] cache = new int[n];\\n    \\t\\tcache[0] = num[0];\\n    \\t\\tcache[1] = num[0] > num[1] ? num[0] : num[1];\\n    \\t\\tfor (int i = 2; i < n; i++) {\\n    \\t\\t\\tcache[i] = cache[i - 2] + num[i];\\n    \\t\\t\\tcache[i] = cache[i] > cache[i-1]? cache[i] : cache[i-1];\\n    \\t\\t}\\n    \\t\\treturn cache[n - 1];\\n    \\t}",
                "solutionTags": [],
                "code": "     public int rob(int[] num) {\\n    \\t\\tint n = num.length;\\n    \\t\\tif (n < 2)\\n    \\t\\t\\treturn n == 0 ? 0 : num[0];\\n    \\t\\tint[] cache = new int[n];\\n    \\t\\tcache[0] = num[0];\\n    \\t\\tcache[1] = num[0] > num[1] ? num[0] : num[1];\\n    \\t\\tfor (int i = 2; i < n; i++) {\\n    \\t\\t\\tcache[i] = cache[i - 2] + num[i];\\n    \\t\\t\\tcache[i] = cache[i] > cache[i-1]? cache[i] : cache[i-1];\\n    \\t\\t}\\n    \\t\\treturn cache[n - 1];\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 55972,
                "title": "explanation-of-the-recursive-formula",
                "content": "By using Dynamic Programming, we can get the maximum amount of money step by step.\\n\\nFor every house  along the street, there are two situations,\\n\\n **1. If the previous house had been robbed, we can't rob the current house,**\\n\\n    currentMaxValue = max(previousNoRobbery, previousYesRobbery);\\n\\n **2. If the previous house hadn't been robbed, we can rob the current house,**\\n\\n    currentMaxValue = moneyOfCurrentHouse + previousNoRobbery\\n\\n\\n----------\\nHere's the code:\\n\\n    int rob(vector<int> &num) {\\n        int preNoRob = 0, preYesRob = 0;\\n        \\n        for(int i = 1; i <= num.size(); ++i) {\\n            int preNoRobTemp = preNoRob;\\n            preNoRob = max(preNoRob, preYesRob); // situation 1\\n            preYesRob = num[i-1] + preNoRobTemp; // situation 2\\n        }\\n        return max(preNoRob, preYesRob);\\n    }",
                "solutionTags": [],
                "code": "By using Dynamic Programming, we can get the maximum amount of money step by step.\\n\\nFor every house  along the street, there are two situations,\\n\\n **1. If the previous house had been robbed, we can't rob the current house,**\\n\\n    currentMaxValue = max(previousNoRobbery, previousYesRobbery);\\n\\n **2. If the previous house hadn't been robbed, we can rob the current house,**\\n\\n    currentMaxValue = moneyOfCurrentHouse + previousNoRobbery\\n\\n\\n----------\\nHere's the code:\\n\\n    int rob(vector<int> &num) {\\n        int preNoRob = 0, preYesRob = 0;\\n        \\n        for(int i = 1; i <= num.size(); ++i) {\\n            int preNoRobTemp = preNoRob;\\n            preNoRob = max(preNoRob, preYesRob); // situation 1\\n            preYesRob = num[i-1] + preNoRobTemp; // situation 2\\n        }\\n        return max(preNoRob, preYesRob);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2910165,
                "title": "python-c-rust-iterative-recursive-solutions-explained-bonus-one-liner",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a *Dynamic Programming* approach to explore all possible paths. Time complexity is linear: **O(N)**. \\n****\\n\\n**Python #1.** Recursive DFS with memoization. Here, we consider each house and (i) either skip it (ii) or rob and skip the next one. This way, we will make a branching decision at every house, thus, exploring all possible scenarios of massive robbery. Space complexity is linear: **O(N)**.\\n```\\nclass Solution:\\n    \\n    def rob(self, nums):\\n        \\n        @cache\\n        def dfs(i):\\n            return max(dfs(i+1), nums[i] + dfs(i+2)) if i < len(nums) else 0\\n        \\n        return dfs(0)\\n```\\n\\n**C++ #1.** Iterative. The same logic as above, but updating the state explicitly. Space complexity is linear: **O(N)**.\\n```\\nclass Solution \\n{\\npublic:\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> dp(n+2,0);\\n        \\n        for (int i = n-1; i >= 0; i--)\\n            dp[i] = max(dp[i+1], nums[i] + dp[i+2]);\\n    \\n        return dp[0];\\n    }\\n};\\n```\\n\\n**C++ #2.** Iterative. From the solution above, we notice that we don\\'t need to maintain the whole `dp` array. Only three values `dp[i]`, `dp[i+1]` and `dp[i+2]` are used in the cycle. Space complexity is constant: **O(1)**.\\n```\\nclass Solution \\n{\\npublic:\\n    int rob(vector<int>& nums) \\n    {\\n        int dp0 = 0, dp1 = 0, dp2 = 0;\\n\\n        for (int n : nums)\\n            dp0 = max(dp1, n + dp2),  // [1] max profit at current house\\n            dp2 = dp1,                // [2] shift last 2 values to be \\n            dp1 = dp0;                //     used in the next iteration\\n\\n        return dp0;\\n    }\\n};\\n```\\n\\n**Python #3.** The last one can be compactified even further using Python\\'s multiple assignment.\\n```\\nclass Solution:\\n\\n    def rob(self, nums):\\n        dp1 = dp2 = 0\\n        for n in nums: \\n            dp2, dp1 = dp1, max(dp1, dp2 + n)\\n        return dp1\\n```\\n\\n**\\u2705 YOU MADE IT TILL THE BONUS SECTION... YOUR GREAT EFFORT DESERVES UPVOTING THIS POST!**\\n\\n**Python.** One-liner for the last Python solution.\\n```\\nclass Solution:\\n    def rob(self, nums):\\n        return reduce(lambda dp, n: (max(n + dp[1], dp[0]), dp[0]), nums, [0,0])[0]\\n```\\n\\n**Rust.** One-liner with the same logic as above.\\n```\\nimpl Solution\\n{\\n    pub fn rob(nums: Vec<i32>) -> i32\\n    {\\n        nums.into_iter()\\n            .fold((0,0), |(dp1,dp2), n| (dp1.max(n + dp2), dp1)).0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def rob(self, nums):\\n        \\n        @cache\\n        def dfs(i):\\n            return max(dfs(i+1), nums[i] + dfs(i+2)) if i < len(nums) else 0\\n        \\n        return dfs(0)\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        vector<int> dp(n+2,0);\\n        \\n        for (int i = n-1; i >= 0; i--)\\n            dp[i] = max(dp[i+1], nums[i] + dp[i+2]);\\n    \\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int rob(vector<int>& nums) \\n    {\\n        int dp0 = 0, dp1 = 0, dp2 = 0;\\n\\n        for (int n : nums)\\n            dp0 = max(dp1, n + dp2),  // [1] max profit at current house\\n            dp2 = dp1,                // [2] shift last 2 values to be \\n            dp1 = dp0;                //     used in the next iteration\\n\\n        return dp0;\\n    }\\n};\\n```\n```\\nclass Solution:\\n\\n    def rob(self, nums):\\n        dp1 = dp2 = 0\\n        for n in nums: \\n            dp2, dp1 = dp1, max(dp1, dp2 + n)\\n        return dp1\\n```\n```\\nclass Solution:\\n    def rob(self, nums):\\n        return reduce(lambda dp, n: (max(n + dp[1], dp[0]), dp[0]), nums, [0,0])[0]\\n```\n```\\nimpl Solution\\n{\\n    pub fn rob(nums: Vec<i32>) -> i32\\n    {\\n        nums.into_iter()\\n            .fold((0,0), |(dp1,dp2), n| (dp1.max(n + dp2), dp1)).0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846231,
                "title": "simple-java-solution-with-explaination-100-faster-0ms-o-n-time-dp",
                "content": "We cannot just keep sum of odd and even index elements and return the max out of them because of case like below -\\n[3,2,2,3] as per odd and even elements -> max(5,5) return 5 but answer would be 6. As just by considering 0 and last index element only we get max profit here. It is not mandatory to pick alternate elements to get max result.\\n1. Take an dp array of size n+1. where n is length of nums array.\\n2. dp[0] will denote max profit with 0 number of houses. hence it is 0.\\n3. dp[1] will be max profit with 1 house. which is num[0].\\n4. now for every next element i.e. dp[2] onwards we have a choice to either include the alternative element or exclude it so that we can make more profit by considering element next to alternate one. \\n5. so while considering current element i we have to choose either use previous max score i.e. dp[i] OR add current element to the 2nd max. i.e. dp[i+1]=max(dp[i], dp[i-1]+nums[i])\\n6.after loop finishes we have the dp[n] as answer.\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length==0) {\\n            return 0;\\n        }\\n        int[] dp = new int[nums.length+1];\\n        dp[1]=nums[0];\\n        for(int i=1;i<nums.length;i++) {\\n            dp[i+1]=Math.max(dp[i],dp[i-1]+nums[i]);\\n        }\\n        return dp[nums.length];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length==0) {\\n            return 0;\\n        }\\n        int[] dp = new int[nums.length+1];\\n        dp[1]=nums[0];\\n        for(int i=1;i<nums.length;i++) {\\n            dp[i+1]=Math.max(dp[i],dp[i-1]+nums[i]);\\n        }\\n        return dp[nums.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55938,
                "title": "dp-with-two-variables-easiest-solution-i-think-o-n",
                "content": "I use two variables respectively to store the maximum amount of money for both action: rob and not rob. \\n\\nTo determine the maximum amount of money that we can rob from the first house to the current house, we need to consider two choice - rob this house or not:\\n\\n+ if we don't rob this house, the maximum amount of money is the bigger one between to rob and not to rob the previous house;\\n\\n+ if we rob this house, the maximum amount of money is the amount of money that we don't rob the previous house plus the money in the current house.\\n\\nThat is,\\n\\n> notRob[i+1] = max(notRob[i], Rob[i]); \\n\\n> Rob[i+1] = notRob[i] + moneyInHouse[i+1]\\n\\nSo, the Python code is like:\\n\\n    # @param {integer[]} nums\\n    # @return {integer}\\n    def rob(self, nums):\\n    \\tRob = non_Rob = 0\\n    \\tfor n in nums:\\n    \\t\\tnon_Rob, Rob = max(non_Rob, Rob), non_Rob + n\\n    \\treturn max(Rob, non_Rob)\\n\\n For people who don't use Python: The assignment statement in the loop calculate the two value first and then assign them to the variables on the left of `=`, which means the values of `non_Rob` and `Rob` won't change until we get both two new values.\\n\\nSorry for my poor English. If the idea is not clearly explained, please remind me.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "I use two variables respectively to store the maximum amount of money for both action: rob and not rob. \\n\\nTo determine the maximum amount of money that we can rob from the first house to the current house, we need to consider two choice - rob this house or not:\\n\\n+ if we don't rob this house, the maximum amount of money is the bigger one between to rob and not to rob the previous house;\\n\\n+ if we rob this house, the maximum amount of money is the amount of money that we don't rob the previous house plus the money in the current house.\\n\\nThat is,\\n\\n> notRob[i+1] = max(notRob[i], Rob[i]); \\n\\n> Rob[i+1] = notRob[i] + moneyInHouse[i+1]\\n\\nSo, the Python code is like:\\n\\n    # @param {integer[]} nums\\n    # @return {integer}\\n    def rob(self, nums):\\n    \\tRob = non_Rob = 0\\n    \\tfor n in nums:\\n    \\t\\tnon_Rob, Rob = max(non_Rob, Rob), non_Rob + n\\n    \\treturn max(Rob, non_Rob)\\n\\n For people who don't use Python: The assignment statement in the loop calculate the two value first and then assign them to the variables on the left of `=`, which means the values of `non_Rob` and `Rob` won't change until we get both two new values.\\n\\nSorry for my poor English. If the idea is not clearly explained, please remind me.",
                "codeTag": "Python3"
            },
            {
                "id": 55799,
                "title": "easy-java-solution-using-dp",
                "content": "public class Solution {\\n    public int rob(int[] nums) {\\n        \\n        //if nums is null or length 0, return 0\\n        if(nums==null || nums.length==0)\\n            return 0;\\n            \\n        //if only 1 element is present,return it as the answer\\n        if(nums.length==1)\\n            return nums[0];\\n            \\n        //array to store the maxProfit attained\\n        int[] maxProfit=new int[nums.length];\\n        \\n        //assign fisrt value\\n        maxProfit[0]=nums[0];\\n        \\n        //second value is higher of first and second\\n        maxProfit[1]=Math.max(nums[0],nums[1]);\\n        \\n        //do dynamic programming for subsequent values\\n        for(int i=2;i<nums.length;i++)\\n        {\\n            maxProfit[i]=Math.max(maxProfit[i-2]+nums[i],maxProfit[i-1]);\\n        }\\n        \\n        //return the last value as answer\\n        return maxProfit[nums.length-1];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int rob(int[] nums) {\\n        \\n        //if nums is null or length 0, return 0\\n        if(nums==null || nums.length==0)\\n            return 0;\\n            \\n        //if only 1 element is present,return it as the answer\\n        if(nums.length==1)\\n            return nums[0];\\n            \\n        //array to store the maxProfit attained\\n        int[] maxProfit=new int[nums.length];\\n        \\n        //assign fisrt value\\n        maxProfit[0]=nums[0];\\n        \\n        //second value is higher of first and second\\n        maxProfit[1]=Math.max(nums[0],nums[1]);\\n        \\n        //do dynamic programming for subsequent values\\n        for(int i=2;i<nums.length;i++)\\n        {\\n            maxProfit[i]=Math.max(maxProfit[i-2]+nums[i],maxProfit[i-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 527520,
                "title": "dp-solution-and-explained-well-for-beginners-only",
                "content": "I will go through step by step to get you understand in better way, so that you all can solve further dp problems easily. *( for being beginner in solving dp problems i can understand the pain,but believe me after this solution you all will get some idea that how to tackle dp problem )*. :)\\n\\nokay, we will start with basics :\\n**Ques**  what if only one house was there?\\n**Ans** So easy right :D , thief will rob that house and get the money.\\n\\n**Ques** what if two house were there with different amount of money?\\n**Ans** umm,not that difficult, the one with max amount of money, thief will go into that house. Easy right !\\n\\nReal problem comes when we have more number of house, but believe me you have already cracked the logic.\\n\\nSo, assume you are starting with first house, after that you can either go to third or fourth or fifth or sixth or last one, depending on which house will give you more profit.(robber can\\'t go to second house as it is adjacent to first).\\nright? That makes sense !\\nBut out of that third or fourth or fifth or sixth etc.. which house to choose?\\n**Ans** Here comes the idea of storing value into an array and that array will going to store maximum amount of money robber can get, if he chooses any house as first house to rob.\\nex : let us suppose 7 houses are there with some amount of money correspondingly :\\n\\nh1,h2,h3,h4,h5,h6,h7.\\n23,12,32,26,20,21,19.\\n\\nAssume robber can go from left to right only,\\nso if he start with h6 or h7  leaving behind all the houses,maximum amount of money he will get same as amount is present in h6 or h7, (as we are assuming robber can go only  left to right).\\n\\nwe will make array as same size of amount array,and name as **dp[ ] =** __ , __ , __ , __ , __ , 21 , 19 (assume index starting from 1 and index representing house numbers).\\nhere each index will going to store maximum amount of money robber will get, if he start robing from that particular house.\\nyou can see that h6 and h7 house values are directly written in dp array.\\n\\nokay,let us come to analysis :\\nif robber went to h1, then next house which he has to go depends on which house is giving maximum amount of money out of h3,h4,h5,h6,h7.\\n\\nSTEP 1 : **max amount of money if he start from h1 or dp[1]= amount of money he get from h1 house + Max amount of money from (h3,h4,h5,h6,h7).**\\nokay,but how we will going to calculate max amount robber can get from h3,h4,h5,h6,h7.\\n**Ans** Same as above !\\nSTEP 2 :**max amount of money if he start from h3 or dp[3] = amount of money he get from h3 house + Max amount of money from (h5,h6,h7).**\\nlike wise we will continue in recursive fashion,until we hit the second last house or last house.\\n\\nSTEP 3 : **max amount of money if he start from h5 or dp[5]= amount of money he get from h5 house + Max amount of money from (h7).**\\n**dp[5]=20+19**\\n**dp[ ] =** __ , __ , __ , __ , 39 , 21 , 19. \\nnow we can calculate for *STEP 2* ,\\ndp[3]=amount in house h3 + max amount we can get from (h5,h6,h7).\\ndp[3]=32 + max of (39,21,19).\\ndp[3]=71\\n**dp[ ] =** __ , __ , 71 , __ , 39 , 21 , 19.\\nnow we can calculate same for *STEP 1*,\\ndp[1]=amount in house h1 + max amount we can get from (h3,h4,h5,h6,h7).\\nBut,\\nwe know what max amount we can get from h3,h5,h6,h7 but don\\'t know about h4.At first, we need to calculate that :\\nSTEP 4 : **max amount of money if he start from h4 or dp[4] = amount of money he get from h4 house + Max amount of money from (h6,h7)**\\ndp[4]=26+ max of (21,19)\\ndp[4]=47\\n**dp[ ] =** __ , __ , 71 , 47 , 39 , 21 , 19.\\nnow, we can go back to calculate *STEP 1* \\ndp[1]=amount in house h1 + max amount we can get from (h3,h4,h5,h6,h7).\\ndp[1]=23+max of (71,47,39,21,19)\\ndp[1]=94\\n**dp[ ] =** 94, __ , 71 , 47 , 39 , 21 , 19.\\nSTEP 5 : **max amount of money if he start from h2or dp[2] = amount of money he get from h4 house + Max amount of money from (h4,h5,h6,h7)**\\ndp[2]=12+ max of(47,39,21,19)\\ndp[2]=59\\n**dp[ ] =** 94, 59 , 71 , 47 , 39 , 21 , 19.\\nsince in question asking for the maximum amount, so the answer is 94.\\n\\nlet us go through the code now :\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n=nums.length;\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n==1){\\n            return nums[0];\\n        }\\n        if(n==2){\\n            return Math.max(nums[0],nums[1]);\\n        }\\n\\t\\t/*above are just  for special conditions when array length is less than 2*/\\n\\t\\t\\n        int[] dp=new int[n]; //creating array\\n        Arrays.fill(dp,-1);\\n        dp[n-1]=nums[n-1];\\n        dp[n-2]=nums[n-2];\\n        \\n        for(int i=0;i<nums.length;i++){\\n        helper(dp,nums,i);\\n        }\\n        return  Arrays.stream(dp).max().getAsInt();\\n    }\\n    public int helper(int[] dp,int[] nums,int i){\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        int max=-1;\\n        for(int j=i+2;j<nums.length;j++){\\n            dp[j]=helper(dp,nums,j);\\n            if(max<dp[j])\\n                max=dp[j];\\n        }\\n        dp[i]=nums[i]+max;\\n        return dp[i];\\n    }\\n}\\n```\\n\\nI have spent an hour just to explain, how to solve dp question.\\nthanks for reading, hope you all got some sort of glimpse, that how to encounter dp problems.\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n=nums.length;\\n        if(n==0){\\n            return 0;\\n        }\\n        if(n==1){\\n            return nums[0];\\n        }\\n        if(n==2){\\n            return Math.max(nums[0],nums[1]);\\n        }\\n\\t\\t/*above are just  for special conditions when array length is less than 2*/\\n\\t\\t\\n        int[] dp=new int[n]; //creating array\\n        Arrays.fill(dp,-1);\\n        dp[n-1]=nums[n-1];\\n        dp[n-2]=nums[n-2];\\n        \\n        for(int i=0;i<nums.length;i++){\\n        helper(dp,nums,i);\\n        }\\n        return  Arrays.stream(dp).max().getAsInt();\\n    }\\n    public int helper(int[] dp,int[] nums,int i){\\n        if(dp[i]!=-1)\\n            return dp[i];\\n        int max=-1;\\n        for(int j=i+2;j<nums.length;j++){\\n            dp[j]=helper(dp,nums,j);\\n            if(max<dp[j])\\n                max=dp[j];\\n        }\\n        dp[i]=nums[i]+max;\\n        return dp[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847007,
                "title": "house-robber-python-dp-explanation-approaching-a-dp",
                "content": "What we have to know is, I think, why this problem is a DP.\\nDP, Dynamic Programming, is commonly used when the next result can be easily derived from the previous result, or the set of previous result is strongly affecting toward the next result. In this case, memorizing previous status, or results, of the same calculation faciliates total calculations and improves time efficiency by accessing old data with O(1) complexity, i.e. array, dict, or hashmap.\\n\\nThe key to solve a DP, in my opinion, is \"Which statement should be memorized.\", and the easiest way to catch whether a problem is a DP is that the answer can be represented as a sequence.\\n\\nFor instance, Fibonacci sequence which is one of the most common examples for a DP.\\nBy definition, ```S``` is a fibonacci sequence where ```S(n) = S(n-1) + S(n-2)``` and ```S(n)``` represents ```S-nth``` element.\\nIn most cases, the value of ```S(0)``` and ```S(1)``` is given, assuming 0-indexed.\\nIn other words, if ```S(0) = 1```, ```S(1) = 1```, the sequence ```S``` will be ```1, 1, 2, 3, 5, 8,...```.\\nFrom this example, I\\'d like to emphasize as **essentials** that \\n\\n* We should find a sequence from a question\\n* Some initial values must be defined, which will be a terminate condition when code uses recursive.\\n\\nLet\\'s start with House Robber.\\nIt says \\'The only constraint is not to rob adjacent houses.\\'\\nWhich menas that I have to decide to rob n-th house or not before visiting the next house, (n+1)-th house. \\nSince we are not a prophet, we don\\'t know the consequences before we trying it. So, let\\'s dig it little more.\\nAt the point of decision, we have two options.\\n\\n* Rob this house and skip the next\\n* Skip this hous to rob the next\\n\\nHowever, if we change our point of view, options can be re-written.\\n\\n* Rob this house if the result of robbing 0-th to (n-2)-th house is better than the result of robbing (n-1)-th house\\n* If not, skip this house\\n\\nPersonally, I call this transformation as a magic of sequence because it is allowed due to the definition of sequence.\\n\\nNow, I can derive a sequence, such as\\n```Rob(n) = max(Rob(n-2) + Money(n), Rob(n-1))```\\nwhere ```Rob(n)``` is the maximum of the sum of robbed money from 0-th house to n-th house, and ```Money(n)``` is the amount of money in the n-th house. **(First essential)**\\nBecause we need up to two previous robbed money, we have to calculate the initial values, ```Rob(0)```,``` Rob(1)```. **(Second essential)**\\n```Rob(0) = Money(0)```\\n```Rob(1) = max(Money(0), Money(1))```\\n\\nConsequently, the basement of function is\\n```\\nClass Solution:\\n\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\trobs = [0] * len(nums) # assign and initialize robs array\\n\\t\\trobs[0], robs[1] = nums[0], max(nums[:2]) # second essential\\n\\t\\tfor i in range(2, len(nums)):\\n\\t\\t\\trobs[i] = max(robs[i-1], robs[i-2]+nums[i]) # applying sequence\\n\\t\\treturn robs[-1] \\n```\\n\\nThe constraint of this problem is ```0 <= nums.length <= 100``` and it is crucial to finish this code.\\nThe reason is if ```nums.length``` is less than 2, it is not going to work because of index out of bound error at ```robs[i] = max(robs[i-1], robs[i-2]+nums[i])```. \\n\\nAs a result, it will be\\n```\\nClass Solution:\\n\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\tif len(nums) == 0:\\n\\t\\t\\treturn 0 # no house, no outcome\\n\\t\\telif len(nums) == 1:\\n\\t\\t\\treturn nums[0] # one house, focus on what we have\\n\\t\\telse:\\n\\t\\t\\trobs = [0] * len(nums) # assign and initialize robs array\\n\\t\\t\\trobs[0], robs[1] = nums[0], max(nums[:2]) # second essential\\n\\t\\t\\tfor i in range(2, len(nums)):\\n\\t\\t\\t\\trobs[i] = max(robs[i-1], robs[i-2]+nums[i]) # applying sequence\\n\\t\\t\\treturn robs[-1] \\n```\\n\\nSince we only traverse houses once, time complexity is ```O(N)```, where ```N``` is the number of houses.\\nAssigning ```robs``` is also ```O(N)``` so time complexity is not going to be changed.\\nSpace complexity is ```O(N)``` as well because we are recording the amout in terms of ```robs```.\\n\\nPlus,\\nIt could be developed to ```O(1)``` space complexity because we only need to 2 previous results at maximum.\\nIn this case, the code will be\\n```\\nClass Solution:\\n\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\tif len(nums) == 0:\\n\\t\\t\\treturn 0 # no house, no outcome\\n\\t\\telif len(nums) == 1:\\n\\t\\t\\treturn nums[0] # one house, focus on what we have\\n\\t\\telse:\\n\\t\\t\\trobs0, robs1 = nums[0], max(nums[:2]) # second essential\\n\\t\\t\\tfor i in range(2, len(nums)):\\n\\t\\t\\t\\t # applying sequence\\n\\t\\t\\t\\tif i % 2:\\n\\t\\t\\t\\t\\trobs1 = max(robs0, robs1+num[i])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\trobs0 = max(robs1, robs0+num[i])\\n\\t\\t\\treturn max(robs0, robs1)\\n```\\n\\nI hope it would be helpful.\\n\\nAlso, I\\'m a very big fan of writing pythonic-code although this isn\\'t obviously.\\nSo, if you guys have a woderful idea, please don\\'t hesitate to share for others.\\n\\nThanks a lot for your attention.\\n\\np.s.) Any comment will be welcomed including typo, gramatical error since English is my second language.",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```S```\n```S(n) = S(n-1) + S(n-2)```\n```S(n)```\n```S-nth```\n```S(0)```\n```S(1)```\n```S(0) = 1```\n```S(1) = 1```\n```S```\n```1, 1, 2, 3, 5, 8,...```\n```Rob(n) = max(Rob(n-2) + Money(n), Rob(n-1))```\n```Rob(n)```\n```Money(n)```\n```Rob(0)```\n``` Rob(1)```\n```Rob(0) = Money(0)```\n```Rob(1) = max(Money(0), Money(1))```\n```\\nClass Solution:\\n\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\trobs = [0] * len(nums) # assign and initialize robs array\\n\\t\\trobs[0], robs[1] = nums[0], max(nums[:2]) # second essential\\n\\t\\tfor i in range(2, len(nums)):\\n\\t\\t\\trobs[i] = max(robs[i-1], robs[i-2]+nums[i]) # applying sequence\\n\\t\\treturn robs[-1] \\n```\n```0 <= nums.length <= 100```\n```nums.length```\n```robs[i] = max(robs[i-1], robs[i-2]+nums[i])```\n```\\nClass Solution:\\n\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\tif len(nums) == 0:\\n\\t\\t\\treturn 0 # no house, no outcome\\n\\t\\telif len(nums) == 1:\\n\\t\\t\\treturn nums[0] # one house, focus on what we have\\n\\t\\telse:\\n\\t\\t\\trobs = [0] * len(nums) # assign and initialize robs array\\n\\t\\t\\trobs[0], robs[1] = nums[0], max(nums[:2]) # second essential\\n\\t\\t\\tfor i in range(2, len(nums)):\\n\\t\\t\\t\\trobs[i] = max(robs[i-1], robs[i-2]+nums[i]) # applying sequence\\n\\t\\t\\treturn robs[-1] \\n```\n```O(N)```\n```N```\n```robs```\n```O(N)```\n```O(N)```\n```robs```\n```O(1)```\n```\\nClass Solution:\\n\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\tif len(nums) == 0:\\n\\t\\t\\treturn 0 # no house, no outcome\\n\\t\\telif len(nums) == 1:\\n\\t\\t\\treturn nums[0] # one house, focus on what we have\\n\\t\\telse:\\n\\t\\t\\trobs0, robs1 = nums[0], max(nums[:2]) # second essential\\n\\t\\t\\tfor i in range(2, len(nums)):\\n\\t\\t\\t\\t # applying sequence\\n\\t\\t\\t\\tif i % 2:\\n\\t\\t\\t\\t\\trobs1 = max(robs0, robs1+num[i])\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\trobs0 = max(robs1, robs0+num[i])\\n\\t\\t\\treturn max(robs0, robs1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 845997,
                "title": "c-house-robber-dp-time-o-n-space-o-1-beats-100",
                "content": "This is very simple 1-D DP problem. At every position we have two choices, either we can choose current house and add it with the previous alternate i.e \\n```\\ndp[i] = nums[i] + dp[i - 2];\\n```\\nor we can select the previous for maximum answer\\n```\\ndp[i] = dp[i -1]\\n```\\nSo now we merge them \\n```\\ndp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\\n```\\nThis approach is used in many similar problems in which we have to select alternates.\\n\\n## Lets code it:\\n\\n```\\nclass Solution {\\n    int dp[105];\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t\\n        if(n == 0) return 0;        \\n        dp[0] = nums[0];        \\n\\t\\t\\n        if(n == 1) return dp[0];        \\t\\t\\n        dp[1] = max(dp[0], nums[1]);        \\n\\t\\t\\n        for(int i = 2; i < n; i++){\\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\\n**TC : O(n)\\nSpace : O(n)**\\n\\n## Further Space Optimization\\nAs we can see we need to maintain 3 states\\n1. dp[i - 2] - previous answer -> ```prev1```\\n2. dp[i - 1] - previous alternate answer -> ```prev2```\\n3. dp[i] - current answer -> ```ans```\\n\\nSo we will replace dp array with above 3 variables\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0) return 0;\\n        \\n        int prev1, prev2;\\n        prev1 = nums[0];\\n        \\n        if(n == 1) return prev1;\\n        \\n        prev2 = max(prev1, nums[1]);\\n        int ans = prev2;\\n        for(int i = 2; i < n; i++){\\n            ans = max(prev2, prev1 + nums[i]);\\n            prev1 = prev2;\\n            prev2 = ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**TC : O(n)\\nSpace : O(1)**\\n \\nPlease comment if you have any doubt or a better solution. Please Upvote if you find this helpful!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[i] = nums[i] + dp[i - 2];\\n```\n```\\ndp[i] = dp[i -1]\\n```\n```\\ndp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\\n```\n```\\nclass Solution {\\n    int dp[105];\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\t\\n        if(n == 0) return 0;        \\n        dp[0] = nums[0];        \\n\\t\\t\\n        if(n == 1) return dp[0];        \\t\\t\\n        dp[1] = max(dp[0], nums[1]);        \\n\\t\\t\\n        for(int i = 2; i < n; i++){\\n            dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\n```prev1```\n```prev2```\n```ans```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n == 0) return 0;\\n        \\n        int prev1, prev2;\\n        prev1 = nums[0];\\n        \\n        if(n == 1) return prev1;\\n        \\n        prev2 = max(prev1, nums[1]);\\n        int ans = prev2;\\n        for(int i = 2; i < n; i++){\\n            ans = max(prev2, prev1 + nums[i]);\\n            prev1 = prev2;\\n            prev2 = ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167616,
                "title": "javascript-clean-dp-solution",
                "content": "```\\nvar rob = function(nums) {\\n    if(nums.length === 0) return 0;\\n    if(nums.length === 1) return nums[0];\\n    let totals = [nums[0], Math.max(nums[0], nums[1])];\\n    for(let i = 2; i < nums.length; i ++){\\n        totals[i] = Math.max(totals[i - 1], totals[i - 2] + nums[i]);\\n    }\\n    return totals[totals.length - 1];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar rob = function(nums) {\\n    if(nums.length === 0) return 0;\\n    if(nums.length === 1) return nums[0];\\n    let totals = [nums[0], Math.max(nums[0], nums[1])];\\n    for(let i = 2; i < nums.length; i ++){\\n        totals[i] = Math.max(totals[i - 1], totals[i - 2] + nums[i]);\\n    }\\n    return totals[totals.length - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55887,
                "title": "5-lines-0-ms-c-o-1-space-c-solution",
                "content": "    class Solution {\\n    public:\\n        int rob(vector<int>& nums) {\\n            int it1 = 0, it2 = 0;\\n            for (int i = 0; i < nums.size(); i++) {\\n                it1 = max(it1 + nums[i], it2);\\n                swap(it1, it2);\\n            }\\n            return it2;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int rob(vector<int>& nums) {\\n            int it1 = 0, it2 = 0;\\n            for (int i = 0; i < nums.size(); i++) {\\n                it1 = max(it1 + nums[i], it2);\\n                swap(it1, it2);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1605472,
                "title": "easy-c-o-n-time-o-1-space-solution-with-explanation",
                "content": "**Please upvote if you like the solution and feel free to comment if you have any query**\\n\\n**APPROACH:**\\nLet ans[i] be the maximum amount of money the robber can steal till the ith house.\\n\\nSuppose the robber is at house i, so he has 2 choices:\\n* Rob the current house. After this he cannot rob the house no i-1 due to the adjacent constraints given in the problem so we move on to finding the answer till house no i-2.\\n* Skip the current house and find the answer till the house no i-1.\\n\\nSo the relation becomes **ans[i]=max(ans[i-1],nums[i]+ans[i-2])**\\n\\nThe base case will arise when:\\n1. i=0: In this case we have only 1 house so we rob money from it and the answer for this subproblem will be nums[0]\\n2. i=1. In this case we have 2 houses so we can either steal from second house and skip the first or skip the second and steal from first. so the answer for this subproblem will be max(nums[0],nums[1])\\n\\nFor other cases, we use the relation defined earlier in this explanation.\\n\\nUsing this relation one can use a dp array to store the answer till the ith and (i-1)th index and use then to calculate the answer till (i+1)th index. But this solution will have a O(N) space complexity. \\n\\nWe can definitely improve it. Have a close look at the relation and you\\'ll observe that we\\'re using the anwsers of the previous 2 indexes only so we can store them into 2 variables and update them accordingly when a new iteration begins.\\n\\nSo we finally have a solution with O(N) time complexity and O(1)  space complexity.\\n\\n**CODE**\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n            return nums[0];\\n        int a=nums[0],b=max(nums[0],nums[1]);\\n        for(int i=2;i<n;i++){\\n            int tmp=b;\\n            b=max(nums[i]+a,b);\\n            a=tmp;\\n        }\\n        return b;\\n    }\\n};\\n```\\n**I hope this helps**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n            return nums[0];\\n        int a=nums[0],b=max(nums[0],nums[1]);\\n        for(int i=2;i<n;i++){\\n            int tmp=b;\\n            b=max(nums[i]+a,b);\\n            a=tmp;\\n        }\\n        return b;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605193,
                "title": "with-explanation-dp-with-o-l-time-and-o-1-space-in-python",
                "content": "# Explanation\\nFor each day, the robber has two choices - to rob or not to rob. Also, you can only rob when you didn\\'t rob on the previous day. Here, I create a dp table with size L `(L = len(nums))` and `dp[i]` represents **the maximum amount of money you can rob until the ith day**. The goal of this problem is to calculate `dp[-1]`, which is the maximum amount of money you can rob until the last day.\\n\\nNow, let\\'s write a formula.\\n1. If you didn\\'t rob yesterday (i - 1th day), you should always rob today (ith day) to maximize the amount. This can be written as `dp[i - 2] + nums[i]`, because `dp[i - 2]` denotes the maximum amount of money you can rob until the day before yesterday, and in that case you should always rob today. Note that all the elements in nums are nonnegative.\\n2. If you robbed on the previous day (i - 1th day), you can\\'t rob today. This can be written as `dp[i - 1]`.\\n\\nYou choose the maximum value between these two choices above, and the larger one is the maximum value you can rob up until today. Therefore, we get this formula.\\n\\n`dp[i] = max(nums[i - 2] + nums[i], dp[i - 1])`\\n\\nUsing this formula, you can write this first approach.\\n\\n\\n# DP with O(L) time and O(L) space\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        #edge case\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        #dp\\n        L = len(nums)\\n        dp = [0 for _ in range(L)]\\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\\n        \\n        for i in range(2, L):\\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\\n        \\n        return dp[-1]\\n```\\n\\nHowever, you can optimize this furthermore. Note that in calculating `dp[i]`, you are just referencing `dp[i - 2]` and `dp[i - 1]`. In other words, all you need is the two values (yesterday and the day before yesterday), and you can discard the old values in the dp table.\\n\\n![image](https://assets.leetcode.com/users/images/22c4bb3b-43f2-4e84-bba4-502cf7d6b461_1638381140.0612247.jpeg)\\n\\nLet `a` be the maximum at the day before yesterday, and let `b` the maximum at yesterday, today\\'s maximum is `max(a + nums[i], b)`. And for the next day, this becomes the maximum at yesterday, and maximum at the day before yesterday is now `a`. So you can write this formula.\\n\\n`a, b = b, max(a + nums[i], b)`\\n\\nThis indicates new `a` is replaced with `b`, and new `b` is replaced with `max(a + nums[i], b)`. By repeating this, you can calculate until the last day without storing all the values along the way. Finally, `b` at the end is what you want. So you can write the improved version.\\n\\n# [Optimization] DP with O(L) time and O(1) space\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        #edge case\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        #dp (less space)\\n        L = len(nums)\\n        a, b = nums[0], max(nums[0], nums[1])\\n        \\n        for i in range(2, L):\\n            a, b = b, max(a + nums[i], b)\\n        \\n        return b\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        #edge case\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        #dp\\n        L = len(nums)\\n        dp = [0 for _ in range(L)]\\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1])\\n        \\n        for i in range(2, L):\\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\\n        \\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        #edge case\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        #dp (less space)\\n        L = len(nums)\\n        a, b = nums[0], max(nums[0], nums[1])\\n        \\n        for i in range(2, L):\\n            a, b = b, max(a + nums[i], b)\\n        \\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216515,
                "title": "recursive-solution-and-it-s-conversion-to-dp",
                "content": "Hey guys, if you able to solve this question recursively, then maybe you can easily understand how it can be solved using DP.\\nLet\\'s take one example [ 3 , 1 , 2 , 9 , 3 ] , if you select any element, then you can\\'t select it\\'s adjacent, that means you need to skip one element and if skipping the current element, then you can again start selection from it\\'s adjacent. \\nLeft child : taking current + skipping next  \\nRight child : skipping current and again start selection from next element.\\n\\n                         fun([ 3, 1, 2 , 9, 3 ])\\n                        /                        \\\\\\n                3 + fun([2,9,3])            fun([1,2,9,3]) _______\\n                    /        \\\\                       /            \\\\\\n             2 + fun([3])  fun([9,3])       1+ fun([9,3])   fun([2,9,3])      \\n                   |          |                   |               /     \\\\\\n                   3       max(9,3)           max(9,3)   2+fun([3])    fun([9,3])\\n                                                               |           |\\n                                                               3        max(9,3)\\n    \\n```\\ndef rob(self, arr: List[int]) -> int:\\n        arrLength = len(arr)\\n        if arrLength == 0: return 0\\n        elif arrLength == 1: return arr[0]\\n        elif arrLength == 2: return max(arr[0], arr[1])\\n        else:\\n            return max(arr[0] + self.rob(arr[2:]), self.rob(arr[1:]))\\n```\\n\\nFrom the about flow, you can check \\nfun([2,9,3])  -> calculated 2 times   // 1 extra calculation \\nfun([9,3])     -> calculated 3 times   // 2 extra calculation\\nfun([3])        -> calculated 2 times   // 1 extra calculation\\nIn length of 5, we are calculating 4 times extra values.. isn\\'t that making solution worst. \\nNow, just simply add dictionary / array whatever you want to store values to avoid same calculation by fetching that stored value. \\n\\n\\tdef rob(self, arr: List[int]) -> int:\\n\\t\\tself.data = arr\\n\\t\\tself.totalElements = len(arr)\\n\\t\\tself.dp = [-1]*(self.dataLen+1)\\n\\t\\treturn self.recursive(0)\\n\\n    # Here we are passing index from where we need to start selection..\\n    def recursive(self , i):\\n        if self.dp[i] != -1:\\n            # Few consoles for better visualization.. \\n            print(i, self.dp[i], \"Already have answer :) \") \\n            return self.dp[i]\\n        # How many elements left \\n        t = self.totalElements - i\\n        if t == 0: self.dp[i]= 0\\n        elif t == 1: self.dp[i] = self.data[-1]\\n        elif t == 2: self.dp[i] = max(self.data[-1], self.data[-2])\\n        else: self.dp[i] = max(self.data[i] + self.recursive(i+2), self.recursive(i+1))\\n        # Few consoles for better visualization.. \\n        print(i, self.dp[i], \"calculation :( \")\\n        return self.dp[i]\\n\\n\\nAbove solution was top-down approach, we had broken down larger problem into smaller, but it can be solved by bottom-up approach as well. Let\\'s see how it can be.\\nAgain taking same example :  [ 3 , 1 , 2 , 9 , 3 ]\\nWe can start from last element  : 3\\nif we have only this element, then our answer = dp[4] =  3\\nfrom second last : [9, 3] => best / max => dp[3] = 9\\nfrom last third [2,9,3] , why not doing same thing we had done in top-down approach => either 2 + [3]   or [9, 3] \\nSo now, we already done calculation so far, dp[2] = max ( 2 + dp[4]  and dp[3] )  \\nfrom last fourth [1,2,9,3]  => dp[1] = max ( 1 + [9,3] , [2,9,3] ) = max ( 1 + dp[3] , dp[2] ) \\nand from first [3,1,2,9,3]  => dp[0] = max ( 3 + [2,9,3], [1,2,9,3] ) = max( 3 + dp[2], dp[1])\\nSo did you saw pattern dp[ i ] = max( arr[i] + dp[i+2], dp[i+1] )\\n\\n*One more easy way to understand this. *\\n\\ndp[i] is storing max sum from i -> n , but we don\\'t know at any i, arr[i] is contributing in max sum or not.\\nBut it is 100% sure that for any i, dp[i+2] definately didn\\'t included either arr[i] or arr [i+1] , since we dp[i+2] is sum from i+2 -> n. That\\'s how we got this relation ..\\ndp[ i ] = ( arr[i] + dp[i+2] ,  dp [i+1] )\\n\\n\\tdef rob(self, arr: List[int]) -> int:\\n\\t\\tn = len(arr)\\n        dp = [0]*(n+1)\\n        for i in range(n-1, -1, -1):\\n            if i+1 < n and arr[i] + dp[i+2] > dp[i+1]:  dp[i] = arr[i] + dp[i+2]\\n            else: dp[i] = max(dp[i+1], arr[i])\\n        return dp[0]\\n\\nOr same can be done in forward direction, either way we are doing same, not including adjacents , so it won\\'t affect answer .\\n\\n\\tdef rob(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dp = [0]*(n)\\n        for i in range(n):\\n            if i > 1 and arr[i] + dp[i-2] > dp[i-1]:   dp[i] = arr[i] + dp[i-2]\\n            else: dp[i] = max(dp[i-1], arr[i])\\n        return dp[n-1]\\n\\nTime : O(n)\\nSpace : O(n) \\n\\nWant some more optimisation :) \\nin a loop, we only need two values dp[i-1] and dp[i-2] to generate new value .. so we can optimize in terms of space.\\n\\n```\\ndef rob(self, arr: List[int]) -> int:\\n        incl = 0\\n        excl = 0\\n\\n        for i in arr:\\n            # Current max by excluding current element \\n            new_excl = max(excl, incl)\\n\\n            # Current max including current element\\n            incl = excl + i\\n            excl = new_excl\\n\\n        return max(excl , incl)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\ndef rob(self, arr: List[int]) -> int:\\n        arrLength = len(arr)\\n        if arrLength == 0: return 0\\n        elif arrLength == 1: return arr[0]\\n        elif arrLength == 2: return max(arr[0], arr[1])\\n        else:\\n            return max(arr[0] + self.rob(arr[2:]), self.rob(arr[1:]))\\n```\n```\\ndef rob(self, arr: List[int]) -> int:\\n        incl = 0\\n        excl = 0\\n\\n        for i in arr:\\n            # Current max by excluding current element \\n            new_excl = max(excl, incl)\\n\\n            # Current max including current element\\n            incl = excl + i\\n            excl = new_excl\\n\\n        return max(excl , incl)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 491274,
                "title": "javascript-solution",
                "content": "### The idea\\n1. The robber can either `rob` the current house, or `not rob` the current house.\\n2. If the robber choose to `rob` the current house, it means he has to skip the next house\\n3. If the robber choose `not rob` the current house, it means he can go to the next house and decide again.\\n``` javascript\\n/**\\n * Top-Down w/ Memoization \\n */\\nvar rob1 = function(nums) {\\n    let memo = [];\\n    \\n    let recur = function(i) {\\n        if (i >= nums.length) return 0;\\n        if (memo[i]!=null) return memo[i];\\n        \\n        memo[i] = Math.max(recur(i+2) + nums[i], recur(i+1))\\n        return memo[i];\\n    }\\n    return recur(0);\\n};\\n```\\n``` javascript\\n/**\\n * Bottom-Up\\n */\\nvar rob2 = function(nums) {\\n    let memo = [];\\n    memo[0] = 0;\\n    memo[1] = nums[0];\\n    \\n    for (let i=1;i<nums.length;i++) {\\n        memo[i+1] = Math.max(memo[i], memo[i-1] + nums[i]);\\n    }\\n    \\n    return memo[nums.length];   \\n}\\n```\\n``` javascript\\n/**\\n * Bottom-Up O(1) Space\\n */\\nvar rob = function(nums) {\\n    let prevMax = 0, curMax = 0;\\n    for (let n of nums) {\\n        let temp = curMax;\\n        curMax = Math.max(prevMax + n, curMax); // rob vs !rob\\n        prevMax = temp;\\n    }\\n    return Math.max(curMax, prevMax);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\n/**\\n * Top-Down w/ Memoization \\n */\\nvar rob1 = function(nums) {\\n    let memo = [];\\n    \\n    let recur = function(i) {\\n        if (i >= nums.length) return 0;\\n        if (memo[i]!=null) return memo[i];\\n        \\n        memo[i] = Math.max(recur(i+2) + nums[i], recur(i+1))\\n        return memo[i];\\n    }\\n    return recur(0);\\n};\\n```\n``` javascript\\n/**\\n * Bottom-Up\\n */\\nvar rob2 = function(nums) {\\n    let memo = [];\\n    memo[0] = 0;\\n    memo[1] = nums[0];\\n    \\n    for (let i=1;i<nums.length;i++) {\\n        memo[i+1] = Math.max(memo[i], memo[i-1] + nums[i]);\\n    }\\n    \\n    return memo[nums.length];   \\n}\\n```\n``` javascript\\n/**\\n * Bottom-Up O(1) Space\\n */\\nvar rob = function(nums) {\\n    let prevMax = 0, curMax = 0;\\n    for (let n of nums) {\\n        let temp = curMax;\\n        curMax = Math.max(prevMax + n, curMax); // rob vs !rob\\n        prevMax = temp;\\n    }\\n    return Math.max(curMax, prevMax);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 246618,
                "title": "",
                "content": "\\u8FD9\\u4E2A\\u95EE\\u9898\\u5927\\u6982\\u5C31\\u662F\\u8BF4\\uFF0C\\u4E00\\u4E2A\\u5C0F\\u5077\\u5077\\u4E1C\\u897F\\uFF0C\\u4F46\\u662F\\u5B83\\u4E0D\\u80FD\\u5077\\u76F8\\u90BB\\u7684\\u4E24\\u5BB6\\u4EBA\\u7684\\u4E1C\\u897F\\uFF0C\\u8FD9\\u6837\\u4F1A\\u88AB\\u6293\\u4F4F\\uFF0C\\u53EA\\u80FD\\u9694\\u7740\\u5077\\uFF0C\\u8BF7\\u95EE\\uFF0C\\u600E\\u4E48\\u5077\\u624D\\u80FD\\u5229\\u76CA\\u6700\\u5927\\u5316\\uFF0C\\u56E0\\u4E3A\\u6BCF\\u4E2A\\u623F\\u5B50\\u7684\\u4EF7\\u503C\\u4E0D\\u4E00\\u6837\\uFF0C\\u5047\\u5982\\u6709\\u4E24\\u5BB6\\uFF0C\\u4E00\\u5BB6\\u6709100\\u5757\\uFF0C\\u4E00\\u5BB6\\u6709\\u4E00\\u4E2A\\u4EBF\\uFF0C\\u4F60\\u9009\\u62E9\\u4E0D\\u597D\\uFF0C\\u9009\\u4E86100\\u7684\\u90A3\\u5BB6\\uFF0C\\u90A3\\u5C31\\u4E8F\\u5927\\u53D1\\u4E86\\uFF0C\\u4E00\\u4E2A\\u4EBF\\u7684\\u4E0B\\u6B21\\u518D\\u6765\\u5077\\u5427\\u3002\\n\\n\\u6309\\u7167\\u4E0A\\u9762\\u7684\\u601D\\u8DEF\\uFF0C\\u6211\\u4EEC\\u6765\\u601D\\u8003\\u8FD9\\u4E2A\\u95EE\\u9898\\uFF0C\\u6211\\u4EEC\\u4ECE\\u6700\\u540E\\u4E00\\u5BB6\\u5F00\\u59CB\\u8003\\u8651\\uFF0C\\u9009\\u62E9\\u5C31\\u4E24\\u4E2A\\uFF0C\\u5077\\u6216\\u8005\\u4E0D\\u5077\\uFF0C\\u5077\\u4E86\\u4F1A\\u600E\\u4E48\\u6837\\uFF0C\\u4E0D\\u5077\\u4F1A\\u600E\\u4E48\\u6837\\uFF0C\\u5176\\u5B9E\\u5173\\u7CFB\\u5F0F\\u8DDF\\u4E0A\\u9762\\u662F\\u5DEE\\u4E0D\\u591A\\u7684\\uFF0C\\u6211\\u5077\\u4E86\\u7684\\u8BDD\\uFF0C\\u6BD4\\u5982\\u5077\\u7684\\u662Fn\\uFF0C\\u90A3\\u4E48\\u4E0B\\u6B21\\u53EA\\u80FD\\u4ECEn-2\\u5F00\\u59CB\\u8003\\u8651\\u5B83\\u7684\\u6700\\u5927\\u4EF7\\u503C\\u65B9\\u6848\\u3002\\u4E0D\\u5077\\u7684\\u8BDD\\uFF0C\\u5C31\\u662F\\u8003\\u8651n-1\\u7684\\u6700\\u5927\\u4EF7\\u503C\\u65B9\\u6848\\u3002\\n\\n\\u6700\\u7B80\\u5355\\u7684\\u5B9E\\u73B0\\u5C31\\u662F\\u9012\\u5F52\\u6765\\u5B9E\\u73B0\\uFF0C\\u4E3B\\u8981\\u662F\\u8981\\u8003\\u8651\\u4E00\\u4E0B\\u51FD\\u6570\\u7684\\u51FA\\u53E3\\u6761\\u4EF6\\uFF0C\\u5373\\u5077\\u5230\\u7B2C\\u4E00\\u5BB6\\u4E86\\u662F\\u4EC0\\u4E48\\u6837\\uFF0C\\u4EE5\\u53CA\\u7B2C\\u4E00\\u5BB6\\u4E4B\\u524D\\u6CA1\\u6709\\u4EBA\\u5BB6\\u4E86\\u600E\\u4E48\\u529E\\u3002\\u4EE3\\u7801\\u5982\\u4E0B\\uFF1A\\n\\n\\n```java\\n//can not pass\\nclass Solution {\\n    public int rob(int[] nums) {\\n        return rob(nums,nums.length-1);\\n    }\\n    \\n    private int rob(int[] nums,int n){\\n        if(n < 0){\\n            return 0;\\n        }else if(n == 0){\\n            return nums[0];\\n        }else{\\n            int A = rob(nums,n-2) + nums[n];\\n            int B = rob(nums,n-1);\\n            return A > B ? A : B;\\n        }\\n    }\\n}\\n```\\n\\n\\u5F88\\u53EF\\u60DC\\uFF0C\\u867D\\u7136\\u903B\\u8F91\\u4E0A\\u6B63\\u786E\\uFF0C\\u4F46\\u662F\\u7531\\u4E8E\\u662F\\u9012\\u5F52\\uFF0C\\u5728\\u6570\\u636E\\u89C4\\u6A21\\u5927\\u4E00\\u70B9\\u4E4B\\u540E\\uFF0C\\u5C31\\u4E0D\\u884C\\u4E86\\uFF0C\\u56E0\\u4E3A\\u6211\\u4EEC\\u524D\\u9762\\u4E5F\\u8BF4\\u5230\\uFF0C\\u5B58\\u5728\\u5927\\u91CF\\u7684\\u91CD\\u53E0\\u5B50\\u95EE\\u9898\\uFF0C\\u95EE\\u9898\\u591A\\u4E00\\u4E2A\\u8F93\\u5165\\uFF0C\\u90A3\\u4E48\\u8BA1\\u7B97\\u7684\\u89C4\\u6A21\\u5C31\\u8981\\u4E58\\u4E0A2\\uFF0C\\u6240\\u4EE5\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u4E3A2^n\\u8FD9\\u4E2A\\u7EA7\\u522B\\u3002\\u6240\\u4EE5\\u6B64\\u65B9\\u6848\\u653E\\u5728leetcode\\u4E0A\\u4F1A\\u8D85\\u65F6\\uFF0C\\u4E0B\\u9762\\u5C31\\u662F\\u60F3\\u529E\\u6CD5\\u628A\\u4ED6\\u6539\\u6210\\u975E\\u9012\\u5F52\\u7684\\u7248\\u672C\\u3002\\n\\n\\u524D\\u9762\\u63D0\\u5230\\uFF0C\\u8BA1\\u7B97\\u51FA\\u6765\\u7684\\u5B50\\u95EE\\u9898\\u5B8C\\u5168\\u53EF\\u4EE5\\u5B58\\u5728\\u4E00\\u4E2A\\u5730\\u65B9\\uFF0C\\u4E0B\\u6B21\\u8981\\u7528\\u76F4\\u63A5\\u53D6\\u3002OK\\uFF0C\\u7528\\u975E\\u9012\\u5F52\\u7248\\u672C\\u7684\\u6570\\u7EC4\\u7248\\u672C\\u5B9E\\u73B0\\u662F\\uFF1A\\n\\n```java\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length <= 0){\\n            return 0;\\n        }\\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n        \\n        int[] tmp = new int[nums.length];\\n        tmp[0] = nums[0];\\n        tmp[1] = nums[0] > nums[1] ? nums[0] : nums[1];\\n        for(int i=2;i<nums.length;i++){\\n            int A = tmp[i-2] + nums[i];\\n            int B = tmp[i-1];\\n            int max = A > B ? A : B;\\n            tmp[i] = max;\\n        }\\n        return tmp[nums.length-1];\\n    }\\n}\\n```\\n\\n\\u4E3B\\u4F53\\u8FD8\\u662F\\u4E0A\\u9762\\u63D0\\u5230\\u7684\\u90A3\\u4E2A\\u5173\\u7CFB\\uFF0C\\u53EA\\u662F\\u6211\\u4EEC\\u5C06\\u5B50\\u95EE\\u9898\\u7684\\u7ED3\\u679C\\u653E\\u5728\\u4E86\\u4E00\\u4E2A\\u4E34\\u65F6\\u6570\\u7EC4\\u4E2D\\u3002\\u4E34\\u65F6\\u6570\\u7EC4\\u4E2D\\u5B58\\u653E\\u7684\\u90FD\\u662F\\u5B50\\u95EE\\u9898\\u7684\\u6700\\u4F18\\u89E3\\u3002\\u6BD4\\u5982tmp[1]\\u91CC\\u9762\\u5B58\\u653E\\u7684\\u5C31\\u662F\\u524D\\u4E24\\u4E2A\\u5143\\u7D20\\u4E2D\\u6700\\u5927\\u503C\\uFF0C\\u5373\\u6700\\u4F18\\u89E3\\u3002\\u5F53\\u8BA1\\u7B97\\u524D\\u4E09\\u4E2A\\u6570\\u4E2D\\u6700\\u4F18\\u89E3\\u7684\\u65F6\\u5019\\uFF0C\\u6211\\u53EA\\u8981\\u505A\\u4E00\\u4E2A\\u9009\\u62E9\\uFF0C\\u5373\\u8981\\u4E0D\\u8981\\u9009\\u62E9nums[2]\\u8FD9\\u4E2A\\u5143\\u7D20\\uFF0C\\u9009\\u62E9\\u7684\\u8BDD\\uFF0C\\u90A3\\u4E48\\u6211\\u5C31\\u4ECEtmp[2-2]\\u4E2D\\u5F97\\u5230\\u6700\\u4F18\\u89E3\\uFF0C\\u52A0\\u8D77\\u6765\\u5C31\\u662F\\u5F53\\u524D\\u6700\\u4F18\\u89E3\\uFF0C\\u4E0D\\u9009\\u62E9\\u7684\\u8BDD\\uFF0C\\u5C31\\u4ECEtmp[2-1]\\u4E2D\\u9009\\u62E9\\u6700\\u4F18\\u89E3\\u3002\\u4F9D\\u6B21\\u4E0B\\u53BB\\uFF0Ctmp\\u4E2D\\u6700\\u540E\\u4E00\\u4E2A\\u503C\\u5C31\\u662F\\u6574\\u4E2A\\u5E8F\\u5217\\u4E2D\\u7EC4\\u5408\\u7684\\u6700\\u4F18\\u89E3\\u4E86\\u3002\\n\\n\\u8FD9\\u91CC\\u6CE8\\u610F\\u4E00\\u4E0B\\uFF0C\\u8FD9\\u91CC\\u5176\\u5B9E\\u662F\\u8BB0\\u5FC6\\u5316\\u641C\\u7D22\\u7684\\u601D\\u60F3\\u6765\\u5B9E\\u73B0\\u7684\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u6CE8\\u610F\\u5230\\uFF0C\\u5176\\u5B9E\\u662F\\u81EA\\u9876\\u5411\\u4E0B\\u6765\\u770B\\u7684\\uFF0C\\u4ECE\\u7B2C\\u4E00\\u4E2A\\u6570\\u5B57\\u6765\\u4E00\\u76F4\\u63A8\\u5230\\u6700\\u540E\\u3002\\u7136\\u800C\\u52A8\\u6001\\u89C4\\u5212\\u7684\\u601D\\u60F3\\u662F\\u4ECE\\u5E95\\u5411\\u4E0A\\u7684\\uFF0C\\u53C2\\u89C1\\u7B2C\\u4E00\\u4E2A\\u9012\\u5F52\\u7248\\u672C\\u7684\\u5B9E\\u73B0\\u3002\\u6211\\u4EEC\\u5148\\u8003\\u8651\\u7684\\u662F\\u6700\\u7EC8\\u7684n\\uFF0C\\u800C\\u4E0D\\u662F\\u8003\\u8651\\u4ECE0\\u5F00\\u59CB\\u3002\\u6240\\u4EE5\\u5728\\u8BBE\\u8BA1\\u601D\\u60F3\\u4E0A\\u662F\\u6709\\u6240\\u533A\\u522B\\u7684\\uFF0C\\u4F46\\u662F\\u53C8\\u662F\\u975E\\u5E38\\u7C7B\\u4F3C\\uFF0C\\u6709\\u7684\\u4EBA\\u5C06\\u4ED6\\u4EEC\\u5F52\\u4F4D\\u4E00\\u7C7B\\uFF0C\\u6211\\u60F3\\uFF0C\\u5B83\\u4EEC\\u5728\\u5927\\u591A\\u6570\\u573A\\u666F\\u4E0B\\u53EF\\u4EE5\\u4E92\\u6362\\u7684\\u5316\\uFF0C\\u53EF\\u4EE5\\u8BA4\\u4E3A\\u90FD\\u662F\\u5E7F\\u4E49\\u4E0A\\u7684DP\\u7B97\\u6CD5\\u5427\\uFF0C\\u56E0\\u4E3ADP\\u6BD5\\u7ADF\\u53EA\\u662F\\u4E00\\u79CD\\u601D\\u60F3\\uFF0C\\u6B63\\u8FC7\\u6765\\u5B9E\\u73B0\\u53CD\\u8FC7\\u6765\\u5B9E\\u73B0\\u4E5F\\u672A\\u5C1D\\u4E0D\\u53EF\\u3002\\n\\n\\u6211\\u4EEC\\u7528\\u4E00\\u4E2A\\u6570\\u7EC4\\u6765\\u5B58\\u653E\\u5B50\\u95EE\\u9898\\u7684\\u6700\\u4F18\\u89E3\\uFF0C\\u5927\\u5927\\u964D\\u4F4E\\u4E86\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\uFF0Cleetcode\\u4E0A\\u4E5F\\u987A\\u5229\\u901A\\u8FC7\\u3002\\u5176\\u5B9E\\u8FD9\\u4E2A\\u662F\\u4E00\\u79CD\\u8BB0\\u5FC6\\u5316\\u641C\\u7D22\\u7684\\u601D\\u60F3\\uFF0C\\u4E0A\\u9762\\u8FD9\\u4E2A\\u7528\\u4E86\\u4E00\\u4E2A\\u6570\\u7EC4\\uFF0C\\u5176\\u5B9E\\u5B8C\\u5168\\u6CA1\\u6709\\u5FC5\\u8981\\u7528\\u6570\\u7EC4\\uFF0C\\u7528\\u4E24\\u4E2A\\u53D8\\u91CF\\u5373\\u53EF\\uFF1A\\n\\n\\n```java\\n//the best solution  think\\n//\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u548C\\u7A7A\\u95F4\\u590D\\u6742\\u5EA6\\u8868\\u73B0\\u6700\\u597D\\u7684\\u4E00\\u79CD\\u65B9\\u5F0F\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length <= 0){\\n            return 0;\\n        }\\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n        \\n        int a = nums[0];\\n        int b = nums[0] > nums[1] ? nums[0] : nums[1];\\n        for(int i=2;i<nums.length;i++){\\n            int A = a + nums[i];\\n            int B = b;\\n            int max = A > B ? A : B;\\n            a = b;\\n            b = max;\\n        }\\n        return b;\\n    }\\n}\\n```\\n\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u4E0D\\u53D8\\uFF0C\\u7A7A\\u95F4\\u4E0A\\u5360\\u7528\\u7684\\u66F4\\u5C11\\u4E86\\u3002\\u4E0B\\u9762\\u6211\\u4EEC\\u8FD8\\u662F\\u4ECE\\u5E95\\u5411\\u4E0A\\u7684\\u601D\\u60F3\\u6765\\u89E3\\u51B3\\u4E00\\u4E0B\\u8FD9\\u4E2A\\u95EE\\u9898\\u5427\\u3002\\u6240\\u4EE5\\u6211\\u4EEC\\u8FD8\\u662F\\u4ECE\\u6700\\u540E\\u4E00\\u4E2A\\u5143\\u7D20\\u5F00\\u59CB\\u601D\\u8003\\uFF0C\\u4ECE\\u540E\\u5F80\\u524D\\u627E\\uFF0C\\u4E00\\u76F4\\u627E\\u5230\\u7B2C\\u4E00\\u4E2A\\u7ED3\\u675F\\u3002\\n\\n```java\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(n <= 0){\\n            return 0;\\n        }\\n        \\n        if(n == 1){\\n            return nums[0];\\n        }\\n        \\n        int[] tmp = new int[n];\\n        tmp[n-1] = nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=i;j<n;j++){\\n                tmp[i] = Math.max(tmp[i],nums[j] + (j+2<n?tmp[j+2]:0));\\n            }\\n        }\\n        return tmp[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n//can not pass\\nclass Solution {\\n    public int rob(int[] nums) {\\n        return rob(nums,nums.length-1);\\n    }\\n    \\n    private int rob(int[] nums,int n){\\n        if(n < 0){\\n            return 0;\\n        }else if(n == 0){\\n            return nums[0];\\n        }else{\\n            int A = rob(nums,n-2) + nums[n];\\n            int B = rob(nums,n-1);\\n            return A > B ? A : B;\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length <= 0){\\n            return 0;\\n        }\\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n        \\n        int[] tmp = new int[nums.length];\\n        tmp[0] = nums[0];\\n        tmp[1] = nums[0] > nums[1] ? nums[0] : nums[1];\\n        for(int i=2;i<nums.length;i++){\\n            int A = tmp[i-2] + nums[i];\\n            int B = tmp[i-1];\\n            int max = A > B ? A : B;\\n            tmp[i] = max;\\n        }\\n        return tmp[nums.length-1];\\n    }\\n}\\n```\n```java\\n//the best solution  think\\n//\\u65F6\\u95F4\\u590D\\u6742\\u5EA6\\u548C\\u7A7A\\u95F4\\u590D\\u6742\\u5EA6\\u8868\\u73B0\\u6700\\u597D\\u7684\\u4E00\\u79CD\\u65B9\\u5F0F\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length <= 0){\\n            return 0;\\n        }\\n        if(nums.length == 1){\\n            return nums[0];\\n        }\\n        \\n        int a = nums[0];\\n        int b = nums[0] > nums[1] ? nums[0] : nums[1];\\n        for(int i=2;i<nums.length;i++){\\n            int A = a + nums[i];\\n            int B = b;\\n            int max = A > B ? A : B;\\n            a = b;\\n            b = max;\\n        }\\n        return b;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n = nums.length;\\n        if(n <= 0){\\n            return 0;\\n        }\\n        \\n        if(n == 1){\\n            return nums[0];\\n        }\\n        \\n        int[] tmp = new int[n];\\n        tmp[n-1] = nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            for(int j=i;j<n;j++){\\n                tmp[i] = Math.max(tmp[i],nums[j] + (j+2<n?tmp[j+2]:0));\\n            }\\n        }\\n        return tmp[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55676,
                "title": "java-4-liner-tc-o-n-sc-o-1",
                "content": "Assigning value to 'prev' in same line while calculating current maximum.\\n(prev(H1), last(H2), curr(H3), House4) -> (House1, prev(H2), last(H3), curr(H4))\\n```\\npublic int rob(int[] nums) {\\n     int prev=0, last=0;\\n     for (int curr : nums)\\n         last = Math.max(prev+curr, prev=last);\\n     return last;\\n}",
                "solutionTags": [],
                "code": "Assigning value to 'prev' in same line while calculating current maximum.\\n(prev(H1), last(H2), curr(H3), House4) -> (House1, prev(H2), last(H3), curr(H4))\\n```\\npublic int rob(int[] nums) {\\n     int prev=0, last=0;\\n     for (int curr : nums)\\n         last = Math.max(prev+curr, prev=last);\\n     return last;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2909648,
                "title": "easy-to-understand-linear-complexity-no-dp-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n         /*\\n       2 1 1 2 \\n       take 2 than skip 1 , 1 again take 2 -->  answer -> 4\\n        */\\n\\n        int evenPos_Sum=0 , oddPos_Sum=0 , max_sum=0; \\n       \\n        for(int i=0;i<nums.size();i++){\\n            //if at even index position -> 0,2,4...\\n            if(!(i&1)){\\n          evenPos_Sum+=nums[i];\\n           evenPos_Sum = max(evenPos_Sum,oddPos_Sum);\\n            }\\n            //if at odd index position -> 1,3,5...\\n            if((i&1)){\\n          oddPos_Sum+=nums[i];\\n          oddPos_Sum = max(evenPos_Sum,oddPos_Sum);\\n            }\\n}\\n   \\n        max_sum = max(evenPos_Sum,oddPos_Sum);\\n        return max_sum;\\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n         /*\\n       2 1 1 2 \\n       take 2 than skip 1 , 1 again take 2 -->  answer -> 4\\n        */\\n\\n        int evenPos_Sum=0 , oddPos_Sum=0 , max_sum=0; \\n       \\n        for(int i=0;i<nums.size();i++){\\n            //if at even index position -> 0,2,4...\\n            if(!(i&1)){\\n          evenPos_Sum+=nums[i];\\n           evenPos_Sum = max(evenPos_Sum,oddPos_Sum);\\n            }\\n            //if at odd index position -> 1,3,5...\\n            if((i&1)){\\n          oddPos_Sum+=nums[i];\\n          oddPos_Sum = max(evenPos_Sum,oddPos_Sum);\\n            }\\n}\\n   \\n        max_sum = max(evenPos_Sum,oddPos_Sum);\\n        return max_sum;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2818729,
                "title": "python3-four-lines-w-explanation-faster-than-96-97-dynamic-programming",
                "content": "# Please upvote if you find this helpful! :)\\n\\n# Intuition\\n- At every house we will have two options: rob or skip\\n- Because we cannot rob a house that is next door to another, and because all values will be non-negative, we will always leave either one or two houses unrobbed between robbed houses.\\n- Given the conditions, it will never make sense to skip three or more houses in a row since we could rob houses in-between.\\n\\n# Approach\\n1. `bag` is the amount stolen so far, starting from zero, with two options for having skipped the previous house or potentially robbed the previous house\\n   a. `bag[0]` is the amount we\\'ll have if we have skipped the previous house\\n   b. `bag[1]` is the max of skipping vs robbing the previous house\\n   c. If we choose to skip twice in a row, `bag[0]` and `bag[1]` will be equal, so it will always be best to rob the following house\\n2. During each iteration:\\n   a. Pull the next value from `nums` and assign it to `house`\\n   b. Add `bag[0] + house` and compare it to `bag[1]`\\n   c. Simultaneously, move `bag[1]` to `bag[0]` and update `bag[1]` to the max of the previous step\\n3. At the end of the iterations, return `bag[1]` as that is the max possible haul of stolen goods\\n   \\n# Example\\nstart:\\n`nums = [2, 7, 9, 3, 1]; bag = (0, 0)`\\n\\niterations:\\n- `house = 2; bag = (0, 0)` -> `bag = (0, 2)`\\n  - `bag[1]` moves to `bag[0]`\\n  - `bag[1]` becomes 2 because 0 + 2 > 0\\n- `house = 7; bag = (0, 2)` -> `bag = (2, 7)`\\n  - `bag[1]` moves to `bag[0]`\\n  - `bag[1]` becomes 7 because 0 + 7 > 2\\n- `house = 9; bag = (2, 7)` -> `bag = (7, 11)`\\n  - `bag[1]` moves to `bag[0]`\\n  - `bag[1]` becomes 11 because 2 + 9 > 7\\n- `house = 3; bag = (7, 11)` -> `bag = (11, 11)`\\n   - `bag[1]` moves to `bag[0]`\\n   - `bag[1]` stays at 11 because 7 + 3 < 11\\n- `house = 1; bag = (11, 11)` -> `bag = (11, 12)`\\n   - `bag[1]` moves to `bag[0]`\\n   - `bag[1]` becomes 12 because 11 + 1 > 11\\n\\nend:\\n`return bag[1]` -> 12\\n\\nNote: It could be looked at as if, with each iteration, we are appending the new value and chopping off every element but the last two.\\n\\n\\nExecution time: 30 ms (faster than 96.97%)\\nMemory usage: 13.9 MB (smaller than 19.80%)\\nTime complexity: O(n)\\nSpace complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        bag = (0, 0)\\n\\n        for house in nums:\\n            bag = (bag[1], max(bag[0] + house, bag[1]))\\n\\n        return bag[1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        bag = (0, 0)\\n\\n        for house in nums:\\n            bag = (bag[1], max(bag[0] + house, bag[1]))\\n\\n        return bag[1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2180198,
                "title": "java-dp-in-depth-explanation",
                "content": "This problem is an iconic DP problem so that means we solve the main problem by solving several sub problems first, and use the result of sub problems to handle our main problem. \\n  \\n  To solve this DP problem, we could use an equation: `maxSum[n] = Math.max(maxSum[i - 1], maxSum[i - 2] + nums[i] ) `. How do we come up with such a formula? Let\\'s look the example below.\\n  \\n  **Step 1.** When we came to the `idx 0` house, what\\'s the max profit we can rob? The answer is 7 because the only house we can rob is `0`th house. Hence, we rob the `0`th house. The max Sum at `idx 0` now is 7. \\n  `nums      = [7, 10, 12, 7, 9, 14]`\\n  `maxSum = [7]`  \\n  \\n   **Step 2.**  When we came to the `idx 1` house, what\\'s the max profit we can rob? We have two options now, right? We either rob `0`th house or `1` th house. 10 > 7 so we rob `idx 1` house. Therefore, maxSum[1] = Math.max(10, 7) = 10\\n  `nums      = [7, 10, 12, 7, 9, 14]`\\n  `maxSum = [7, 10]`  \\n  \\n   **Step 3.** When we came to the `idx 2` house, what\\'s the max profit we can rob? We either rob both (`idx 0` house and `idx 2` house) or (`idx 1` house), right? 7 + 12 > 10. Therefore, maxSum[2] = Math.max(7+12, 10) = 19\\n    `nums      = [7, 10, 12, 7, 9, 14]`\\n    `maxSum = [7, 10, 19]`\\n\\t\\n\\t\\n**Step 4.** When we came to the `idx 3` house, what\\'s the max profit we can rob? Now we can start applying the concept of DP. At `idx 2` house, the max profit we can have is 19. Now we either keep this max profit `19` or we rob `idx 3` house. Therefore, maxSum[3] = Math.max(19, 10 + 7) = 19. Do you get the idea at this point now? If not, let\\'s keep moving forward.\\n\\t`nums      = [7, 10, 12, 7, 9, 14]`\\n    `maxSum = [7, 10, 19, 19]` \\n\\t\\n\\t\\n**Step 5.** When we came to the `idx 4` house, what\\'s the max profit we can rob? At `idx 3` house, the max profit we can have is 19. Now we either keep this max profit `19`, or we can rob `idx 4` house. Therefore, maxSum[4] = Math.max(19, 19 + 9) = 28.\\n\\t`nums      = [7, 10, 12, 7, 9, 14]`\\n    `maxSum = [7, 10, 19, 19, 28]` \\n\\t\\n**Step 6.** When we came to the `idx 5` house, what\\'s the max profit we can rob? maxSum[4] = Math.max(28, 19 + 14) = 33.\\n    `nums      = [7, 10, 12, 7, 9, 14]`\\n    `maxSum = [7, 10, 19, 19, 28, 33]` \\n\\nI hope my explanation is helpful for you guys to ace the coding interview and become a professional robber **: )**\\n\\t\\nBelow is my Solution in Java:\\n\\t\\n```\\nclass Solution \\n{\\n    public int rob(int[] nums) \\n    {\\n        // O(n) time | O(n) space\\n        if(nums.length == 0)    return 0;\\n        if(nums.length == 1)    return nums[0];\\n        \\n        int[] maxSum = nums.clone();\\n        maxSum[1] = Math.max(nums[0], nums[1]);\\n        \\n        for(int i = 2; i < nums.length; i++)\\n            maxSum[i] = Math.max(maxSum[i-1], maxSum[i-2] + nums[i]);\\n        \\n        return maxSum[nums.length-1];\\n    }\\n}\\n```\\n\\n===================================================\\nSince the solution above has O(n) time and O(n) space, and now your interviwer ask you that \"Can you do better\"? Of course, we can. We even know how to rob the house w/ algorithms. To decrease the space complexity, we simply get rid of int[ ] maxSum. We use two variables to track the max profit. \\n```\\nclass Solution \\n{\\n    public int rob(int[] nums) \\n    {\\n        // O(n) time || O(1) space\\n        if(nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n\\n        int second = nums[0];\\n        int first = Math.max(nums[0], nums[1]);\\n\\n        for(int i = 2; i < nums.length; i++)\\n        {\\n            int cur = Math.max(first, second + nums[i]);\\n            second = first;\\n            first = cur;\\n        }\\n        return first;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int rob(int[] nums) \\n    {\\n        // O(n) time | O(n) space\\n        if(nums.length == 0)    return 0;\\n        if(nums.length == 1)    return nums[0];\\n        \\n        int[] maxSum = nums.clone();\\n        maxSum[1] = Math.max(nums[0], nums[1]);\\n        \\n        for(int i = 2; i < nums.length; i++)\\n            maxSum[i] = Math.max(maxSum[i-1], maxSum[i-2] + nums[i]);\\n        \\n        return maxSum[nums.length-1];\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public int rob(int[] nums) \\n    {\\n        // O(n) time || O(1) space\\n        if(nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n\\n        int second = nums[0];\\n        int first = Math.max(nums[0], nums[1]);\\n\\n        for(int i = 2; i < nums.length; i++)\\n        {\\n            int cur = Math.max(first, second + nums[i]);\\n            second = first;\\n            first = cur;\\n        }\\n        return first;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248441,
                "title": "c-recursion-memoization-dp-three-approaches",
                "content": "BRUTE FORCE\\n```\\nclass Solution {\\npublic:\\n    int robHelper(vector<int>&nums, int i){\\n        if(i>=nums.size()){\\n            return 0;\\n        }\\n        int a = robHelper(nums, i+2) + nums[i];\\n        int b = robHelper(nums, i+1);\\n        return max(a,b);\\n    }\\n    int rob(vector<int>& nums){\\n        return robHelper(nums,0);\\n    }\\n};\\n```\\nThis solution will show TLE\\n\\nMEMOIZATION\\n\\n```\\nclass Solution {\\npublic:\\n    int robHelper(vector<int>&nums, int i, int*dp){\\n        int n = nums.size();\\n        if(i>=n){\\n            return 0;\\n        }\\n        \\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        \\n        int a = robHelper(nums, i+2,dp) + nums[i];\\n        int b = robHelper(nums, i+1,dp);\\n        int ans = max(a,b);\\n        dp[i] = ans;\\n        return ans;\\n    }\\n    int rob(vector<int>& nums){\\n        int n = nums.size();\\n        int *dp = new int[n+1];\\n        for(int i=0; i<=n; i++){\\n            dp[i] = -1;\\n        }\\n        return robHelper(nums,0,dp);\\n    }\\n};\\n```\\n\\nDYNAMIC PROGRAMMING\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums){\\n        int *dp = new int[nums.size()];\\n        int n = nums.size();\\n        if(n==0) {\\n            return 0;\\n        }\\n        if(n==1){\\n         return nums[0];   \\n        }\\n        if(n==2){\\n          return max(nums[1],nums[0]);  \\n        }\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for(int i = 2; i <nums.size(); i++){\\n            dp[i] = max(nums[i] + dp[i-2], dp[i-1]);\\n        }\\n        return dp[nums.size()-1];\\n        delete[] dp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int robHelper(vector<int>&nums, int i){\\n        if(i>=nums.size()){\\n            return 0;\\n        }\\n        int a = robHelper(nums, i+2) + nums[i];\\n        int b = robHelper(nums, i+1);\\n        return max(a,b);\\n    }\\n    int rob(vector<int>& nums){\\n        return robHelper(nums,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int robHelper(vector<int>&nums, int i, int*dp){\\n        int n = nums.size();\\n        if(i>=n){\\n            return 0;\\n        }\\n        \\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        \\n        int a = robHelper(nums, i+2,dp) + nums[i];\\n        int b = robHelper(nums, i+1,dp);\\n        int ans = max(a,b);\\n        dp[i] = ans;\\n        return ans;\\n    }\\n    int rob(vector<int>& nums){\\n        int n = nums.size();\\n        int *dp = new int[n+1];\\n        for(int i=0; i<=n; i++){\\n            dp[i] = -1;\\n        }\\n        return robHelper(nums,0,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums){\\n        int *dp = new int[nums.size()];\\n        int n = nums.size();\\n        if(n==0) {\\n            return 0;\\n        }\\n        if(n==1){\\n         return nums[0];   \\n        }\\n        if(n==2){\\n          return max(nums[1],nums[0]);  \\n        }\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for(int i = 2; i <nums.size(); i++){\\n            dp[i] = max(nums[i] + dp[i-2], dp[i-1]);\\n        }\\n        return dp[nums.size()-1];\\n        delete[] dp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312003,
                "title": "c-simple-solution-with-o-1-memory",
                "content": "``` csharp\\n  public int Rob(int[] nums) {\\n        if(nums == null || nums.Length == 0)\\n        {\\n            return 0;\\n        }\\n        \\n        int firstPrevious = 0;\\n        int secondPrevious = 0;\\n        int current = 0;\\n                        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            secondPrevious = firstPrevious;\\n            firstPrevious = current;\\n            current = Math.Max(firstPrevious, secondPrevious + nums[i]);\\n        }\\n        \\n        return current;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` csharp\\n  public int Rob(int[] nums) {\\n        if(nums == null || nums.Length == 0)\\n        {\\n            return 0;\\n        }\\n        \\n        int firstPrevious = 0;\\n        int secondPrevious = 0;\\n        int current = 0;\\n                        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            secondPrevious = firstPrevious;\\n            firstPrevious = current;\\n            current = Math.Max(firstPrevious, secondPrevious + nums[i]);\\n        }\\n        \\n        return current;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 299751,
                "title": "c-straightforward-easy",
                "content": "```\\npublic class Solution {\\n    public int Rob(int[] nums) {\\n        for (int i = 2; i < nums.Length; i++) {\\n            if (i > 2)\\n                nums[i] += Math.Max(nums[i - 2], nums[i - 3]);\\n            else\\n                nums[i] += nums[i - 2];\\n        }\\n        return nums.Length > 1 ? Math.Max(nums[nums.Length - 1], nums[nums.Length - 2]) : nums.Sum();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int Rob(int[] nums) {\\n        for (int i = 2; i < nums.Length; i++) {\\n            if (i > 2)\\n                nums[i] += Math.Max(nums[i - 2], nums[i - 3]);\\n            else\\n                nums[i] += nums[i - 2];\\n        }\\n        return nums.Length > 1 ? Math.Max(nums[nums.Length - 1], nums[nums.Length - 2]) : nums.Sum();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55950,
                "title": "share-my-2ms-c-dp-solution-with-o-1-space",
                "content": "f(j) indicates the robber has made a dicison for jth house for the max money, the recursion can be f(j) = max(f(j-1), f(j-2)+nums[j]); it can be implemented by iteration with O(1) space.\\n\\n    #define max(x,y)  (((x)>(y))?(x):(y))\\n    int rob(int* nums, int numsSize) {\\n        int x0 = 0, x1 = 0, x2 = 0;\\n        \\n        //f(j) = max(f(j-1),f(j-2)+nums[i])\\n        for(int i = 0; i < numsSize; i++)\\n        {\\n            x2 = max(x0+nums[i],x1);\\n            x0 = x1;\\n            x1 = x2;\\n        }\\n        \\n        return x2;\\n    }",
                "solutionTags": [],
                "code": "f(j) indicates the robber has made a dicison for jth house for the max money, the recursion can be f(j) = max(f(j-1), f(j-2)+nums[j]); it can be implemented by iteration with O(1) space.\\n\\n    #define max(x,y)  (((x)>(y))?(x):(y))\\n    int rob(int* nums, int numsSize) {\\n        int x0 = 0, x1 = 0, x2 = 0;\\n        \\n        //f(j) = max(f(j-1),f(j-2)+nums[i])\\n        for(int i = 0; i < numsSize; i++)\\n        {\\n            x2 = max(x0+nums[i],x1);\\n            x0 = x1;\\n            x1 = x2;\\n        }\\n        \\n        return x2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 55947,
                "title": "java-dp-solution-without-extra-space",
                "content": "    //f(i) : harvest from house 0 to i\\n    //f(i) = max{f(i-2), f(i-3)} + a[i], i>=3\\n    \\n    //f(2) = a[0] + a[2],     i= 2\\n    //f(1) = a[1],            i= 1\\n    //f(0) = a[0],            i= 0\\n\\n    public class Solution {\\n        public int rob(int[] nums) {\\n            if(nums == null || nums.length ==0) return 0;\\n            \\n            int len = nums.length;\\n            if(len == 1) return nums[0];\\n            if(len == 2) return Math.max(nums[0],nums[1]);\\n            if(len == 3) return Math.max(nums[0]+nums[2], nums[1]);\\n            \\n            nums[2] = nums[0]+nums[2];//f(2) = a[0] + a[2]\\n            \\n            for(int i=3; i<len; i++){\\n                nums[i] = Math.max(nums[i-3], nums[i-2])+nums[i];\\n            }\\n            \\n            return Math.max(nums[len-1], nums[len-2]);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int rob(int[] nums) {\\n            if(nums == null || nums.length ==0) return 0;\\n            \\n            int len = nums.length;\\n            if(len == 1) return nums[0];\\n            if(len == 2) return Math.max(nums[0],nums[1]);\\n            if(len == 3) return Math.max(nums[0]+nums[2], nums[1]);\\n            \\n            nums[2] = nums[0]+nums[2];//f(2) = a[0] + a[2]\\n            \\n            for(int i=3; i<len; i++){\\n                nums[i] = Math.max(nums[i-3], nums[i-2])+nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2909432,
                "title": "python-o-1-space-optimized-dynamic-programming-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we cannot rob adjacent homes, we need to figure out the most optimal robbing path to take. Note, this does not always equate to every odd index house or every even index. To solve this problem, we can utilize dynamic programming to ensure we always have the most optimal robbing path until a given house. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCommon way to solve this problem is to create a dp array to keep track of the optimal robbing path. For our optimal profit, we can either include this house in the robbing or not.\\n\\nA simple ex: [2,1,1,2]\\nDP Array:    [2,2,3,4] -> *(dp[i] = max profit robbing from 0 to house[i])*\\n   \\n- At house 1, the most optimal profit is 2 from robbing house 1\\n- At house 2, the most optimal profit is either robbing only house 2 or only house 1, hence, optimal is 2. i.e. we don\\'t rob house 2 since there is a more optimal robbing path.\\n- At house 3, the most optimal profit is either robbing house 1 and 3 = 3 or only house 2 = 1, hence we get 3.\\n- At house 4, the most optimal profit is if we include this house in the robbing but we also rob house 1.\\n\\nFrom this we can determine that if we have a DP array, we can set \\n**dp[i] = max of ( dp[i-1] ) or ( nums[i] + dp[i-2] ) **\\n(Skip current house in robbing) or (Include current house in robbing + 2 houses back so not adjacent)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) optimized to O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nCommon Dynamic Programming Solution with O(N).\\n*DP Arr is 1-indexed for ease of computation*\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Input:  [  2,1,1,2]\\n        DP Arr: [0,2,2,3,4]\\n        \"\"\"\\n        if len(nums) <= 2:\\n            return max(nums)\\n\\n        opt = [0] * (len(nums)+1)\\n        opt[1] = nums[0]\\n        for n in range(1,len(nums)):\\n            # Max of previous optimal (skip this house) or 2 houses back and rob this house\\n            opt[n+1] = max(opt[n], nums[n] + opt[n-1])\\n\\n        return opt[-1]\\n```\\nOptimized to constant space since we only need to store the last 2 most optimal profits. \\nWe use temp var since oneBack value is changed. \\n*See comments for alternative way to not use temp var in python.*\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        twoBack = 0\\n        oneBack = nums[0]\\n        for n in range(1,len(nums)):\\n            temp = oneBack\\n            # Choice between include current house in robbing or not\\n            oneBack = max(oneBack, nums[n] + twoBack)\\n            twoBack = temp\\n\\n        return oneBack\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Input:  [  2,1,1,2]\\n        DP Arr: [0,2,2,3,4]\\n        \"\"\"\\n        if len(nums) <= 2:\\n            return max(nums)\\n\\n        opt = [0] * (len(nums)+1)\\n        opt[1] = nums[0]\\n        for n in range(1,len(nums)):\\n            # Max of previous optimal (skip this house) or 2 houses back and rob this house\\n            opt[n+1] = max(opt[n], nums[n] + opt[n-1])\\n\\n        return opt[-1]\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        twoBack = 0\\n        oneBack = nums[0]\\n        for n in range(1,len(nums)):\\n            temp = oneBack\\n            # Choice between include current house in robbing or not\\n            oneBack = max(oneBack, nums[n] + twoBack)\\n            twoBack = temp\\n\\n        return oneBack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605804,
                "title": "c-python-java-simple-and-clean-dynamic-programming-solution",
                "content": "**Idea:**\\nFirst, we have some edge cases.\\nThen, we use simple DP: for each house, we can\\'t rob two adjacent houses. So either we rob the previous one - `dp[i-1]`, or the two before and the current one - `nums[i]+dp[i-2]`.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(n)\\n\\n**C++:**\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        // edge cases:\\n        if (nums.size() == 0) return 0;\\n        if (nums.size() == 1) return nums[0];\\n        if (nums.size() == 2) return max(nums[0], nums[1]);\\n        \\n        // dynamic programming - decide each problem by its sub-problems:\\n        int dp[nums.size()];\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\\n**Python:**\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        # edge cases:\\n        if len(nums) == 0: return 0\\n        if len(nums) == 1: return nums[0]\\n        if len(nums) == 2: return max(nums)\\n        \\n        # dynamic programming - decide each problem by its sub-problems:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2])\\n        \\n        return dp[-1]\\n```\\n**Java:**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        // edge cases:\\n        if (nums.length == 0) return 0;\\n        if (nums.length == 1) return nums[0];\\n        if (nums.length == 2) return Math.max(nums[0], nums[1]);\\n        \\n        // dynamic programming - decide each problem by its sub-problems:\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        dp[1] = Math.max(nums[0], nums[1]);\\n        for (int i=2; i<nums.length; i++)\\n            dp[i] = Math.max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.length-1];\\n    }\\n}\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        // edge cases:\\n        if (nums.size() == 0) return 0;\\n        if (nums.size() == 1) return nums[0];\\n        if (nums.size() == 2) return max(nums[0], nums[1]);\\n        \\n        // dynamic programming - decide each problem by its sub-problems:\\n        int dp[nums.size()];\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        # edge cases:\\n        if len(nums) == 0: return 0\\n        if len(nums) == 1: return nums[0]\\n        if len(nums) == 2: return max(nums)\\n        \\n        # dynamic programming - decide each problem by its sub-problems:\\n        dp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2])\\n        \\n        return dp[-1]\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        // edge cases:\\n        if (nums.length == 0) return 0;\\n        if (nums.length == 1) return nums[0];\\n        if (nums.length == 2) return Math.max(nums[0], nums[1]);\\n        \\n        // dynamic programming - decide each problem by its sub-problems:\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        dp[1] = Math.max(nums[0], nums[1]);\\n        for (int i=2; i<nums.length; i++)\\n            dp[i] = Math.max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605688,
                "title": "all-solutions-from-recursion-to-constant-space-dp-c",
                "content": "* For each house you have 2 choices , rob the current house or don\\'t robe.\\n* If you rob the ith house then you will go to (i+2)th house next , as you can\\'t robe 2 adjacent houses.\\n## Solution 1 : Recursion\\n```\\nclass Solution {\\n    int helper(vector<int>& nums , int ind){\\n        \\n        //base case\\n        if(ind >= nums.size())\\n            return 0;\\n        \\n        //Choice 1 : Rob current house\\n        int money1 = nums[ind] + helper(nums , ind+2);\\n        \\n        //Choice 2: Don\\'t rob current house\\n        int money2 = helper(nums , ind+1);\\n        \\n        return max(money1 , money2);\\n    }\\n    \\npublic:\\n    int rob(vector<int>& nums) {\\n        return helper(nums,0);\\n    }\\n};\\n```\\n\\nTime Complexity : O(2^n), this will give us TLE\\nWe can optimise this solution using memoization and bottom up DP.\\n\\n## Solution 2: Recursion + Memoization\\n```\\nclass Solution {\\n    int helper(vector<int>& nums , int ind , vector<int>& dp){\\n        \\n        //base case\\n        if(ind >= nums.size())\\n            return 0;\\n        \\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        \\n        //Choice 1 : Rob current house\\n        int money1 = nums[ind] + helper(nums , ind+2 , dp);\\n        \\n        //Choice 2: Don\\'t rob current house\\n        int money2 = helper(nums , ind+1 , dp);\\n        \\n        return dp[ind] = max(money1 , money2);\\n    }\\n    \\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(nums.size() , -1);\\n        return helper(nums,0,dp);\\n    }\\n};\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n## Solution 3: Bottom Up DP\\ndp[i] denotes maximum money we can get till ith house.\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n            return nums[0];\\n        \\n        vector<int> dp(n,-1);\\n        \\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0] , nums[1]);\\n        for(int i=2;i<n;i++){\\n            dp[i] = max(nums[i] + dp[i-2] , dp[i-1]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n## Solution 4: Optimised Dp\\nFor every ith house we need 2 values:\\na) total money including robbing from i-1 house.\\nb) total money without robbing i-1 house.\\n\\nTherefore we maintain just 2 variables and not the dp array.\\n```\\nint rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n            return nums[0];\\n        \\n        int inc = nums[0]; //robbing house 0\\n        int excl = 0; //not robbing house 0\\n        \\n        for(int i=1;i<n;i++){\\n            int newInc = excl + nums[i]; //robbing ith house\\n            excl = max(inc , excl); // not robbing ith house\\n            inc = newInc;\\n        }\\n        return max(inc , excl);\\n    }\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\n***If you find the solution helpful, please Upvote!***\\n**Happy Coding!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int helper(vector<int>& nums , int ind){\\n        \\n        //base case\\n        if(ind >= nums.size())\\n            return 0;\\n        \\n        //Choice 1 : Rob current house\\n        int money1 = nums[ind] + helper(nums , ind+2);\\n        \\n        //Choice 2: Don\\'t rob current house\\n        int money2 = helper(nums , ind+1);\\n        \\n        return max(money1 , money2);\\n    }\\n    \\npublic:\\n    int rob(vector<int>& nums) {\\n        return helper(nums,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int helper(vector<int>& nums , int ind , vector<int>& dp){\\n        \\n        //base case\\n        if(ind >= nums.size())\\n            return 0;\\n        \\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        \\n        //Choice 1 : Rob current house\\n        int money1 = nums[ind] + helper(nums , ind+2 , dp);\\n        \\n        //Choice 2: Don\\'t rob current house\\n        int money2 = helper(nums , ind+1 , dp);\\n        \\n        return dp[ind] = max(money1 , money2);\\n    }\\n    \\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(nums.size() , -1);\\n        return helper(nums,0,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n            return nums[0];\\n        \\n        vector<int> dp(n,-1);\\n        \\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0] , nums[1]);\\n        for(int i=2;i<n;i++){\\n            dp[i] = max(nums[i] + dp[i-2] , dp[i-1]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\n```\\nint rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1)\\n            return nums[0];\\n        \\n        int inc = nums[0]; //robbing house 0\\n        int excl = 0; //not robbing house 0\\n        \\n        for(int i=1;i<n;i++){\\n            int newInc = excl + nums[i]; //robbing ith house\\n            excl = max(inc , excl); // not robbing ith house\\n            inc = newInc;\\n        }\\n        return max(inc , excl);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133686,
                "title": "c-five-approaches-bruteforce-topdown-optimised-bottomup-time-space",
                "content": "**Bruteforce Recursion - TLE**\\nTime Complexity: O (2^N)\\nSpace Complexity: O (N)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size()==1) return nums[0];\\n        return robUtil(nums, 0);\\n    }\\n    int robUtil (vector<int>& nums, int start) {\\n        if (start>=nums.size()) return 0;\\n        return max(nums[start]+robUtil (nums, start+2), robUtil (nums, start+1));\\n    }\\n};\\n```\\n**Recursion + Memoisation (Top-Down)**\\nTime Complexity: O (N)\\nSpace Complexity: O (N)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size()==1) return nums[0];\\n        vector <int> dp (nums.size(), -1);\\n        return robUtil(nums, 0, dp);\\n    }\\n    int robUtil (vector<int>& nums, int start, vector <int>& dp) {\\n        if (start>=nums.size()) return 0;\\n        if (dp[start]>-1) return dp[start];\\n        return dp[start]=max(nums[start]+robUtil (nums, start+2, dp), robUtil (nums, start+1, dp));\\n    }\\n};\\n```\\n\\n**Optimised DP (Bottom-Up)**\\nTime Complexity: O (N)\\nSpace Complexity: O (N)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 0) return nums[0];\\n        vector<int> dp(nums.size()+1, -1);\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        for (int i = 1; i<nums.size(); i++) {\\n            dp[i+1] = max(nums[i]+dp[i-1], dp[i]);\\n        }\\n        return dp[nums.size()];\\n    }\\n};\\n```\\n\\n**Very Optimised Bottom Up (#1)**\\nTime Complexity: O (N)\\nSpace Complexity: O (1)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size()==1) return nums[0];\\n        int prevByOne=0;\\n        int prevByTwo=0;\\n        for (int i=0; i<nums.size(); i++) {\\n            int cur=max(nums[i]+prevByTwo, prevByOne);\\n            prevByTwo=prevByOne;\\n            prevByOne=cur;\\n        }\\n        return prevByOne;\\n    }\\n};\\n```\\n\\n**Very Optimised Bottom Up (#2)**\\nWill add explanation some other day\\nTime Complexity: O (N)\\nSpace Complexity: O (1)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 0) return nums[0];\\n        int rob1 = 0;\\n        int rob2 = nums[0];\\n        for (int i = 1; i<nums.size(); i++) {\\n            int rob = max(nums[i]+rob1, rob2);\\n            rob1=rob2;\\n            rob2=rob;\\n        }\\n        return rob2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size()==1) return nums[0];\\n        return robUtil(nums, 0);\\n    }\\n    int robUtil (vector<int>& nums, int start) {\\n        if (start>=nums.size()) return 0;\\n        return max(nums[start]+robUtil (nums, start+2), robUtil (nums, start+1));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size()==1) return nums[0];\\n        vector <int> dp (nums.size(), -1);\\n        return robUtil(nums, 0, dp);\\n    }\\n    int robUtil (vector<int>& nums, int start, vector <int>& dp) {\\n        if (start>=nums.size()) return 0;\\n        if (dp[start]>-1) return dp[start];\\n        return dp[start]=max(nums[start]+robUtil (nums, start+2, dp), robUtil (nums, start+1, dp));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 0) return nums[0];\\n        vector<int> dp(nums.size()+1, -1);\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        for (int i = 1; i<nums.size(); i++) {\\n            dp[i+1] = max(nums[i]+dp[i-1], dp[i]);\\n        }\\n        return dp[nums.size()];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size()==1) return nums[0];\\n        int prevByOne=0;\\n        int prevByTwo=0;\\n        for (int i=0; i<nums.size(); i++) {\\n            int cur=max(nums[i]+prevByTwo, prevByOne);\\n            prevByTwo=prevByOne;\\n            prevByOne=cur;\\n        }\\n        return prevByOne;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 0) return nums[0];\\n        int rob1 = 0;\\n        int rob2 = nums[0];\\n        for (int i = 1; i<nums.size(); i++) {\\n            int rob = max(nums[i]+rob1, rob2);\\n            rob1=rob2;\\n            rob2=rob;\\n        }\\n        return rob2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759165,
                "title": "python3-solution-with-a-detailed-explanation-house-robber",
                "content": "Following solutions are not mine,the first solution comes from [here](https://leetcode.com/problems/house-robber/discuss/55959/4-line-python.-O(1)-space-O(n)-time.-With-explaination.-Simplest). The second one [here](https://leetcode.com/problems/house-robber/discuss/346376/Python-Dynamic-Programming-20-ms). \\n\\nEDIT: I now think that I should have talked about second solution first. Go read the whole post and start with whichever you feel is easier. \\n\\n\\nAs it\\'s mentioned in the problem statement, you can\\'t rob two adjacent houses. That\\'s I think the most important part of the problem to fully understand. Let\\'s try `nums = [1,2,3,1]` example! It\\'s obvious, right? You rob (not you, the thief)  `nums[0] + nums[2] = 4`. At first glance, what came to my mind was that what if we sum every other number starting from zero index (`sum(nums[::2])`) and start from index 1 (`sum(nums[1::2])`) and return the max of two! This works for the above example but it\\'s not going to work in general! Consider this example! `nums = [7,2,3,4]`! you need to choose `nums[0] + nums[3] = 11` to maximize your profit (thief\\'s profit). That\\'s why the above approach doesn\\'t work. \\n\\nReminder: In a list you can slice using `[start index : end index: step]`! In the above paragraph, `nums[::2] = num[0:-1:2]`. \\n\\nFor the first solution, the idea is similar to dynamic programming, but, not implemented using the DP approach. What I mean is that you move from left to right in `nums` and decide to whether include the current house `curr` in the robbery (view this problem as a `0/1 knapsack` problem where you decide whether to include an item in the knapsack or not). But, in contradiction to dp, you don\\'t store each step in an array (something we\\'ll do in the second solution). \\n\\nHere, we first define two parameters `curr_included` and `max_curr_excluded` (line `#1`) to keep track of whether we want to include `curr` or not. In the loop of line `#2`, we go from left to right in `nums`. There are two cases: 1) if we want to include `curr` or 2) we don\\'t want to include `curr` ! Regardless of what we decide here `max_curr_excluded` keep track of maximum profit so far excluding `curr`. Note that while we\\'re at an element, the previous element used to be `curr` at some point, right? However, the `max_curr_excluded` doesn\\'t care if something used to be `curr`, it just doesn\\'t want to include the `curr` we\\'re at right now. Does this make sense? Let\\'s check again the `nums = [7, 2, 3, 4]` example! If you do print some stuff (check the code below), you see something like this. \\n\\n```\\ncurr_included =  7 , max_curr_excluded=  0 <---- curr = 7\\ncurr_included =  2 , max_curr_excluded=  7 <---- curr = 2\\ncurr_included =  10 , max_curr_excluded=  7 <---- curr = 3\\ncurr_included =  11 , max_curr_excluded=  10 <---- curr = 4\\n\\n```\\n\\nOnce we include `nums[0]`, `curr_included = 7` while `max_curr_excluded` is still zero since it cannot include `curr`. However, once we move to `nums[1] = 2`, both variables get updated! `curr_included` cannot include `7` (two adjacent houses) anymore while `max_curr_excluded = 7` because it shows the maximum excluding `curr`.  We keep moving toward the end of the array. Let\\'s see what happens when we\\'re at the last element `curr = 4`. Here, we include `4` to be added to the `curr_included`, which we\\'ll give us `11`. Note that `max_curr_excluded` hasn\\'t considered the `curr = 4` yet, and shows the maximum up to the previous point. The `max_curr_excluded` up to the previous point, doesn\\'t included the previous point itself, right? Since it excluded that `curr`! Therefore, it\\'s eligible to add `curr = 4` to `max_curr_excluded` because it doesn\\'t include the adjacent house. That\\'s what we do in line `#3` to update `curr_included`. As for `max_curr_excluded` however, we use the `max` of two variables, none of which includes `curr` we\\'re looking at right now. Finally, we return the `max` of the two. The maximum we\\'re returning shows two cases. Whether the last element is included (`curr_included`) or the last element is not included (`max_curr_excluded`).\\n\\n```\\n# first solution\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        curr_included, max_curr_excluded = 0, 0 #1\\n        for curr in nums: #2\\n            curr_included, max_curr_excluded = curr+max_curr_excluded, max(curr_included, max_curr_excluded) #3\\n            #print(\\'curr_included = \\',curr_included, \\', max_curr_excluded= \\', max_curr_excluded, \\'<---- curr =\\', curr)\\n            \\n        return max(curr_included, max_curr_excluded)\\n```\\n\\n\\nThe second solution is a dynamic programming approach (I find this easier to understand). The idea is similar to the above! You move from left to right in `nums` and decide whether to include current house or not. Similar to any dp problem, there\\'re some base cases. You return `0` if `nums = []` (line `#1`). If the `len(nums) == 1`, you return its only value. If it has `len(nums) == 2`, you return the `max` of two values (line `#3`). These cases are projected in the `dp` array that we generated to keep track of maximum profit at each on the input array. For the main `loop`, we start from index `2` to the end of the array since the base cases cover up to index `2`. At each `i`, we check whether we should included `curr = nums[i]` or not in line `#6`. We either choose the maximum up to previous `i`, which means that we don\\'t need to included `curr = nums[i]` (note that I\\'m using `curr` to make a connection between this solution and the previous one. I don\\'t use `curr` in this solution) if `dp[i-1]` is larger than `dp[i-2]  + nums[i]`. However, similar to the previous appraoch, whatever goes into the `dp` shows the maximum up to index `i` regardless of `nums[i]` is included or not. \\n\\n\\nFinally, we return the maximum of two cases, including last element or not, which are shown in `dp[-1]` and `dp[-2]`. \\n\\n```\\n# second solution\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        dp = [0]*len(nums)\\n        \\n        if len(nums) == 0: #1\\n            return 0\\n        \\n        if len(nums) == 1: #1\\n            return nums[0]\\n        \\n        if len(nums) == 2: #3\\n            return max(nums[0], nums[1])\\n        \\n        dp[0] = nums[0] #4\\n        dp[1] = max(nums[:2]) #5\\n        \\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-2] + nums[i], dp[i-1]) #6\\n            \\n        return max(dp[-1], dp[-2])\\n```\\n\\nThat\\'s it! \\n\\n==================================================================\\nFinal note: Please let me know if you found any typo/error/etc. I\\'ll try to fix them\\n\\nFinal note 2: I\\'m writing it to help myself understand the subject better. Hope you also find it helpful.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ncurr_included =  7 , max_curr_excluded=  0 <---- curr = 7\\ncurr_included =  2 , max_curr_excluded=  7 <---- curr = 2\\ncurr_included =  10 , max_curr_excluded=  7 <---- curr = 3\\ncurr_included =  11 , max_curr_excluded=  10 <---- curr = 4\\n\\n```\n```\\n# first solution\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        curr_included, max_curr_excluded = 0, 0 #1\\n        for curr in nums: #2\\n            curr_included, max_curr_excluded = curr+max_curr_excluded, max(curr_included, max_curr_excluded) #3\\n            #print(\\'curr_included = \\',curr_included, \\', max_curr_excluded= \\', max_curr_excluded, \\'<---- curr =\\', curr)\\n            \\n        return max(curr_included, max_curr_excluded)\\n```\n```\\n# second solution\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        dp = [0]*len(nums)\\n        \\n        if len(nums) == 0: #1\\n            return 0\\n        \\n        if len(nums) == 1: #1\\n            return nums[0]\\n        \\n        if len(nums) == 2: #3\\n            return max(nums[0], nums[1])\\n        \\n        dp[0] = nums[0] #4\\n        dp[1] = max(nums[:2]) #5\\n        \\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-2] + nums[i], dp[i-1]) #6\\n            \\n        return max(dp[-1], dp[-2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55810,
                "title": "well-explained-java-dynamic-programming-style-code-good-for-beginners-like-me",
                "content": "    public class Solution {\\n    public int rob(int[] nums) {\\n        /*\\n        Dynamic programming\\n        Bottom-up approach\\n        Since we cannot rob 2 adjacent houses, generally, we cannot rob house[n] and house [n-1] at the same night\\n        So the basic idea is to see if house[n-1] has been robbed\\n        If house[n-1] has been robbed, then the optimal approach should be max{robbedmoney(n-1), robbedmoney(n-2)+nums[n]}\\n        If house[n-1] hasn't been robbed, then the optimal approach should be robbedmoney(n-2)+nums[n]\\n        */\\n        \\n        int l = nums.length;\\n        if (l == 0){\\n            return 0;\\n        }\\n\\n        int[] robbedmoney = new int[l]; //robbedmoney[i] array is used to store the maximum amount of money that can be robbed from the first i houses.\\n        for (int i = 0; i < l; i ++){\\n            if (i == 0){\\n                robbedmoney[i] = nums[i];\\n            }\\n            else if (i == 1){\\n                robbedmoney[i] = Math.max(nums[i], nums[i-1]);\\n            }\\n            else{\\n                robbedmoney[i] = Math.max(robbedmoney[i - 2] + nums[i], robbedmoney[i-1]);\\n            }\\n        }\\n        \\n        return robbedmoney[l - 1];\\n        \\n    }\\n}",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int rob(int[] nums) {\\n        /*\\n        Dynamic programming\\n        Bottom-up approach\\n        Since we cannot rob 2 adjacent houses, generally, we cannot rob house[n] and house [n-1] at the same night\\n        So the basic idea is to see if house[n-1] has been robbed\\n        If house[n-1] has been robbed, then the optimal approach should be max{robbedmoney(n-1), robbedmoney(n-2)+nums[n]}",
                "codeTag": "Java"
            },
            {
                "id": 2909316,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int temp,max,max1;\\n        if(nums.length==1)\\n         return nums[0];\\n         if(nums.length==2)\\n           return Math.max(nums[0],nums[1]);\\n        max=nums[0];\\n        max1=nums[1];\\n        for(int i=2;i<nums.length;i++)\\n        {\\n            max1=Math.max(max1,max);\\n            if(max+nums[i]>=max)\\n               max+=nums[i];\\n            temp=max;\\n            max=max1;\\n            max1=temp;\\n        }\\n        return Math.max(max1,max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int temp,max,max1;\\n        if(nums.length==1)\\n         return nums[0];\\n         if(nums.length==2)\\n           return Math.max(nums[0],nums[1]);\\n        max=nums[0];\\n        max1=nums[1];\\n        for(int i=2;i<nums.length;i++)\\n        {\\n            max1=Math.max(max1,max);\\n            if(max+nums[i]>=max)\\n               max+=nums[i];\\n            temp=max;\\n            max=max1;\\n            max1=temp;\\n        }\\n        return Math.max(max1,max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779597,
                "title": "comprehensive-python-explanation",
                "content": "Let\\'s walk through how to start with the basic recursive solution and work all the way up to the solution with the best time and space complexity! First we have to identify the recursive relationship:\\n\\nBase cases:\\n1. If we only have one house to rob, we rob it\\n2. If we have only two houses to rob, then we cannot rob both so we rob the one with the most money\\n\\nThat was pretty simple! But what if we have more than two houses? Well, let\\'s think about it as if we are at the `n`th house and we already robbed the previous houses. We can either rob this house or not. If we do rob the house, we cannot rob the `n-1`th house, so the total amount of money we get is the total amount of money after robbing the first `n-2` houses plus the money at the `n`th house. If we don\\'t rob the `n`th house, then we still have the same amount of money as we had after robbing the `n-1`th house. Using this, we can construct our first solution:\\n\\n**Basic Recursion Solution; Time: O(2^N), Space: O(1) --> TLE**\\n```\\ndef rob(self, nums: List[int]) -> int:\\n\\t# helper method to find the most money we can get for robbing the first n houses\\n\\tdef rob_n_houses(n):\\n\\t\\t# if there is only one house to rob\\n\\t\\tif n == 1:\\n\\t\\t\\t# rob it\\n\\t\\t\\treturn nums[0]\\n\\t\\t# if there are only two houses to rob\\n\\t\\tif n == 2: \\n\\t\\t\\t# rob the one with the most money\\n\\t\\t\\treturn max(nums[0], nums[1])\\n\\t\\t\\t\\n\\t\\t# otherwise we can either rob this house and not the previous one\\n\\t\\t# or we can not rob this house and rob any houses before it\\n\\n\\t\\t# if we rob this house (nums[-1]), we can\\'t rob nums[n-2], but we can rob any before that\\n\\t\\trob_this_house = nums[n-1] + rob_n_houses(n-2)\\n\\n\\t\\t# if we don\\'t rob nums[n-1], we can rob any house before it, meaning this is the same as rob_n_houses(n-1)\\n\\t\\tdont_rob_this_house = rob_n_houses(n-1)\\n\\t\\t# do whatever gets us the most money\\n\\t\\treturn max(rob_this_house, dont_rob_this_house)\\n\\t# originally we can rob any of the houses\\n\\treturn rob_n_houses(len(nums))\\n```\\nThis is the most basic solution, taking advantage of the recursive relationship we explored above. However, it is quite slow and results in a time limit exception because it has a time complextiy of ```O(2^N)``` since we need to make 2 recursive calls at each point and those recursive calls make recursive calls of their own. This can be illustrated with the following diagram about the fibonnaci sequence (credit to [Prateek Narang](https://www.scaler.com/topics/fibonacci-series-in-c/)):\\n![image](https://assets.leetcode.com/users/images/0b8e23d2-abd9-4553-b622-5efb833ba81a_1665202511.7852473.png)\\nTo improve on this solution, we can use memoization, one of the core DP techniques. Memoization just means storing our previous results. One way to do this is with python\\'s built in ```@cache```, which stores previous return values from a function call.\\n\\n**Cache Memoization Solution: Time: O(N), Space: O(N)**\\n```\\ndef rob(self, nums: List[int]) -> int:\\n\\t# helper method to find the most money we can get for robbing the first n houses\\n\\t@cache # store previous calls to this helper method\\n\\tdef rob_n_houses(n):\\n\\t\\t# if there is only one house to rob\\n\\t\\tif n == 1:\\n\\t\\t\\t# rob it\\n\\t\\t\\treturn nums[0]\\n\\t\\t# if there are only two houses to rob\\n\\t\\tif n == 2: \\n\\t\\t\\t# rob the one with the most money\\n\\t\\t\\treturn max(nums[0], nums[1])\\n\\t\\t# otherwise we can either rob this house and not the previous one\\n\\t\\t# or we can not rob this house and rob any houses before it\\n\\n\\t\\t# if we rob this house (nums[-1]), we can\\'t rob nums[n-2], but we can rob any before that\\n\\t\\trob_this_house = nums[n-1] + rob_n_houses(n-2)\\n\\n\\t\\t# if we don\\'t rob nums[n-1], we can rob any house before it, meaning this is the same as rob_n_houses(n-1)\\n\\t\\tdont_rob_this_house = rob_n_houses(n-1)\\n\\t\\t# do whatever gets us the most money\\n\\t\\treturn max(rob_this_house, dont_rob_this_house)\\n\\t# originally we can rob any of the houses\\n\\treturn rob_n_houses(len(nums))\\n```\\nThe time complexity is now ```O(N)``` since we only need to make one calculation for every value from ```1``` to ```n```. The space is also ```O(N)``` since we are now storing the answers to recursive calls to ```rob_n_houses```. To show that we are capable of implementing the same functionality as python\\'s `@cache`, let\\'s store the results ourselves by using a list where the ```i```th index corresponds to the result of ```rob_n_houses(i)```. We will start our array with `[0, nums[0]]`, since we would have `0` dollars after robbing zero houses. I would recommend going this route in an interview rather than using `@cache`.\\n\\n**List Memoization Solution; Time: O(N), Space: O(N)**\\n```\\ndef rob(self, nums: List[int]) -> int:\\n\\t# we have 0 dollars after robbing no houses and nums[0] dollars after robbing the first house\\n\\trob_n_houses = [0, nums[0]]\\n\\t# go through the rest of the houses\\n\\tfor i in range(1, len(nums)):\\n\\t\\t# if we rob this house\\n\\t\\trob_this_house = nums[i] + rob_n_houses[-2]\\n\\t\\t# if we dont\\n\\t\\tdont_rob_this_house = rob_n_houses[-1]\\n\\t\\t# add the max amt of money at this point\\n\\t\\trob_n_houses.append(max(rob_this_house, dont_rob_this_house))\\n\\t# return money after robbing all the houses\\n\\treturn rob_n_houses[-1] \\n```\\nThis is a great solution, but we can do even better! When we add the newest number to ```rob_n_houses``` , we actually only need to access the previous numbers in ```rob_n_houses```, so we can just use a tuple to store the last two!\\n\\n**Optimized Memoization Solution; Time: O(N), Space: O(1)**\\n```\\ndef rob(self, nums: List[int]) -> int:\\n\\t# we have 0 dollars after robbing no houses and nums[0] dollars after robbing the first house\\n\\tlast_two = (0, nums[0])\\n\\t# go through the rest of the houses\\n\\tfor i in range(1, len(nums)):\\n\\t\\t# if we rob this house\\n\\t\\trob_this_house = nums[i] + last_two[0]\\n\\t\\t# if we dont\\n\\t\\tdont_rob_this_house = last_two[1]\\n\\t\\t# update the amt of money we could have gotten from the last two houses\\n\\t\\tlast_two = (last_two[1], max(rob_this_house, dont_rob_this_house))\\n\\t# return money after robbing all the houses\\n\\treturn last_two[1]\\n```\\n\\n**Thanks for Reading!**\\nIf this post has been helpful, please consider upvoting! If you have any questions, please feel free to ask in the comments and I will try to answer them. Also, if I made any mistakes or there are other optimizations, methods I didn\\'t consider, etc. please let me know!",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef rob(self, nums: List[int]) -> int:\\n\\t# helper method to find the most money we can get for robbing the first n houses\\n\\tdef rob_n_houses(n):\\n\\t\\t# if there is only one house to rob\\n\\t\\tif n == 1:\\n\\t\\t\\t# rob it\\n\\t\\t\\treturn nums[0]\\n\\t\\t# if there are only two houses to rob\\n\\t\\tif n == 2: \\n\\t\\t\\t# rob the one with the most money\\n\\t\\t\\treturn max(nums[0], nums[1])\\n\\t\\t\\t\\n\\t\\t# otherwise we can either rob this house and not the previous one\\n\\t\\t# or we can not rob this house and rob any houses before it\\n\\n\\t\\t# if we rob this house (nums[-1]), we can\\'t rob nums[n-2], but we can rob any before that\\n\\t\\trob_this_house = nums[n-1] + rob_n_houses(n-2)\\n\\n\\t\\t# if we don\\'t rob nums[n-1], we can rob any house before it, meaning this is the same as rob_n_houses(n-1)\\n\\t\\tdont_rob_this_house = rob_n_houses(n-1)\\n\\t\\t# do whatever gets us the most money\\n\\t\\treturn max(rob_this_house, dont_rob_this_house)\\n\\t# originally we can rob any of the houses\\n\\treturn rob_n_houses(len(nums))\\n```\n```O(2^N)```\n```@cache```\n```\\ndef rob(self, nums: List[int]) -> int:\\n\\t# helper method to find the most money we can get for robbing the first n houses\\n\\t@cache # store previous calls to this helper method\\n\\tdef rob_n_houses(n):\\n\\t\\t# if there is only one house to rob\\n\\t\\tif n == 1:\\n\\t\\t\\t# rob it\\n\\t\\t\\treturn nums[0]\\n\\t\\t# if there are only two houses to rob\\n\\t\\tif n == 2: \\n\\t\\t\\t# rob the one with the most money\\n\\t\\t\\treturn max(nums[0], nums[1])\\n\\t\\t# otherwise we can either rob this house and not the previous one\\n\\t\\t# or we can not rob this house and rob any houses before it\\n\\n\\t\\t# if we rob this house (nums[-1]), we can\\'t rob nums[n-2], but we can rob any before that\\n\\t\\trob_this_house = nums[n-1] + rob_n_houses(n-2)\\n\\n\\t\\t# if we don\\'t rob nums[n-1], we can rob any house before it, meaning this is the same as rob_n_houses(n-1)\\n\\t\\tdont_rob_this_house = rob_n_houses(n-1)\\n\\t\\t# do whatever gets us the most money\\n\\t\\treturn max(rob_this_house, dont_rob_this_house)\\n\\t# originally we can rob any of the houses\\n\\treturn rob_n_houses(len(nums))\\n```\n```O(N)```\n```1```\n```n```\n```O(N)```\n```rob_n_houses```\n```i```\n```rob_n_houses(i)```\n```\\ndef rob(self, nums: List[int]) -> int:\\n\\t# we have 0 dollars after robbing no houses and nums[0] dollars after robbing the first house\\n\\trob_n_houses = [0, nums[0]]\\n\\t# go through the rest of the houses\\n\\tfor i in range(1, len(nums)):\\n\\t\\t# if we rob this house\\n\\t\\trob_this_house = nums[i] + rob_n_houses[-2]\\n\\t\\t# if we dont\\n\\t\\tdont_rob_this_house = rob_n_houses[-1]\\n\\t\\t# add the max amt of money at this point\\n\\t\\trob_n_houses.append(max(rob_this_house, dont_rob_this_house))\\n\\t# return money after robbing all the houses\\n\\treturn rob_n_houses[-1] \\n```\n```rob_n_houses```\n```rob_n_houses```\n```\\ndef rob(self, nums: List[int]) -> int:\\n\\t# we have 0 dollars after robbing no houses and nums[0] dollars after robbing the first house\\n\\tlast_two = (0, nums[0])\\n\\t# go through the rest of the houses\\n\\tfor i in range(1, len(nums)):\\n\\t\\t# if we rob this house\\n\\t\\trob_this_house = nums[i] + last_two[0]\\n\\t\\t# if we dont\\n\\t\\tdont_rob_this_house = last_two[1]\\n\\t\\t# update the amt of money we could have gotten from the last two houses\\n\\t\\tlast_two = (last_two[1], max(rob_this_house, dont_rob_this_house))\\n\\t# return money after robbing all the houses\\n\\treturn last_two[1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2399156,
                "title": "4-approaches-recursion-memoization-tabulation-space-optimization",
                "content": "**Logic :** \\n* If you observe carefully, then you can see that this is a decision making problem as on each step we have the choice of taking it (robbing that house) or not take it (not robbing that house). \\n\\n* If we take it then we add it to our sum and skip 1 house to move to the third one.. If we don\\'t take it then we move to the next house and don\\'t add anything to our sum/or add 0.\\n\\n* At every step, we calculate the maximum out of both the situations and move forward accordingly.\\n\\n**Approach 1 : Normal Recursion**\\n\\n```\\n       int solve(int i, vector<int>&nums){\\n        \\n        if(i==0){\\n            return nums[i];\\n        }    \\n        if(i<0){                         // prevents negative indexing for take case\\n            return 0;\\n        }\\n        \\n        int take = solve(i-2,nums)+nums[i];     //adding nums[i] and skipping 1 house\\n        int not_take = solve(i-1,nums)+0;       //adding 0 and moving to the next house\\n        \\n        return max(take,not_take);              // return max of both situations\\n    }\\n        \\n    int rob(vector<int>& nums) {\\n         return solve(nums.size()-1,nums);\\n    }\\n```\\n\\nTime : O(2^N)   \\nSpace : O(N)     --> Recursion stack space\\n\\n\\n**Approach 2 : Recursion -> Memoization**\\n\\n* We can see that there are many subproblems that are computed already and now are being recomputed like for f(5) we need f(4) and f(3) and then for f(4) we again need f(3) and f(2). So it is evident that we are recalculating a lot of stuff.\\n\\n* So, we are going to memoize it using a dp vector where we store the values which we calculate during recursion. If the value is stored in dp vector we will use it directly and won\\'t recalculate the same thing again, otherwise we will solve that subproblem and store its value in dp vector.\\n\\n```\\n       int solve(int i, vector<int>&nums,vector<int>&dp){\\n        \\n        if(i==0){\\n            return nums[i];\\n        }    \\n        if(i<0){\\n            return 0;\\n        }        \\n        \\n        if(dp[i]!=-1){           // if value is precalculated then use it\\n            return dp[i];\\n        }\\n        \\n        int take = solve(i-2,nums,dp)+nums[i];  // else calculate it \\n        int not_take = solve(i-1,nums,dp)+0;\\n        \\n        dp[i]=max(take,not_take);              // after calculation store it in dp vector to reuse it and prevent recalculation.\\n        return dp[i];\\n    }\\n        \\n    int rob(vector<int>& nums) {\\n        vector<int>dp(nums.size()+1,-1);\\n        return solve(nums.size()-1,nums,dp);\\n    }\\n```\\n\\nSpace : O(N) for recursion and O(N) for Dp vector\\nTime : O(N)\\n\\n**Approach 3 : Tabulation**\\n\\n* We can see that we are taking an extra O(N) space for recursion. Let\\'s remove it by converting our top-down approach to an iterative bottom-up approach.\\n\\n```\\n        int rob(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1);\\n        \\n        dp[0]=nums[0];\\n\\n        for(int i = 1;i<nums.size();i++){\\n            if(i>1) dp[i] = max(dp[i-1],dp[i-2]+nums[i]); // taking the max of take and non take conditions\\n            else dp[i] = max(dp[i-1],nums[i]);      //bcs if i=1 , dp[i-2] won\\'t exist\\n        }\\n        return dp[nums.size()-1];\\n    }\\n```\\n\\nTime : O(N)\\nSpace : O(N)\\n\\n**Approach 4 : Space optimized to O(1)**\\n\\n* If you observe the solution of approach 3 carefully, you will notice that at each step we require only dp[i-1] and dp[i-2] i.e. the previous 2 values of function.\\n\\n* We don\\'t need to maintain the whole dp vector .. we can just keep track of the last two values of the function to obtain the current value and keep modifying our three pointers.\\n\\n```\\n        int rob(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1);\\n        \\n        int prev = nums[0];\\n        int curr,prev2;\\n        \\n        for(int i = 1;i<nums.size();i++){\\n\\n           if(i>1) curr = max(prev,prev2+nums[i]);\\n            else curr = max(prev,nums[i]);\\n            prev2 = prev;\\n            prev = curr;   \\n        }\\n        return prev;\\n    }\\n```\\n\\nSpace : O(1)\\nTime : O(N)\\n\\n**P.S.**\\n1. Upvote if helpful",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n       int solve(int i, vector<int>&nums){\\n        \\n        if(i==0){\\n            return nums[i];\\n        }    \\n        if(i<0){                         // prevents negative indexing for take case\\n            return 0;\\n        }\\n        \\n        int take = solve(i-2,nums)+nums[i];     //adding nums[i] and skipping 1 house\\n        int not_take = solve(i-1,nums)+0;       //adding 0 and moving to the next house\\n        \\n        return max(take,not_take);              // return max of both situations\\n    }\\n        \\n    int rob(vector<int>& nums) {\\n         return solve(nums.size()-1,nums);\\n    }\\n```\n```\\n       int solve(int i, vector<int>&nums,vector<int>&dp){\\n        \\n        if(i==0){\\n            return nums[i];\\n        }    \\n        if(i<0){\\n            return 0;\\n        }        \\n        \\n        if(dp[i]!=-1){           // if value is precalculated then use it\\n            return dp[i];\\n        }\\n        \\n        int take = solve(i-2,nums,dp)+nums[i];  // else calculate it \\n        int not_take = solve(i-1,nums,dp)+0;\\n        \\n        dp[i]=max(take,not_take);              // after calculation store it in dp vector to reuse it and prevent recalculation.\\n        return dp[i];\\n    }\\n        \\n    int rob(vector<int>& nums) {\\n        vector<int>dp(nums.size()+1,-1);\\n        return solve(nums.size()-1,nums,dp);\\n    }\\n```\n```\\n        int rob(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1);\\n        \\n        dp[0]=nums[0];\\n\\n        for(int i = 1;i<nums.size();i++){\\n            if(i>1) dp[i] = max(dp[i-1],dp[i-2]+nums[i]); // taking the max of take and non take conditions\\n            else dp[i] = max(dp[i-1],nums[i]);      //bcs if i=1 , dp[i-2] won\\'t exist\\n        }\\n        return dp[nums.size()-1];\\n    }\\n```\n```\\n        int rob(vector<int>& nums) {\\n        vector<int>dp(nums.size(),-1);\\n        \\n        int prev = nums[0];\\n        int curr,prev2;\\n        \\n        for(int i = 1;i<nums.size();i++){\\n\\n           if(i>1) curr = max(prev,prev2+nums[i]);\\n            else curr = max(prev,nums[i]);\\n            prev2 = prev;\\n            prev = curr;   \\n        }\\n        return prev;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 942309,
                "title": "python3-o-n-time-o-1-space-explained-with-code",
                "content": "Solution and description mainly based on the following:\\n1. [Answer by @GavinCode](https://leetcode.com/problems/house-robber/discuss/55938/DP-with-two-variables-Easiest-Solution-(I-think)-O(n))\\n2. [Answer by @cjhuo](https://leetcode.com/problems/house-robber/discuss/55977/Python-DP-solution-4-line-O(n)-time-O(1)-space-easy-to-understand-with-detailed-explanation)\\n3. [Answer by @huangclose](https://leetcode.com/problems/house-robber/discuss/55959/4-line-python.-O(1)-space-O(n)-time.-With-explaination.-Simplest)\\n\\nThis question honestly stumped me and I found a lot of the explanations didn\\'t help all too much, so I thought I\\'d try write my own explanation. I also tried to use longer more descriptive names on variables.\\n\\nYou can boil down this problem into a dynamic programming solution by considering the following.\\n\\nAt the first house, the maximum you can steal is whatever is in the first house\\n\\nAt the second house, since you can\\'t steal from 2 houses in a row you should take the max of:\\n* the money in the first house\\n* the money in the second house\\n\\nThen for any house past the second you must figure out what the maxium amount of money you can steal up until that house is.\\n\\nSo at house `i` past the second house there are two choices:\\n1. Rob house `i`:\\n\\t* In this case you cannot consider the max amount you can steal at house `i - 1` as if you do, you could rob 2 houses in a row and set off an alarm.\\n\\t* So you want to take whatever is in house `i` PLUS the max you can take from house `i - 2` so you don\\'t set off an alarm.\\n\\n2. Don\\'t rob house `i`:\\n\\t* In this case you want to take the max amount of money that you can steal at house `i - 1`.\\n\\t* This is because you are not stealing from house `i` and you\\'ve already figured out the maximum\\n\\t  you can take up until house `i - 1` previously, so you should take that...\\n\\nIn order to maximize your takings, you want to choose the case that will result in the most amount of money.\\nIE: the maximum between case 1 and case 2.\\n\\nAssuming you store the max amount possible at house `i` in an array called `max_possible_at_house`, the formula \\nfor choosing between case 1 and case 2 is:\\n\\n```python\\nmax(\\n\\tmax_possible_at_house[i - 2] + money_in_house_i,  # Case 1, rob the house\\n\\tmax_possible_at_house[i - 1] # Case 2, don\\'t rob the house\\n)\\n```\\n\\nUsing an array to store the maximums, you would initialize the first two entries as:\\n\\n```python\\nmax_possible_at_house[0] = nums[0] # value in the first house\\nmax_possible_at_house[1] = max(nums[0], nums[1]) # The maxium we could take between the first two houses\\n```\\n\\nThen your loop would start at index `2`, and each position is in the array is filled with the formula above.\\n\\nYou then return the last element in `max_possible_at_house` as it will be the maximum possible after considering all the houses.\\n\\n**But wait! There\\'s more!**\\n\\nWe can actually omit storing the maximums in a new array by realizing that at house `i`, you only need to know:\\n\\t- amount you can take from house `i`\\n\\t- max amount you can take up to house `i - 2`\\n\\t- max amount you can take up to house `i - 1`\\n\\nSo you do not need to store an array of all the possible maximums, instead you can use two variables.\\nOne to track `max_2_houses_ago`, ie: max at house `i-2`, and `max_last_house`, ie: max at house `i - 1`.\\n\\nWith that, here is the solution:\\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n\\t\\n\\t\\t# On the first iteration we haven\\'t stolen anything because we haven\\'t seen two houses, \\n\\t\\t# so our maxes will be 0.\\n        max_2_houses_ago = max_last_house = 0\\n        \\n\\t\\tfor house_value in nums:\\n            # Python lets us do some really fancy swapping.\\n            # The following is equivalent to:\\n            # temp = max_2_houses_ago\\n            # max_2_houses_ago = max_last_house\\n            # max_last_house = max(temp + house_value, max_last_house)\\n\\t\\t\\t\\n            max_2_houses_ago, max_last_house = max_last_house, max(max_2_houses_ago + house_value, max_last_house)\\n            \\n        return max_last_house\\n```\\n\\nI hope this was helpful! I found this solution really hard to wrap my head around.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nmax(\\n\\tmax_possible_at_house[i - 2] + money_in_house_i,  # Case 1, rob the house\\n\\tmax_possible_at_house[i - 1] # Case 2, don\\'t rob the house\\n)\\n```\n```python\\nmax_possible_at_house[0] = nums[0] # value in the first house\\nmax_possible_at_house[1] = max(nums[0], nums[1]) # The maxium we could take between the first two houses\\n```\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n\\t\\n\\t\\t# On the first iteration we haven\\'t stolen anything because we haven\\'t seen two houses, \\n\\t\\t# so our maxes will be 0.\\n        max_2_houses_ago = max_last_house = 0\\n        \\n\\t\\tfor house_value in nums:\\n            # Python lets us do some really fancy swapping.\\n            # The following is equivalent to:\\n            # temp = max_2_houses_ago\\n            # max_2_houses_ago = max_last_house\\n            # max_last_house = max(temp + house_value, max_last_house)\\n\\t\\t\\t\\n            max_2_houses_ago, max_last_house = max_last_house, max(max_2_houses_ago + house_value, max_last_house)\\n            \\n        return max_last_house\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559247,
                "title": "python-3-dp-with-space-optimization-5-lines-beats-92-1",
                "content": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        prev = 0\\n        curr = 0\\n        # every loop, calculate the maximum cumulative amount of money until current house\\n        for i in nums:\\n            # as the loop begins\\uFF0Ccurr represents dp[k-1]\\uFF0Cprev represents dp[k-2]\\n            # dp[k] = max{ dp[k-1], dp[k-2] + i }\\n            prev, curr = curr, max(curr, prev + i)\\n            # as the loop ends\\uFF0Ccurr represents dp[k]\\uFF0Cprev represents dp[k-1]\\n\\n        return curr\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        prev = 0\\n        curr = 0\\n        # every loop, calculate the maximum cumulative amount of money until current house\\n        for i in nums:\\n            # as the loop begins\\uFF0Ccurr represents dp[k-1]\\uFF0Cprev represents dp[k-2]\\n            # dp[k] = max{ dp[k-1], dp[k-2] + i }\\n            prev, curr = curr, max(curr, prev + i)\\n            # as the loop ends\\uFF0Ccurr represents dp[k]\\uFF0Cprev represents dp[k-1]\\n\\n        return curr\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 118575,
                "title": "dp-solution-for-fun",
                "content": "I\\'m still learning DP, got the idea from best time to buy or sell stocks. Basically the main idea is to decide whether or not to steal the current house or not. `dp[i]` represents the maximum value I have after leaving house `i`th house.\\n\\n`dp[i] = dp[i -1]` means I\\'m not stealing this house, my value is retained from last house.\\n`dp[i] = dp[i - 2] + nums[i]` means the sum of the stash in current house and 2 houses ago is more than what I got from last house. So stealing the current house will give me more value.\\n\\nStill in the process of learning DP in general, more than welcome to give me feedback to optimize the code. Thanks~\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if (nums == null || nums.length < 1) return 0;\\n        if (nums.length < 2) return nums[0];\\n        int[] dp = new int[nums.length];\\n        \\n        dp[0] = nums[0];\\n        dp[1] = Math.max(dp[0], nums[1]);\\n        for (int i = 2; i < nums.length; i++) {\\n            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\\n        }\\n        return dp[nums.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if (nums == null || nums.length < 1) return 0;\\n        if (nums.length < 2) return nums[0];\\n        int[] dp = new int[nums.length];\\n        \\n        dp[0] = nums[0];\\n        dp[1] = Math.max(dp[0], nums[1]);\\n        for (int i = 2; i < nums.length; i++) {\\n            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i]);\\n        }\\n        return dp[nums.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55908,
                "title": "o-n-java-solution-using-dp",
                "content": "    public int rob(int[] nums) {\\n        int len = nums.length;\\n        if(len == 0) return 0;\\n        if(len == 1) return nums[0];\\n        int[] val = new int[len];\\n        val[0] = nums[0];\\n        val[1] = Math.max(nums[0], nums[1]);\\n        for(int i=2; i<len; i++)\\n            val[i] = Math.max(nums[i] + val[i-2], val[i-1]);\\n        return val[len-1];\\n    }\\n\\n**For each house, the maximum amount you can get is either the amount you get from two houses before this one plus the amount you get from this one, or the amount you get from the neighbor house before this one (so you can't get any from this one), whatever is larger.**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public int rob(int[] nums) {\\n        int len = nums.length;\\n        if(len == 0) return 0;\\n        if(len == 1) return nums[0];\\n        int[] val = new int[len];\\n        val[0] = nums[0];\\n        val[1] = Math.max(nums[0], nums[1]);\\n        for(int i=2; i<len; i++)\\n            val[i] = Math.max(nums[i] + val[i-2], val[i-1]);\\n        return val[len-1];\\n    }\\n\\n**For each house, the maximum amount you can get is either the amount you get from two houses before this one plus the amount you get from this one, or the amount you get from the neighbor house before this one (so you can't get any from this one), whatever is larger.**",
                "codeTag": "Unknown"
            },
            {
                "id": 55990,
                "title": "dp-2ms-c-space-o-1-concise-with-explaination",
                "content": "**DP 2ms using C++, with/without memoization, concise solution with explaination**\\n\\nAssume we start from left to right, then here I use dp array to store i-th house's max money I can squeeze. The idea is that since we cannot get a quote from adjacent house, the dp[i-1] can only be compared to discard or replace current position's max money. E.g. :\\n\\nFor bonanzas like this:**5=10=13= 1 = 7 = 2**\\n\\nWill yield dp array like: **5=10=18=18=25=25**<------then return the last element.\\n\\nThe time complexity of DP straightforward version is O(n), space O(n).\\n\\n**DP straightforward:**\\n\\n    class Solution {\\n    public:\\n        int rob(vector<int> &A) {\\n            if(A.size()<=1)return A.empty()?0:A[0];\\n            vector<int> dp={A[0], max(A[1],A[0])};\\n            for(int i=2;i<A.size();i++)\\n                dp.push_back(max(A[i]+dp[i-2],dp[i-1]));\\n            return dp.back();\\n        }\\n    };\\n\\nThis solution costs me 2ms.\\n\\n\\n\\n\\nSince the dp array is only used with its newest two elements, we can reduce space using memoization. The idea is same with above solution except the dp array is replaced by int dp1, dp2. The time complexity is O(n), space O(1).\\n\\n**dp with memoization:**\\n\\n    class Solution {\\n    public:\\n        int rob(vector<int> &A) {\\n            if(A.size()<=1)return A.empty()?0:A[0];\\n            int dp1=A[0],dp2=max(A[1],A[0]);\\n            for(int i=2;i<A.size();i++){\\n                swap(dp1,dp2);\\n                dp2=max(A[i]+dp2,dp1);\\n            }\\n            return dp2;\\n        }\\n    };\\n\\nThis solution costs me 3ms.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int rob(vector<int> &A) {\\n            if(A.size()<=1)return A.empty()?0:A[0];\\n            vector<int> dp={A[0], max(A[1],A[0])}",
                "codeTag": "Java"
            },
            {
                "id": 3385971,
                "title": "c-easy-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& v) {\\n     \\n        int n=v.size();\\n           if(n==1)return v[0];\\n        int dp[n];\\n        dp[0]=v[0];\\n        dp[1]=max(v[0],v[1]);\\n        for(int i=2;i<n;i++){\\n            dp[i]=max(dp[i-1],v[i]+dp[i-2]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/7efa2f9a-24cd-42a3-9cbc-29372b4b1421_1680774100.3589573.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& v) {\\n     \\n        int n=v.size();\\n           if(n==1)return v[0];\\n        int dp[n];\\n        dp[0]=v[0];\\n        dp[1]=max(v[0],v[1]);\\n        for(int i=2;i<n;i++){\\n            dp[i]=max(dp[i-1],v[i]+dp[i-2]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909624,
                "title": "c-memoized-bottomup-sc-o-n-sc-o-1",
                "content": "**Memoized Solution**\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[105];\\n    int rec(int i, vector<int>&a) {\\n        if (i >= a.size()) {\\n            return 0;\\n        }\\n        if (dp[i] != -1) return dp[i];\\n        int op1 = rec(i + 1, a);\\n        int op2 = a[i] + rec(i + 2, a);\\n        return dp[i] = max(op1, op2);\\n    }\\n    int rob(vector<int>& nums) {\\n        memset(dp, -1, sizeof(dp));\\n        return rec(0, nums);\\n    }\\n};\\n```\\n\\n**Bottom Up O(N) Space**\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n];\\n        dp[0] = nums[0];  // base cases\\n        if (n == 1) return dp[0];\\n        dp[1] = max(nums[0] , nums[1]);  // base cases\\n\\n        for (int i = 2; i < n; i++) {\\n            dp[i] = max(dp[i - 1] , nums[i] + dp[i - 2]);\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\\n\\n**Bottom Up O(1) Space**\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        \\n        int prev2 = nums[0];     // dp[i-2]  base case\\n        int prev1 = max(nums[0] , nums[1]);    // dp[i-1]   it base case\\n        int curr = prev1;        // dp[i] \\n        \\n        for(int i=2;i<n;i++){\\n            curr = max(prev1 , nums[i] + prev2);   // dp[i] = max(dp[i-1] , nums[i] + dp[i-2])\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n        return curr;        // dp[n-1]\\n    }\\n};\\n```\\n\\n**All above solutions have TC O(N)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[105];\\n    int rec(int i, vector<int>&a) {\\n        if (i >= a.size()) {\\n            return 0;\\n        }\\n        if (dp[i] != -1) return dp[i];\\n        int op1 = rec(i + 1, a);\\n        int op2 = a[i] + rec(i + 2, a);\\n        return dp[i] = max(op1, op2);\\n    }\\n    int rob(vector<int>& nums) {\\n        memset(dp, -1, sizeof(dp));\\n        return rec(0, nums);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n];\\n        dp[0] = nums[0];  // base cases\\n        if (n == 1) return dp[0];\\n        dp[1] = max(nums[0] , nums[1]);  // base cases\\n\\n        for (int i = 2; i < n; i++) {\\n            dp[i] = max(dp[i - 1] , nums[i] + dp[i - 2]);\\n        }\\n        return dp[n - 1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        \\n        int prev2 = nums[0];     // dp[i-2]  base case\\n        int prev1 = max(nums[0] , nums[1]);    // dp[i-1]   it base case\\n        int curr = prev1;        // dp[i] \\n        \\n        for(int i=2;i<n;i++){\\n            curr = max(prev1 , nums[i] + prev2);   // dp[i] = max(dp[i-1] , nums[i] + dp[i-2])\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n        return curr;        // dp[n-1]\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909308,
                "title": "easiest-possible-dp-java",
                "content": "**EXPLANATION:**\\n\\nLet dp[i] == the max money we can get up until the i-th house. Then dp[i]=max(dp[i-1], nums[i]+dp[i-2]);\\n\\n# Code\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n=nums.length;\\n        int[] dp=new int[n];\\n        dp[0]=nums[0];\\n        for(int i=1; i<n; i++){\\n            if(i >= 2){\\n                dp[i]= Math.max(dp[i],Math.max(nums[i]+dp[i-2],dp[i-1]));\\n            }else{\\n                dp[i]=Math.max(nums[i],dp[i-1]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n=nums.length;\\n        int[] dp=new int[n];\\n        dp[0]=nums[0];\\n        for(int i=1; i<n; i++){\\n            if(i >= 2){\\n                dp[i]= Math.max(dp[i],Math.max(nums[i]+dp[i-2],dp[i-1]));\\n            }else{\\n                dp[i]=Math.max(nums[i],dp[i-1]);\\n            }\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139025,
                "title": "java-recursion-space-optimisation-faster-than-100",
                "content": "Let\\'s start. The flow will be:\\n* Recursion -> **T.C.: O(2^n), S.C.: O(1)**.\\n* Memoization -> **T.C.: O(N), S.C.: O(N) + O(N)**. (Auxillary Stack Space)\\n* Tabulation -> **T.C.: O(N), S.C.: O(N)**.\\n* Tabulation Space Optmisation -> **T.C.: O(N), S.C.: O(1)**.\\n\\nMost Important catch in the question:\\n\"**adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.**\"\\n\\nThis simply means **we cannot loot adjacent houses**, or simply saying **we can not access the adjacent elements from the array**.\\n\\nSo for every index `i` of the array, we can *either pick that element or not pick it*.\\n\\nOk. Let\\'s start coding.\\n\\n**Recursion:**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        return solve(nums, nums.length-1);\\n    }\\n    public int solve(int nums[], int ind){\\n        if(ind < 0)\\n            return 0;\\n        if(ind == 0)\\n            return nums[ind];\\n        int pick = nums[ind] + solve(nums, ind-2);\\n        int notPick = 0 + solve(nums, ind-1);\\n        return Math.max(pick, notPick);\\n    }\\n}\\n```\\n\\nNow let\\'s optmise this. We will just require 3 additonal steps:\\n1. Create a dp table of size of given array to store the pre-computed values and initialise it with -1.\\n2.  Check if the value at any index of the dp is modified, if modified return that without moving into recursion.\\n3.  Update the dp[i] value at the end of every recursion.\\n\\nThis step is called *memoisation*.\\n\\n**Memoisation:**\\n```\\nclass Solution {\\n    int dp[];\\n    public int rob(int[] nums) {\\n        dp = new int[nums.length];\\n        Arrays.fill(dp,-1);\\n        return solve(nums, nums.length-1);\\n    }\\n    public int solve(int nums[], int ind){\\n        if(ind < 0)\\n            return 0;\\n        if(ind == 0)\\n            return nums[ind];\\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        int pick = nums[ind] + solve(nums, ind-2);\\n        int notPick = 0 + solve(nums, ind-1);\\n        return dp[ind] = Math.max(pick, notPick);\\n    }\\n}\\n```\\n\\nCan we optmise further ? Yes, we can. Let\\'s tabulate this. The only major change in this flow will be that we will be traversing the array from the start and not from the end.\\n\\n**Tabulation:**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int dp[] = new int[nums.length];\\n        dp[0] = nums[0]; // Base Condition 1\\n        int negativeIndexVal = 0; // Base Condition 2\\n        for(int i = 1; i < nums.length; i++){\\n            int pick = nums[i];\\n            if(i > 1)\\n                pick += dp[i-2];\\n            else pick += negativeIndexVal;\\n            int notPick = 0 + dp[i-1];\\n            dp[i] = Math.max(pick, notPick);\\n        }\\n        return dp[nums.length-1];\\n    }\\n}\\n```\\n\\nIf you carefully go through the iterations, you can see that we are only concerned about the `dp[nums.length-1]`, this means that the other values are useless. Then why unnecessarily use the extra space to store them. Let\\'s get rid of this. \\n\\nWe will do this by using variables to store the values at our `i-1` and `i-2` indexes.\\n\\n**Space Optmisation:**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int prev1 = nums[0];  // For value at i-1 index\\n\\t\\tint prev2 = 0; // For value at i-2 index\\n        for(int i = 1; i<nums.length; i++){\\n            int pick = nums[i] + prev2;\\n            int notPick = 0 + prev1;\\n            int curr = Math.max(pick, notPick);\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n        return prev1;\\n    }\\n}\\n```\\n\\nIsn\\'t it simple, short and sweet? \\uD83E\\uDD0C \\uD83E\\uDEE0 \\n\\nP.S.: Please upvote if you like it. \\uD83D\\uDC9C",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        return solve(nums, nums.length-1);\\n    }\\n    public int solve(int nums[], int ind){\\n        if(ind < 0)\\n            return 0;\\n        if(ind == 0)\\n            return nums[ind];\\n        int pick = nums[ind] + solve(nums, ind-2);\\n        int notPick = 0 + solve(nums, ind-1);\\n        return Math.max(pick, notPick);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int dp[];\\n    public int rob(int[] nums) {\\n        dp = new int[nums.length];\\n        Arrays.fill(dp,-1);\\n        return solve(nums, nums.length-1);\\n    }\\n    public int solve(int nums[], int ind){\\n        if(ind < 0)\\n            return 0;\\n        if(ind == 0)\\n            return nums[ind];\\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        int pick = nums[ind] + solve(nums, ind-2);\\n        int notPick = 0 + solve(nums, ind-1);\\n        return dp[ind] = Math.max(pick, notPick);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int dp[] = new int[nums.length];\\n        dp[0] = nums[0]; // Base Condition 1\\n        int negativeIndexVal = 0; // Base Condition 2\\n        for(int i = 1; i < nums.length; i++){\\n            int pick = nums[i];\\n            if(i > 1)\\n                pick += dp[i-2];\\n            else pick += negativeIndexVal;\\n            int notPick = 0 + dp[i-1];\\n            dp[i] = Math.max(pick, notPick);\\n        }\\n        return dp[nums.length-1];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int prev1 = nums[0];  // For value at i-1 index\\n\\t\\tint prev2 = 0; // For value at i-2 index\\n        for(int i = 1; i<nums.length; i++){\\n            int pick = nums[i] + prev2;\\n            int notPick = 0 + prev1;\\n            int curr = Math.max(pick, notPick);\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n        return prev1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846461,
                "title": "the-art-of-dynamic-programming",
                "content": "**Synopsis:**\\n\\n`\\uD83C\\uDFA8 ` [The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/the-art-of-dynamic-programming-an-intuitive-approach-from-apprentice-to-master/)\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n2. **R**emember each subproblem\\'s optimal solution via memo\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n4. Optimize Memory, ie. sliding window `a, b, c = dp[i + 2], dp[i + 1], dp[i]`\\n\\n---\\n\\n**All Possibilities:**\\n\\nThere are two use cases to consider for each current house:\\n\\n* **Case 1:** `\\u2705 take` (ie. rob) the current house\\n* **Case 2:**  `\\uD83D\\uDEAB skip` (ie. don\\'t rob) the current house\\n\\n---\\n\\n**Top-Down Details:**\\n\\nIf we rob the `i`<sup>th</sup> house, then we cannot rob the `i + 1`<sup>th</sup> house, thus the next candidate house to rob is the `i + 2`<sup>th</sup> house.  However, if we do *not* rob the `i`<sup>th</sup> house, then the next candidate house to rob is the `i + 1`<sup>th</sup> house.\\n\\n**Recursive Formulas:**\\n\\n* `\\u2705 take` (ie. rob) the current house:\\n\\t* `go(i + 2) + A[i]`\\n* `\\uD83D\\uDEAB skip` (ie. don\\'t rob) the current house:\\n\\t* `go(i + 1)`\\n\\n---\\n\\n**Bottom-Up Details:**\\n\\nThe bottom-up solutions simply mimic the top-down solution\\'s recursive stack unwinding.  Let `N` be the cardinality of `A` and let `i` denote the current `i`<sup>th</sup> house.  Since the top-down recursive stack \"bottoms-out\" at the base case when `i == N` or `i == N + 1`, thus we begin filling in the bottom-up solution from the right-most position `N - 1`.  This means we need to append two zeros onto the DP maxtrix to store the base cases when `i == N` and `i == N + 1` correspondingly.\\n\\n**Iterative Formulas:**\\n\\n* `\\u2705 take` (ie. rob) the current house:\\n\\t* `dp[i + 2] + A[i]`\\n* `\\uD83D\\uDEAB skip` (ie. don\\'t rob) the current house:\\n\\t* `dp[i + 1]`\\n\\n**Optimize Memory:**\\n\\n`a, b, c = dp[i + 2], dp[i + 1], dp[i]`\\n\\nThis problem essentially is as simple as `a, b, c`.  Since each `dp[i]` calculation is only dependent upon the previous two solutions, ie. `dp[i + 1]` and `dp[i + 2]`, we can reduce memory consumption from O(N) to O(1) via a sliding window of size 3: `a, b, c`.  Each time the window \"slides\", `a` \"drops off\" the window to make `c` available for the next computation via `a`, `b`.  In summary, `a` represents the optimal solution \"two-away\" from `c`, thus, when we choose `\\u2705` with `A[i]`, we add the value of `A[i]` onto the optimal solution \"two-away\" from `c`, which is `a`.  Otherwise when we choose `\\uD83D\\uDEAB` without `A[i]`, we use the optimal solution \"one-away\" from `c`, which is `b`.  Cheers!  \\uD83C\\uDF7A\\n\\n---\\n\\n**Kotlin Solutions**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        fun go(i: Int = 0): Int {\\n            if (N <= i)\\n                return 0\\n            var take = go(i + 2) + A[i]\\n            var skip = go(i + 1)\\n            return Math.max(take, skip)\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via memo\\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        var m = mutableMapOf<Int, Int>()\\n        fun go(i: Int = 0): Int {\\n            if (N <= i)\\n                return 0\\n            if (!m.contains(i)) {\\n                var take = go(i + 2) + A[i]\\n                var skip = go(i + 1)\\n                m[i] = Math.max(take, skip)\\n            }\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        var dp = IntArray(N + 2) { 0 }\\n        for (i in N - 1 downTo 0) {\\n            var take = dp[i + 2] + A[i]\\n            var skip = dp[i + 1]\\n            dp[i] = Math.max(take, skip)\\n        }\\n        return dp[0]\\n    }\\n}\\n```\\n\\n4. Optimize Memory, ie. sliding window a, b, c = dp[i + 2], dp[i + 1], dp[i]\\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        var (a, b, c) = listOf(0, 0, 0)\\n        for (i in N - 1 downTo 0) {\\n            var take = a + A[i]\\n            var skip = b\\n            c = Math.max(take, skip)\\n            a = b; b = c\\n        }\\n        return c\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nlet rob = A => {\\n    let N = A.length;\\n    let go = (i = 0) => {\\n        if (N <= i)\\n            return 0;\\n        let take = go(i + 2) + A[i],\\n            skip = go(i + 1);\\n        return Math.max(take, skip);\\n    };\\n    return go();\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via memo\\n```\\nlet rob = (A, m = new Map()) => {\\n    let N = A.length;\\n    let go = (i = 0) => {\\n        if (N <= i)\\n            return 0;\\n        if (!m.has(i)) {\\n            let take = go(i + 2) + A[i],\\n                skip = go(i + 1);\\n            m.set(i, Math.max(take, skip));\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nlet rob = A => {\\n    let N = A.length;\\n    let dp = Array(N + 2).fill(0);\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let take = dp[i + 2] + A[i],\\n            skip = dp[i + 1];\\n        dp[i] = Math.max(take, skip);\\n    }\\n    return dp[0];\\n};\\n```\\n\\n4. Optimize Memory, ie. sliding window a, b, c = dp[i + 2], dp[i + 1], dp[i]\\n```\\nlet rob = A => {\\n    let N = A.length;\\n    let [a, b, c] = [0, 0, 0];\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let take = a + A[i],\\n            skip = b;\\n        c = Math.max(take, skip);\\n        a = b, b = c;\\n    }\\n    return c;\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        def go(i = 0):\\n            if N <= i:\\n                return 0\\n            take = go(i + 2) + A[i]\\n            skip = go(i + 1)\\n            return max(take, skip)\\n        return go()\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via memo\\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        @cache\\n        def go(i = 0):\\n            if N <= i:\\n                return 0\\n            take = go(i + 2) + A[i]\\n            skip = go(i + 1)\\n            return max(take, skip)\\n        return go()\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        dp = [0] * (N + 2)\\n        for i in range(N - 1, -1, -1):\\n            take = dp[i + 2] + A[i]\\n            skip = dp[i + 1]\\n            dp[i] = max(take, skip)\\n        return dp[0]\\n```\\n\\n4. Optimize Memory, ie. sliding window a, b, c = dp[i + 2], dp[i + 1], dp[i]\\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        a, b, c = 0, 0, 0\\n        for i in range(N - 1, -1, -1):\\n            take = a + A[i]\\n            skip = b\\n            c = max(take, skip)\\n            a = b; b = c\\n        return c\\n```\\n\\n---\\n\\n**C++ Solutions**\\n\\n1. **A**ll possibilities are considered via top-down brute-force depth-first-search\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        fun go = [&](auto i) {\\n            if (N <= i)\\n                return 0;\\n            auto take = go(i + 2) + A[i],\\n                 skip = go(i + 1);\\n            return max(take, skip);\\n        };\\n        return go(0);\\n    }\\n};\\n```\\n\\n2. **R**emember each subproblem\\'s optimal solution via memo\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int rob(VI& A, Map m = {}) {\\n        int N = A.size();\\n        fun go = [&](auto i) {\\n            if (N <= i)\\n                return 0;\\n            if (m.find(i) == m.end()) {\\n                auto take = go(i + 2) + A[i],\\n                     skip = go(i + 1);\\n                m[i] = max(take, skip);\\n            }\\n            return m[i];\\n        };\\n        return go(0);\\n    }\\n};\\n```\\n\\n3. **T**urn the top-down solution upside-down to create the bottom-up solution\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        VI dp(N + 2);\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            auto take = dp[i + 2] + A[i],\\n                 skip = dp[i + 1];\\n            dp[i] = max(take, skip);\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n\\n4. Optimize Memory, ie. sliding window a, b, c = dp[i + 2], dp[i + 1], dp[i]\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        auto [a, b, c] = make_tuple(0, 0, 0);\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            auto take = a + A[i],\\n                 skip = b;\\n            c = max(take, skip);\\n            a = b, b = c;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        fun go(i: Int = 0): Int {\\n            if (N <= i)\\n                return 0\\n            var take = go(i + 2) + A[i]\\n            var skip = go(i + 1)\\n            return Math.max(take, skip)\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        var m = mutableMapOf<Int, Int>()\\n        fun go(i: Int = 0): Int {\\n            if (N <= i)\\n                return 0\\n            if (!m.contains(i)) {\\n                var take = go(i + 2) + A[i]\\n                var skip = go(i + 1)\\n                m[i] = Math.max(take, skip)\\n            }\\n            return m[i]!!\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        var dp = IntArray(N + 2) { 0 }\\n        for (i in N - 1 downTo 0) {\\n            var take = dp[i + 2] + A[i]\\n            var skip = dp[i + 1]\\n            dp[i] = Math.max(take, skip)\\n        }\\n        return dp[0]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun rob(A: IntArray): Int {\\n        var N = A.size\\n        var (a, b, c) = listOf(0, 0, 0)\\n        for (i in N - 1 downTo 0) {\\n            var take = a + A[i]\\n            var skip = b\\n            c = Math.max(take, skip)\\n            a = b; b = c\\n        }\\n        return c\\n    }\\n}\\n```\n```\\nlet rob = A => {\\n    let N = A.length;\\n    let go = (i = 0) => {\\n        if (N <= i)\\n            return 0;\\n        let take = go(i + 2) + A[i],\\n            skip = go(i + 1);\\n        return Math.max(take, skip);\\n    };\\n    return go();\\n};\\n```\n```\\nlet rob = (A, m = new Map()) => {\\n    let N = A.length;\\n    let go = (i = 0) => {\\n        if (N <= i)\\n            return 0;\\n        if (!m.has(i)) {\\n            let take = go(i + 2) + A[i],\\n                skip = go(i + 1);\\n            m.set(i, Math.max(take, skip));\\n        }\\n        return m.get(i);\\n    };\\n    return go();\\n};\\n```\n```\\nlet rob = A => {\\n    let N = A.length;\\n    let dp = Array(N + 2).fill(0);\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let take = dp[i + 2] + A[i],\\n            skip = dp[i + 1];\\n        dp[i] = Math.max(take, skip);\\n    }\\n    return dp[0];\\n};\\n```\n```\\nlet rob = A => {\\n    let N = A.length;\\n    let [a, b, c] = [0, 0, 0];\\n    for (let i = N - 1; 0 <= i; --i) {\\n        let take = a + A[i],\\n            skip = b;\\n        c = Math.max(take, skip);\\n        a = b, b = c;\\n    }\\n    return c;\\n};\\n```\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        def go(i = 0):\\n            if N <= i:\\n                return 0\\n            take = go(i + 2) + A[i]\\n            skip = go(i + 1)\\n            return max(take, skip)\\n        return go()\\n```\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        @cache\\n        def go(i = 0):\\n            if N <= i:\\n                return 0\\n            take = go(i + 2) + A[i]\\n            skip = go(i + 1)\\n            return max(take, skip)\\n        return go()\\n```\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        dp = [0] * (N + 2)\\n        for i in range(N - 1, -1, -1):\\n            take = dp[i + 2] + A[i]\\n            skip = dp[i + 1]\\n            dp[i] = max(take, skip)\\n        return dp[0]\\n```\n```\\nclass Solution:\\n    def rob(self, A: List[int]) -> int:\\n        N = len(A)\\n        a, b, c = 0, 0, 0\\n        for i in range(N - 1, -1, -1):\\n            take = a + A[i]\\n            skip = b\\n            c = max(take, skip)\\n            a = b; b = c\\n        return c\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        fun go = [&](auto i) {\\n            if (N <= i)\\n                return 0;\\n            auto take = go(i + 2) + A[i],\\n                 skip = go(i + 1);\\n            return max(take, skip);\\n        };\\n        return go(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Map = unordered_map<int, int>;\\n    int rob(VI& A, Map m = {}) {\\n        int N = A.size();\\n        fun go = [&](auto i) {\\n            if (N <= i)\\n                return 0;\\n            if (m.find(i) == m.end()) {\\n                auto take = go(i + 2) + A[i],\\n                     skip = go(i + 1);\\n                m[i] = max(take, skip);\\n            }\\n            return m[i];\\n        };\\n        return go(0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        VI dp(N + 2);\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            auto take = dp[i + 2] + A[i],\\n                 skip = dp[i + 1];\\n            dp[i] = max(take, skip);\\n        }\\n        return dp[0];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int rob(VI& A) {\\n        int N = A.size();\\n        auto [a, b, c] = make_tuple(0, 0, 0);\\n        for (auto i{ N - 1 }; 0 <= i; --i) {\\n            auto take = a + A[i],\\n                 skip = b;\\n            c = max(take, skip);\\n            a = b, b = c;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55859,
                "title": "0ms-java-solution-using-dp-o-n-time-with-explanation",
                "content": "let sum[i] be the maximum amount of money when robber comes at i, he can either rob it or not depending on the money robbed at i-1 and i-2.\\n\\ncorner case: sum[0] = num[0], sum[1] = max(num[0],num[1])\\n\\ngenerally, at position i, sum[i] = max(sum[i-1], sum[i-2]+num[i])\\n\\n    public int rob(int[] nums) {\\n        int size = nums.length;\\n        if(size == 0) return 0;\\n        int[] sum = new int[size];\\n        sum[0] = nums[0];\\n        if(size == 1) return sum[0];\\n        sum[1] = Math.max(sum[0],nums[1]);\\n        if(size == 2) return sum[1];\\n        for(int i = 2;i<size;i++){\\n            sum[i] = Math.max(sum[i-1], sum[i-2]+nums[i]);\\n        }\\n        return sum[size-1];\\n    }\\n\\nAnother approach is to use two variables to store sum[i-1] and sum[i-2] iteratively in the previous program. This approach avoids building an array to store all of the sums, which only uses O(1) space.\\n\\n    public int rob(int[] nums) {\\n        int size = nums.length;\\n        if(size == 0) return 0;\\n        if(size == 1) return nums[0];\\n        if(size == 2) return Math.max(nums[0],nums[1]);\\n        int minusOne = Math.max(nums[0],nums[1]), minusTwo = nums[0], sum = minusOne;\\n        for(int i = 2;i<size;i++){\\n            sum = Math.max(minusOne, minusTwo+nums[i]);\\n            minusTwo = minusOne;\\n            minusOne = sum;\\n        }\\n        return sum;\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "let sum[i] be the maximum amount of money when robber comes at i, he can either rob it or not depending on the money robbed at i-1 and i-2.\\n\\ncorner case: sum[0] = num[0], sum[1] = max(num[0],num[1])\\n\\ngenerally, at position i, sum[i] = max(sum[i-1], sum[i-2]+num[i])\\n\\n    public int rob(int[] nums) {\\n        int size = nums.length;\\n        if(size == 0) return 0;\\n        int[] sum = new int[size];\\n        sum[0] = nums[0];\\n        if(size == 1) return sum[0];\\n        sum[1] = Math.max(sum[0],nums[1]);\\n        if(size == 2) return sum[1];\\n        for(int i = 2;i<size;i++){\\n            sum[i] = Math.max(sum[i-1], sum[i-2]+nums[i]);\\n        }\\n        return sum[size-1];\\n    }\\n\\nAnother approach is to use two variables to store sum[i-1] and sum[i-2] iteratively in the previous program. This approach avoids building an array to store all of the sums, which only uses O(1) space.\\n\\n    public int rob(int[] nums) {\\n        int size = nums.length;\\n        if(size == 0) return 0;\\n        if(size == 1) return nums[0];\\n        if(size == 2) return Math.max(nums[0],nums[1]);\\n        int minusOne = Math.max(nums[0],nums[1]), minusTwo = nums[0], sum = minusOne;\\n        for(int i = 2;i<size;i++){\\n            sum = Math.max(minusOne, minusTwo+nums[i]);\\n            minusTwo = minusOne;\\n            minusOne = sum;\\n        }\\n        return sum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 55902,
                "title": "simple-java-5-line-solution-o-n-time-o-1-space",
                "content": "    if(num.length==0) return 0;\\n    if(num.length==1) return num[0];\\n    num[1] = Math.max(num[0], num[1]);\\n    for(int i=2;i<num.length;i++) num[i] = Math.max(num[i]+num[i-2], num[i-1]);\\n    return num[num.length-1];",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    if(num.length==0) return 0;\\n    if(num.length==1) return num[0];\\n    num[1] = Math.max(num[0], num[1]);\\n    for(int i=2;i<num.length;i++) num[i] = Math.max(num[i]+num[i-2], num[i-1]);\\n    return num[num.length-1];",
                "codeTag": "Unknown"
            },
            {
                "id": 3218951,
                "title": "198-solution-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. We first check if the input array nums is empty. If it is, we return 0, since we cannot rob any houses.\\n2. We then check if the length of nums is 1. If it is, we can only rob the single house, so we return the value of that house.\\n3. We create a list dp of the same length as nums, initialized to 0.\\n4. We set dp[0] to the value of the first house, since we can only rob that house if there is only one house.\\n5. We set dp[1] to the maximum of the first two houses, since we can only rob one of them.\\n6. We loop over the rest of the houses in nums, starting from the third house (index 2), and for each house, we calculate the maximum amount we can rob up to that house, by choosing whether to rob the current house or the previous house. We use the formula dp[i] = max(dp[i-1], dp[i-2] + nums[i]) to calculate this value.\\n7. Finally, we return the last value in dp, which represents the maximum amount we can rob from all the houses.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        dp = [0] * len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        \\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\\n        \\n        return dp[-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        \\n        if len(nums) == 1:\\n            return nums[0]\\n        \\n        dp = [0] * len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        \\n        for i in range(2, len(nums)):\\n            dp[i] = max(dp[i-1], dp[i-2] + nums[i])\\n        \\n        return dp[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909869,
                "title": "python-bottom-up",
                "content": "# Code\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n\\n        prev2 = nums[0]\\n        moneyRobbed = prev1 = max(nums[0], nums[1])\\n\\n        for i in range(2, len(nums)):\\n            moneyRobbed = max(prev1, prev2+nums[i])\\n\\n            prev2 = prev1\\n            prev1 = moneyRobbed\\n\\n        return moneyRobbed\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) == 1:\\n            return nums[0]\\n\\n        prev2 = nums[0]\\n        moneyRobbed = prev1 = max(nums[0], nums[1])\\n\\n        for i in range(2, len(nums)):\\n            moneyRobbed = max(prev1, prev2+nums[i])\\n\\n            prev2 = prev1\\n            prev1 = moneyRobbed\\n\\n        return moneyRobbed\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909848,
                "title": "c-short-and-fast-o-n-o-1",
                "content": "# Intuition\\n- We start by assuming that we have robbed the first house. (prev = nums[0])\\n- Hence we can\\'t pick the just next element. \\n- If we robb the house which is 2nd to the the current index ( if(i>1) non-adjacent). We have to add that money. \\n- And if we do not pick the house to robb. We are left with 1st house money. \\n- Lastly we take the max of both the conditions. And update the variables for further computations. \\n\\n# Approach\\n- We start using pick and Not pick method. \\n\\n# Complexity\\n- Time complexity: O(N) Single Pass \\n- Space complexity: O(1) No extra Space \\n\\n# Code\\n```\\n    int rob( vector<int>& nums ) {\\n        int n = nums.size();\\n        \\n        int prev = nums[0];\\n        int prev2 = 0;\\n\\n        for( int i=1 ; i<n ; i++ ){\\n            \\n            int pick = nums[i];\\n            if( i>1 ) pick += prev2 ;\\n\\n            int notPick = prev ;  \\n\\n            int curr = max( pick, notPick );\\n            prev2 = prev ;\\n            prev = curr ;\\n        }\\n\\n        return prev ;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    int rob( vector<int>& nums ) {\\n        int n = nums.size();\\n        \\n        int prev = nums[0];\\n        int prev2 = 0;\\n\\n        for( int i=1 ; i<n ; i++ ){\\n            \\n            int pick = nums[i];\\n            if( i>1 ) pick += prev2 ;\\n\\n            int notPick = prev ;  \\n\\n            int curr = max( pick, notPick );\\n            prev2 = prev ;\\n            prev = curr ;\\n        }\\n\\n        return prev ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2909820,
                "title": "c-4-approaches-easy-to-understand",
                "content": "# Code\\n\\n**Approach 1: (Recursion : TLE)**\\n```\\nclass Solution {\\npublic:\\n    int find(int idx,vector<int>& nums)\\n    {\\n        if(idx==0) return nums[0];                // if i am on last then take that\\n\\n        int not_pick = 0 + find(idx-1,nums);   // not robbing curr house so can rob adjacency house\\n        int pick = nums[idx];\\n        if(idx-2 >= 0)\\n        {\\n            pick += find(idx-2,nums);          // robbing curr house so can not rob adjacency house\\n        }\\n\\n        return max(pick,not_pick);               // take max from both\\n    }\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        return find(n-1,nums,dp);\\n    }\\n};\\n# Complexity\\n# Time complexity : O(2^N) (recursion)\\n\\n# Space complexity : O(N) (recursion auxiliary space)\\n```\\n\\nApproach 2: (Memoization)\\n```\\nclass Solution {\\npublic:\\n    int find(int idx,vector<int>& nums,vector<int>& dp)\\n    {\\n        if(idx==0) return nums[0];\\n        if(dp[idx] != -1) return dp[idx];\\n\\n        int not_pick = 0 + find(idx-1,nums,dp);\\n        int pick = nums[idx];\\n        if(idx-2 >= 0)\\n        {\\n            pick += find(idx-2,nums,dp);\\n        }\\n\\n        return dp[idx] = max(pick,not_pick);\\n    }\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        return find(n-1,nums,dp);\\n    }\\n};\\n\\n# Complexity\\n# Time complexity : O(N) (recursion)\\n\\n# Space complexity : O(N) + O(N) (recursion auxiliary space)\\n``` \\n\\n\\nApproach 3: (Tabulation : Accepted)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n\\n        vector<int> dp(n,0);\\n        dp[0] = nums[0];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            int not_pick = 0 + dp[i-1];\\n            int pick = nums[i];\\n            if(i-2 >= 0)\\n            {\\n                pick += dp[i-2];\\n            }\\n\\n            dp[i] = max(pick,not_pick);\\n        }\\n\\n        return dp[n-1];\\n    }\\n};\\n# Complexity\\n# Time complexity : O(N)\\n\\n# Space complexity : O(N)\\n```\\n\\nApproach 4: (Space Optimization)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n\\n        int prev1 = nums[0];\\n        int prev2 = 0;\\n\\n        int curr;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            int not_pick = 0 + prev1;\\n            int pick = nums[i];\\n            if(i-2 >= 0)\\n            {\\n                pick += prev2;\\n            }\\n            curr = max(pick,not_pick);\\n\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n\\n        return prev1;\\n    }\\n};\\n# Complexity\\n# Time complexity : O(N)\\n\\n# Space complexity : O(1)\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int idx,vector<int>& nums)\\n    {\\n        if(idx==0) return nums[0];                // if i am on last then take that\\n\\n        int not_pick = 0 + find(idx-1,nums);   // not robbing curr house so can rob adjacency house\\n        int pick = nums[idx];\\n        if(idx-2 >= 0)\\n        {\\n            pick += find(idx-2,nums);          // robbing curr house so can not rob adjacency house\\n        }\\n\\n        return max(pick,not_pick);               // take max from both\\n    }\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        return find(n-1,nums,dp);\\n    }\\n};\\n# Complexity\\n# Time complexity : O(2^N) (recursion)\\n\\n# Space complexity : O(N) (recursion auxiliary space)\\n```\n```\\nclass Solution {\\npublic:\\n    int find(int idx,vector<int>& nums,vector<int>& dp)\\n    {\\n        if(idx==0) return nums[0];\\n        if(dp[idx] != -1) return dp[idx];\\n\\n        int not_pick = 0 + find(idx-1,nums,dp);\\n        int pick = nums[idx];\\n        if(idx-2 >= 0)\\n        {\\n            pick += find(idx-2,nums,dp);\\n        }\\n\\n        return dp[idx] = max(pick,not_pick);\\n    }\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n        vector<int> dp(n,-1);\\n        return find(n-1,nums,dp);\\n    }\\n};\\n\\n# Complexity\\n# Time complexity : O(N) (recursion)\\n\\n# Space complexity : O(N) + O(N) (recursion auxiliary space)\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n\\n        vector<int> dp(n,0);\\n        dp[0] = nums[0];\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            int not_pick = 0 + dp[i-1];\\n            int pick = nums[i];\\n            if(i-2 >= 0)\\n            {\\n                pick += dp[i-2];\\n            }\\n\\n            dp[i] = max(pick,not_pick);\\n        }\\n\\n        return dp[n-1];\\n    }\\n};\\n# Complexity\\n# Time complexity : O(N)\\n\\n# Space complexity : O(N)\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        if(n==1) return nums[0];\\n\\n        int prev1 = nums[0];\\n        int prev2 = 0;\\n\\n        int curr;\\n\\n        for(int i=1;i<n;i++)\\n        {\\n            int not_pick = 0 + prev1;\\n            int pick = nums[i];\\n            if(i-2 >= 0)\\n            {\\n                pick += prev2;\\n            }\\n            curr = max(pick,not_pick);\\n\\n            prev2 = prev1;\\n            prev1 = curr;\\n        }\\n\\n        return prev1;\\n    }\\n};\\n# Complexity\\n# Time complexity : O(N)\\n\\n# Space complexity : O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909756,
                "title": "java-memoization-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Memoization, inspired by 0/1 knapsack.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake element at index i or skip it.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nimport java.lang.*;\\nclass Solution {\\n\\n    public int helper(int[] nums, int i,HashMap<Integer,Integer> memo){\\n        if(memo.containsKey(i)){\\n            return memo.get(i);\\n        }\\n        if(i >= nums.length){\\n            return 0;\\n        }\\n        int notTake = 0;\\n        int take= nums[i]+helper(nums,i+2,memo);\\n        if (i < nums.length-1)    \\n            notTake = nums[i+1]+helper(nums,i+3,memo);\\n        memo.put(i,Math.max(take,notTake));\\n        return memo.get(i);\\n    }\\n    public int rob(int[] nums) {\\n        return helper(nums,0, new HashMap<Integer,Integer>());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.lang.*;\\nclass Solution {\\n\\n    public int helper(int[] nums, int i,HashMap<Integer,Integer> memo){\\n        if(memo.containsKey(i)){\\n            return memo.get(i);\\n        }\\n        if(i >= nums.length){\\n            return 0;\\n        }\\n        int notTake = 0;\\n        int take= nums[i]+helper(nums,i+2,memo);\\n        if (i < nums.length-1)    \\n            notTake = nums[i+1]+helper(nums,i+3,memo);\\n        memo.put(i,Math.max(take,notTake));\\n        return memo.get(i);\\n    }\\n    public int rob(int[] nums) {\\n        return helper(nums,0, new HashMap<Integer,Integer>());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909722,
                "title": "c-simple-dp-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dp[1000] = {0};\\n\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        dp[0] = nums[0];\\n        if(n == 1)return nums[0];\\n        dp[1] = max(nums[1],nums[0]);\\n        for(int i = 2; i < n; i++)\\n        {\\n            dp[i] = max(dp[i-1],nums[i]+dp[i-2]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dp[1000] = {0};\\n\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        dp[0] = nums[0];\\n        if(n == 1)return nums[0];\\n        dp[1] = max(nums[1],nums[0]);\\n        for(int i = 2; i < n; i++)\\n        {\\n            dp[i] = max(dp[i-1],nums[i]+dp[i-2]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909274,
                "title": "java-0ms-100-beats",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        if(nums.length == 2) return Math.max(nums[0],nums[1]);\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        dp[1] = Math.max(nums[1],nums[0]);\\n        for(int i = 2 ; i < nums.length ; i++){\\n            dp[i] = Math.max(nums[i]+dp[i-2],dp[i-1]);\\n        }\\n        return dp[nums.length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length == 0) return 0;\\n        if(nums.length == 1) return nums[0];\\n        if(nums.length == 2) return Math.max(nums[0],nums[1]);\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        dp[1] = Math.max(nums[1],nums[0]);\\n        for(int i = 2 ; i < nums.length ; i++){\\n            dp[i] = Math.max(nums[i]+dp[i-2],dp[i-1]);\\n        }\\n        return dp[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995444,
                "title": "c-dp-memoization-tabulation-space-optimization-o-1-space",
                "content": "**Approach 01 : Memoization/Top-Down DP (aka Recursive DP)**\\n\\nIdea : In every state of DP we have only two choice , eighter we will include current element in our result (with under the condition)  or we will skip the current (for be more banifited)\\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    \\n    int solve(int now , vector<int>& nums, vector<int>& DP){\\n        if(now >= nums.size()){\\n            return 0;\\n        }\\n        int &ret = DP[now];\\n        if(ret != -1) return ret;\\n        \\n        int w1 = 0, w2 = 0;\\n        w1 = solve(now+1, nums, DP);\\n        w2 = nums[now] + solve(now+2, nums, DP); \\n        return ret = max(w1, w2);;\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int N = nums.size();\\n        vector<int>DP(N, -1);\\n        \\n        int result = solve(0, nums, DP);\\n        return result;\\n    }\\n};\\n```\\n\\nTime Complexity : **O(N)**\\nSpace Complexity : **O(N)** for iterate all of the N item + **O(N)** space also required for Recursion stack Memory\\nso Total Space will be : **O(N)+O(N) ~ O(N)**.\\n\\n\\n**Approach 02 : Tabulation/ Buttom-Up DP (aka Iterative DP)**\\n\\nIdea : Idea is as simple as approach 01.\\n\\n**Code : **\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int N = nums.size();\\n        \\n        if(N==0) return 0;\\n        if(N==1) return nums[0];\\n        \\n        vector<int>DP(N);\\n        DP[0] = nums[0];\\n        DP[1] = max(nums[0], nums[1]);\\n        \\n        for(int i=2; i<N; i++){\\n            DP[i] = max(DP[i-1], nums[i]+ DP[i-2]);\\n        }\\n        return DP[N-1];\\n    }\\n};\\n```\\n\\nTime Complexity : **O(N)** \\nSpace Complexity : **O(N)** , we omitted our recursion stack memory here :)\\n\\n**Approach 03: Space Optimization of Approach 02.**\\n\\nIdea : In approach 02 , we clearly see that we need only last two value for compute the current state. so we don\\'t need to store all previous state\\'s value at all. Here we will store only **previous** and **secondPrevious** value for compute the **current state**.\\n\\n**Code : **\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int N = nums.size();\\n        if(N==1) return nums[0];\\n        \\n        int prev = nums[0], secondPrev = 0, current;\\n        \\n        for(int i=1; i<N; i++){\\n            \\n            current = nums[i] + secondPrev;\\n            current = max(current, prev);\\n            \\n            secondPrev = prev;\\n            prev = current;\\n        }\\n        return prev;\\n    }\\n};\\n```\\n\\nTime Complexity : **O(N)** , to comute every state of DP.\\nSpace Complexity : **O(1)**, we use only constant space here.\\n\\n\\nThanks for Reading....\\nHappy learning :)\\nPlease Upvote if helpful :)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int solve(int now , vector<int>& nums, vector<int>& DP){\\n        if(now >= nums.size()){\\n            return 0;\\n        }\\n        int &ret = DP[now];\\n        if(ret != -1) return ret;\\n        \\n        int w1 = 0, w2 = 0;\\n        w1 = solve(now+1, nums, DP);\\n        w2 = nums[now] + solve(now+2, nums, DP); \\n        return ret = max(w1, w2);;\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int N = nums.size();\\n        vector<int>DP(N, -1);\\n        \\n        int result = solve(0, nums, DP);\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int N = nums.size();\\n        \\n        if(N==0) return 0;\\n        if(N==1) return nums[0];\\n        \\n        vector<int>DP(N);\\n        DP[0] = nums[0];\\n        DP[1] = max(nums[0], nums[1]);\\n        \\n        for(int i=2; i<N; i++){\\n            DP[i] = max(DP[i-1], nums[i]+ DP[i-2]);\\n        }\\n        return DP[N-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int N = nums.size();\\n        if(N==1) return nums[0];\\n        \\n        int prev = nums[0], secondPrev = 0, current;\\n        \\n        for(int i=1; i<N; i++){\\n            \\n            current = nums[i] + secondPrev;\\n            current = max(current, prev);\\n            \\n            secondPrev = prev;\\n            prev = current;\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791061,
                "title": "python-3-50ms-3-lines-dp-formula",
                "content": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        last, now = 0, 0\\n        for i in nums: last, now = now, max(last + i, now)\\n        return now\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        last, now = 0, 0\\n        for i in nums: last, now = now, max(last + i, now)\\n        return now\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354469,
                "title": "dp-using-memoization-easy-understanding",
                "content": "class Solution {\\n    public int rob(int[] nums) {\\n        int[] dp = new int[nums.length+1];\\n        Arrays.fill(dp, -1);\\n        int res = houseRob(nums, 0, nums.length, dp);\\n        return(res);\\n    }\\n    \\n    public static int houseRob(int[] nums, int curr, int n, int[] dp){\\n        if(curr >= n){ \\n            return 0;\\n        }\\n        if(dp[curr] != -1) return dp[curr];\\n        \\n        // First time calculation\\n        int rob = nums[curr] + houseRob(nums, curr+2, n, dp);\\n        int doNot = houseRob(nums, curr+1, n, dp);\\n        \\n        return dp[curr] = Math.max(rob, doNot);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public int rob(int[] nums) {\\n        int[] dp = new int[nums.length+1];\\n        Arrays.fill(dp, -1);\\n        int res = houseRob(nums, 0, nums.length, dp);\\n        return(res);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 835280,
                "title": "python-solution-good-explanation",
                "content": "We build dp[]. Suppose we are at the first house on the block, what is the most money we can make by being here? Well we can rob this house and make that much money, so dp[0] = nums[0]. Suppose we are at the second house on the block, what is the most money we can make by being here? Well we can either rob the first house and not rob the second or we can rob the second and not rob the first. We choose whichever makes us more money, so dp[1] = max(nums[0], nums[1]). Now suppose you are at the ith house, what is the most money we can make by being here? There are 2 cases. **Case 1:** If we rob the ith house that means we could not have robbed the i - 1th house because they are adjacent, so we could make dp[i - 2] + nums[i]. **Case 2:** If we dont rob the ith house then we should have robbed the i - 1th. I hope this helped someone.\\n```\\ndef rob(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        if len(nums) == 1:\\n            return nums[0]\\n        if len(nums) == 2:\\n            return max(nums[0], nums[1])\\n\\t\\tdp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            dp[i] = max(nums[i] + dp[i - 2], dp[i - 1])\\n        return dp[len(nums) - 1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef rob(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        if len(nums) == 1:\\n            return nums[0]\\n        if len(nums) == 2:\\n            return max(nums[0], nums[1])\\n\\t\\tdp = [0]*len(nums)\\n        dp[0] = nums[0]\\n        dp[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            dp[i] = max(nums[i] + dp[i - 2], dp[i - 1])\\n        return dp[len(nums) - 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 824923,
                "title": "javascript-solution-198",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nlet rob = function(nums) {\\n    let previous = 0;\\n    let current = 0;\\n    let temp; \\n    for (let x of nums) {\\n        temp = current; \\n        current = Math.max(x+previous, current);\\n        previous = temp;\\n    }\\n    return current;\\n}\\n```\\n**Runtime: 68 ms, faster than 90.14% of JavaScript online submissions for House Robber.**\\n**Memory Usage: 36.9 MB, less than 16.04% of JavaScript online submissions for House Robber.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nlet rob = function(nums) {\\n    let previous = 0;\\n    let current = 0;\\n    let temp; \\n    for (let x of nums) {\\n        temp = current; \\n        current = Math.max(x+previous, current);\\n        previous = temp;\\n    }\\n    return current;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 488741,
                "title": "python-3-dp-recursion-93-100-tutorial-url-included",
                "content": "First time trying DP after 20 min Youtube learning and it\\'s interesting!\\nIf you are not familiar with DP, these videos are really helpful:\\nhttps://www.youtube.com/watch?v=vYquumk4nWw\\nhttps://www.youtube.com/watch?v=xOlhR_2QCXY\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:  \\n        n = len(nums)\\n        if not n:\\n            return 0        \\n        memo = [None] * n\\n        \\n        def steal(n):\\n            if memo[n] != None:\\n                return memo[n]\\n            if n == 0:\\n                result = nums[0]\\n            elif n == 1:\\n                result = max(nums[0], nums[1])\\n            else:\\n                result = max(steal(n-1),  nums[n] + steal(n-2))\\n            memo[n] = result\\n            return result\\n\\t\\t\\t\\n        return steal(n-1)\\n```\\n\\nThe bottom-up scheme has the same intuition thus also works.\\nHope these video help you. :)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:  \\n        n = len(nums)\\n        if not n:\\n            return 0        \\n        memo = [None] * n\\n        \\n        def steal(n):\\n            if memo[n] != None:\\n                return memo[n]\\n            if n == 0:\\n                result = nums[0]\\n            elif n == 1:\\n                result = max(nums[0], nums[1])\\n            else:\\n                result = max(steal(n-1),  nums[n] + steal(n-2))\\n            memo[n] = result\\n            return result\\n\\t\\t\\t\\n        return steal(n-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55675,
                "title": "96-5-python-sol",
                "content": "``` class Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count = len(nums)\\n        if count == 0:\\n            return 0\\n        elif count == 1:\\n            return nums[0]\\n        elif count == 2: \\n            return max(nums[0], nums[1])\\n        \\n        memo = nums[:] # copy\\n        memo[1] = max(nums[0], nums[1])\\n        \\n        for i in range(2, count):\\n            memo[i] = max(memo[i-1], nums[i] + memo[i-2]) \\n        \\n        return memo[count-1] ```",
                "solutionTags": [],
                "code": "``` class Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        count = len(nums)\\n        if count == 0:\\n            return 0\\n        elif count == 1:\\n            return nums[0]\\n        elif count == 2: \\n            return max(nums[0], nums[1])\\n        \\n        memo = nums[:] # copy\\n        memo[1] = max(nums[0], nums[1])\\n        \\n        for i in range(2, count):\\n            memo[i] = max(memo[i-1], nums[i] + memo[i-2]) \\n        \\n        return memo[count-1] ```",
                "codeTag": "Java"
            },
            {
                "id": 55687,
                "title": "python-easy-to-understand-solution",
                "content": "dp[i] contains max amount that robber can take from house i \\nAt each index, we check for the max amount from 0 to index - 1, since we can't take the adjacent house's money\\nand we add the current amount to the max amount\\n\\n```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums: return 0\\n        \\n        dp = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                dp[i] = nums[i] + max(dp[:i-1])\\n            else:\\n                dp[i] = nums[i]\\n        return max(dp)\\n```\\nO(n) time and space complexity",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if not nums: return 0\\n        \\n        dp = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                dp[i] = nums[i] + max(dp[:i-1])\\n            else:\\n                dp[i] = nums[i]\\n        return max(dp)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55906,
                "title": "easy-to-understand-python-solutions-dynamic-programming",
                "content": "        \\n    # O(n) space\\n    def rob1(self, nums):\\n        if not nums:\\n            return 0\\n        if len(nums) <= 2:\\n            return max(nums)\\n        res = [0] * len(nums)\\n        res[0], res[1] = nums[0], max(nums[0], nums[1])\\n        for i in xrange(2, len(nums)):\\n            res[i] = max(nums[i]+res[i-2], res[i-1])\\n        return res[-1]\\n    \\n    def rob2(self, nums):\\n        if not nums:\\n            return 0\\n        res = [0] * len(nums)\\n        for i in xrange(len(nums)):\\n            if i == 0:\\n                res[0] = nums[0]\\n            elif i == 1:\\n                res[1] = max(nums[0], nums[1])\\n            else:\\n                res[i] = max(nums[i]+res[i-2], res[i-1])\\n        return res[-1]\\n      \\n    # Constant space  \\n    def rob(self, nums):\\n        if not nums:\\n            return 0\\n        if len(nums) <= 2:\\n            return max(nums)\\n        a, b = nums[0], max(nums[0], nums[1])\\n        for i in xrange(2, len(nums)):\\n            tmp = b\\n            b = max(nums[i]+a, b)\\n            a = tmp\\n        return b",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "        \\n    # O(n) space\\n    def rob1(self, nums):\\n        if not nums:\\n            return 0\\n        if len(nums) <= 2:\\n            return max(nums)\\n        res = [0] * len(nums)\\n        res[0], res[1] = nums[0], max(nums[0], nums[1])\\n        for i in xrange(2, len(nums)):\\n            res[i] = max(nums[i]+res[i-2], res[i-1])\\n        return res[-1]\\n    \\n    def rob2(self, nums):\\n        if not nums:\\n            return 0\\n        res = [0] * len(nums)\\n        for i in xrange(len(nums)):\\n            if i == 0:\\n                res[0] = nums[0]\\n            elif i == 1:\\n                res[1] = max(nums[0], nums[1])\\n            else:\\n                res[i] = max(nums[i]+res[i-2], res[i-1])\\n        return res[-1]\\n      \\n    # Constant space  \\n    def rob(self, nums):\\n        if not nums:\\n            return 0\\n        if len(nums) <= 2:\\n            return max(nums)\\n        a, b = nums[0], max(nums[0], nums[1])\\n        for i in xrange(2, len(nums)):\\n            tmp = b\\n            b = max(nums[i]+a, b)\\n            a = tmp\\n        return b",
                "codeTag": "Python3"
            },
            {
                "id": 55936,
                "title": "java-house-robber-solution",
                "content": "public class Solution {\\n\\n    public int rob(int[] nums) {\\n\\n       if(nums == null || nums.length == 0){\\n           return 0;\\n       }\\n\\n       if(nums.length == 1){\\n           return nums[0];\\n       }\\n\\n       if(nums.length == 2){\\n           return Math.max(nums[0], nums[1]);\\n       }\\n       \\n       \\n       int[] dp = new int[nums.length];\\n       dp[0] = nums[0];\\n       dp[1] = Math.max(nums[0], nums[1]);\\n       \\n       for(int i = 2; i < dp.length; i++){\\n           dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);\\n       }\\n       \\n       return dp[dp.length - 1];\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int rob(int[] nums) {\\n\\n       if(nums == null || nums.length == 0){\\n           return 0;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 55937,
                "title": "0-ms-c-solution",
                "content": "    int rob(vector<int>& nums) {\\n    \\tint len=nums.size();\\n    \\tif(0==len) \\n    \\t\\treturn 0;\\n    \\tvector<int> bag;\\n    \\tif(len>0)  \\n    \\t\\tbag.push_back(nums[0]);\\n    \\tif(len>1) \\n    \\t\\tbag.push_back(max(nums[0],nums[1]));\\n    \\tfor(int i=2;i<len;++i)\\n    \\t\\tbag.push_back(max(bag[i-1],nums[i]+bag[i-2]));\\n    \\treturn bag[len-1];\\n    }",
                "solutionTags": [],
                "code": "    int rob(vector<int>& nums) {\\n    \\tint len=nums.size();\\n    \\tif(0==len) \\n    \\t\\treturn 0;\\n    \\tvector<int> bag;\\n    \\tif(len>0)  \\n    \\t\\tbag.push_back(nums[0]);\\n    \\tif(len>1) \\n    \\t\\tbag.push_back(max(nums[0],nums[1]));\\n    \\tfor(int i=2;i<len;++i)\\n    \\t\\tbag.push_back(max(bag[i-1],nums[i]+bag[i-2]));\\n    \\treturn bag[len-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3940935,
                "title": "putta-easy-solution-c-beats-100",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n    int n = nums.size();\\n    vector<int> dp(n+1,0);\\n    for(int i = 1;i<n+1;i++){\\n        if (i >1)\\n        dp[i] = max(nums[i-1] + dp[i-2] ,dp[i-1]);\\n        else \\n        dp[i] = max(nums[i-1]  ,dp[i-1]);\\n\\n    }  \\n    return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n    int n = nums.size();\\n    vector<int> dp(n+1,0);\\n    for(int i = 1;i<n+1;i++){\\n        if (i >1)\\n        dp[i] = max(nums[i-1] + dp[i-2] ,dp[i-1]);\\n        else \\n        dp[i] = max(nums[i-1]  ,dp[i-1]);\\n\\n    }  \\n    return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372812,
                "title": "easy-clear-python-3-solution-recursive-memo-top-down",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        memo=[-1 for _ in range(len(nums))]\\n        def dp(i):\\n            if i<0:\\n                return 0 \\n            elif memo[i]>=0:\\n                return  memo[i]\\n            else:\\n                res=max(dp(i-2)+nums[i],dp(i-1))\\n                memo[i]=res\\n                return res\\n        return dp(len(nums)-1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        memo=[-1 for _ in range(len(nums))]\\n        def dp(i):\\n            if i<0:\\n                return 0 \\n            elif memo[i]>=0:\\n                return  memo[i]\\n            else:\\n                res=max(dp(i-2)+nums[i],dp(i-1))\\n                memo[i]=res\\n                return res\\n        return dp(len(nums)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911051,
                "title": "concise-and-readable-no-additional-space",
                "content": "```csharp\\npublic class Solution\\n{\\n    public int Rob(int[] nums)\\n    {\\n        int max = nums[0];\\n        int s = 0;\\n\\n        foreach (int n in nums[1..])\\n        {\\n            (max, s) = (Math.Max(n + s, max), max);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public int Rob(int[] nums)\\n    {\\n        int max = nums[0];\\n        int s = 0;\\n\\n        foreach (int n in nums[1..])\\n        {\\n            (max, s) = (Math.Max(n + s, max), max);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909291,
                "title": "100-recursive-easy",
                "content": "# Approach\\nRecursive solve using memorisation, if we have  computed already return if not for any i compute recursively.\\n\\n# Code\\n```\\n\\nclass Solution {\\n    int dp[100] = {0};\\npublic:\\n    Solution(){\\n        for (int i=0 ; i < 100; i++) dp[i] = -1;\\n    }\\n    int rob(vector<int>& nums, int i=0) {\\n        if ( i >= nums.size()) return 0;\\n\\n        if (dp[i] != -1) return dp[i];\\n\\n        return dp[i] = max(nums[i] + rob(nums,i+2), rob(nums,i+1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\n    int dp[100] = {0};\\npublic:\\n    Solution(){\\n        for (int i=0 ; i < 100; i++) dp[i] = -1;\\n    }\\n    int rob(vector<int>& nums, int i=0) {\\n        if ( i >= nums.size()) return 0;\\n\\n        if (dp[i] != -1) return dp[i];\\n\\n        return dp[i] = max(nums[i] + rob(nums,i+2), rob(nums,i+1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909246,
                "title": "c-dp-no-edge-cases-constant-memory-linear-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe solve the following subproblem: What is the optimal sum we can get up to some index?\\n\\nThis is trivial for the first element.\\nAfter that we take the maximum of either the value plus its second last element or just the last element.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe save the maxima for the last and second last elements and iterate over the array.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ - We iterate once over the whole array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: $$O(1)$$ - We only save the results of the last two iterations.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef int32_t i32;\\n\\n\\ninline i32\\nmaximum(i32 x, i32 y)\\n{\\n    return x > y ? x : y;\\n}\\n\\n\\ni32\\nrob(i32 *numbers, size_t numbersLength)\\n{\\n    i32 prePredecessor  = 0;\\n    i32 predecessor     = 0;\\n    i32 current         = 0;\\n\\n    for (size_t index = 0; index < numbersLength; index += 1)\\n    {\\n        prePredecessor  = predecessor;\\n        predecessor     = current;\\n        current         = maximum(prePredecessor + numbers[index], predecessor);\\n    }\\n    \\n    return current;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef int32_t i32;\\n\\n\\ninline i32\\nmaximum(i32 x, i32 y)\\n{\\n    return x > y ? x : y;\\n}\\n\\n\\ni32\\nrob(i32 *numbers, size_t numbersLength)\\n{\\n    i32 prePredecessor  = 0;\\n    i32 predecessor     = 0;\\n    i32 current         = 0;\\n\\n    for (size_t index = 0; index < numbersLength; index += 1)\\n    {\\n        prePredecessor  = predecessor;\\n        predecessor     = current;\\n        current         = maximum(prePredecessor + numbers[index], predecessor);\\n    }\\n    \\n    return current;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2909087,
                "title": "daily-leetcoding-challenge-december-day-14",
                "content": "This problem is the Daily LeetCoding Challenge for December, Day 14.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2806976,
                "title": "house-robber-solution-recursion-memoization-tabulation",
                "content": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        //1.Recursion\\n        //return help(nums.length-1,nums);\\n        \\n        //2.Memoization - Top-down DP\\n        // int[] dp = new int[nums.length];\\n        // for(int i=0; i<dp.length; i++)\\n        // {\\n        //     dp[i] = -1;\\n        // }\\n        // return Memo(nums.length-1,nums,dp);\\n        \\n        //3.Tabulation - Bottom-Up Dp\\n        return DP(nums,nums.length);\\n    }\\n    \\n    int help(int index,int[] nums){\\n        if(index==0)return nums[0];\\n        if(index<0)return 0;\\n           \\n        int include = help(index-2,nums) + nums[index];\\n        int exclude= help(index-1,nums);\\n        \\n        return Math.max(include,exclude);\\n    }\\n    int Memo(int index,int[] nums, int dp[]){\\n        if(index==0)return nums[0];\\n        if(index<0)return 0;\\n        if(dp[index]!=-1)return dp[index];\\n           \\n        int include = Memo(index-2,nums,dp) + nums[index];\\n        int exclude= Memo(index-1,nums,dp);\\n        \\n        return dp[index]=Math.max(include,exclude);\\n    }\\n    int DP(int[] nums, int n){\\n        int dp[] = new int[n];\\n\\n        dp[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            int include = nums[i];\\n            if(i>1){\\n               include = include + dp[i-2];\\n            }  \\n            int exclude = dp[i-1];\\n            dp[i] = Math.max(include,exclude);\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        //1.Recursion\\n        //return help(nums.length-1,nums);\\n        \\n        //2.Memoization - Top-down DP\\n        // int[] dp = new int[nums.length];\\n        // for(int i=0; i<dp.length; i++)\\n        // {\\n        //     dp[i] = -1;\\n        // }\\n        // return Memo(nums.length-1,nums,dp);\\n        \\n        //3.Tabulation - Bottom-Up Dp\\n        return DP(nums,nums.length);\\n    }\\n    \\n    int help(int index,int[] nums){\\n        if(index==0)return nums[0];\\n        if(index<0)return 0;\\n           \\n        int include = help(index-2,nums) + nums[index];\\n        int exclude= help(index-1,nums);\\n        \\n        return Math.max(include,exclude);\\n    }\\n    int Memo(int index,int[] nums, int dp[]){\\n        if(index==0)return nums[0];\\n        if(index<0)return 0;\\n        if(dp[index]!=-1)return dp[index];\\n           \\n        int include = Memo(index-2,nums,dp) + nums[index];\\n        int exclude= Memo(index-1,nums,dp);\\n        \\n        return dp[index]=Math.max(include,exclude);\\n    }\\n    int DP(int[] nums, int n){\\n        int dp[] = new int[n];\\n\\n        dp[0] = nums[0];\\n        for(int i=1; i<n; i++){\\n            int include = nums[i];\\n            if(i>1){\\n               include = include + dp[i-2];\\n            }  \\n            int exclude = dp[i-1];\\n            dp[i] = Math.max(include,exclude);\\n        }\\n        return dp[n-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596573,
                "title": "o-n-time-o-1-space-clean-dp-solution-with-explanation",
                "content": "H1 H2 H3 H4\\n**99** \\n**99** 98\\n**99** 98 **60**\\n**99** 98 60 **100**\\n\\nScenario with 1 house and 2 houses can be decided. For 3 houses scenario, your choices are \\nwhat you would choose with 1 house plus current house OR what you would choose with 2 houses.\\nLikewise, with 4 houses, your choices are what you would choose in 2 houses scenario plus the current house OR just what you would choose with 3 houses.\\nTherefor with N houses, your choices are f(n - 2) + Nth house OR f(n-1).\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if (nums.length == 1)\\n            return nums[0];\\n        if (nums.length == 2)\\n            return Math.max(nums[0], nums[1]);\\n        \\n        int maxSum = 0;\\n        int scheme1 = nums[0];\\n        int scheme2 = Math.max(nums[0], nums[1]);\\n        \\n        for (int i = 2; i < nums.length; i++){\\n            maxSum = Math.max(scheme1 + nums[i], scheme2);\\n            scheme1 = scheme2;\\n            scheme2 = maxSum;\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\\n\\nThe above is for better understanding, the code can be further cleaned up to:\\n```\\n    public int rob(int[] nums) {\\n        if (nums.length == 0)\\n            return 0;\\n        \\n        int scheme1 = 0; //f(n-2)\\n        int scheme2 = 0; //f(n-1)\\n        \\n        for (int i = 0; i < nums.length; i++){\\n            int preScheme = scheme2;\\n            scheme2 = Math.max(scheme1 + nums[i], scheme2);\\n            scheme1 = preScheme;\\n        }\\n        \\n        return scheme2;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if (nums.length == 1)\\n            return nums[0];\\n        if (nums.length == 2)\\n            return Math.max(nums[0], nums[1]);\\n        \\n        int maxSum = 0;\\n        int scheme1 = nums[0];\\n        int scheme2 = Math.max(nums[0], nums[1]);\\n        \\n        for (int i = 2; i < nums.length; i++){\\n            maxSum = Math.max(scheme1 + nums[i], scheme2);\\n            scheme1 = scheme2;\\n            scheme2 = maxSum;\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\n```\\n    public int rob(int[] nums) {\\n        if (nums.length == 0)\\n            return 0;\\n        \\n        int scheme1 = 0; //f(n-2)\\n        int scheme2 = 0; //f(n-1)\\n        \\n        for (int i = 0; i < nums.length; i++){\\n            int preScheme = scheme2;\\n            scheme2 = Math.max(scheme1 + nums[i], scheme2);\\n            scheme1 = preScheme;\\n        }\\n        \\n        return scheme2;\\n    }\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2429533,
                "title": "rust-one-liner-with-comments",
                "content": "Imagine we are standing at house `i`. We can rob the house, but then we can\\'t rob the house before it, so the maximum total we can have is the maximum total we can have at house `i-2`, plus what we get at house `i`. Or we can keep whatever we can get up to house `i-1`, and avoid robbing house `i`. The base case is that without any houses, there is no money to rob, so the initial state for the DP is (0,0).\\n\\nI use `into_iter` to take ownership of nums and iterate over the numbers directly, and not complicate things with references. Then a fold to propagate the state according to the logic above.\\n\\n```\\nimpl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        nums.into_iter().fold((0, 0), |(pp, p), curr| (p, p.max(curr + pp))).1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        nums.into_iter().fold((0, 0), |(pp, p), curr| (p, p.max(curr + pp))).1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1764927,
                "title": "java-4-solutions-recursion-memoization-tabulation-space-optimized-tabulation",
                "content": "```\\n// Method 1-\\n//     Recurion\\n//     TC - O(2^n)\\n//     SC - O(n)\\n    \\nclass Solution {\\n    public int rob(int[] nums) {\\n        return getMaximumSum(nums.length-1,nums);\\n    }\\n    public int getMaximumSum(int index,int [] nums)\\n    {\\n        if(index==0)return nums[index];\\n        if(index<0)return 0;\\n        int pick=nums[index]+ getMaximumSum(index-2,nums);\\n        int notPick=getMaximumSum(index-1,nums);\\n        return Math.max(pick,notPick);\\n    }\\n        \\n}\\n// Method 2 -\\n//     Using Memoization\\n//     TC - O(n)\\n//     SC - O(n)+O(n)\\n    \\nclass Solution {\\n    public int rob(int[] nums) {\\n        int dp[]=new int[nums.length];\\n        Arrays.fill(dp,-1);\\n        return getMaximumSum(nums.length-1,nums,dp);\\n    }\\n    public int getMaximumSum(int index,int [] nums,int []dp)\\n    {\\n        if(index==0)return nums[index];\\n        if(index<0)return 0;\\n        if(dp[index]!=-1)return dp[index];\\n        int pick=nums[index]+ getMaximumSum(index-2,nums,dp);\\n        int notPick=getMaximumSum(index-1,nums,dp);\\n        dp[index]=Math.max(pick,notPick);\\n        return dp[index];\\n    }\\n        \\n}\\n\\n// Method 3-\\n//     Using Tabulation\\n//     SC - O(n)\\n//     TC -O(n)\\n    \\nclass Solution {\\n    public int rob(int[] nums) {\\n        int dp[]=new int[nums.length];\\n        Arrays.fill(dp,-1);\\n        dp[0]=nums[0];\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            int pick=nums[i];\\n            if(i>1)pick+=dp[i-2];\\n            int notPick=dp[i-1];\\n            dp[i]=Math.max(pick,notPick);\\n        }\\n        return dp[nums.length-1];\\n\\n   }\\n        \\n}\\n\\n// Method 4 -\\n//     Optimized Tabulation\\n//     TC - O(n)\\n//     SC -O(1)\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        int prev=nums[0];\\n        int secPrev=0;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            int pick=nums[i]+secPrev;\\n            int notPick=prev;\\n            int curr=Math.max(pick,notPick);\\n            secPrev=prev;\\n            prev=curr;\\n        }\\n        return prev;\\n\\n   }\\n        \\n}\\n\\n",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n    public int rob(int[] nums) {\\n        return getMaximumSum(nums.length-1,nums);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1621030,
                "title": "java-recursion-recursion-memoization-optimized-solution",
                "content": "Before starting we need to consider two situations or we will be having two choices\\n**1) If an element is selected then the next element cannot be selected.\\n2) if an element is not selected then the next element can be selected.**\\n\\nRecursive Solution\\n\\n```\\nclass Solution {\\n    int solve(int[] nums,int l)\\n    {\\n        if(l>=nums.length)\\n            return 0;\\n        \\n        return Math.max(nums[l]+solve(nums,l+2),solve(nums,l+1));\\n    }\\n    public int rob(int[] nums) {\\n        \\n        return solve(nums,0);\\n    }\\n}\\n\\n```\\n\\nRecursive Solution leads to Time Limit error when large input is provided, because it recursively calculate amount which leads to repeatition.\\n\\nRecursive solution can further be optimized using memoization using an integer array, if solution at any point is already calculated it return the amount as it is.\\n\\n```\\nclass Solution {\\n    int[] dp;\\n    int solve(int[] nums,int l)\\n    {\\n        if(l>=nums.length)\\n            return 0;\\n        if(dp[l] != -1)\\n            return dp[l];\\n        \\n        return dp[l] = Math.max(nums[l]+solve(nums,l+2),solve(nums,l+1));\\n    }\\n    public int rob(int[] nums) {\\n        \\n        dp = new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            dp[i] = -1;\\n        }\\n        \\n        return solve(nums,0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int solve(int[] nums,int l)\\n    {\\n        if(l>=nums.length)\\n            return 0;\\n        \\n        return Math.max(nums[l]+solve(nums,l+2),solve(nums,l+1));\\n    }\\n    public int rob(int[] nums) {\\n        \\n        return solve(nums,0);\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    int[] dp;\\n    int solve(int[] nums,int l)\\n    {\\n        if(l>=nums.length)\\n            return 0;\\n        if(dp[l] != -1)\\n            return dp[l];\\n        \\n        return dp[l] = Math.max(nums[l]+solve(nums,l+2),solve(nums,l+1));\\n    }\\n    public int rob(int[] nums) {\\n        \\n        dp = new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            dp[i] = -1;\\n        }\\n        \\n        return solve(nums,0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446375,
                "title": "brute-better-optimal-thought-process-matters",
                "content": "## Everyone will give solution, only few will give their thought process.\\n# [**My DSA-EndGame Link**](https://github.com/heyimvikash/DSA-EndGame)\\n# [**198. House Robber**](https://leetcode.com/problems/house-robber/)\\n# Thought Process :-\\n## 1. Think Recurrsively\\nA robber has 2 options: \\n- a) rob current house.\\n- b) don\\'t rob current house.\\n1. If Option A is selected then after robbing current house he will move ahead by 2 position.\\n2. If Option B is selected then he will move ahead by 1 position.\\n## Base Case : when N<1 then ANS is Zero\\n```java\\nint rob(int arr[],int n){\\n    if(n<1) return 0;\\n    return Math.max(arr[n-1]+rob(arr,n-2),rob(arr,n-1));\\n}\\n```\\n## 2. Optimise reccursive code using memonization\\n```java\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n=nums.length;\\n        int dp[]=new int[n+1];\\n        Arrays.fill(dp,-1);\\n        return rob(nums,n,dp);\\n    }\\n    int rob(int arr[],int n, int dp[]){\\n        if(n<1) return 0;\\n        if(dp[n]!=-1) return dp[n];\\n        return dp[n]=Math.max(arr[n-1]+rob(arr,n-2,dp),rob(arr,n-1,dp));\\n    }\\n}\\n```\\n**Here TC - O(N) and SC - O(N) and Stack Space - O(N)**\\n## 3. Optimise Memonised code using tabulation\\n```java\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n=nums.length;\\n        int dp[]=new int[n+1];\\n        // intialise \\n        dp[0]=0; dp[1]=nums[0];\\n        for(int i=2;i<=n;i++){ // here i signifies n\\n           dp[i]=Math.max(nums[i-1]+dp[i-2],dp[i-1]); \\n        }\\n        return dp[n];\\n    }\\n}\\n```\\n**Here TC - O(N) and SC - O(N)**",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```java\\nint rob(int arr[],int n){\\n    if(n<1) return 0;\\n    return Math.max(arr[n-1]+rob(arr,n-2),rob(arr,n-1));\\n}\\n```\n```java\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n=nums.length;\\n        int dp[]=new int[n+1];\\n        Arrays.fill(dp,-1);\\n        return rob(nums,n,dp);\\n    }\\n    int rob(int arr[],int n, int dp[]){\\n        if(n<1) return 0;\\n        if(dp[n]!=-1) return dp[n];\\n        return dp[n]=Math.max(arr[n-1]+rob(arr,n-2,dp),rob(arr,n-1,dp));\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int rob(int[] nums) {\\n        int n=nums.length;\\n        int dp[]=new int[n+1];\\n        // intialise \\n        dp[0]=0; dp[1]=nums[0];\\n        for(int i=2;i<=n;i++){ // here i signifies n\\n           dp[i]=Math.max(nums[i-1]+dp[i-2],dp[i-1]); \\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257348,
                "title": "c-recursive-top-down-bottom-up",
                "content": "**Solution 1 : Recursive Approach - O(2^n)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int getMoney(vector <int> nums, int curr) {\\n        if (curr >= nums.size()) {\\n            return 0;\\n        }\\n        \\n        int rob = nums[curr] + getMoney(nums, curr + 2);\\n        int dontRob = getMoney(nums, curr + 1);\\n        \\n        return max(rob, dontRob);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int maxMoney = getMoney(nums, 0);\\n        return maxMoney;\\n    }\\n};\\n```\\n\\n<hr>\\n\\n**Solution 2 : Top Down DP**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int getMoney(vector <int> nums, int curr, vector <int> dp) {\\n        if (curr >= nums.size()) {\\n            return 0;\\n        }\\n        \\n        if (dp[curr] == 0) {\\n        \\n            int rob = nums[curr] + getMoney(nums, curr + 2, dp);\\n            int dontRob = getMoney(nums, curr + 1, dp);\\n\\n            dp[curr] = max(rob, dontRob);\\n        }\\n        \\n        return dp[curr];\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        vector <int> dp(nums.size(), 0);\\n        int maxMoney = getMoney(nums, 0, dp);\\n        return maxMoney;\\n    }\\n};\\n```\\n\\n<hr>\\n\\n**Solution 3 : Bottom Up DP - O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int getMoney(vector <int> nums) {\\n        vector <int> dp(nums.size(), 0);\\n        dp[0] = nums[0];      \\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            if (i == 1) {\\n                dp[i] = max(nums[i], nums[i - 1]);  \\n            } else {\\n                dp[i] = max(nums[i] + dp[i - 2], dp[i - 1]);\\n            }\\n        }\\n        \\n        return dp[nums.size() - 1];\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int maxMoney = getMoney(nums);\\n        return maxMoney;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int getMoney(vector <int> nums, int curr) {\\n        if (curr >= nums.size()) {\\n            return 0;\\n        }\\n        \\n        int rob = nums[curr] + getMoney(nums, curr + 2);\\n        int dontRob = getMoney(nums, curr + 1);\\n        \\n        return max(rob, dontRob);\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int maxMoney = getMoney(nums, 0);\\n        return maxMoney;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int getMoney(vector <int> nums, int curr, vector <int> dp) {\\n        if (curr >= nums.size()) {\\n            return 0;\\n        }\\n        \\n        if (dp[curr] == 0) {\\n        \\n            int rob = nums[curr] + getMoney(nums, curr + 2, dp);\\n            int dontRob = getMoney(nums, curr + 1, dp);\\n\\n            dp[curr] = max(rob, dontRob);\\n        }\\n        \\n        return dp[curr];\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        vector <int> dp(nums.size(), 0);\\n        int maxMoney = getMoney(nums, 0, dp);\\n        return maxMoney;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int getMoney(vector <int> nums) {\\n        vector <int> dp(nums.size(), 0);\\n        dp[0] = nums[0];      \\n        \\n        for (int i = 1; i < nums.size(); i++) {\\n            if (i == 1) {\\n                dp[i] = max(nums[i], nums[i - 1]);  \\n            } else {\\n                dp[i] = max(nums[i] + dp[i - 2], dp[i - 1]);\\n            }\\n        }\\n        \\n        return dp[nums.size() - 1];\\n    }\\n    \\n    int rob(vector<int>& nums) {\\n        int maxMoney = getMoney(nums);\\n        return maxMoney;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1216607,
                "title": "intuitive-python-solution-dp",
                "content": "The robber can rob only choose the maximum of previous maximum nums but not adjacent ones. So take the max of i-2 and i-3.\\n\\n```\\nclass Solution:\\n\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\tif len(nums) <= 2:\\n\\t\\t\\treturn max(nums)\\n\\t\\tnums[2] = nums[0] + nums[2]\\n\\t\\tfor i in range(3, len(nums)):\\n\\t\\t\\tnums[i] = nums[i] + max(nums[i-2], nums[i-3])\\n\\t\\treturn max(nums)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\tdef rob(self, nums: List[int]) -> int:\\n\\t\\tif len(nums) <= 2:\\n\\t\\t\\treturn max(nums)\\n\\t\\tnums[2] = nums[0] + nums[2]\\n\\t\\tfor i in range(3, len(nums)):\\n\\t\\t\\tnums[i] = nums[i] + max(nums[i-2], nums[i-3])\\n\\t\\treturn max(nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855457,
                "title": "python-dp-solution-in-o-n-time",
                "content": "This is textbook example of a DP problem. The basic idea is we want to define our objective function, transition function, and build our base cases. \\n\\nFor this particular problem: \\n* Objective function: F(i) is the maximum number of money stolen given seeing i homes.\\n* Transition function f(i) = max(f(i-1) , f(i - 2) + nums[i])\\n* Base Cases: f(0) = 0 , f(1) = nums[0]\\n\\nExplanation:\\nThe objective function defines the optimal substructure at the ith position which is usually given by the problem statement.\\n\\nThe transition function is saying given the ith position how can we generate the next optimal substructure.\\nIn our case, there are two possibilities: We stole from the i - 1 th home so we don\\'t steal from the ith home to prevent triggering the security system. Or we didn\\'t steal from the i - 1th home so we can steal from the ith home. We have f(i) = max( f(i - 1),f(i - 2) + nums[i])\\n\\nThe base cases: There are two account for the two possibilities at each subproblem. So we have the case where there are no homes to steal from and the case where there is only one home to steal from on the street. (That\\'s one big home! must be a mansion)\\n\\n\\n```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp = [0]\\n        if len(nums) == 0:\\n            return dp[0]\\n        dp.append(nums[0])\\n        for i in range(2,len(nums) + 1):\\n            dp.append(max(dp[i - 1],dp[i - 2] + nums[i - 1]))\\n        return dp[len(dp) - 1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp = [0]\\n        if len(nums) == 0:\\n            return dp[0]\\n        dp.append(nums[0])\\n        for i in range(2,len(nums) + 1):\\n            dp.append(max(dp[i - 1],dp[i - 2] + nums[i - 1]))\\n        return dp[len(dp) - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529228,
                "title": "python-dp",
                "content": "\"\"\"\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \"\"\"\\n          Constraints:\\n            Cannot rob adjacant houses\\n            \\n          Goal:\\n            Find max you can rob in the neighborhood\\n          \\n          Lets build the problem up from most money of money you can rob in each index\\n          \\n          \\n          [4,1,1,4]\\n          \\n          \\n          [4]\\n          [4, 4]       \\n          [4, 4, 5]  dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\\n          [4, 4, 5, 8]\\n          \\n          \\n          If I choose to rob this house take the max of profit from the houses two to the left\\n          If I choose to not rob then take the max of the house one to the left\\n\\n\\n        \"\"\"\\n\\n        if nums is None or len(nums) == 0:\\n          return 0\\n        if len(nums) == 1:\\n          return nums[0]\\n    \\n      \\n        dp = [nums[0], max(nums[0], nums[1])]\\n        \\n        for i in range(2, len(nums)):\\n          dp.append(max(dp[i -2] + nums[i], dp[i - 1]))\\n        \\n        return dp[-1]\\n\\t\\t\"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \"\"\"\\n          Constraints:\\n            Cannot rob adjacant houses\\n            \\n          Goal:\\n            Find max you can rob in the neighborhood\\n          \\n          Lets build the problem up from most money of money you can rob in each index\\n          \\n          \\n          [4,1,1,4]\\n          \\n          \\n          [4]\\n          [4, 4]       \\n          [4, 4, 5]  dp[i] = max(dp[i - 2] + nums[i], dp[i - 1])\\n          [4, 4, 5, 8]\\n          \\n          \\n          If I choose to rob this house take the max of profit from the houses two to the left\\n          If I choose to not rob then take the max of the house one to the left\\n\\n\\n        \"\"\"\\n\\n        if nums is None or len(nums) == 0:\\n          return 0\\n        if len(nums) == 1:\\n          return nums[0]\\n    \\n      \\n        dp = [nums[0], max(nums[0], nums[1])]\\n        \\n        for i in range(2, len(nums)):\\n          dp.append(max(dp[i -2] + nums[i], dp[i - 1]))\\n        \\n        return dp[-1]\\n\\t\\t\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 227675,
                "title": "c-well-commented-solution-dp-100",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int rob(vector<int>& a);\\n};\\n\\nint Solution :: rob(vector<int>& a)\\n{\\n    int n = a.size();\\n    \\n    if(n==0) return 0;\\n    \\n    int dp[n];\\n    \\n    /* dp[i] represents the maximum value stolen after the thief has reached the ith house*/\\n    /* Note that it does not mean that he has to rob this house compulsorily */\\n    /* He has the option of robbing it or leaving it, depending upon his choices */\\n    \\n    memset(dp,0,sizeof(dp));\\n    \\n    int takeIt = 0;\\n    int leaveIt = 0;\\n    \\n    /* The thief comes to the first house */\\n    takeIt = a[0];\\n    leaveIt = 0;\\n    dp[0] = max(takeIt,leaveIt);\\n    \\n    // If there is only one house to rob, the you\\'re done */\\n    // Tricky corner case\\n    if(n==1) return dp[0];\\n    \\n    /* So now assume that the second house exists*/\\n    \\n    /* The thief goes to the 2nd house */\\n    // If he takes it, he has to give back the contents of house 1, if stolen */\\n    takeIt = a[1]; \\n    // If he leaves it, he\\'ll be just where he started off \\n    leaveIt = dp[0];\\n    dp[1] = max(takeIt,leaveIt);\\n    \\n    /* Now, apply the definition */\\n    for(int i=2; i<n; i++)\\n    {\\n        // If you take this, you are not eligible for the left house\\n        // Note that the i-2th house  need not be robbed compulsorily as per dp definition\\n        takeIt = a[i] + dp[i-2];\\n        \\n        // If you leave it, you\\'ll only get the benefits earned till  the last house\\n        leaveIt = dp[i-1];\\n        \\n        // Take the best of the two outcomes\\n        dp[i] = max(takeIt, leaveIt);\\n    }\\n    \\n    return dp[n-1];\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int rob(vector<int>& a);\\n};\\n\\nint Solution :: rob(vector<int>& a)\\n{\\n    int n = a.size();\\n    \\n    if(n==0) return 0;\\n    \\n    int dp[n];\\n    \\n    /* dp[i] represents the maximum value stolen after the thief has reached the ith house*/\\n    /* Note that it does not mean that he has to rob this house compulsorily */\\n    /* He has the option of robbing it or leaving it, depending upon his choices */\\n    \\n    memset(dp,0,sizeof(dp));\\n    \\n    int takeIt = 0;\\n    int leaveIt = 0;\\n    \\n    /* The thief comes to the first house */\\n    takeIt = a[0];\\n    leaveIt = 0;\\n    dp[0] = max(takeIt,leaveIt);\\n    \\n    // If there is only one house to rob, the you\\'re done */\\n    // Tricky corner case\\n    if(n==1) return dp[0];\\n    \\n    /* So now assume that the second house exists*/\\n    \\n    /* The thief goes to the 2nd house */\\n    // If he takes it, he has to give back the contents of house 1, if stolen */\\n    takeIt = a[1]; \\n    // If he leaves it, he\\'ll be just where he started off \\n    leaveIt = dp[0];\\n    dp[1] = max(takeIt,leaveIt);\\n    \\n    /* Now, apply the definition */\\n    for(int i=2; i<n; i++)\\n    {\\n        // If you take this, you are not eligible for the left house\\n        // Note that the i-2th house  need not be robbed compulsorily as per dp definition\\n        takeIt = a[i] + dp[i-2];\\n        \\n        // If you leave it, you\\'ll only get the benefits earned till  the last house\\n        leaveIt = dp[i-1];\\n        \\n        // Take the best of the two outcomes\\n        dp[i] = max(takeIt, leaveIt);\\n    }\\n    \\n    return dp[n-1];\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 55765,
                "title": "java-o-n-runtime-and-o-1-space-before-simplified-version-after-simplified-version",
                "content": "I saw an elegant solution but it's difficult to understand.  https://discuss.leetcode.com/topic/11082/java-o-n-solution-space-o-1/2\\n\\nKey point is: For each loop (house), we will make the `currNo` (current not robbed) and `currYes`(currently been robbed) to become the `prevYes` and `prevNo` for the next house.\\n\\nLet's see the before simplified version:\\n\\n```\\npublic static int rob(int[] nums) {\\n        int currYes = 0, currNo = 0;\\n        for (int x : nums) {\\n            int prevNo = currNo;\\n            int prevYes = currYes;\\n            currNo = Math.max(prevNo, prevYes);\\n            currYes = prevNo + x;\\n        }\\n        return Math.max(currNo, currYes);\\n    }\\n```\\n\\n\\nBut we find that `prevYes` only been used once, so we deleted it, Now in the for loop it's like\\n```\\npublic static int rob2(int[] nums) {\\n        int currYes = 0, currNo = 0;\\n        for (int x : nums) {\\n            int prevNo = currNo;\\n            currNo = Math.max(prevNo, currYes);\\n            currYes = prevNo + x;\\n        }\\n        return Math.max(currNo, currYes);\\n    }\\n\\n```\\nWhatever how you name the two variables. But I think these names are easier to understand.",
                "solutionTags": [],
                "code": "```\\npublic static int rob(int[] nums) {\\n        int currYes = 0, currNo = 0;\\n        for (int x : nums) {\\n            int prevNo = currNo;\\n            int prevYes = currYes;\\n            currNo = Math.max(prevNo, prevYes);\\n            currYes = prevNo + x;\\n        }\\n        return Math.max(currNo, currYes);\\n    }\\n```\n```\\npublic static int rob2(int[] nums) {\\n        int currYes = 0, currNo = 0;\\n        for (int x : nums) {\\n            int prevNo = currNo;\\n            currNo = Math.max(prevNo, currYes);\\n            currYes = prevNo + x;\\n        }\\n        return Math.max(currNo, currYes);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 55915,
                "title": "6-line-in-c-constant-space-solution-easy-to-understand",
                "content": "      class Solution {\\n     public:\\n       int rob(vector<int>& nums) {\\n        int a=0,b=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n        int t=max(a,b+nums[i]);b=a;a=t;\\n        }\\n        return a;\\n     }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n     public:\\n       int rob(vector<int>& nums) {\\n        int a=0,b=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n        int t=max(a,b+nums[i]);b=a;a=t;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 55968,
                "title": "share-my-c-dp-sol",
                "content": "Say num.size() == n. Define f(i) be maximum sum from i to n-1 for the case you rob house i. Define g(i) be maximum sum from i to n-1 for the case that you do not rob house i. Therefore,\\n\\n> f(i) = num[i] + g(i+1) <--- rob house i plus the max sum of the case\\n> that you do not rob house i+1\\n> \\n> g(i) = max(f(i+1),g(i+1)) <--- do not rob house i. Get either the\\n> maximum sum of the case you rob house i+1, or of the case you do not\\n> rob house i+1\\n\\n \\nYou do this backwards from the last house and the final answer is max(f(0),g(0)).\\n\\nThe code:\\n\\n    int rob(vector<int>& nums) {\\n            int f=0, g=0;\\n            for(int i=nums.size()-1; i>=0; i--) {\\n                int f_nxt = nums[i] + g;\\n                int g_nxt = max(f,g);\\n                f = f_nxt;\\n                g = g_nxt;\\n            }\\n            return max(f,g);\\n        }",
                "solutionTags": [],
                "code": "Say num.size() == n. Define f(i) be maximum sum from i to n-1 for the case you rob house i. Define g(i) be maximum sum from i to n-1 for the case that you do not rob house i. Therefore,\\n\\n> f(i) = num[i] + g(i+1) <--- rob house i plus the max sum of the case\\n> that you do not rob house i+1\\n> \\n> g(i) = max(f(i+1),g(i+1)) <--- do not rob house i. Get either the\\n> maximum sum of the case you rob house i+1, or of the case you do not\\n> rob house i+1\\n\\n \\nYou do this backwards from the last house and the final answer is max(f(0),g(0)).\\n\\nThe code:\\n\\n    int rob(vector<int>& nums) {\\n            int f=0, g=0;\\n            for(int i=nums.size()-1; i>=0; i--) {\\n                int f_nxt = nums[i] + g;\\n                int g_nxt = max(f,g);\\n                f = f_nxt;\\n                g = g_nxt;\\n            }\\n            return max(f,g);\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3323577,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nDP (Top Down Approach)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int solve(int idx, vector<int>& nums, vector <int>& dp) {\\n        if (idx == 0)\\n            return nums[0];\\n        if (idx < 0)\\n            return 0;\\n        if (dp[idx] != -1)\\n            return dp[idx];\\n        int pick = nums[idx] + solve(idx-2, nums, dp);\\n        int notPick = 0 + solve(idx-1, nums, dp);\\n        return dp[idx] = max (pick, notPick);\\n    }\\npublic:\\t\\n    int rob(vector<int>& nums) {   \\n        int n = nums.size(); \\n\\t    vector <int> dp(n, -1);\\n\\t    int maxSum = solve(n-1, nums, dp);\\n\\t    return maxSum;\\n\\t}\\n};\\n```\\n\\n# Approach 2\\nDP (Bottom Up Approach) + Space Optimization\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int prev1 = nums[0], prev2 = 0;\\n\\t    for (int i = 0; i < n; i++) {\\n\\t        int pick = nums[i];\\n\\t        if (i > 1)\\n\\t        pick += prev2;\\n            int notPick = 0 + prev1;\\n\\t        int curr = max (pick, notPick);\\n\\t        prev2 = prev1;\\n\\t        prev1 = curr;\\n\\t    }\\n\\t    return prev1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int idx, vector<int>& nums, vector <int>& dp) {\\n        if (idx == 0)\\n            return nums[0];\\n        if (idx < 0)\\n            return 0;\\n        if (dp[idx] != -1)\\n            return dp[idx];\\n        int pick = nums[idx] + solve(idx-2, nums, dp);\\n        int notPick = 0 + solve(idx-1, nums, dp);\\n        return dp[idx] = max (pick, notPick);\\n    }\\npublic:\\t\\n    int rob(vector<int>& nums) {   \\n        int n = nums.size(); \\n\\t    vector <int> dp(n, -1);\\n\\t    int maxSum = solve(n-1, nums, dp);\\n\\t    return maxSum;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int prev1 = nums[0], prev2 = 0;\\n\\t    for (int i = 0; i < n; i++) {\\n\\t        int pick = nums[i];\\n\\t        if (i > 1)\\n\\t        pick += prev2;\\n            int notPick = 0 + prev1;\\n\\t        int curr = max (pick, notPick);\\n\\t        prev2 = prev1;\\n\\t        prev1 = curr;\\n\\t    }\\n\\t    return prev1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132866,
                "title": "python-o-n-1-time-fully-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Robber will think reversly, and try to solve problem in reverse manner\\n- we will start from $$house(0)$$ at $$house(0)$$ only one possibility is there that is that house only.\\n- now, from next house onwards we will try to take maximum of\\n1. cost if we include current $$house(i)$$ that is $$incl = nums[i]+house(i-2)(assuming house(i-2 has optimal solution))$$\\n2. cost if we skip current house(i) that is excl = house(i-1)(same assumption)\\n- cost of current $$house(i) = max(incl, excl)$$\\n- do this for $$n-1$$ iteration and answer lies in $$memo(n-1)$$, n-1 because we made all optimal choices and finished searching all houses (if permitted) and maximum lies in last optimal choice which depends on whole chain of house searching.\\n\\n# Complexity\\n- Time complexity:$$O(n-1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n-1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def helper():\\n            memo = [0 for _ in range(len(nums))]\\n            memo[0] = nums[0]\\n            for i in range(1, len(nums)):\\n                incl = nums[i]+memo[i-2] if i-2 >=0 else nums[i]\\n                excl = memo[i-1]\\n                memo[i] = max(incl, excl)\\n            return memo[len(nums)-1]\\n        return helper()\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        def helper():\\n            memo = [0 for _ in range(len(nums))]\\n            memo[0] = nums[0]\\n            for i in range(1, len(nums)):\\n                incl = nums[i]+memo[i-2] if i-2 >=0 else nums[i]\\n                excl = memo[i-1]\\n                memo[i] = max(incl, excl)\\n            return memo[len(nums)-1]\\n        return helper()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829831,
                "title": "0ms-solution-fully-explained-phase-of-transfer-function-o-n-java",
                "content": "# Approach : Using Dynamic Programming\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Explanation :\\n- The trick is the dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]) statement (Phase of Transfer Function).\\n\\n# Code\\n```\\nclass Solution \\n{\\n    Integer[] dp;//Intrger object\\n    public int rob(int[] nums) \\n    {\\n        dp=new Integer[nums.length];//Initialize an arrays to store the money\\n        return profit(nums,nums.length-1);\\n    }\\n    private int profit(int[] nums, int i)\\n    {\\n        if(i<0)\\n          return 0;\\n        if(dp[i]!=null)\\n          return dp[i];\\n        return dp[i]=Math.max(profit(nums,i-2)+nums[i],profit(nums,i-1));\\n//phase of transfer function (We can infer the formula from problem:mark[i]=max(num[i]+mark[i-2],mark[i-1])                        \\n    }\\n}\\n```\\n\\n## *If you find this solution easy to understand and helpful, then please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D*",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\n    Integer[] dp;//Intrger object\\n    public int rob(int[] nums) \\n    {\\n        dp=new Integer[nums.length];//Initialize an arrays to store the money\\n        return profit(nums,nums.length-1);\\n    }\\n    private int profit(int[] nums, int i)\\n    {\\n        if(i<0)\\n          return 0;\\n        if(dp[i]!=null)\\n          return dp[i];\\n        return dp[i]=Math.max(profit(nums,i-2)+nums[i],profit(nums,i-1));\\n//phase of transfer function (We can infer the formula from problem:mark[i]=max(num[i]+mark[i-2],mark[i-1])                        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741820,
                "title": "fast-c-dynamic-recursion",
                "content": "```\\nclass Solution {\\nprivate:\\n    int robCount(vector<int>& nums, int i, vector<int>& robbox) {\\n        if (i>nums.size()-1) return 0;\\n        if (robbox[i]>=0) return robbox[i];\\n        return robbox[i] = nums[i] + max(robCount(nums, i+2, robbox),robCount(nums, i+3, robbox));\\n    }\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size()==1) return nums[0];\\n        vector<int> robbox(nums.size(), -1);\\n        return max(robCount(nums, 0, robbox), robCount(nums, 1, robbox));\\n    }\\n};\\n```\\n\\n*Upvote solution if you liked it!*",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int robCount(vector<int>& nums, int i, vector<int>& robbox) {\\n        if (i>nums.size()-1) return 0;\\n        if (robbox[i]>=0) return robbox[i];\\n        return robbox[i] = nums[i] + max(robCount(nums, i+2, robbox),robCount(nums, i+3, robbox));\\n    }\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size()==1) return nums[0];\\n        vector<int> robbox(nums.size(), -1);\\n        return max(robCount(nums, 0, robbox), robCount(nums, 1, robbox));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657099,
                "title": "python-can-you-beat-this-easy-solution",
                "content": "```\\ndef rob(self, nums: List[int]) -> int:\\n        prev=0\\n        curr=0\\n        for x in nums:\\n            temp=prev\\n            prev=curr\\n            curr=max(x+temp,prev)\\n        return curr\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef rob(self, nums: List[int]) -> int:\\n        prev=0\\n        curr=0\\n        for x in nums:\\n            temp=prev\\n            prev=curr\\n            curr=max(x+temp,prev)\\n        return curr\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2553410,
                "title": "python-solution-dp-and-memoization-best-approach-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # \\'dp\\' is used to store sub-problem results\\n        dp={}\\n        \\n        def solve(i):\\n            if i >= len(nums):\\n                return 0\\n            if i in dp:\\n                return dp[i]    # memoization\\n            else:\\n                dp[i] = max(nums[i]+solve(i+2), solve(i+1))  \\n            return dp[i]\\n        \\n        \\n        return solve(0)\\n```\\n**Note**: we are incrementing i+2 because adjacent house can alert the police.",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution(object):\\n    def rob(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # \\'dp\\' is used to store sub-problem results\\n        dp={}\\n        \\n        def solve(i):\\n            if i >= len(nums):\\n                return 0\\n            if i in dp:\\n                return dp[i]    # memoization\\n            else:\\n                dp[i] = max(nums[i]+solve(i+2), solve(i+1))  \\n            return dp[i]\\n        \\n        \\n        return solve(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507801,
                "title": "c-recursion-memoization-tabulation",
                "content": "**RECURSION:-**\\nThe idea of the problem is easy if we choose the ith element than we have to choose i+2 th element else we can choose the (i+1)th element.\\n```\\nclass Solution {\\npublic:\\n    \\n    int help(vector<int> &nums,int i){\\n        if(i>=nums.size()){\\n            return 0;\\n        }\\n        int res=INT_MIN;\\n        int take=help(nums,i+2)+nums[i];\\n        int notake=help(nums,i+1);\\n        res=max(take,notake);\\n        return res;\\n    }\\n    int rob(vector<int>& nums) {\\n        return help(nums,0);\\n    }\\n};\\n```\\n**MEMOIZATION**\\n```\\nclass Solution {\\npublic:\\n    \\n    int help(vector<int> &nums,int i,vector<int> &dp){\\n        if(i>=nums.size()){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int res=INT_MIN;\\n        int take=help(nums,i+2,dp)+nums[i];\\n        int notake=help(nums,i+1,dp);\\n        res=max(take,notake);\\n        return dp[i]=res;\\n    }\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        return help(nums,0,dp);\\n    }\\n};\\n```\\n**TABULATION**\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> v(n+1,0);\\n        v[0]=0;\\n        v[1]=nums[0];\\n        for(int i=2;i<=n;i++){\\n            v[i]=max(v[i-2]+nums[i-1],v[i-1]);\\n        }\\n        return v[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int help(vector<int> &nums,int i){\\n        if(i>=nums.size()){\\n            return 0;\\n        }\\n        int res=INT_MIN;\\n        int take=help(nums,i+2)+nums[i];\\n        int notake=help(nums,i+1);\\n        res=max(take,notake);\\n        return res;\\n    }\\n    int rob(vector<int>& nums) {\\n        return help(nums,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int help(vector<int> &nums,int i,vector<int> &dp){\\n        if(i>=nums.size()){\\n            return 0;\\n        }\\n        if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int res=INT_MIN;\\n        int take=help(nums,i+2,dp)+nums[i];\\n        int notake=help(nums,i+1,dp);\\n        res=max(take,notake);\\n        return dp[i]=res;\\n    }\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(nums.size()+1,-1);\\n        return help(nums,0,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> v(n+1,0);\\n        v[0]=0;\\n        v[1]=nums[0];\\n        for(int i=2;i<=n;i++){\\n            v[i]=max(v[i-2]+nums[i-1],v[i-1]);\\n        }\\n        return v[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2280017,
                "title": "c-solution-with-comments-representation-5-level-optimization-from-recursion-to-space",
                "content": "***\\n***Please Upvote if it helps.....***\\n***\\n***Solution :***\\n***\\n***\\nAs we need to find the sum of subsequences, one approach that comes to our mind is to generate all subsequences and pick the one with the maximum sum. \\n\\nTo generate all the subsequences, we can use the pick/non-pick technique. This technique can be briefly explained as follows:\\n\\n* At every index of the array, we have two options.\\n* First, to pick the array element at that index and consider it in our subsequence.\\n* Second, to leave the array element at that index and not to consider it in our subsequence.\\n\\n\\nFirst, we will try to form the recursive solution to the problem with the pick/non-pick technique. There is one more catch, the problem wants us to have only non-adjacent elements of the array in the subsequence, therefore we need to address that too.\\n***\\n***\\n***Steps to form the recursive solution:-***\\n***\\n\\n***Step 1:*** Form the function in terms of indexes: \\n\\n* We are given an array which can be easily thought of in terms of indexes. \\n* We can define our function f(ind) as : Maximum sum of the subsequence starting from index 0 to index ind.\\n* We need to return f(n-1) as our final answer.\\n\\n***Step 2:*** Try all the choices to reach the goal.\\n\\nAs mentioned earlier we will use the pick/non-pick technique to generate all subsequences. We also need to take care of the non-adjacent elements in this step.\\n\\n* If we pick an element then, pick = arr[ind] + f(ind-2). The reason we are doing f(ind-2) is because we have picked the current index element so we need to pick a non-adjacent element so we choose the index \\u2018ind-2\\u2019 instead of \\u2018ind-1\\u2019.\\n* Next we need to ignore the current element in our subsequence. So nonPick= 0 + f(ind-1). As we don\\u2019t pick the current element, we can consider the adjacent element in the subsequence.\\n\\nOur pseudocode till this step will be:\\n\\n![image](https://assets.leetcode.com/users/images/37f857f3-b55e-4e8b-a9fe-c60ba5f2d11f_1657777829.2284176.png)\\n\\n\\n***Step 3:*** Take the maximum of all the choices\\n\\nAs the problem statement asks to find the maximum subsequence total, we will return the maximum of two choices of step2.\\n\\n![image](https://assets.leetcode.com/users/images/ae7d9bed-45c5-4efd-8683-04f07d34aa51_1657777846.7399182.png)\\n***\\n***\\n\\n***Base Conditions***\\n***\\n\\nThe base conditions for the recursive function will be as follows:\\n\\n* If ind=0, then we know to reach at index=0, we would have ignored the element at index = 1. Therefore, we can simply return the value of arr[ind] and consider it in the subsequence.\\n* If ind<0, this case can hit when we call f(ind-2) at ind=1. In this case we want to return to the calling function so we simply return 0 so that nothing is added to the subsequence sum.\\n\\nOur final pseudo-code will be:\\n\\n![image](https://assets.leetcode.com/users/images/eeeb521f-840f-4066-96b7-92e88f0d2826_1657777914.744225.png)\\n\\n***\\n***\\n***Memoization approach***\\n***\\nIf we observe the recursion tree, we will observe a number of overlapping subproblems. Therefore the recursive solution can be memoized to reduce the time complexity.\\n***\\n***Recursion tree diagram:***\\n![image](https://assets.leetcode.com/users/images/bbe32ffd-2efe-4ffe-afea-6d142431ca92_1657777955.877174.png)\\n***\\n\\n***Steps to convert Recursive code to memoization solution:***\\n***\\n\\n* Create a dp[n] array initialized to -1.\\n* Whenever we want to find the answer of a particular value (say n), we first check whether the answer is already calculated using the dp array(i.e dp[n] != -1 ). If yes, simply return the value from the dp array.\\n* If not, then we are finding the answer for the given value for the first time, we will use the recursive relation as usual but before returning from the function, we will set dp[n] to the solution we get.\\n***\\n***\\n***C++ Code:***\\n***\\n```\\nint solveUtil(int ind, vector<int>& arr, vector<int>& dp){\\n    \\n    if(dp[ind]!=-1) return dp[ind];\\n    \\n    if(ind==0) return arr[ind];\\n    if(ind<0)  return 0;\\n    \\n    int pick= arr[ind]+ solveUtil(ind-2, arr,dp);\\n    int nonPick = 0 + solveUtil(ind-1, arr, dp);\\n    \\n    return dp[ind]=max(pick, nonPick);\\n}\\n\\nint solve(int n, vector<int>& arr){\\n    vector<int> dp(n,-1);\\n    return solveUtil(n-1, arr, dp);\\n}\\n\\n```\\n***\\n\\n***Output: 11***\\n***\\n***\\n***Time Complexity: O(N)***\\n\\n***Reason:*** The overlapping subproblems will return the answer in constant time O(1). Therefore the total number of new subproblems we solve is \\u2018n\\u2019. Hence total time complexity is O(N).\\n\\n***Space Complexity: O(N)***\\n\\n***Reason:*** We are using a recursion stack space(O(N)) and an array (again O(N)). Therefore total space complexity will be O(N) + O(N) \\u2248 O(N)\\n***\\n***\\n\\n***Tabulation approach***\\n***\\n* Declare a dp[] array of size n.\\n* First initialize the base condition values, i.e dp[0] as 0.\\n* Set an iterative loop which traverses the array( from index 1 to n-1) and for every index calculate pick  and nonPick\\n*  And then we can set dp[i] = max (pick, nonPick)\\n***\\n***\\n***C++ Code:***\\n***\\n```\\nint solveUtil(int n, vector<int>& arr, vector<int>& dp){\\n    \\n    dp[0]= arr[0];\\n    \\n    for(int i=1 ;i<n; i++){\\n        int pick = arr[i];\\n        if(i>1)\\n            pick += dp[i-2];\\n        int nonPick = 0+ dp[i-1];\\n        \\n        dp[i]= max(pick, nonPick);\\n    }\\n    return dp[n-1];\\n}\\n\\nint solve(int n, vector<int>& arr){\\n    vector<int> dp(n,-1);\\n    return solveUtil(n, arr, dp);\\n}\\n```\\n***\\n***Output: 11***\\n***\\n***\\n***Time Complexity: O(N)***\\n\\n***Reason:*** We are running a simple iterative loop\\n\\n***Space Complexity: O(N)***\\n\\n***Reason:*** We are using an external array of size \\u2018n+1\\u2019.\\n***\\n***\\n***Part 3: Space Optimization***\\n\\nIf we closely look the values required at every iteration,\\n\\n***dp[i] , dp[i-1] and  dp[i-2]***\\n\\nwe see that for any i, we do need only the last two values in the array. So is there a need to maintain a whole array for it? \\n\\nThe answer is \\u2018No\\u2019. Let us call dp[i-1] as prev and dp[i-2] as prev2. Now understand the following illustration.\\n\\n![image](https://assets.leetcode.com/users/images/8a0fea97-2a7b-4a0c-9262-0684fa6ad77d_1657778207.2451472.png)\\n\\n\\n* Each iteration\\u2019s cur_i and prev becomes the next iteration\\u2019s prev and prev2 respectively.\\n* Therefore after calculating cur_i, if we update prev and prev2 according to the next step, we will always get the answer. \\n* After the iterative loop has ended we can simply return prev as our answer.\\n***\\n\\n***C++ Code:***\\n```\\nint solve(int n, vector<int>& arr){\\n    int prev = arr[0];\\n    int prev2 =0;\\n    \\n    for(int i=1; i<n; i++){\\n        int pick = arr[i];\\n        if(i>1)\\n            pick += prev2;\\n        int nonPick = 0 + prev;\\n        \\n        int cur_i = max(pick, nonPick);\\n        prev2 = prev;\\n        prev= cur_i;\\n        \\n    }\\n    return prev;\\n}\\n```\\n***\\n***Output: 11***\\n***\\n***\\n***Time Complexity: O(N)***\\n\\n***Reason:*** We are running a simple iterative loop\\n\\n***Space Complexity: O(1)***\\n\\n***Reason:*** We are not using any extra space.\\n***\\n***\\n***Please Upvote if it helps.....***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint solveUtil(int ind, vector<int>& arr, vector<int>& dp){\\n    \\n    if(dp[ind]!=-1) return dp[ind];\\n    \\n    if(ind==0) return arr[ind];\\n    if(ind<0)  return 0;\\n    \\n    int pick= arr[ind]+ solveUtil(ind-2, arr,dp);\\n    int nonPick = 0 + solveUtil(ind-1, arr, dp);\\n    \\n    return dp[ind]=max(pick, nonPick);\\n}\\n\\nint solve(int n, vector<int>& arr){\\n    vector<int> dp(n,-1);\\n    return solveUtil(n-1, arr, dp);\\n}\\n\\n```\n```\\nint solveUtil(int n, vector<int>& arr, vector<int>& dp){\\n    \\n    dp[0]= arr[0];\\n    \\n    for(int i=1 ;i<n; i++){\\n        int pick = arr[i];\\n        if(i>1)\\n            pick += dp[i-2];\\n        int nonPick = 0+ dp[i-1];\\n        \\n        dp[i]= max(pick, nonPick);\\n    }\\n    return dp[n-1];\\n}\\n\\nint solve(int n, vector<int>& arr){\\n    vector<int> dp(n,-1);\\n    return solveUtil(n, arr, dp);\\n}\\n```\n```\\nint solve(int n, vector<int>& arr){\\n    int prev = arr[0];\\n    int prev2 =0;\\n    \\n    for(int i=1; i<n; i++){\\n        int pick = arr[i];\\n        if(i>1)\\n            pick += prev2;\\n        int nonPick = 0 + prev;\\n        \\n        int cur_i = max(pick, nonPick);\\n        prev2 = prev;\\n        prev= cur_i;\\n        \\n    }\\n    return prev;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1836989,
                "title": "c-o-n-time-100-faster-dp-memoization",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int n = nums.size();\\n        vector<int>dp(n+1, 0);\\n        \\n        if(n == 1) return nums[0];\\n        if(n == 2) return max(nums[0], nums[1]);\\n        \\n        dp[0] = nums[0], dp[1] = nums[1];\\n        for(int i = 2; i<n; i++){\\n            dp[i] = max((dp[i-2] + nums[i]), dp[i-1]);\\n            dp[i-1] = max(dp[i-1], dp[i-2]);\\n        }\\n        \\n        return dp[n-1];\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int n = nums.size();\\n        vector<int>dp(n+1, 0);\\n        \\n        if(n == 1) return nums[0];\\n        if(n == 2) return max(nums[0], nums[1]);\\n        \\n        dp[0] = nums[0], dp[1] = nums[1];\\n        for(int i = 2; i<n; i++){\\n            dp[i] = max((dp[i-2] + nums[i]), dp[i-1]);\\n            dp[i-1] = max(dp[i-1], dp[i-2]);\\n        }",
                "codeTag": "C++"
            },
            {
                "id": 1700182,
                "title": "c-100-faster-without-extra-space-o-n",
                "content": "**Please Upvote if You Like :)**\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {    \\n    int n=nums.size();\\n    int even=0;\\n    int odd=0;\\n    for(int i=0;i<n;i++)\\n    { \\n        if(i%2==0)\\n        {\\n            even+=nums[i];\\n            if(even<odd)\\n            {\\n                even=odd;\\n            }\\n        }\\n        else\\n        {\\n            odd+=nums[i];\\n            if(even>odd)\\n            {\\n                odd=even;\\n            }\\n        }     \\n    }\\n    return max(even,odd); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {    \\n    int n=nums.size();\\n    int even=0;\\n    int odd=0;\\n    for(int i=0;i<n;i++)\\n    { \\n        if(i%2==0)\\n        {\\n            even+=nums[i];\\n            if(even<odd)\\n            {\\n                even=odd;\\n            }\\n        }\\n        else\\n        {\\n            odd+=nums[i];\\n            if(even>odd)\\n            {\\n                odd=even;\\n            }\\n        }     \\n    }\\n    return max(even,odd); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684688,
                "title": "0ms-c-dp-soln",
                "content": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n  \\n    int inc = nums[0] , exc = 0;\\n    \\n    for(int index = 1 ; index < nums.size() ; index++)\\n    {\\n        int ninc = exc + nums[index];\\n        int nexc = max(inc , exc);\\n        \\n        inc = ninc;\\n        exc = nexc;\\n    }\\n    return max(inc,exc);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n  \\n    int inc = nums[0] , exc = 0;\\n    \\n    for(int index = 1 ; index < nums.size() ; index++)\\n    {\\n        int ninc = exc + nums[index];\\n        int nexc = max(inc , exc);\\n        \\n        inc = ninc;\\n        exc = nexc;\\n    }\\n    return max(inc,exc);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605941,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        nums.into_iter()\\n            .fold((0, 0), |(a, b), x| (a.max(b + x), a))\\n            .0\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        nums.into_iter()\\n            .fold((0, 0), |(a, b), x| (a.max(b + x), a))\\n            .0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1605258,
                "title": "python-dynamic-programming-dp-o-n-time-o-1-space-explaination",
                "content": "User DP algorithms:\\n**Approach**: Bottom->Up\\n**Recursive formula**: m[i] = max(m[i-1], m[i-2]+nums[i-2])\\nwhere m[i] is maximum money that the robber can get tonight when he walks thought the i(th) horse\\n**Clarify the formula**:  \\nOn a i(th) horse, we have two choices\\nFirst: skip -> m[i] = m[i-1]\\nSecond: Stole this horse -> he just ignore i-1(th)horse -> m[i] = m[i-2]+nums[i]\\nSo maximun mount of money is maximun two above choices\\n\\nIf you have any question, free feel comment bellow\\nUpvote if it is useful. Have a nice day coders :D\\n\\n```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1:\\n            return nums[0]\\n        nums[1] = max(nums[1], nums[0])\\n        for i in range(2, n):\\n            nums[i] = max(nums[i-1], nums[i-2]+nums[i])\\n            \\n        return nums[n-1]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        if n == 1:\\n            return nums[0]\\n        nums[1] = max(nums[1], nums[0])\\n        for i in range(2, n):\\n            nums[i] = max(nums[i-1], nums[i-2]+nums[i])\\n            \\n        return nums[n-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1591372,
                "title": "c-two-approaches-both-beat-100",
                "content": "**Approach 1-**\\nBottom up dp TC-O(N), SC-O(N)\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n            return nums[0];\\n        vector<int> dp(n,0);\\n        dp[0]=nums[0];\\n        dp[1]=max(nums[0],nums[1]);        \\n        for(int i=2;i<n;i++)\\n        {\\n            dp[i]=max(dp[i-2]+nums[i],dp[i-1]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n\\n```\\n**Approach 2 (Best)-**\\nWe can notice in approach 1 that we only need 2 variables instead of the whole DP array. TC-O(N), SC-O(1). \\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 0)\\n            return 0;\\n        int prev1 = 0;\\n        int prev2 = 0;\\n        for (int i=0;i<nums.size();++i) \\n        {\\n            int temp = prev1;\\n            prev1 = max(prev2 + nums[i], prev1);\\n            prev2 = temp;\\n        }\\n        return prev1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==1)\\n            return nums[0];\\n        vector<int> dp(n,0);\\n        dp[0]=nums[0];\\n        dp[1]=max(nums[0],nums[1]);        \\n        for(int i=2;i<n;i++)\\n        {\\n            dp[i]=max(dp[i-2]+nums[i],dp[i-1]);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        if (nums.size() == 0)\\n            return 0;\\n        int prev1 = 0;\\n        int prev2 = 0;\\n        for (int i=0;i<nums.size();++i) \\n        {\\n            int temp = prev1;\\n            prev1 = max(prev2 + nums[i], prev1);\\n            prev2 = temp;\\n        }\\n        return prev1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579854,
                "title": "python-from-recursion-to-top-down-to-bottom-up",
                "content": "**Recursion sol: Time and Space: O(2^N)**\\n`Recurrence Relation: rob(i) = max(rob(i - 2) + currentHouseValue, rob(i - 1))`\\n*Credits for this relation goes to @heroes3001*\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        return self.robMax(nums, len(nums) - 1) # start from the last/top\\n    \\n    \\n    def robMax(self, nums, i):\\n        if i < 0:\\n            return 0 # when i < 0 we just have to return 0\\n        return max(nums[i] + self.robMax(nums, i - 2), self.robMax(nums, i - 1))\\n```\\n\\n**Recursion + caching = Top-Down: Time and Space: O(N)**\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        dp = [-1 for _ in range(len(nums))] # cache\\n        return self.robMax(nums, dp, len(nums) - 1)\\n    \\n    \\n    def robMax(self, nums, dp, i):\\n        if i < 0:\\n            return 0\\n        \\n        if dp[i] != -1: # if the value of dp[i] is not default i.e. -1 that means we have already calculated it so we dont have to do it again we just have to return it\\n            return dp[i]\\n        \\n        dp[i] = max(nums[i] + self.robMax(nums, dp, i - 2), self.robMax(nums, dp, i - 1))\\n        return dp[i]\\n```\\n\\n**Bottom Up sol: Converting Top Down, Time and Space: O(N)**\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        dp = [-1 for _ in range(len(nums))]\\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1]) # the base cases where rob1 is the amount you can take from 1 house and rob2 is the amount you can take from 2 houses (that will be the maximum of nums[0] and nums[1])\\n        \\n        for i in range(2, len(nums)):\\n            dp[i] = max(nums[i] + dp[i - 2], dp[i - 1]) # the recurrence relation\\n        return dp[len(nums) - 1] # the last value will be your maximum amount of robbery\\n```\\n\\nIn the above solution if we notice carefully we just need the values of the last two values and not a whole array so we can further optimize it.\\n\\n**Bottom Up sol: Time: O(n) Space: O(1)**\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        rob1, rob2 = nums[0], max(nums[0], nums[1])\\n        \\n        for n in nums[2:]:\\n            temp = max(rob1 + n, rob2) # the max amount we can rob from the given house and from the prev\\'s previous and from the previous house\\n            rob1, rob2 = rob2, temp # update both the variables \\n            \\n        return temp # return the max amount\\n```\\nThe last solution can be hard to visualize but try dry running it with a few examples and you\\'ll get it.\\nI hope you understand all the solutions :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        return self.robMax(nums, len(nums) - 1) # start from the last/top\\n    \\n    \\n    def robMax(self, nums, i):\\n        if i < 0:\\n            return 0 # when i < 0 we just have to return 0\\n        return max(nums[i] + self.robMax(nums, i - 2), self.robMax(nums, i - 1))\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        dp = [-1 for _ in range(len(nums))] # cache\\n        return self.robMax(nums, dp, len(nums) - 1)\\n    \\n    \\n    def robMax(self, nums, dp, i):\\n        if i < 0:\\n            return 0\\n        \\n        if dp[i] != -1: # if the value of dp[i] is not default i.e. -1 that means we have already calculated it so we dont have to do it again we just have to return it\\n            return dp[i]\\n        \\n        dp[i] = max(nums[i] + self.robMax(nums, dp, i - 2), self.robMax(nums, dp, i - 1))\\n        return dp[i]\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        dp = [-1 for _ in range(len(nums))]\\n        dp[0], dp[1] = nums[0], max(nums[0], nums[1]) # the base cases where rob1 is the amount you can take from 1 house and rob2 is the amount you can take from 2 houses (that will be the maximum of nums[0] and nums[1])\\n        \\n        for i in range(2, len(nums)):\\n            dp[i] = max(nums[i] + dp[i - 2], dp[i - 1]) # the recurrence relation\\n        return dp[len(nums) - 1] # the last value will be your maximum amount of robbery\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if len(nums) <= 2:\\n            return max(nums)\\n        \\n        rob1, rob2 = nums[0], max(nums[0], nums[1])\\n        \\n        for n in nums[2:]:\\n            temp = max(rob1 + n, rob2) # the max amount we can rob from the given house and from the prev\\'s previous and from the previous house\\n            rob1, rob2 = rob2, temp # update both the variables \\n            \\n        return temp # return the max amount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1472747,
                "title": "my-easy-c-solution-0ms-better-than-100",
                "content": "plz upvote my solution\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        const auto N = nums.size();\\n        if(N == 0) return 0;\\n        if(N == 1) return nums[0];\\n\\n        std::vector<int> dp(N);dp[0] = nums[0];dp[1] = std::max(nums[0],nums[1]);\\n        for (int i = 2; i < N; ++i) {\\n            dp[i] = std::max(dp[i - 2] + nums[i],dp[i-1]);\\n        }\\n        return dp[N-1];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        const auto N = nums.size();\\n        if(N == 0) return 0;\\n        if(N == 1) return nums[0];\\n\\n        std::vector<int> dp(N);dp[0] = nums[0];dp[1] = std::max(nums[0],nums[1]);\\n        for (int i = 2; i < N; ++i) {\\n            dp[i] = std::max(dp[i - 2] + nums[i],dp[i-1]);\\n        }\\n        return dp[N-1];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419217,
                "title": "simple-o-n-javascript-solution-dynamic-programming",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar rob = function(nums) {\\n   let prev = 0,\\n       curr = 0;\\n    \\n    //prev means house at i - 2, curr is house at i - 1\\n    for(let i = 0; i < nums.length; i++){\\n        let temp = Math.max(nums[i] + prev, curr);\\n        prev = curr;\\n        curr = temp;\\n    }\\n    return curr;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar rob = function(nums) {\\n   let prev = 0,\\n       curr = 0;\\n    \\n    //prev means house at i - 2, curr is house at i - 1\\n    for(let i = 0; i < nums.length; i++){\\n        let temp = Math.max(nums[i] + prev, curr);\\n        prev = curr;\\n        curr = temp;\\n    }\\n    return curr;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1345827,
                "title": "dp-0-1-knapsack-memoization-and-tabulation-c",
                "content": "**TOP-DOWN MEMOIZATION** \\n\\n```\\nclass Solution {\\npublic: \\n    int dp[102]; \\n    \\n    int rob(vector<int>& nums) {  \\n        \\n        memset(dp, -1, sizeof(dp)); \\n        \\n        return knapSack(nums, nums.size());\\n        \\n    } \\n    \\n    int knapSack(vector<int> &nums, int n)  { \\n        \\n        if (n <= 0) { \\n            return 0;\\n        } \\n        \\n        if (dp[n] != -1) { \\n            return dp[n];\\n        }\\n        \\n        return dp[n] = max(nums[n-1] + knapSack(nums, n-2), knapSack(nums, n-1));\\n    }\\n};\\n``` \\n\\n**BOTTOM-UP TABULATION** \\n```\\nclass Solution {\\npublic: \\n    \\n    int rob(vector<int>& nums) {  \\n        \\n        int n = nums.size(); \\n        \\n        int dp[n+1]; \\n        \\n        dp[0] = 0;  \\n        dp[1] = nums[0];\\n        \\n        for (int i = 2; i <= n; i++) { \\n            \\n            dp[i] = max (nums[i-1] + dp[i-2], dp[i-1]);\\n        } \\n        \\n        return dp[n];\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int dp[102]; \\n    \\n    int rob(vector<int>& nums) {  \\n        \\n        memset(dp, -1, sizeof(dp)); \\n        \\n        return knapSack(nums, nums.size());\\n        \\n    } \\n    \\n    int knapSack(vector<int> &nums, int n)  { \\n        \\n        if (n <= 0) { \\n            return 0;\\n        } \\n        \\n        if (dp[n] != -1) { \\n            return dp[n];\\n        }\\n        \\n        return dp[n] = max(nums[n-1] + knapSack(nums, n-2), knapSack(nums, n-1));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic: \\n    \\n    int rob(vector<int>& nums) {  \\n        \\n        int n = nums.size(); \\n        \\n        int dp[n+1]; \\n        \\n        dp[0] = 0;  \\n        dp[1] = nums[0];\\n        \\n        for (int i = 2; i <= n; i++) { \\n            \\n            dp[i] = max (nums[i-1] + dp[i-2], dp[i-1]);\\n        } \\n        \\n        return dp[n];\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1286131,
                "title": "c-approach-explanation",
                "content": "Give it a try :)\\n**How to start ?**\\nFor this problem recursive approach will not work.\\nThink for a better approach\\nBelow solution is based on bottom-up approach(DP)\\n*I\\' will try to add other approaches later, Please comment if you got any *\\n\\nEXPLANATION:\\nNote: the probem says you can not rob alternate house and we need to rob maximum value, so we can observe  that we if we choose to rob house[i] then we cann\\'t rob house[i+1], we have to rob from house[i+2].\\nhence you got two choices and we\\'ll take maximum of them\\n  1. To rob ith-house and jump to (i+2)th-house\\n       amount_when_ith_house_choosen=amount[i] + amount from (i+2)th to last house\\n  2. To not rob i-th house and move to (i+1)th house\\n    \\tamount_when_ith_house_not_choosen=amount from (i+1)th to last house   \\nSo, we will continue searching till we reach the end and store the maximum amount robbed from both the choices into an array\\nThe last index of the array will be the aanswer.\\n\\t\\t\\ndp[i] = max( dp[i-2] + amount[i] , dp[i-1]) = max(choose to rob i-th house, choose not to rob i-th house)\\n\\n\\nclass Solution {\\npublic:\\n   \\n#    DP\\n     //DP- don\\'t be scared :)\\n    int rob(vector<int>&nums){\\n        if(nums.size()==1) return nums[0];\\n        int n=nums.size();\\n        int *dp=new int[nums.size()];\\n        dp[0]=nums[0]; \\n        dp[1]=max(nums[1],nums[0]);\\n        for(int i=2;i<n;i++){\\n            dp[i]=max(dp[i-2] + nums[i] , dp[i-1]);\\n        }\\n        int ans= dp[n-1];\\n        delete[] dp; //free this memory\\n        return ans;\\n    }\\n    \\n    \\n  #     USING RECURSION ---> TLE(Time Limit Exceeded)  [Not working]\\n    //using recursion\\n    int helper(vector<int>&nums, int n, int s){\\n        if(s==n-1) return nums[s];\\n        if(s>=n) return 0;\\n        \\n        int robbed=helper(nums,n,s+2) + nums[s];\\n        int not_robbed=helper(nums,n,s+1); \\n        \\n        return max(robbed, not_robbed);\\n    }\\n    \\n    int robRec(vector<int>& nums) {\\n        int n=nums.size();\\n        return helper(nums,n,0);\\n    }\\n};\\n\\n*I have tried my best to explain this problem, if still something I missed something please let me know*",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n   \\n#    DP\\n     //DP- don\\'t be scared :)\\n    int rob(vector<int>&nums){\\n        if(nums.size()==1) return nums[0];\\n        int n=nums.size();\\n        int *dp=new int[nums.size()];\\n        dp[0]=nums[0]; \\n        dp[1]=max(nums[1],nums[0]);\\n        for(int i=2;i<n;i++){\\n            dp[i]=max(dp[i-2] + nums[i] , dp[i-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1164281,
                "title": "python-6-lines-o-1-space-iterating-from-the-start",
                "content": "We build the dependency graph from the start of the list. It contains just 2 elements - f (the first preceding element) and s (the element that precedes f). \\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        f,s = 0,0\\n        for i in nums:\\n            f,s = max(f, s + i),f\\n        return f\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        f,s = 0,0\\n        for i in nums:\\n            f,s = max(f, s + i),f\\n        return f\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161208,
                "title": "cpp-3-approach-recursion-memoization-dynamic-programming-100-faster",
                "content": "**BRUTE FORCE**\\n\\n```\\nclass Solution {\\npublic:\\n    int robHelper(vector<int>&nums, int i){\\n        if(i>=nums.size()){\\n            return 0;\\n        }\\n        int a = robHelper(nums, i+2) + nums[i];\\n        int b = robHelper(nums, i+1);\\n        return max(a,b);\\n    }\\n    int rob(vector<int>& nums){\\n        return robHelper(nums,0);\\n    }\\n};\\n```\\nThis solution will show TLE\\n\\n\\n\\n**MEMOIZATION**\\n\\n```\\nclass Solution {\\npublic:\\n    int robHelper(vector<int>&nums, int i, int*dp){\\n        int n = nums.size();\\n        if(i>=n){\\n            return 0;\\n        }\\n        \\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        \\n        int a = robHelper(nums, i+2,dp) + nums[i];\\n        int b = robHelper(nums, i+1,dp);\\n        int ans = max(a,b);\\n        dp[i] = ans;\\n        return ans;\\n    }\\n    int rob(vector<int>& nums){\\n        int n = nums.size();\\n        int *dp = new int[n+1];\\n        for(int i=0; i<=n; i++){\\n            dp[i] = -1;\\n        }\\n        return robHelper(nums,0,dp);\\n    }\\n};\\n\\n```\\n\\n**DYNAMIC PROGRAMMING**\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums){\\n        int *dp = new int[nums.size()];\\n        int n = nums.size();\\n        if(n==0) {\\n            return 0;\\n        }\\n        if(n==1){\\n         return nums[0];   \\n        }\\n        if(n==2){\\n          return max(nums[1],nums[0]);  \\n        }\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for(int i = 2; i <nums.size(); i++){\\n            dp[i] = max(nums[i] + dp[i-2], dp[i-1]);\\n        }\\n        return dp[nums.size()-1];\\n        delete[] dp;\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int robHelper(vector<int>&nums, int i){\\n        if(i>=nums.size()){\\n            return 0;\\n        }\\n        int a = robHelper(nums, i+2) + nums[i];\\n        int b = robHelper(nums, i+1);\\n        return max(a,b);\\n    }\\n    int rob(vector<int>& nums){\\n        return robHelper(nums,0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int robHelper(vector<int>&nums, int i, int*dp){\\n        int n = nums.size();\\n        if(i>=n){\\n            return 0;\\n        }\\n        \\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        \\n        int a = robHelper(nums, i+2,dp) + nums[i];\\n        int b = robHelper(nums, i+1,dp);\\n        int ans = max(a,b);\\n        dp[i] = ans;\\n        return ans;\\n    }\\n    int rob(vector<int>& nums){\\n        int n = nums.size();\\n        int *dp = new int[n+1];\\n        for(int i=0; i<=n; i++){\\n            dp[i] = -1;\\n        }\\n        return robHelper(nums,0,dp);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 991999,
                "title": "recursion-and-memoization-c-aditya-verma-approach",
                "content": "Recursion -\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // recursive\\n    \\n    int fun(vector<int> &v, int i)\\n    {\\n        if(i<0)\\n            return 0;\\n            \\n        int num1 = fun(v,i-2) + v[i];\\n        int num2 = fun(v,i-1);\\n        \\n        return max(num1,num2);\\n    }\\n    \\n    int rob(vector<int>& v) \\n    {   \\n        int n = v.size();\\n        return fun(v,n-1);\\n    }\\n};\\n```\\n\\nMemoization - \\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // memoization\\n    \\n    vector<int> dp;\\n    \\n    int fun(vector<int> &v, int i)\\n    {\\n        if(i<0)\\n            return 0;\\n            \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        int num1 = fun(v,i-2) + v[i];\\n        int num2 = fun(v,i-1);\\n        \\n        return dp[i] = max(num1,num2);\\n    }\\n    \\n    int rob(vector<int>& v) \\n    {   \\n        int n = v.size();\\n        \\n        dp.clear();\\n        dp.resize(n+1,-1);\\n        return fun(v,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // recursive\\n    \\n    int fun(vector<int> &v, int i)\\n    {\\n        if(i<0)\\n            return 0;\\n            \\n        int num1 = fun(v,i-2) + v[i];\\n        int num2 = fun(v,i-1);\\n        \\n        return max(num1,num2);\\n    }\\n    \\n    int rob(vector<int>& v) \\n    {   \\n        int n = v.size();\\n        return fun(v,n-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // memoization\\n    \\n    vector<int> dp;\\n    \\n    int fun(vector<int> &v, int i)\\n    {\\n        if(i<0)\\n            return 0;\\n            \\n        if(dp[i]!=-1)\\n            return dp[i];\\n        \\n        int num1 = fun(v,i-2) + v[i];\\n        int num2 = fun(v,i-1);\\n        \\n        return dp[i] = max(num1,num2);\\n    }\\n    \\n    int rob(vector<int>& v) \\n    {   \\n        int n = v.size();\\n        \\n        dp.clear();\\n        dp.resize(n+1,-1);\\n        return fun(v,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 860590,
                "title": "java-dp-solution-faster-than-100-submission",
                "content": "**Java self explanatory Code**\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length==0)\\n            return 0;\\n        if(nums.length==1)\\n            return nums[0];\\n        if(nums.length==2)\\n            return Math.max(nums[0],nums[1]);\\n        int dp[] = new int[nums.length];\\n        dp[0]=nums[0];\\n        dp[1]=Math.max(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]);//maximum of the previous element or the sum of current element and the previous of previous element.\\n        }\\n        return dp[nums.length-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        if(nums.length==0)\\n            return 0;\\n        if(nums.length==1)\\n            return nums[0];\\n        if(nums.length==2)\\n            return Math.max(nums[0],nums[1]);\\n        int dp[] = new int[nums.length];\\n        dp[0]=nums[0];\\n        dp[1]=Math.max(nums[0],nums[1]);\\n        for(int i=2;i<nums.length;i++){\\n            dp[i]=Math.max(dp[i-1],dp[i-2]+nums[i]);//maximum of the previous element or the sum of current element and the previous of previous element.\\n        }\\n        return dp[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847546,
                "title": "length-of-last-word-java-beats-100-simple-and-explained",
                "content": "This problem is real simple when we start to iterate from end to beginning of the given string.\\n1. First while loop, iterates over all the empty spaces at the end\\nExample String: ```s = \"Hello \"``` Last word is \\'Hello\\', but there is an extra space, thus we are removing all such spaces from consideration in this loop.\\n2. Second loop iterates over the last word and count number of characters in it\\n```\\npublic int lengthOfLastWord(String s) {\\n\\tint i = s.length() - 1, len = 0;\\n\\twhile (i >= 0 && s.charAt(i) == \\' \\') {i--;};\\n\\twhile (i >= 0 && s.charAt(i) != \\' \\'){ len++; i--;}\\n\\treturn len;\\n}\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```s = \"Hello \"```\n```\\npublic int lengthOfLastWord(String s) {\\n\\tint i = s.length() - 1, len = 0;\\n\\twhile (i >= 0 && s.charAt(i) == \\' \\') {i--;};\\n\\twhile (i >= 0 && s.charAt(i) != \\' \\'){ len++; i--;}\\n\\treturn len;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 846848,
                "title": "python-recursive-dp-using-lru-cache-super-simple",
                "content": "The lru_cache deorator is a great way to solve DP problems intuitively. Instead of having to store state in a map or a DP table, you can take a more mathematical approach to problems like these and not worry about the memoisation aspect of it.\\n\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        from functools import lru_cache\\n        \\n        n = len(nums)\\n        \\n        @lru_cache(maxsize=None)\\n        def dp(i, state, cur):\\n            if i >= n:\\n                return cur\\n            if state == True:\\n                return dp(i+1, False, cur)\\n            else:\\n                l = dp(i+1, False, cur)\\n                r = dp(i+1, True, cur+nums[i])\\n                \\n                return max(l, r)\\n        return dp(0, False, 0)\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        from functools import lru_cache\\n        \\n        n = len(nums)\\n        \\n        @lru_cache(maxsize=None)\\n        def dp(i, state, cur):\\n            if i >= n:\\n                return cur\\n            if state == True:\\n                return dp(i+1, False, cur)\\n            else:\\n                l = dp(i+1, False, cur)\\n                r = dp(i+1, True, cur+nums[i])\\n                \\n                return max(l, r)\\n        return dp(0, False, 0)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846151,
                "title": "faster-than-100-00-memory-less-than-98-42-cpp-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0) return 0;\\n        if(n==1) return nums[0];\\n\\t\\t\\n        int lastmax=nums[0],maxi=max(nums[0],nums[1]);\\n        \\n        for(int i=2;i<n;++i) {\\n            int extra=maxi;\\n            maxi=max(maxi, lastmax+nums[i]);\\n            lastmax=extra;\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==0) return 0;\\n        if(n==1) return nums[0];\\n\\t\\t\\n        int lastmax=nums[0],maxi=max(nums[0],nums[1]);\\n        \\n        for(int i=2;i<n;++i) {\\n            int extra=maxi;\\n            maxi=max(maxi, lastmax+nums[i]);\\n            lastmax=extra;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846016,
                "title": "java-dynamic-programming-easy-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        // edge cases:\\n        if (nums.length == 0) return 0;\\n        if (nums.length == 1) return nums[0];\\n        if (nums.length == 2) return Math.max(nums[0], nums[1]);\\n        \\n        // dynamic programming - decide each problem by its sub-problems:\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        dp[1] = Math.max(nums[0], nums[1]);\\n        for (int i=2; i<nums.length; i++)\\n            dp[i] = Math.max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        // edge cases:\\n        if (nums.length == 0) return 0;\\n        if (nums.length == 1) return nums[0];\\n        if (nums.length == 2) return Math.max(nums[0], nums[1]);\\n        \\n        // dynamic programming - decide each problem by its sub-problems:\\n        int[] dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        dp[1] = Math.max(nums[0], nums[1]);\\n        for (int i=2; i<nums.length; i++)\\n            dp[i] = Math.max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846011,
                "title": "c-dynamic-programming-short-and-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        // edge cases:\\n        if (nums.size() == 0) return 0;\\n        if (nums.size() == 1) return nums[0];\\n        if (nums.size() == 2) return max(nums[0], nums[1]);\\n        \\n        // dynamic programming - decide each problem by its sub-problems:\\n        int dp[nums.size()];\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        // edge cases:\\n        if (nums.size() == 0) return 0;\\n        if (nums.size() == 1) return nums[0];\\n        if (nums.size() == 2) return max(nums[0], nums[1]);\\n        \\n        // dynamic programming - decide each problem by its sub-problems:\\n        int dp[nums.size()];\\n        dp[0] = nums[0];\\n        dp[1] = max(nums[0], nums[1]);\\n        for (int i=2; i<nums.size(); i++)\\n            dp[i] = max(dp[i-1], nums[i]+dp[i-2]);\\n        return dp[nums.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733107,
                "title": "python3-dp-top-down-bottom-up",
                "content": "Define `fn(i)` as the maximum amount of money after robbing `i`th house. Then, below recursive relation holds \\n\\n`fn(i) = max(fn(i-1), fn(i-2) + nums[i])` for `i >= 0` and `fn(i) = 0` for `i < 0`;\\n\\nAs a result, it can be solved using dynamic programming. \\n\\ntop-down implementation (`O(N)` time & `O(N)` space)\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def fn(i):\\n            \"\"\"Return the maximum amount of money robbing up to ith house.\"\"\"\\n            if i < 0: return 0\\n            return max(fn(i-1), fn(i-2) + nums[i])\\n        \\n        return fn(len(nums)-1)\\n```\\n\\nbottom-up implementation (`O(N)` time & `O(1)` space)\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        f0 = f1 = 0\\n        for x in nums: f0, f1 = f1, max(f1, f0+x)\\n        return f1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def fn(i):\\n            \"\"\"Return the maximum amount of money robbing up to ith house.\"\"\"\\n            if i < 0: return 0\\n            return max(fn(i-1), fn(i-2) + nums[i])\\n        \\n        return fn(len(nums)-1)\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        f0 = f1 = 0\\n        for x in nums: f0, f1 = f1, max(f1, f0+x)\\n        return f1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 512490,
                "title": "python-js-java-go-c-o-n-sol-by-dp-w-visualization",
                "content": "O(n) sol. by dynamic programming.\\n\\n---\\n\\n**Visualization**:\\n\\n![image](https://assets.leetcode.com/users/images/997ee642-7503-434b-be17-cc65e70fca70_1598862172.6326396.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/950de25b-aec2-4ac9-a1f4-8329b64dc3a0_1598862187.8272965.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/b60e468d-fe8f-4ca8-ade7-957840a119f3_1598862199.4649277.png)\\n\\n\\n---\\n\\n**Hint**:\\nThink of the **item value taking optimization** with **Dynamic programming**.\\n\\n---\\n\\n**Algorithm**:\\nSolve by dynamic programming with the **Optimal substructure** (i.e., recurrence relationship) as following:\\n\\nLet **Optimal[i]** denotes the highest value taking, considering from house_#0 to house_#i\\n\\n**Optimal**[ *i* ] \\n= Optimization of ( **Take** house_#*i* , or **Not to take** house_#*i* )\\n= Max( **Optimal**[ *i* - 2 ] + nums[*i*] , **Optimal**[ *i* - 1 ] )\\n\\n---\\n\\n**Implementation** by bottom-up dynamic programming:\\nPython:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        value_dp = [ 0 for _ in range(size) ]\\n        \\n        if size == 0:\\n            # Empty list\\n            return 0\\n        \\n        elif size == 1:\\n            # Only one item\\n            return nums[0]\\n    \\n        else:\\n            # Initialization\\n            value_dp[0] = nums[0]\\n            value_dp[1] = max(nums[0], nums[1])\\n\\n            # General case\\n            for i in range(2, size):\\n                value_dp[i] = max(value_dp[i-2] + nums[i], value_dp[i-1] )\\n\\n            return value_dp[-1]\\n```\\n\\nor\\n\\nwith space-optimization\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        # Since we only refer to previous two grids, we can carry out space optimization\\n        \\n        # refer to dp[i-2]\\n        take_prev_2 = 0\\n        \\n        # refer to dp[i-1]\\n        take_prev_1 = 0\\n        \\n\\t\\tprofit = 0\\n\\t\\t\\n        for number in nums:\\n            \\n            profit = max(take_prev_2 + number, take_prev_1 + 0)\\n            take_prev_2 = take_prev_1\\n            take_prev_1 = profit\\n        \\n      \\n        return profit\\n```\\n\\n---\\n\\nJava:\\n\\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        // Since we only refer to previous two grids, we can carry out space optimization\\n        \\n        // refer to dp[i-2]\\n        int take_prev_2 = 0;\\n        \\n        // refer to dp[i-1]\\n        int take_prev_1 = 0;\\n        \\n        int profit = 0;\\n        \\n        for(int value : nums){\\n            \\n            profit = Math.max(take_prev_2 + value, take_prev_1 + 0);\\n            take_prev_2 = take_prev_1;\\n            take_prev_1 = profit;\\n        }\\n      \\n        return profit;\\n    }\\n}\\n```\\n\\n---\\n\\nJavscript:\\n\\n```\\nvar rob = function(nums) {\\n    \\n    size = nums.length;\\n    value = Array(size).fill(0);\\n    \\n    if( size == 0 ){\\n        // empty input\\n        return 0;\\n        \\n    }else if( size == 1 ){\\n        // only one item\\n        return nums[0];\\n    }\\n    \\n    \\n    // initialization\\n    \\n    value[0] = nums[0];\\n    value[1] = Math.max( nums[0], nums[1] );\\n    \\n    // general case\\n    for( let i = 2 ; i < size ; i++){\\n        \\n        value[i] = Math.max( value[i-2] + nums[i],  value[i-1] + 0 );\\n    }\\n    \\n    return value[size-1];\\n};\\n```\\n\\nor\\n\\nwith space-optimization\\n\\n```\\nvar rob = function(nums) {\\n    \\n        // Since we only refer to previous two grids, we can carry out space optimization\\n        \\n        // refer to dp[i-2]\\n        let take_prev_2 = 0\\n        \\n        // refer to dp[i-1]\\n        let take_prev_1 = 0\\n        \\n        let profit = 0;\\n        \\n        for(const value of nums){\\n            \\n            profit = Math.max(take_prev_2 + value, take_prev_1 + 0);\\n            take_prev_2 = take_prev_1;\\n            take_prev_1 = profit;\\n        }\\n      \\n        return profit\\n\\n};\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        size_t size = nums.size() ;\\n        \\n        // dp table for maximum value\\n        vector<int> value = vector<int>( size );\\n        \\n        \\n        if( size == 0 ){\\n            // empty list\\n            return 0;\\n        }else if( size == 1 ){\\n            // only one item\\n            return nums[0];\\n        }\\n        \\n        // initialization\\n        value[0] = nums[0];\\n        value[1] = max(nums[0], nums[1]);\\n        \\n        // general cases\\n        for( size_t i = 2 ; i < size ; i++){\\n            value[i] = max( value[i-2] + nums[i], value[i-1] + 0 );\\n        }\\n        \\n        return value[size-1];\\n    }\\n};\\n```\\n\\nor\\n\\nwith space-optimization\\n\\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        // Since we only refer to previous two grids, we can carry out space optimization\\n        \\n        // refer to dp[i-2]\\n        int prev_2 = 0;\\n            \\n        // refer to dp[i-1]\\n        int prev_1 = 0;\\n        \\n        int profit = 0;\\n        \\n        for( const int& value : nums){\\n            \\n            profit = max( prev_2 + value, prev_1 + 0 );\\n            prev_2 = prev_1;\\n            prev_1 = profit;\\n        }\\n        \\n        return profit;\\n        \\n    }\\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\n\\n// Golang does\\'t have natural built-in max function for integer type\\nfunc max(a, b int) int{\\n    if a >= b{\\n        return a\\n    }else{\\n        return b\\n    }\\n}\\n\\n\\n\\nfunc rob(nums []int) int {\\n    \\n    size := len(nums)\\n    value := make([]int, size)\\n    \\n    if size == 0{\\n        \\n        // empty input\\n        return 0\\n    }else if size == 1{\\n        \\n        // only one item\\n        return nums[0]\\n    }\\n    \\n    // initialization\\n    value[0] = nums[0]\\n    value[1] = max(nums[0], nums[1])\\n    \\n    // general case\\n    for i := 2 ; i < size ; i++ {\\n        value[i] = max( value[i-2] + nums[i], value[i-1] + 0 )\\n    }\\n    \\n    return value[size-1]\\n}\\n```\\n\\nor\\n\\nwith space optimiaztion\\n\\n```\\n\\n// Golang does\\'t have natural built-in max function for integer type\\nfunc max(a, b int) int{\\n    if a >= b{\\n        return a\\n    }else{\\n        return b\\n    }\\n}\\n\\n\\n\\nfunc rob(nums []int) int {\\n    \\n    // Since we only refer to previous two grids, we can carry out space optimization\\n    \\n    // refer to dp[i-2]\\n    prev_2 := 0\\n    \\n    // refer to dp[i-1]\\n    prev_1 := 0\\n    \\n    profit := 0\\n    \\n    for _, value := range nums{\\n        \\n        profit = max( prev_2 + value, prev_1 + 0 )\\n        \\n        prev_2, prev_1 = prev_1, profit\\n    }\\n    \\n    return profit\\n}\\n```\\n\\n---\\n\\n**Implementation** by top-down DP with memoization:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        # DP table\\n        # key: index i \\n        # value: max rob value consider from 0 to i, inclusively\\n        dp = {}\\n\\n        def consider( i ):\\n\\n            # look-up table\\n            if i in dp:\\n                return dp[i]\\n            \\n            # base case\\n            if i == 0:\\n                dp[0] = nums[0]\\n                return dp[0]\\n            \\n            # base case\\n            if i == 1:\\n                dp[1] = max(nums[0], nums[1])\\n                return dp[1]\\n            \\n            # general case\\n            take = nums[i] + consider(i-2)\\n            skip = 0 + consider(i-1)\\n\\n            dp[i] = max( take, skip )\\n            return dp[i]\\n        # ----------------------------------------\\n        last_house = len(nums)-1\\n        return consider(last_house)\\n            \\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        size = len(nums)\\n        value_dp = [ 0 for _ in range(size) ]\\n        \\n        if size == 0:\\n            # Empty list\\n            return 0\\n        \\n        elif size == 1:\\n            # Only one item\\n            return nums[0]\\n    \\n        else:\\n            # Initialization\\n            value_dp[0] = nums[0]\\n            value_dp[1] = max(nums[0], nums[1])\\n\\n            # General case\\n            for i in range(2, size):\\n                value_dp[i] = max(value_dp[i-2] + nums[i], value_dp[i-1] )\\n\\n            return value_dp[-1]\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        # Since we only refer to previous two grids, we can carry out space optimization\\n        \\n        # refer to dp[i-2]\\n        take_prev_2 = 0\\n        \\n        # refer to dp[i-1]\\n        take_prev_1 = 0\\n        \\n\\t\\tprofit = 0\\n\\t\\t\\n        for number in nums:\\n            \\n            profit = max(take_prev_2 + number, take_prev_1 + 0)\\n            take_prev_2 = take_prev_1\\n            take_prev_1 = profit\\n        \\n      \\n        return profit\\n```\n```\\nclass Solution {\\n    public int rob(int[] nums) {\\n        \\n        // Since we only refer to previous two grids, we can carry out space optimization\\n        \\n        // refer to dp[i-2]\\n        int take_prev_2 = 0;\\n        \\n        // refer to dp[i-1]\\n        int take_prev_1 = 0;\\n        \\n        int profit = 0;\\n        \\n        for(int value : nums){\\n            \\n            profit = Math.max(take_prev_2 + value, take_prev_1 + 0);\\n            take_prev_2 = take_prev_1;\\n            take_prev_1 = profit;\\n        }\\n      \\n        return profit;\\n    }\\n}\\n```\n```\\nvar rob = function(nums) {\\n    \\n    size = nums.length;\\n    value = Array(size).fill(0);\\n    \\n    if( size == 0 ){\\n        // empty input\\n        return 0;\\n        \\n    }else if( size == 1 ){\\n        // only one item\\n        return nums[0];\\n    }\\n    \\n    \\n    // initialization\\n    \\n    value[0] = nums[0];\\n    value[1] = Math.max( nums[0], nums[1] );\\n    \\n    // general case\\n    for( let i = 2 ; i < size ; i++){\\n        \\n        value[i] = Math.max( value[i-2] + nums[i],  value[i-1] + 0 );\\n    }\\n    \\n    return value[size-1];\\n};\\n```\n```\\nvar rob = function(nums) {\\n    \\n        // Since we only refer to previous two grids, we can carry out space optimization\\n        \\n        // refer to dp[i-2]\\n        let take_prev_2 = 0\\n        \\n        // refer to dp[i-1]\\n        let take_prev_1 = 0\\n        \\n        let profit = 0;\\n        \\n        for(const value of nums){\\n            \\n            profit = Math.max(take_prev_2 + value, take_prev_1 + 0);\\n            take_prev_2 = take_prev_1;\\n            take_prev_1 = profit;\\n        }\\n      \\n        return profit\\n\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        size_t size = nums.size() ;\\n        \\n        // dp table for maximum value\\n        vector<int> value = vector<int>( size );\\n        \\n        \\n        if( size == 0 ){\\n            // empty list\\n            return 0;\\n        }else if( size == 1 ){\\n            // only one item\\n            return nums[0];\\n        }\\n        \\n        // initialization\\n        value[0] = nums[0];\\n        value[1] = max(nums[0], nums[1]);\\n        \\n        // general cases\\n        for( size_t i = 2 ; i < size ; i++){\\n            value[i] = max( value[i-2] + nums[i], value[i-1] + 0 );\\n        }\\n        \\n        return value[size-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        \\n        // Since we only refer to previous two grids, we can carry out space optimization\\n        \\n        // refer to dp[i-2]\\n        int prev_2 = 0;\\n            \\n        // refer to dp[i-1]\\n        int prev_1 = 0;\\n        \\n        int profit = 0;\\n        \\n        for( const int& value : nums){\\n            \\n            profit = max( prev_2 + value, prev_1 + 0 );\\n            prev_2 = prev_1;\\n            prev_1 = profit;\\n        }\\n        \\n        return profit;\\n        \\n    }\\n};\\n```\n```\\n\\n// Golang does\\'t have natural built-in max function for integer type\\nfunc max(a, b int) int{\\n    if a >= b{\\n        return a\\n    }else{\\n        return b\\n    }\\n}\\n\\n\\n\\nfunc rob(nums []int) int {\\n    \\n    size := len(nums)\\n    value := make([]int, size)\\n    \\n    if size == 0{\\n        \\n        // empty input\\n        return 0\\n    }else if size == 1{\\n        \\n        // only one item\\n        return nums[0]\\n    }\\n    \\n    // initialization\\n    value[0] = nums[0]\\n    value[1] = max(nums[0], nums[1])\\n    \\n    // general case\\n    for i := 2 ; i < size ; i++ {\\n        value[i] = max( value[i-2] + nums[i], value[i-1] + 0 )\\n    }\\n    \\n    return value[size-1]\\n}\\n```\n```\\n\\n// Golang does\\'t have natural built-in max function for integer type\\nfunc max(a, b int) int{\\n    if a >= b{\\n        return a\\n    }else{\\n        return b\\n    }\\n}\\n\\n\\n\\nfunc rob(nums []int) int {\\n    \\n    // Since we only refer to previous two grids, we can carry out space optimization\\n    \\n    // refer to dp[i-2]\\n    prev_2 := 0\\n    \\n    // refer to dp[i-1]\\n    prev_1 := 0\\n    \\n    profit := 0\\n    \\n    for _, value := range nums{\\n        \\n        profit = max( prev_2 + value, prev_1 + 0 )\\n        \\n        prev_2, prev_1 = prev_1, profit\\n    }\\n    \\n    return profit\\n}\\n```\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        \\n        # DP table\\n        # key: index i \\n        # value: max rob value consider from 0 to i, inclusively\\n        dp = {}\\n\\n        def consider( i ):\\n\\n            # look-up table\\n            if i in dp:\\n                return dp[i]\\n            \\n            # base case\\n            if i == 0:\\n                dp[0] = nums[0]\\n                return dp[0]\\n            \\n            # base case\\n            if i == 1:\\n                dp[1] = max(nums[0], nums[1])\\n                return dp[1]\\n            \\n            # general case\\n            take = nums[i] + consider(i-2)\\n            skip = 0 + consider(i-1)\\n\\n            dp[i] = max( take, skip )\\n            return dp[i]\\n        # ----------------------------------------\\n        last_house = len(nums)-1\\n        return consider(last_house)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 405055,
                "title": "cpp-easy-100-beat-simple-3-line-code",
                "content": "```\\nint rob(vector<int>& nums) {\\n\\tint inc = 0, ex = 0;\\n\\tfor(auto it : nums){\\n\\t// To include current element need to exclude pre element\\n\\t\\tint ninc = ex + it;\\n\\t// to exlucde current we will take max upto previous\\n\\t\\tex = max(inc, ex), inc = ninc;\\n\\t}\\n\\treturn max(inc, ex);\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint rob(vector<int>& nums) {\\n\\tint inc = 0, ex = 0;\\n\\tfor(auto it : nums){\\n\\t// To include current element need to exclude pre element\\n\\t\\tint ninc = ex + it;\\n\\t// to exlucde current we will take max upto previous\\n\\t\\tex = max(inc, ex), inc = ninc;\\n\\t}\\n\\treturn max(inc, ex);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 341554,
                "title": "python-dynamic-progranming",
                "content": "Run time O(N), space O(1)\\n```\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        if len(nums) < 2:\\n            return nums[0]\\n        nums[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            nums[i] = max((nums[i-2]+nums[i]), nums[i-1])\\n            print(nums)\\n        return nums[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums:\\n            return 0\\n        if len(nums) < 2:\\n            return nums[0]\\n        nums[1] = max(nums[0], nums[1])\\n        for i in range(2, len(nums)):\\n            nums[i] = max((nums[i-2]+nums[i]), nums[i-1])\\n            print(nums)\\n        return nums[-1]\\n```",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1704140,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1573183,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1570429,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1565038,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1875755,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1716458,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1576563,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1570165,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1565134,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1715861,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1704140,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1573183,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1570429,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1565038,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1875755,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1716458,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1576563,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1570165,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1565134,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1715861,
                "content": [
                    {
                        "username": "b10s",
                        "content": "I think the test case `[2,1,1,2]` must be in description. Otherwise from the current two cases we can assume to check odd/even elements only. "
                    },
                    {
                        "username": "user9896r",
                        "content": "You are right"
                    },
                    {
                        "username": "nik216",
                        "content": "That\\'s the trick ..."
                    },
                    {
                        "username": "i_0x6c1_i",
                        "content": "This is so true. I was actually thinking that only."
                    },
                    {
                        "username": "pranav4magdum",
                        "content": "yes right brother"
                    },
                    {
                        "username": "Akash_Lawande",
                        "content": "exactly what i did\\n"
                    },
                    {
                        "username": "natitati",
                        "content": "I fell for that too, haha"
                    },
                    {
                        "username": "yash_jadaun",
                        "content": "I will assume the  odd/even  testcase  only . Now I  have to think [2,1,1,2] testcase."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "That one got me too, but I think part of the challenge is coming up with a test like that yourself. Just returning odds or even is not dynamic programming."
                    },
                    {
                        "username": "omarzs",
                        "content": "really misleading test cases in descriptions"
                    },
                    {
                        "username": "ANURAG_YADAV_000",
                        "content": "yes sir \\n"
                    },
                    {
                        "username": "yug_tyagi",
                        "content": "thats the beauty if qn only "
                    },
                    {
                        "username": "AnketSingh",
                        "content": "Yes, thats what I implenmented at first! Lol they must have described in sample test cases."
                    },
                    {
                        "username": "Yongbi",
                        "content": "[@b10s](/b10s) I understand what you mean. \\nThe choice of rep exercises is a bit tricky, if they change nums = [1,2,3,1]  -> [1,2,1,3] it would be clearer.\\nPerhaps the author of the question was deliberately misleading!!"
                    },
                    {
                        "username": "b10s",
                        "content": "[@Yongbi](/Yongbi) in description I see [1,2,3,1] and [2,7,9,3,1] only. Neither [2,1,1,2] nor [2,1,7,9]."
                    },
                    {
                        "username": "Yongbi",
                        "content": "For the test case [2,1,7,9] in your opinion, what would you choose? According to the description of the problem, I will choose 2+9 because 2+max(7,9). So checking parity arrays is not reasonable."
                    },
                    {
                        "username": "udavid",
                        "content": "\"You are a professional robber planning to rob houses along a street.\"\\n\\nI refuse to believe that a professional robber would ever attempt to rob a street that had no houses on it. The description should be updated to indicate that the robber is perhaps an amateur robber, or a blind robber."
                    },
                    {
                        "username": "HappyLoganLi",
                        "content": "[@bhumika-aga](/bhumika-aga) Maybe that\\'s why leetcode editor removed the \"nums=[]\" from test cases "
                    },
                    {
                        "username": "Zachary1988",
                        "content": "If you think that\\'s bad, just wait until you hear about the bozo who designed an alarm that only goes off if the robber hits your next door neighbor too."
                    },
                    {
                        "username": "bhumika-aga",
                        "content": "I think you are focussing on the wrong point here. :P"
                    },
                    {
                        "username": "debz_9830",
                        "content": "haha point :\\')"
                    },
                    {
                        "username": "mtundi",
                        "content": "[@Yongbi](/Yongbi) \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "Yongbi",
                        "content": "and he won\\'t be foolish enough to optimize the amount of money he stole tonight :\")"
                    },
                    {
                        "username": "coder1311",
                        "content": "**We need more posts or explanations like this**\\nhttps://leetcode.com/problems/house-robber/discuss/156523/From-good-to-great.-How-to-approach-most-of-DP-problems.\\nNot only me, everyone wants this kind of explanation.\\nPlease everyone just stop posting direct solutions. Post with as much possible comments.\\nIf anyone want to post One-Liners Solution, they must also post detailed solution before with explanation. Then the one-liner will be more joyful to understand and earn.\\n\\n**WE SHOULD MAKE A RULE----**\\nDownvote the posts which are direct solutions with no or less comments added as needed.\\nUpvote only these kind of solutions.\\nWe have to bring this change, as the direct solutions is frustrating and very time-wasting to understand.\\nRequesting Everyone!!!!\\n**Be a part of this CHANGE.  **"
                    },
                    {
                        "username": "lauchokyip",
                        "content": "I still found it hard to understand the explanation from that post :/ For me, picture > words\n\nSo I posted another one which would help people wrap their head around with systematic appraoch https://leetcode.com/problems/house-robber/solutions/3691266/python3-clean-code-approach-graphical-approach-systematic-approach/\n\nHope it helps!"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "I\\'m tired of reporting solutions posted in Discussions tab as well as it is against the rules, it for feedback, tips or general discussion. I used to report before but I think its of no use, Discussions are still flooded with solutions or advertisement spam."
                    },
                    {
                        "username": "nick46",
                        "content": "Here is the DP formula that leads to the right answer:\\n\\n - M(k) = money at the kth house\\n - P(0) = 0\\n - P(1) = M(1)\\n - P(k) = max(P(k\\u22122) + M(k), P(k\\u22121))"
                    },
                    {
                        "username": "Skripko",
                        "content": "[@sankiii_7](/sankiii_7) no, it depends on your origin. If you prefer 0 index, then your remark has place to be"
                    },
                    {
                        "username": "nirutgupta",
                        "content": "[@sankiii_7](/sankiii_7) he/she is using 1 index here."
                    },
                    {
                        "username": "sankalpxanand",
                        "content": "P(1) should be max(M(0),M(1)) and not M(1) only"
                    },
                    {
                        "username": "JobHunterPlus",
                        "content": "I\\'m a law abiding citizen, so I will always return 0 :)"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "Andhbhakt"
                    },
                    {
                        "username": "normalpersontryingtopayrent",
                        "content": "I hope to always be the adjacent house. "
                    },
                    {
                        "username": "Trifi-lit",
                        "content": "[@sehajdeep2611](/sehajdeep2611) also living adjacent to people with a lot of money may help"
                    },
                    {
                        "username": "sehajdeep2611",
                        "content": "Just have minimum money with you and you will almost always be safe. (from THIS robber)"
                    },
                    {
                        "username": "bweez",
                        "content": "The emphasis on TWO is misleading in the question.  It can be interpreted two ways.  It could be a house with two adjacent break-ins (ie break-ins on both sides) or two houses next to each other (ie neighbors).  The latter is the intended meaning.  It would be a simple fix of removing TWO from the wording.\\n`it will automatically contact the police if two adjacent houses were broken into on the same night` \\n`=>` \\n`it will automatically contact the police if adjacent houses were broken into on the same night`"
                    },
                    {
                        "username": "marsrover4",
                        "content": "agreed"
                    },
                    {
                        "username": "BeatrizdOS",
                        "content": "I mean, it\\'s an easy dp + memoization problem, but I don\\'t think the community in general has mastered this topic to do this easily. Is there any naive solution to this problem that doesn\\'t give TLE?"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "[@Sahil_23](/Sahil_23) did u find out naive solution?\\n"
                    },
                    {
                        "username": "Sahil_23",
                        "content": "can you please explain how did you solve this ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/house-robber/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion with Memoization\n\n  \n**Approach 2:** Dynamic Programming\n\n  \n**Approach 3:** Optimized Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Msey",
                        "content": "Too easy to be medium"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "TLE make it tougher."
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "True. They asked a slightly tougher problem couple of days before in the daily challenge which was categorized as Easy."
                    }
                ]
            },
            {
                "id": 1715994,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 1575589,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 1567528,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 1569324,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 1980936,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 1928954,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 1716180,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 1571419,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 2000829,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 1997944,
                "content": [
                    {
                        "username": "disturbedbrown1",
                        "content": "Imagine robbers planning their workflows with such algorithms ;)"
                    },
                    {
                        "username": "Sudeepreddy537",
                        "content": "indian robbers always plans an algo for everything\\n"
                    },
                    {
                        "username": "user4740t",
                        "content": "dp[0] = nums[0]\\ndp[1] = max(nums[0], nums[1])\\ndp[i] = max(dp(i - 1), dp(i - 2) + nums[i])"
                    },
                    {
                        "username": "leetavenger",
                        "content": "**Post python3 one-liners here for fun, the shorter the better. How many of this month\\'s problems will fall to a one-line solution?**\\n\\nCurrently 16/26 for September! (And I think we can add more.)\\n\\n*These are mostly written in what you might call \"lisc\" (or maybe \"pisp\") -> python 3 code that is written almost entirely using list comprehensions, recursion and (as a last resort) lambdas. Basically a language for people who think that python is a funky and slow functional lisp. Yes, they would probably work better in some other language, but abusing python is fun!*\\n\\n*Abusing javascript would also be fun if anyone is in the mood.*\\n\\n"
                    },
                    {
                        "username": "jl4930",
                        "content": "When I see it is easy, I will not reckon using DP to solve it."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Before going, one tip .\\nI failed to notice and ended up with wrong solution first.\\n\\nDon\\'t think like this\\n\\nThe solution is not like this.\\n\\nMaximum of( (1,3,5,9 ) - Odd Elements  ,  (2,4,6,8 ) - Even Elements )\\n\\nIf input is \\n( 40,2,4,10)\\n For this if we apply above solution\\nwe got 44 and 12\\nand maximum is 44 which was wrong\\uD83D\\uDE05\\n\\nWe will steal at first  and  last house, which will give 50.\\n( First and Last is not adjacent house )\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB\\n\\n"
                    },
                    {
                        "username": "Fful",
                        "content": "if I can\\'t become a programmer, at least I know how to choose the right house for a robbery.."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "                                             \\n     class Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n           ans = [0] * len(nums)\\n        for i in range(len(nums)):\\n            if i-1 > 0:\\n                ans[i] = nums[i] + max(ans[:i-1])\\n            else:\\n                ans[i] = nums[i]\\n        return max(ans)\\n"
                    },
                    {
                        "username": "timepass3",
                        "content": "Hi,\\n\\nOne of the test cases says:\\n\\nInput:  \\t5 2 7 9 3 1 \\n\\nExpected: 12\\n\\nThat means we can rob the houses in round brackets - 5 (2) 7 (9) 3 (1) = 2 + 9 + 1 = 12\\n\\nWhy not the following -  (5) 2 (7) 9 (3) 1 = 5 + 7 + 3 = 15\\n\\nShouldn't the answer be 15?"
                    },
                    {
                        "username": "ranajay206",
                        "content": "Yes, answer is 15 ."
                    },
                    {
                        "username": "Ataf10",
                        "content": "what if the robber doesn\\'t know DP and robbed all the non adjacent houses and at the end finds 1 million dollar in the last adjacent house, hahaha lol!"
                    },
                    {
                        "username": "mikeycantcode",
                        "content": "you sir have won the internet :-) for the day."
                    },
                    {
                        "username": "rmolinamir",
                        "content": "Biggest hint I could give is: `DP(i) = nums[i] + max{DP(i - 2), DP(i - 3)}`"
                    }
                ]
            },
            {
                "id": 1990293,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 1575574,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 1571418,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 1571876,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 1576035,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 2073860,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 2064659,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 2063285,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 2062784,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 2055359,
                "content": [
                    {
                        "username": "Ultron03",
                        "content": "Reason why engineers found in every profession \\uD83D\\uDE01..\\n"
                    },
                    {
                        "username": "amarkumaramarkumar15102001",
                        "content": "![image](https://assets.leetcode.com/users/images/881dd9fa-8bc9-431e-a1d1-f71628168463_1627221461.3974254.png)\\n"
                    },
                    {
                        "username": "TMS",
                        "content": "I think it is a must to check for overflows in this question since you will be adding integers. I ran the program without this test case handled and it ran perfectly. Needs to be fixed in my opinion."
                    },
                    {
                        "username": "varunkodi",
                        "content": "I don\\'t think there is any need to check for overflow because the constraints say that there can be maximum of 100 elements or houses and the max amount of money in each house is 400. so even in the case where there are 100 houses with 400 money it is well within the range of integer."
                    },
                    {
                        "username": "clancyjjosh",
                        "content": "Consider the array \n\n5, 11, 7, 1, 2, 8\n\n the optimal solution is picking 5, 7, and 8. This requires skipping over 1 AND 2. Am I missing something from other's solutions? I havent seen solutions addressing this problem.\n"
                    },
                    {
                        "username": "charonme",
                        "content": "solutions address this by in each step comparing the payout of skipping 1 vs. 2 houses and continuing with the better outcome. Solutions could for example use a \"max\" function for this"
                    },
                    {
                        "username": "eshavlyugin",
                        "content": "impl Solution {\\n    pub fn rob(nums: Vec<i32>) -> i32 {\\n        *nums.iter().fold([0,0], |prev, x| [prev[0].max(prev[1]), prev[0] + x]).iter().max().unwrap()\\n    }\\n}"
                    },
                    {
                        "username": "Hanagaki_Takimichy",
                        "content": "Spoiler alert:\n        Easy approach:\n                If we are robbing current house then, max we can rob is \n                house[current] + max from all the houses starting from \n                current+2.\n\n       Efficient approach:\n                If we are robbing current house then, max we can rob is \n                Math.max(house[current] + house[current-2], \n                house[current-1]). Two choices are included, one is if we \n                rob current house then we can rob current-2 house or we \n                can rob only house before current and not rob current.\n     "
                    },
                    {
                        "username": "flower2",
                        "content": "Excellent problem, very instructive. A simpler rendition of knapsack."
                    },
                    {
                        "username": "uniqs",
                        "content": "The world is so dangerous, even if you are poor than your adjacent houses, you may be robbed. [100, 10, 1, 10, 100]."
                    },
                    {
                        "username": "anvuong",
                        "content": "The test case [0] is pretty stupid, it does not server any purpose ..."
                    },
                    {
                        "username": "uniqs",
                        "content": "It means the robber is in prison now, no houses to rob"
                    },
                    {
                        "username": "psionl0",
                        "content": "This house robber has some really good intel."
                    }
                ]
            },
            {
                "id": 2055038,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 2054888,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 2040689,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 2039996,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 2030878,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 2020856,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 2017306,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 2015736,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 2008023,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 1987582,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "For recursion + memoization,\\nWhat do you memoize? surely we aren\\'t memoizing a list of ints?\\n```\\n@cache\\ndef recur(nums):\\n  ...\\n  first = nums[0]\\n  rest = nums[1:]\\n  r_rest = nums[2:]\\n  return max(add(first, recur(r_rest)),\\n                      recur(rest))\\nreturn recur(nums)\\n```"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "change the signature to accept an index into the nums array. Reindex the nums array within the subroutine."
                    },
                    {
                        "username": "WoxToxFox",
                        "content": "YAY i did it first try!!"
                    },
                    {
                        "username": "dilip2048",
                        "content": "Why is the statement `memo[i] = max(dp(i-2) + nums[i], dp(i-1))` faster(95% of python submission) than statement `memo[i] = dp(i-1)) + max(dp(i-2) + nums[i]` (45%) in top down approach?\n\n```\ndef rob(self, nums: List[int]) -> int:\n        def dp(i):\n            if i == 0:\n                return nums[0]\n            elif i == 1:\n                return max(nums[0], nums[1])\n            if i not in memo:\n                memo[i] = max(dp(i-2) + nums[i], dp(i-1))\n            return memo[i]\n        memo = {}\n        return dp(len(nums) - 1)\n```"
                    },
                    {
                        "username": "j053carlosanach",
                        "content": "I think the test case [2,1,1,2] must be in description as and Edge case, because to get that answer we need a different variation of the initial algorithm. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "then your initial algorithm is wrong"
                    },
                    {
                        "username": "Gaurav_INFY_SP95",
                        "content": "is there any other solution than dp ?\\nplz provide link or intuition\\n"
                    },
                    {
                        "username": "lordrsling",
                        "content": "Tiny hint: Usually (for example fibbonacci numbers) you are using previous numbers of the same type - they are all fibbonacci numbers. In this task you have two different kinds of numbers - one numbers that you robbed house on position i and then other numbers that you didn\\'t robbed house on position i. Using this information it\\'s fairly easy to figure out, how to calculate the rest."
                    },
                    {
                        "username": "cjbot1998",
                        "content": "Not exactly hard, but it took me a while to distill down the thought process. "
                    },
                    {
                        "username": "bldrnnr0x7ca",
                        "content": "It\\'s good that they specified we want to rob the houses *without alerting the police*. I would never go down without a fight."
                    },
                    {
                        "username": "hrishikakkad",
                        "content": "What about [6,3,8,14]. Still confused on how the solution will work here. I\\'m sure I am going wrong somewhere"
                    },
                    {
                        "username": "ovi_21",
                        "content": "It was labeled as an easy category problem initially xD"
                    }
                ]
            },
            {
                "id": 1968226,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1965917,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1959854,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1959818,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1943030,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1931031,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1919156,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1913813,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1912791,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1887595,
                "content": [
                    {
                        "username": "rohan_6398",
                        "content": "try to think whether we have taken the previous element or not.\\nIf we have then, take maximum of dp[i-2]+current element and dp[i-1]\\nelse we always take current element"
                    },
                    {
                        "username": "RK_9097",
                        "content": "I think the test case [2,1,1,2] must be in description. Otherwise from the current two cases we can assume to check odd/even elements only."
                    },
                    {
                        "username": "layyy",
                        "content": "[20,2,3,50,1,100]\\nbetter test case considering that the given test cases only have odd-even series"
                    },
                    {
                        "username": "eldavimost",
                        "content": "My first question to the interviewer would be: WHY ARE WE HELPING A ROBBER!??\nThen he'll say: That was the right answer, you're hired!\nGG"
                    },
                    {
                        "username": "psionl0",
                        "content": "What if the interviewer is moonlighting as the house robber?"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "The constraint allowing just 1 house is hateful."
                    },
                    {
                        "username": "nitingangwar71",
                        "content": "==24==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==24==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n\\n[@LeetCode](/LeetCode)\\nI\\'m getting some kind of VM error while running and submitting the solution\\n"
                    },
                    {
                        "username": "Husoski",
                        "content": "Funny that this problem is rated \"Medium\", but \"746. Min Cost Climbing Stairs\" is nearly identical but rated \"Easy.\"  I copy-pasted my solution to that and only needed to make two minor changes--other than changing function and argument names.)"
                    },
                    {
                        "username": "Sravyasri788",
                        "content": "space complexity\\n"
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It requires high level of problem solving skill to be thief these days, feeling sed for them \\uD83D\\uDE42"
                    },
                    {
                        "username": "mystiquecoder",
                        "content": "suppose there is an example [2,21,14,18,22], here the best solution will be 21+22 =43 rather then 2+14+22 = 38 or 21+18=39 . But the algorithm will not map this case i suppose. can anyone help me understand this? "
                    }
                ]
            },
            {
                "id": 1870127,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1859163,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1838674,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1827110,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1811514,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1808984,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1808598,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1805070,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1787847,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1771530,
                "content": [
                    {
                        "username": "imtiaz_py",
                        "content": "Test case- [1,5,3,1,9]\\nExpecting answer to be 14. \\nSo we can pick any house as long as it is not adjacent, is that so?"
                    },
                    {
                        "username": "ankush920",
                        "content": "100% Fast T.C. solution using dynamic programming\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nchecking and finding different possibity using dynamic programming\\n\\nApproach\\nbottom up approach\\n\\nComplexity\\nTime complexity:\\nO(n)\\n\\nSpace complexity:\\nO(1)\\n\\nCode\\n// find useful upvote it vro :) \\nclass Solution {\\npublic:\\nint dp[100];\\n    int rob(vector<int>& nums) {\\n        memset( dp ,-1 , size( dp));\\n      if(nums.size()==1)\\n      {\\n           return nums[0];\\n      }\\n    \\n    dp[0]=nums[0];\\n    dp[1]=nums[1];\\n\\n    for( int i= 2 ; i< nums.size( );i++)\\n    {\\n         if( i-3>=0)\\n         {  dp[i]=max(dp[i-2],dp[i-3])+nums[i];\\n         }\\n          else\\n          { \\n              dp[i]= dp[i-2]+nums[i];\\n          }\\n    }\\n         \\n        return max( dp[nums.size()-2], dp[nums.size()-1]) ;\\n        \\n    }\\n}; "
                    },
                    {
                        "username": "JoshBleggi",
                        "content": "Blue Ocean idea: A security system that contacts the police if the house is robbed "
                    },
                    {
                        "username": "manifold1985",
                        "content": "A billion dollar idea."
                    },
                    {
                        "username": "joaojhro",
                        "content": ". . . the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\\n\\n-> Shouldn\\'t house at index 1 (nums[1] = 7)  contact the police since house 0 and 2 were robbed?\\nInput: nums = [2,7,9,3,1]\\nOutput: 12\\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\\nTotal amount you can rob = 2 + 9 + 1 = 12.\\n\\n"
                    },
                    {
                        "username": "manifold1985",
                        "content": "\" it will automatically contact the police if two adjacent houses were broken into on the same night.\" But house 1 and house 3 are not adjacent to each other, so the system will not contact the police."
                    },
                    {
                        "username": "AkbarjonAbdukarimov",
                        "content": "why when nums is [1,2,3,1] result is 4 not 5 its saying max amount?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "You cannot rob two adjacent houses."
                    },
                    {
                        "username": "guobao2",
                        "content": "Can someone explain why greedy approach doesn\\'t always generate the optimal result?\\n```\\ndef coinChangeGreedy(self, coins: List[int], amount: int, sorted=False) -> int:\\n    if amount == 0:\\n        return 0\\n    if not sorted:\\n        coins.sort(reverse=True)\\n    for coin in coins:\\n        nextAmount = amount - coin\\n        if nextAmount < 0:\\n            continue\\n        if nextAmount == 0:\\n            return 1\\n        else:\\n            if amount % coin == 0:\\n                return amount // coin\\n            n = self.coinChange(coins, nextAmount, True)\\n            if n > -1:\\n                return 1 + n\\n    return -1\\n```"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "//Approach 1: 1D DP\\n\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    if (nums.empty())\\n      return 0;\\n    if (nums.size() == 1)\\n      return nums[0];\\n\\n    // dp[i] := max money of robbing nums[0..i]\\n    vector<int> dp(nums.size());\\n    dp[0] = nums[0];\\n    dp[1] = max(nums[0], nums[1]);\\n\\n    for (int i = 2; i < nums.size(); ++i)\\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]);\\n\\n    return dp.back();\\n  }\\n};\\n\\n//Approach 2: O(1) DP Bottom UP \\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& a) {\\n\\n        if(a.size() ==0)return 0;\\n        if(a.size() ==1)return a[0];\\n        if(a.size() ==2)return max(a[0],a[1]);\\n\\n        vector<int>loot(a.size());\\n\\n        loot[0] =a[0];\\n        loot[1] = max(a[0],a[1]);\\n\\n        for(int i=2;i<a.size();i++){\\n            loot[i] = max(loot[i-2]+a[i],loot[i-1]);\\n        }\\n\\n          return loot[a.size()-1];\\n        \\n    }\\n};\\n\\n\\n//second\\n\\nclass Solution {\\n public:\\n  int rob(vector<int>& nums) {\\n    int prev1 = 0;  // dp[i - 1]\\n    int prev2 = 0;  // dp[i - 2]\\n\\n    for (const int num : nums) {\\n      const int dp = max(prev1, prev2 + num);\\n      prev2 = prev1;\\n      prev1 = dp;\\n    }\\n\\n    return prev1;\\n  }\\n};"
                    },
                    {
                        "username": "shahil3303",
                        "content": "nums =\\n[114,117,207,117,235,82,90,67,143,146,53,108,200,91,80,223,58,170,110,236,81,90,222,160,165,195,187,199,114,235,197,187,69,129,64,214,228,78,188,67,205,94,205,169,241,202,144,240]\\ngiven TLE"
                    },
                    {
                        "username": "rishu_raj4789",
                        "content": "just a regular dp problem"
                    },
                    {
                        "username": "archiearya",
                        "content": " `class Solution {\\npublic:\\n    int recursive(int idx, vector<int> &nums, int sum){\\n        sum = 0;\\n\\n        if(idx == 0){\\n            sum = sum + nums[0];\\n            return sum;\\n        }\\n\\n        if(idx<0){ return 0; }\\n\\n        int pick = sum + nums[idx] + recursive(idx-2, nums , sum);\\n\\n        int not_pick = sum + recursive(idx-1, nums, sum);\\n\\n        return max(pick,not_pick);\\n    }\\n    int rob(vector<int>& nums) {\\n        int n = nums.size();\\n        int sum = recursive(n-1, nums , 0);\\n\\n        return sum;\\n        \\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1761746,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1760685,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1756396,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1752299,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1742752,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1740013,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1729489,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1721406,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1717295,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1716624,
                "content": [
                    {
                        "username": "swaroopbhanja996",
                        "content": "Memorization Approach \\n `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n   int maxi(int curr_index,int size,vector<int>&nums,int dp[])\\n   {\\n       if(curr_index>=size)\\n       {\\n           return 0;\\n       }\\n\\n       if(dp[curr_index]!=-1)\\n       {\\n           return dp[curr_index];\\n       }\\n\\n       int maxiSum=nums[curr_index];\\n       for(int i=curr_index;i<size;i++)\\n       {\\n           maxiSum=max(maxi(i+2,size,nums,dp)+nums[i],maxiSum);\\n       }\\n\\n       return dp[curr_index]=maxiSum;\\n\\n   }\\n\\n\\n    int rob(vector<int>& nums) \\n    {\\n        int dp[nums.size()+1];\\n        memset(dp,-1,sizeof(dp));\\n        return maxi(0,nums.size(),nums,dp);\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "crpeck",
                        "content": "What am I missing here? I came up with the following (very slow, but accurate) solution, Python3:\\n\\n```\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        if not nums: return 0\\n        if len(nums) <= 2: return max(nums)\\n        if len(nums) == 3: return max(nums[0] + nums[2], nums[1])\\n        rob1 = nums[0] + self.rob(nums[2:])\\n        rob2 = nums[1] + self.rob(nums[3:])\\n        return max(rob1,rob2)\\n```\\nThis runs fine, but times out. I tried adding a `@cache` decorator for the `rob()` function, and this is where I\\'m confused: just adding that decorator causes \\n\\n```\\nTypeError: unhashable type: \\'list\\'\\n    ret = Solution().rob(param_1)\\nLine 30 in _driver (Solution.py)\\n    _driver()\\nLine 41 in <module> (Solution.py)\\n```\\nAnyone know why this would happen?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Dheeraj_bhandari",
                        "content": "Two Python Solution :[leetcode](https://leetcode.com)\\n\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        dp = [0] * n\\n        dp[0] = nums[0]\\n        for i in range(1, n):\\n            incl = dp[i-2] + nums[i]\\n            excl = dp[i-1] + 0\\n            dp[i] = max(incl, excl)\\n        return dp[n-1]\\n    \\n    #Space optimisation\\n\\n    \"\"\"\\n    prev2 = 0\\n    prev1 = nums[0]\\n\\n    for i in range(1, len(nums)):\\n        incl = prev2 + nums[i]\\n        excl = prev1 + 0\\n\\n        ans = max(incl, excl)\\n    \\n    return prev1\\n    \"\"\""
                    },
                    {
                        "username": "ZilanZaman",
                        "content": "I have tried  solved the problem with adding the even indexes to one variable and odd indexes to another variable and lastly returning the bigger one. Whats the problem in that? its failing on [2,1,1,2] . My ouput: 3\\nAns: 4"
                    },
                    {
                        "username": "patrickallard",
                        "content": "It fails because your algorithm only accounts for situations where the greatest val must be sum of either all the even or the sum of all the odd indexes. Unfortunately, this does not cover all test cases. It misses edges cases where taking the first and last values yields the largest sum."
                    },
                    {
                        "username": "bohkoval",
                        "content": "Yey, finally I am a cool guy and not that nerd"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "prabhudas",
                        "content": "I enjoyed solving this question :)\\nFailed at initial attempts but then was able to come up with solutions\\n\\n- recursive solution\\n- recursive solution with Memorization (top-down)\\n- iterative with memorization (bottom-up)\\n- iterative with O(1) extra space.\\nJust created Page on this : https://prabhudas.notion.site/198-House-Robber-11090996999647fab4f3e177106b4fc2\\nHope this helps.."
                    },
                    {
                        "username": "namanpuri",
                        "content": "Here is a Tip, If you are using memoization technique :\\n\\n `Use Circular List to store the information of previous houses`\\n`It will improve Space Complexity to O(1)` "
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "we can even do that without circular list , here is my explanation https://www.youtube.com/watch?v=g25NpgyboNg"
                    },
                    {
                        "username": "denkochev",
                        "content": "Very interesting problem, I like it a lot \\uD83D\\uDC4D.\\nGuys try to solve it on paper first, you have to figure out how you can storage max sum in each possible way. \\nhint: each possible way means n=index-2; n--  in your storage"
                    }
                ]
            },
            {
                "id": 1716533,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1716245,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1716220,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1716014,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1715955,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1715881,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1715872,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1715756,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1690812,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1678679,
                "content": [
                    {
                        "username": "ak2545307",
                        "content": "int dp[101];\\nint solve(int i, vector<int>& nums){\\n    if(i >= nums.size()){\\n        return 0;\\n    }\\n    if(dp[i]!= -1){\\n        return dp[i];\\n    }\\n    int take = solve(i+2,nums)+nums[i];\\n    int untake = solve(i+1,nums)+ 0;\\n    dp[i] = max(take,untake);\\n    return dp[i];\\n}\\n    int rob(vector<int>& nums) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,nums);\\n    }"
                    },
                    {
                        "username": "vasanthnannuri",
                        "content": "can any one tell me where i went wrong?\\n `your inline code...your inline code...`class Solution {\\n    public int rob(int[] nums) {\\n        int sum1=0,sum2=0,sum3=0;\\n        for(int i=0;i<nums.length;i+=2)\\n         sum1=sum1+nums[i];\\n       for(int j=1;j<nums.length;j+=2)\\n        sum2=sum2+nums[j];\\n       int k=0;\\n        if(nums.length>2)\\n        sum3=nums[0]+nums[nums.length-1];\\n       int max=Math.max(sum1,Math.max(sum2,sum3));\\n        return max; }\\n}\\n\\n       \\n"
                    },
                    {
                        "username": "vinod_aka_veenu",
                        "content": "you can watch the full explanation with O(1) space and single traversal in Time O(n) https://leetcode.com/problems/house-robber/discussion/comments/1729479"
                    },
                    {
                        "username": "Ujjwal_9T9",
                        "content": "Your approach to this question is wrong.\\nYou are simply adding the money in alternating houses and returning the maximum of it.\\nConsider example [15,2,9,10,1,8]\\nFrom ur code sum1=15+9+1=25\\nsum2=2+10+8=20;  sum3=15+8=23\\nreturn 25 as its max;\\nBut the correct answer to this question is 15+10+8 = 33;\\n"
                    },
                    {
                        "username": "avi__09",
                        "content": "easy to solve this question but hard to get the logic."
                    },
                    {
                        "username": "piyush4299",
                        "content": "Try to think of recursive solution first then memoize it by assuming how you could reduce multiple iterations and then write iterative dp approach(this would be really easy if above two steps are taken care of). Kind of generic approach for DP problems but I love this approach."
                    },
                    {
                        "username": "Priyanka-Chatterjee98_doll",
                        "content": "Here is the recursive formula that leads to be right answer:\\nf(0) = nums[0]\\nf(1) = max(num[0], num[1])\\nf(k) = max( f(k-2) + nums[k], f(k-1) )"
                    },
                    {
                        "username": "mukulvagh11",
                        "content": "\\nclass Solution:\\n    def rob(self, nums: List[int]) -> int:\\n        m1=nums[len(nums)-1]\\n        m2=nums[len(nums)-2]\\n        if len(nums)==2:\\n            return max(m1,m2)\\n        for i in range(len(nums)-3,-1,-1):\\n            if i%2==0:\\n                t1=nums[i]+max(nums[i+2:])\\n                nums[i]=t1\\n            else:\\n                t2 = nums[i]+max(nums[i+2:])\\n                nums[i]=t2\\n        return max(nums)"
                    },
                    {
                        "username": "jd_Kdcgc",
                        "content": "Just observe clearly, the robber cannot rob two adjacent houses\\n\\nDoes it mean that for house i, either he will rob i and i - 2\\nOR\\nhe will not rob house i because he robbed house i - 1\\n\\nSo, can we say that house  [i] = max (house [i] + house [i - 2], house [i - 1])?\\n\\nBase case: \\nnums [0] = nums [0] and nums [1] = max (nums [0], nums [1])"
                    },
                    {
                        "username": "kamleshchauhan",
                        "content": "e.g. [2,1,1,2]\\nUse an array to store the max bounty till i & put value of first 2 positions. \\nbounty= [2,2] { since 2 is more than 1 so max bounty till i=0 is also 2}\\nif nums[i]+bounty[i-2]>bounty[i-1] then you have a new number for your bounty \\ni=2 bounty= [2,2,3] (2+1)>2\\ni=3 bounty=[2,2,3,4] (2+2)>3\\nreturn bounty[n-1]"
                    },
                    {
                        "username": "tharun_p",
                        "content": "Can anyone find bug in this code. Works fine in Debugger as well as in local. But in Leetcode fails for this input [2,7,9,3,1]. Thanks\\n\\n`let DP_Memo = []\\n\\nvar rob = function(nums) {\\n    DP_Memo[0] = nums[0]\\n    DP_Memo[1] = Math.max(nums[0], nums[1])\\n    return DP(nums.length-1, nums, DP_Memo )\\n};\\n\\nlet DP = (index, arr) => {\\n    if(DP_Memo[index] != undefined){ return DP_Memo[index] }\\n    DP_Memo[index] = Math.max(DP(index-1, arr, DP_Memo), DP(index-2,arr, DP_Memo)+arr[index])\\n    return DP_Memo[index]\\n}`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "?\\nDP_Memo[0] = nums[0]\\nDP_Memo[1] = Math.max(nums[0], nums[1])"
                    },
                    {
                        "username": "Souvik360",
                        "content": "OPTIMAL SOLUTION (C++)\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n\\nLogic: \\nWe have two options, either to rob a house or leave it.\\n\\nCASE 1 (rob a house):\\nWe can  rob a house if we haven\\'t robbed the previous one. So maximum rob amount till that house will be maximum robbed money till i-2th house + ith house.\\n\\nCASE 2 (not rob a house):\\nIn this case maximum robbed amount will be maximum robbed till i-1th house as we are not robbing the ith one.\\n\\nAnd finally maximum of these two cases will be the final maximum robbed amount for ith house.\\nHere we need only maximum data for i-1th and i-2th house. So we need not keep the data for all the houses, by this we can reduce space complexity from O(N) -> O(1).\\n\\nclass Solution {\\npublic:\\n    int rob(vector<int>& nums) {\\n        vector<int> dp(3);\\n        int n = nums.size();\\n        dp[0] = 0;\\n        dp[1] = nums[0];\\n        if(n==1){\\n            return dp[1];\\n        }\\n        dp[2] = max(nums[0], nums[1]);\\n        for(int i=3;i<=n;i++){\\n            dp[0] = dp[1];\\n            dp[1] = dp[2];\\n            dp[2] = max(dp[1], dp[0]+nums[i-1]);\\n        }\\n        return dp[2];\\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Tree Longest Consecutive Sequence",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1571548,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The 2 examples given in this problem show binary search trees. \\n\\nThis makes it seem as if the problem is to find longest consecutive sequence in a binary search tree.\\nIf this is the case, it should be stated explicitly. If it is not the case, the trees in the example should be replaced with binary tress which are not BST."
                    },
                    {
                        "username": "Defunctionalize",
                        "content": "does anyone know the answer here?  Is the question asking about binary trees or BSTs?"
                    },
                    {
                        "username": "longbin",
                        "content": "The bug case is:\\n[2147483647, -2147483648]\\n\\nApparently, the result should be 1, but the expected answer gives 2. \\nThis is due to Integer.MIN_VALUE = Integer.MAX_VALUE + 1."
                    },
                    {
                        "username": "yueyub",
                        "content": "is  1-2-1-2 consecutive ? Please use mathematical words, such as\\n\\ncontinuously increasing, non-decreasing, etc..."
                    },
                    {
                        "username": "rafiki6",
                        "content": "Question should say \"longest subsequent path in increasing order\". Otherwise it is very confusing."
                    },
                    {
                        "username": "chepukha",
                        "content": "Since the problem only accept increasing sequence, it's better to make the title more specific."
                    },
                    {
                        "username": "learnfromnk",
                        "content": "The first case in the example, 1->3->4->5 is not consecutive, where consecutive means (a)->(a+1)->(a+2)->... where the child's value is parent's value + 1. Can the editor make it clear? It is really misleading by people do not notice the word **consecutive**."
                    }
                ]
            },
            {
                "id": 1571549,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The 2 examples given in this problem show binary search trees. \\n\\nThis makes it seem as if the problem is to find longest consecutive sequence in a binary search tree.\\nIf this is the case, it should be stated explicitly. If it is not the case, the trees in the example should be replaced with binary tress which are not BST."
                    },
                    {
                        "username": "Defunctionalize",
                        "content": "does anyone know the answer here?  Is the question asking about binary trees or BSTs?"
                    },
                    {
                        "username": "longbin",
                        "content": "The bug case is:\\n[2147483647, -2147483648]\\n\\nApparently, the result should be 1, but the expected answer gives 2. \\nThis is due to Integer.MIN_VALUE = Integer.MAX_VALUE + 1."
                    },
                    {
                        "username": "yueyub",
                        "content": "is  1-2-1-2 consecutive ? Please use mathematical words, such as\\n\\ncontinuously increasing, non-decreasing, etc..."
                    },
                    {
                        "username": "rafiki6",
                        "content": "Question should say \"longest subsequent path in increasing order\". Otherwise it is very confusing."
                    },
                    {
                        "username": "chepukha",
                        "content": "Since the problem only accept increasing sequence, it's better to make the title more specific."
                    },
                    {
                        "username": "learnfromnk",
                        "content": "The first case in the example, 1->3->4->5 is not consecutive, where consecutive means (a)->(a+1)->(a+2)->... where the child's value is parent's value + 1. Can the editor make it clear? It is really misleading by people do not notice the word **consecutive**."
                    }
                ]
            },
            {
                "id": 1571551,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The 2 examples given in this problem show binary search trees. \\n\\nThis makes it seem as if the problem is to find longest consecutive sequence in a binary search tree.\\nIf this is the case, it should be stated explicitly. If it is not the case, the trees in the example should be replaced with binary tress which are not BST."
                    },
                    {
                        "username": "Defunctionalize",
                        "content": "does anyone know the answer here?  Is the question asking about binary trees or BSTs?"
                    },
                    {
                        "username": "longbin",
                        "content": "The bug case is:\\n[2147483647, -2147483648]\\n\\nApparently, the result should be 1, but the expected answer gives 2. \\nThis is due to Integer.MIN_VALUE = Integer.MAX_VALUE + 1."
                    },
                    {
                        "username": "yueyub",
                        "content": "is  1-2-1-2 consecutive ? Please use mathematical words, such as\\n\\ncontinuously increasing, non-decreasing, etc..."
                    },
                    {
                        "username": "rafiki6",
                        "content": "Question should say \"longest subsequent path in increasing order\". Otherwise it is very confusing."
                    },
                    {
                        "username": "chepukha",
                        "content": "Since the problem only accept increasing sequence, it's better to make the title more specific."
                    },
                    {
                        "username": "learnfromnk",
                        "content": "The first case in the example, 1->3->4->5 is not consecutive, where consecutive means (a)->(a+1)->(a+2)->... where the child's value is parent's value + 1. Can the editor make it clear? It is really misleading by people do not notice the word **consecutive**."
                    }
                ]
            },
            {
                "id": 1575936,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The 2 examples given in this problem show binary search trees. \\n\\nThis makes it seem as if the problem is to find longest consecutive sequence in a binary search tree.\\nIf this is the case, it should be stated explicitly. If it is not the case, the trees in the example should be replaced with binary tress which are not BST."
                    },
                    {
                        "username": "Defunctionalize",
                        "content": "does anyone know the answer here?  Is the question asking about binary trees or BSTs?"
                    },
                    {
                        "username": "longbin",
                        "content": "The bug case is:\\n[2147483647, -2147483648]\\n\\nApparently, the result should be 1, but the expected answer gives 2. \\nThis is due to Integer.MIN_VALUE = Integer.MAX_VALUE + 1."
                    },
                    {
                        "username": "yueyub",
                        "content": "is  1-2-1-2 consecutive ? Please use mathematical words, such as\\n\\ncontinuously increasing, non-decreasing, etc..."
                    },
                    {
                        "username": "rafiki6",
                        "content": "Question should say \"longest subsequent path in increasing order\". Otherwise it is very confusing."
                    },
                    {
                        "username": "chepukha",
                        "content": "Since the problem only accept increasing sequence, it's better to make the title more specific."
                    },
                    {
                        "username": "learnfromnk",
                        "content": "The first case in the example, 1->3->4->5 is not consecutive, where consecutive means (a)->(a+1)->(a+2)->... where the child's value is parent's value + 1. Can the editor make it clear? It is really misleading by people do not notice the word **consecutive**."
                    }
                ]
            },
            {
                "id": 1571550,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The 2 examples given in this problem show binary search trees. \\n\\nThis makes it seem as if the problem is to find longest consecutive sequence in a binary search tree.\\nIf this is the case, it should be stated explicitly. If it is not the case, the trees in the example should be replaced with binary tress which are not BST."
                    },
                    {
                        "username": "Defunctionalize",
                        "content": "does anyone know the answer here?  Is the question asking about binary trees or BSTs?"
                    },
                    {
                        "username": "longbin",
                        "content": "The bug case is:\\n[2147483647, -2147483648]\\n\\nApparently, the result should be 1, but the expected answer gives 2. \\nThis is due to Integer.MIN_VALUE = Integer.MAX_VALUE + 1."
                    },
                    {
                        "username": "yueyub",
                        "content": "is  1-2-1-2 consecutive ? Please use mathematical words, such as\\n\\ncontinuously increasing, non-decreasing, etc..."
                    },
                    {
                        "username": "rafiki6",
                        "content": "Question should say \"longest subsequent path in increasing order\". Otherwise it is very confusing."
                    },
                    {
                        "username": "chepukha",
                        "content": "Since the problem only accept increasing sequence, it's better to make the title more specific."
                    },
                    {
                        "username": "learnfromnk",
                        "content": "The first case in the example, 1->3->4->5 is not consecutive, where consecutive means (a)->(a+1)->(a+2)->... where the child's value is parent's value + 1. Can the editor make it clear? It is really misleading by people do not notice the word **consecutive**."
                    }
                ]
            },
            {
                "id": 1569059,
                "content": [
                    {
                        "username": "isaackleinman",
                        "content": "The 2 examples given in this problem show binary search trees. \\n\\nThis makes it seem as if the problem is to find longest consecutive sequence in a binary search tree.\\nIf this is the case, it should be stated explicitly. If it is not the case, the trees in the example should be replaced with binary tress which are not BST."
                    },
                    {
                        "username": "Defunctionalize",
                        "content": "does anyone know the answer here?  Is the question asking about binary trees or BSTs?"
                    },
                    {
                        "username": "longbin",
                        "content": "The bug case is:\\n[2147483647, -2147483648]\\n\\nApparently, the result should be 1, but the expected answer gives 2. \\nThis is due to Integer.MIN_VALUE = Integer.MAX_VALUE + 1."
                    },
                    {
                        "username": "yueyub",
                        "content": "is  1-2-1-2 consecutive ? Please use mathematical words, such as\\n\\ncontinuously increasing, non-decreasing, etc..."
                    },
                    {
                        "username": "rafiki6",
                        "content": "Question should say \"longest subsequent path in increasing order\". Otherwise it is very confusing."
                    },
                    {
                        "username": "chepukha",
                        "content": "Since the problem only accept increasing sequence, it's better to make the title more specific."
                    },
                    {
                        "username": "learnfromnk",
                        "content": "The first case in the example, 1->3->4->5 is not consecutive, where consecutive means (a)->(a+1)->(a+2)->... where the child's value is parent's value + 1. Can the editor make it clear? It is really misleading by people do not notice the word **consecutive**."
                    }
                ]
            }
        ]
    },
    {
        "title": "Random Pick Index",
        "question_content": "<p>Given an integer array <code>nums</code> with possible <strong>duplicates</strong>, randomly output the index of a given <code>target</code> number. You can assume that the given target number must exist in the array.</p>\n\n<p>Implement the <code>Solution</code> class:</p>\n\n<ul>\n\t<li><code>Solution(int[] nums)</code> Initializes the object with the array <code>nums</code>.</li>\n\t<li><code>int pick(int target)</code> Picks a random index <code>i</code> from <code>nums</code> where <code>nums[i] == target</code>. If there are multiple valid i&#39;s, then each index should have an equal probability of returning.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input</strong>\n[&quot;Solution&quot;, &quot;pick&quot;, &quot;pick&quot;, &quot;pick&quot;]\n[[[1, 2, 3, 3, 3]], [3], [1], [3]]\n<strong>Output</strong>\n[null, 4, 0, 2]\n\n<strong>Explanation</strong>\nSolution solution = new Solution([1, 2, 3, 3, 3]);\nsolution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\nsolution.pick(1); // It should return 0. Since in the array only nums[0] is equal to 1.\nsolution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 2 * 10<sup>4</sup></code></li>\n\t<li><code>-2<sup>31</sup> &lt;= nums[i] &lt;= 2<sup>31</sup> - 1</code></li>\n\t<li><code>target</code> is an integer from <code>nums</code>.</li>\n\t<li>At most <code>10<sup>4</sup></code> calls will be made to <code>pick</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 88072,
                "title": "simple-reservoir-sampling-solution",
                "content": "```\\npublic class Solution {\\n\\n    int[] nums;\\n    Random rnd;\\n\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        this.rnd = new Random();\\n    }\\n    \\n    public int pick(int target) {\\n        int result = -1;\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != target)\\n                continue;\\n            if (rnd.nextInt(++count) == 0)\\n                result = i;\\n        }\\n        \\n        return result;\\n    }\\n}```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n    int[] nums;\\n    Random rnd;\\n\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        this.rnd = new Random();\\n    }\\n    \\n    public int pick(int target) {\\n        int result = -1;\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] != target)\\n                continue;\\n            if (rnd.nextInt(++count) == 0)\\n                result = i;\\n        }\\n        \\n        return result;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 88071,
                "title": "c-time-o-n-space-o-n-116ms-96-41-with-clear-explanation-by-probability",
                "content": "Actually, we could first consider following question:\\n\\n**You have a file consisting of characters. The characters in the file can be read sequentially, but the length of the file is unknown. How do you pick a character so that every character in the file has equal probability of being chosen?**\\n\\nFor this problem we can take algorithm like this:\\n\\n* Draw the 1st char. If there is a second char, then we will hold 1st char by prob = 1/2, and replace the 1st char to 2nd char with prob = 1/2. After this step we suppose that the char is X now.\\n\\n* After then, if there is 3rd char, then we will hold the X with prob = 2/3 and replace X to 3rd char with prob = 1/3. Why do they hold the same prob to be picked?\\nBecause:\\n    **Obviously, Prob(the 3rd char is picked) = 1/3;**\\n    **Prob(the 2nd char is picked) = 1 * 1/2 * 2/3 = 1/3;**\\n    **Prob(the 1st char is picked) = 1 * 1/2 * 2/3 = 1/3;**\\n\\n* So we can say that when we now has n chars and there is still another char in the file, we can pick the other char with prob= 1/(n+1), also keep original char with prob = n/(n+1), then we can secure each char is picked with same prob = 1/(n+1), because **prob = 1 * 1/2 * 2/3 * \\xb7\\xb7\\xb7\\xb7 * n/(n+1) = 1/(n+1).**\\n\\n Now, go back to this problem. The thought is the same, when we meet some **nums[i] == target**, we can use above conclusion: **we can pick the other char with prob= 1/(n+1), also keep original char with prob = n/(n+1), then we can secure each char is picked with same prob = 1/(n+1).**\\n\\n**Code:**\\n\\n    class Solution {\\n    vector<int> _nums;\\n    public:\\n    Solution(vector<int> nums) {\\n        _nums = nums;\\n    }\\n    \\n    int pick(int target) {\\n        int n = 0, ans = -1;\\n        for(int i = 0 ; i < _nums.size(); i++){\\n            if(_nums[i] != target) continue;\\n            if(n == 0){ans = i; n++;}\\n            else{\\n                n++;\\n                if(rand() % n == 0){ans = i;}// with prob 1/(n+1) to replace the previous index\\n            }\\n        }\\n        return ans;\\n    }\\n    };\\n\\n![0_1475804025522_F32094D6-140C-47AB-AD65-C4460D0C19AA.png](/uploads/files/1475804029350-f32094d6-140c-47ab-ad65-c4460d0c19aa.png)",
                "solutionTags": [],
                "code": "class Solution {\\n    vector<int> _nums;\\n    public:\\n    Solution(vector<int> nums) {\\n        _nums = nums;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 88153,
                "title": "python-reservoir-sampling-solution",
                "content": "class Solution(object):\\n\\n    def __init__(self, nums):\\n        self.nums = nums\\n        \\n    def pick(self, target):\\n        res = None\\n        count = 0\\n        for i, x in enumerate(self.nums):\\n            if x == target:\\n                count += 1\\n                chance = random.randint(1, count)\\n                if chance == count:\\n                    res = i\\n        return res",
                "solutionTags": [],
                "code": "class Solution(object):\\n\\n    def __init__(self, nums):\\n        self.nums = nums\\n        \\n    def pick(self, target):\\n        res = None\\n        count = 0\\n        for i, x in enumerate(self.nums):\\n            if x == target:\\n                count += 1\\n                chance = random.randint(1, count)\\n                if chance == count:\\n                    res = i\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 88084,
                "title": "clean-understandable-o-1-momery-o-n-time-java-solution",
                "content": "```\\npublic class Solution {\\n    int[] nums;\\n    Random rand;\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        this.rand = new Random();\\n    }\\n    public int pick(int target) {\\n        int total = 0;\\n        int res = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                // randomly select an int from 0 to the nums of target. If x equals 0, set the res as the current index. The probability is always 1/nums for the latest appeared number. For example, 1 for 1st num, 1/2 for 2nd num, 1/3 for 3nd num (1/2 * 2/3 for each of the first 2 nums).\\n                int x = rand.nextInt(++total); \\n                res = x == 0 ? i : res;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int[] nums;\\n    Random rand;\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        this.rand = new Random();\\n    }\\n    public int pick(int target) {\\n        int total = 0;\\n        int res = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                // randomly select an int from 0 to the nums of target. If x equals 0, set the res as the current index. The probability is always 1/nums for the latest appeared number. For example, 1 for 1st num, 1/2 for 2nd num, 1/3 for 3nd num (1/2 * 2/3 for each of the first 2 nums).\\n                int x = rand.nextInt(++total); \\n                res = x == 0 ? i : res;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493137,
                "title": "java-o-n-pick-o-1-space-or-o-1-pick-o-n-space-two-approaches-reservoir-sampling-or-hashmap",
                "content": "# Solution 1\\n```\\n/**\\n * Using Reservoir Sampling\\n *\\n * Suppose the indexes of the target element in array are from 1 to N. You have\\n * already picked i-1 elements. Now you are trying to pick ith element. The\\n * probability to pick it is 1/i. Now you do not want to pick any future\\n * numbers.. Thus, the final probability for ith element = 1/i * (1 - 1/(i+1)) *\\n * (1 - 1/(i+2)) * .. * (1 - 1/N) = 1 / N.\\n *\\n * Time Complexity:\\n * 1) Solution() Constructor -> O(1)\\n * 2) pick() -> O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input array.\\n */\\nclass Solution {\\n\\n    int[] nums;\\n    Random random;\\n\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        this.random = new Random();\\n    }\\n\\n    public int pick(int target) {\\n        int idx = -1;\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                count++;\\n                if (random.nextInt(count) == 0) {\\n                    idx = i;\\n                }\\n            }\\n        }\\n\\n        return idx;\\n    }\\n}\\n```\\n\\n# Solution 2\\n```\\n/**\\n * Preprocessing input using HashMap\\n *\\n * Time Complexity:\\n * 1) Solution() Constructor -> O(N)\\n * 2) pick() -> O(1)\\n *\\n * Space Complexity: O(N)\\n *\\n * N = Length of the input array.\\n */\\nclass Solution2 {\\n\\n    Map<Integer, List<Integer>> map;\\n    Random random;\\n\\n    public Solution2(int[] nums) {\\n        random = new Random();\\n        map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (!map.containsKey(nums[i])) {\\n                map.put(nums[i], new ArrayList<>());\\n            }\\n            map.get(nums[i]).add(i);\\n        }\\n    }\\n\\n    public int pick(int target) {\\n        if (!map.containsKey(target)) {\\n            return -1;\\n        }\\n        List<Integer> curList = map.get(target);\\n        return curList.get(random.nextInt(curList.size()));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\n/**\\n * Using Reservoir Sampling\\n *\\n * Suppose the indexes of the target element in array are from 1 to N. You have\\n * already picked i-1 elements. Now you are trying to pick ith element. The\\n * probability to pick it is 1/i. Now you do not want to pick any future\\n * numbers.. Thus, the final probability for ith element = 1/i * (1 - 1/(i+1)) *\\n * (1 - 1/(i+2)) * .. * (1 - 1/N) = 1 / N.\\n *\\n * Time Complexity:\\n * 1) Solution() Constructor -> O(1)\\n * 2) pick() -> O(N)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Length of the input array.\\n */\\nclass Solution {\\n\\n    int[] nums;\\n    Random random;\\n\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        this.random = new Random();\\n    }\\n\\n    public int pick(int target) {\\n        int idx = -1;\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                count++;\\n                if (random.nextInt(count) == 0) {\\n                    idx = i;\\n                }\\n            }\\n        }\\n\\n        return idx;\\n    }\\n}\\n```\n```\\n/**\\n * Preprocessing input using HashMap\\n *\\n * Time Complexity:\\n * 1) Solution() Constructor -> O(N)\\n * 2) pick() -> O(1)\\n *\\n * Space Complexity: O(N)\\n *\\n * N = Length of the input array.\\n */\\nclass Solution2 {\\n\\n    Map<Integer, List<Integer>> map;\\n    Random random;\\n\\n    public Solution2(int[] nums) {\\n        random = new Random();\\n        map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (!map.containsKey(nums[i])) {\\n                map.put(nums[i], new ArrayList<>());\\n            }\\n            map.get(nums[i]).add(i);\\n        }\\n    }\\n\\n    public int pick(int target) {\\n        if (!map.containsKey(target)) {\\n            return -1;\\n        }\\n        List<Integer> curList = map.get(target);\\n        return curList.get(random.nextInt(curList.size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88158,
                "title": "reservoir-sampling-solution",
                "content": "Reservoir sampling is usually used to randomly pick up k elements in an array S with very big size N or in a data stream S with the same probability. The  idea of the algorithm is:\\n\\n(1) Get the first  k elements from S and put them into an array result[]\\n(2) for j >= k && j < N:\\n          generate a random number r [0, j]\\n          if r < k: result[r] = S[j]\\n\\nFor this question, we can take k = 1, and we only care about the number whose value equals target. First, keep an array of size 1 (just a variable V works).Then assign the first index of the target to it. We can loop every element in input, and at the meantime, use a count to record how many target we've seen now (same role as j). Then generate a random number [0, count). If the number == 0, we can replace the V's value with the new index. After visiting every element in S, the V's value is what we want.\\n\\nYou may wonder, why Reservoir Sampling can guarantee the equal possibility. Let's take a look at the original problem and solution. When we see element S[j], the possibility of choosing it into the reservoir is k/j, and the possibility of its being replaced by ONE elements(t, t > j) later is (k/t)/k = 1/t. Therefore, the probability of S[j] not being replaced by ANY OTHER elements later in S is: \\n (1 - 1/(j + 1)) *  (1 - 1/(j + 2)) * ......* (1 - 1/N) = j/N\\nTherefore, the posibiility of S[j] is in the Reservoir is\\nk/j * j/N = k/N\\n\\nThe code for this specific problem is :\\n```\\npublic class Solution {\\n    int[] input;\\n    public Solution(int[] nums) {\\n        input = nums;\\n    }\\n\\n    public int pick(int target) {\\n         int resevoir = -1;\\n         int cnt = 0;\\n         for(int i = 0; i < input.length; i++){\\n             if(input[i] == target){\\n                 cnt++;\\n                 Random rand = new Random();\\n                 int random = rand.nextInt(cnt);\\n                 \\n                 if(random == 0){\\n                     resevoir = i;\\n                 }\\n             }\\n         }\\n         \\n         return resevoir;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int[] input;\\n    public Solution(int[] nums) {\\n        input = nums;\\n    }\\n\\n    public int pick(int target) {\\n         int resevoir = -1;\\n         int cnt = 0;\\n         for(int i = 0; i < input.length; i++){\\n             if(input[i] == target){\\n                 cnt++;\\n                 Random rand = new Random();\\n                 int random = rand.nextInt(cnt);\\n                 \\n                 if(random == 0){\\n                     resevoir = i;\\n                 }\\n             }\\n         }\\n         \\n         return resevoir;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88069,
                "title": "simple-python-solution",
                "content": "```py\\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        self.nums = nums\\n        \\n\\n    def pick(self, target):\\n        return random.choice([k for k, v in enumerate(self.nums) if v == target])\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        self.nums = nums\\n        \\n\\n    def pick(self, target):\\n        return random.choice([k for k, v in enumerate(self.nums) if v == target])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042503,
                "title": "97-87-python3-c-c-c-java-randomized-index-selection-for-target-values-in-an-array",
                "content": "![Screenshot 2023-08-20 065922.png](https://assets.leetcode.com/users/images/2a849569-493f-4d48-bfe2-9b8fc2be5d95_1694668475.0602646.png)\\n\\n\\n```Python3 []\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.indices = defaultdict(list)\\n        for i, num in enumerate(nums):\\n            self.indices[num].append(i)\\n\\n    def pick(self, target: int) -> int:\\n        return random.choice(self.indices[target])\\n\\n```\\n```Python []\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.indices = defaultdict(list)\\n        for i, num in enumerate(nums):\\n            self.indices[num].append(i)\\n\\n    def pick(self, target: int) -> int:\\n        return random.choice(self.indices[target])\\n\\n```\\n```C# []\\npublic class Solution\\n{\\n    private Dictionary<int, List<int>> indices;\\n\\n    public Solution(int[] nums)\\n    {\\n        indices = new Dictionary<int, List<int>>();\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (!indices.ContainsKey(nums[i]))\\n            {\\n                indices[nums[i]] = new List<int>();\\n            }\\n            indices[nums[i]].Add(i);\\n        }\\n    }\\n\\n    public int Pick(int target)\\n    {\\n        Random random = new Random();\\n        List<int> targetIndices = indices.ContainsKey(target) ? indices[target] : new List<int>();\\n        \\n        int randomIndex = random.Next(0, targetIndices.Count);\\n        \\n        return targetIndices[randomIndex];\\n    }\\n}\\n```\\n```C []\\ntypedef struct {\\n    int* nums;\\n    int numsSize;\\n} Solution;\\n\\nSolution* solutionCreate(int* nums, int numsSize) {\\n    Solution* obj = (Solution*)malloc(sizeof(Solution));\\n    obj->nums = (int*)malloc(numsSize * sizeof(int));\\n    obj->numsSize = numsSize;\\n    \\n    for (int i = 0; i < numsSize; i++) {\\n        obj->nums[i] = nums[i];\\n    }\\n    \\n    return obj;\\n}\\n\\nint solutionPick(Solution* obj, int target) {\\n    int count = 0;\\n    int result = -1;\\n    \\n    for (int i = 0; i < obj->numsSize; i++) {\\n        if (obj->nums[i] == target) {\\n            count++;\\n            if (rand() % count == 0) {\\n                result = i;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n}\\n\\nvoid solutionFree(Solution* obj) {\\n    free(obj->nums);\\n    free(obj);\\n}\\n```\\n```C++ []\\nclass Solution {\\nprivate:\\n    std::unordered_map<int, std::vector<int>> indices;\\n\\npublic:\\n    Solution(std::vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i) {\\n            indices[nums[i]].push_back(i);\\n        }\\n    }\\n\\n    int pick(int target) {\\n        std::random_device rd;\\n        std::mt19937 gen(rd());\\n\\n        if (indices.find(target) != indices.end()) {\\n            std::vector<int>& targetIndices = indices[target];\\n            std::uniform_int_distribution<int> dist(0, targetIndices.size() - 1);\\n            int randomIndex = dist(gen);\\n            return targetIndices[randomIndex];\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\\n```Java []\\npublic class Solution {\\n    private Map<Integer, List<Integer>> indices = new HashMap<>();\\n\\n    public Solution(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            if (!indices.containsKey(nums[i])) {\\n                indices.put(nums[i], new ArrayList<>());\\n            }\\n            indices.get(nums[i]).add(i);\\n        }\\n    }\\n\\n    public int pick(int target) {\\n        Random random = new Random();\\n\\n        if (indices.containsKey(target)) {\\n            List<Integer> targetIndices = indices.get(target);\\n            int randomIndex = random.nextInt(targetIndices.size());\\n            return targetIndices.get(randomIndex);\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#"
                ],
                "code": "```Python3 []\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.indices = defaultdict(list)\\n        for i, num in enumerate(nums):\\n            self.indices[num].append(i)\\n\\n    def pick(self, target: int) -> int:\\n        return random.choice(self.indices[target])\\n\\n```\n```Python []\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.indices = defaultdict(list)\\n        for i, num in enumerate(nums):\\n            self.indices[num].append(i)\\n\\n    def pick(self, target: int) -> int:\\n        return random.choice(self.indices[target])\\n\\n```\n```C# []\\npublic class Solution\\n{\\n    private Dictionary<int, List<int>> indices;\\n\\n    public Solution(int[] nums)\\n    {\\n        indices = new Dictionary<int, List<int>>();\\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            if (!indices.ContainsKey(nums[i]))\\n            {\\n                indices[nums[i]] = new List<int>();\\n            }\\n            indices[nums[i]].Add(i);\\n        }\\n    }\\n\\n    public int Pick(int target)\\n    {\\n        Random random = new Random();\\n        List<int> targetIndices = indices.ContainsKey(target) ? indices[target] : new List<int>();\\n        \\n        int randomIndex = random.Next(0, targetIndices.Count);\\n        \\n        return targetIndices[randomIndex];\\n    }\\n}\\n```\n```C []\\ntypedef struct {\\n    int* nums;\\n    int numsSize;\\n} Solution;\\n\\nSolution* solutionCreate(int* nums, int numsSize) {\\n    Solution* obj = (Solution*)malloc(sizeof(Solution));\\n    obj->nums = (int*)malloc(numsSize * sizeof(int));\\n    obj->numsSize = numsSize;\\n    \\n    for (int i = 0; i < numsSize; i++) {\\n        obj->nums[i] = nums[i];\\n    }\\n    \\n    return obj;\\n}\\n\\nint solutionPick(Solution* obj, int target) {\\n    int count = 0;\\n    int result = -1;\\n    \\n    for (int i = 0; i < obj->numsSize; i++) {\\n        if (obj->nums[i] == target) {\\n            count++;\\n            if (rand() % count == 0) {\\n                result = i;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n}\\n\\nvoid solutionFree(Solution* obj) {\\n    free(obj->nums);\\n    free(obj);\\n}\\n```\n```C++ []\\nclass Solution {\\nprivate:\\n    std::unordered_map<int, std::vector<int>> indices;\\n\\npublic:\\n    Solution(std::vector<int>& nums) {\\n        for (int i = 0; i < nums.size(); ++i) {\\n            indices[nums[i]].push_back(i);\\n        }\\n    }\\n\\n    int pick(int target) {\\n        std::random_device rd;\\n        std::mt19937 gen(rd());\\n\\n        if (indices.find(target) != indices.end()) {\\n            std::vector<int>& targetIndices = indices[target];\\n            std::uniform_int_distribution<int> dist(0, targetIndices.size() - 1);\\n            int randomIndex = dist(gen);\\n            return targetIndices[randomIndex];\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\n```Java []\\npublic class Solution {\\n    private Map<Integer, List<Integer>> indices = new HashMap<>();\\n\\n    public Solution(int[] nums) {\\n        for (int i = 0; i < nums.length; i++) {\\n            if (!indices.containsKey(nums[i])) {\\n                indices.put(nums[i], new ArrayList<>());\\n            }\\n            indices.get(nums[i]).add(i);\\n        }\\n    }\\n\\n    public int pick(int target) {\\n        Random random = new Random();\\n\\n        if (indices.containsKey(target)) {\\n            List<Integer> targetIndices = indices.get(target);\\n            int randomIndex = random.nextInt(targetIndices.size());\\n            return targetIndices.get(randomIndex);\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88105,
                "title": "share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting",
                "content": "Pre-process sorting for O(nlg(n))\\nPick in O(lg(n)) using binary search\\nO(n) space to store value/index pairs\\n```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> pp; // <value, index>\\n\\n    static bool comp(const pp& i, const pp& j) { return (i.first < j.first); }\\n\\n    vector<pp> mNums;\\n\\n    Solution(vector<int> nums) {\\n        for(int i = 0; i < nums.size(); i++) {\\n            mNums.push_back(pp({nums[i], i}));\\n        }\\n        sort(mNums.begin(), mNums.end(), comp);\\n    }\\n\\n    int pick(int target) {\\n        pair<vector<pp>::iterator, vector<pp>::iterator> bounds = equal_range(mNums.begin(), mNums.end(), pp({target,0}), comp);\\n        int s = bounds.first - mNums.begin();\\n        int e = bounds.second - mNums.begin();\\n        int r = e - s;\\n        return mNums[s + (rand() % r)].second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int, int> pp; // <value, index>\\n\\n    static bool comp(const pp& i, const pp& j) { return (i.first < j.first); }\\n\\n    vector<pp> mNums;\\n\\n    Solution(vector<int> nums) {\\n        for(int i = 0; i < nums.size(); i++) {\\n            mNums.push_back(pp({nums[i], i}));\\n        }\\n        sort(mNums.begin(), mNums.end(), comp);\\n    }\\n\\n    int pick(int target) {\\n        pair<vector<pp>::iterator, vector<pp>::iterator> bounds = equal_range(mNums.begin(), mNums.end(), pp({target,0}), comp);\\n        int s = bounds.first - mNums.begin();\\n        int e = bounds.second - mNums.begin();\\n        int r = e - s;\\n        return mNums[s + (rand() % r)].second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88077,
                "title": "why-not-this-straight-forward-solution",
                "content": "I didn't see any performance difference with this solution https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution?page=1\\n\\nI think the question is not clear, it only requires  \"randomly output the index of a given target number\", but not make it clear whether the probability should be 1/(number of target) or 1/(number of whole  array numbers)\\n```\\nclass Solution {\\n    Random random;\\n    int[] origin;\\n    \\n    public Solution(int[] nums) {\\n        random = new Random();\\n        origin = nums;\\n    }\\n    \\n    public int pick(int target) {\\n        \\n        while(true){\\n            int idx = random.nextInt(origin.length);\\n            if(origin[idx] == target){\\n                return idx;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Random random;\\n    int[] origin;\\n    \\n    public Solution(int[] nums) {\\n        random = new Random();\\n        origin = nums;\\n    }\\n    \\n    public int pick(int target) {\\n        \\n        while(true){\\n            int idx = random.nextInt(origin.length);\\n            if(origin[idx] == target){\\n                return idx;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 382297,
                "title": "easy-peasy-python-reservoir-sampling",
                "content": "\\tdef __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        cnt = idx = 0\\n        for i, num in enumerate(self.nums):\\n            if num != target:\\n                continue\\n            if cnt == 0:\\n                idx = i\\n                cnt = 1\\n            else:\\n                # this random will already give me numbers\\n                # between 0 and cnt inclusive\\n                # so for 2nd number I am getting random number 0 and 1\\n                # so each having a probability of 1/2\\n                # similarly for three numbers it will be 1/3\\n                rnd = random.randint(0, cnt)\\n                if (rnd == cnt):\\n                    idx = i\\n                cnt += 1\\n        \\n        return idx",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tdef __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        cnt = idx = 0\\n        for i, num in enumerate(self.nums):\\n            if num != target:\\n                continue\\n            if cnt == 0:\\n                idx = i\\n                cnt = 1\\n            else:\\n                # this random will already give me numbers\\n                # between 0 and cnt inclusive\\n                # so for 2nd number I am getting random number 0 and 1\\n                # so each having a probability of 1/2\\n                # similarly for three numbers it will be 1/3\\n                rnd = random.randint(0, cnt)\\n                if (rnd == cnt):\\n                    idx = i\\n                cnt += 1\\n        \\n        return idx",
                "codeTag": "Python3"
            },
            {
                "id": 88103,
                "title": "share-c-o-n-time-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> n;\\n    Solution(vector<int> nums) \\n    {\\n        n = nums;\\n    }\\n    \\n    int pick(int target) \\n    {\\n        int count = 0, res = -1;\\n        for (int i = 0; i < n.size(); ++i)\\n        {\\n            if(n[i] != target) continue;\\n            if(++count == 1) res = i;\\n            else\\n                if(!(rand()%count)) res = i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> n;\\n    Solution(vector<int> nums) \\n    {\\n        n = nums;\\n    }\\n    \\n    int pick(int target) \\n    {\\n        int count = 0, res = -1;\\n        for (int i = 0; i < n.size(); ++i)\\n        {\\n            if(n[i] != target) continue;\\n            if(++count == 1) res = i;\\n            else\\n                if(!(rand()%count)) res = i;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2407068,
                "title": "c-rand-very-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>> m;\\n    Solution(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]].push_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        int x=m[target].size();\\n        x=rand()%x;\\n        return m[target][x];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>> m;\\n    Solution(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]].push_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        int x=m[target].size();\\n        x=rand()%x;\\n        return m[target][x];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834293,
                "title": "python-simplest-4-line-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        self.index_dict = defaultdict(list)\\n        for i in range(len(nums)):\\n            self.index_dict[nums[i]].append(i)\\n\\n    def pick(self, target: int) -> int:\\n        return random.choice(self.index_dict[target])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        self.index_dict = defaultdict(list)\\n        for i in range(len(nums)):\\n            self.index_dict[nums[i]].append(i)\\n\\n    def pick(self, target: int) -> int:\\n        return random.choice(self.index_dict[target])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672209,
                "title": "python-clean-well-explained-faster-than-90",
                "content": "* Based on Algorithm R (Simple Algorithm): https://en.wikipedia.org/wiki/Reservoir_sampling#Simple_algorithm\\n```\\nfrom random import randint\\n\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\t\\t\\n\\t# Time complexity: O(n), where \"n\" is the length of self.nums\\n    def pick(self, target: int) -> int:\\n        # how many samples with value \"target\" we have seen so far\\n        n_samples = 0\\n\\t\\t\\n\\t\\t# result, selected index\\n        reservoir = 0\\n        \\n\\t\\t# iterate over all the values in self.nums\\n        for index, value in enumerate(self.nums):\\n            if value == target:\\n\\t\\t\\t\\t# target value is found, increment the number of samples with value \"target\" found so far\\n                n_samples += 1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# if it is the first sample found, just keep it index\\n                if n_samples == 1:\\n                    reservoir = index\\n                else:\\n\\t\\t\\t\\t\\t# if there are more than 1 sample, randomly select any of them\\n                    nth_sample = randint(1, n_samples)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# if the selected sample matches the first sample selected initially, then replace it\\n                    if nth_sample == 1:\\n                        reservoir = index\\n        return reservoir\\n```\\nE.g.\\nlet\\'s consider a particular example, for simplicity a given array has the same target value appearing 3 times:\\n\\n**0 1 2 (indices)**\\n**3 3 3 (values)**\\n\\n**step 1**: select the first sample \"3\" (index 0), the probability to select this sample is 1/1 and the probability that this selected item will remain in the reservior is 1/3 (other 2 samples could replace it), setting the resulting probablity to 1/1 * 1/3 -> 1/3\\n\\n**step 2**: select out of the first two samples \"3\" (index 0, index 1), the probability to select the second sample is 1/2 and the probability that it will remain in the reservior is 2/3 (other 1 sample could replace it), setting the resulting probablity to 1/2 * 2/3 -> 1/3\\n\\n**step 3**: select out of the first three samples \"3\" (index 0, index 1, index 2), the probability to select the third sample is 1/3 and the probability that it will remain in the reservior is 3/3 or simply 1.0 (none other samples could replace it), setting the resulting probablity to 1/3 * 1 -> 1/3",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom random import randint\\n\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\t\\t\\n\\t# Time complexity: O(n), where \"n\" is the length of self.nums\\n    def pick(self, target: int) -> int:\\n        # how many samples with value \"target\" we have seen so far\\n        n_samples = 0\\n\\t\\t\\n\\t\\t# result, selected index\\n        reservoir = 0\\n        \\n\\t\\t# iterate over all the values in self.nums\\n        for index, value in enumerate(self.nums):\\n            if value == target:\\n\\t\\t\\t\\t# target value is found, increment the number of samples with value \"target\" found so far\\n                n_samples += 1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# if it is the first sample found, just keep it index\\n                if n_samples == 1:\\n                    reservoir = index\\n                else:\\n\\t\\t\\t\\t\\t# if there are more than 1 sample, randomly select any of them\\n                    nth_sample = randint(1, n_samples)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# if the selected sample matches the first sample selected initially, then replace it\\n                    if nth_sample == 1:\\n                        reservoir = index\\n        return reservoir\\n```",
                "codeTag": "Java"
            },
            {
                "id": 649629,
                "title": "swift-linear-and-constant-space-reservoir-sampling-example-explanation",
                "content": "```\\nclass Solution {\\n    var nums: [Int]\\n    init(_ nums: [Int]) {\\n        self.nums = nums\\n    }\\n    \\n    func pick(_ target: Int) -> Int {\\n        var targets = 0\\n        var pick = -1\\n        \\n        for i in 0..<nums.count where target == nums[i]  {\\n            targets += 1\\n            \\n            if Int.random(in: 0..<targets) == 0 { pick = i }\\n        }\\n        \\n        return pick\\n    }\\n}\\n```\\n\\n// Reservoir sample \\n// No matter how many targets are in the nums, we can randomly pick one just by one loop.\\n// Example: {1,2,3,3,3}\\n// index 2 targets = 1 random pick between [0, 1), so it would be always 0 and pick = 2; Probability is 1\\n// index 3 targets = 2 random pick between [0, 2), so the probability that index 2 is stay as answer is 1/2 (0 - change index, 1 - not change)\\n// index 4 targets = 3 random pick between [0, 3), so the probability that index 2 is stay as answer is 2/3 (0 - change index, 1-2 - not change)\\n// To sum up index 2 probability is = 1 * 1/2 * 2/3 = 1/3\\n// \\n// Probability for index 3 will be 1/2 * 2/3 = 1/3 \\n// Probability for index 4 will be 1/3 = 1/3****",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var nums: [Int]\\n    init(_ nums: [Int]) {\\n        self.nums = nums\\n    }\\n    \\n    func pick(_ target: Int) -> Int {\\n        var targets = 0\\n        var pick = -1\\n        \\n        for i in 0..<nums.count where target == nums[i]  {\\n            targets += 1\\n            \\n            if Int.random(in: 0..<targets) == 0 { pick = i }\\n        }\\n        \\n        return pick\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673083,
                "title": "easy-c-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int>arr;\\n    Solution(vector<int>& nums) {\\n        arr=nums;\\n    }\\n    \\n    int pick(int target) {\\n        vector<int>ans;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i] == target)\\n                ans.push_back(i);\\n        }\\n        return ans[rand()%ans.size()];\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int>arr;\\n    Solution(vector<int>& nums) {\\n        arr=nums;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2866858,
                "title": "c-solutions",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    Solution(vector<int>& nums) {\\n        arr = nums;\\n        \\n    }\\n    \\n    int pick(int target) {\\n        int len = arr.size();\\n        int random = 0 + (rand() % len);\\n        while(arr[random] != target)\\n            random = 0 + (rand() % len);\\n        \\n        return random;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    Solution(vector<int>& nums) {\\n        arr = nums;\\n        \\n    }\\n    \\n    int pick(int target) {\\n        int len = arr.size();\\n        int random = 0 + (rand() % len);\\n        while(arr[random] != target)\\n            random = 0 + (rand() % len);\\n        \\n        return random;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1671979,
                "title": "python-3-reservoir-sampling-o-n-time-o-1-space",
                "content": "Reservoir sampling is particularly helpful when the size of the array `nums` is unknown (e.g. when we have a **stream** of numbers).\\nThe [solution](https://leetcode.com/problems/linked-list-random-node/solution/) to LC 382 (Linked List Random Node) gives a more detailed & clear explanation (and the proof) on the mathematics behind reservoir sampling.\\nTime complexity for `init()`: `O(1)`; for `pick()`: `O(n)`\\nSpace complexity: `O(1)` (constant)\\nPlease upvote if you find this solution helpful.\\n```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        # Reservoir Sampling (which can handle the linked list with unknown size), time complexity O(n) (init: O(1), pick: O(n)), space complextiy O(1)\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        # https://docs.python.org/3/library/random.html\\n        count = 0\\n        chosen_index = None\\n        for i in range(len(self.nums)):\\n            if self.nums[i] != target:\\n                continue\\n            count += 1\\n            if count == 1:\\n                chosen_index = i\\n            elif random.random() < 1 / count:\\n                chosen_index = i\\n        return chosen_index\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        # Reservoir Sampling (which can handle the linked list with unknown size), time complexity O(n) (init: O(1), pick: O(n)), space complextiy O(1)\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        # https://docs.python.org/3/library/random.html\\n        count = 0\\n        chosen_index = None\\n        for i in range(len(self.nums)):\\n            if self.nums[i] != target:\\n                continue\\n            count += 1\\n            if count == 1:\\n                chosen_index = i\\n            elif random.random() < 1 / count:\\n                chosen_index = i\\n        return chosen_index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 550253,
                "title": "simple-java-hashmap-solution",
                "content": "```\\nclass Solution {\\n    private Map<Integer, List<Integer>> map;\\n    \\n    public Solution(int[] nums) {\\n        this.map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            if (!map.containsKey(num)) map.put(num, new ArrayList<>());\\n            map.get(num).add(i);\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        List<Integer> indexes = map.get(target);\\n        int i = (int) (Math.random() * indexes.size());\\n        return indexes.get(i);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Map<Integer, List<Integer>> map;\\n    \\n    public Solution(int[] nums) {\\n        this.map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            if (!map.containsKey(num)) map.put(num, new ArrayList<>());\\n            map.get(num).add(i);\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        List<Integer> indexes = map.get(target);\\n        int i = (int) (Math.random() * indexes.size());\\n        return indexes.get(i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 370797,
                "title": "javascript-constant-space-and-single-o-n-time-solution-easy-and-simple-97-faster-and-100-space",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar Solution = function(nums) {\\n    this.nums = nums;\\n    this.len = nums.length;\\n};\\n\\n/** \\n * @param {number} target\\n * @return {number}\\n */\\nSolution.prototype.pick = function(target) {\\n    if (this.len == 1) return 0;\\n    var result = 0;\\n    var count = 0;\\n    for (var i = 0; i < this.len; i++) {\\n        if (this.nums[i] == target) {\\n            if (Math.floor(Math.random() * (++count)) == 0) result = i;\\n        }\\n    }\\n    return result;\\n};\\n\\n/** \\n * Your Solution object will be instantiated and called as such:\\n * var obj = new Solution(nums)\\n * var param_1 = obj.pick(target)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar Solution = function(nums) {\\n    this.nums = nums;\\n    this.len = nums.length;\\n};\\n\\n/** \\n * @param {number} target\\n * @return {number}\\n */\\nSolution.prototype.pick = function(target) {\\n    if (this.len == 1) return 0;\\n    var result = 0;\\n    var count = 0;\\n    for (var i = 0; i < this.len; i++) {\\n        if (this.nums[i] == target) {\\n            if (Math.floor(Math.random() * (++count)) == 0) result = i;\\n        }\\n    }\\n    return result;\\n};\\n\\n/** \\n * Your Solution object will be instantiated and called as such:\\n * var obj = new Solution(nums)\\n * var param_1 = obj.pick(target)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 342035,
                "title": "c-straight-forward-approach",
                "content": "```\\nclass Solution {\\n    vector<int>arr;\\npublic:\\n    Solution(vector<int>& nums) {\\n        arr = nums;\\n        srand(time(NULL));\\n    }\\n    \\n    \\n    //SOLUCHAN STARTS HERE - DUN DUN DUN DUN\\n    int pick(int target) {\\n        vector<int>ans;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i] == target)\\n                ans.push_back(i);\\n        }\\n        \\n        \\n        // cout<<rand()%ans.size()<<endl;\\n        return ans[rand()%ans.size()];\\n    }\\n};\\n\\n\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n \\n ```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    vector<int>arr;\\npublic:\\n    Solution(vector<int>& nums) {\\n        arr = nums;\\n        srand(time(NULL));\\n    }\\n    \\n    \\n    //SOLUCHAN STARTS HERE - DUN DUN DUN DUN\\n    int pick(int target) {\\n        vector<int>ans;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i] == target)\\n                ans.push_back(i);\\n        }\\n        \\n        \\n        // cout<<rand()%ans.size()<<endl;\\n        return ans[rand()%ans.size()];\\n    }\\n};\\n\\n\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n \\n ```",
                "codeTag": "C++"
            },
            {
                "id": 88093,
                "title": "o-log-n-pick-solution-with-binary-search",
                "content": "I'm surprised that O(n) pick time solutions pass the OJ. I thought that the goal of this exercise is to design data structure that allows faster than O(n) pick. Sharing my solution:\\n```\\nclass Solution {\\npublic:\\n    // Solution: \\n    //  * initialization: keep array of (val, index) pairs. Sort the array by val.\\n    //  * pick: find lower and upper bound of target in the array; pick random element from the range\\n    \\n    struct data\\n    {\\n        int val;\\n        int ind;\\n    };\\n    \\n    std::default_random_engine generator;\\n    \\n    vector<data> counters;\\n    Solution(vector<int> nums) {\\n        srand (time(NULL));\\n        counters.resize(nums.size());\\n        for(int i=0; i < nums.size(); ++i)\\n            counters[i] = data{nums[i], i};\\n        sort(counters.begin(), counters.end(), [](const data &l, const data &r){return l.val < r.val;});\\n    }\\n    \\n    int pick(int target) {\\n        int lo = 0;\\n        int hi = counters.size()-1;\\n        while(hi>lo+1)\\n        {\\n            int mid = (hi + lo)/2;\\n            if(counters[mid].val < target)\\n                lo=mid+1;\\n            else\\n                hi=mid;\\n        }\\n        if(counters[lo].val != target)\\n            ++lo;\\n        \\n        int low_bound = lo;\\n        \\n        lo = 0, hi = counters.size()-1;\\n        while(hi>lo+1)\\n        {\\n            int mid = (hi + lo)/2;\\n            if(counters[mid].val > target)\\n                hi=mid-1;\\n            else\\n                lo=mid;\\n        }        \\n        if(counters[hi].val != target)\\n            --hi;\\n        int up_bound = hi;\\n        //std::uniform_int_distribution<int> distribution(low_bound,up_bound);\\n        int range = up_bound - low_bound;\\n        int ind = low_bound + (range != 0 ? rand() % (range+1) : 0 );// distribution(generator);\\n        \\n        return counters[ind].ind;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Solution: \\n    //  * initialization: keep array of (val, index) pairs. Sort the array by val.\\n    //  * pick: find lower and upper bound of target in the array; pick random element from the range\\n    \\n    struct data\\n    {\\n        int val;\\n        int ind;\\n    };\\n    \\n    std::default_random_engine generator;\\n    \\n    vector<data> counters;\\n    Solution(vector<int> nums) {\\n        srand (time(NULL));\\n        counters.resize(nums.size());\\n        for(int i=0; i < nums.size(); ++i)\\n            counters[i] = data{nums[i], i};\\n        sort(counters.begin(), counters.end(), [](const data &l, const data &r){return l.val < r.val;});\\n    }\\n    \\n    int pick(int target) {\\n        int lo = 0;\\n        int hi = counters.size()-1;\\n        while(hi>lo+1)\\n        {\\n            int mid = (hi + lo)/2;\\n            if(counters[mid].val < target)\\n                lo=mid+1;\\n            else\\n                hi=mid;\\n        }\\n        if(counters[lo].val != target)\\n            ++lo;\\n        \\n        int low_bound = lo;\\n        \\n        lo = 0, hi = counters.size()-1;\\n        while(hi>lo+1)\\n        {\\n            int mid = (hi + lo)/2;\\n            if(counters[mid].val > target)\\n                hi=mid-1;\\n            else\\n                lo=mid;\\n        }        \\n        if(counters[hi].val != target)\\n            --hi;\\n        int up_bound = hi;\\n        //std::uniform_int_distribution<int> distribution(low_bound,up_bound);\\n        int range = up_bound - low_bound;\\n        int ind = low_bound + (range != 0 ? rand() % (range+1) : 0 );// distribution(generator);\\n        \\n        return counters[ind].ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88102,
                "title": "simple-java-reservoir-sampling-solution",
                "content": "```\\npublic Solution(int[] nums) {\\n\\tthis.nums=nums;\\n\\tthis.rand = new Random();\\n}\\n\\npublic int pick(int target) {\\n\\tint index = -1;\\n\\tint count = 1;\\n\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\tif(nums[i]==target && rand.nextInt(count++)==0) {\\n\\t\\t\\tindex = i;\\n\\t\\t}\\n\\t}\\n\\treturn index;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic Solution(int[] nums) {\\n\\tthis.nums=nums;\\n\\tthis.rand = new Random();\\n}\\n\\npublic int pick(int target) {\\n\\tint index = -1;\\n\\tint count = 1;\\n\\tfor(int i=0;i<nums.length;i++) {\\n\\t\\tif(nums[i]==target && rand.nextInt(count++)==0) {\\n\\t\\t\\tindex = i;\\n\\t\\t}\\n\\t}\\n\\treturn index;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1283007,
                "title": "python-concise-solution-with-a-dictionary-time-o-1-and-space-o-n",
                "content": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.h = collections.defaultdict(list)\\n        for i, num in enumerate(nums):\\n            self.h[num].append(i)\\n\\n    def pick(self, target: int) -> int:\\n        return self.h[target][random.randint(0, len(self.h[target]) - 1)]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.h = collections.defaultdict(list)\\n        for i, num in enumerate(nums):\\n            self.h[num].append(i)\\n\\n    def pick(self, target: int) -> int:\\n        return self.h[target][random.randint(0, len(self.h[target]) - 1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244823,
                "title": "c-easy-two-different-solutions-commented",
                "content": "First solution\\n```\\nclass Solution {\\npublic:\\n    // unordered_map<int,vector<int>> mp;\\n    \\n    vector<int> arr;\\n    Solution(vector<int>& nums) {\\n       arr=nums;\\n    }\\n    \\n    int pick(int target) {\\n        \\n         //we are traversing the array again and storing the indices and then we pick a random index from it\\n        vector<int> indices;\\n        for(int i=0;i<arr.size();++i)\\n        {\\n            if(arr[i]==target)\\n                indices.push_back(i);\\n        }\\n        return indices[rand()%indices.size()];\\n    }\\n};\\n```\\nResult -\\nRuntime: 52 ms, faster than 97.08% of C++ online submissions for Random Pick Index.\\nMemory Usage: 36.3 MB, less than 71.70% of C++ online submissions for Random Pick Index.\\n\\n\\n\\nSecond solution\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>> mp;\\n    \\n    \\n    Solution(vector<int>& nums) {\\n          //map stores the all indices of element in a vector\\n        for(int i=0;i<nums.size();++i){\\n            mp[nums[i]].push_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        \\n         //randomly pick an index from the indices of target in the map\\n        vector<int> v=mp[target];\\n        return v[rand()%v.size()];\\n         \\n    }\\n};\\n```\\nResult-\\nRuntime: 224 ms, faster than 5.03% of C++ online submissions for Random Pick Index.\\nMemory Usage: 52 MB, less than 28.71% of C++ online submissions for Random Pick Index.\\n\\n\\nThe fisrt solution time complexity is much better than second one.\\n\\n**Please upvote if this helps :)**\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // unordered_map<int,vector<int>> mp;\\n    \\n    vector<int> arr;\\n    Solution(vector<int>& nums) {\\n       arr=nums;\\n    }\\n    \\n    int pick(int target) {\\n        \\n         //we are traversing the array again and storing the indices and then we pick a random index from it\\n        vector<int> indices;\\n        for(int i=0;i<arr.size();++i)\\n        {\\n            if(arr[i]==target)\\n                indices.push_back(i);\\n        }\\n        return indices[rand()%indices.size()];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>> mp;\\n    \\n    \\n    Solution(vector<int>& nums) {\\n          //map stores the all indices of element in a vector\\n        for(int i=0;i<nums.size();++i){\\n            mp[nums[i]].push_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        \\n         //randomly pick an index from the indices of target in the map\\n        vector<int> v=mp[target];\\n        return v[rand()%v.size()];\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597400,
                "title": "python-o-1-and-sampling",
                "content": "**O(1) Pick**\\n```python\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        self.m = {}\\n        for i, n in enumerate(nums):\\n            self.m.setdefault(n, []).append(i)\\n\\n    def pick(self, target: int) -> int:\\n        return random.choice(self.m[target])\\n```\\n\\n**Sampling**\\nWe randomly pick a number until we find our target. O(n) time complexity for the pick but constant memory.\\n\\n```python\\nclass Solution:       \\n    def __init__(self, nums: List[int]):\\n        self.n = nums\\n\\n    def pick(self, target: int) -> int:\\n        idx = random.randrange(0, len(self.n))\\n        while (self.n[idx] != target):\\n            idx = random.randrange(0, len(self.n))\\n        return idx\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        self.m = {}\\n        for i, n in enumerate(nums):\\n            self.m.setdefault(n, []).append(i)\\n\\n    def pick(self, target: int) -> int:\\n        return random.choice(self.m[target])\\n```\n```python\\nclass Solution:       \\n    def __init__(self, nums: List[int]):\\n        self.n = nums\\n\\n    def pick(self, target: int) -> int:\\n        idx = random.randrange(0, len(self.n))\\n        while (self.n[idx] != target):\\n            idx = random.randrange(0, len(self.n))\\n        return idx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523818,
                "title": "java-reservoir-sampling-detailed-explain",
                "content": "for evry dup, keep looping random.nextInt(++cnt), the possibility to stay in result would be 1/cnt;\\nfor example, \\n1, if we have only one at idex 0, value 2, so far, prob is 1/1;\\n2, now, we get idx 3, value 2, reservoir2, prob of idx 0 remains equal to idx 3 not randomized, 1/1 * (1- 1/2) = 1/2;\\n3,similar,  we get idx 7, value 2, reservoir 3, prob of idx 0 remains, 1/1 * (1 -1/2) * (1 - 1/3) = 1/3;\\n...\\nn,  reservoir n, 1 * 1/2 * 2/3 * ... (n-1)/n = 1/n;\\n\\nsimilarly for all other idx, the prob is also 1/n;\\nThat is why it is \"equal opportunity\", sounds like a good political word.\\n\\n\\n```\\nclass Solution {\\n    int[] arr;\\n    Random rnd;\\n    int len;\\n    public Solution(int[] nums) {\\n        arr = nums;\\n        rnd = new Random();\\n        len = arr.length;\\n    }\\n    \\n    public int pick(int t) {\\n        int cnt = 0, res = -1;\\n        for (int i = 0; i < len; i++) {\\n            if (arr[i] == t && rnd.nextInt(++cnt) == 0) {\\n                res = i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nUsing hashMap\\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> map = new HashMap<>();\\n    Random rand = new Random();\\n    public Solution(int[] nums) {\\n        for (int i = 0; i < nums.length; ++i) {\\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>());\\n            map.get(nums[i]).add(i);\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        int res = 0, cnt = 1;\\n        for (int i : map.get(target)) {\\n            if (rand.nextInt(cnt++) == 0)  res = i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] arr;\\n    Random rnd;\\n    int len;\\n    public Solution(int[] nums) {\\n        arr = nums;\\n        rnd = new Random();\\n        len = arr.length;\\n    }\\n    \\n    public int pick(int t) {\\n        int cnt = 0, res = -1;\\n        for (int i = 0; i < len; i++) {\\n            if (arr[i] == t && rnd.nextInt(++cnt) == 0) {\\n                res = i;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> map = new HashMap<>();\\n    Random rand = new Random();\\n    public Solution(int[] nums) {\\n        for (int i = 0; i < nums.length; ++i) {\\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>());\\n            map.get(nums[i]).add(i);\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        int res = 0, cnt = 1;\\n        for (int i : map.get(target)) {\\n            if (rand.nextInt(cnt++) == 0)  res = i;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88081,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Random Pick Index** https://leetcode.com/problems/random-pick-index/\\n\\n* Do we want to optimize run time or memory?If we want to optimize run time then we can use a dictionary to pre-process the nums array. Simply create a map of key (number) and value (list of its indices). Then run reservoir sampling over this input.\\n* But the problem statement says that using too much memory is not allowed. In that case, we can iterate the entire array and keep a variable to track the frequency of the target for input into reservoir sampling.\\n* Notice random() returns uniform random number between [0 to 1]\\n\\n```\\nfrom random import random\\nclass Solution(object):\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type numsSize: int\\n        \"\"\"\\n        self.nums = nums\\n\\n    def pick(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        cnt, index = 0, 0\\n        for idx, x in enumerate(self.nums):\\n            if x == target:\\n                cnt += 1\\n                if random() <= 1.0/(cnt):\\n                    index = idx\\n        return index\\n```",
                "solutionTags": [],
                "code": "```\\nfrom random import random\\nclass Solution(object):\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type numsSize: int\\n        \"\"\"\\n        self.nums = nums\\n\\n    def pick(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        cnt, index = 0, 0\\n        for idx, x in enumerate(self.nums):\\n            if x == target:\\n                cnt += 1\\n                if random() <= 1.0/(cnt):\\n                    index = idx\\n        return index\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1446438,
                "title": "python-98-35-272ms-easy-solution",
                "content": "```python\\nimport random\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        answer = []\\n        for idx, num in enumerate(self.nums):\\n            if target == num:\\n                answer.append(idx)\\n        return random.choice(answer)\\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.pick(target)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nimport random\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        answer = []\\n        for idx, num in enumerate(self.nums):\\n            if target == num:\\n                answer.append(idx)\\n        return random.choice(answer)\\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.pick(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349508,
                "title": "concise-java-solution",
                "content": "```\\nclass Solution {\\n    \\n    private Map<Integer,List<Integer>> map = new HashMap<>();\\n    private Random rand = new Random();\\n\\n    public Solution(int[] nums) {\\n        IntStream.range(0,nums.length)\\n            .forEach(i -> map.computeIfAbsent(nums[i], k -> new ArrayList<Integer>()).add(i));\\n    }\\n    \\n    public int pick(int target) {\\n        var indices = map.get(target);\\n        return indices.get(rand.nextInt(indices.size()));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private Map<Integer,List<Integer>> map = new HashMap<>();\\n    private Random rand = new Random();\\n\\n    public Solution(int[] nums) {\\n        IntStream.range(0,nums.length)\\n            .forEach(i -> map.computeIfAbsent(nums[i], k -> new ArrayList<Integer>()).add(i));\\n    }\\n    \\n    public int pick(int target) {\\n        var indices = map.get(target);\\n        return indices.get(rand.nextInt(indices.size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 713427,
                "title": "java-hashmap-arraylist",
                "content": "```\\nclass Solution {\\n    \\n    Map<Integer, List<Integer>> map;\\n    Random rand;\\n    \\n    public Solution(int[] nums) {\\n        map = new HashMap<>();\\n        rand = new Random();\\n        List<Integer> list;\\n        for(int i=0;i<nums.length;i++){\\n            list = map.getOrDefault(nums[i], new ArrayList<Integer>());\\n            list.add(i);\\n            map.put(nums[i], list);\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        List<Integer> list = map.get(target);\\n        return list.get(rand.nextInt(list.size()));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Map<Integer, List<Integer>> map;\\n    Random rand;\\n    \\n    public Solution(int[] nums) {\\n        map = new HashMap<>();\\n        rand = new Random();\\n        List<Integer> list;\\n        for(int i=0;i<nums.length;i++){\\n            list = map.getOrDefault(nums[i], new ArrayList<Integer>());\\n            list.add(i);\\n            map.put(nums[i], list);\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        List<Integer> list = map.get(target);\\n        return list.get(rand.nextInt(list.size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 211622,
                "title": "python-solution",
                "content": "Reservoir sampling. Time complexity for `__init__`: `O(1)`. Time complexity for `pick`: `O(n)`.\\n\\n```\\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums = nums\\n\\n    def pick(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        res = None\\n        count = 0\\n        for i, n in enumerate(self.nums):\\n            if n == target:\\n                num = random.randint(0, count)\\n                if num == 0:\\n                    res = i\\n                count += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums = nums\\n\\n    def pick(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        res = None\\n        count = 0\\n        for i, n in enumerate(self.nums):\\n            if n == target:\\n                num = random.randint(0, count)\\n                if num == 0:\\n                    res = i\\n                count += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88110,
                "title": "why-memory-limit-exceeded",
                "content": "In test case : Array [1,2,3,3,3] with a long list of [3].\\nI used C++. And I used a map<<int, vector<int>> to do a map from value to it's indexes. As far as I understand, in constructor I built a very small map, with only a few numbers. Then this small structure is queried many times. The huge answer vector is constructed outside my function. And I used none of those memory. So why there is a MLE problem?",
                "solutionTags": [],
                "code": "In test case : Array [1,2,3,3,3] with a long list of [3].\\nI used C++. And I used a map<<int, vector<int>> to do a map from value to it's indexes. As far as I understand, in constructor I built a very small map, with only a few numbers. Then this small structure is queried many times. The huge answer vector is constructed outside my function. And I used none of those memory. So why there is a MLE problem?",
                "codeTag": "Unknown"
            },
            {
                "id": 88126,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\n    vector<int> nums;\\n    \\npublic:\\n    Solution(vector<int> nums) {\\n        this->nums = nums;\\n        srand(time(NULL));\\n    }\\n    \\n    int pick(int target) {\\n        int cnt = 0;\\n        int index = -1;\\n        for(int i = 0; i<nums.size(); i++) {\\n            if (nums[i] == target) {\\n                cnt++;\\n                if (index == -1)\\n                    index = i;\\n                else {\\n                    if(rand()%cnt == 0) \\n                        index = i;\\n                }\\n            }\\n        }\\n        \\n        return index;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int> nums;\\n    \\npublic:\\n    Solution(vector<int> nums) {\\n        this->nums = nums;\\n        srand(time(NULL));\\n    }\\n    \\n    int pick(int target) {\\n        int cnt = 0;\\n        int index = -1;\\n        for(int i = 0; i<nums.size(); i++) {\\n            if (nums[i] == target) {\\n                cnt++;\\n                if (index == -1)\\n                    index = i;\\n                else {\\n                    if(rand()%cnt == 0) \\n                        index = i;\\n                }\\n            }\\n        }\\n        \\n        return index;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282715,
                "title": "c-hashmap-3-liner-easy-implementation",
                "content": "Our map will store all the indexes where a particular element is occuring.\\nand we will return any position randomlly using the rand() function from our vector\\n```\\nclass Solution {\\npublic:\\n    \\n\\t//initialize the map globally\\n    unordered_map<int, vector<int>> mp;\\n    Solution(vector<int>& nums) {\\n        \\n\\t\\t//add the positions of all the elements into the map\\n        for(int i=0;i<nums.size();i++) mp[nums[i]].push_back(i);\\n        \\n    }\\n    \\n    int pick(int target) {\\n                \\n\\t\\t//return the index by using the rand() function \\n        return mp[target][0+rand()%(mp[target].size())];\\n        \\n    }\\n};\\n\\n ```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t//initialize the map globally\\n    unordered_map<int, vector<int>> mp;\\n    Solution(vector<int>& nums) {\\n        \\n\\t\\t//add the positions of all the elements into the map\\n        for(int i=0;i<nums.size();i++) mp[nums[i]].push_back(i);\\n        \\n    }\\n    \\n    int pick(int target) {\\n                \\n\\t\\t//return the index by using the rand() function \\n        return mp[target][0+rand()%(mp[target].size())];\\n        \\n    }\\n};\\n\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1995169,
                "title": "why-does-reservoir-sampling-time-out-now",
                "content": "You can literally copy paste the solutions from the solution section and they TLE. Idiots.\\n\\n```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        ret = None\\n        count = 0\\n        \\n        for i, num in enumerate(self.nums):\\n            if num != target:\\n                continue\\n                \\n            count += 1\\n            r = random.randint(1, count)\\n            \\n            if r == 1:\\n                ret = i\\n            \\n        return ret\\n                \\n            \\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.pick(target)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        ret = None\\n        count = 0\\n        \\n        for i, num in enumerate(self.nums):\\n            if num != target:\\n                continue\\n                \\n            count += 1\\n            r = random.randint(1, count)\\n            \\n            if r == 1:\\n                ret = i\\n            \\n        return ret\\n                \\n            \\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.pick(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460428,
                "title": "c-5-lines-easy-to-understand-unordered-map-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int, vector<int>> m;\\npublic:\\n    Solution(vector<int>& nums) {\\n        for(int i = 0; i < nums.size(); i++)\\n            m[nums[i]].push_back(i);\\n    }\\n    \\n    int pick(int target) {\\n        auto picked = m[target];\\n        int n = picked.size();\\n        return picked[rand()%n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int, vector<int>> m;\\npublic:\\n    Solution(vector<int>& nums) {\\n        for(int i = 0; i < nums.size(); i++)\\n            m[nums[i]].push_back(i);\\n    }\\n    \\n    int pick(int target) {\\n        auto picked = m[target];\\n        int n = picked.size();\\n        return picked[rand()%n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325703,
                "title": "js-map-and-reservoir-sampling-solution",
                "content": "**Solution 1: Using Map**\\nCreating a map of nums containing an array of indexes in which a num is present. Then using Math.Random() function, getting an index from among the array of indices.\\n```\\nclass Solution {\\n    constructor(nums) {\\n        this.nums = nums;\\n        this.map = this.createMap();    // O(n)\\n    }\\n    createMap() {   // O(n)\\n        const map = new Map();\\n        this.nums.forEach((num, idx) => {\\n            const numIdxs = map.has(num) ? map.get(num) : [];\\n            numIdxs.push(idx);\\n            map.set(num, numIdxs);\\n        })\\n        return map;\\n    }\\n    pick(target) {  // O(1)\\n        const targetIdxOptions = this.map.get(target);\\n        const randomIdx = Math.floor(Math.random() * targetIdxOptions.length);\\n        return targetIdxOptions[randomIdx];\\n    }\\n}\\n```\\nTime Complexity = \\n`Initialization = O(n)`\\n`Pick - O(1)`\\nSpace Complexity = O(n)\\n\\n----\\n\\n**Solution 2: Reservoir Sampling**\\nThis approach optimises on Space from O(n) to O(1).\\n\\n```\\nclass Solution {\\n    constructor(nums) {\\n        this.nums = nums;\\n    }\\n    pick(target) {  // O(n)\\n        let count = 0;\\n        let picked = 0;\\n        \\n        this.nums.forEach((num, idx) => {\\n            if(num === target) {\\n                ++count;\\n                const probOfPicked = Math.floor(Math.random() * count);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// probOfPicked value can be an int within the range [0, count)\\n\\t\\t\\t\\t// so probability of it being (count - 1) is 1/count\\n\\t\\t\\t\\t// since we have to chose each index uniformly in a random fashion\\n                if(probOfPicked === (count - 1)) {\\n                    picked = idx;\\n                }\\n            }\\n        })\\n        return picked;\\n    }\\n}\\n```\\nTime Complexity = \\n`Initialization = O(1)`\\n`Pick - O(n)`\\nSpace Complexity = O(1)\\n\\nIn this solution, we do not need to pre-process and create a map. That is, there is no need to have a buffer with indices of the possible target value.\\nIf we consider input as a stream - for an unlimited stream, we cannot have an unlimited space. Then this solution works very well.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    constructor(nums) {\\n        this.nums = nums;\\n        this.map = this.createMap();    // O(n)\\n    }\\n    createMap() {   // O(n)\\n        const map = new Map();\\n        this.nums.forEach((num, idx) => {\\n            const numIdxs = map.has(num) ? map.get(num) : [];\\n            numIdxs.push(idx);\\n            map.set(num, numIdxs);\\n        })\\n        return map;\\n    }\\n    pick(target) {  // O(1)\\n        const targetIdxOptions = this.map.get(target);\\n        const randomIdx = Math.floor(Math.random() * targetIdxOptions.length);\\n        return targetIdxOptions[randomIdx];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    constructor(nums) {\\n        this.nums = nums;\\n    }\\n    pick(target) {  // O(n)\\n        let count = 0;\\n        let picked = 0;\\n        \\n        this.nums.forEach((num, idx) => {\\n            if(num === target) {\\n                ++count;\\n                const probOfPicked = Math.floor(Math.random() * count);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// probOfPicked value can be an int within the range [0, count)\\n\\t\\t\\t\\t// so probability of it being (count - 1) is 1/count\\n\\t\\t\\t\\t// since we have to chose each index uniformly in a random fashion\\n                if(probOfPicked === (count - 1)) {\\n                    picked = idx;\\n                }\\n            }\\n        })\\n        return picked;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003770,
                "title": "python-two-methods-reservoir-sampling-and-using-a-dictonary",
                "content": "Reservoir sampling. \\n```\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        count = 0        \\n        for i, n in enumerate(self.nums):\\n            if n == target:\\n                count += 1\\n                if random.randrange(count) == 0:\\n                    picked = i\\n                    \\n        return picked\\n```        \\n Storing indices in a hashmap\\n```\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        self.indices = defaultdict(list)\\n        for i, n in enumerate(nums):\\n            self.indices[n].append(i)\\n\\n    def pick(self, target: int) -> int:\\n        indices = self.indices[target]\\n        idx = random.randrange(len(indices))\\n        return indices[idx]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        count = 0        \\n        for i, n in enumerate(self.nums):\\n            if n == target:\\n                count += 1\\n                if random.randrange(count) == 0:\\n                    picked = i\\n                    \\n        return picked\\n```\n```\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        self.indices = defaultdict(list)\\n        for i, n in enumerate(nums):\\n            self.indices[n].append(i)\\n\\n    def pick(self, target: int) -> int:\\n        indices = self.indices[target]\\n        idx = random.randrange(len(indices))\\n        return indices[idx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894311,
                "title": "my-swift-solution-using-dictionary",
                "content": "My Swift solution using dictionary\\n```\\nclass Solution {\\n\\n    private var dict = [Int: [Int]]()\\n\\n    init(_ nums: [Int]) {\\n        for i in 0..<nums.count {\\n            dict[nums[i], default: [Int]()].append(i)\\n        }\\n    }\\n    \\n    func pick(_ target: Int) -> Int {\\n        let c = dict[target, default: [Int]()].count\\n        return dict[target, default: [Int]()][Int.random(in: 0..<c)]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\n    private var dict = [Int: [Int]]()\\n\\n    init(_ nums: [Int]) {\\n        for i in 0..<nums.count {\\n            dict[nums[i], default: [Int]()].append(i)\\n        }\\n    }\\n    \\n    func pick(_ target: Int) -> Int {\\n        let c = dict[target, default: [Int]()].count\\n        return dict[target, default: [Int]()][Int.random(in: 0..<c)]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602542,
                "title": "python-optimal-solution-with-o-1-space-o-n-time-using-reservoir-sampling",
                "content": "Reservoir sampling can be used to randomly select one item or k items in a data stream or any large input sequence in one pass and without knowing the input length.\\n\\nThis youtube video explains reservoir sampling very well: https://www.youtube.com/watch?v=Ybra0uGEkpM&t=609s\\n```\\nimport collections\\nimport random\\n\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        count = 0\\n        \\n        s = None\\n        \\n        for i, num in enumerate(self.nums):\\n            if num != target:\\n                continue\\n            \\n            count += 1\\n            if random.uniform(0, 1) <= 1 / count:\\n                s = i\\n                \\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nimport random\\n\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        count = 0\\n        \\n        s = None\\n        \\n        for i, num in enumerate(self.nums):\\n            if num != target:\\n                continue\\n            \\n            count += 1\\n            if random.uniform(0, 1) <= 1 / count:\\n                s = i\\n                \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 254566,
                "title": "python-binary-search-with-explanation-o-lg-n-pick-o-n-space",
                "content": "The fact there\\'s an `__init__` in the template implies that the solution wants us to preprocess and optimise for the `pick()`\\n\\n0. Store the numbers as pairs: (num, original_idx), then sort this list by `num` so we can do binary search\\n1. Do 2 binary searches:\\n1.1. To find the leftmost index in `srt_nums` that contians the `target`.\\nWe do this by checking when target is found, is the target also to the left of us? Then move search space left\\n1.2. To find the rightmost.\\nWhen target is found, if target is also to the right of us, then move search space right\\n2. Pick an index between leftmost and rightmost, get that element from `srt_nums` and return its original index.\\n\\nRT: Preprocess = O(N lg N), Pick = O(lg N)\\nSpc: O(N), we must store the original indices\\n\\n```\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        Pair = namedtuple(\\'Pair\\', [\\'num\\', \\'idx\\'])\\n        # Store the numbers along with their original indices.\\n        self.nums = [Pair(num, i) for i, num in enumerate(nums)]\\n        # Sort by the numbers so we can binary search over them.\\n        self.nums.sort()        \\n\\n    def pick(self, target: int) -> int:\\n        begin_idx = bin_search(self.nums, target, True)\\n        end_idx = bin_search(self.nums, target, False)\\n        between_idx = random.randint(begin_idx, end_idx)\\n        return self.nums[between_idx].idx\\n                 \\ndef bin_search(nums, target, find_begin):\\n    \"\"\"@find_begin: If True, then we\\'re trying to find the lowest index\\n        that contains the target. If False, we\\'re trying to find the highest index.\\n    \"\"\"\\n    L = 0\\n    R = len(nums) - 1\\n    while True:  # Target guaranteed to be in nums so no break condition.\\n        mid = (L + R) // 2\\n        if nums[mid].num < target:\\n            L = mid + 1\\n        elif nums[mid].num > target:\\n            R = mid - 1\\n        else:\\n            if find_begin:\\n                # If we found the target but the target is also to the left of us\\n                # move the search space to the left so that we can find the leftmost\\n                # index containing the target.\\n                if (mid - 1) >= 0 and nums[mid - 1].num == target:\\n                    R = mid - 1\\n                else:\\n                    # If the target is not to the left, we found the leftmost index.\\n                    return mid\\n            else:\\n                # The same but we check if target is to the right, and in this case\\n                # move search space to the right.\\n                if (mid + 1) < len(nums) and nums[mid + 1].num == target:\\n                    L = mid + 1\\n                else:\\n                    return mid\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        Pair = namedtuple(\\'Pair\\', [\\'num\\', \\'idx\\'])\\n        # Store the numbers along with their original indices.\\n        self.nums = [Pair(num, i) for i, num in enumerate(nums)]\\n        # Sort by the numbers so we can binary search over them.\\n        self.nums.sort()        \\n\\n    def pick(self, target: int) -> int:\\n        begin_idx = bin_search(self.nums, target, True)\\n        end_idx = bin_search(self.nums, target, False)\\n        between_idx = random.randint(begin_idx, end_idx)\\n        return self.nums[between_idx].idx\\n                 \\ndef bin_search(nums, target, find_begin):\\n    \"\"\"@find_begin: If True, then we\\'re trying to find the lowest index\\n        that contains the target. If False, we\\'re trying to find the highest index.\\n    \"\"\"\\n    L = 0\\n    R = len(nums) - 1\\n    while True:  # Target guaranteed to be in nums so no break condition.\\n        mid = (L + R) // 2\\n        if nums[mid].num < target:\\n            L = mid + 1\\n        elif nums[mid].num > target:\\n            R = mid - 1\\n        else:\\n            if find_begin:\\n                # If we found the target but the target is also to the left of us\\n                # move the search space to the left so that we can find the leftmost\\n                # index containing the target.\\n                if (mid - 1) >= 0 and nums[mid - 1].num == target:\\n                    R = mid - 1\\n                else:\\n                    # If the target is not to the left, we found the leftmost index.\\n                    return mid\\n            else:\\n                # The same but we check if target is to the right, and in this case\\n                # move search space to the right.\\n                if (mid + 1) < len(nums) and nums[mid + 1].num == target:\\n                    L = mid + 1\\n                else:\\n                    return mid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88143,
                "title": "o-n-constructor-o-1-pick-two-ways",
                "content": "## Update: Second way\\n\\nI found another way. If a number only appears at one index, map the number to that index. Otherwise map it to a list of its indexes. Also got accepted all five times I submitted it.\\n```\\nclass Solution(object):\\n    \\n    def __init__(self, nums):\\n        indexes = self.indexes = {}\\n        for i, num in enumerate(nums):\\n            I = indexes.get(num)\\n            if I is None:\\n                indexes[num] = i\\n            elif isinstance(I, int):\\n                indexes[num] = [I, i]\\n            else:\\n                indexes[num].append(i)\\n\\n    def pick(self, target):\\n        I = self.indexes[target]\\n        return I if isinstance(I, int) else random.choice(I)\\n```\\n\\n## Original:\\nAfter quite a fight, this is my first version of this idea not getting *\"Memory Limit Exceeded\"*. It got accepted all five times I submitted it.\\n```\\nclass Solution(object):\\n    def __init__(self, nums):\\n\\n        count = {}\\n        for num in nums:\\n            count[num] = count.get(num, 0) + 1\\n\\n        start, startstop = 0, count\\n        for num in count:\\n            startstop[num], start = (start << 32) | start, start + count[num]\\n\\n        indexes = [None] * len(nums)\\n        for i, num in enumerate(nums):\\n            indexes[startstop[num] & 0xFFFFFFFF] = i\\n            startstop[num] += 1\\n\\n        self.indexes = indexes\\n        self.startstop = startstop\\n        \\n    def pick(self, target):\\n        ss = self.startstop[target]\\n        return self.indexes[random.randrange(ss >> 32, ss & 0xFFFFFFFF)]\\n```\\nFirst I count each number, then I write each number's indexes consecutively into `indexes`. So that for number `num`, its indexes are stored in `indexes[start:stop]`. And its `start`/`stop` are stored as `startstop[num] = (start << 32) | stop`.\\n\\n---\\n\\nI tried this because the [obvious solution](https://discuss.leetcode.com/post/129742) storing one list of indexes for each number consistently got MLE, with *\"Last executed input\" having `nums = [1,2,3,3,3]`. I believe that that display is wrong, that I actually got MLE for a later case where `nums` has many more different numbers. Each different number having its own list can be expensive, so I came up with the above solution where I only have one list of all indexes, and each different number now has its own `startstop` int instead of its own list. An `int` takes only 24 bytes while even the empty list takes 72 bytes (as you can see with `print sys.getsizeof([])` and `print sys.getsizeof(2**60)`).\\n\\nNote that I reuse the `count` dict as `startstop` instead of creating a new dict. That was the last optimization, the one that finally got me from MLE to Accepted.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    \\n    def __init__(self, nums):\\n        indexes = self.indexes = {}\\n        for i, num in enumerate(nums):\\n            I = indexes.get(num)\\n            if I is None:\\n                indexes[num] = i\\n            elif isinstance(I, int):\\n                indexes[num] = [I, i]\\n            else:\\n                indexes[num].append(i)\\n\\n    def pick(self, target):\\n        I = self.indexes[target]\\n        return I if isinstance(I, int) else random.choice(I)\\n```\n```\\nclass Solution(object):\\n    def __init__(self, nums):\\n\\n        count = {}\\n        for num in nums:\\n            count[num] = count.get(num, 0) + 1\\n\\n        start, startstop = 0, count\\n        for num in count:\\n            startstop[num], start = (start << 32) | start, start + count[num]\\n\\n        indexes = [None] * len(nums)\\n        for i, num in enumerate(nums):\\n            indexes[startstop[num] & 0xFFFFFFFF] = i\\n            startstop[num] += 1\\n\\n        self.indexes = indexes\\n        self.startstop = startstop\\n        \\n    def pick(self, target):\\n        ss = self.startstop[target]\\n        return self.indexes[random.randrange(ss >> 32, ss & 0xFFFFFFFF)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88073,
                "title": "share-my-simple-java-solution",
                "content": "If we have ``int[] nums = [1,2,3,1,1,1,1,1]``, using ``r.nextInt(n)`` will give us a random int between ``[0, n)`` (exclusive), so each number in nums has 1/n probability to be returned. \\n\\nThus, numbers equal to target share the same probability. \\n\\n```\\npublic class Solution {\\n    int[] nums;\\n    Random r;\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        r = new Random();\\n    }\\n    \\n    public int pick(int target) {\\n        int size = nums.length;\\n        int i = r.nextInt(size);\\n        while (nums[i] != target) {\\n            i = r.nextInt(size);\\n        }\\n        \\n        return i;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int[] nums;\\n    Random r;\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        r = new Random();\\n    }\\n    \\n    public int pick(int target) {\\n        int size = nums.length;\\n        int i = r.nextInt(size);\\n        while (nums[i] != target) {\\n            i = r.nextInt(size);\\n        }\\n        \\n        return i;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88162,
                "title": "python-zero-liner",
                "content": "I added one line but also removed one :-)\\n```\\nclass Solution(object):\\n    def __init__(self, nums):\\n        self.pick = lambda target: random.choice([i for i, num in enumerate(nums) if num == target])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def __init__(self, nums):\\n        self.pick = lambda target: random.choice([i for i, num in enumerate(nums) if num == target])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88150,
                "title": "simple-java-solution",
                "content": "\\n\\n\\t    public int pick(int target) {\\n\\t        ArrayList<Integer> list = new ArrayList<Integer>();\\n\\t        for(int i =0;i<input.length;i++)\\n\\t        {\\n\\t            if(input[i] == target)\\n\\t                list.add(i);\\n\\t        }\\n\\t        Random rand = new Random();\\n\\t        int index =rand.nextInt(list.size());\\n\\t        return list.get(index);\\n\\t    }",
                "solutionTags": [],
                "code": "\\n\\n\\t    public int pick(int target) {\\n\\t        ArrayList<Integer> list = new ArrayList<Integer>();\\n\\t        for(int i =0;i<input.length;i++)\\n\\t        {\\n\\t            if(input[i] == target)\\n\\t                list.add(i);\\n\\t        }\\n\\t        Random rand = new Random();\\n\\t        int index =rand.nextInt(list.size());\\n\\t        return list.get(index);\\n\\t    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3501333,
                "title": "c-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    Solution(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        vector<int> temp;\\n        for(int i=0;i<ans.size();i++){\\n            if(ans[i]==target){\\n                temp.push_back(i);\\n            }\\n        }\\n        return temp[rand()%temp.size()];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    Solution(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(nums[i]);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        vector<int> temp;\\n        for(int i=0;i<ans.size();i++){\\n            if(ans[i]==target){\\n                temp.push_back(i);\\n            }\\n        }\\n        return temp[rand()%temp.size()];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3258481,
                "title": "398-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo solve this problem, we can create a dictionary to store the indices of each target number. Then, when we need to pick a random index, we can use the random module to generate a random index from the list of indices associated with the target number.\\n\\n1. Create a dictionary to store the indices of each target number.\\n\\n2. Iterate through the array nums and add the index i to the list of indices associated with nums[i].\\n\\n3. When pick(target) is called, get the list of indices associated with the target number from the dictionary.\\n\\n4. Use the random module to generate a random index from the list of indices.\\n\\n5. Return the random index.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        # Create a dictionary to store the indices of each target number\\n        self.indices = {}\\n        # Iterate through the array nums and add the index i to the list of indices associated with nums[i]\\n        for i, num in enumerate(nums):\\n            if num not in self.indices:\\n                self.indices[num] = [i]\\n            else:\\n                self.indices[num].append(i)\\n\\n    def pick(self, target: int) -> int:\\n        # Get the list of indices associated with the target number from the dictionary\\n        indices = self.indices[target]\\n        # Use the random module to generate a random index from the list of indices\\n        return random.choice(indices)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Math",
                    "Reservoir Sampling"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        # Create a dictionary to store the indices of each target number\\n        self.indices = {}\\n        # Iterate through the array nums and add the index i to the list of indices associated with nums[i]\\n        for i, num in enumerate(nums):\\n            if num not in self.indices:\\n                self.indices[num] = [i]\\n            else:\\n                self.indices[num].append(i)\\n\\n    def pick(self, target: int) -> int:\\n        # Get the list of indices associated with the target number from the dictionary\\n        indices = self.indices[target]\\n        # Use the random module to generate a random index from the list of indices\\n        return random.choice(indices)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766657,
                "title": "python3-solution-2-approaches",
                "content": "**My First Approach but Time Limit was Exceeded :\\nIn this case only 14/15 Testcases were passed**\\n\\n```\\n\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        # Reservoir Sampling (which can handle the linked list with unknown size), time complexity O(n) (init: O(1), pick: O(n)), space complextiy O(1)\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        # https://docs.python.org/3/library/random.html\\n        count = 0\\n        chosen_index = None\\n        for i in range(len(self.nums)):\\n            if self.nums[i] != target:\\n                continue\\n            count += 1\\n            if count == 1:\\n                chosen_index = i\\n            elif random.random() < 1 / count:\\n                chosen_index = i\\n        return chosen_index\\n```\\n\\n**Easy Approach which clears all testcases**\\n\\n```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.d = defaultdict(list)\\n        for idx, num in enumerate(nums):\\n            self.d[num].append(idx)\\n        \\n\\n    def pick(self, target: int) -> int:\\n        return random.choice(self.d[target])\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        # Reservoir Sampling (which can handle the linked list with unknown size), time complexity O(n) (init: O(1), pick: O(n)), space complextiy O(1)\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        # https://docs.python.org/3/library/random.html\\n        count = 0\\n        chosen_index = None\\n        for i in range(len(self.nums)):\\n            if self.nums[i] != target:\\n                continue\\n            count += 1\\n            if count == 1:\\n                chosen_index = i\\n            elif random.random() < 1 / count:\\n                chosen_index = i\\n        return chosen_index\\n```\n```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.d = defaultdict(list)\\n        for idx, num in enumerate(nums):\\n            self.d[num].append(idx)\\n        \\n\\n    def pick(self, target: int) -> int:\\n        return random.choice(self.d[target])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2712997,
                "title": "java-solution-hashmap",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> map;\\n\\n    public Solution(int[] nums) {\\n        map = new HashMap<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            map.putIfAbsent(nums[i], new ArrayList<>());\\n            map.get(nums[i]).add(i);\\n        }\\n    }\\n\\n    public int pick(int target) {\\n        List<Integer> list = map.get(target);\\n        int randomIdx = (int) (Math.random() * list.size());\\n        return list.get(randomIdx);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, List<Integer>> map;\\n\\n    public Solution(int[] nums) {\\n        map = new HashMap<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            map.putIfAbsent(nums[i], new ArrayList<>());\\n            map.get(nums[i]).add(i);\\n        }\\n    }\\n\\n    public int pick(int target) {\\n        List<Integer> list = map.get(target);\\n        int randomIdx = (int) (Math.random() * list.size());\\n        return list.get(randomIdx);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656628,
                "title": "simple-mapping-based-c-solution-rand",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>mp;\\n    Solution(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        int n=mp[target].size();\\n        int x=rand()%n;\\n        return mp[target][x];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>mp;\\n    Solution(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        int n=mp[target].size();\\n        int x=rand()%n;\\n        return mp[target][x];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656596,
                "title": "simple-mapping-based-c-solution-rand",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>mp;\\n\\n    Solution(vector<int>& nums) \\n    {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           mp[nums[i]].push_back(i);\\t\\n        }          \\n    }\\n    int pick(int target) \\n    {\\n        int random_idx=rand()%mp[target].size();\\n        return mp[target][random_idx];       \\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>mp;\\n\\n    Solution(vector<int>& nums) \\n    {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n           mp[nums[i]].push_back(i);\\t\\n        }          \\n    }\\n    int pick(int target) \\n    {\\n        int random_idx=rand()%mp[target].size();\\n        return mp[target][random_idx];       \\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440444,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector <int> v;//vector of int\\n    Solution(vector<int>& nums) {\\n        vector<int> &v1=nums;\\n        for(int i=0;i<v1.size();i++)\\n            v.push_back(v1[i]);\\n    }\\n    int pick(int target) {\\n        start:int t=rand()%v.size();\\n        if (v[t]==target)\\n            return t;\\n        goto start;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n",
                "solutionTags": [
                    "Hash Table",
                    "Math"
                ],
                "code": "class Solution {\\npublic:\\n    vector <int> v;//vector of int\\n    Solution(vector<int>& nums) {\\n        vector<int> &v1=nums;\\n        for(int i=0;i<v1.size();i++)\\n            v.push_back(v1[i]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1450986,
                "title": "python3-python-solution-using-random-choice-w-comments",
                "content": "```\\nfrom collections import defaultdict\\nimport random\\n\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        \\n        # Make a dictionary consisting of nums\\n        # as keys and the index as values\\n        self.data = defaultdict(lambda: [])\\n        for i,num in enumerate(nums):\\n            self.data[num].append(i)\\n            \\n        return\\n\\n    def pick(self, target: int) -> int:\\n        \\n        # use random.choice method to choose random index\\n        # with \"replacement\"\\n        \\n        # NOTE: Using random.sample will choose random index\\n        # without \"replacement\", so random.choice is the\\n        # correct method in this case\\n        \\n        return random.choice(self.data[target])\\n        \\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.pick(target)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nimport random\\n\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        \\n        # Make a dictionary consisting of nums\\n        # as keys and the index as values\\n        self.data = defaultdict(lambda: [])\\n        for i,num in enumerate(nums):\\n            self.data[num].append(i)\\n            \\n        return\\n\\n    def pick(self, target: int) -> int:\\n        \\n        # use random.choice method to choose random index\\n        # with \"replacement\"\\n        \\n        # NOTE: Using random.sample will choose random index\\n        # without \"replacement\", so random.choice is the\\n        # correct method in this case\\n        \\n        return random.choice(self.data[target])\\n        \\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.pick(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426612,
                "title": "python3-solution-two-approaches",
                "content": "```\\nimport random\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.d = {}\\n        for i,j in enumerate(nums):\\n            self.d[j] = self.d.get(j,[]) + [i]\\n    def pick(self, target: int) -> int:\\n        return random.choice(self.d[target])\\n```\\n\\n```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.d = {}\\n        self.c = {}\\n        for i,j in enumerate(nums):\\n            self.d[j] = self.d.get(j,[]) + [i]\\n    def pick(self, target: int) -> int:\\n        self.c[target] = self.c.get(target,0) + 1\\n        return self.d[target][self.c[target]%len(self.d[target])]\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport random\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.d = {}\\n        for i,j in enumerate(nums):\\n            self.d[j] = self.d.get(j,[]) + [i]\\n    def pick(self, target: int) -> int:\\n        return random.choice(self.d[target])\\n```\n```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.d = {}\\n        self.c = {}\\n        for i,j in enumerate(nums):\\n            self.d[j] = self.d.get(j,[]) + [i]\\n    def pick(self, target: int) -> int:\\n        self.c[target] = self.c.get(target,0) + 1\\n        return self.d[target][self.c[target]%len(self.d[target])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1277297,
                "title": "use-reservoir-sampling-template",
                "content": "The [top voted solution](https://leetcode.com/problems/random-pick-index/discuss/88072/Simple-Reservoir-Sampling-solution) is amazing which is based on reservoir sampling. While when you look up this algorithm, it looks different which may confuse you.\\n\\nSo, I want to show you how we can use the standard reservoir sampling template for this question. It may help you to understand the top voted solution. For the algorithm itself, you can checkout the [wiki](https://en.wikipedia.org/wiki/Reservoir_sampling#Simple_algorithm).\\n\\n1. Standard template:\\n```\\npublic int[] sampling(int[] dataStream, int k) {\\n  int[] reservoir = new int[k];\\n  // fill the reservoir\\n  for (int i = 0; i < reservoir.length; i++) {\\n      reservoir[i] = dataStream[i];\\n  }\\n // replace element in reservoir when condition met\\n  for (int i = k; i < dataStream.length; i++) {\\n      int d = rand.nextInt(i + 1);\\n      if (d < k) {\\n        reservoir[d] = dataStream[i];\\n    }\\n  }\\n  return reservoir;\\n}\\n```\\n\\n2. How can we apply the template to this question?\\nIn this question, we only return index for the target value. So, you can image you are only checking the targes - you will fill the reservoir only with target values. \\nThe question asks to return any ONE index of the target with same possibility. That\\'s the reservoir with size 1. \\nSo, below is the solution applied to the template.\\n```\\nclass Solution {\\n    private int[] dataStream;\\n    \\n    public Solution(int[] dataStream) {\\n        this.dataStream = dataStream;\\n    }\\n    \\n    public int pick(int target) {\\n        Random random = new Random();\\n        int[] reservoir = new int[1];\\n        int i = 0;\\n        int countTargets = 0; // since dataStream has non-target values, we use counter to count how many targets been \"processed\".\\n\\t\\t\\n\\t\\t// fill the reservoir\\n        for(;i < dataStream.length; ++i) {\\n            if(dataStream[i] == target) { // only care about target\\n                reservoir[0] = i;\\n                ++countTargets;\\n                break;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// replace element in reservoir when condition met\\n        ++i; // next index the stream data can select from\\n        for(; i < dataStream.length; ++i) {\\n            if(dataStream[i] != target) { // only care about target\\n                continue;\\n            }\\n            ++countTargets;\\n            int replaceIndex = random.nextInt(countTargets);\\n            if(replaceIndex < reservoir.length) {\\n                reservoir[replaceIndex] = i;\\n            }\\n        }\\n        return reservoir[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] sampling(int[] dataStream, int k) {\\n  int[] reservoir = new int[k];\\n  // fill the reservoir\\n  for (int i = 0; i < reservoir.length; i++) {\\n      reservoir[i] = dataStream[i];\\n  }\\n // replace element in reservoir when condition met\\n  for (int i = k; i < dataStream.length; i++) {\\n      int d = rand.nextInt(i + 1);\\n      if (d < k) {\\n        reservoir[d] = dataStream[i];\\n    }\\n  }\\n  return reservoir;\\n}\\n```\n```\\nclass Solution {\\n    private int[] dataStream;\\n    \\n    public Solution(int[] dataStream) {\\n        this.dataStream = dataStream;\\n    }\\n    \\n    public int pick(int target) {\\n        Random random = new Random();\\n        int[] reservoir = new int[1];\\n        int i = 0;\\n        int countTargets = 0; // since dataStream has non-target values, we use counter to count how many targets been \"processed\".\\n\\t\\t\\n\\t\\t// fill the reservoir\\n        for(;i < dataStream.length; ++i) {\\n            if(dataStream[i] == target) { // only care about target\\n                reservoir[0] = i;\\n                ++countTargets;\\n                break;\\n            }\\n        }\\n\\t\\t\\n\\t\\t// replace element in reservoir when condition met\\n        ++i; // next index the stream data can select from\\n        for(; i < dataStream.length; ++i) {\\n            if(dataStream[i] != target) { // only care about target\\n                continue;\\n            }\\n            ++countTargets;\\n            int replaceIndex = random.nextInt(countTargets);\\n            if(replaceIndex < reservoir.length) {\\n                reservoir[replaceIndex] = i;\\n            }\\n        }\\n        return reservoir[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796021,
                "title": "swift-dictionary-o-1-pick-method",
                "content": "```\\nclass Solution {\\n    var dict: [Int: [Int]] = [:]\\n\\n    init(_ nums: [Int]) {\\n        setupDictionary(nums)\\n    }\\n    \\n    func pick(_ target: Int) -> Int {\\n        return dict[target]!.randomElement()!\\n    }\\n    \\n    private func setupDictionary(_ nums: [Int]) {\\n        for (i,n) in nums.enumerated(){\\n            dict[n, default: []].append(i)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var dict: [Int: [Int]] = [:]\\n\\n    init(_ nums: [Int]) {\\n        setupDictionary(nums)\\n    }\\n    \\n    func pick(_ target: Int) -> Int {\\n        return dict[target]!.randomElement()!\\n    }\\n    \\n    private func setupDictionary(_ nums: [Int]) {\\n        for (i,n) in nums.enumerated(){\\n            dict[n, default: []].append(i)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 680856,
                "title": "c-map-based-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,vector<int>> m;\\n    Solution(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++)\\n            m[nums[i]].push_back(i);\\n    }\\n    \\n    int pick(int target) {\\n        return m[target][rand()%(m[target].size())];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,vector<int>> m;\\n    Solution(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++)\\n            m[nums[i]].push_back(i);\\n    }\\n    \\n    int pick(int target) {\\n        return m[target][rand()%(m[target].size())];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 671525,
                "title": "java-simple-solution-explained",
                "content": "Because the element frequencies are already taken care of, we can keep generating a random index until we have an index that has our target value. Because of random index picking, we can be sure that at some point, expected complexity theta(n), we will get our target.\\n```\\nclass Solution {\\n    int[] nums;\\n    Random rand;\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int pick(int target) {\\n        rand = new Random();\\n        while(true){\\n            int r = rand.nextInt(nums.length);\\n            if(nums[r] == target) return r;\\n        }\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int param_1 = obj.pick(target);\\n */\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] nums;\\n    Random rand;\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int pick(int target) {\\n        rand = new Random();\\n        while(true){\\n            int r = rand.nextInt(nums.length);\\n            if(nums[r] == target) return r;\\n        }\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int param_1 = obj.pick(target);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 652410,
                "title": "java-reservoir-sampling-beats-95-time-100-memory",
                "content": "```\\nclass Solution {\\n    \\n    private int[] nums;\\n\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int pick(int target) {\\n        double count = 0;\\n        int result = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                count++;\\n\\t\\t\\t\\t// Replace currently selected index with a probability 1/(count of target seen so far in nums)\\n                if (Math.random() < 1/count) {\\n                    result = i;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private int[] nums;\\n\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int pick(int target) {\\n        double count = 0;\\n        int result = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                count++;\\n\\t\\t\\t\\t// Replace currently selected index with a probability 1/(count of target seen so far in nums)\\n                if (Math.random() < 1/count) {\\n                    result = i;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 614684,
                "title": "simple-c",
                "content": "```\\nclass Solution {\\npublic:\\n    Solution(vector<int>& nums) {\\n        srand (time(NULL));\\n        for(int i = 0; i < nums.size(); ++i) {\\n            mymap[nums[i]].emplace_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        vector<int> &v = mymap[target];\\n        return v[rand() % v.size()];\\n    }\\nprivate:\\n    unordered_map<int, vector<int>> mymap;\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution(vector<int>& nums) {\\n        srand (time(NULL));\\n        for(int i = 0; i < nums.size(); ++i) {\\n            mymap[nums[i]].emplace_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        vector<int> &v = mymap[target];\\n        return v[rand() % v.size()];\\n    }\\nprivate:\\n    unordered_map<int, vector<int>> mymap;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 557607,
                "title": "python-3-reservoir-sampling",
                "content": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        count = 0\\n        res = -1\\n        for i, v in enumerate(self.nums):\\n            if v == target:\\n                count+=1\\n                if random.randint(1,count) == 1:\\n                    res = i\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        count = 0\\n        res = -1\\n        for i, v in enumerate(self.nums):\\n            if v == target:\\n                count+=1\\n                if random.randint(1,count) == 1:\\n                    res = i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538762,
                "title": "python-space-o-1-reservoir-sample-with-explanation",
                "content": "This challenge of this problem is to solve the pick() in O(1) space.\\nSo Reservoir sample\\nWhen iterate the nums list, count the occurrence of the target nums and random between 1 and occurrence.\\nGive nums = [1,2,3,3,3] and pick(3) \\nWhen idx = 2, we got the first 3, so cnt = 1 and random is between 1 and 1, 100% chances to get 1. So res is set to idx 2 for 100%\\nWhen idx = 3, we got the second 3, so cnt = 2 and random is between 1 and 2, 50% chances to get 1.\\nIf 1 is picked, which is 50%, res is set to idx 3. There is 50% chances that 1 is not pick, which means res remains idx 2.\\nSo 50% for idx 2 and 50% for idx 3 after the second 3.\\nWhen idx = 4, we got the third 3, so cnt = 3 and random is between 1 and 3, 1/3 chances to get 1.\\nSo 1/3 chances to set res to idx 4. And 2/3 chances to have res remain the old value after the second 3. \\nThat old value is 50% for idx 2 and 50% for idx 3. So 2/3*50% = 1/3 for both idx 2 and idx 3.\\n\\nFor Pick() the complexity is: Time O(n) Space O(1)\\n```\\nimport random\\n\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums        \\n\\n    def pick(self, target: int) -> int:\\n        cnt, res = 0, 0\\n        for idx, n in enumerate(self.nums):\\n            if n == target:\\n                cnt += 1\\n                pick = random.randint(1, cnt) # random from 1, ..., cnt inclusive\\n                if pick == 1:\\n                    res = idx\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nimport random\\n\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums        \\n\\n    def pick(self, target: int) -> int:\\n        cnt, res = 0, 0\\n        for idx, n in enumerate(self.nums):\\n            if n == target:\\n                cnt += 1\\n                pick = random.randint(1, cnt) # random from 1, ..., cnt inclusive\\n                if pick == 1:\\n                    res = idx\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471440,
                "title": "pool-sampling-algorithm-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    Solution(vector<int>& nums) {\\n        srand(time(0));\\n        v = nums;\\n    }\\n    \\n    int pick(int target) {\\n        int index = -1;\\n        int cnt = 2;\\n        for(int i = 0; i < v.size(); i++) {\\n            if(v[i] == target && index == -1) index = i;\\n            else if(v[i] == target) {\\n                if(rand()*1.0/RAND_MAX < 1.0/cnt) {\\n                    index = i;\\n                } \\n                cnt++;\\n            }\\n        }\\n        return index;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    Solution(vector<int>& nums) {\\n        srand(time(0));\\n        v = nums;\\n    }\\n    \\n    int pick(int target) {\\n        int index = -1;\\n        int cnt = 2;\\n        for(int i = 0; i < v.size(); i++) {\\n            if(v[i] == target && index == -1) index = i;\\n            else if(v[i] == target) {\\n                if(rand()*1.0/RAND_MAX < 1.0/cnt) {\\n                    index = i;\\n                } \\n                cnt++;\\n            }\\n        }\\n        return index;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442122,
                "title": "funny-even-this-pass",
                "content": "class Solution {\\n    int[] array;\\n    public Solution(int[] nums) {\\n        array = nums;\\n    }\\n    \\n    public int pick(int target) {\\n        while(true) {\\n            int r = (int) (Math.random() * (array.length));\\n            if (array[r] == target) {\\n                return r;\\n            }            \\n        }    \\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int[] array;\\n    public Solution(int[] nums) {\\n        array = nums;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 430813,
                "title": "genius-java-solution-beat-96-21",
                "content": "The idea is to keep generating random number until we get the index we want.\\nAverage time complexity is O(n)\\n```\\nclass Solution {\\n    public int[] arr;\\n    public Solution(int[] nums) {\\n        arr = nums;\\n    }\\n    \\n    public int pick(int target) {\\n        Random random = new Random();\\n        int rand = random.nextInt(arr.length);\\n        if(arr[rand]!=target){\\n            return pick(target);\\n        }\\n        return rand;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] arr;\\n    public Solution(int[] nums) {\\n        arr = nums;\\n    }\\n    \\n    public int pick(int target) {\\n        Random random = new Random();\\n        int rand = random.nextInt(arr.length);\\n        if(arr[rand]!=target){\\n            return pick(target);\\n        }\\n        return rand;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393402,
                "title": "share-python-0-1-space-o-n-time-clear-code",
                "content": "\\tdef __init__(self, nums):\\n        self.nums = nums\\n\\n    def pick(self, target):\\n        import random\\n        a = self.nums.count(target) #a is num of target\\n        b = random.randint(1,a) #randomly choose\\n        for j,i in enumerate(self.nums):\\n            if i==target: b-=1\\n            if b==0:return j",
                "solutionTags": [],
                "code": "\\tdef __init__(self, nums):\\n        self.nums = nums\\n\\n    def pick(self, target):\\n        import random\\n        a = self.nums.count(target) #a is num of target\\n        b = random.randint(1,a) #randomly choose\\n        for j,i in enumerate(self.nums):\\n            if i==target: b-=1\\n            if b==0:return j",
                "codeTag": "Python3"
            },
            {
                "id": 272504,
                "title": "reservoir-sampling",
                "content": "Reservoir sampling randomly chooses a sample of  k items from a list S, where size of S is either a very large or unknown number.\\n\\nHere k = 1, S is list of numbers equal to target.\\nWe don\\'t need to save S separately. We use `index` to mark all numbers equal to target.\\n****\\n```\\n    private Random random;\\n    private int[] nums;\\n\\n    public Solution(int[] nums) {\\n        random = new Random();\\n        this.nums = nums;\\n    }\\n    \\n    public int pick(int target) {\\n        // Declare candidate as -1\\n        int candidate = -1;\\n        \\n        // Initialize index as 0\\n        int index = 0;\\n        \\n        // Iterate nums\\n        for (int i = 0; i < nums.length; i++) {\\n            // If num[i] equal to target\\n            if (nums[i] == target) {\\n                // Get random from 0 to index inclusive\\n                int randomValue = random.nextInt(index + 1);\\n                // If random equal to 0, i as candidate\\n                if (randomValue == 0) {\\n                    candidate = i;\\n                }\\n                // Increase index\\n                index++;\\n            }\\n        }\\n        \\n        return candidate;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private Random random;\\n    private int[] nums;\\n\\n    public Solution(int[] nums) {\\n        random = new Random();\\n        this.nums = nums;\\n    }\\n    \\n    public int pick(int target) {\\n        // Declare candidate as -1\\n        int candidate = -1;\\n        \\n        // Initialize index as 0\\n        int index = 0;\\n        \\n        // Iterate nums\\n        for (int i = 0; i < nums.length; i++) {\\n            // If num[i] equal to target\\n            if (nums[i] == target) {\\n                // Get random from 0 to index inclusive\\n                int randomValue = random.nextInt(index + 1);\\n                // If random equal to 0, i as candidate\\n                if (randomValue == 0) {\\n                    candidate = i;\\n                }\\n                // Increase index\\n                index++;\\n            }\\n        }\\n        \\n        return candidate;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 179584,
                "title": "simple-java-beats-99-8-using-reservoir-sampling-with-explanation",
                "content": "Because we cannot store all the index for each distinct element, so we need O(n) time for each call. Say we have 4 of \\'1\\' in the array, when we first time meet \\'1\\', we take this index with probability of 1, then 1/2 for the second time, 1/3 for the third time, 1/4 for the 4th time. This is the basic idea.\\n\\nSo overall we use O(n) time and O(1) space.\\n\\n---\\n\\n```java\\nclass Solution {\\n    private int[] nums;\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int pick(int target) {\\n        int currIdx = -1;\\n        int count = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] == target) {\\n                count++;\\n                if (Math.random() * count < 1) {\\n                    currIdx = i;\\n                }\\n            }\\n        }\\n        return currIdx;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    private int[] nums;\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int pick(int target) {\\n        int currIdx = -1;\\n        int count = 0;\\n        for (int i = 0; i < nums.length; ++i) {\\n            if (nums[i] == target) {\\n                count++;\\n                if (Math.random() * count < 1) {\\n                    currIdx = i;\\n                }\\n            }\\n        }\\n        return currIdx;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 141863,
                "title": "java-simple-intuitive-and-easy-to-understand-solution-o-1-memory-and-o-n-time",
                "content": "```\\nclass Solution {\\n    int[] nums;\\n    Random random;    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        this.random = new Random();\\n    }    \\n    public int pick(int target) {\\n        int result = -1;\\n        int occurrenceCount = 0;\\n        for (int i = 0; i < this.nums.length; i++)\\n        {\\n            if (this.nums[i] == target)\\n                occurrenceCount++;\\n        }\\n        int randomOccurrenceToPick = this.random.nextInt(occurrenceCount);\\n        for (int i = 0; i < this.nums.length; i++)\\n        {\\n            if (this.nums[i] == target)\\n            {\\n                randomOccurrenceToPick--;\\n                if (randomOccurrenceToPick == -1)\\n                {\\n                    result = i;\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[] nums;\\n    Random random;    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        this.random = new Random();\\n    }    \\n    public int pick(int target) {\\n        int result = -1;\\n        int occurrenceCount = 0;\\n        for (int i = 0; i < this.nums.length; i++)\\n        {\\n            if (this.nums[i] == target)\\n                occurrenceCount++;\\n        }\\n        int randomOccurrenceToPick = this.random.nextInt(occurrenceCount);\\n        for (int i = 0; i < this.nums.length; i++)\\n        {\\n            if (this.nums[i] == target)\\n            {\\n                randomOccurrenceToPick--;\\n                if (randomOccurrenceToPick == -1)\\n                {\\n                    result = i;\\n                    break;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 88079,
                "title": "my-easy-and-simple-solution-beating-99-53",
                "content": "```\\npublic class Solution {\\n    int[] nums;\\n    Random myrand;\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        myrand = new Random();\\n    }\\n    public int pick(int target) {\\n        int count = 0;\\n        int ret = -1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                count++;\\n                ret = myrand.nextInt(count)==0?i:ret;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int[] nums;\\n    Random myrand;\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        myrand = new Random();\\n    }\\n    public int pick(int target) {\\n        int count = 0;\\n        int ret = -1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                count++;\\n                ret = myrand.nextInt(count)==0?i:ret;\\n            }\\n        }\\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88142,
                "title": "c-o-n-8-lines-uisng-reservoir-sampling",
                "content": "```\\nclass Solution {\\nprivate:\\n    vector<int> nums;\\n    \\npublic:\\n    Solution(vector<int> nums) {\\n        this->nums = nums;\\n        srand(time(0));\\n    }\\n    \\n    int pick(int target) {\\n        int ans;\\n        \\n        for (int i = 0, cnt = 1; i < nums.size(); i++) {\\n            if (nums[i] == target && ((rand() % cnt++) == 0)) { ans = i; }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> nums;\\n    \\npublic:\\n    Solution(vector<int> nums) {\\n        this->nums = nums;\\n        srand(time(0));\\n    }\\n    \\n    int pick(int target) {\\n        int ans;\\n        \\n        for (int i = 0, cnt = 1; i < nums.size(); i++) {\\n            if (nums[i] == target && ((rand() % cnt++) == 0)) { ans = i; }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 88145,
                "title": "java-solution-using-reservoir-sampling",
                "content": "```\\npublic class Solution {\\n    private int[] nums;\\n    private Random random;\\n\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        random = new Random();\\n    }\\n\\n    public int pick(int target) {\\n        int result = -1;\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target && random.nextInt(++count) == 0) {\\n                result = i;\\n            }\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private int[] nums;\\n    private Random random;\\n\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        random = new Random();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 88156,
                "title": "simple-java-solution-with-o-n-time-and-o-1-space",
                "content": "Each time when we find a num that is equal to target, generate a random number,  return the index with the largest random number.\\n\\npublic class Solution {\\n    int[] nums;\\n\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int pick(int target) {\\n        int index = -1;\\n        double maxResult = 0;\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target) {\\n                double cur = Math.random();\\n                if (cur >= maxResult) {\\n                    maxResult = cur;\\n                    index = i;\\n                }\\n            }\\n        }\\n        \\n        return index;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int[] nums;\\n\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 88161,
                "title": "o-1-memory-with-reservoir-sampling-java",
                "content": "Since the question says it focusing on memory, we discard the solution according to ```Map```. And since it has not been sorted, binary search does not work here.\\n```\\npublic int pick(int target) {\\n        int count = 0, index = -1;\\n        for(int i = 0; i<n.length; i++){\\n            if(n[i] == target&&Math.random()*(++count)<1.0) index = i;\\n        }\\n        return index;\\n    }\\n```",
                "solutionTags": [],
                "code": "```Map```\n```\\npublic int pick(int target) {\\n        int count = 0, index = -1;\\n        for(int i = 0; i<n.length; i++){\\n            if(n[i] == target&&Math.random()*(++count)<1.0) index = i;\\n        }\\n        return index;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831151,
                "title": "beat-100-o-1-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTake the advantage of hashmap and randint O(1) attribute\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse hashmap with list to store candidate numbers, and random pick target from the target list.\\n\\n# Complexity\\n- Time complexity:\\n- O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.hashmap = defaultdict(list)\\n        for i, v in enumerate(nums):\\n            self.hashmap[v].append(i)\\n\\n    def pick(self, target: int) -> int:\\n        indexes = self.hashmap[target]\\n        length = len(indexes)\\n        index = randint(0, length-1)\\n        return indexes[index]\\n        \\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.pick(target)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.hashmap = defaultdict(list)\\n        for i, v in enumerate(nums):\\n            self.hashmap[v].append(i)\\n\\n    def pick(self, target: int) -> int:\\n        indexes = self.hashmap[target]\\n        length = len(indexes)\\n        index = randint(0, length-1)\\n        return indexes[index]\\n        \\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.pick(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515636,
                "title": "java-solution-with-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    Map<Integer, List<Integer>> map;\\n    Random rand;\\n    \\n    public Solution(int[] nums) {\\n        map = new HashMap<>();\\n        rand = new Random();\\n        List<Integer> list;\\n        for(int i=0;i<nums.length;i++){\\n            list = map.getOrDefault(nums[i], new ArrayList<Integer>());\\n            list.add(i);\\n            map.put(nums[i], list);\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        List<Integer> list = map.get(target);\\n        return list.get(rand.nextInt(list.size()));\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int param_1 = obj.pick(target);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Math",
                    "Reservoir Sampling",
                    "Randomized"
                ],
                "code": "```\\nclass Solution {\\n    \\n    Map<Integer, List<Integer>> map;\\n    Random rand;\\n    \\n    public Solution(int[] nums) {\\n        map = new HashMap<>();\\n        rand = new Random();\\n        List<Integer> list;\\n        for(int i=0;i<nums.length;i++){\\n            list = map.getOrDefault(nums[i], new ArrayList<Integer>());\\n            list.add(i);\\n            map.put(nums[i], list);\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        List<Integer> list = map.get(target);\\n        return list.get(rand.nextInt(list.size()));\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int param_1 = obj.pick(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493682,
                "title": "beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n  ; \\nvector<int> v; \\n    Solution(vector<int>& nums) \\n    {\\n         n = nums.size();\\n         v = nums;\\n    }\\n    \\n    int pick(int target) \\n    {\\n        int idx = rand()%n; \\n        if(v[idx]==target)\\n        return idx;\\n        else return pick(target);\\n        \\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n  ; \\nvector<int> v; \\n    Solution(vector<int>& nums) \\n    {\\n         n = nums.size();\\n         v = nums;\\n    }\\n    \\n    int pick(int target) \\n    {\\n        int idx = rand()%n; \\n        if(v[idx]==target)\\n        return idx;\\n        else return pick(target);\\n        \\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3346823,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    Solution(vector<int>& nums) {\\n        arr = nums; \\n    }\\n    int pick(int target) {\\n        int len = arr.size();\\n        int random = 0 + (rand() % len);\\n        while(arr[random] != target)\\n            random = 0 + (rand() % len);\\n        return random;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        while True:\\n            i = int(random.random()*len(self.nums))\\n            if self.nums[i] == target:\\n                return i\\n```\\n\\n```Java []\\nclass Solution {\\n    private Random rmd;\\n    private int[] nums;\\n    public Solution(int[] nums) {\\n        this.rmd = new Random();\\n        this.nums = nums;\\n    }\\n    public int pick(int target) {\\n        while (true) {\\n            int index = rmd.nextInt(nums.length);\\n            if (nums[index] == target) {\\n                return index;\\n            }\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    Solution(vector<int>& nums) {\\n        arr = nums; \\n    }\\n    int pick(int target) {\\n        int len = arr.size();\\n        int random = 0 + (rand() % len);\\n        while(arr[random] != target)\\n            random = 0 + (rand() % len);\\n        return random;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        while True:\\n            i = int(random.random()*len(self.nums))\\n            if self.nums[i] == target:\\n                return i\\n```\n```Java []\\nclass Solution {\\n    private Random rmd;\\n    private int[] nums;\\n    public Solution(int[] nums) {\\n        this.rmd = new Random();\\n        this.nums = nums;\\n    }\\n    public int pick(int target) {\\n        while (true) {\\n            int index = rmd.nextInt(nums.length);\\n            if (nums[index] == target) {\\n                return index;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3278843,
                "title": "c-simplest-solution-rand-reservoir-sampling",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int, vector<int>> hashmap;\\n    Solution(vector<int>& nums) {\\n       for (int i=0; i<nums.size(); i++) \\n            hashmap[nums[i]].emplace_back(i); \\n    }\\n    \\n    int pick(int target) {\\n        int n = hashmap[target].size();\\n        int ind = rand();\\n        return hashmap[target][ind % n];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Reservoir Sampling",
                    "Randomized"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, vector<int>> hashmap;\\n    Solution(vector<int>& nums) {\\n       for (int i=0; i<nums.size(); i++) \\n            hashmap[nums[i]].emplace_back(i); \\n    }\\n    \\n    int pick(int target) {\\n        int n = hashmap[target].size();\\n        int ind = rand();\\n        return hashmap[target][ind % n];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274674,
                "title": "java-pick-o-1-solution-using-map",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> map;\\n    static Random random = new Random();\\n\\n    public Solution(int[] nums) {\\n        map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int key = nums[i];\\n            if (map.containsKey(key)) {\\n                map.get(key).add(i);\\n            } else {\\n                List<Integer> ids = new ArrayList<>();\\n                ids.add(i);\\n                map.put(key, ids);\\n            }\\n        }\\n    }\\n\\n    public int pick(int target) {\\n        List<Integer> ids = map.get(target);\\n        return ids.get(random.nextInt(ids.size()));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, List<Integer>> map;\\n    static Random random = new Random();\\n\\n    public Solution(int[] nums) {\\n        map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            int key = nums[i];\\n            if (map.containsKey(key)) {\\n                map.get(key).add(i);\\n            } else {\\n                List<Integer> ids = new ArrayList<>();\\n                ids.add(i);\\n                map.put(key, ids);\\n            }\\n        }\\n    }\\n\\n    public int pick(int target) {\\n        List<Integer> ids = map.get(target);\\n        return ids.get(random.nextInt(ids.size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090521,
                "title": "easiest-solution-math-random-beats-90",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>nums;\\n    Solution(vector<int>& nums) {\\n        this->nums=nums;\\n    }\\n    \\n    int pick(int target) {\\n        int n=nums.size();\\n        int idx=rand()%n;\\n        if(nums[idx]==target)return idx;\\n        else{\\n            while(nums[idx]!=target){\\n                idx=rand()%n;\\n            }\\n            return idx;\\n        }\\n\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>nums;\\n    Solution(vector<int>& nums) {\\n        this->nums=nums;\\n    }\\n    \\n    int pick(int target) {\\n        int n=nums.size();\\n        int idx=rand()%n;\\n        if(nums[idx]==target)return idx;\\n        else{\\n            while(nums[idx]!=target){\\n                idx=rand()%n;\\n            }\\n            return idx;\\n        }\\n\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894753,
                "title": "c",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    private List<int> list = new List<int>();\\n\\n    public Solution(int[] nums) \\n    {\\n        list.AddRange(nums);    \\n    }\\n    \\n    public int Pick(int target) \\n    {\\n        List<int> temp = new List<int>();\\n\\n        for (int i=0; i<list.Count; i++)\\n        {\\n            if (list[i] == target)\\n            {\\n                temp.Add(i);\\n            }\\n        }\\n\\n        Random random = new Random();\\n        return temp[random.Next(0, temp.Count)];\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int param_1 = obj.Pick(target);\\n */\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    private List<int> list = new List<int>();\\n\\n    public Solution(int[] nums) \\n    {\\n        list.AddRange(nums);    \\n    }\\n    \\n    public int Pick(int target) \\n    {\\n        List<int> temp = new List<int>();\\n\\n        for (int i=0; i<list.Count; i++)\\n        {\\n            if (list[i] == target)\\n            {\\n                temp.Add(i);\\n            }\\n        }\\n\\n        Random random = new Random();\\n        return temp[random.Next(0, temp.Count)];\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int param_1 = obj.Pick(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810470,
                "title": "python-simple-4-line-code-98-61-faster-runtime-339-ms",
                "content": "Runtime: 339 ms, faster than 98.61%\\nMemory Usage: 24.1 MB, less than 27.08%\\n\\n\\tclass Solution(object):\\n\\t\\tdef __init__(self, nums):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type nums: List[int]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tself.dict = defaultdict(list)\\n\\n\\t\\t\\tfor i, n in enumerate(nums):\\n\\t\\t\\t\\tself.dict[n].append(i)\\n\\n\\n\\t\\tdef pick(self, target):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type target: int\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\treturn choice(self.dict[target])\\n\\n\\n\\t# Your Solution object will be instantiated and called as such:\\n\\t# obj = Solution(nums)\\n\\t# param_1 = obj.pick(target)",
                "solutionTags": [
                    "Python"
                ],
                "code": "Runtime: 339 ms, faster than 98.61%\\nMemory Usage: 24.1 MB, less than 27.08%\\n\\n\\tclass Solution(object):\\n\\t\\tdef __init__(self, nums):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type nums: List[int]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tself.dict = defaultdict(list)\\n\\n\\t\\t\\tfor i, n in enumerate(nums):\\n\\t\\t\\t\\tself.dict[n].append(i)\\n\\n\\n\\t\\tdef pick(self, target):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type target: int\\n\\t\\t\\t:rtype: int\\n\\t\\t\\t\"\"\"\\n\\t\\t\\treturn choice(self.dict[target])\\n\\n\\n\\t# Your Solution object will be instantiated and called as such:\\n\\t# obj = Solution(nums)\\n\\t# param_1 = obj.pick(target)",
                "codeTag": "Java"
            },
            {
                "id": 2798470,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    Solution(vector<int>& nums) {\\n        arr = nums;\\n        \\n    }\\n    \\n    int pick(int target) {\\n        int len = arr.size();\\n        int random = 0 + (rand() % len);\\n        while(arr[random] != target)\\n            random = 0 + (rand() % len);\\n        \\n        return random;\\n        \\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    Solution(vector<int>& nums) {\\n        arr = nums;\\n        \\n    }\\n    \\n    int pick(int target) {\\n        int len = arr.size();\\n        int random = 0 + (rand() % len);\\n        while(arr[random] != target)\\n            random = 0 + (rand() % len);\\n        \\n        return random;\\n        \\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697955,
                "title": "99-65-c-random-function",
                "content": "![image](https://assets.leetcode.com/users/images/1daf3d7d-dd60-4338-9912-22b1b0111a41_1665655022.5902166.png)\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    Solution(vector<int>& nums) {\\n        arr = nums;\\n        \\n    }\\n    \\n    int pick(int target) {\\n        int len = arr.size();\\n        int random = 0 + (rand() % len);\\n        while(arr[random] != target)\\n            random = 0 + (rand() % len);\\n        \\n        return random;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> arr;\\n    Solution(vector<int>& nums) {\\n        arr = nums;\\n        \\n    }\\n    \\n    int pick(int target) {\\n        int len = arr.size();\\n        int random = 0 + (rand() % len);\\n        while(arr[random] != target)\\n            random = 0 + (rand() % len);\\n        \\n        return random;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615025,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> arr;\\n    Solution(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            arr.push_back({nums[i],i});\\n        }\\n        sort(arr.begin(),arr.end());\\n    }\\n    \\n    int pick(int target) {\\n        int n=arr.size();\\n        int lo=0,hi=n-1,lower=-1,higher=-1;\\n        \\n        //Upper bound\\n        while(lo<=hi){\\n            int mid=(lo+hi)/2;\\n            if(arr[mid].first<=target){\\n                lo=mid+1;\\n                higher=mid;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        \\n        //Lower bound\\n        lo=0,hi=n-1;\\n        while(lo<=hi){\\n            int mid=(lo+hi)/2;\\n            if(arr[mid].first>=target){\\n                hi=mid-1;\\n                lower=mid;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }\\n        \\n        int index=rand()%(higher-lower+1);\\n        return arr[lower+index].second;\\n        \\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> arr;\\n    Solution(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            arr.push_back({nums[i],i});\\n        }\\n        sort(arr.begin(),arr.end());\\n    }\\n    \\n    int pick(int target) {\\n        int n=arr.size();\\n        int lo=0,hi=n-1,lower=-1,higher=-1;\\n        \\n        //Upper bound\\n        while(lo<=hi){\\n            int mid=(lo+hi)/2;\\n            if(arr[mid].first<=target){\\n                lo=mid+1;\\n                higher=mid;\\n            }else{\\n                hi=mid-1;\\n            }\\n        }\\n        \\n        //Lower bound\\n        lo=0,hi=n-1;\\n        while(lo<=hi){\\n            int mid=(lo+hi)/2;\\n            if(arr[mid].first>=target){\\n                hi=mid-1;\\n                lower=mid;\\n            }else{\\n                lo=mid+1;\\n            }\\n        }\\n        \\n        int index=rand()%(higher-lower+1);\\n        return arr[lower+index].second;\\n        \\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510351,
                "title": "c-easy-solution-using-random-inbuilt-function",
                "content": "```\\nclass Solution {\\n    \\n    unordered_map<int , vector<int>> mp;\\n    \\npublic:\\n    Solution(vector<int>& nums) {\\n        \\n        for(int i = 0 ; i<nums.size() ; i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        \\n        int x = rand();\\n        int size = mp[target].size();\\n         return mp[target][x%size];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\n    unordered_map<int , vector<int>> mp;\\n    \\npublic:\\n    Solution(vector<int>& nums) {\\n        \\n        for(int i = 0 ; i<nums.size() ; i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        \\n        int x = rand();\\n        int size = mp[target].size();\\n         return mp[target][x%size];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399678,
                "title": "simple-python-w-defaultdict",
                "content": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.array = defaultdict(list)\\n        \\n        for k,v in enumerate(nums):\\n            self.array[v].append(k)\\n\\n    def pick(self, target: int) -> int:\\n         \\n        return random.choice(self.array[target])\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.pick(target)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.array = defaultdict(list)\\n        \\n        for k,v in enumerate(nums):\\n            self.array[v].append(k)\\n\\n    def pick(self, target: int) -> int:\\n         \\n        return random.choice(self.array[target])\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.pick(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201252,
                "title": "c-hashmap-5-lines-of-code-explained",
                "content": "**Method:**\\n\\n```\\n* store the indexes where each unique element of nums is present in a map\\n* key = unique element; value = vector containing all the indexes where this key is present\\n* now find the size(let\\'s say it is k) of the vector array corresponding to the key==target\\n* generate a random number between 0 to k\\n* return element present at that position in the vector array\\n\\n```\\n\\n**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    unordered_map<int, vector<int>> mp;\\n    Solution(vector<int> &nums)\\n    {\\n        for (int i = 0; i < nums.size(); i++)\\n            mp[nums[i]].push_back(i);\\n    }\\n\\n    int pick(int target)\\n    {\\n        int k = mp[target].size();\\n        int r = rand() % k;\\n        return mp[target][r];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n* store the indexes where each unique element of nums is present in a map\\n* key = unique element; value = vector containing all the indexes where this key is present\\n* now find the size(let\\'s say it is k) of the vector array corresponding to the key==target\\n* generate a random number between 0 to k\\n* return element present at that position in the vector array\\n\\n```\n```\\nclass Solution\\n{\\npublic:\\n    unordered_map<int, vector<int>> mp;\\n    Solution(vector<int> &nums)\\n    {\\n        for (int i = 0; i < nums.size(); i++)\\n            mp[nums[i]].push_back(i);\\n    }\\n\\n    int pick(int target)\\n    {\\n        int k = mp[target].size();\\n        int r = rand() % k;\\n        return mp[target][r];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161360,
                "title": "this-solution-is-ultra-fast-c",
                "content": "**Steps to follow**\\n1. Take a vector\\n2. use rand() function .\\nTo be in the range of the vector make a new variable and store rand() % vector(V).size()\\nEvery time check if  **V[rand()%v.size()] == target**  if yes then return Index else run a while loop till V[index] not equal to Target.\\n*The math behind the rand() function is very complex henxe the probablity of this function is eually likely*.\\n```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    Solution(vector<int>& nums) {\\n      v = nums; \\n    }\\n    \\n    int pick(int target) {\\n        int i = rand()%v.size();\\n        if(v[i]==target)\\n        {\\n            return i;\\n        }\\n        else\\n        {\\n            while(v[i]!=target)\\n            {\\n                i = rand()%v.size();\\n            }\\n            \\n        }\\n        return i;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    Solution(vector<int>& nums) {\\n      v = nums; \\n    }\\n    \\n    int pick(int target) {\\n        int i = rand()%v.size();\\n        if(v[i]==target)\\n        {\\n            return i;\\n        }\\n        else\\n        {\\n            while(v[i]!=target)\\n            {\\n                i = rand()%v.size();\\n            }\\n            \\n        }\\n        return i;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116438,
                "title": "reservoir-sampling-map-python3",
                "content": "Map \\n```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.d = defaultdict(list)\\n        for idx, num in enumerate(nums):\\n            self.d[num].append(idx)\\n        \\n\\n    def pick(self, target: int) -> int:\\n        return random.choice(self.d[target])\\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.pick(target)\\n```\\n\\nReservoir Sampling (TLE)\\n```\\nclass Solution:\\n\\n    def __init__(self, nums):\\n        self.nums = nums\\n    \\n    def pick(self, target):\\n        res = None\\n        count = 0\\n        for idx, num in enumerate(self.nums):\\n            if num == target:\\n                count += 1\\n                if random.randint(1, count) == count:\\n                    res = idx\\n        return res\\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.pick(target)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.d = defaultdict(list)\\n        for idx, num in enumerate(nums):\\n            self.d[num].append(idx)\\n        \\n\\n    def pick(self, target: int) -> int:\\n        return random.choice(self.d[target])\\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.pick(target)\\n```\n```\\nclass Solution:\\n\\n    def __init__(self, nums):\\n        self.nums = nums\\n    \\n    def pick(self, target):\\n        res = None\\n        count = 0\\n        for idx, num in enumerate(self.nums):\\n            if num == target:\\n                count += 1\\n                if random.randint(1, count) == count:\\n                    res = idx\\n        return res\\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.pick(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056930,
                "title": "java-using-hashmap-unique-and-clean-well-commented-explanation",
                "content": "**Approach:**\\n1) We will make a static HashMap hm of (Integer mapped to ArrayList<Integer>).\\n2) When Solution Function is called, we initialise our HashMap hm.\\n3) Inside the Solution only, we traverse the nums Array and fill the Hashmap.\\n4) In the HashMap, we map the Value in the nums Array with an ArrayList and this ArrayList contains all the indexes of Value inside the nums Array.\\n5) When the \"Pick\" function is called, we first get from the HashMap, the ArrayList mapped to the given target.\\n6) We find the size of this ArrayList and then using Math.random() function we call the random index from the ArrayList.\\n\\n```\\nclass Solution {\\n    HashMap<Integer,ArrayList<Integer>> hm;\\n\\n    public Solution(int[] nums) {\\n        hm=new HashMap<>(); //Initialising the HashMap\\n\\t\\t\\n        //Traverse the nums array and fill the HashMap\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            ArrayList<Integer> idxArr=hm.getOrDefault(nums[i],new ArrayList<Integer>());\\n            idxArr.add(i);\\n            hm.put(nums[i],idxArr);\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        ArrayList<Integer> idxArr=hm.get(target); //Get the ArrayList mapped to the given \"target\" value\\n        \\n        int size=idxArr.size(); //Find the size of this ArrayList\\n        \\n\\t\\t//Using Math.random() find the randomIdx in the range 0 to size-1\\n        int randomIdx=(int)(Math.random()*size); \\n        \\n        return idxArr.get(randomIdx); //Return the value from the ArrayList at the randomIdx\\n    }\\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    HashMap<Integer,ArrayList<Integer>> hm;\\n\\n    public Solution(int[] nums) {\\n        hm=new HashMap<>(); //Initialising the HashMap\\n\\t\\t\\n        //Traverse the nums array and fill the HashMap\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            ArrayList<Integer> idxArr=hm.getOrDefault(nums[i],new ArrayList<Integer>());\\n            idxArr.add(i);\\n            hm.put(nums[i],idxArr);\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        ArrayList<Integer> idxArr=hm.get(target); //Get the ArrayList mapped to the given \"target\" value\\n        \\n        int size=idxArr.size(); //Find the size of this ArrayList\\n        \\n\\t\\t//Using Math.random() find the randomIdx in the range 0 to size-1\\n        int randomIdx=(int)(Math.random()*size); \\n        \\n        return idxArr.get(randomIdx); //Return the value from the ArrayList at the randomIdx\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2001636,
                "title": "c-if-your-code-is-giving-tle-do-this",
                "content": "\\'\\'\\'\\n\\nprivate:\\n\\n    unordered_map<int, vector<int>> indices;\\n\\npublic:\\n    \\n    Solution(vector<int>& nums) {\\n        int l = nums.size();\\n        for (int i = 0; i < l; ++i) {\\n            this->indices[nums[i]].push_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        int l = indices[target].size();\\n        // pick an index at random\\n        int randomIndex = indices[target][rand() % l];\\n        return randomIndex;\\n    }\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "\\'\\'\\'\\n\\nprivate:\\n\\n    unordered_map<int, vector<int>> indices;\\n\\npublic:\\n    \\n    Solution(vector<int>& nums) {\\n        int l = nums.size();\\n        for (int i = 0; i < l; ++i) {\\n            this->indices[nums[i]].push_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        int l = indices[target].size();\\n        // pick an index at random\\n        int randomIndex = indices[target][rand() % l];\\n        return randomIndex;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1914063,
                "title": "python-easy-understanding-solution-o-1-time-when-picking",
                "content": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.dict = collections.defaultdict(list)       # self.dict record: {unique num: [indices]}\\n        for i, n in enumerate(nums):\\n            self.dict[n].append(i)\\n    def pick(self, target: int) -> int:\\n        return random.choice(self.dict[target])         # random pick from list is O(1)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.dict = collections.defaultdict(list)       # self.dict record: {unique num: [indices]}",
                "codeTag": "Java"
            },
            {
                "id": 1791566,
                "title": "python-simple-dict-and-random",
                "content": "````\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        self.indices = defaultdict(list)\\n        for i,v in enumerate(nums):\\n            self.indices[v].append(i)\\n        \\n    def pick(self, target: int) -> int:\\n        return choice(self.indices[target])\\n````",
                "solutionTags": [],
                "code": "````\\nclass Solution:\\n    def __init__(self, nums: List[int]):\\n        self.indices = defaultdict(list)\\n        for i,v in enumerate(nums):\\n            self.indices[v].append(i)\\n        \\n    def pick(self, target: int) -> int:\\n        return choice(self.indices[target])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744977,
                "title": "easy-peasy-python",
                "content": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.hash=defaultdict(list)\\n        for i,num in enumerate(nums):\\n            self.hash[num].append(i)\\n        \\n    def pick(self, target: int) -> int:\\n        return random.choice(self.hash[target])",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.hash=defaultdict(list)\\n        for i,num in enumerate(nums):\\n            self.hash[num].append(i)\\n        \\n    def pick(self, target: int) -> int:\\n        return random.choice(self.hash[target])",
                "codeTag": "Java"
            },
            {
                "id": 1741219,
                "title": "c-very-easy-approach",
                "content": "\\n\\'\\'\\'\\n\\n    unordered_map<int,vector<int>> mp;\\n    Solution(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        int n = mp[target].size();\\n        int j = rand()%n;\\n        return mp[target][j];\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n\\'\\'\\'\\n\\n    unordered_map<int,vector<int>> mp;\\n    Solution(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]].push_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        int n = mp[target].size();\\n        int j = rand()%n;\\n        return mp[target][j];\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1628136,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n\\n    Random r=new Random();\\n    HashMap<Integer,ArrayList<Integer>> map=new HashMap<>();\\n    public Solution(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])) map.get(nums[i]).add(i);\\n            else{\\n                map.put(nums[i],new ArrayList<>());\\n                map.get(nums[i]).add(i);\\n            }\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        return map.get(target).get(r.nextInt(map.get(target).size()));\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    Random r=new Random();\\n    HashMap<Integer,ArrayList<Integer>> map=new HashMap<>();\\n    public Solution(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            if(map.containsKey(nums[i])) map.get(nums[i]).add(i);\\n            else{\\n                map.put(nums[i],new ArrayList<>());\\n                map.get(nums[i]).add(i);\\n            }\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        return map.get(target).get(r.nextInt(map.get(target).size()));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615403,
                "title": "c",
                "content": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int,vector<int>> m;\\npublic:\\n    Solution(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]].push_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        int randnum=rand()%m[target].size();\\n        return m[target][randnum];\\n    }\\n    \\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    unordered_map<int,vector<int>> m;\\npublic:\\n    Solution(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]].push_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        int randnum=rand()%m[target].size();\\n        return m[target][randnum];\\n    }\\n    \\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569137,
                "title": "c-simple-implementation-using-rand",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>mp;\\n    Solution(vector<int>& nums) {\\n        \\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]].push_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        auto picked=mp[target];\\n        // int n=picked.size();\\n        return picked[rand()%picked.size()];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>mp;\\n    Solution(vector<int>& nums) {\\n        \\n        for(int i=0;i<nums.size();i++){\\n            mp[nums[i]].push_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {\\n        auto picked=mp[target];\\n        // int n=picked.size();\\n        return picked[rand()%picked.size()];\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560435,
                "title": "c-solution",
                "content": "**Approach 1: Reservoir Sampling**\\n\\nReservior Sampling allows us randomly choose ```k``` samples from ```n``` items, where n is either too large or even unknown. \\n\\nFor this particular question, ```k = 1```. We need to make the probability of choosing each ```target``` is ```1/count``` where count is the number of ocurrence of ```target```.\\n- When the 1st ```target``` occurs, we have no choices but to choose it, so ```P(target1) = 1```.\\n- When the 2nd ```target``` occurs, we choose it with ```1/2``` probability, so ```P(target2) = 1/2```. \\n\\t- At this time, ```P(target1) = 1 * 1/2 = 1/2```.\\n\\t\\t- ```1```: probability of being chosen from the previous round.\\n\\t\\t- ```1/2```:  probability of not being replaced in current round.\\n- When the 3rd ```target``` occurs, we choose it with ```1/3``` probability, so```P(target3) = 1/3```.\\n\\t- At this time,  ```P(target1) = P(target2) = 1/2* (1-1/3)= 1/3```.\\n\\t\\t- ```1/2```: probability of being chosen from the previous round.\\n\\t\\t- ```1-1/3```:  probability of not being replaced in current round.\\n-  ...\\n-  For the i-th target, ```P(target i) = 1/i * [1- 1/(i+1)]* [1 - 1/(i+2)] * ...* (1 - 1/n) = 1/n = 1/n ```.\\n\\t\\t-  ```1/i ```: probability of being chosen in ```i-th``` round.\\n\\t\\t-  ```[1- 1/(i+1)]```: probability of not being replaced in ```(i+1)-th``` round.\\n\\t\\t-  ```[1- 1/(i+2)]```: probability of not being replaced in ```(i+2)-th``` round.\\n\\t\\t-  ...\\n\\t\\t-  ```[1 - 1/n]```: probability of not being replaced in ```n-th``` round.\\n\\n**Complexity**\\n- Time: O(n)\\n- Space: O(1)\\n\\n```\\npublic class Solution {\\n\\n    private int[] arr;\\n    private Random random;\\n    \\n    public Solution(int[] nums) {\\n    \\n        random = new Random();\\n        \\n        arr = new int[nums.Length];\\n        for(int i = 0; i < arr.Length; i++)\\n            arr[i] = nums[i];\\n    }\\n    \\n    public int Pick(int target) {\\n        \\n        int res = -1, cnt = 0; \\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            if(arr[i] == target)\\n            {\\n                cnt++;\\n                \\n                // Reservoir Sampling\\n                // Choose i-th target with probability of 1/cnt\\n                // random.Next(0,cnt) return an random value between 0 and cnt-1 inclusively\\n                // so the probability that random value is 0 is 1/cnt\\n                int randomIdx = random.Next(0,cnt);\\n                if(randomIdx == 0)\\n                    res = i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**Approach 2: Dictionary+List**\\n- Time: O(n)\\n- Space: O(n)\\n```\\npublic class Solution {\\n\\n    private Dictionary<int, List<int>> dic;\\n    private Random random;\\n    \\n    public Solution(int[] nums) {\\n        \\n        dic = new Dictionary<int,List<int>>();\\n        random = new Random();\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(dic.ContainsKey(nums[i]))\\n                dic[nums[i]].Add(i);\\n            else\\n                dic.Add(nums[i], new List<int>(){i});\\n        }\\n    }\\n    \\n    public int Pick(int target) {\\n        \\n        int idx = random.Next(0, dic[target].Count);\\n        return dic[target][idx];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```k```\n```n```\n```k = 1```\n```target```\n```1/count```\n```target```\n```target```\n```P(target1) = 1```\n```target```\n```1/2```\n```P(target2) = 1/2```\n```P(target1) = 1 * 1/2 = 1/2```\n```1```\n```1/2```\n```target```\n```1/3```\n```P(target3) = 1/3```\n```P(target1) = P(target2) = 1/2* (1-1/3)= 1/3```\n```1/2```\n```1-1/3```\n```P(target i) = 1/i * [1- 1/(i+1)]* [1 - 1/(i+2)] * ...* (1 - 1/n) = 1/n = 1/n ```\n```1/i ```\n```i-th```\n```[1- 1/(i+1)]```\n```(i+1)-th```\n```[1- 1/(i+2)]```\n```(i+2)-th```\n```[1 - 1/n]```\n```n-th```\n```\\npublic class Solution {\\n\\n    private int[] arr;\\n    private Random random;\\n    \\n    public Solution(int[] nums) {\\n    \\n        random = new Random();\\n        \\n        arr = new int[nums.Length];\\n        for(int i = 0; i < arr.Length; i++)\\n            arr[i] = nums[i];\\n    }\\n    \\n    public int Pick(int target) {\\n        \\n        int res = -1, cnt = 0; \\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            if(arr[i] == target)\\n            {\\n                cnt++;\\n                \\n                // Reservoir Sampling\\n                // Choose i-th target with probability of 1/cnt\\n                // random.Next(0,cnt) return an random value between 0 and cnt-1 inclusively\\n                // so the probability that random value is 0 is 1/cnt\\n                int randomIdx = random.Next(0,cnt);\\n                if(randomIdx == 0)\\n                    res = i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n\\n    private Dictionary<int, List<int>> dic;\\n    private Random random;\\n    \\n    public Solution(int[] nums) {\\n        \\n        dic = new Dictionary<int,List<int>>();\\n        random = new Random();\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(dic.ContainsKey(nums[i]))\\n                dic[nums[i]].Add(i);\\n            else\\n                dic.Add(nums[i], new List<int>(){i});\\n        }\\n    }\\n    \\n    public int Pick(int target) {\\n        \\n        int idx = random.Next(0, dic[target].Count);\\n        return dic[target][idx];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560005,
                "title": "c-unordered-map-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>> target_indices;\\n    \\n    Solution(vector<int>& nums) {\\n        for (int idx = 0; idx < nums.size(); idx++)\\n            target_indices[nums[idx]].push_back(idx);\\n    }\\n    \\n    int pick(int target) {\\n        vector<int>& indices = target_indices[target];\\n        return indices[rand() % indices.size()];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>> target_indices;\\n    \\n    Solution(vector<int>& nums) {\\n        for (int idx = 0; idx < nums.size(); idx++)\\n            target_indices[nums[idx]].push_back(idx);\\n    }\\n    \\n    int pick(int target) {\\n        vector<int>& indices = target_indices[target];\\n        return indices[rand() % indices.size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556838,
                "title": "java-fast-solution-tc-o-n-easy-understandable",
                "content": "```\\nclass Solution {\\n    \\n    HashMap<Integer,ArrayList<Integer>> map;\\n\\n    public Solution(int[] nums) {\\n        \\n        map=new HashMap<>();\\n        \\n        for (int i=0; i<nums.length; i++) {\\n            if (!map.containsKey(nums[i])) {\\n                map.put(nums[i], new ArrayList<>());\\n            }\\n            map.get(nums[i]).add(i);\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        \\n        ArrayList<Integer> l=map.get(target);\\n        int ind=(int)(Math.random()*l.size());\\n        \\n        return l.get(ind);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    \\n    HashMap<Integer,ArrayList<Integer>> map;\\n\\n    public Solution(int[] nums) {\\n        \\n        map=new HashMap<>();\\n        \\n        for (int i=0; i<nums.length; i++) {\\n            if (!map.containsKey(nums[i])) {\\n                map.put(nums[i], new ArrayList<>());\\n            }\\n            map.get(nums[i]).add(i);\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        \\n        ArrayList<Integer> l=map.get(target);\\n        int ind=(int)(Math.random()*l.size());\\n        \\n        return l.get(ind);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541885,
                "title": "c-using-map-of-vectors-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,vector<int>> mp;\\n    \\n    void set_values(vector<int>&nums){\\n        for(int i=0; i<nums.size(); i++){\\n           mp[nums[i]].push_back(i);       \\n        }    \\n    }\\n    Solution(vector<int>& nums) {\\n        set_values(nums);\\n    }\\n    \\n    int pick(int target) {\\n        vector<int> tmp = mp[target];\\n          return tmp[rand()%tmp.size()];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    map<int,vector<int>> mp;\\n    \\n    void set_values(vector<int>&nums){\\n        for(int i=0; i<nums.size(); i++){\\n           mp[nums[i]].push_back(i);       \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1528966,
                "title": "python-3-using-random-function",
                "content": "```\\ndef __init__(self, nums: List[int]):\\n\\tself.dic = {}\\n\\tl = len(nums)\\n\\n\\tfor i in range(0, l):\\n\\t\\tif nums[i] not in self.dic:\\n\\t\\t\\tself.dic[nums[i]] = [i]\\n\\t\\telse:\\n\\t\\t\\tself.dic[nums[i]].append(i)\\n\\ndef pick(self, target: int) -> int:\\n\\treturn self.dic[target][random.randint(0, len(self.dic[target])-1)]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef __init__(self, nums: List[int]):\\n\\tself.dic = {}\\n\\tl = len(nums)\\n\\n\\tfor i in range(0, l):\\n\\t\\tif nums[i] not in self.dic:\\n\\t\\t\\tself.dic[nums[i]] = [i]\\n\\t\\telse:\\n\\t\\t\\tself.dic[nums[i]].append(i)\\n\\ndef pick(self, target: int) -> int:\\n\\treturn self.dic[target][random.randint(0, len(self.dic[target])-1)]\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1435355,
                "title": "simple-implementation-in-javascript-without-using-math-random-and-equal-probability-for-picked-index",
                "content": "* Create a hash with [key = each number, value = array of indexes ]\\n* On pick, get the target array, rotate it by one and return value. **Could use linked list too.**\\n\\n```\\nvar Solution = function(nums) {\\n    this.hash = {};\\n    nums.forEach((num, index) => {\\n        if(!this.hash[num]) {\\n            this.hash[num] = [];            \\n        }\\n        this.hash[num].push(index);\\n    });\\n};\\n\\nSolution.prototype.pick = function(target) {\\n    const index = this.hash[target].shift();\\n    this.hash[target].push(index);\\n    return index;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar Solution = function(nums) {\\n    this.hash = {};\\n    nums.forEach((num, index) => {\\n        if(!this.hash[num]) {\\n            this.hash[num] = [];            \\n        }\\n        this.hash[num].push(index);\\n    });\\n};\\n\\nSolution.prototype.pick = function(target) {\\n    const index = this.hash[target].shift();\\n    this.hash[target].push(index);\\n    return index;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1362390,
                "title": "python-solution-using-random-choice",
                "content": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        res = random.choice([i for i, v in enumerate(self.nums) if v == target])\\n        return res\\n        \\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.pick(target)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        res = random.choice([i for i, v in enumerate(self.nums) if v == target])\\n        return res\\n        \\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.pick(target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339867,
                "title": "python-solution-o-n-hashmap",
                "content": "```\\n\\nimport random, bisect\\nfrom collections import defaultdict\\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums = nums\\n        self.numMap = defaultdict(list)\\n        \\n        for i, item in enumerate(self.nums):\\n            self.numMap[item].append(i)\\n            \\n       \\n        \\n\\n    def pick(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        size = self.numMap[target]\\n        index = random.choice(size)\\n        return index\\n        \\n        \\n        \\n        \\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.pick(target)",
                "solutionTags": [],
                "code": "```\\n\\nimport random, bisect\\nfrom collections import defaultdict\\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums = nums\\n        self.numMap = defaultdict(list)\\n        \\n        for i, item in enumerate(self.nums):\\n            self.numMap[item].append(i)\\n            \\n       \\n        \\n\\n    def pick(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        size = self.numMap[target]\\n        index = random.choice(size)\\n        return index\\n        \\n        \\n        \\n        \\n\\n\\n# Your Solution object will be instantiated and called as such:\\n# obj = Solution(nums)\\n# param_1 = obj.pick(target)",
                "codeTag": "Java"
            },
            {
                "id": 1333725,
                "title": "reservoir-in-python-o-n-for-pick",
                "content": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n        \\n\\n    def pick(self, target: int) -> int:\\n        \\n        res = -1\\n        count = 0\\n        for i, n in enumerate(self.nums):\\n            \\n            if  n == target:\\n                count += 1\\n                \\n                if randint(0, count-1) == 0 :\\n                    res = i\\n        return res\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n        \\n\\n    def pick(self, target: int) -> int:\\n        \\n        res = -1\\n        count = 0\\n        for i, n in enumerate(self.nums):\\n            \\n            if  n == target:\\n                count += 1\\n                \\n                if randint(0, count-1) == 0 :\\n                    res = i\\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322488,
                "title": "can-someone-explain-why-does-setting-a-seed-for-rand-in-c-leads-to-wrong-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    Solution(vector<int>& nums) {\\n        v = nums;\\n    }\\n    \\n    int pick(int target) {\\n        int n = v.size();\\n        vector<int> temp;\\n        for(int i = 0; i < n; i++) {\\n            if(v[i] == target) temp.push_back(i);\\n        }\\n        int x = temp.size();\\n        srand(time(0));\\n        int t = rand()%x;\\n        \\n        return temp[t];\\n    }\\n};\\n```\\n\\nI submitted this and got wrong answer verdict, I dont feel that should be the case\\nAlso after just commenting the srand(time(0)) , it passed.\\n\\nCan anyone explain reason behind this behaviour.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    Solution(vector<int>& nums) {\\n        v = nums;\\n    }\\n    \\n    int pick(int target) {\\n        int n = v.size();\\n        vector<int> temp;\\n        for(int i = 0; i < n; i++) {\\n            if(v[i] == target) temp.push_back(i);\\n        }\\n        int x = temp.size();\\n        srand(time(0));\\n        int t = rand()%x;\\n        \\n        return temp[t];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087550,
                "title": "using-binary-search-approach-in-java",
                "content": "```\\nPair<Integer,Integer> arr[];\\npublic Solution(int[] nums) {\\n\\tthis.nums = nums; \\n\\tint len = nums.length;\\n\\tarr = new Pair[len];\\n\\tfor(int idx=0; idx <len; ++idx){\\n\\t\\tarr[idx] = new Pair<>(nums[idx], idx);\\n\\t}\\n\\tArrays.sort(arr, (a,b) -> {\\n\\t\\tint val = a.getKey();\\n\\t\\tint x = b.getKey();\\n\\t\\tif (val < x)\\n\\t\\treturn -1;\\n\\t\\tif (val > x)\\n\\t\\treturn 1;\\n\\t\\treturn 0;\\n\\t});\\n}\\n\\npublic int pick(int target) {\\n\\treturn binPick(target);\\n}\\n\\npublic int binPick(int target) {\\n\\tint idx=binSearch(target);\\n\\n\\tint eidx=idx;\\n\\twhile(eidx+1 < arr.length && arr[eidx+1].getKey().equals(target)){\\n\\t\\t++eidx;\\n\\t}\\n\\n\\tif(idx==eidx) return arr[idx].getValue();\\n\\telse {\\n\\t\\tRandom r = new Random();\\n\\t\\tint rand = r.nextInt(eidx-idx+1);\\n\\t\\treturn arr[idx+rand].getValue();\\n\\t}\\n}\\n\\nprivate int binSearch(int value) {\\n\\tint len = arr.length;\\n\\tint st=0;\\n\\tint end=len-1;\\n\\twhile(st<end){\\n\\t\\tint mid = st + (end-st)/2;\\n\\t\\tint midValue = arr[mid].getKey();\\n\\t\\tif(midValue == value){\\n\\t\\t\\tend = mid;\\n\\t\\t}\\n\\t\\telse if(midValue > value){\\n\\t\\t\\tend = mid-1;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tst = mid+1;\\n\\t\\t}\\n\\t}\\n\\treturn st;\\n}\\n```\\nBinary search approach\\nONlogN to sort the array with O(N) space\\nbinPick does O(LogN) for lookup and O(N) scan worst case to find the end of equal range.\\n",
                "solutionTags": [],
                "code": "```\\nPair<Integer,Integer> arr[];\\npublic Solution(int[] nums) {\\n\\tthis.nums = nums; \\n\\tint len = nums.length;\\n\\tarr = new Pair[len];\\n\\tfor(int idx=0; idx <len; ++idx){\\n\\t\\tarr[idx] = new Pair<>(nums[idx], idx);\\n\\t}\\n\\tArrays.sort(arr, (a,b) -> {\\n\\t\\tint val = a.getKey();\\n\\t\\tint x = b.getKey();\\n\\t\\tif (val < x)\\n\\t\\treturn -1;\\n\\t\\tif (val > x)\\n\\t\\treturn 1;\\n\\t\\treturn 0;\\n\\t});\\n}\\n\\npublic int pick(int target) {\\n\\treturn binPick(target);\\n}\\n\\npublic int binPick(int target) {\\n\\tint idx=binSearch(target);\\n\\n\\tint eidx=idx;\\n\\twhile(eidx+1 < arr.length && arr[eidx+1].getKey().equals(target)){\\n\\t\\t++eidx;\\n\\t}\\n\\n\\tif(idx==eidx) return arr[idx].getValue();\\n\\telse {\\n\\t\\tRandom r = new Random();\\n\\t\\tint rand = r.nextInt(eidx-idx+1);\\n\\t\\treturn arr[idx+rand].getValue();\\n\\t}\\n}\\n\\nprivate int binSearch(int value) {\\n\\tint len = arr.length;\\n\\tint st=0;\\n\\tint end=len-1;\\n\\twhile(st<end){\\n\\t\\tint mid = st + (end-st)/2;\\n\\t\\tint midValue = arr[mid].getKey();\\n\\t\\tif(midValue == value){\\n\\t\\t\\tend = mid;\\n\\t\\t}\\n\\t\\telse if(midValue > value){\\n\\t\\t\\tend = mid-1;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tst = mid+1;\\n\\t\\t}\\n\\t}\\n\\treturn st;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1076994,
                "title": "simple-intuitive-python-beats-98",
                "content": "\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n        self.index_dict = {}\\n        self.count = {}\\n        \\n    def pick(self, target: int) -> int:\\n        if target not in self.index_dict:\\n            index = [i for i, num in enumerate(self.nums) if num == target]\\n            self.index_dict[target] = target # set index_list\\n\\t\\t\\tself.count[target] = -1 # set count from -1\\n        self.count[target] = (self.count[target]+1) % len(self.index_dict[target]) # count+1 modulo by length; if len == 3: 0-1-2-0-1-2...\\n        return self.index_dict[target][self.count[target]]\\n\\n\\t",
                "solutionTags": [],
                "code": "\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n        self.index_dict = {}\\n        self.count = {}\\n        \\n    def pick(self, target: int) -> int:\\n        if target not in self.index_dict:\\n            index = [i for i, num in enumerate(self.nums) if num == target]\\n            self.index_dict[target] = target # set index_list\\n\\t\\t\\tself.count[target] = -1 # set count from -1\\n        self.count[target] = (self.count[target]+1) % len(self.index_dict[target]) # count+1 modulo by length; if len == 3: 0-1-2-0-1-2...\\n        return self.index_dict[target][self.count[target]]\\n\\n\\t",
                "codeTag": "Python3"
            },
            {
                "id": 1015281,
                "title": "reservoir-sampling-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] nums;\\n    public Solution(int[] nums) {\\n        this.nums=nums;\\n    }\\n    \\n    public int pick(int target) {\\n        int count=0,index=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                count++;\\n                if(Math.random()<1.0/count)\\n                    index=i;\\n            }\\n        }\\n       return index; \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] nums;\\n    public Solution(int[] nums) {\\n        this.nums=nums;\\n    }\\n    \\n    public int pick(int target) {\\n        int count=0,index=0;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==target){\\n                count++;\\n                if(Math.random()<1.0/count)\\n                    index=i;\\n            }\\n        }\\n       return index; \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955859,
                "title": "simple-java-solution",
                "content": "Just store a list of all index corressponding to a number in a map, and return 1 index at random. \\n```\\nclass Solution {\\n    private Map<Integer,List<Integer>> map;\\n    private Random rand = new Random(); \\n    public Solution(int[] nums) {\\n        map = new HashMap();\\n        List<Integer> tmp;\\n        \\n        for(int i =0 ; i< nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                map.get(nums[i]).add(i);\\n            } else{\\n                tmp = new ArrayList<>();\\n                tmp.add(i);\\n                map.put(nums[i], tmp);\\n            }\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        List<Integer> mapping = map.get(target);\\n        return mapping.get(rand.nextInt(mapping.size()));\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Map<Integer,List<Integer>> map;\\n    private Random rand = new Random(); \\n    public Solution(int[] nums) {\\n        map = new HashMap();\\n        List<Integer> tmp;\\n        \\n        for(int i =0 ; i< nums.length; i++){\\n            if(map.containsKey(nums[i])){\\n                map.get(nums[i]).add(i);\\n            } else{\\n                tmp = new ArrayList<>();\\n                tmp.add(i);\\n                map.put(nums[i], tmp);\\n            }\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        List<Integer> mapping = map.get(target);\\n        return mapping.get(rand.nextInt(mapping.size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930965,
                "title": "simple-python-solution-5-lines-using-dictionary",
                "content": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.myDict=defaultdict(list)\\n        \\n        for idx,n in enumerate(nums):\\n            self.myDict[n].append(idx)\\n        \\n    def pick(self, target: int) -> int:\\n        rand=random.randint(0,len(self.myDict[target])-1)\\n        return self.myDict[target][rand]\\n\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.myDict=defaultdict(list)\\n        \\n        for idx,n in enumerate(nums):\\n            self.myDict[n].append(idx)\\n        \\n    def pick(self, target: int) -> int:\\n        rand=random.randint(0,len(self.myDict[target])-1)\\n        return self.myDict[target][rand]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916952,
                "title": "python-solution-using-dictionary",
                "content": "```python\\nfrom random import randint\\n\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.indices = {}\\n        for i, val in enumerate(nums):\\n            if val in self.indices:\\n                self.indices[val].append(i)\\n            else:\\n                self.indices[val] = [i]\\n\\n    def pick(self, target: int) -> int:\\n        if target not in self.indices:\\n            return -1\\n        \\n        i = randint(0, len(self.indices[target])-1)\\n        \\n        return self.indices[target][i]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nfrom random import randint\\n\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.indices = {}\\n        for i, val in enumerate(nums):\\n            if val in self.indices:\\n                self.indices[val].append(i)\\n            else:\\n                self.indices[val] = [i]\\n\\n    def pick(self, target: int) -> int:\\n        if target not in self.indices:\\n            return -1\\n        \\n        i = randint(0, len(self.indices[target])-1)\\n        \\n        return self.indices[target][i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 890603,
                "title": "brute-force",
                "content": "```\\nclass Solution(val nums: IntArray) {\\n    \\n    val map: HashMap<Int, ArrayList<Int>> = HashMap()\\n    val random = java.util.Random()\\n    init {\\n        for (i in nums.indices) {\\n            map.computeIfAbsent(nums[i]) { ArrayList<Int>() }.add(i)\\n        }\\n    }\\n    \\n    fun pick(target: Int): Int {\\n        val values = map[target]!!\\n        return values[random.nextInt(values.size)]\\n    }\\n\\n}\\n/**\\n\\n    KEY TERMS\\n    -----------\\n    Array of possible duplicates.\\n    Return idx\\'s of picks\\n    The idx\\'s should have equal probablity\\n    \\n    BRUTE FORCE\\n    -----------\\n    Store array in hashmap as <int, list of idx\\'s>\\n    For every pick call\\n        - return random from the list values\\n            - find a random index in the list\\n            - return that idx\\'s value\\n    1 : [0]\\n    2 : [1]\\n    3 : [2, 3, 4]\\n\\n**/\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution(val nums: IntArray) {\\n    \\n    val map: HashMap<Int, ArrayList<Int>> = HashMap()\\n    val random = java.util.Random()\\n    init {\\n        for (i in nums.indices) {\\n            map.computeIfAbsent(nums[i]) { ArrayList<Int>() }.add(i)\\n        }\\n    }\\n    \\n    fun pick(target: Int): Int {\\n        val values = map[target]!!\\n        return values[random.nextInt(values.size)]\\n    }\\n\\n}\\n/**\\n\\n    KEY TERMS\\n    -----------\\n    Array of possible duplicates.\\n    Return idx\\'s of picks\\n    The idx\\'s should have equal probablity\\n    \\n    BRUTE FORCE\\n    -----------\\n    Store array in hashmap as <int, list of idx\\'s>\\n    For every pick call\\n        - return random from the list values\\n            - find a random index in the list\\n            - return that idx\\'s value\\n    1 : [0]\\n    2 : [1]\\n    3 : [2, 3, 4]\\n\\n**/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881492,
                "title": "simple-map-and-deque-very-easy-solution",
                "content": "It simply works using deque data structure ;\\ni.e : for map[3] = (2,3,4);\\nafter first pick(3) ,  map[3] will correspond to (3,4,2) ans so on.\\n```\\nclass Solution {\\npublic:\\n    map<int, deque<int>> m;\\n    Solution(vector<int>& nums) \\n    {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]].push_back(i);\\n        }\\n    }\\n    int pick(int target) \\n    {\\n        int ans=m[target][0];\\n        deque<int> d = m[target];\\n        int k= d[0];\\n        d.pop_front();\\n        d.push_back(k);\\n        m[target]=d;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int, deque<int>> m;\\n    Solution(vector<int>& nums) \\n    {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m[nums[i]].push_back(i);\\n        }\\n    }\\n    int pick(int target) \\n    {\\n        int ans=m[target][0];\\n        deque<int> d = m[target];\\n        int k= d[0];\\n        d.pop_front();\\n        d.push_back(k);\\n        m[target]=d;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850626,
                "title": "via-linq",
                "content": "```\\npublic class Solution {\\n    private int[] _nums;\\n    \\n    public Solution(int[] nums) {\\n        _nums = nums;\\n    }\\n    \\n    public int Pick(int target) => _nums\\n            .Select((number, index) => new { number, index })\\n            .Where(x => x.number == target)\\n            .OrderBy(x => Guid.NewGuid())\\n            .Select(x => x.index)\\n            .First();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    private int[] _nums;\\n    \\n    public Solution(int[] nums) {\\n        _nums = nums;\\n    }\\n    \\n    public int Pick(int target) => _nums\\n            .Select((number, index) => new { number, index })\\n            .Where(x => x.number == target)\\n            .OrderBy(x => Guid.NewGuid())\\n            .Select(x => x.index)\\n            .First();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840770,
                "title": "simple-java-solution-faster-than-69",
                "content": "```\\nclass Solution {\\nint[] nums;\\n    public Solution(int[] nums) {\\n        this.nums=nums;\\n    }\\n    \\n    public int pick(int target) {\\n      List<Integer> list= new ArrayList<>();\\n        //figure out all the indices where target number appears\\n        //add those indices to a list\\n        for(int i=0;i<nums.length;i++)\\n            if(nums[i]==target)\\n                list.add(i);\\n        \\n        //randomly pick an index of the list\\n        //return item from that index\\n        Random random= new Random();\\n        int randomIndex=random.nextInt(list.size());\\n        return list.get(randomIndex);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nint[] nums;\\n    public Solution(int[] nums) {\\n        this.nums=nums;\\n    }\\n    \\n    public int pick(int target) {\\n      List<Integer> list= new ArrayList<>();\\n        //figure out all the indices where target number appears\\n        //add those indices to a list\\n        for(int i=0;i<nums.length;i++)\\n            if(nums[i]==target)\\n                list.add(i);\\n        \\n        //randomly pick an index of the list\\n        //return item from that index\\n        Random random= new Random();\\n        int randomIndex=random.nextInt(list.size());\\n        return list.get(randomIndex);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838806,
                "title": "java-98-2-approaches-depending-on-the-problem-set",
                "content": "This is an open ended question and solution depends on getting answers for following aspects\\n1. The frequency of \\'pick\\' vs size of the set.\\n2. The expected O(time) of the \\'pick\\' vs \\'initiatlization\\'\\n\\nThe statement that \"one should not use too much memory\" is a distraction from thinking about real aspects.  \\n\\n**Solution - 1**\\ntime : O(n) for \\'initialization\\' -  Where one would optimize the input to data structure for making \\'pick\\' quick\\ntime : O(1) for pick\\nsize : O(n) \\n```\\nclass Solution {\\n\\n    Map<Integer, List<Integer>> map;\\n    Random rand = new Random();\\n    \\n    public Solution(int[] nums) {\\n        map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) \\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\\n    }\\n    \\n    public int pick(int target) {\\n        List<Integer> positions = map.get(target);\\n        return positions.get(rand.nextInt(positions.size()));\\n    }\\n}\\n```\\n\\n**Solution - 2**\\ntime : O(1) for \\'initilization\\' - basically save the input without any processing.\\ntime : worst case O(n) for \\'pick\\', but average case will be much less than O(n). \\nsize  : O(n)\\n\\n```\\nclass Solution {\\n\\n    int[] nums;\\n    Random rand = new Random();\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int pick(int target) {\\n        while(true) {\\n            int index = rand.nextInt(nums.length);\\n            if (nums[index] == target)\\n                return index;\\n        }\\n    }\\n}\\n```\\n***P.S : The test cases given are happy with Solution-2, which would mean \\'picks\\' are relatively less compared to the size of the problem set.***\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    Map<Integer, List<Integer>> map;\\n    Random rand = new Random();\\n    \\n    public Solution(int[] nums) {\\n        map = new HashMap<>();\\n        for (int i = 0; i < nums.length; i++) \\n            map.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\\n    }\\n    \\n    public int pick(int target) {\\n        List<Integer> positions = map.get(target);\\n        return positions.get(rand.nextInt(positions.size()));\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    int[] nums;\\n    Random rand = new Random();\\n    \\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n    }\\n    \\n    public int pick(int target) {\\n        while(true) {\\n            int index = rand.nextInt(nums.length);\\n            if (nums[index] == target)\\n                return index;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 837074,
                "title": "javascript-hashmap-constructor-o-n-time-o-n-space-pick-o-1-time",
                "content": "```\\nvar Solution = function(nums) {\\n    this.map = new Map();\\n    nums.map((val, i) => {\\n            let indexes = this.map.has(val) ? this.map.get(val) : [];\\n            indexes.push(i);\\n            this.map.set(val, indexes);\\n    });  \\n};\\n\\nSolution.prototype.pick = function(target) {\\n    let arr = this.map.get(target);\\n    return arr[Math.floor(Math.random()*arr.length)];\\n};",
                "solutionTags": [],
                "code": "```\\nvar Solution = function(nums) {\\n    this.map = new Map();\\n    nums.map((val, i) => {\\n            let indexes = this.map.has(val) ? this.map.get(val) : [];\\n            indexes.push(i);\\n            this.map.set(val, indexes);\\n    });  \\n};\\n\\nSolution.prototype.pick = function(target) {\\n    let arr = this.map.get(target);\\n    return arr[Math.floor(Math.random()*arr.length)];\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 824633,
                "title": "c-simple-solution-using-rand-generator",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    int n;\\n    Solution(vector<int>& nums) {\\n        ans=nums;\\n        n=ans.size();\\n    }\\n    \\n    int pick(int target) {\\n        int i=rand()%n;\\n        while(ans[i]!=target){\\n            i=rand()%n;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    int n;\\n    Solution(vector<int>& nums) {\\n        ans=nums;\\n        n=ans.size();\\n    }\\n    \\n    int pick(int target) {\\n        int i=rand()%n;\\n        while(ans[i]!=target){\\n            i=rand()%n;\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813837,
                "title": "java-using-hashmap",
                "content": "\\n    HashMap<Integer, List<Integer>> map;\\n    \\n\\tpublic Solution(int[] nums) {\\n        map = new HashMap<>();\\n        for(int i = 0; i< nums.length; i++) {\\n            if(map.containsKey(nums[i])){\\n                map.get(nums[i]).add(i);\\n            } else{\\n                map.put(nums[i], new ArrayList(Arrays.asList(i)));\\n            }\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        Random rand = new Random();\\n        List<Integer> indices = map.get(target);\\n        return indices.get(rand.nextInt(indices.size())); \\n    }\\n",
                "solutionTags": [],
                "code": "\\n    HashMap<Integer, List<Integer>> map;\\n    \\n\\tpublic Solution(int[] nums) {\\n        map = new HashMap<>();\\n        for(int i = 0; i< nums.length; i++) {\\n            if(map.containsKey(nums[i])){\\n                map.get(nums[i]).add(i);\\n            } else{\\n                map.put(nums[i], new ArrayList(Arrays.asList(i)));\\n            }\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        Random rand = new Random();\\n        List<Integer> indices = map.get(target);\\n        return indices.get(rand.nextInt(indices.size())); \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 807376,
                "title": "rand-passed-c",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>v;\\n    Solution(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++)\\n            v[nums[i]].push_back(i);\\n    }\\n    int pick(int target) {\\n        int in=rand()%(v[target].size());\\n        return v[target][in];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>v;\\n    Solution(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++)\\n            v[nums[i]].push_back(i);\\n    }\\n    int pick(int target) {\\n        int in=rand()%(v[target].size());\\n        return v[target][in];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 791787,
                "title": "cpp14-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int , vector<int> > mpp ;\\n    Solution(vector<int>& nums) {\\n        mpp.clear() ; \\n        for(int i = 0 ; i < nums.size() ; ++i){\\n            mpp[nums[i]].push_back(i); \\n        }\\n    }\\n    \\n    int pick(int target) {\\n        int size = mpp[target].size(); \\n        int index = rand() % (size) ; \\n        int ans = mpp[target][index] ; \\n        return ans ; \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int , vector<int> > mpp ;\\n    Solution(vector<int>& nums) {\\n        mpp.clear() ; \\n        for(int i = 0 ; i < nums.size() ; ++i){\\n            mpp[nums[i]].push_back(i); \\n        }\\n    }\\n    \\n    int pick(int target) {\\n        int size = mpp[target].size(); \\n        int index = rand() % (size) ; \\n        int ans = mpp[target][index] ; \\n        return ans ; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789916,
                "title": "c-simple-code-faster-than-98-5-average-less-memory-usage-than-99-86",
                "content": "Here is my high end solution,i hope you will understand it ;)\\n\\n```\\nclass Solution {\\n    vector<int>& nums;\\npublic:\\n    Solution(vector<int>& nums) :nums(nums){}\\n    \\n    int pick(int target) {\\n        int i;\\n        do {\\n            i = rand()%nums.size();\\n        } while (nums[i]!=target);\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<int>& nums;\\npublic:\\n    Solution(vector<int>& nums) :nums(nums){}\\n    \\n    int pick(int target) {\\n        int i;\\n        do {\\n            i = rand()%nums.size();\\n        } while (nums[i]!=target);\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763749,
                "title": "c-resivior-sampling-and-reject-sampling",
                "content": "Reservoir sampling\\nimage we select 1 item from the data stream;\\nO(N) space O(N) time\\n```\\nprivate:\\n    vector<int> n;\\npublic:\\n    Solution(vector<int>& nums) {\\n        n=nums;\\n    }\\n    \\n    int pick(int target) {\\n        int count = 0, ret = -1;\\n        for(int i = 0;i<n.size();++i){\\n            if(target==n[i]){\\n                if(count == 0) ret = i;\\n                else if(rand()%(count+1)==1) ret = i;\\n                count++;\\n            }\\n        }\\n        return ret;\\n    }\\n```\\nRejection sampling O(N) space O(N) time\\n```\\nprivate:\\n    vector<int> n;\\npublic:\\n    Solution(vector<int>& nums) {\\n        n=nums;\\n    }\\n    \\n    int pick(int target) {\\n        int ret = 0;\\n        do{\\n            ret = rand()%n.size();\\n        } while(n[ret]!=target);\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate:\\n    vector<int> n;\\npublic:\\n    Solution(vector<int>& nums) {\\n        n=nums;\\n    }\\n    \\n    int pick(int target) {\\n        int count = 0, ret = -1;\\n        for(int i = 0;i<n.size();++i){\\n            if(target==n[i]){\\n                if(count == 0) ret = i;\\n                else if(rand()%(count+1)==1) ret = i;\\n                count++;\\n            }\\n        }\\n        return ret;\\n    }\\n```\n```\\nprivate:\\n    vector<int> n;\\npublic:\\n    Solution(vector<int>& nums) {\\n        n=nums;\\n    }\\n    \\n    int pick(int target) {\\n        int ret = 0;\\n        do{\\n            ret = rand()%n.size();\\n        } while(n[ret]!=target);\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 744559,
                "title": "easy-hashmap-python-solution",
                "content": "1) Store all indexed of every possible nums value in a hashmap \\n2) Choose random index from hashmap array based on its size\\n```\\nimport random\\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        d = {}\\n\\t\\t# Add all indexes of value as array\\n        for i, v in enumerate(nums):\\n            if v in d:\\n                d[v].append(i)\\n            else:\\n                d[v] = [i]\\n                \\n        self.d = d\\n\\n    def pick(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        d = self.d\\n        arr = d[target]\\n\\t\\t# Random index of array based on size\\n        return arr[random.randint(0,len(arr)-1)]\\n```",
                "solutionTags": [
                    "Python",
                    "Probability and Statistics"
                ],
                "code": "```\\nimport random\\nclass Solution(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        d = {}\\n\\t\\t# Add all indexes of value as array\\n        for i, v in enumerate(nums):\\n            if v in d:\\n                d[v].append(i)\\n            else:\\n                d[v] = [i]\\n                \\n        self.d = d\\n\\n    def pick(self, target):\\n        \"\"\"\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        d = self.d\\n        arr = d[target]\\n\\t\\t# Random index of array based on size\\n        return arr[random.randint(0,len(arr)-1)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741867,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution {\\n\\n    Dictionary<int,List<int>> dict = new Dictionary<int,List<int>>();\\n    Random rand = new Random();\\n    \\n    public Solution(int[] nums) \\n    {\\n        for(int i=0; i<nums.Length; i++)\\n        {\\n            dict.TryAdd(nums[i],new List<int>());\\n            dict[nums[i]].Add(i);\\n        }\\n    }\\n    \\n    public int Pick(int target) \\n    {\\n        List<int> indexes = dict[target];\\n        int liInd = rand.Next(0,indexes.Count);\\n        return indexes[liInd];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n    Dictionary<int,List<int>> dict = new Dictionary<int,List<int>>();\\n    Random rand = new Random();\\n    \\n    public Solution(int[] nums) \\n    {\\n        for(int i=0; i<nums.Length; i++)\\n        {\\n            dict.TryAdd(nums[i],new List<int>());\\n            dict[nums[i]].Add(i);\\n        }\\n    }\\n    \\n    public int Pick(int target) \\n    {\\n        List<int> indexes = dict[target];\\n        int liInd = rand.Next(0,indexes.Count);\\n        return indexes[liInd];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723436,
                "title": "java-hashmap-cleaner-code",
                "content": "```\\nclass Solution {\\n    private final Random rng = new Random();\\n    private final Map<Integer, List<Integer>> index = new HashMap<>();\\n\\n    public Solution(int[] nums) {\\n        for (int i = 0; i < nums.length; ++i)\\n            index.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\\n    }\\n    \\n    public int pick(int target) {\\n        final List<Integer> ind = index.get(target);\\n        return ind.get(rng.nextInt(ind.size()));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private final Random rng = new Random();\\n    private final Map<Integer, List<Integer>> index = new HashMap<>();\\n\\n    public Solution(int[] nums) {\\n        for (int i = 0; i < nums.length; ++i)\\n            index.computeIfAbsent(nums[i], k -> new ArrayList<>()).add(i);\\n    }\\n    \\n    public int pick(int target) {\\n        final List<Integer> ind = index.get(target);\\n        return ind.get(rng.nextInt(ind.size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701959,
                "title": "java-queue-solution",
                "content": "```\\nclass Solution {\\n\\n    Map<Integer,Queue<Integer>> map;\\n    public Solution(int[] nums) {\\n        map = new HashMap<>();\\n        if(nums == null)\\n            return;\\n        for(int i=0;i<nums.length;i++){\\n            map.putIfAbsent(nums[i],new LinkedList<Integer>());\\n            map.get(nums[i]).add(i);\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        Queue<Integer> q = map.get(target);\\n        int ind = q.poll();\\n        q.add(ind);\\n        return ind;\\n    }\\n}",
                "solutionTags": [
                    "Queue"
                ],
                "code": "class Solution {\\n\\n    Map<Integer,Queue<Integer>> map;\\n    public Solution(int[] nums) {\\n        map = new HashMap<>();\\n        if(nums == null)\\n            return;\\n        for(int i=0;i<nums.length;i++){\\n            map.putIfAbsent(nums[i],new LinkedList<Integer>());\\n            map.get(nums[i]).add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 691953,
                "title": "one-pass-using-hashmap",
                "content": "\\'\\'\\'\\nclass Node{\\n        int start;\\n        int end;\\n        \\n        public Node( int start, int end){\\n            this.start=start;\\n            this.end= end;\\n        }\\n    }\\n    \\n    Map<Integer,Node> map;\\n    public Solution(int[] nums) {\\n        map = new HashMap<>();\\n        fillMap(nums);\\n    }\\n    \\n    public int pick(int target) {\\n        \\n        Node node = map.get(target);\\n        \\n        return new Random().nextInt((node.end-node.start)+1)+node.start;\\n    }\\n    \\n    private void fillMap(int[] nums) {\\n        \\n        int left=0,right=0;\\n        \\n        while(right < nums.length) {\\n                \\n            if(nums[right]!=nums[left]){\\n                map.put(nums[left], new Node(left, right-1));\\n                left = right;\\n            }\\n            right++;\\n        }\\n        \\n        if(!map.containsKey(nums[left]))\\n            map.put(nums[left],new Node(left,right-1));\\n        \\n        return;\\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Node{\\n        int start;\\n        int end;\\n        \\n        public Node( int start, int end){\\n            this.start=start;\\n            this.end= end;\\n        }\\n    }\\n    \\n    Map<Integer,Node> map;\\n    public Solution(int[] nums) {\\n        map = new HashMap<>();\\n        fillMap(nums);\\n    }\\n    \\n    public int pick(int target) {\\n        \\n        Node node = map.get(target);\\n        \\n        return new Random().nextInt((node.end-node.start)+1)+node.start;\\n    }\\n    \\n    private void fillMap(int[] nums) {\\n        \\n        int left=0,right=0;\\n        \\n        while(right < nums.length) {\\n                \\n            if(nums[right]!=nums[left]){\\n                map.put(nums[left], new Node(left, right-1));\\n                left = right;\\n            }\\n            right++;\\n        }\\n        \\n        if(!map.containsKey(nums[left]))\\n            map.put(nums[left],new Node(left,right-1));\\n        \\n        return;\\n    }\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 672422,
                "title": "simple-java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    List<Integer> ls = new ArrayList<>();\\n    int[] n;\\n    public Solution(int[] nums) {\\n        this.n = nums;\\n    }\\n\\n    public int pick(int target) {\\n        for (int i=0;i<n.length;i++){\\n            if (n[i]==target)\\n                this.ls.add(i);\\n        }\\n        int len=ls.size();\\n        int number=(int)(Math.random()*(len));//\\u751F\\u6210[0,len-1]\\u4E4B\\u95F4\\u7684\\u968F\\u673A\\u6574\\u6570\\n        return ls.get(number);\\n   \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<Integer> ls = new ArrayList<>();\\n    int[] n;\\n    public Solution(int[] nums) {\\n        this.n = nums;\\n    }\\n\\n    public int pick(int target) {\\n        for (int i=0;i<n.length;i++){\\n            if (n[i]==target)\\n                this.ls.add(i);\\n        }\\n        int len=ls.size();\\n        int number=(int)(Math.random()*(len));//\\u751F\\u6210[0,len-1]\\u4E4B\\u95F4\\u7684\\u968F\\u673A\\u6574\\u6570\\n        return ls.get(number);\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 672196,
                "title": "c-simple-o-n-solution-using-reservoir-sampling-algorithm",
                "content": "```\\npublic class Solution {\\n    private int[] _nums;\\n    private Random _rand;\\n\\n    public Solution(int[] nums) {\\n        _nums = nums;\\n        _rand = new Random();\\n    }\\n    \\n    public int Pick(int target) {\\n        int index = 0;\\n        int count = 0;\\n        for (int i = 0; i < _nums.Length; i++) {\\n            if (_nums[i] == target) {\\n                count += 1;\\n                double r = _rand.NextDouble();\\n                if (r < 1.0/count)\\n                    index = i;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    private int[] _nums;\\n    private Random _rand;\\n\\n    public Solution(int[] nums) {\\n        _nums = nums;\\n        _rand = new Random();\\n    }\\n    \\n    public int Pick(int target) {\\n        int index = 0;\\n        int count = 0;\\n        for (int i = 0; i < _nums.Length; i++) {\\n            if (_nums[i] == target) {\\n                count += 1;\\n                double r = _rand.NextDouble();\\n                if (r < 1.0/count)\\n                    index = i;\\n            }\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 630322,
                "title": "java-solution-using-hashmap-short-and-easy-to-understand",
                "content": "```\\n    HashMap<Integer, List<Integer>> map = new HashMap();\\n    \\n    public Solution(int[] nums) {\\n        List<Integer> list;\\n        for(int i = 0; i<nums.length; i++){\\n            list = map.getOrDefault(nums[i], new ArrayList<Integer>());\\n            list.add(i);\\n            map.put(nums[i], list);\\n            list = null;\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        List<Integer> list = map.get(target);\\n        double ret = Double.valueOf(list.size()) * Math.random();\\n        return list.get((int) ret);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    HashMap<Integer, List<Integer>> map = new HashMap();\\n    \\n    public Solution(int[] nums) {\\n        List<Integer> list;\\n        for(int i = 0; i<nums.length; i++){\\n            list = map.getOrDefault(nums[i], new ArrayList<Integer>());\\n            list.add(i);\\n            map.put(nums[i], list);\\n            list = null;\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        List<Integer> list = map.get(target);\\n        double ret = Double.valueOf(list.size()) * Math.random();\\n        return list.get((int) ret);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 624893,
                "title": "ruby-solution-using-hash",
                "content": "```\\nclass Solution\\n\\n  attr_accessor :index_hash\\n  def initialize(nums)\\n    @index_hash = {}\\n    nums.each_with_index { |n,i|\\n      @index_hash[n] ||= []\\n      @index_hash[n] << i\\n    }\\n  end\\n\\n  def pick(target)\\n    indices = index_hash[target]\\n    indices.sample\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n\\n  attr_accessor :index_hash\\n  def initialize(nums)\\n    @index_hash = {}\\n    nums.each_with_index { |n,i|\\n      @index_hash[n] ||= []\\n      @index_hash[n] << i\\n    }\\n  end\\n\\n  def pick(target)\\n    indices = index_hash[target]\\n    indices.sample\\n  end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615808,
                "title": "java-simple-solution-space-beats-100",
                "content": "```\\nclass Solution {\\n    int[] nums;\\n    Random random;\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        this.random = new Random();\\n    }\\n    \\n    public int pick(int target) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == target)\\n                list.add(i);\\n        }\\n        return list.get(random.nextInt(list.size()));\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int[] nums;\\n    Random random;\\n    public Solution(int[] nums) {\\n        this.nums = nums;\\n        this.random = new Random();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 614413,
                "title": "c-concise-sampling-reservoir-approach-o-1-space-o-n-time",
                "content": "public class Solution {\\n\\n    int[] nums;\\n    Random r;\\n    \\n    public Solution(int[] nums) {        \\n        this.nums = nums;\\n        this.r = new Random();\\n    }\\n    \\n    public int Pick(int target) {        \\n        int count = 0;\\n        int pickedIndex = -1;\\n        \\n        for(int i = 0; i < nums.Length; i++){\\n            if(nums[i] == target && r.Next(++count) == 0)  pickedIndex = i;       \\n        }        \\n        return pickedIndex;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    int[] nums;\\n    Random r;\\n    \\n    public Solution(int[] nums) {        \\n        this.nums = nums;\\n        this.r = new Random();\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 604057,
                "title": "very-easy-ruby-solution",
                "content": "1.  Use a hash to store indices for each number\\n2.  Ruby makes it super easy so you can just use .sample to return a random ele from an array\\n\\n```\\nclass Solution\\n    \\n    def initialize(nums)\\n        @hash = {}\\n        nums.each.with_index do |num,i|\\n            if @hash[num]\\n                @hash[num] << i\\n            else\\n                @hash[num] = [i]\\n            end\\n        end\\n    end\\n\\n    def pick(target)\\n        array = @hash[target]\\n        array.sample\\n    end\\n\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\nclass Solution\\n    \\n    def initialize(nums)\\n        @hash = {}\\n        nums.each.with_index do |num,i|\\n            if @hash[num]\\n                @hash[num] << i\\n            else\\n                @hash[num] = [i]\\n            end\\n        end\\n    end\\n\\n    def pick(target)\\n        array = @hash[target]\\n        array.sample\\n    end\\n\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 583110,
                "title": "java-simple-intuitive-with-one-hashmap-low-efficient-but-easy-to-understand",
                "content": "```\\nclass Solution {\\n    private Map<Integer, List<Integer>> map;\\n\\n    public Solution(int[] nums) {\\n        map = new HashMap<Integer, List<Integer>>();\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(!map.containsKey(nums[i])){\\n                map.put(nums[i], new ArrayList<Integer>());\\n            }\\n            \\n            map.get(nums[i]).add(i);\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        int index = new Random().nextInt(map.get(target).size());\\n        return map.get(target).get(index);\\n    }\\n}\\n```\\n\\nRuntime: 72 ms, faster than 10.99% of Java online submissions for Random Pick Index.\\nMemory Usage: 53.1 MB, less than 82.35% of Java online submissions for Random Pick Index.\\n\\nThank @stfedosov\\n\\n```\\nclass Solution {\\n    private Map<Integer, List<Integer>> map;\\n\\n    public Solution(int[] nums) {\\n        map = new HashMap<Integer, List<Integer>>();\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            map.computeIfAbsent(nums[i], x -> new ArrayList<Integer>()).add(i);\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        int index = new Random().nextInt(map.get(target).size());\\n        return map.get(target).get(index);\\n    }\\n}\\n```\\nRuntime: 68 ms, faster than 25.32% of Java online submissions for Random Pick Index.\\nMemory Usage: 48.6 MB, less than 100.00% of Java online submissions for Random Pick Index.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private Map<Integer, List<Integer>> map;\\n\\n    public Solution(int[] nums) {\\n        map = new HashMap<Integer, List<Integer>>();\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(!map.containsKey(nums[i])){\\n                map.put(nums[i], new ArrayList<Integer>());\\n            }\\n            \\n            map.get(nums[i]).add(i);\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        int index = new Random().nextInt(map.get(target).size());\\n        return map.get(target).get(index);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private Map<Integer, List<Integer>> map;\\n\\n    public Solution(int[] nums) {\\n        map = new HashMap<Integer, List<Integer>>();\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            map.computeIfAbsent(nums[i], x -> new ArrayList<Integer>()).add(i);\\n        }\\n    }\\n    \\n    public int pick(int target) {\\n        int index = new Random().nextInt(map.get(target).size());\\n        return map.get(target).get(index);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581308,
                "title": "straighforward-python-reservoir-sampling-solution",
                "content": "Using the elogant Reservoir Sampling, we know we don\\'t need to know ahead of time how many `target`s exist in `nums` because of this we only need to store a single index, a target, and have the `nums` which could be stream or the entire array.\\n\\nhttps://www.youtube.com/watch?v=A1iwzSew5QY\\n\\n```python\\nfrom random import uniform\\n\\n\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        our_pick = -1\\n        prob = 1\\n        for i, num in enumerate(self.nums):\\n            if num == target:\\n                if uniform(0, 1) <= 1/prob:\\n                    our_pick = i\\n                prob += 1\\n        return our_pick\\n```\\n\\nSo we know the first time we find a target the probability to pick it is `1/1` or 100%, the next time we encounter a target the probability of sticking to our current pick is `1/2` and the next `1/3`,`1/4`,... and so on.\\nThis can be shown that each target we find has an equal likelihood.",
                "solutionTags": [],
                "code": "```python\\nfrom random import uniform\\n\\n\\nclass Solution:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def pick(self, target: int) -> int:\\n        our_pick = -1\\n        prob = 1\\n        for i, num in enumerate(self.nums):\\n            if num == target:\\n                if uniform(0, 1) <= 1/prob:\\n                    our_pick = i\\n                prob += 1\\n        return our_pick\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578609,
                "title": "java-reservoir-sampling-45-to-50-ms-runtime-and-100-memory-efficient",
                "content": "```\\n\\nclass Solution {\\n    private int[] array;\\n    private Random random;\\n    private int N;\\n    public Solution(int[] nums) {\\n        this.array = nums;\\n        this.random = new Random();\\n        this.N = this.array.length;\\n    }\\n    \\n    public int pick(int target) {\\n        int i;\\n        int result = -1;\\n        int count = 0;\\n        for(i = 0; i < N; i++){\\n            if(this.array[i] == target){\\n                ++count;\\n                if(this.random.nextInt(count) == 0){\\n                    result = i;\\n                } \\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int param_1 = obj.pick(target);\\n */\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    private int[] array;\\n    private Random random;\\n    private int N;\\n    public Solution(int[] nums) {\\n        this.array = nums;\\n        this.random = new Random();\\n        this.N = this.array.length;\\n    }\\n    \\n    public int pick(int target) {\\n        int i;\\n        int result = -1;\\n        int count = 0;\\n        for(i = 0; i < N; i++){\\n            if(this.array[i] == target){\\n                ++count;\\n                if(this.random.nextInt(count) == 0){\\n                    result = i;\\n                } \\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int param_1 = obj.pick(target);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536848,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>m;\\n    Solution(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]].push_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {         \\n        return m[target][rand() % m[target].size()];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>m;\\n    Solution(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]].push_back(i);\\n        }\\n    }\\n    \\n    int pick(int target) {         \\n        return m[target][rand() % m[target].size()];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 522459,
                "title": "java-reservoir-sampling-99-fast-and-100-memory-efficient",
                "content": "```\\n\\nclass Solution {\\n    private int N;\\n    private int[] A;\\n    private Random random;\\n    public Solution(int[] nums) {\\n        this.A = nums;\\n        this.N = nums.length;\\n        this.random = new Random();\\n    }\\n    \\n    public int pick(int target) {\\n        int i;\\n        int index = -1;\\n        int seenCount = 0;\\n        for(i = 0; i < this.N; i++){\\n            if(this.A[i] == target){\\n                ++seenCount;\\n                if(this.random.nextInt(seenCount) == 0){\\n                    index = i;\\n                }\\n            }\\n        }\\n        \\n        return index;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int param_1 = obj.pick(target);\\n */\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    private int N;\\n    private int[] A;\\n    private Random random;\\n    public Solution(int[] nums) {\\n        this.A = nums;\\n        this.N = nums.length;\\n        this.random = new Random();\\n    }\\n    \\n    public int pick(int target) {\\n        int i;\\n        int index = -1;\\n        int seenCount = 0;\\n        for(i = 0; i < this.N; i++){\\n            if(this.A[i] == target){\\n                ++seenCount;\\n                if(this.random.nextInt(seenCount) == 0){\\n                    index = i;\\n                }\\n            }\\n        }\\n        \\n        return index;\\n    }\\n}\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution obj = new Solution(nums);\\n * int param_1 = obj.pick(target);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 510956,
                "title": "no-fuss-simple-solution-with-hashmap-and-queue",
                "content": "```\\nclass Solution {\\n    Map<Integer, Queue<Integer>> map = new HashMap();\\n    \\n    public Solution(int[] nums) {\\n        for(int i = 0 ; i < nums.length; i++){\\n            if(!map.containsKey(nums[i])){\\n                map.put(nums[i], new LinkedList());\\n            }\\n            map.get(nums[i]).add(i);\\n        }    \\n    }\\n    \\n    public int pick(int target) {\\n        if(map.containsKey(target)){\\n            int ele = map.get(target).poll();\\n            map.get(target).add(ele);\\n            return ele;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Queue<Integer>> map = new HashMap();\\n    \\n    public Solution(int[] nums) {\\n        for(int i = 0 ; i < nums.length; i++){\\n            if(!map.containsKey(nums[i])){\\n                map.put(nums[i], new LinkedList());\\n            }\\n            map.get(nums[i]).add(i);\\n        }    \\n    }\\n    \\n    public int pick(int target) {\\n        if(map.containsKey(target)){\\n            int ele = map.get(target).poll();\\n            map.get(target).add(ele);\\n            return ele;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508419,
                "title": "c-reservoir-sampling-beats-94",
                "content": "```\\nclass Solution {\\npublic:\\n    vector <int> *pnums;\\n    Solution(vector<int>& nums) {\\n        pnums = &nums;\\n        srand (time (NULL));\\n    }\\n    \\n    int pick(int target) \\n    {\\n        int ret = -1; // target hasnt occurred.\\n        int n = 0;\\n        \\n        for (int i = 0; i < pnums->size (); i++)\\n        {\\n            // not target.\\n            if ((*pnums) [i] != target)\\n                continue;\\n            \\n            // target. have to decide if \\'i\\' can be ret or not.\\n            // the probability of i being ret should be 1 out of \\n            // number of times target has occurred in the array so far (n).\\n            // so (n-1) out of n times, indices < i are going to be selected,\\n            // thereby making every occurrence equally probably,\\n            // at each iteration.\\n\\n            /*// base case.\\n            if (n == 0)\\n            {\\n                ret = i;\\n                n = 1;\\n                continue;\\n            }\\n            \\n            // include current index in the search.\\n            n++;\\n            \\n            // 1 out of n times -> %n is 0.\\n            if (rand () % n == 0)\\n               ret = i; */\\n            \\n            // include current index in the search.\\n            n++;\\n            \\n            // 1 out of n times -> %n is 0.\\n            if (rand () % n == 0)\\n                ret = i;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <int> *pnums;\\n    Solution(vector<int>& nums) {\\n        pnums = &nums;\\n        srand (time (NULL));\\n    }\\n    \\n    int pick(int target) \\n    {\\n        int ret = -1; // target hasnt occurred.\\n        int n = 0;\\n        \\n        for (int i = 0; i < pnums->size (); i++)\\n        {\\n            // not target.\\n            if ((*pnums) [i] != target)\\n                continue;\\n            \\n            // target. have to decide if \\'i\\' can be ret or not.\\n            // the probability of i being ret should be 1 out of \\n            // number of times target has occurred in the array so far (n).\\n            // so (n-1) out of n times, indices < i are going to be selected,\\n            // thereby making every occurrence equally probably,\\n            // at each iteration.\\n\\n            /*// base case.\\n            if (n == 0)\\n            {\\n                ret = i;\\n                n = 1;\\n                continue;\\n            }\\n            \\n            // include current index in the search.\\n            n++;\\n            \\n            // 1 out of n times -> %n is 0.\\n            if (rand () % n == 0)\\n               ret = i; */\\n            \\n            // include current index in the search.\\n            n++;\\n            \\n            // 1 out of n times -> %n is 0.\\n            if (rand () % n == 0)\\n                ret = i;\\n        }\\n        \\n        return ret;\\n    }\\n};\\n\\n/**\\n * Your Solution object will be instantiated and called as such:\\n * Solution* obj = new Solution(nums);\\n * int param_1 = obj->pick(target);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 505822,
                "title": "java-solution-o-n-constructor-o-1-pick",
                "content": "```\\nclass Solution {\\n\\n    Map<Integer, List<Integer>> map; // number -> list of indexes.\\n    Random rand;\\n    \\n    public Solution(int[] nums) {\\n        map = new HashMap<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            if(!map.containsKey(num)) map.put(num, new ArrayList<>());\\n            map.get(num).add(i);\\n        }\\n        rand = new Random();\\n    }\\n    \\n    public int pick(int target) {\\n        List<Integer> list = map.get(target);\\n        int n = list.size();\\n        return list.get(rand.nextInt(n));\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    Map<Integer, List<Integer>> map; // number -> list of indexes.\\n    Random rand;\\n    \\n    public Solution(int[] nums) {\\n        map = new HashMap<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            int num = nums[i];\\n            if(!map.containsKey(num)) map.put(num, new ArrayList<>());\\n            map.get(num).add(i);\\n        }\\n        rand = new Random();\\n    }\\n    \\n    public int pick(int target) {\\n        List<Integer> list = map.get(target);\\n        int n = list.size();\\n        return list.get(rand.nextInt(n));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564748,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1565671,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1670970,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1968863,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 2067011,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1960948,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1934770,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1827740,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1806028,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1771412,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1564748,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1565671,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1670970,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1968863,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 2067011,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1960948,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1934770,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1827740,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1806028,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1771412,
                "content": [
                    {
                        "username": "SergeyTachenov",
                        "content": "Because I've made a rather naive map-of-index-lists Java solution and it was happily accepted by the OJ. So far I see three types of solutions:\\n\\n1. Like mine, O(N) memory, O(N) init, O(1) pick.\\n\\n2. Like @dettier's [Reservoir Sampling](https://discuss.leetcode.com/topic/58301/simple-reservoir-sampling-solution). O(1) init, O(1) memory, but O(N) to pick.\\n\\n3. Like @chin-heng's [binary search](https://discuss.leetcode.com/topic/58295/share-my-c-solution-o-lg-n-to-pick-o-nlg-n-for-sorting): O(N) memory, O(N lg N) init, O(lg N) pick.\\n\\nAre all three kinds acceptable?"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "naive gang"
                    },
                    {
                        "username": "BenjaminHolland",
                        "content": "The example implies that the list is sorted, which would change how the problem can be approached. Either it should be specified that it's sorted, or the example should be changed to show that the data is not sorted."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I mean, nowhere in the problem is it mentionned that the data is sorted. If you make unjustified assumption about the input, I don\\'t think leetcode is to blame for them.\\nYou could also say that the example implies that all data is between 1 and 3, it would be equally wrong"
                    },
                    {
                        "username": "acearth",
                        "content": "Even official solution of reservoir is TLE!  Could the official team modify the time limitation?\n\nUPDATE: solved by treating the problem input as sorted array.\n\nSee: https://leetcode.com/problems/random-pick-index/solutions/2778322/accepted-by-treating-array-as-sorted/"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "should be an easy question unless random library isn\\'t allowed IMO"
                    },
                    {
                        "username": "code__HARD",
                        "content": "Simple implementation question in python.  \nUsed two dictionaries one for storing all the indexes of occurrence's, \nand another for the last used index."
                    },
                    {
                        "username": "ChelsiGarg",
                        "content": "Why can't I use srand() function before rand() to have different indices for same n because rand() generates fixed numbers b/w 0 to n for given value of n.\n\nint pick(int target) {\n        int n=v.size();\n        // srand(time(0));\n        int i=rand()%n;\n        while(v[i]!=target)\n            i=rand()%n;\n        return i;\n    }"
                    },
                    {
                        "username": "krobzh",
                        "content": "This problem is to check skill in Reservoir Sampling. But it got TLE since every pick operation takes O(n). :|"
                    },
                    {
                        "username": "quizliu",
                        "content": "It\\'s interesting that the problem is mean to show you the resorvoir sampling which is difficult to think of, while this method has a `O(N)` time complexity for the pick function and gives TLE."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Reservoir sampling is relevant on a stream of data, but not really smart on offline data. \nReservoir sampling is genuinely a bad solution to the problem as stated, but you could easily imagine a follow up that requires you to use it"
                    },
                    {
                        "username": "pokaChika",
                        "content": "Deserves more upvotes! All the maang/faang companies look for the reserovir sampling approach in this question. Sad LC is rewarding TLEs all those answers."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            }
        ]
    },
    {
        "title": "Diagonal Traverse",
        "question_content": "<p>Given an <code>m x n</code> matrix <code>mat</code>, return <em>an array of all the elements of the array in a diagonal order</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg\" style=\"width: 334px; height: 334px;\" />\n<pre>\n<strong>Input:</strong> mat = [[1,2,3],[4,5,6],[7,8,9]]\n<strong>Output:</strong> [1,2,4,7,5,3,6,8,9]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> mat = [[1,2],[3,4]]\n<strong>Output:</strong> [1,2,3,4]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>1 &lt;= m * n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>5</sup> &lt;= mat[i][j] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 581868,
                "title": "easy-python-no-direction-checking",
                "content": "Hey guys, super easy solution here, with NO DIRECTION CHECKS!!!\\nThe key here is to realize that the sum of indices on all diagonals are equal.\\nFor example, in\\n```\\n[1,2,3]\\n[4,5,6]\\n[7,8,9]\\n```\\n2, 4 are on the same diagonal, and they share the index sum of 1. (2 is matrix[0][1] and 4 is in matrix[1][0]). 3,5,7 are on the same diagonal, and they share the sum of 2. (3 is matrix[0][2], 5 is matrix[1][1], and 7 is matrix [2][0]).\\n\\nSO, if you can loop through the matrix, store each element by the sum of its indices in a dictionary, you have a collection of all elements on shared diagonals. \\n\\nThe last part is easy, build your answer (a list) by elements on diagonals. To capture the \\'zig zag\\' or \\'snake\\' phenomena of this problem, simply reverse ever other diagonal level. So check if the level is divisible by 2. \\n\\n\\n```\\nclass Solution(object):\\n    def findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        d={}\\n\\t\\t#loop through matrix\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[i])):\\n\\t\\t\\t\\t#if no entry in dictionary for sum of indices aka the diagonal, create one\\n                if i + j not in d:\\n                    d[i+j] = [matrix[i][j]]\\n                else:\\n\\t\\t\\t\\t#If you\\'ve already passed over this diagonal, keep adding elements to it!\\n                    d[i+j].append(matrix[i][j])\\n\\t\\t# we\\'re done with the pass, let\\'s build our answer array\\n        ans= []\\n\\t\\t#look at the diagonal and each diagonal\\'s elements\\n        for entry in d.items():\\n\\t\\t\\t#each entry looks like (diagonal level (sum of indices), [elem1, elem2, elem3, ...])\\n\\t\\t\\t#snake time, look at the diagonal level\\n            if entry[0] % 2 == 0:\\n\\t\\t\\t\\t#Here we append in reverse order because its an even numbered level/diagonal. \\n                [ans.append(x) for x in entry[1][::-1]]\\n            else:\\n                [ans.append(x) for x in entry[1]]\\n        return ans\\n                \\n                ```\\n\\t\\t\\t\\t\\nso 2 key facts:\\n1. Diagonals are defined by the sum of indicies in a 2 dimensional array\\n2. The snake phenomena can be achieved by reversing every other diagonal level, therefore check if divisible by 2\\n\\nLet me know if you need further explanation",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n[1,2,3]\\n[4,5,6]\\n[7,8,9]\\n```\n```\\nclass Solution(object):\\n    def findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        d={}\\n\\t\\t#loop through matrix\\n        for i in range(len(matrix)):\\n            for j in range(len(matrix[i])):\\n\\t\\t\\t\\t#if no entry in dictionary for sum of indices aka the diagonal, create one\\n                if i + j not in d:\\n                    d[i+j] = [matrix[i][j]]\\n                else:\\n\\t\\t\\t\\t#If you\\'ve already passed over this diagonal, keep adding elements to it!\\n                    d[i+j].append(matrix[i][j])\\n\\t\\t# we\\'re done with the pass, let\\'s build our answer array\\n        ans= []\\n\\t\\t#look at the diagonal and each diagonal\\'s elements\\n        for entry in d.items():\\n\\t\\t\\t#each entry looks like (diagonal level (sum of indices), [elem1, elem2, elem3, ...])\\n\\t\\t\\t#snake time, look at the diagonal level\\n            if entry[0] % 2 == 0:\\n\\t\\t\\t\\t#Here we append in reverse order because its an even numbered level/diagonal. \\n                [ans.append(x) for x in entry[1][::-1]]\\n            else:\\n                [ans.append(x) for x in entry[1]]\\n        return ans\\n                \\n                ```",
                "codeTag": "Java"
            },
            {
                "id": 97711,
                "title": "java-15-lines-without-using-boolean",
                "content": "```\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if (matrix.length == 0) return new int[0];\\n        int r = 0, c = 0, m = matrix.length, n = matrix[0].length, arr[] = new int[m * n];\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = matrix[r][c];\\n            if ((r + c) % 2 == 0) { // moving up\\n                if      (c == n - 1) { r++; }\\n                else if (r == 0)     { c++; }\\n                else            { r--; c++; }\\n            } else {                // moving down\\n                if      (r == m - 1) { c++; }\\n                else if (c == 0)     { r++; }\\n                else            { r++; c--; }\\n            }   \\n        }   \\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if (matrix.length == 0) return new int[0];\\n        int r = 0, c = 0, m = matrix.length, n = matrix[0].length, arr[] = new int[m * n];\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = matrix[r][c];\\n            if ((r + c) % 2 == 0) { // moving up\\n                if      (c == n - 1) { r++; }\\n                else if (r == 0)     { c++; }\\n                else            { r--; c++; }\\n            } else {                // moving down\\n                if      (r == m - 1) { c++; }\\n                else if (c == 0)     { r++; }\\n                else            { r++; c--; }\\n            }   \\n        }   \\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 97712,
                "title": "concise-java-solution",
                "content": "I don't think this is a hard problem. It is easy to figure out the walk pattern. Anyway...\\nWalk patterns:\\n- If out of ```bottom border``` (row >= m) then row = m - 1; col += 2; change walk direction.\\n- if out of ```right border``` (col >= n) then col = n - 1; row += 2; change walk direction.\\n- if out of ```top border``` (row < 0)  then row = 0; change walk direction.\\n- if out of ```left border``` (col < 0)  then col = 0; change walk direction.\\n- Otherwise, just go along with the current direction.\\n\\nTime complexity: O(m * n), m = number of rows, n = number of columns.\\nSpace complexity: O(1).\\n\\n```\\npublic class Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0) return new int[0];\\n        int m = matrix.length, n = matrix[0].length;\\n        \\n        int[] result = new int[m * n];\\n        int row = 0, col = 0, d = 0;\\n        int[][] dirs = {{-1, 1}, {1, -1}};\\n        \\n        for (int i = 0; i < m * n; i++) {\\n            result[i] = matrix[row][col];\\n            row += dirs[d][0];\\n            col += dirs[d][1];\\n            \\n            if (row >= m) { row = m - 1; col += 2; d = 1 - d;}\\n            if (col >= n) { col = n - 1; row += 2; d = 1 - d;}\\n            if (row < 0)  { row = 0; d = 1 - d;}\\n            if (col < 0)  { col = 0; d = 1 - d;}\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```bottom border```\n```right border```\n```top border```\n```left border```\n```\\npublic class Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0) return new int[0];\\n        int m = matrix.length, n = matrix[0].length;\\n        \\n        int[] result = new int[m * n];\\n        int row = 0, col = 0, d = 0;\\n        int[][] dirs = {{-1, 1}, {1, -1}};\\n        \\n        for (int i = 0; i < m * n; i++) {\\n            result[i] = matrix[row][col];\\n            row += dirs[d][0];\\n            col += dirs[d][1];\\n            \\n            if (row >= m) { row = m - 1; col += 2; d = 1 - d;}\\n            if (col >= n) { col = n - 1; row += 2; d = 1 - d;}\\n            if (row < 0)  { row = 0; d = 1 - d;}\\n            if (col < 0)  { col = 0; d = 1 - d;}\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 136365,
                "title": "c-o-n-m-2-with-o-1-extra-memory-explained",
                "content": "Consider the indices of the diagonals of a NxM matrix. Let\\'s use a 4x4 matrix as an example:\\n\\n```\\n(0, 0) (0, 1) (0, 2) (0, 3)\\n(1, 0) (1, 1) (1, 2) (1, 3)\\n(2, 0) (2, 1) (2, 2) (2, 3)\\n(3, 0) (3, 1) (3, 2) (3, 3)\\n```\\n\\nThe first diagonal is `(0, 0)`. The second is `(0, 1), (1, 0)`, the third is `(2, 0), (1, 1), (0, 2)`, etc. \\n\\nIt should be clear that the sum of row `i` and column `j` is equal to the index of the diagonal (diagonal number - 1). e.g. for the second diagonal (index 1), all possible pairings of `(i, j)` sum to `1`, i.e. `i + j = 1` for the 2nd diagonal. The maximum diagonal index is simply `((N-1) + (M-1)) = N + M - 2`\\n\\nSo to solve the problem we simply need iterate through all possible diagonal indices (denote this as `s`) and find all possible pairs (i, j) such that `i + j = s`. The only thing we need to concern ourselves about is the order. We can find the ordering by looking at whether the diagonal index is even or odd. When the diagonal index is even we want to the first pair to be `(s, 0)` and when it is odd when want the first pair to be `(0, s)`, and we decrease or increase i/j by 1 accordingly.\\n\\n```\\nvector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        if(matrix.empty()) return {};\\n        \\n        const int N = matrix.size();\\n        const int M = matrix[0].size();\\n        \\n        vector<int> res;\\n        for(int s = 0; s <= N + M - 2; ++s)\\n        {\\n            // for all i + j = s\\n            for(int x = 0; x <= s; ++x) \\n            {\\n                int i = x;\\n                int j = s - i;\\n                if(s % 2 == 0) swap(i, j);\\n\\n                if(i >= N || j >= M) continue;\\n                \\n                res.push_back(matrix[i][j]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n(0, 0) (0, 1) (0, 2) (0, 3)\\n(1, 0) (1, 1) (1, 2) (1, 3)\\n(2, 0) (2, 1) (2, 2) (2, 3)\\n(3, 0) (3, 1) (3, 2) (3, 3)\\n```\n```\\nvector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        if(matrix.empty()) return {};\\n        \\n        const int N = matrix.size();\\n        const int M = matrix[0].size();\\n        \\n        vector<int> res;\\n        for(int s = 0; s <= N + M - 2; ++s)\\n        {\\n            // for all i + j = s\\n            for(int x = 0; x <= s; ++x) \\n            {\\n                int i = x;\\n                int j = s - i;\\n                if(s % 2 == 0) swap(i, j);\\n\\n                if(i >= N || j >= M) continue;\\n                \\n                res.push_back(matrix[i][j]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 203060,
                "title": "java-solution-with-clear-explanation",
                "content": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0){\\n            return new int[0];\\n        } \\n\\n        //Idea is the following\\n        //notice all values in the same diagonal share the same sum value of x index + y index\\n        //direction of going up right or going down left depends whether the index sum is even or odd\\n        //for each even or odd diagonal, there are three cases:\\n        // 1. there is room to go that direction \\n        // 2. there is no row space to go further but there is col space \\n        // 3. there is no col space to go further but there is row space\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        int[] res = new int[rows * cols];\\n        int r = 0;\\n        int c = 0;\\n        for (int i = 0; i < rows * cols; i++) {\\n          res[i] = matrix[r][c];\\n          // even sum diagonal\\n          if ((r + c) % 2 == 0) {\\n            if (r - 1 >= 0 && c + 1 < cols) {\\n              c = c + 1;\\n              r = r - 1;\\n            } else if (r - 1 < 0 && c + 1 < cols) {\\n              c = c + 1;\\n            } else if (r + 1 < rows && c + 1 > cols - 1) {\\n              r = r + 1;\\n            }\\n          }\\n          // odd sum diagonal\\n          else if ((r + c) % 2 != 0) {\\n            if (r + 1 < rows && c - 1 >= 0) {\\n              c = c - 1;\\n              r = r + 1;\\n            } else if (r + 1 < rows && c - 1 < 0) {\\n              r = r + 1;\\n            } else if (r + 1 > rows - 1 && c +1 < cols) {\\n              c = c + 1;\\n            }\\n          }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0){\\n            return new int[0];\\n        } \\n\\n        //Idea is the following\\n        //notice all values in the same diagonal share the same sum value of x index + y index\\n        //direction of going up right or going down left depends whether the index sum is even or odd\\n        //for each even or odd diagonal, there are three cases:\\n        // 1. there is room to go that direction \\n        // 2. there is no row space to go further but there is col space \\n        // 3. there is no col space to go further but there is row space\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        int[] res = new int[rows * cols];\\n        int r = 0;\\n        int c = 0;\\n        for (int i = 0; i < rows * cols; i++) {\\n          res[i] = matrix[r][c];\\n          // even sum diagonal\\n          if ((r + c) % 2 == 0) {\\n            if (r - 1 >= 0 && c + 1 < cols) {\\n              c = c + 1;\\n              r = r - 1;\\n            } else if (r - 1 < 0 && c + 1 < cols) {\\n              c = c + 1;\\n            } else if (r + 1 < rows && c + 1 > cols - 1) {\\n              r = r + 1;\\n            }\\n          }\\n          // odd sum diagonal\\n          else if ((r + c) % 2 != 0) {\\n            if (r + 1 < rows && c - 1 >= 0) {\\n              c = c - 1;\\n              r = r + 1;\\n            } else if (r + 1 < rows && c - 1 < 0) {\\n              r = r + 1;\\n            } else if (r + 1 > rows - 1 && c +1 < cols) {\\n              c = c + 1;\\n            }\\n          }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97767,
                "title": "simply-python-solution",
                "content": "Simple two step approach:\\n1- Group numbers according to diagonals. Sum of row+col in same diagonal is same.\\n2- Reverse numbers in odd diagonals before adding numbers to result list.\\n\\n```\\nclass Solution(object):\\n    def findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        result = [ ]\\n        dd = collections.defaultdict(list)\\n        if not matrix: return result\\n        # Step 1: Numbers are grouped by the diagonals.\\n        # Numbers in same diagonal have same value of row+col\\n        for i in range(0, len(matrix)):\\n            for j in range(0, len(matrix[0])):\\n                dd[i+j+1].append(matrix[i][j]) # starting indices from 1, hence i+j+1.\\n        # Step 2: Place diagonals in the result list.\\n        # But remember to reverse numbers in odd diagonals.\\n        for k in sorted(dd.keys()):\\n            if k%2==1: dd[k].reverse()\\n            result += dd[k]\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        result = [ ]\\n        dd = collections.defaultdict(list)\\n        if not matrix: return result\\n        # Step 1: Numbers are grouped by the diagonals.\\n        # Numbers in same diagonal have same value of row+col\\n        for i in range(0, len(matrix)):\\n            for j in range(0, len(matrix[0])):\\n                dd[i+j+1].append(matrix[i][j]) # starting indices from 1, hence i+j+1.\\n        # Step 2: Place diagonals in the result list.\\n        # But remember to reverse numbers in odd diagonals.\\n        for k in sorted(dd.keys()):\\n            if k%2==1: dd[k].reverse()\\n            result += dd[k]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97733,
                "title": "c-without-paying-too-much-attention-on-direction-switch",
                "content": "Put all diagonal sequences from top-right to bottom-left to an array and then combine all sequence together by reversing odd sequences.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        if (m == 0) return vector<int>();\\n        int n = matrix[0].size();\\n        vector<vector<int>> tmp (m+n-1);\\n        for (int i = 0; i < m+n-1 ; i++) {\\n            int row = max(0, i-n+1);\\n            int col = min(i, n-1);\\n            for (; col >= 0 && row < m; row++, col--) {\\n                tmp[i].push_back(matrix[row][col]);\\n            }\\n        }\\n        vector<int> res;\\n        for (int i = 0; i< tmp.size(); i++) {\\n            if (i % 2) res.insert(res.end(), tmp[i].begin(), tmp[i].end());\\n            else res.insert(res.end(), tmp[i].rbegin(), tmp[i].rend());\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        int m = matrix.size();\\n        if (m == 0) return vector<int>();\\n        int n = matrix[0].size();\\n        vector<vector<int>> tmp (m+n-1);\\n        for (int i = 0; i < m+n-1 ; i++) {\\n            int row = max(0, i-n+1);\\n            int col = min(i, n-1);\\n            for (; col >= 0 && row < m; row++, col--) {\\n                tmp[i].push_back(matrix[row][col]);\\n            }\\n        }\\n        vector<int> res;\\n        for (int i = 0; i< tmp.size(); i++) {\\n            if (i % 2) res.insert(res.end(), tmp[i].begin(), tmp[i].end());\\n            else res.insert(res.end(), tmp[i].rbegin(), tmp[i].rend());\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517538,
                "title": "java-tc-o-m-n-sc-o-1-concise-one-pass-solution",
                "content": "```java\\n/**\\n * Simulate Diagonal Order Traversal\\n *\\n * r+c determines which diagonal you are on. For ex: [2,0],[1,1],[0,2] are all\\n * on same diagonal with r+c =2. If you check the directions of diagonals, first\\n * diagonal is up, second diagonal is down, third one is up and so on..\\n * Therefore (r+c)%2 simply determines direction. Even is UP direction. Odd is\\n * DOWN direction.\\n *\\n * Time Complexity: O(M*N)\\n *\\n * Space Complexity: O(1) without considering result space.\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input matrix is null\");\\n        }\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return new int[0];\\n        }\\n\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        int[] result = new int[rows * cols];\\n        int r = 0;\\n        int c = 0;\\n\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = matrix[r][c];\\n            if ((r + c) % 2 == 0) { // Move Up\\n                if (c == cols - 1) {\\n                    // Reached last column. Now move to below cell in the same column.\\n                    // This condition needs to be checked first due to top right corner cell.\\n                    r++;\\n                } else if (r == 0) {\\n                    // Reached first row. Now move to next cell in the same row.\\n                    c++;\\n                } else {\\n                    // Somewhere in middle. Keep going up diagonally.\\n                    r--;\\n                    c++;\\n                }\\n            } else { // Move Down\\n                if (r == rows - 1) {\\n                    // Reached last row. Now move to next cell in same row.\\n                    // This condition needs to be checked first due to bottom left corner cell.\\n                    c++;\\n                } else if (c == 0) {\\n                    // Reached first columns. Now move to below cell in the same column.\\n                    r++;\\n                } else {\\n                    // Somewhere in middle. Keep going down diagonally.\\n                    r++;\\n                    c--;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```java\\n/**\\n * Simulate Diagonal Order Traversal\\n *\\n * r+c determines which diagonal you are on. For ex: [2,0],[1,1],[0,2] are all\\n * on same diagonal with r+c =2. If you check the directions of diagonals, first\\n * diagonal is up, second diagonal is down, third one is up and so on..\\n * Therefore (r+c)%2 simply determines direction. Even is UP direction. Odd is\\n * DOWN direction.\\n *\\n * Time Complexity: O(M*N)\\n *\\n * Space Complexity: O(1) without considering result space.\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if (matrix == null) {\\n            throw new IllegalArgumentException(\"Input matrix is null\");\\n        }\\n        if (matrix.length == 0 || matrix[0].length == 0) {\\n            return new int[0];\\n        }\\n\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        int[] result = new int[rows * cols];\\n        int r = 0;\\n        int c = 0;\\n\\n        for (int i = 0; i < result.length; i++) {\\n            result[i] = matrix[r][c];\\n            if ((r + c) % 2 == 0) { // Move Up\\n                if (c == cols - 1) {\\n                    // Reached last column. Now move to below cell in the same column.\\n                    // This condition needs to be checked first due to top right corner cell.\\n                    r++;\\n                } else if (r == 0) {\\n                    // Reached first row. Now move to next cell in the same row.\\n                    c++;\\n                } else {\\n                    // Somewhere in middle. Keep going up diagonally.\\n                    r--;\\n                    c++;\\n                }\\n            } else { // Move Down\\n                if (r == rows - 1) {\\n                    // Reached last row. Now move to next cell in same row.\\n                    // This condition needs to be checked first due to bottom left corner cell.\\n                    c++;\\n                } else if (c == 0) {\\n                    // Reached first columns. Now move to below cell in the same column.\\n                    r++;\\n                } else {\\n                    // Somewhere in middle. Keep going down diagonally.\\n                    r++;\\n                    c--;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 159033,
                "title": "o-n-java-solution-with-simple-logic",
                "content": "The basic idea here is that while changing the direction \\nfrom moving up to moving down, the element on the right is always the first to traverse, whereas \\nfrom moving down to moving up, the element below the current one is always the first to traverse.\\n\\n```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if(matrix.length == 0) return new int[0];\\n        \\n        int rows = matrix.length;\\n        int columns = matrix[0].length;\\n        int[] nums = new int[rows * columns];\\n        \\n        int currentRow = 0;\\n        int currentColumn = 0;\\n        boolean goUp = true;\\n        \\n        \\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            if(goUp) // moving up\\n            {\\n                nums[i] = matrix[currentRow--][currentColumn++];\\n                \\n                // exceed the boundary\\n                if(!(currentRow >= 0 && currentColumn <= columns - 1))\\n                {\\n                    // return to the previous valid position\\n                    currentRow++;\\n                    currentColumn--;\\n                    \\n                    // Going to the element right to it(same row, next column) is always preferable\\n                    // while changing the direction from moving up to moving down \\n                    // unless the next column is invalid \\n                    if(currentColumn < columns - 1) currentColumn++;\\n                    else currentRow++;\\n                    \\n                    // will move down for next iteration  \\n                    goUp = false;\\n                }     \\n            }\\n            else // moving down\\n            {\\n                nums[i] = matrix[currentRow++][currentColumn--];\\n                \\n                // exceed the boundary\\n                if(!(currentRow <= rows - 1 && currentColumn >= 0))\\n                {\\n                    // return to the previous valid position\\n                    currentRow--;\\n                    currentColumn++;\\n                    \\n                    // Going to the element below it(same column, next row) is always preferable\\n                    // while changing the direction from moving down to moving up \\n                    // unless the next row is invalid \\n                    if(currentRow < rows - 1) currentRow++;\\n                    else currentColumn++;\\n                    \\n                    // will move up for next iteration  \\n                    goUp = true;\\n                }       \\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if(matrix.length == 0) return new int[0];\\n        \\n        int rows = matrix.length;\\n        int columns = matrix[0].length;\\n        int[] nums = new int[rows * columns];\\n        \\n        int currentRow = 0;\\n        int currentColumn = 0;\\n        boolean goUp = true;\\n        \\n        \\n        for(int i = 0; i < nums.length; i++)\\n        {\\n            if(goUp) // moving up\\n            {\\n                nums[i] = matrix[currentRow--][currentColumn++];\\n                \\n                // exceed the boundary\\n                if(!(currentRow >= 0 && currentColumn <= columns - 1))\\n                {\\n                    // return to the previous valid position\\n                    currentRow++;\\n                    currentColumn--;\\n                    \\n                    // Going to the element right to it(same row, next column) is always preferable\\n                    // while changing the direction from moving up to moving down \\n                    // unless the next column is invalid \\n                    if(currentColumn < columns - 1) currentColumn++;\\n                    else currentRow++;\\n                    \\n                    // will move down for next iteration  \\n                    goUp = false;\\n                }     \\n            }\\n            else // moving down\\n            {\\n                nums[i] = matrix[currentRow++][currentColumn--];\\n                \\n                // exceed the boundary\\n                if(!(currentRow <= rows - 1 && currentColumn >= 0))\\n                {\\n                    // return to the previous valid position\\n                    currentRow--;\\n                    currentColumn++;\\n                    \\n                    // Going to the element below it(same column, next row) is always preferable\\n                    // while changing the direction from moving down to moving up \\n                    // unless the next row is invalid \\n                    if(currentRow < rows - 1) currentRow++;\\n                    else currentColumn++;\\n                    \\n                    // will move up for next iteration  \\n                    goUp = true;\\n                }       \\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97719,
                "title": "sorting-and-normal-python",
                "content": "**Solution 1**, annotate the matrix entries with coordinate information so that we can just sort them by that.\\n\\n    def findDiagonalOrder(self, matrix):\\n        entries = [(i+j, (j, i)[(i^j)&1], val)\\n                   for i, row in enumerate(matrix)\\n                   for j, val in enumerate(row)]\\n        return [e[2] for e in sorted(entries)]\\n\\nI just saw that @\\\\_aig_ does it very similarly, [but sorting coordinates](https://discuss.leetcode.com/topic/77889/3-line-python-solution). Not sure what I like better.\\n\\n**Solution 2**, just walk over the matrix in the desired order. My `d` is the diagonal number, i.e., `i+j`. So I can compute `j` as `d-i`.\\n\\n    def findDiagonalOrder(self, matrix):\\n        m, n = len(matrix), len(matrix and matrix[0])\\n        return [matrix[i][d-i]\\n                for d in range(m+n-1)\\n                for i in range(max(0, d-n+1), min(d+1, m))[::d%2*2-1]]\\n\\nWhy the range `range(max(0, d-n+1), min(d+1, m))`? Well I need `0 <= i < m` and `0 <= j < n`. As said above, `j` is `d-i`, so I have `0 <= d-i < n`. Isolating `i` gives me `i <= d` and `i > d-n`. Since we're dealing with integers, they're equivalent to `i < d+1` and `i >= d-n+1`. So my `i` needs to be in the range [0, m) as well as in the range [d-n+1, d+1). And my range is simply the intersection of those two ranges.",
                "solutionTags": [],
                "code": "**Solution 1**, annotate the matrix entries with coordinate information so that we can just sort them by that.\\n\\n    def findDiagonalOrder(self, matrix):\\n        entries = [(i+j, (j, i)[(i^j)&1], val)\\n                   for i, row in enumerate(matrix)\\n                   for j, val in enumerate(row)]\\n        return [e[2] for e in sorted(entries)]\\n\\nI just saw that @\\\\_aig_ does it very similarly, [but sorting coordinates](https://discuss.leetcode.com/topic/77889/3-line-python-solution). Not sure what I like better.\\n\\n**Solution 2**, just walk over the matrix in the desired order. My `d` is the diagonal number, i.e., `i+j`. So I can compute `j` as `d-i`.\\n\\n    def findDiagonalOrder(self, matrix):\\n        m, n = len(matrix), len(matrix and matrix[0])\\n        return [matrix[i][d-i]\\n                for d in range(m+n-1)\\n                for i in range(max(0, d-n+1), min(d+1, m))[::d%2*2-1]]\\n\\nWhy the range `range(max(0, d-n+1), min(d+1, m))`? Well I need `0 <= i < m` and `0 <= j < n`. As said above, `j` is `d-i`, so I have `0 <= d-i < n`. Isolating `i` gives me `i <= d` and `i > d-n`. Since we're dealing with integers, they're equivalent to `i < d+1` and `i >= d-n+1`. So my `i` needs to be in the range [0, m) as well as in the range [d-n+1, d+1). And my range is simply the intersection of those two ranges.",
                "codeTag": "Python3"
            },
            {
                "id": 1092834,
                "title": "beautiful-10-line-c-solution",
                "content": "```\\nvector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        \\n        vector<int> res;\\n        map<int, vector<int>> mp;\\n        \\n        for(int i = 0 ; i < matrix.size() ; i++) \\n            for(int j = 0 ; j < matrix[0].size() ; j++)\\n                mp[i + j].push_back(matrix[i][j]);\\n        \\n        for(auto i : mp) {\\n            if((i.first)%2 == 0) \\n                reverse(i.second.begin(), i.second.end()); \\n            \\n            for(auto k : i.second) res.push_back(k);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        \\n        vector<int> res;\\n        map<int, vector<int>> mp;\\n        \\n        for(int i = 0 ; i < matrix.size() ; i++) \\n            for(int j = 0 ; j < matrix[0].size() ; j++)\\n                mp[i + j].push_back(matrix[i][j]);\\n        \\n        for(auto i : mp) {\\n            if((i.first)%2 == 0) \\n                reverse(i.second.begin(), i.second.end()); \\n            \\n            for(auto k : i.second) res.push_back(k);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 985799,
                "title": "c-simple-easy-to-understand-one-pass-solution-100-time-and-100-space",
                "content": "This solution is a simple one pass solution which traverses the matrix moving in the up-right direction until hitting the top and/or right end of the matrix. After hitting the end, we switch direction to move down-left until we hit the bottom and/or left end of the matrix. We switch direction again to move up-right again and doing this until we reach the final bottom right element in the matrix.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        // manage base case of when matrix is empty\\n        if (matrix.size() == 0) return {};\\n        \\n        // variables for storing the last index for rows and columns\\n        int iIndex = matrix.size(), jIndex = matrix[0].size();\\n        // variables for storing the current index while traversing the matrix\\n        int i = 0, j = 0;\\n        // variable to check which direction we are moving\\n        bool isMovingUpRight = true;\\n        // variable for keep track of which elements in the result vector are populated\\n        int count = 1;\\n        // declare vector we will return at the end\\n        vector<int> result(iIndex * jIndex);\\n        \\n        // assign the first element in the result vector\\n        result[0] = matrix[i][j];\\n        \\n        // while we have not reach the end of the row and column (last index for both row and column)\\n        while (i != iIndex - 1 || j != jIndex - 1) {\\n            if (isMovingUpRight) { // if we are moving in the up-right direction...\\n                if (j == jIndex - 1) { // ...and we have hit the right end of the matrix, we will move down one position and switch direction\\n                    i++;\\n                    isMovingUpRight = false;\\n                } else if (i == 0) { // ...and we have hit the top the matrix, we will move right one position and switch direction\\n                    j++;\\n                    isMovingUpRight = false;\\n                } else { // ...else we have not hit the end of either side so we will move up and right one position\\n                    i--;\\n                    j++;\\n                }\\n            } else { // else we are moving in the bottom-left direction...\\n                if (i == iIndex - 1) { // ...and we have hit the bottom of the matrix, we will move right one position and switch direction\\n                    j++;\\n                    isMovingUpRight = true;\\n                } else if (j == 0) { // ...and we have hit the left end of the matrix, we will move down and switch direction\\n                    i++;\\n                    isMovingUpRight = true;\\n                } else { // ...else we have not hit the end of either side so we will move down and left one position\\n                    i++;\\n                    j--;\\n                }\\n            }\\n            \\n            result[count++] = matrix[i][j]; // after moving, we will assign the current element into the result vector\\n        }\\n        \\n        return result; // return final result after traversing the matrix\\n    }\\n};\\n```\\n\\nEdit: Thanks to [@Ajna](https://leetcode.com/Ajna)  for improving my solution which is now consuming less memory by declaring the vector with the size required to prevent any reallocations.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        // manage base case of when matrix is empty\\n        if (matrix.size() == 0) return {};\\n        \\n        // variables for storing the last index for rows and columns\\n        int iIndex = matrix.size(), jIndex = matrix[0].size();\\n        // variables for storing the current index while traversing the matrix\\n        int i = 0, j = 0;\\n        // variable to check which direction we are moving\\n        bool isMovingUpRight = true;\\n        // variable for keep track of which elements in the result vector are populated\\n        int count = 1;\\n        // declare vector we will return at the end\\n        vector<int> result(iIndex * jIndex);\\n        \\n        // assign the first element in the result vector\\n        result[0] = matrix[i][j];\\n        \\n        // while we have not reach the end of the row and column (last index for both row and column)\\n        while (i != iIndex - 1 || j != jIndex - 1) {\\n            if (isMovingUpRight) { // if we are moving in the up-right direction...\\n                if (j == jIndex - 1) { // ...and we have hit the right end of the matrix, we will move down one position and switch direction\\n                    i++;\\n                    isMovingUpRight = false;\\n                } else if (i == 0) { // ...and we have hit the top the matrix, we will move right one position and switch direction\\n                    j++;\\n                    isMovingUpRight = false;\\n                } else { // ...else we have not hit the end of either side so we will move up and right one position\\n                    i--;\\n                    j++;\\n                }\\n            } else { // else we are moving in the bottom-left direction...\\n                if (i == iIndex - 1) { // ...and we have hit the bottom of the matrix, we will move right one position and switch direction\\n                    j++;\\n                    isMovingUpRight = true;\\n                } else if (j == 0) { // ...and we have hit the left end of the matrix, we will move down and switch direction\\n                    i++;\\n                    isMovingUpRight = true;\\n                } else { // ...else we have not hit the end of either side so we will move down and left one position\\n                    i++;\\n                    j--;\\n                }\\n            }\\n            \\n            result[count++] = matrix[i][j]; // after moving, we will assign the current element into the result vector\\n        }\\n        \\n        return result; // return final result after traversing the matrix\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 153212,
                "title": "my-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(matrix)==0 or len(matrix[0])==0:\\n            return []\\n        m,n=len(matrix),len(matrix[0])\\n        \\n        r,c=0,0\\n        res=list()\\n        for i in range(m*n):\\n            res.append(matrix[r][c])\\n            if (r+c)%2==0:\\n                #going up\\n                if c==n-1:\\n                    r+=1\\n                elif r==0:\\n                    c+=1\\n                else:\\n                    r-=1\\n                    c+=1\\n            else:\\n                #going down\\n                if r==m-1:\\n                    c+=1\\n                \\n                elif c==0:\\n                    r+=1    \\n                else:\\n                    r+=1\\n                    c-=1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(matrix)==0 or len(matrix[0])==0:\\n            return []\\n        m,n=len(matrix),len(matrix[0])\\n        \\n        r,c=0,0\\n        res=list()\\n        for i in range(m*n):\\n            res.append(matrix[r][c])\\n            if (r+c)%2==0:\\n                #going up\\n                if c==n-1:\\n                    r+=1\\n                elif r==0:\\n                    c+=1\\n                else:\\n                    r-=1\\n                    c+=1\\n            else:\\n                #going down\\n                if r==m-1:\\n                    c+=1\\n                \\n                elif c==0:\\n                    r+=1    \\n                else:\\n                    r+=1\\n                    c-=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162316,
                "title": "reference-binding-to-null-pointer-of-type-struct-value-type",
                "content": "Why it appears \\'reference binding to null pointer of type \\'struct value_type\\' when the input is an empty matrix?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 97779,
                "title": "python-solution-with-detailed-explanation-deque",
                "content": "**Solution**\\n\\n**Diagonal Traverse** https://leetcode.com/problems/diagonal-traverse/?tab=Description\\n\\n**Deque & Dictionary - O(MN)**\\n* Property for the diagonals is that: row + col = constant. This constant varies from 0 to M+N-2.\\n* The direction of the diagonal is top to bottom or bottom to top. The direction depends if constant is even or odd.\\n* Iterate the matrix. Maintain a dictionary with key as integer and value as a deque. \\n* The key will be row+col and deque will have all elements which have the same row +col. Depending whether row+col is even or odd, we will either append or appendleft.\\n\\n```\\nfrom collections import deque, defaultdict\\nclass Solution(object):\\n    def findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        if matrix == []:\\n            return []\\n        M, N = len(matrix), len(matrix[0])\\n        result = defaultdict(deque)\\n        max_sum, top_down = M+N-2, True\\n        for i in range(M):\\n            for j in range(N):\\n                s = i+j\\n                if s&1:\\n                    result[s].append(matrix[i][j])\\n                else:\\n                    result[s].appendleft(matrix[i][j])\\n        output = []\\n        for s in range(max_sum+1):\\n            output.extend(result[s])\\n        return output\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque, defaultdict\\nclass Solution(object):\\n    def findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        if matrix == []:\\n            return []\\n        M, N = len(matrix), len(matrix[0])\\n        result = defaultdict(deque)\\n        max_sum, top_down = M+N-2, True\\n        for i in range(M):\\n            for j in range(N):\\n                s = i+j\\n                if s&1:\\n                    result[s].append(matrix[i][j])\\n                else:\\n                    result[s].appendleft(matrix[i][j])\\n        output = []\\n        for s in range(max_sum+1):\\n            output.extend(result[s])\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177945,
                "title": "java-picture-included-hashmap-solution-one-pass",
                "content": "![image](https://assets.leetcode.com/users/images/61c876c4-190c-490b-98bf-8f87fbbe80b2_1619462851.4074552.png)\\n```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] nums) {\\n        if(nums==null || nums.length==0) return null;\\n        \\n        HashMap<Integer,ArrayList<Integer>> map=new HashMap<>();\\n        int count=nums.length*nums[0].length;\\n        \\n        for(int i=nums.length-1;i>=0;i--){\\n            for(int j=0;j<nums[i].length;j++){\\n                if(!map.containsKey(i+j)){\\n                    map.put(i+j,new ArrayList<Integer>());\\n                }\\n                map.get(i+j).add(nums[i][j]);\\n            }\\n        }\\n        \\n        int size=map.size();\\n        int mapIndex=0;\\n        int arrIndex=0;\\n        \\n        int arr[]=new int[count];\\n        \\n        while(mapIndex<size){\\n            if(mapIndex%2==0){\\n                for(int i:map.get(mapIndex)){\\n                    arr[arrIndex++]=i;\\n                }\\n                mapIndex++;\\n            }else{\\n                for(int i=map.get(mapIndex).size()-1;i>=0;i--){\\n                    arr[arrIndex++]=map.get(mapIndex).get(i);\\n                }\\n                mapIndex++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] nums) {\\n        if(nums==null || nums.length==0) return null;\\n        \\n        HashMap<Integer,ArrayList<Integer>> map=new HashMap<>();\\n        int count=nums.length*nums[0].length;\\n        \\n        for(int i=nums.length-1;i>=0;i--){\\n            for(int j=0;j<nums[i].length;j++){\\n                if(!map.containsKey(i+j)){\\n                    map.put(i+j,new ArrayList<Integer>());\\n                }\\n                map.get(i+j).add(nums[i][j]);\\n            }\\n        }\\n        \\n        int size=map.size();\\n        int mapIndex=0;\\n        int arrIndex=0;\\n        \\n        int arr[]=new int[count];\\n        \\n        while(mapIndex<size){\\n            if(mapIndex%2==0){\\n                for(int i:map.get(mapIndex)){\\n                    arr[arrIndex++]=i;\\n                }\\n                mapIndex++;\\n            }else{\\n                for(int i=map.get(mapIndex).size()-1;i>=0;i--){\\n                    arr[arrIndex++]=map.get(mapIndex).get(i);\\n                }\\n                mapIndex++;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 985751,
                "title": "python-short-solution-using-defaultdict-explained",
                "content": "Main trick to solve this problem easily is to understand the structure of our diagonal traverse. Let us call level each diagonal we traverse: \\n1. In first level we have only one coordinates: `[0, 0]`.\\n2. In second level we have two points: `[0, 1]` and `[1, 0]`.\\n3. In third level we have three points: `[0, 2]`, `[1, 1]` and `[2, 0]`.\\n\\nNow, aogorithm becomes very easy:\\n1. For each level put all elements in this level to dictionary `levels`: note, that for each level we put it in direct order.\\n2. Now, for each level choose if we traverse it in direct order or reverse, using `[::lev%2*2-1]` notation. If `lev` is odd number, then we have `[::1]`, that is direct order, if `lev` is even, we have `[::-1]`, that is reverse order.\\n\\n**Complexity**: time complexity is `O(mn)`: we traverse each element once. Additional space complexity in this approach is also `O(mn)`, because we keep `levels` dictionary. Theoretically, we can put our data directly into long list and then reverse some parts, we will have `O(1)` additional space in this case.\\n\\n```\\nclass Solution:\\n    def findDiagonalOrder(self, matrix):\\n        if not matrix: return []\\n        m, n = len(matrix), len(matrix[0])\\n        levels = defaultdict(list)\\n        for i, j in product(range(m), range(n)):\\n            levels[i+j].append(matrix[i][j])\\n                \\n        out = []\\n        for lev in range(m + n):\\n            out += levels[lev][::lev%2*2-1]   \\n        return out\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDiagonalOrder(self, matrix):\\n        if not matrix: return []\\n        m, n = len(matrix), len(matrix[0])\\n        levels = defaultdict(list)\\n        for i, j in product(range(m), range(n)):\\n            levels[i+j].append(matrix[i][j])\\n                \\n        out = []\\n        for lev in range(m + n):\\n            out += levels[lev][::lev%2*2-1]   \\n        return out\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244530,
                "title": "easy-to-understand-python",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        R, C = len(mat), len(mat[0])\\n        diagonalDict = defaultdict(list)\\n\\t\\t# key - diagonal elements have the same r + c value.\\n        for r in range(R):\\n            for c in range(C):\\n                diagonalDict[r+c].append(mat[r][c])\\n        ans = []\\n        for i, value in enumerate(diagonalDict.values()):\\n            if i % 2 == 0:\\n                ans += value[::-1]\\n            else:\\n                ans += value\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        R, C = len(mat), len(mat[0])\\n        diagonalDict = defaultdict(list)\\n\\t\\t# key - diagonal elements have the same r + c value.\\n        for r in range(R):\\n            for c in range(C):\\n                diagonalDict[r+c].append(mat[r][c])\\n        ans = []\\n        for i, value in enumerate(diagonalDict.values()):\\n            if i % 2 == 0:\\n                ans += value[::-1]\\n            else:\\n                ans += value\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580783,
                "title": "simple-javascript",
                "content": "Explanation\\n1. We\\'re given a matrix, we need to diagonally traverse the matrix and return the result\\n\\n2. We create an empty matrix of same size as the given matrix but in this matrix we will\\n   fill the values according to the desired result and atlast we will use Javascript pre build\\n   function flat() which flatten multi-dimentional array into single array.\\n3. We\\'ll be required two for loops to loop through the given matrix as obvious.\\n4. The \"if\" condition states that if (rowIndex + colIndex) % 2 === 0, i.e, if we we will push\\nthe               element which is at (rowIndex, colIndex) to the position [rowIndex + colIndex], to the starting of the matrix.\\nWHY ?\\nNotice that whenever we\\'re at even position we are moving in downwards direction\\nin the matrix and whenever we are at odd position we are moving upwards in the matrix\\n\\n\\n\\n\\n```\\nvar findDiagonalOrder = function(mat) {\\n    let rows = mat.length;\\n    let cols = mat[0].length;\\n    let result = new Array(rows + cols - 1).fill(null).map(() => []);\\n\\n    for(let row = 0; row < rows; row++) {\\n        for(let col = 0; col < cols; col++) {\\n            if((row + col) % 2 === 0) result[row + col].unshift(mat[row][col]);\\n            else result[row + col].push(mat[row][col]);   \\n        }\\n    }\\n    return result.flat();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findDiagonalOrder = function(mat) {\\n    let rows = mat.length;\\n    let cols = mat[0].length;\\n    let result = new Array(rows + cols - 1).fill(null).map(() => []);\\n\\n    for(let row = 0; row < rows; row++) {\\n        for(let col = 0; col < cols; col++) {\\n            if((row + col) % 2 === 0) result[row + col].unshift(mat[row][col]);\\n            else result[row + col].push(mat[row][col]);   \\n        }\\n    }\\n    return result.flat();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1391037,
                "title": "simple-readable-and-interview-friendly-o-n-m-time-o-1-space-and-fast",
                "content": "I wasn\\'t satisfied with the official simulation solution, so I made it cleaner.\\n\\nIf we know the starting and ending cells of a diagonal, then we can easily traverse it, so I made this process into a function. We also need to keep track of whether we\\'re traversing top-right or bottom-left, and accordingly set the starting and ending cells in the `addDiagonal` function call.\\n\\nThe only tricky part is updating the boundaries after we\\'ve added a diagonal, but I think the code is self-explanatory. \\n```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        def addDiagonal(start_row, start_col, end_row, end_col, inc):\\n            row, col = start_row, start_col\\n            \\n            while (row, col) != (end_row, end_col):\\n                res.append(mat[row][col])\\n                row -= inc\\n                col += inc\\n            \\n            res.append(mat[row][col])\\n        \\n        \\n        M, N = len(mat), len(mat[0])\\n        res = []\\n        go_top_right = True\\n        right = left = top = bottom = 0\\n        \\n        while len(res) < N * M:\\n            if go_top_right:\\n                addDiagonal(bottom, left, top, right, 1)\\n            else:\\n                addDiagonal(top, right, bottom, left, -1)\\n            \\n            if right + 1 < N:\\n                right += 1\\n            else:\\n                top += 1\\n            if bottom + 1 < M:\\n                bottom += 1\\n            else:\\n                left += 1\\n            \\n            go_top_right = not go_top_right\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        def addDiagonal(start_row, start_col, end_row, end_col, inc):\\n            row, col = start_row, start_col\\n            \\n            while (row, col) != (end_row, end_col):\\n                res.append(mat[row][col])\\n                row -= inc\\n                col += inc\\n            \\n            res.append(mat[row][col])\\n        \\n        \\n        M, N = len(mat), len(mat[0])\\n        res = []\\n        go_top_right = True\\n        right = left = top = bottom = 0\\n        \\n        while len(res) < N * M:\\n            if go_top_right:\\n                addDiagonal(bottom, left, top, right, 1)\\n            else:\\n                addDiagonal(top, right, bottom, left, -1)\\n            \\n            if right + 1 < N:\\n                right += 1\\n            else:\\n                top += 1\\n            if bottom + 1 < M:\\n                bottom += 1\\n            else:\\n                left += 1\\n            \\n            go_top_right = not go_top_right\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836769,
                "title": "simple-cpp-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        vector<int> result;\\n        map<int, vector<int>>mp;\\n        for (int i=0; i<matrix.size(); i++) {\\n            for (int j=0; j<matrix[i].size(); j++) {\\n                mp[i+j].push_back(matrix[i][j]);\\n            }\\n        }\\n        for(auto i:mp)\\n        {   if(i.first%2==0)\\n            {\\n                for(int j=i.second.size()-1;j>=0;j--)\\n                    result.push_back(i.second[j]);\\n            }\\n            else\\n            {\\n                for(int j=0;j<i.second.size();j++)\\n                    result.push_back(i.second[j]);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        vector<int> result;\\n        map<int, vector<int>>mp;\\n        for (int i=0; i<matrix.size(); i++) {\\n            for (int j=0; j<matrix[i].size(); j++) {\\n                mp[i+j].push_back(matrix[i][j]);\\n            }\\n        }\\n        for(auto i:mp)\\n        {   if(i.first%2==0)\\n            {\\n                for(int j=i.second.size()-1;j>=0;j--)\\n                    result.push_back(i.second[j]);\\n            }\\n            else\\n            {\\n                for(int j=0;j<i.second.size();j++)\\n                    result.push_back(i.second[j]);\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97787,
                "title": "highly-intuitive-java-solution",
                "content": "The main idea is that for each diagonal sum of row and column should be number of diagonals already traversed.\\neg: \\nfor first diagonal : (0, 0) -> row + col = 0\\nfor second diagonal : (0, 1), (1, 0) -> row + col = 1  \\n\\n\\n\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if(matrix.length == 0)\\n            return new int[0];\\n\\n        int result[] = new int[matrix.length * matrix[0].length];\\n        int curRow = 0;\\n        int curCol = 0;\\n        int index = 0;\\n        boolean isUp = true;\\n        for(int i = 0; i < matrix.length + matrix[0].length; i++) {\\n            if(isUp) {\\n                while(curRow >= 0 && curCol < matrix[0].length) {\\n                    result[index++] = matrix[curRow--][curCol++];\\n                }\\n                if(curCol == matrix[0].length)\\n                    curCol = matrix[0].length - 1;\\n                curRow = i + 1 - curCol;\\n                isUp = !isUp;\\n            }\\n            else {\\n                while(curRow < matrix.length && curCol >= 0) {\\n                    result[index++] = matrix[curRow++][curCol--];\\n                }\\n                if(curRow == matrix.length)\\n                    curRow = matrix.length - 1;\\n                curCol = i + 1 - curRow;\\n                isUp = !isUp;\\n            }\\n        }        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "The main idea is that for each diagonal sum of row and column should be number of diagonals already traversed.\\neg: \\nfor first diagonal : (0, 0) -> row + col = 0\\nfor second diagonal : (0, 1), (1, 0) -> row + col = 1  \\n\\n\\n\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if(matrix.length == 0)\\n            return new int[0];\\n\\n        int result[] = new int[matrix.length * matrix[0].length];\\n        int curRow = 0;\\n        int curCol = 0;\\n        int index = 0;\\n        boolean isUp = true;\\n        for(int i = 0; i < matrix.length + matrix[0].length; i++) {\\n            if(isUp) {\\n                while(curRow >= 0 && curCol < matrix[0].length) {\\n                    result[index++] = matrix[curRow--][curCol++];\\n                }\\n                if(curCol == matrix[0].length)\\n                    curCol = matrix[0].length - 1;\\n                curRow = i + 1 - curCol;\\n                isUp = !isUp;\\n            }\\n            else {\\n                while(curRow < matrix.length && curCol >= 0) {\\n                    result[index++] = matrix[curRow++][curCol--];\\n                }\\n                if(curRow == matrix.length)\\n                    curRow = matrix.length - 1;\\n                curCol = i + 1 - curRow;\\n                isUp = !isUp;\\n            }\\n        }        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 433586,
                "title": "java-python-solutions-faster-than-100",
                "content": "> More Leetcode solutions can be find in Github of \\u3010[myleetcode](https://github.com/guobinhit/myleetcode)\\u3011, contributions are very welcome!\\n\\n\\n- **Java Solution**\\n\\n```java\\npublic int[] findDiagonalOrder(int[][] matrix) {\\n        if (matrix.length == 0) {\\n            return new int[0];\\n        }\\n\\n        // Initial variable\\n        int row = 0, col = 0;\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[] aimArr = new int[m * n];\\n\\n        // Execute m * n times circle, in order to fill m * n element into aimArr\\n        for (int i = 0; i < aimArr.length; i++) {\\n            aimArr[i] = matrix[row][col];\\n            /**\\n             * According to this subject model, we can find some rules about index of matrix.\\n             * For example, the sum of all moving up trajectory element can be divided by 2\\uFF0C\\n             * and the sum of all moving down trajectory element can\\'t be divided by 2\\n             */\\n            if ((row + col) % 2 == 0) {\\n                // moving up\\n                if (col == n - 1) {\\n                    /**\\n                     * If col == n - 1, it\\'s mean this position is last column,\\n                     * so, only row index must be increased\\n                     */\\n                    row++;\\n                } else if (row == 0) {\\n                    /**\\n                     * If row == 0, it\\'s mean this position is first row,\\n                     * so, only column index can be increased\\n                     */\\n                    col++;\\n                } else {\\n                    /**\\n                     * In this condition, in order to moving up,\\n                     * column index must be increased and row index must be decreased\\n                     */\\n                    row--;\\n                    col++;\\n                }\\n            } else {\\n                // moving down\\n                if (row == m - 1) {\\n                    /**\\n                     * If row == m - 1, it\\'s mean this position is last row,\\n                     * so, only column index must be increased\\n                     */\\n                    col++;\\n                } else if (col == 0) {\\n                    /**\\n                     * If col == 0, it\\'s mean this position is first column,\\n                     * so, only row index can be increased\\n                     */\\n                    row++;\\n                } else {\\n                    /**\\n                     * In this condition, in order to moving down,\\n                     * row index must be increased and column index must be decreased\\n                     */\\n                    row++;\\n                    col--;\\n                }\\n            }\\n        }\\n        return aimArr;\\n    }\\n```\\n\\n- **Python Solution**\\n\\n```python\\nclass Solution(object):\\n    def findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(matrix) == 0:\\n            return []\\n\\n        row = 0\\n        col = 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        aimArr = []\\n\\n        i = 0\\n        while i < m * n:\\n            aimArr.append(matrix[row][col])\\n            if (row + col) % 2 == 0:\\n                if col == n - 1:\\n                    row += 1\\n                elif row == 0:\\n                    col += 1\\n                else:\\n                    row -= 1\\n                    col += 1\\n            else:\\n                if row == m - 1:\\n                    col += 1\\n                elif col == 0:\\n                    row += 1\\n                else:\\n                    row += 1\\n                    col -= 1\\n\\n            i += 1\\n\\n        return aimArr\\n\\n```\\n",
                "solutionTags": [],
                "code": "```java\\npublic int[] findDiagonalOrder(int[][] matrix) {\\n        if (matrix.length == 0) {\\n            return new int[0];\\n        }\\n\\n        // Initial variable\\n        int row = 0, col = 0;\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[] aimArr = new int[m * n];\\n\\n        // Execute m * n times circle, in order to fill m * n element into aimArr\\n        for (int i = 0; i < aimArr.length; i++) {\\n            aimArr[i] = matrix[row][col];\\n            /**\\n             * According to this subject model, we can find some rules about index of matrix.\\n             * For example, the sum of all moving up trajectory element can be divided by 2\\uFF0C\\n             * and the sum of all moving down trajectory element can\\'t be divided by 2\\n             */\\n            if ((row + col) % 2 == 0) {\\n                // moving up\\n                if (col == n - 1) {\\n                    /**\\n                     * If col == n - 1, it\\'s mean this position is last column,\\n                     * so, only row index must be increased\\n                     */\\n                    row++;\\n                } else if (row == 0) {\\n                    /**\\n                     * If row == 0, it\\'s mean this position is first row,\\n                     * so, only column index can be increased\\n                     */\\n                    col++;\\n                } else {\\n                    /**\\n                     * In this condition, in order to moving up,\\n                     * column index must be increased and row index must be decreased\\n                     */\\n                    row--;\\n                    col++;\\n                }\\n            } else {\\n                // moving down\\n                if (row == m - 1) {\\n                    /**\\n                     * If row == m - 1, it\\'s mean this position is last row,\\n                     * so, only column index must be increased\\n                     */\\n                    col++;\\n                } else if (col == 0) {\\n                    /**\\n                     * If col == 0, it\\'s mean this position is first column,\\n                     * so, only row index can be increased\\n                     */\\n                    row++;\\n                } else {\\n                    /**\\n                     * In this condition, in order to moving down,\\n                     * row index must be increased and column index must be decreased\\n                     */\\n                    row++;\\n                    col--;\\n                }\\n            }\\n        }\\n        return aimArr;\\n    }\\n```\n```python\\nclass Solution(object):\\n    def findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        if len(matrix) == 0:\\n            return []\\n\\n        row = 0\\n        col = 0\\n        m = len(matrix)\\n        n = len(matrix[0])\\n\\n        aimArr = []\\n\\n        i = 0\\n        while i < m * n:\\n            aimArr.append(matrix[row][col])\\n            if (row + col) % 2 == 0:\\n                if col == n - 1:\\n                    row += 1\\n                elif row == 0:\\n                    col += 1\\n                else:\\n                    row -= 1\\n                    col += 1\\n            else:\\n                if row == m - 1:\\n                    col += 1\\n                elif col == 0:\\n                    row += 1\\n                else:\\n                    row += 1\\n                    col -= 1\\n\\n            i += 1\\n\\n        return aimArr\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97789,
                "title": "3-line-python-solution",
                "content": "Within diagonal row+col is same, so we first sort index pairs by row+col, and within diagonal sort them either by row or by column index depending if row+col is odd/even. \\n```\\ndef findDiagonalOrder(self, matrix):\\n        l = [[i,j] for i in range(len(matrix)) for j in range(len(matrix[0]))]\\n        l.sort(key=lambda x: float(x[0]+x[1])-float(x[(x[0]+x[1])%2])*0.00000001 )\\n        return [matrix[x][y] for [x,y] in l]\\n```",
                "solutionTags": [],
                "code": "```\\ndef findDiagonalOrder(self, matrix):\\n        l = [[i,j] for i in range(len(matrix)) for j in range(len(matrix[0]))]\\n        l.sort(key=lambda x: float(x[0]+x[1])-float(x[(x[0]+x[1])%2])*0.00000001 )\\n        return [matrix[x][y] for [x,y] in l]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 495382,
                "title": "java-easiest-solution-with-explanation-must-read",
                "content": "**Key Observation** : If you write down the matrix in terms of the indices, you will notice that **whenever the indices add to an even number, we go in the upward direction, else in the downward direction.**\\n\\nBelow is the code with comments for better understanding of the solution. We use 2 variables row and col as indices of the matrix. We update them at each iteration of filling in the solution array. There are 2 corner cases for each direction which we handle separately.\\n\\n```\\npublic int[] findDiagonalOrder(int[][] matrix) {\\n\\tif (matrix.length == 0) return new int[0];\\n\\tint m = matrix.length, n = matrix[0].length;\\n\\tint sol[] = new int[m*n];\\n\\tint row = 0, col = 0;\\n\\tfor(int i = 0; i < sol.length; i++) {\\n\\t\\tsol[i] = matrix[row][col];\\n\\t\\tif((row+col)%2 == 0) {              // go up\\n\\t\\t\\tif(col == n-1) row++;           // corner case of last column\\n\\t\\t\\telse if(row == 0) col++;        // corner case of first row\\n\\t\\t\\telse { row--; col++;}           // normal update to go up diagonally\\n\\t\\t} else {                            // go down\\n\\t\\t\\tif(row == m-1) col++;           // corner case of last row\\n\\t\\t\\telse if(col == 0) row++;        // corner case of first column\\n\\t\\t\\telse { row++; col--;}           // normal update to go down diagonally\\n\\t\\t}\\n\\t}\\n\\treturn sol;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] findDiagonalOrder(int[][] matrix) {\\n\\tif (matrix.length == 0) return new int[0];\\n\\tint m = matrix.length, n = matrix[0].length;\\n\\tint sol[] = new int[m*n];\\n\\tint row = 0, col = 0;\\n\\tfor(int i = 0; i < sol.length; i++) {\\n\\t\\tsol[i] = matrix[row][col];\\n\\t\\tif((row+col)%2 == 0) {              // go up\\n\\t\\t\\tif(col == n-1) row++;           // corner case of last column\\n\\t\\t\\telse if(row == 0) col++;        // corner case of first row\\n\\t\\t\\telse { row--; col++;}           // normal update to go up diagonally\\n\\t\\t} else {                            // go down\\n\\t\\t\\tif(row == m-1) col++;           // corner case of last row\\n\\t\\t\\telse if(col == 0) row++;        // corner case of first column\\n\\t\\t\\telse { row++; col--;}           // normal update to go down diagonally\\n\\t\\t}\\n\\t}\\n\\treturn sol;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2124822,
                "title": "c-solution-detailed-explanation-using-diagrams-easy-to-understand",
                "content": "**EXPLANATION:**\\n\\nLet\\'s undestand the approach by taking an example:\\n\\n![image](https://assets.leetcode.com/users/images/caa6f12d-0103-458a-814d-4d28cdd0a872_1654659765.3004186.png)\\n\\n**By analyzing the diagram we can see that we have to consider two directions**\\n1) Top-right\\n2) Bottom-left\\n\\nLet i = 0 and j = 0, i.e we are at the first row and first column. Store it in our ans.\\nLet\\'s understand the scenario of both the directions\\n\\n**1) Top - right:**\\n\\nIf we are moving top right then three cases arises\\n\\n* j becomes n-1 i.e we reaches the last column => In this case we have to move down and change the direction\\n* i becomes 0 i.e we reaches the first row => In this case we have to move right and change the direction\\n* Neither i reaches 0 nor j reaches n-1 => In this case we have to simply traverse the matrix in top-right manner by decrementing i (i.e going to previous row) and incrementing j (i.e going to next column)\\n\\nYou can understand the above cases by looking at the following diagrams:\\n\\n![image](https://assets.leetcode.com/users/images/3f0d942a-dbd3-4e09-8463-ecb0587443ea_1654660481.24194.png)\\n\\n![image](https://assets.leetcode.com/users/images/2ea2f1c8-e5f0-4682-840c-ac2f16b90924_1654660579.270721.png)\\n\\n**2) Bottom-left**\\n\\nIf we are moving bottom-left, again three cases arises\\n\\n* i becomes m-1 i.e we reaches the last row => In this case we have to move right and change the direction\\n* j becomes 0 i.e we reaches the first column => In this case we have to move down and change the direction\\n* Neither i reaches m-1 nor j reaches 0 => In this case we have to simply traverse the matrix in bottom-left manner by incrementing i (i.e going to next row) and decrementing j (i.e going to previous column)\\n\\nYou can understand the above cases by looking at the following diagrams:\\n\\n![image](https://assets.leetcode.com/users/images/6c3cbf3f-fe71-491f-bf38-a9ba5802ecd2_1654661178.5207338.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/f8737b9c-d2d1-4a37-99ba-3fd0dfa04d3d_1654660950.721314.png)\\n\\n\\n**Let\\'s CODE it :**\\n\\n\\n\\t vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<int>res;\\n        int i = 0, j = 0, dir = 0;\\n        res.push_back(mat[0][0]);\\n        while(i != m-1 || j != n-1) {\\n            if(dir == 0) {   // Moving top-right\\n                if(j == n-1) \\n                    i++, dir = 1;   // Move down and change direction\\n                else if(i == 0) \\n                    j++, dir = 1;   // Move right and change direction\\n                else \\n                    i--, j++;       // Move in top-right manner\\n            }\\n            else {    // Moving bottom-left\\n                if(i == m-1) \\n                    j++, dir = 0;   // Move right and change direction\\n                else if(j == 0) \\n                    i++, dir = 0;   // Move down and change direction\\n                else  \\n                    i++, j--;       // Move in bottom-left manner\\n            }   \\n            res.push_back(mat[i][j]);    \\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "**EXPLANATION:**\\n\\nLet\\'s undestand the approach by taking an example:\\n\\n![image](https://assets.leetcode.com/users/images/caa6f12d-0103-458a-814d-4d28cdd0a872_1654659765.3004186.png)\\n\\n**By analyzing the diagram we can see that we have to consider two directions**\\n1) Top-right\\n2) Bottom-left\\n\\nLet i = 0 and j = 0, i.e we are at the first row and first column. Store it in our ans.\\nLet\\'s understand the scenario of both the directions\\n\\n**1) Top - right:**\\n\\nIf we are moving top right then three cases arises\\n\\n* j becomes n-1 i.e we reaches the last column => In this case we have to move down and change the direction\\n* i becomes 0 i.e we reaches the first row => In this case we have to move right and change the direction\\n* Neither i reaches 0 nor j reaches n-1 => In this case we have to simply traverse the matrix in top-right manner by decrementing i (i.e going to previous row) and incrementing j (i.e going to next column)\\n\\nYou can understand the above cases by looking at the following diagrams:\\n\\n![image](https://assets.leetcode.com/users/images/3f0d942a-dbd3-4e09-8463-ecb0587443ea_1654660481.24194.png)\\n\\n![image](https://assets.leetcode.com/users/images/2ea2f1c8-e5f0-4682-840c-ac2f16b90924_1654660579.270721.png)\\n\\n**2) Bottom-left**\\n\\nIf we are moving bottom-left, again three cases arises\\n\\n* i becomes m-1 i.e we reaches the last row => In this case we have to move right and change the direction\\n* j becomes 0 i.e we reaches the first column => In this case we have to move down and change the direction\\n* Neither i reaches m-1 nor j reaches 0 => In this case we have to simply traverse the matrix in bottom-left manner by incrementing i (i.e going to next row) and decrementing j (i.e going to previous column)\\n\\nYou can understand the above cases by looking at the following diagrams:\\n\\n![image](https://assets.leetcode.com/users/images/6c3cbf3f-fe71-491f-bf38-a9ba5802ecd2_1654661178.5207338.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/f8737b9c-d2d1-4a37-99ba-3fd0dfa04d3d_1654660950.721314.png)\\n\\n\\n**Let\\'s CODE it :**\\n\\n\\n\\t vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        vector<int>res;\\n        int i = 0, j = 0, dir = 0;\\n        res.push_back(mat[0][0]);\\n        while(i != m-1 || j != n-1) {\\n            if(dir == 0) {   // Moving top-right\\n                if(j == n-1) \\n                    i++, dir = 1;   // Move down and change direction\\n                else if(i == 0) \\n                    j++, dir = 1;   // Move right and change direction\\n                else \\n                    i--, j++;       // Move in top-right manner\\n            }\\n            else {    // Moving bottom-left\\n                if(i == m-1) \\n                    j++, dir = 0;   // Move right and change direction\\n                else if(j == 0) \\n                    i++, dir = 0;   // Move down and change direction\\n                else  \\n                    i++, j--;       // Move in bottom-left manner\\n            }   \\n            res.push_back(mat[i][j]);    \\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 691181,
                "title": "3-easy-to-understand-java-solutions",
                "content": "```\\n/**\\n     1. Create a map( Key as  sum of row and columns) because the row + column sum for all diagonal elements are same .\\n     2. Another interesting thing is that last diagnol element is the last row last element which is Maxrow + maxcol  -2. \\n     3. Iterate from 0 to Last diagonal element  ( refer to point 2 ) and get the value ( list of elments) from map. \\n     4. If diag element is multiple of 2 reverse the list and then add to output else as it is add to output .\\n   **/\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        \\n        if( matrix == null || matrix.length ==0){\\n            return new int[0];\\n        }\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        int retObject[] = new int[rows * cols];\\n        \\n        // The sum of diagonal elements are same \\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        \\n        for(int row = 0 ; row < rows ; row++){\\n            for( int col=0; col < cols; col++){\\n                if(! map.containsKey( row+ col)){\\n                     map.put( row+ col, new ArrayList<>());\\n                }\\n                map.get(row+col).add(matrix[row][col]);\\n            }\\n        }\\n        \\n        int lastElement = rows + cols-2;\\n        int index =0;\\n        \\n        for( int diag=0; diag <= lastElement ; diag++ ){\\n            List<Integer> list = map.get(diag);\\n            if(diag %2 ==0){\\n                Collections.reverse(list);\\n            }\\n            for(int dt : list){\\n                retObject[index++]= dt;\\n            }\\n        }\\n        return retObject;\\n        \\n    }\\n    \\n    \\n    \\n    /**\\n      1. Iterate diagonaly , diagonal is first row starting columsn and last columns . Total diagonals= rows+ cols -1.\\n      2. Then create the list reverse it in case of Odd level ( diag +1) %2 ==0.  \\n      3. thats it \\n    \\n    **/\\n    public int[] findDiagonalOrder_v1(int[][] matrix) {\\n        \\n        if( matrix == null || matrix.length ==0){\\n            return new int[0];\\n        }\\n        \\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        \\n        int retObject[] = new int[rows * cols];\\n        int index =0;\\n        List<Integer> list = new ArrayList<>();\\n        \\n        // iterate through diagnol\\n        for( int diag =0; diag < (rows + cols -1) ; diag++){\\n            int row = diag< cols ? 0 : diag-cols +1;\\n            int col = diag< cols ? diag : cols -1;\\n            list.clear();\\n            while( row < rows && col >=0 ){\\n                list.add(matrix[row][col]);\\n                row++;\\n                col--;\\n                \\n            }\\n            if((diag +1)%2 !=0){\\n                Collections.reverse(list);\\n            }\\n            \\n            for( Integer data : list){\\n                if( index < retObject.length){\\n                     retObject[index++]=data; \\n                }\\n            }\\n            \\n        }\\n        return retObject;\\n    }\\n    \\n    \\n    /**\\n      Based on Intiution\\n    **/\\n    public int[] findDiagonalOrder_v2(int[][] matrix) {\\n        \\n        if( matrix == null || matrix.length ==0){\\n            return new int[0];\\n        }\\n        \\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        \\n        int retObject[] = new int[rows * cols];\\n        int index =0;\\n        int row =0;\\n        int col=0;\\n        \\n        // iterate through diagnol\\n        for(int pos=0; pos<retObject.length ; pos++ ){\\n            retObject[pos]=matrix[row][col]; \\n            // If diagnoal level is Even\\n            if( (row+col) % 2 ==0){\\n                // If col reaches last col then  move down row increased;\\n                if(col == cols-1) row++;\\n                // If row reaches last row\\n                else if(row == 0) col++;\\n                else {\\n                    row--;\\n                    col++;\\n                }\\n            }else {\\n                // If row reaches last row then  move col to rifgh;\\n                if(row == rows-1) col++;\\n                // If row reaches last row\\n                else if(col == 0) row++;\\n                else {\\n                   col--;\\n                   row++; \\n                }\\n            }\\n        }\\n        return retObject;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n     1. Create a map( Key as  sum of row and columns) because the row + column sum for all diagonal elements are same .\\n     2. Another interesting thing is that last diagnol element is the last row last element which is Maxrow + maxcol  -2. \\n     3. Iterate from 0 to Last diagonal element  ( refer to point 2 ) and get the value ( list of elments) from map. \\n     4. If diag element is multiple of 2 reverse the list and then add to output else as it is add to output .\\n   **/\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        \\n        if( matrix == null || matrix.length ==0){\\n            return new int[0];\\n        }\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        int retObject[] = new int[rows * cols];\\n        \\n        // The sum of diagonal elements are same \\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        \\n        for(int row = 0 ; row < rows ; row++){\\n            for( int col=0; col < cols; col++){\\n                if(! map.containsKey( row+ col)){\\n                     map.put( row+ col, new ArrayList<>());\\n                }\\n                map.get(row+col).add(matrix[row][col]);\\n            }\\n        }\\n        \\n        int lastElement = rows + cols-2;\\n        int index =0;\\n        \\n        for( int diag=0; diag <= lastElement ; diag++ ){\\n            List<Integer> list = map.get(diag);\\n            if(diag %2 ==0){\\n                Collections.reverse(list);\\n            }\\n            for(int dt : list){\\n                retObject[index++]= dt;\\n            }\\n        }\\n        return retObject;\\n        \\n    }\\n    \\n    \\n    \\n    /**\\n      1. Iterate diagonaly , diagonal is first row starting columsn and last columns . Total diagonals= rows+ cols -1.\\n      2. Then create the list reverse it in case of Odd level ( diag +1) %2 ==0.  \\n      3. thats it \\n    \\n    **/\\n    public int[] findDiagonalOrder_v1(int[][] matrix) {\\n        \\n        if( matrix == null || matrix.length ==0){\\n            return new int[0];\\n        }\\n        \\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        \\n        int retObject[] = new int[rows * cols];\\n        int index =0;\\n        List<Integer> list = new ArrayList<>();\\n        \\n        // iterate through diagnol\\n        for( int diag =0; diag < (rows + cols -1) ; diag++){\\n            int row = diag< cols ? 0 : diag-cols +1;\\n            int col = diag< cols ? diag : cols -1;\\n            list.clear();\\n            while( row < rows && col >=0 ){\\n                list.add(matrix[row][col]);\\n                row++;\\n                col--;\\n                \\n            }\\n            if((diag +1)%2 !=0){\\n                Collections.reverse(list);\\n            }\\n            \\n            for( Integer data : list){\\n                if( index < retObject.length){\\n                     retObject[index++]=data; \\n                }\\n            }\\n            \\n        }\\n        return retObject;\\n    }\\n    \\n    \\n    /**\\n      Based on Intiution\\n    **/\\n    public int[] findDiagonalOrder_v2(int[][] matrix) {\\n        \\n        if( matrix == null || matrix.length ==0){\\n            return new int[0];\\n        }\\n        \\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        \\n        int retObject[] = new int[rows * cols];\\n        int index =0;\\n        int row =0;\\n        int col=0;\\n        \\n        // iterate through diagnol\\n        for(int pos=0; pos<retObject.length ; pos++ ){\\n            retObject[pos]=matrix[row][col]; \\n            // If diagnoal level is Even\\n            if( (row+col) % 2 ==0){\\n                // If col reaches last col then  move down row increased;\\n                if(col == cols-1) row++;\\n                // If row reaches last row\\n                else if(row == 0) col++;\\n                else {\\n                    row--;\\n                    col++;\\n                }\\n            }else {\\n                // If row reaches last row then  move col to rifgh;\\n                if(row == rows-1) col++;\\n                // If row reaches last row\\n                else if(col == 0) row++;\\n                else {\\n                   col--;\\n                   row++; \\n                }\\n            }\\n        }\\n        return retObject;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 400847,
                "title": "simple-c-solution",
                "content": "It\\'s easy to find that the index sum of each round is from 0 to n + m - 1. When we set colume index as j, we can easily get row index by i - j. Of course we should make sure that j in [0, m - 1] and i - j in [0, n - 1]. Then we will get that j\\'s value is between min(i, m - 1) and  max(i - n + 1, 0)\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n\\t\\tif (matrix.empty())\\n\\t\\t\\treturn {};\\n\\t\\tvector<int>res;\\n\\t\\tint n = matrix.size(), m = matrix[0].size();\\n        for (int i = 0; i < n + m - 1; i++) { \\n\\t\\t\\tif (i & 1) {\\n\\t\\t\\t\\tfor (int j = min(i, m - 1); j >= max(i - n + 1, 0); j--)\\n\\t\\t\\t\\t\\tres.push_back(matrix[i - j][j]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (int j = max(i - n + 1, 0); j <= min(i, m - 1); j++)\\n\\t\\t\\t\\t\\tres.push_back(matrix[i - j][j]);\\n\\t\\t\\t}\\n\\t\\t}\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n\\t\\tif (matrix.empty())\\n\\t\\t\\treturn {};\\n\\t\\tvector<int>res;\\n\\t\\tint n = matrix.size(), m = matrix[0].size();\\n        for (int i = 0; i < n + m - 1; i++) { \\n\\t\\t\\tif (i & 1) {\\n\\t\\t\\t\\tfor (int j = min(i, m - 1); j >= max(i - n + 1, 0); j--)\\n\\t\\t\\t\\t\\tres.push_back(matrix[i - j][j]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor (int j = max(i - n + 1, 0); j <= min(i, m - 1); j++)\\n\\t\\t\\t\\t\\tres.push_back(matrix[i - j][j]);\\n\\t\\t\\t}\\n\\t\\t}\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361938,
                "title": "easy-peasy-python-solution-using-dictionary-map",
                "content": "\\tdef findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        M = len(matrix)\\n        if M == 0:\\n            return []\\n        N = len(matrix[0])\\n        mp = { }\\n        for i in range(M):\\n            for j in range(N):\\n                if i+j in mp:\\n                    mp[i+j].append(matrix[i][j])\\n                else:\\n                    mp[i+j] = [matrix[i][j]]\\n        \\n        rs = []\\n        rev = True\\n        print(mp)\\n        for i in range(0, M+N-1):\\n            if rev:\\n                mp[i] = mp[i][::-1]\\n            rev = not rev\\n            rs.extend(mp[i])\\n        return rs",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tdef findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        M = len(matrix)\\n        if M == 0:\\n            return []\\n        N = len(matrix[0])\\n        mp = { }\\n        for i in range(M):\\n            for j in range(N):\\n                if i+j in mp:\\n                    mp[i+j].append(matrix[i][j])\\n                else:\\n                    mp[i+j] = [matrix[i][j]]\\n        \\n        rs = []\\n        rev = True\\n        print(mp)\\n        for i in range(0, M+N-1):\\n            if rev:\\n                mp[i] = mp[i][::-1]\\n            rev = not rev\\n            rs.extend(mp[i])\\n        return rs",
                "codeTag": "Python3"
            },
            {
                "id": 145195,
                "title": "python-solution-beats-100-using-bfs-just-like-maze-problem",
                "content": "This is obviously a standard BFS problem. What we need to deal with is whether each layer is sequential or reverse.![image](https://s3-lc-upload.s3.amazonaws.com/users/2017111303/image_1530756650.png)\\n\\nWe always add elements to the queue in the order from `bottom left to top right.`\\nusing `level` to determine if we need to reverse the order.\\n\\n```python\\nclass Solution(object):\\n    def findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not matrix or not matrix[0]: return []\\n        m,n = len(matrix),len(matrix[0])\\n\\n        visited = set()\\n\\t# rec record all element in the level i\\n        res,rec,level = [],[],0\\n        Q = collections.deque([(0,0),(-1,-1)])\\n        while Q:\\n            i,j = Q.popleft()\\n\\t    # using (-1,-1) to represent the end of this layer traversal\\n            if i == j == -1:\\n                if level & 1: rec = rec[::-1]\\n                res.extend(rec)\\n                level += 1\\n                rec = []\\n                if not Q: break\\n                Q.append((-1,-1))\\n                continue\\n\\n            if (i,j) in visited: continue\\n            visited.add((i,j))\\n            rec.append(matrix[i][j])\\n\\t\\t\\t\\t\\t\\t# always from botton left to top right\\n            if 0<=i+1<m and 0<=j<n:\\n                Q.append((i+1,j))\\n            if 0<=i<m and 0<=j+1<n:\\n                Q.append((i,j+1))\\n        return res\\nO(m*n) time, O(m*n) space\\n164ms,beats 100%\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not matrix or not matrix[0]: return []\\n        m,n = len(matrix),len(matrix[0])\\n\\n        visited = set()\\n\\t# rec record all element in the level i\\n        res,rec,level = [],[],0\\n        Q = collections.deque([(0,0),(-1,-1)])\\n        while Q:\\n            i,j = Q.popleft()\\n\\t    # using (-1,-1) to represent the end of this layer traversal\\n            if i == j == -1:\\n                if level & 1: rec = rec[::-1]\\n                res.extend(rec)\\n                level += 1\\n                rec = []\\n                if not Q: break\\n                Q.append((-1,-1))\\n                continue\\n\\n            if (i,j) in visited: continue\\n            visited.add((i,j))\\n            rec.append(matrix[i][j])\\n\\t\\t\\t\\t\\t\\t# always from botton left to top right\\n            if 0<=i+1<m and 0<=j<n:\\n                Q.append((i+1,j))\\n            if 0<=i<m and 0<=j+1<n:\\n                Q.append((i,j+1))\\n        return res\\nO(m*n) time, O(m*n) space\\n164ms,beats 100%\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1204811,
                "title": "simple-af",
                "content": "**just find the pattern in the index of each diagonal.\\n1st->    (0,0)  => sum=0\\n2nd->  (0,1),(1,0)  => sum=1\\n3rd->  (2,0),(1,1),(0,2) => sum=2\\n4th->  (1,2),(2,1) => sum=3\\n5th-> (2,2) => sum=4**\\n\\nNow store all the diagonals corresponding to their sum value. We can simple travsere the array and store the \\nvalue in unordered<int,vector<int>>mp unordered_map where int is the sum which is mapped to the corresponding values whose index is equal to sum.\\ni.e mp[i+j].push_back(mat[i][j])\\n\\nThe maximum value sum is n+m-2. Loop from 0 to max_Val of sum and if sum is even reverse the vector and then insert all the values of vector in result vector. if odd dont do anything just push all the values into result vector.\\n\\nHere is my code:\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        \\n        int n=mat.size(),m=mat[0].size();\\n        vector<int>res;\\n        unordered_map<int,vector<int>>mp;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n             mp[i+j].push_back(mat[i][j]);  // push values corresponding to sum\\n            }\\n        }\\n        \\n        int size=m+n-2; // max_val of sum\\n        for(int i=0;i<=size;i++){\\n            vector<int>temp=mp[i];\\n            if(i%2==0) reverse(temp.begin(),temp.end()); // reverse if even\\n            for(auto x:temp) res.push_back(x); // push in result vector\\n        }\\n        \\n        return res;\\n        \\n     }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        \\n        int n=mat.size(),m=mat[0].size();\\n        vector<int>res;\\n        unordered_map<int,vector<int>>mp;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n             mp[i+j].push_back(mat[i][j]);  // push values corresponding to sum\\n            }\\n        }\\n        \\n        int size=m+n-2; // max_val of sum\\n        for(int i=0;i<=size;i++){\\n            vector<int>temp=mp[i];\\n            if(i%2==0) reverse(temp.begin(),temp.end()); // reverse if even\\n            for(auto x:temp) res.push_back(x); // push in result vector\\n        }\\n        \\n        return res;\\n        \\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672132,
                "title": "java-linear-time-constant-space-eyplanatory-text",
                "content": "Some observations:\\n1. There are m + n - 1 diagonals in the matrix.\\n2. If we number the diagonals non-descending, starting from mat[0][0] as diagonal 0, down to diagonal (m + n - 1), it turns out, that \"even\" diagonals go up to the right, and \"odd\" diagonals go down to the left.\\n3. Going up to the right, we may leave the matrix at row 0, or col (n - 1). In this cases we must handle the column and row indexes special. In a turn through the middle of the matrix we increment the column and decrement the row.\\n4. Going down to the left, we may leave the matrix at column 0, or row (m - 1). In this cases, we must handle the column and row indexes special. In a turn through the middle of the matrix we decrement the column and increment the row.\\n5. The solution can handle the corner cases (m or n, one or both, are 1). No special handling necessary.\\n6. The surrounding for-loop takes care, that we traverse all m * n numbers in the matrix.\\n7. The traversal algorithm itself is done by the row/col manipulation logic inside the loop.\\n```java\\n    public int[] findDiagonalOrder(int[][] mat) {\\n\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[] answer = new int[n * m];\\n        int col = 0, row = 0;\\n\\n        for (int i = 0; i < m * n; i++) {\\n\\n            answer[i] = mat[row][col];\\n\\n            if ((row + col) % 2 == 0) { // go up to the right\\n\\n                if (col == n - 1) row++;\\n                else if (row == 0) col++;\\n                else {\\n                    row--;\\n                    col++;\\n                }\\n            } else {  // go down to the left\\n\\n                if (row == m - 1) col++;\\n                else if (col == 0) row++;\\n                else {\\n                    row++;\\n                    col--;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n    public int[] findDiagonalOrder(int[][] mat) {\\n\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[] answer = new int[n * m];\\n        int col = 0, row = 0;\\n\\n        for (int i = 0; i < m * n; i++) {\\n\\n            answer[i] = mat[row][col];\\n\\n            if ((row + col) % 2 == 0) { // go up to the right\\n\\n                if (col == n - 1) row++;\\n                else if (row == 0) col++;\\n                else {\\n                    row--;\\n                    col++;\\n                }\\n            } else {  // go down to the left\\n\\n                if (row == m - 1) col++;\\n                else if (col == 0) row++;\\n                else {\\n                    row++;\\n                    col--;\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1836969,
                "title": "simulation-direction-python3-easy-understanding",
                "content": "# 498. Diagonal Traverse\\n\\nLogic is: When Even we hit a border we move Up or Down.\\n* When we are row == 0 or col == last col. We want to move down. \\n* When we are at col == 0 or row == last row. We want to move up\\n\\n\\n```\\n# Time = O(row.col) \\n# Space = O(1). If we dont consider op.\\n\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        row = 0\\n        col = 0\\n        height = len(mat) - 1\\n        width = len(mat[0]) - 1\\n        \\n        \\n        res = []\\n        \\n        goingUp = True\\n        \\n        while not self.isBound(row, col, height, width):\\n            \\n            res.append(mat[row][col])\\n            \\n            if goingUp:\\n\\n                if row == 0 or col == width:\\n                    goingUp = False # go Down\\n                    \\n                    if col == width:\\n                        row += 1\\n                    else:\\n                        col += 1\\n                        \\n                else:\\n                    row -= 1\\n                    col += 1\\n            \\n            else:\\n                if col == 0 or row == height:\\n                    goingUp = True\\n                    \\n                    if row == height:\\n                        col += 1\\n                    else :\\n                        row += 1\\n                        \\n                else:\\n                    row += 1\\n                    col -= 1\\n                    \\n            \\n        return res\\n    \\n    def isBound(self, row, col, height, width):\\n        # this will return true if any of this condition is met\\n        return row < 0 or col < 0 or row > height or col > width\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\n# Time = O(row.col) \\n# Space = O(1). If we dont consider op.\\n\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        row = 0\\n        col = 0\\n        height = len(mat) - 1\\n        width = len(mat[0]) - 1\\n        \\n        \\n        res = []\\n        \\n        goingUp = True\\n        \\n        while not self.isBound(row, col, height, width):\\n            \\n            res.append(mat[row][col])\\n            \\n            if goingUp:\\n\\n                if row == 0 or col == width:\\n                    goingUp = False # go Down\\n                    \\n                    if col == width:\\n                        row += 1\\n                    else:\\n                        col += 1\\n                        \\n                else:\\n                    row -= 1\\n                    col += 1\\n            \\n            else:\\n                if col == 0 or row == height:\\n                    goingUp = True\\n                    \\n                    if row == height:\\n                        col += 1\\n                    else :\\n                        row += 1\\n                        \\n                else:\\n                    row += 1\\n                    col -= 1\\n                    \\n            \\n        return res\\n    \\n    def isBound(self, row, col, height, width):\\n        # this will return true if any of this condition is met\\n        return row < 0 or col < 0 or row > height or col > width\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1772539,
                "title": "unordered-map-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<int>res;\\n        map<int,vector<int>>mp;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                mp[i+j].push_back(mat[i][j]);\\n            }\\n        }\\n        for(auto x:mp){\\n            if(x.first%2==0){\\n                reverse(x.second.begin(),x.second.end());\\n            }\\n            for(auto i:x.second){\\n                res.push_back(i);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\nPls upvote if you like it\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size();\\n        vector<int>res;\\n        map<int,vector<int>>mp;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                mp[i+j].push_back(mat[i][j]);\\n            }\\n        }\\n        for(auto x:mp){\\n            if(x.first%2==0){\\n                reverse(x.second.begin(),x.second.end());\\n            }\\n            for(auto i:x.second){\\n                res.push_back(i);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\nPls upvote if you like it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1644184,
                "title": "c-straightforward-solution",
                "content": "```\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        vector<int> result;\\n        // we define two directions, 1 and -1\\n        // if current cell is (r, c)\\n        // for direction 1, next iteration cell is (r - 1, c + 1)\\n        // for direction -1, next iteratoin cell is (r + 1, c - 1)\\n        compute(mat, 0, 0, 1, result);\\n        return result;\\n    }\\n    \\n    void compute(vector<vector<int>>& mat, int r, int c, int dir, vector<int>& result) {\\n        int rows = mat.size();\\n        int columns = mat[0].size();\\n        result.push_back(mat[r][c]);\\n        if (result.size() == rows * columns) {\\n            return;\\n        }\\n        if (dir == 1 && c == columns - 1) {\\n            // if direction is 1 and current we are at the last column, then the only way is to go down\\n            compute(mat, r + 1, c, -1, result);\\n        } else if (dir == 1 && r == 0) {\\n            // if direction is 1 and we are in the first row and not the last column, then we need to go right\\n            compute(mat, r, c + 1, -1, result);\\n        } else if (dir == -1 && r == rows - 1) {\\n            // if direction is -1 and we are at the last row, then we have to go right\\n            compute(mat, r, c + 1, 1, result);\\n        } else if (dir == -1 && c == 0) {\\n            // if direction is -1 and we are at the first column and it\\'s not the last row, then we need to go down\\n            compute(mat, r + 1, c, 1, result);\\n        } else {\\n            // safe to move along the direction to the next cell\\n            compute(mat, r - dir, c + dir, dir, result);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        vector<int> result;\\n        // we define two directions, 1 and -1\\n        // if current cell is (r, c)\\n        // for direction 1, next iteration cell is (r - 1, c + 1)\\n        // for direction -1, next iteratoin cell is (r + 1, c - 1)\\n        compute(mat, 0, 0, 1, result);\\n        return result;\\n    }\\n    \\n    void compute(vector<vector<int>>& mat, int r, int c, int dir, vector<int>& result) {\\n        int rows = mat.size();\\n        int columns = mat[0].size();\\n        result.push_back(mat[r][c]);\\n        if (result.size() == rows * columns) {\\n            return;\\n        }\\n        if (dir == 1 && c == columns - 1) {\\n            // if direction is 1 and current we are at the last column, then the only way is to go down\\n            compute(mat, r + 1, c, -1, result);\\n        } else if (dir == 1 && r == 0) {\\n            // if direction is 1 and we are in the first row and not the last column, then we need to go right\\n            compute(mat, r, c + 1, -1, result);\\n        } else if (dir == -1 && r == rows - 1) {\\n            // if direction is -1 and we are at the last row, then we have to go right\\n            compute(mat, r, c + 1, 1, result);\\n        } else if (dir == -1 && c == 0) {\\n            // if direction is -1 and we are at the first column and it\\'s not the last row, then we need to go down\\n            compute(mat, r + 1, c, 1, result);\\n        } else {\\n            // safe to move along the direction to the next cell\\n            compute(mat, r - dir, c + dir, dir, result);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1634894,
                "title": "c-easy-short-direct-solution",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n\\t\\t\\t\\tvector<int> a;\\n\\t\\t\\t\\tint r=0,c=0;\\n\\t\\t\\t\\tint m = mat.size(), n = mat[0].size();\\n\\t\\t\\t\\tbool up = true;\\n\\t\\t\\t\\twhile(r<m && c<n){\\n\\t\\t\\t\\t\\tif(up){\\n\\t\\t\\t\\t\\t\\twhile(r>0 && c<n-1){\\n\\t\\t\\t\\t\\t\\t\\ta.push_back(mat[r][c]);\\n\\t\\t\\t\\t\\t\\t\\tr--;\\n\\t\\t\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\ta.push_back(mat[r][c]);\\n\\t\\t\\t\\t\\t\\tif(c==n-1) r++;\\n\\t\\t\\t\\t\\t\\telse c++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\twhile(r<m-1 && c>0){\\n\\t\\t\\t\\t\\t\\t\\ta.push_back(mat[r][c]);\\n\\t\\t\\t\\t\\t\\t\\tr++;\\n\\t\\t\\t\\t\\t\\t\\tc--;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\ta.push_back(mat[r][c]);\\n\\t\\t\\t\\t\\t\\tif(r==m-1) c++;\\n\\t\\t\\t\\t\\t\\telse r++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tup = !up;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn a;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tvector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n\\t\\t\\t\\tvector<int> a;\\n\\t\\t\\t\\tint r=0,c=0;\\n\\t\\t\\t\\tint m = mat.size(), n = mat[0].size();\\n\\t\\t\\t\\tbool up = true;\\n\\t\\t\\t\\twhile(r<m && c<n){\\n\\t\\t\\t\\t\\tif(up){\\n\\t\\t\\t\\t\\t\\twhile(r>0 && c<n-1){\\n\\t\\t\\t\\t\\t\\t\\ta.push_back(mat[r][c]);\\n\\t\\t\\t\\t\\t\\t\\tr--;\\n\\t\\t\\t\\t\\t\\t\\tc++;\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 987172,
                "title": "python-solution-explained-t-o-m-n-s-o-1-step-by-step",
                "content": "Diagonal Travers:\\n1. When we are travsering up, the sum of row and col is even and for down its odd. This is the key point here.\\n2.  While traversing up we need to do row-=1 and col+=1 and for down row+=1 and col=-1.\\n3.  Take special care about when traversing up\\n\\t i. Once we get (0,0) position value then we need to increment one col to traverse downside.\\n\\t ii. if the column became length -1 it means it reaches end of the column(ex: 1,3) then we need to    increment row so it came to (2, 3)\\n4.  Take special care about when traversing down\\n\\t i.  When we are at (1, 0)  we need to increment row+=1 so it became (2,0) towards up.\\n\\t ii. if the row became length -1 it means it reaches end of the row (ex: 3,0) then we need to    increment column. ex: (3,0) --> (3,1) \\n\\t \\n```\\ninput_matrix = [\\n    [1, 2, 3, 4],\\n    [5, 6, 7, 8],\\n    [9, 10, 11, 12],\\n    [13, 14, 15, 16]\\n]\\n```\\n```\\nIndex\\n[ 00 01 02 03\\n10 11 12 13\\n20 21 22 23\\n30 31 32 33 ]\\n```\\n```\\nclass Solution:\\n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\\n        \\n        if not matrix: return []\\n        len_row = len(matrix)\\n        len_col = len(matrix[0])\\n        \\n        result = []\\n        row = col = 0\\n        for i in range(len_row * len_col):\\n            result.append(matrix[row][col])\\n            if (row + col) % 2 == 0:\\n                \\n                if col == len_col -1:\\n                    row += 1\\n                elif row == 0:\\n                    col += 1\\n                else:\\n                    row -= 1\\n                    col += 1\\n            else:\\n                if row == len_row -1:\\n                    col += 1\\n                elif col == 0:\\n                    row += 1\\n                else:\\n                    row += 1\\n                    col -= 1   \\n        return result\\n        ```\\n\\t\\tIf you get it please Upvote.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ninput_matrix = [\\n    [1, 2, 3, 4],\\n    [5, 6, 7, 8],\\n    [9, 10, 11, 12],\\n    [13, 14, 15, 16]\\n]\\n```\n```\\nIndex\\n[ 00 01 02 03\\n10 11 12 13\\n20 21 22 23\\n30 31 32 33 ]\\n```\n```\\nclass Solution:\\n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\\n        \\n        if not matrix: return []\\n        len_row = len(matrix)\\n        len_col = len(matrix[0])\\n        \\n        result = []\\n        row = col = 0\\n        for i in range(len_row * len_col):\\n            result.append(matrix[row][col])\\n            if (row + col) % 2 == 0:\\n                \\n                if col == len_col -1:\\n                    row += 1\\n                elif row == 0:\\n                    col += 1\\n                else:\\n                    row -= 1\\n                    col += 1\\n            else:\\n                if row == len_row -1:\\n                    col += 1\\n                elif col == 0:\\n                    row += 1\\n                else:\\n                    row += 1\\n                    col -= 1   \\n        return result\\n        ```",
                "codeTag": "Java"
            },
            {
                "id": 985709,
                "title": "diagonal-traverse-java-o-row-col-solution-beats-100-solutions",
                "content": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if(matrix.length == 0)\\n            return new int[0];\\n        \\n        int r = matrix.length, c = matrix[0].length, i =0, j =0;\\n        int[] ans = new int[r*c];\\n        \\n        for(int k=0; k<ans.length; k++){\\n            ans[k] = matrix[i][j];\\n            \\n            if((i+j)%2 == 0){\\n                if(j == c-1)\\n                    i++;\\n                else if(i == 0)\\n                    j++;\\n                else{\\n                    i--;\\n                    j++;\\n                }\\n            }else{\\n                if(i == r-1)\\n                    j++;\\n                else if(j == 0)\\n                    i++;\\n                else{\\n                    i++;\\n                    j--;\\n                }\\n                \\n            }\\n        }\\n        return ans;   \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if(matrix.length == 0)\\n            return new int[0];\\n        \\n        int r = matrix.length, c = matrix[0].length, i =0, j =0;\\n        int[] ans = new int[r*c];\\n        \\n        for(int k=0; k<ans.length; k++){\\n            ans[k] = matrix[i][j];\\n            \\n            if((i+j)%2 == 0){\\n                if(j == c-1)\\n                    i++;\\n                else if(i == 0)\\n                    j++;\\n                else{\\n                    i--;\\n                    j++;\\n                }\\n            }else{\\n                if(i == r-1)\\n                    j++;\\n                else if(j == 0)\\n                    i++;\\n                else{\\n                    i++;\\n                    j--;\\n                }\\n                \\n            }\\n        }\\n        return ans;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853968,
                "title": "my-solution-to-the-matrix-diagonal-traverse",
                "content": "**Input:** [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\\n**Output:** [1, 2, 4, 7, 5, 3, 6, 8, 9]\\n\\n**Note:**\\n* The sum of diagonal value subscript will be always same i.e (i+j)\\n![image](https://assets.leetcode.com/users/images/5ce6e443-b4aa-4a18-98ab-41ce5ddf1892_1600523225.9328363.png)\\n\\n```\\nvar findDiagonalOrder = function (matrix) {\\n  if (matrix.length ===0) return [];\\n  \\n  let arrayMap = new Map();\\n  let result = [];\\n  \\n  // Storing all the diagonal value in the Map with i+j as a key\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[0].length; j++) {\\n      if (!arrayMap.has(i + j)) {\\n        arrayMap.set(i + j, [matrix[i][j]]);\\n      } else {\\n        arrayMap.set(i + j, [...arrayMap.get(i + j), matrix[i][j]]);\\n      }\\n    }\\n  }\\n\\n\\n  let isDown = false;\\n\\n  arrayMap.forEach((x) => {\\n    if (isDown) {\\n      result.push(...x);\\n    } else {\\n      result.push(...x.reverse());\\n    }\\n    isDown = !isDown;\\n  });\\n\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Matrix"
                ],
                "code": "```\\nvar findDiagonalOrder = function (matrix) {\\n  if (matrix.length ===0) return [];\\n  \\n  let arrayMap = new Map();\\n  let result = [];\\n  \\n  // Storing all the diagonal value in the Map with i+j as a key\\n  for (let i = 0; i < matrix.length; i++) {\\n    for (let j = 0; j < matrix[0].length; j++) {\\n      if (!arrayMap.has(i + j)) {\\n        arrayMap.set(i + j, [matrix[i][j]]);\\n      } else {\\n        arrayMap.set(i + j, [...arrayMap.get(i + j), matrix[i][j]]);\\n      }\\n    }\\n  }\\n\\n\\n  let isDown = false;\\n\\n  arrayMap.forEach((x) => {\\n    if (isDown) {\\n      result.push(...x);\\n    } else {\\n      result.push(...x.reverse());\\n    }\\n    isDown = !isDown;\\n  });\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 362953,
                "title": "clear-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if(matrix==null || matrix.length==0 || matrix[0].length==0) return new int[0];\\n        int r=0,c=0;\\n        int rows=matrix.length,cols=matrix[0].length;\\n        int[] res=new int[rows*cols];\\n        for(int i=0;i<res.length;i++){\\n            res[i]=matrix[r][c];\\n            if((r+c)%2==0){\\n                if(c==cols-1) r++;\\n                else if(r==0) c++;\\n                else{\\n                    c++;\\n                    r--;\\n                }\\n            }\\n            else{\\n                if(r==rows-1) c++;\\n                else if(c==0) r++;\\n                else{\\n                    r++;\\n                    c--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if(matrix==null || matrix.length==0 || matrix[0].length==0) return new int[0];\\n        int r=0,c=0;\\n        int rows=matrix.length,cols=matrix[0].length;\\n        int[] res=new int[rows*cols];\\n        for(int i=0;i<res.length;i++){\\n            res[i]=matrix[r][c];\\n            if((r+c)%2==0){\\n                if(c==cols-1) r++;\\n                else if(r==0) c++;\\n                else{\\n                    c++;\\n                    r--;\\n                }\\n            }\\n            else{\\n                if(r==rows-1) c++;\\n                else if(c==0) r++;\\n                else{\\n                    r++;\\n                    c--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463187,
                "title": "c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(1)\\n\\n![WhatsApp Image 2023-04-28 at 15.45.49.jpg](https://assets.leetcode.com/users/images/ed923236-c384-45a2-af3d-37ab25809c1d_1682677085.3867977.jpeg)\\n\\n# Code\\n```\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    std::vector<int> findDiagonalOrder(std::vector<std::vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        vector<int> ans(m * n);\\n        int index = 0;\\n\\n        int i = 0;\\n        int j = 0;\\n        ans[index++] = mat[i][j];\\n\\n        bool isUp = true;\\n        while(index != ans.size()) {\\n            if(isUp) {\\n                j += 1;\\n\\n                while(j != 0 && i != m - 1) {\\n                    if(j < n) {\\n                        ans[index++] = mat[i][j];\\n                    }\\n                    i++;\\n                    j--;\\n                }\\n\\n                ans[index++] = mat[i][j];\\n                isUp = false;\\n            } else {\\n                i += 1;\\n\\n                while(i != 0 && j != n - 1) {\\n                    if(i < m) {\\n                        ans[index++] = mat[i][j];\\n                    }\\n                    i--;\\n                    j++;\\n                }\\n\\n                ans[index++] = mat[i][j];\\n                isUp = true;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <vector>\\n\\nclass Solution {\\npublic:\\n    std::vector<int> findDiagonalOrder(std::vector<std::vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        vector<int> ans(m * n);\\n        int index = 0;\\n\\n        int i = 0;\\n        int j = 0;\\n        ans[index++] = mat[i][j];\\n\\n        bool isUp = true;\\n        while(index != ans.size()) {\\n            if(isUp) {\\n                j += 1;\\n\\n                while(j != 0 && i != m - 1) {\\n                    if(j < n) {\\n                        ans[index++] = mat[i][j];\\n                    }\\n                    i++;\\n                    j--;\\n                }\\n\\n                ans[index++] = mat[i][j];\\n                isUp = false;\\n            } else {\\n                i += 1;\\n\\n                while(i != 0 && j != n - 1) {\\n                    if(i < m) {\\n                        ans[index++] = mat[i][j];\\n                    }\\n                    i--;\\n                    j++;\\n                }\\n\\n                ans[index++] = mat[i][j];\\n                isUp = true;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3285220,
                "title": "498-time-97-90-and-space-98-87-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize an empty list called result to store the elements in diagonal order.\\n2. Get the dimensions of the matrix, m and n, and set the starting indices i and j to 0. Also initialize a variable direction to 0 to represent the up-right direction.\\n3. Loop through each element in the matrix using a for loop that iterates m * n times. For each iteration, append the current element at index (i, j) to result. Then, check the current direction and update the indices accordingly:\\n    1. If the current direction is up-right (direction == 0):\\nIf we\\'ve reached the right edge of the matrix (j == n - 1), change the direction to down-left (direction = 1) and move down to the next row (i += 1).\\nIf we\\'ve reached the top edge of the matrix (i == 0), change the direction to down-left (direction = 1) and move right to the next column (j += 1).\\nOtherwise, move up one row and right one column (i -= 1 and j += 1).\\n    2. If the current direction is down-left (direction == 1):\\nIf we\\'ve reached the bottom edge of the matrix (i == m - 1), change the direction to up-right (direction = 0) and move right to the next column (j += 1).\\nIf we\\'ve reached the left edge of the matrix (j == 0), change the direction to up-right (direction = 0) and move down to the next row (i += 1).\\nOtherwise, move down one row and left one column (i += 1 and j -= 1).\\n4. After the loop completes, return result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n    # Step 1\\n    result = []\\n    # Step 2\\n    m, n = len(mat), len(mat[0])\\n    i = j = direction = 0\\n    \\n    # Step 3\\n    for _ in range(m * n):\\n        result.append(mat[i][j])\\n        \\n        if direction == 0: # Up-right direction\\n            if j == n - 1:\\n                direction = 1 # Change direction to down-left\\n                i += 1\\n            elif i == 0:\\n                direction = 1 # Change direction to down-left\\n                j += 1\\n            else:\\n                i -= 1\\n                j += 1\\n        else: # Down-left direction\\n            if i == m - 1:\\n                direction = 0 # Change direction to up-right\\n                j += 1\\n            elif j == 0:\\n                direction = 0 # Change direction to up-right\\n                i += 1\\n            else:\\n                i += 1\\n                j -= 1\\n    \\n    # Step 4\\n    return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n  def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n    # Step 1\\n    result = []\\n    # Step 2\\n    m, n = len(mat), len(mat[0])\\n    i = j = direction = 0\\n    \\n    # Step 3\\n    for _ in range(m * n):\\n        result.append(mat[i][j])\\n        \\n        if direction == 0: # Up-right direction\\n            if j == n - 1:\\n                direction = 1 # Change direction to down-left\\n                i += 1\\n            elif i == 0:\\n                direction = 1 # Change direction to down-left\\n                j += 1\\n            else:\\n                i -= 1\\n                j += 1\\n        else: # Down-left direction\\n            if i == m - 1:\\n                direction = 0 # Change direction to up-right\\n                j += 1\\n            elif j == 0:\\n                direction = 0 # Change direction to up-right\\n                i += 1\\n            else:\\n                i += 1\\n                j -= 1\\n    \\n    # Step 4\\n    return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500074,
                "title": "c-index-sum-is-same-for-all-element-in-a-diagonal",
                "content": "```\\nclass Solution {\\npublic:\\n    int r , c ;\\n    vector<int> findDiagonalOrder(vector<vector<int>>& grid ) {\\n        \\n        map<int,vector<int>> mpp ;\\n        r = grid.size() , c = grid[0].size() ;\\n        \\n        for(int i = 0 ; i < r ; ++i ){\\n            for(int j = 0 ; j < c ; ++j ){\\n                int sum = i + j ;\\n                mpp[sum].push_back(grid[i][j]) ;\\n            }\\n        }\\n        \\n        vector<int> ans ;\\n        for(auto &x : mpp){\\n            if(x.first % 2 == 0)\\n                //print in reverse fashion\\n                for(int i = x.second.size() - 1 ; i >= 0 ; --i) ans.push_back(x.second[i]) ;\\n                \\n            else\\n                //print in normal order\\n                for(int i = 0 ; i < x.second.size() ; ++i ) ans.push_back(x.second[i]) ;\\n            \\n        }\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int r , c ;\\n    vector<int> findDiagonalOrder(vector<vector<int>>& grid ) {\\n        \\n        map<int,vector<int>> mpp ;\\n        r = grid.size() , c = grid[0].size() ;\\n        \\n        for(int i = 0 ; i < r ; ++i ){\\n            for(int j = 0 ; j < c ; ++j ){\\n                int sum = i + j ;\\n                mpp[sum].push_back(grid[i][j]) ;\\n            }\\n        }\\n        \\n        vector<int> ans ;\\n        for(auto &x : mpp){\\n            if(x.first % 2 == 0)\\n                //print in reverse fashion\\n                for(int i = x.second.size() - 1 ; i >= 0 ; --i) ans.push_back(x.second[i]) ;\\n                \\n            else\\n                //print in normal order\\n                for(int i = 0 ; i < x.second.size() ; ++i ) ans.push_back(x.second[i]) ;\\n            \\n        }\\n        \\n        return ans ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610797,
                "title": "python-no-direction-checking",
                "content": "using idea where each diagonal sum of row and col index is always the same\\n\\n```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        dic = collections.defaultdict(list)\\n        m,n = len(mat), len(mat[0])\\n        for i in range(m):\\n            for j in range(n):\\n                dic[i+j].append(mat[i][j])\\n                \\n        res = []\\n        \\n        direction = -1\\n        \\n        for num in range(n*m):\\n            res.extend(dic[num][::direction])\\n            direction*=-1\\n    \\n        return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        dic = collections.defaultdict(list)\\n        m,n = len(mat), len(mat[0])\\n        for i in range(m):\\n            for j in range(n):\\n                dic[i+j].append(mat[i][j])\\n                \\n        res = []\\n        \\n        direction = -1\\n        \\n        for num in range(n*m):\\n            res.extend(dic[num][::direction])\\n            direction*=-1\\n    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604791,
                "title": "java-easy-implementation-with-comment-explanation",
                "content": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        if (mat.length == 0) return new int[0];\\n        \\n        int i = 0;\\n        int j = 0;\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[] result = new int[m * n];\\n        \\n        for (int k = 0;k < result.length;k++){\\n            result[k] = mat[i][j];\\n            //all sum diagonal values will be even \\n            // left to right [0,0], [1,1], [2,2]\\n            // right to left [2,0], [1,1], [0,2]\\n            if ((i + j) % 2 == 0){ // moving up\\n                if (j == (n-1)) i++; //reached the column bound, move the row\\n                else if(i == 0) j++;    //reaching up and we have to move the column\\n                else {                  //from left, going up decrement row, increment column\\n                    i--; \\n                    j++;\\n                }\\n            }\\n            else{\\n                if (i == (m-1)) j++;    //hit the row bound, increment column\\n                else if(j == 0) i++;   // column bound, increment row\\n                else {                 //from right, going down increment row, decrement column\\n                    i++;\\n                    j--;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        if (mat.length == 0) return new int[0];\\n        \\n        int i = 0;\\n        int j = 0;\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int[] result = new int[m * n];\\n        \\n        for (int k = 0;k < result.length;k++){\\n            result[k] = mat[i][j];\\n            //all sum diagonal values will be even \\n            // left to right [0,0], [1,1], [2,2]\\n            // right to left [2,0], [1,1], [0,2]\\n            if ((i + j) % 2 == 0){ // moving up\\n                if (j == (n-1)) i++; //reached the column bound, move the row\\n                else if(i == 0) j++;    //reaching up and we have to move the column\\n                else {                  //from left, going up decrement row, increment column\\n                    i--; \\n                    j++;\\n                }\\n            }\\n            else{\\n                if (i == (m-1)) j++;    //hit the row bound, increment column\\n                else if(j == 0) i++;   // column bound, increment row\\n                else {                 //from right, going down increment row, decrement column\\n                    i++;\\n                    j--;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262175,
                "title": "c-straightforward-solution",
                "content": "```\\npublic class Solution {\\n    public int[] FindDiagonalOrder(int[][] mat) {\\n        List<int> res = new List<int>();\\n        int x = 0;\\n        int y = 0;\\n        while(x < mat.Length-1 || y < mat[0].Length-1)\\n        {\\n            res.Add(mat[x][y]);\\n            if((x+y) % 2 == 0)\\n            {//GO UP\\n                \\n                if(y < mat[0].Length-1)\\n                {\\n                    y++;\\n                    if(x > 0) x--;\\n                }\\n                else\\n                {\\n                    x++;\\n                }\\n            }\\n            else\\n            {//GO DOWN\\n                if(x < mat.Length-1)\\n                {\\n                    x++;\\n                    if(y > 0) y--;\\n                }\\n                else\\n                {\\n                    y++;\\n                }\\n            }\\n        }\\n        res.Add(mat[x][y]);\\n        return res.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] FindDiagonalOrder(int[][] mat) {\\n        List<int> res = new List<int>();\\n        int x = 0;\\n        int y = 0;\\n        while(x < mat.Length-1 || y < mat[0].Length-1)\\n        {\\n            res.Add(mat[x][y]);\\n            if((x+y) % 2 == 0)\\n            {//GO UP\\n                \\n                if(y < mat[0].Length-1)\\n                {\\n                    y++;\\n                    if(x > 0) x--;\\n                }\\n                else\\n                {\\n                    x++;\\n                }\\n            }\\n            else\\n            {//GO DOWN\\n                if(x < mat.Length-1)\\n                {\\n                    x++;\\n                    if(y > 0) y--;\\n                }\\n                else\\n                {\\n                    y++;\\n                }\\n            }\\n        }\\n        res.Add(mat[x][y]);\\n        return res.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258703,
                "title": "c-using-adjacency-list-and-reverse",
                "content": "**Part 2-> 1424. Diagonal Traverse II**\\n\\n**Question link ->**  https://leetcode.com/problems/diagonal-traverse-ii/\\n\\n**Solution link->** https://leetcode.com/problems/diagonal-traverse-ii/discuss/1258784/C%2B%2B-using-adjacency-list-and-reverse\\n\\n```\\n\\nclass Solution {\\n   public:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size(),k=0;\\n        vector<vector<int>>temp(m+n);\\n        vector<int>ans;\\n\\t\\t\\n\\t\\t// convert mat into adjacency list and keep value in temp\\n\\t\\t\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                temp[i+j].push_back(mat[i][j]);\\n            }\\n        }\\n\\t\\t\\n\\t\\t// here we reverse matrix\\n\\t\\t\\n        for(int i=0;i<m+n;i++){\\n            if(i%2==0){\\n                reverse(temp[i].begin(),temp[i].end());\\n            }\\n        }\\n\\t\\t\\n\\t\\t// all value  of temp in ans vector\\n\\t\\t\\n        for(int i=0;i<m+n;i++){\\n            for(int j=0;j<temp[i].size();j++){\\n                ans.push_back(temp[i][j]);\\n            }\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\n   public:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size(),k=0;\\n        vector<vector<int>>temp(m+n);\\n        vector<int>ans;\\n\\t\\t\\n\\t\\t// convert mat into adjacency list and keep value in temp\\n\\t\\t\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                temp[i+j].push_back(mat[i][j]);\\n            }\\n        }\\n\\t\\t\\n\\t\\t// here we reverse matrix\\n\\t\\t\\n        for(int i=0;i<m+n;i++){\\n            if(i%2==0){\\n                reverse(temp[i].begin(),temp[i].end());\\n            }\\n        }\\n\\t\\t\\n\\t\\t// all value  of temp in ans vector\\n\\t\\t\\n        for(int i=0;i<m+n;i++){\\n            for(int j=0;j<temp[i].size();j++){\\n                ans.push_back(temp[i][j]);\\n            }\\n         }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233078,
                "title": "c-easy-simple-clean-solution",
                "content": "```\\nvector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        map<int,vector<int>> mp;\\n        for(int i=0; i<mat.size(); i++)\\n            for(int j=0; j<mat[i].size(); j++)\\n                mp[i+j].push_back(mat[i][j]);\\n        vector<int> res;\\n        int level = 0;\\n        for(auto& [k, v] : mp){\\n            if(level%2)\\n                copy(v.begin(), v.end(), back_inserter(res));\\n            else\\n                copy(v.rbegin(), v.rend(), back_inserter(res));\\n            level++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        map<int,vector<int>> mp;\\n        for(int i=0; i<mat.size(); i++)\\n            for(int j=0; j<mat[i].size(); j++)\\n                mp[i+j].push_back(mat[i][j]);\\n        vector<int> res;\\n        int level = 0;\\n        for(auto& [k, v] : mp){\\n            if(level%2)\\n                copy(v.begin(), v.end(), back_inserter(res));\\n            else\\n                copy(v.rbegin(), v.rend(), back_inserter(res));\\n            level++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 893704,
                "title": "python3-easy-to-understand",
                "content": "## Python 3 solution (EASY TO UNDERSTAND)\\n- First store the rows and columns count on a variable like this so that we can use this later\\n```python\\na = [[1,2,3],\\n     [4,5,6],\\n     [7,8,9]]\\nrows, col = len(a), len(a[0])\\nprint(f\\'Row = {rows}, columns = {col}\\')\\n```\\n- Now we need to get the diagonals in the matrix. If you look closely the result is once forward pass on diagonals then a reverse pass on the diagonals. So first make a dictionary containing all the diagonal paths in the matrix\\n```python\\ndiag = collections.defaultdict(list)\\nfor row in range(rows):\\n    for _col in range(col):\\n        diag[row + _col].append(a[row][_col])\\nprint(diag)\\n```\\n\\nFor `a = [[1,2,3], [4,5,6], [7,8,9]]`  matrix the diag dictionary would become `defaultdict(<class \\'list\\'>, {0: [1], 1: [2, 4], 2: [3, 5, 7], 3: [6, 8], 4: [9]})`\\n\\nLet\\'s see this nicely\\n```\\nfor indx, data in enumerate(diag.values()):\\n    print(f\\'indx:{indx}, data:{data}\\')\\n```\\n\\n```plain text\\nindx:0, data:[1]\\nindx:1, data:[2, 4]\\nindx:2, data:[3, 5, 7]\\nindx:3, data:[6, 8]\\nindx:4, data:[9]\\n```\\n- If you look at the diagonal travarsal you can see that once every alternating step we travel in reverse order. So for indx 0 we travel in say this direction then we switch to opposite direction in the next step.\\n- So for each index that is divisible by 2 we can reverse the `diag` and append that to the result.\\n```python\\noutput = []\\nfor index, data in enumerate(diag.values()):\\n        if index % 2 ==0:\\n            output.extend(reversed(diag[index]))\\n        else:\\n            output.extend(diag[index])\\n```\\n#### Now putting it back altogether\\n\\n```python\\nimport collections\\n\\nclass Solution(object):\\n    def findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not matrix: return []\\n        rows, col = len(matrix), len(matrix[0])\\n\\n        output = []\\n        diag = collections.defaultdict(list)\\n\\n        for row in range(rows):\\n            for _col in range(col):\\n                diag[row + _col].append(matrix[row][_col])\\n\\n        for index, data in enumerate(diag.values()):\\n            if index % 2 ==0:\\n                output.extend(reversed(diag[index]))\\n            else:\\n                output.extend(diag[index])\\n\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\na = [[1,2,3],\\n     [4,5,6],\\n     [7,8,9]]\\nrows, col = len(a), len(a[0])\\nprint(f\\'Row = {rows}, columns = {col}\\')\\n```\n```python\\ndiag = collections.defaultdict(list)\\nfor row in range(rows):\\n    for _col in range(col):\\n        diag[row + _col].append(a[row][_col])\\nprint(diag)\\n```\n```\\nfor indx, data in enumerate(diag.values()):\\n    print(f\\'indx:{indx}, data:{data}\\')\\n```\n```plain text\\nindx:0, data:[1]\\nindx:1, data:[2, 4]\\nindx:2, data:[3, 5, 7]\\nindx:3, data:[6, 8]\\nindx:4, data:[9]\\n```\n```python\\noutput = []\\nfor index, data in enumerate(diag.values()):\\n        if index % 2 ==0:\\n            output.extend(reversed(diag[index]))\\n        else:\\n            output.extend(diag[index])\\n```\n```python\\nimport collections\\n\\nclass Solution(object):\\n    def findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not matrix: return []\\n        rows, col = len(matrix), len(matrix[0])\\n\\n        output = []\\n        diag = collections.defaultdict(list)\\n\\n        for row in range(rows):\\n            for _col in range(col):\\n                diag[row + _col].append(matrix[row][_col])\\n\\n        for index, data in enumerate(diag.values()):\\n            if index % 2 ==0:\\n                output.extend(reversed(diag[index]))\\n            else:\\n                output.extend(diag[index])\\n\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718953,
                "title": "javascript-easy-simple-solution",
                "content": "```\\nvar findDiagonalOrder = function(matrix) {\\n    if (matrix.length===0 || matrix[0].length==0) return [];\\n    let rows = matrix.length;\\n    let columns = matrix[0].length;\\n    let results = new Array(rows+columns-1);\\n    for (let i =0;i<rows;i++) {\\n      for (let j =0;j<columns;j++) {\\n        if (!results[i+j]) results[i+j] = [];\\n          results[i+j].push(matrix[i][j]);\\n      }\\n    }\\n    for (i=0;i<(rows+columns-1);i=i+2) {\\n        if (i%2 === 0) results[i] = results[i].reverse();\\n    }\\n    return results.flat()\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findDiagonalOrder = function(matrix) {\\n    if (matrix.length===0 || matrix[0].length==0) return [];\\n    let rows = matrix.length;\\n    let columns = matrix[0].length;\\n    let results = new Array(rows+columns-1);\\n    for (let i =0;i<rows;i++) {\\n      for (let j =0;j<columns;j++) {\\n        if (!results[i+j]) results[i+j] = [];\\n          results[i+j].push(matrix[i][j]);\\n      }\\n    }\\n    for (i=0;i<(rows+columns-1);i=i+2) {\\n        if (i%2 === 0) results[i] = results[i].reverse();\\n    }\\n    return results.flat()\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 423921,
                "title": "java-o-mn-with-easy-explanation-and-avoiding-common-mistakes",
                "content": "1. We can choose a directions flag to determine which direction we are moving. Up = 1 and down = -1\\n1. When we are moving up. \\n\\t* \\tIf we overshoot the array from last column then we should change direction and increase row.\\n\\t*   If we overshoot the array from first column then we should change direction and increase. Then we need to increase columns. However its a common mistake if we make a check on row == 0 before column == last. In that case we will end up increasing column by 1 and it might end up taking us to last column.\\n\\t*   If we are not overshooting then simply increase column by 1 and decrease row by 1.\\n1. Repeat the similar algo when we are moving down. i.r dir = -1\\n1. Time Complexity: O(mn)\\n1. Space Complexity: O(1).\\n\\nFor interviews and DS Algo tips you can follow me on https://twitter.com/Jaspind07199761\\nor connect on https://www.linkedin.com/in/jaspindersingh1/\\n\\n```\\nclass Solution {\\n   public int[] findDiagonalOrder(int[][] matrix) {\\n       if(matrix == null || matrix.length == 0) return new int[0];\\n       int m = matrix.length;\\n       int n = matrix[0].length;\\n       int [] result = new int[m*n];\\n       int r = 0, c = 0;\\n       int i = 0;\\n       int dir = 1;\\n       while(i < m*n){\\n           result[i] = matrix[r][c];\\n           if(dir == 1){ \\n               if(c==n-1) {\\n                   r++;\\n                   dir = -1;\\n               } else if (r==0) { \\n\\t\\t\\t   //common mistake if r == 0 is checked before c== n-1\\n                   c++;\\n                   dir = -1;\\n               } else{\\n                   r--; \\n                   c++;\\n               }\\n           } else {\\n               if(r == m-1) {\\n                   c++;\\n                   dir = 1;\\n               } else if(c==0) {\\n                   r++;\\n                   dir = 1;\\n               } else {\\n                   r++; c--;\\n               }\\n           }\\n           i++;\\n       }\\n       return result;\\n   }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public int[] findDiagonalOrder(int[][] matrix) {\\n       if(matrix == null || matrix.length == 0) return new int[0];\\n       int m = matrix.length;\\n       int n = matrix[0].length;\\n       int [] result = new int[m*n];\\n       int r = 0, c = 0;\\n       int i = 0;\\n       int dir = 1;\\n       while(i < m*n){\\n           result[i] = matrix[r][c];\\n           if(dir == 1){ \\n               if(c==n-1) {\\n                   r++;\\n                   dir = -1;\\n               } else if (r==0) { \\n\\t\\t\\t   //common mistake if r == 0 is checked before c== n-1\\n                   c++;\\n                   dir = -1;\\n               } else{\\n                   r--; \\n                   c++;\\n               }\\n           } else {\\n               if(r == m-1) {\\n                   c++;\\n                   dir = 1;\\n               } else if(c==0) {\\n                   r++;\\n                   dir = 1;\\n               } else {\\n                   r++; c--;\\n               }\\n           }\\n           i++;\\n       }\\n       return result;\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272114,
                "title": "simple-python-solution-with-comments",
                "content": "Key observation is that the sum of indices along diagonals are identical.\\n- The first step is to build a `map` where keys are the sum of indices and values are lists of the numbers across each diagonal. The smallest key in `map` will always be 0, the largest key will always be `M - 1 + N - 1`. \\n- The second step is to populate `map` by iterating over `matrix` and appending  each `val` to its respective `map[i + j]` list. \\n- The third step is to invert the order of each list in `matrix` where its key value is divisible by two. This is done in order to return the correct directional traversal as shown in the provided image.\\n- The last step is to populate `res` from `map`.\\n\\n```\\nclass Solution:\\n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = []\\n        if not matrix:\\n            return res\\n\\n        # group values in matrix by the sum of their indices in a map\\n        map = {}\\n        for i in range(len(matrix) + len(matrix[0]) - 1):\\n            map[i] = []\\n\\n        # populate the map\\n        for i, row in enumerate(matrix):\\n            for j, val in enumerate(row):\\n                map[i + j].append(val)\\n\\n        # iterate through map and reverse values where key is divisible by two\\n        for k, v in map.items():\\n            if k % 2 == 0:\\n                map[k] = v[::-1]\\n        \\n        # populate output\\n        for v in map.values():\\n            for val in v:\\n                res.append(val)\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\\n        res = []\\n        if not matrix:\\n            return res\\n\\n        # group values in matrix by the sum of their indices in a map\\n        map = {}\\n        for i in range(len(matrix) + len(matrix[0]) - 1):\\n            map[i] = []\\n\\n        # populate the map\\n        for i, row in enumerate(matrix):\\n            for j, val in enumerate(row):\\n                map[i + j].append(val)\\n\\n        # iterate through map and reverse values where key is divisible by two\\n        for k, v in map.items():\\n            if k % 2 == 0:\\n                map[k] = v[::-1]\\n        \\n        # populate output\\n        for v in map.values():\\n            for val in v:\\n                res.append(val)\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 162294,
                "title": "reasonably-readable-javascript-solution",
                "content": "Here\\'s my original Javascript solution. The idea is simple: when we hit a wall, reverse direction. If we hit more than one wall, we perform more than one operation.\\n\\nRun time is 96ms, beats 91.8%.\\n\\n```\\nlet findDiagonalOrder = function(matrix) {\\n    function reverse() {\\n        x = -x;\\n        y = -y;\\n    }\\n\\n    if (matrix.length < 1) {\\n        return [];\\n    }\\n\\n    let res = [], row = 0, col = 0, x = 1, y = -1;\\n    while (res.length < matrix.length * matrix[0].length) {\\n        res.push(matrix[col][row]);\\n        row += x;\\n        col += y;\\n        if (col < 0 && row < matrix[0].length) {\\n            reverse();\\n            col = 0;\\n        }\\n        if (row < 0 && col < matrix.length) {\\n            reverse();\\n            row = 0;\\n        }\\n        if (row >= matrix[0].length) {\\n            reverse();\\n            col += 2 * y;\\n            --row;\\n        }\\n        if (col >= matrix.length) {\\n            reverse();\\n            row += 2 * x;\\n            --col;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet findDiagonalOrder = function(matrix) {\\n    function reverse() {\\n        x = -x;\\n        y = -y;\\n    }\\n\\n    if (matrix.length < 1) {\\n        return [];\\n    }\\n\\n    let res = [], row = 0, col = 0, x = 1, y = -1;\\n    while (res.length < matrix.length * matrix[0].length) {\\n        res.push(matrix[col][row]);\\n        row += x;\\n        col += y;\\n        if (col < 0 && row < matrix[0].length) {\\n            reverse();\\n            col = 0;\\n        }\\n        if (row < 0 && col < matrix.length) {\\n            reverse();\\n            row = 0;\\n        }\\n        if (row >= matrix[0].length) {\\n            reverse();\\n            col += 2 * y;\\n            --row;\\n        }\\n        if (col >= matrix.length) {\\n            reverse();\\n            row += 2 * x;\\n            --col;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 97756,
                "title": "java-solution-easy-to-understand-o-n-7ms",
                "content": "There are two key points.\\nFirst, in each path, index **row + col == sum**. sum is some constant looping from 0 to totalRow + totalCol.\\nSecond, the boundary of row and col is either sum or four edges.  Four edges correspond to row == 0 || **row == totalRow - 1** || col == 0 || **col == totalCol - 1**.\\n\\nif{ } block is the only thing we need to figure out. The two tricky parts are \"**rr = Math.min(sum, r-1)**\" and \"**while(rr >= 00 && cc < c)**\" as I commented in the code.\\n```\\npublic class Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if(matrix.length == 0)\\n            return new int[0];\\n        int c = matrix[0].length, r = matrix.length;\\n        int[] res = new int[r*c];\\n        boolean flip = true;\\n        int count = 0;\\n        for(int sum = 0; sum <= r + c - 2; sum++){\\n            int rr,cc;\\n            if(flip == true){                               // Direction: to up-right\\n                rr = Math.min(sum, r-1);                    // if before diagonal, rr = sum; else rr = r-1\\n                cc = sum - rr;\\n                while(rr >= 00 && cc < c)                   // reach matrix upper or right bound\\n                    res[count++] = matrix[rr--][cc++];\\n            }\\n            else{                                           // Direction: to bottom-left\\n                cc = Math.min(sum, c-1);                    // if before diagonal, cc = sum; else cc = c-1\\n                rr = sum - cc;\\n                while(cc >= 00 && rr < r)                   // reach matrix bottom or left bound\\n                    res[count++] = matrix[rr++][cc--];\\n            }\\n            flip = !flip;           \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if(matrix.length == 0)\\n            return new int[0];\\n        int c = matrix[0].length, r = matrix.length;\\n        int[] res = new int[r*c];\\n        boolean flip = true;\\n        int count = 0;\\n        for(int sum = 0; sum <= r + c - 2; sum++){\\n            int rr,cc;\\n            if(flip == true){                               // Direction: to up-right\\n                rr = Math.min(sum, r-1);                    // if before diagonal, rr = sum; else rr = r-1\\n                cc = sum - rr;\\n                while(rr >= 00 && cc < c)                   // reach matrix upper or right bound\\n                    res[count++] = matrix[rr--][cc++];\\n            }\\n            else{                                           // Direction: to bottom-left\\n                cc = Math.min(sum, c-1);                    // if before diagonal, cc = sum; else cc = c-1\\n                rr = sum - cc;\\n                while(cc >= 00 && rr < r)                   // reach matrix bottom or left bound\\n                    res[count++] = matrix[rr++][cc--];\\n            }\\n            flip = !flip;           \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 97751,
                "title": "my-8ms-short-solution-9line",
                "content": "```\\npublic int[] findDiagonalOrder(int[][] matrix) {\\n\\tif (matrix.length == 0) return new int[0];\\n\\tint h = matrix.length, w = matrix[0].length, id = 0;\\n\\tint[] res  = new int[h*w];\\n\\tfor (int i = 0; i < h+w; i++) {\\n\\t\\t// find lower bound and upper bound\\n\\t\\tint lb = (int)Math.max(0, i-w+1), ub = (int)Math.min(i,h-1);\\n\\t\\tif (i%2 == 0) for (int j = ub; j >= lb; j--) res[id++] = matrix[j][i-j];\\n\\t\\telse for (int j = lb;j <= ub; j++) res[id++] = matrix[j][i-j];\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] findDiagonalOrder(int[][] matrix) {\\n\\tif (matrix.length == 0) return new int[0];\\n\\tint h = matrix.length, w = matrix[0].length, id = 0;\\n\\tint[] res  = new int[h*w];\\n\\tfor (int i = 0; i < h+w; i++) {\\n\\t\\t// find lower bound and upper bound\\n\\t\\tint lb = (int)Math.max(0, i-w+1), ub = (int)Math.min(i,h-1);\\n\\t\\tif (i%2 == 0) for (int j = ub; j >= lb; j--) res[id++] = matrix[j][i-j];\\n\\t\\telse for (int j = lb;j <= ub; j++) res[id++] = matrix[j][i-j];\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3336354,
                "title": "c-solution-with-and-without-using-map",
                "content": "# Approach 1\\nThis is the simplest of the two approaches :\\n**`On careful observation we can see that on any diagonal the sum of indices for all the elements is same`**. Make a map with the key as the sum of indices and store a vector corresponding to the key value.\\n`Ordered map` shall be used as we need to store the keys in a sorted order.\\nAlso if we observe carefully we can see that for upward diagonal the upper element would be stored first, so for that we will need to traverse the vector from the end.\\n# Complexity\\n- Time complexity:\\nO(N*N Log(N))\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int row = mat.size();\\n        int col = mat[0].size();\\n        vector <int> ans;\\n        map <int,vector<int>> mp;\\n        \\n        for( int i = 0; i < row; i++ ){\\n            for( int j = 0; j < col; j++ ){\\n                mp[i+j].push_back(mat[i][j]);\\n            }\\n        }\\n\\n        for( auto it : mp ){\\n            if( it.first % 2 == 0 ){\\n                for(int j = it.second.size() - 1; j >= 0; j-- ){\\n                    ans.push_back(it.second[j]);\\n                }\\n            }\\n            else{\\n                for( int j = 0; j < it.second.size(); j++ ){\\n                    ans.push_back(it.second[j]);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```\\n# Approach 2\\nSet up a boolean variable to check whether you need to go up or down.\\nHere you will need to take care of exiting the matrix. Let\\'s talk about while we are going up :\\n1) We could have reached the c + 1 column\\n2) We could have reached -1st row.\\n\\nIn the first case we need to increase the rows by 2 and decrease the column by 1.\\nIn the second case only the row need to be incremented by 1.\\nIn either case set boolean to false to go in the opposite direction next.\\n# Complexity\\n- Time complexity:\\nO(N*N)\\n\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        bool up = true;\\n        int row = mat.size(), col = mat[0].size();\\n        int r = 0, c = 0;\\n        vector<int> ans;\\n        while( r < row && c < col ){\\n\\n            if( up ){\\n                ans.push_back(mat[r][c]);\\n                c += 1;\\n                r -= 1;\\n                if( (c == col) ){\\n                    r += 2;\\n                    c -= 1;\\n                    up = false;\\n                }\\n                else if( r < 0 ){\\n                    r += 1;\\n                    up = false;\\n                }\\n            }\\n            else{\\n                ans.push_back(mat[r][c]);\\n                c -= 1;\\n                r += 1;\\n                if( (r == row) ){\\n                    c += 2;\\n                    r -= 1;\\n                    up = true;\\n                }\\n                else if( c < 0 ){\\n                    c += 1;\\n                    up = true;\\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int row = mat.size();\\n        int col = mat[0].size();\\n        vector <int> ans;\\n        map <int,vector<int>> mp;\\n        \\n        for( int i = 0; i < row; i++ ){\\n            for( int j = 0; j < col; j++ ){\\n                mp[i+j].push_back(mat[i][j]);\\n            }\\n        }\\n\\n        for( auto it : mp ){\\n            if( it.first % 2 == 0 ){\\n                for(int j = it.second.size() - 1; j >= 0; j-- ){\\n                    ans.push_back(it.second[j]);\\n                }\\n            }\\n            else{\\n                for( int j = 0; j < it.second.size(); j++ ){\\n                    ans.push_back(it.second[j]);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        bool up = true;\\n        int row = mat.size(), col = mat[0].size();\\n        int r = 0, c = 0;\\n        vector<int> ans;\\n        while( r < row && c < col ){\\n\\n            if( up ){\\n                ans.push_back(mat[r][c]);\\n                c += 1;\\n                r -= 1;\\n                if( (c == col) ){\\n                    r += 2;\\n                    c -= 1;\\n                    up = false;\\n                }\\n                else if( r < 0 ){\\n                    r += 1;\\n                    up = false;\\n                }\\n            }\\n            else{\\n                ans.push_back(mat[r][c]);\\n                c -= 1;\\n                r += 1;\\n                if( (r == row) ){\\n                    c += 2;\\n                    r -= 1;\\n                    up = true;\\n                }\\n                else if( c < 0 ){\\n                    c += 1;\\n                    up = true;\\n                }\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222555,
                "title": "faang-approach-well-commented-self-explanatory-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n      int m=mat.size(); \\n      int n=mat[0].size();\\n      int row=0;\\n      int col=0;\\n      bool up=true;\\n      //The above are some intilisations;\\n      vector<int>result;\\n      while(row<m and col<n){\\n          if(up==true){\\n              //when we are moving in the up direction\\n              while(row>0 and col<n-1){\\n               result.push_back(mat[row][col]);\\n               row--;\\n               col++;\\n              }\\n              result.push_back(mat[row][col]);\\n              if(col==n-1){\\n                  row++;\\n              }\\n              else{\\n                  col++;\\n              }\\n          }\\n         else{\\n             //when we are moving in the down direction\\n             while(col>0 and row<m-1){\\n                 result.push_back(mat[row][col]);\\n                 row++;\\n                 col--;\\n             }\\n             result.push_back(mat[row][col]);\\n             if(row==m-1){\\n                 col++;\\n             }\\n             else{\\n                 row++;\\n             }\\n         }\\n         up=!up; //reversing the condition to move in alternate direction\\n      }\\n    return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n      int m=mat.size(); \\n      int n=mat[0].size();\\n      int row=0;\\n      int col=0;\\n      bool up=true;\\n      //The above are some intilisations;\\n      vector<int>result;\\n      while(row<m and col<n){\\n          if(up==true){\\n              //when we are moving in the up direction\\n              while(row>0 and col<n-1){\\n               result.push_back(mat[row][col]);\\n               row--;\\n               col++;\\n              }\\n              result.push_back(mat[row][col]);\\n              if(col==n-1){\\n                  row++;\\n              }\\n              else{\\n                  col++;\\n              }\\n          }\\n         else{\\n             //when we are moving in the down direction\\n             while(col>0 and row<m-1){\\n                 result.push_back(mat[row][col]);\\n                 row++;\\n                 col--;\\n             }\\n             result.push_back(mat[row][col]);\\n             if(row==m-1){\\n                 col++;\\n             }\\n             else{\\n                 row++;\\n             }\\n         }\\n         up=!up; //reversing the condition to move in alternate direction\\n      }\\n    return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2346356,
                "title": "simple-java-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\n    int index=0;\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        \\n        int n=mat.length;\\n        int m=mat[0].length;\\n        int ans[]=new int[n*m];\\n        int id=0;\\n        for(int i=0;i<m;i++){\\n            \\n            int prev=index;\\n                increment(mat,0,i,ans);\\n            if(id%2==0){\\n                rverese(ans, prev, index-1);\\n            }\\n            id++;\\n        }\\n        for(int i=1;i<n;i++){\\n            int prev=index;\\n            increment(mat,i,m-1,ans);\\n             if(id%2==0){\\n                rverese(ans, prev, index-1);\\n            }\\n            id++;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n    public void increment(int[][] mat,int i,int j,int[] ans){\\n        while(i>=0 && i<mat.length && j>=0 && j<mat[i].length){\\n            ans[index++]=mat[i][j];\\n            i++;\\n            j--;\\n        }\\n    }\\n    public void rverese(int arr[], int start, int end)\\n{\\n    while (start < end)\\n    {\\n        int temp = arr[start];\\n        arr[start] = arr[end];\\n        arr[end] = temp;\\n        start++;\\n        end--;\\n    }\\n}   \\n    \\n}\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    int index=0;\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        \\n        int n=mat.length;\\n        int m=mat[0].length;\\n        int ans[]=new int[n*m];\\n        int id=0;\\n        for(int i=0;i<m;i++){\\n            \\n            int prev=index;\\n                increment(mat,0,i,ans);\\n            if(id%2==0){\\n                rverese(ans, prev, index-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1318667,
                "title": "swift-diagonal-traverse-test-cases",
                "content": "```swift\\nclass Solution {\\n    func findDiagonalOrder(_ mat: [[Int]]) -> [Int] {\\n        let c = mat.count, n = mat.first?.count ?? 0\\n        guard c > 0 && n > 0 else { return [] }\\n        var res = [Int](), fromTop = false\\n        \\n        for sum in 0...(c + n - 2) {\\n            let arr = Array(max(sum - n + 1, 0)...min(c - 1, sum))\\n            for i in fromTop ? arr : arr.reversed() { res.append(mat[i][sum-i]) }\\n            fromTop = !(fromTop)\\n        }\\n        return res\\n    }\\n}\\n```\\n\\n```swift\\nimport XCTest\\n\\n// MARK: Executed 2 tests, with 0 failures (0 unexpected) in 0.009 (0.011) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let res = s.findDiagonalOrder([[1,2,3],[4,5,6],[7,8,9]])\\n        XCTAssertEqual(res, [1,2,4,7,5,3,6,8,9])\\n    }\\n    func test2() {\\n        let res = s.findDiagonalOrder([[1,2],[3,4]])\\n        XCTAssertEqual(res, [1,2,3,4])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func findDiagonalOrder(_ mat: [[Int]]) -> [Int] {\\n        let c = mat.count, n = mat.first?.count ?? 0\\n        guard c > 0 && n > 0 else { return [] }\\n        var res = [Int](), fromTop = false\\n        \\n        for sum in 0...(c + n - 2) {\\n            let arr = Array(max(sum - n + 1, 0)...min(c - 1, sum))\\n            for i in fromTop ? arr : arr.reversed() { res.append(mat[i][sum-i]) }\\n            fromTop = !(fromTop)\\n        }\\n        return res\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// MARK: Executed 2 tests, with 0 failures (0 unexpected) in 0.009 (0.011) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test1() {\\n        let res = s.findDiagonalOrder([[1,2,3],[4,5,6],[7,8,9]])\\n        XCTAssertEqual(res, [1,2,4,7,5,3,6,8,9])\\n    }\\n    func test2() {\\n        let res = s.findDiagonalOrder([[1,2],[3,4]])\\n        XCTAssertEqual(res, [1,2,3,4])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1073456,
                "title": "javascript-solution",
                "content": "```\\nvar findDiagonalOrder = function(matrix) {\\n    const traversed = [];\\n    const obj = {};\\n    for (let i = 0; i < matrix.length; i++) {\\n        for(let j = 0; j < matrix[0].length; j++) {\\n            obj[i + j] ? obj[i + j].push(matrix[i][j]) : obj[i + j] = [matrix[i][j]];\\n        }\\n    }\\n    Object.keys(obj).forEach(key => {\\n        if (+key % 2 === 0) {\\n            traversed.push(...obj[key].reverse());\\n        } else {\\n            traversed.push(...obj[key]);\\n        }\\n    });\\n    return traversed;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findDiagonalOrder = function(matrix) {\\n    const traversed = [];\\n    const obj = {};\\n    for (let i = 0; i < matrix.length; i++) {\\n        for(let j = 0; j < matrix[0].length; j++) {\\n            obj[i + j] ? obj[i + j].push(matrix[i][j]) : obj[i + j] = [matrix[i][j]];\\n        }\\n    }\\n    Object.keys(obj).forEach(key => {\\n        if (+key % 2 === 0) {\\n            traversed.push(...obj[key].reverse());\\n        } else {\\n            traversed.push(...obj[key]);\\n        }\\n    });\\n    return traversed;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 986691,
                "title": "java-bfs-for-diagonal-traverse-with-explanation",
                "content": "The idea behind this approach is that the elements of each diagonal are neighbours of the next one. So, starting from the left top element (the first diagonal) we use BFS approach to find the elements of the next diagonal. \\n\\ni.e. We consider the element at the left top corner of the matrix as the root of our tree for traversal => elements in each level belong to the same diagonal. Hence Breadth First Search.\\n![image](https://assets.leetcode.com/users/images/9542b844-6d07-4105-9769-be4d701ed881_1608954653.1377945.png)\\nAs depicted above, similar to a binary tree, each element will have at most two children (or neighbours here) in the direction of next diagonal. \\n\\nFrom here the question can be viewed as a level order tree traversal. One difference would be that each element can have upto 2 parents here. Hence to avoid considering any element twice, we will use a set to keep track of the elements that have been already considered within a level.\\n\\nWe use an intermediate list ***sub*** in the below code to keep track of the elements in the diagonal. After going through all the elements within the level, we check the direction for traversal and add them to the result array ***ans*** accordingly.\\n**Note:** The representation of an element at row ***r1*** ans column ***c1*** is given by ***(r1\\\\*C)+c1***, where ***C*** is the column length of the matrix. \\n\\n```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        \\n        //check for empty (or null) matrices\\n        if(matrix == null || matrix.length < 1 || matrix[0].length < 1)\\n            return new int[0];\\n        \\n        //get the row and coulumn height of the given matrix\\n        int r = matrix.length;\\n        int c = matrix[0].length;\\n        \\n        //declare the data-structure to store the final result\\n        int[] ans = new int[r*c];\\n        \\n        //queue for BFS traversal\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        \\n        //add the representational index of the first element to both the queue and set\\n        q.add(0);\\n        \\n        //add the first element to the result array\\n        ans[0] = matrix[0][0];\\n        \\n        //a counter for the position of the next element to be added in the result array\\n        int z = 1;\\n        \\n        //direction of the traversal of the diagonal\\n        //intialised to false as we are starting from 2nd diagonal where we traverse down (right to left)\\n        boolean up = false;\\n        \\n        // a 2D array to help find the valid neighbours of current element\\n        int[][] cart = {{1, 0}, {0, 1}};\\n        \\n        \\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            List<Integer> sub = new ArrayList();\\n\\t\\t\\t\\n\\t\\t\\t//a set to avoid an element from being considered more than once\\n\\t\\t\\tSet<Integer> done = new HashSet();\\n            for(int i = 0; i < size; i++)\\n            {\\n                int rep = q.poll();\\n                int r1 = rep / c;\\n                int c1 = rep % c;\\n                for(int[] dir: cart)\\n                {\\n                    //only add to the queue and set if not already covered\\n                    if( ( r1 + dir[0] ) < r && ( c1 + dir[1] ) < c && !done.contains( (r1 + dir[0])*c + (c1 + dir[1]) ) )\\n                    {\\n                        q.add((r1 + dir[0])*c + (c1 + dir[1]));\\n                        done.add((r1 + dir[0])*c + (c1 + dir[1]));\\n                        sub.add( matrix[r1 + dir[0]][c1 + dir[1]]);\\n                    }\\n                }\\n            }\\n            //check direction of traversal\\n            if(up)\\n            {\\n                for(int index = 0; index < sub.size(); index++)\\n                {\\n                    ans[z++] = sub.get(index);\\n                }\\n            }\\n            else\\n            {\\n                for(int index = sub.size()-1; index >= 0; index--)\\n                {\\n                    ans[z++] = sub.get(index);\\n                }\\n            }\\n            //invert direction\\n            up = !up;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nTime Complexity : O(NM)\\nSpace Complexity (excluding result array) : O(Min(N, M))",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        \\n        //check for empty (or null) matrices\\n        if(matrix == null || matrix.length < 1 || matrix[0].length < 1)\\n            return new int[0];\\n        \\n        //get the row and coulumn height of the given matrix\\n        int r = matrix.length;\\n        int c = matrix[0].length;\\n        \\n        //declare the data-structure to store the final result\\n        int[] ans = new int[r*c];\\n        \\n        //queue for BFS traversal\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        \\n        //add the representational index of the first element to both the queue and set\\n        q.add(0);\\n        \\n        //add the first element to the result array\\n        ans[0] = matrix[0][0];\\n        \\n        //a counter for the position of the next element to be added in the result array\\n        int z = 1;\\n        \\n        //direction of the traversal of the diagonal\\n        //intialised to false as we are starting from 2nd diagonal where we traverse down (right to left)\\n        boolean up = false;\\n        \\n        // a 2D array to help find the valid neighbours of current element\\n        int[][] cart = {{1, 0}, {0, 1}};\\n        \\n        \\n        while(!q.isEmpty())\\n        {\\n            int size = q.size();\\n            List<Integer> sub = new ArrayList();\\n\\t\\t\\t\\n\\t\\t\\t//a set to avoid an element from being considered more than once\\n\\t\\t\\tSet<Integer> done = new HashSet();\\n            for(int i = 0; i < size; i++)\\n            {\\n                int rep = q.poll();\\n                int r1 = rep / c;\\n                int c1 = rep % c;\\n                for(int[] dir: cart)\\n                {\\n                    //only add to the queue and set if not already covered\\n                    if( ( r1 + dir[0] ) < r && ( c1 + dir[1] ) < c && !done.contains( (r1 + dir[0])*c + (c1 + dir[1]) ) )\\n                    {\\n                        q.add((r1 + dir[0])*c + (c1 + dir[1]));\\n                        done.add((r1 + dir[0])*c + (c1 + dir[1]));\\n                        sub.add( matrix[r1 + dir[0]][c1 + dir[1]]);\\n                    }\\n                }\\n            }\\n            //check direction of traversal\\n            if(up)\\n            {\\n                for(int index = 0; index < sub.size(); index++)\\n                {\\n                    ans[z++] = sub.get(index);\\n                }\\n            }\\n            else\\n            {\\n                for(int index = sub.size()-1; index >= 0; index--)\\n                {\\n                    ans[z++] = sub.get(index);\\n                }\\n            }\\n            //invert direction\\n            up = !up;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986125,
                "title": "c-linear-solution-explained-98-time-95-space",
                "content": "Initially I decided to tackle this problem with a BFS approach going with diagonal layers in the same order and direction as requested (thus having to organise data in some sort of reversable queue), but I soon realised it was unnecessarily complicated and moved past it, with a lighter approach.\\n\\nIn order to solve this problem, then, discarding a queue, we will need still a few support variables, provided our input is not an empty matrix (in which case we can just return `{}`0:\\n* `len` and `rLen` will be respectively the length of the matrix and the lenght of a row, thus marking our `y` and `x` limits;\\n* `isReverse` is a boolean to keep track of the current parsing direction we need to consider;\\n* `res`, finally, is our accumulator variable that we will go and populate as we progress - already set initially on the right size to avoid needless reallocations.\\n\\nWe will then have a main loop, running with `offset` from `0` up to `len + rLen - 1`, working like this (`*` means nodes currently considered):\\n\\n```cpp\\n* 2 3 // offset == 0\\n4 5 6\\n7 8 9 \\n\\n1 * 3 // offset == 1\\n* 5 6\\n7 8 9 \\n\\n1 2 * // offset == 2\\n4 * 6\\n* 8 9 \\n\\n1 2 3 // offset == 3\\n4 5 *\\n7 * 9 \\n\\n1 2 3 // offset == 4\\n4 5 6\\n7 8 *\\n```\\n\\nIn the same loop, for our convenience, we will also declare a pointer `i` initialised to `0`, which will tell us which cell of `res` we will be writing next.\\n\\nAt each iteration, we will read the matrix depending on the current value of `isReverse`, but with logic staying basically the same:\\n* one coordinate will be set as the minimum between offset and its maximum `- 1` and iterated as long as it is `>= 0`;\\n* the trickier part is with the other coordinate, being set as the maximum between `0` and `offset` minus its current maximum `- 1`, minus the difference between the 2 values of the maximum coordinates (`len` and `rLen`).\\n\\nThe second bit was a bit counter-intuitive to visualise, but I got there proceeding by steps:\\n* first I found a solution that worked until you passed the main diagonal, setting the other coordinate always to 0;\\n* then I realised I need a specular condition (ie: a maximu, instead of a minimum);\\n* when width and height of the matrix were the same, I would just have to set the coordinate to be the minimum between `0` and `offset` minus the relative size (ie: `len` or `rLen`), again minus `1` (since we never reach the full size, using `0`-based indexing);\\n* the final intuition was that this measure would increase or decrease with the difference of `len` and `rLen`, so I ran a couple of test cases to adjust it and came up with a more manageable formula than putting an extra ternay operator to see if we passed the main diagonal or not.\\n\\nAt each iteration we will then assign the value of the cell matching the current coordinates to the current cell of our result variable and increase our pointer: `res[i++] = arr[y][x]`.\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& arr) {\\n        // edge case\\n        if (!arr.size()) return {};\\n        // support variables\\n        int len = arr.size(), rLen = arr[0].size();\\n        bool isReverse = false;\\n        vector<int> res(len * rLen);\\n        // main loop\\n        for (int offset = 0, diag = len + rLen, diff = len - rLen, i = 0; offset < diag; offset++) {\\n            // going north => south and east => west\\n            if (isReverse) {\\n                for (int x = min(rLen - 1, offset), y = max(0, offset - len + 1 + diff); x >= 0 && y < len; x--, y++) res[i++] = arr[y][x];\\n            }\\n            // going south => north and west => east\\n            else {\\n                for (int x = max(0, offset - rLen + 1 - diff), y = min(len - 1, offset); x < rLen && y >= 0; x++, y--) res[i++] = arr[y][x];\\n            }\\n            // flipping direction\\n            isReverse = !isReverse;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "```cpp\\n* 2 3 // offset == 0\\n4 5 6\\n7 8 9 \\n\\n1 * 3 // offset == 1\\n* 5 6\\n7 8 9 \\n\\n1 2 * // offset == 2\\n4 * 6\\n* 8 9 \\n\\n1 2 3 // offset == 3\\n4 5 *\\n7 * 9 \\n\\n1 2 3 // offset == 4\\n4 5 6\\n7 8 *\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& arr) {\\n        // edge case\\n        if (!arr.size()) return {};\\n        // support variables\\n        int len = arr.size(), rLen = arr[0].size();\\n        bool isReverse = false;\\n        vector<int> res(len * rLen);\\n        // main loop\\n        for (int offset = 0, diag = len + rLen, diff = len - rLen, i = 0; offset < diag; offset++) {\\n            // going north => south and east => west\\n            if (isReverse) {\\n                for (int x = min(rLen - 1, offset), y = max(0, offset - len + 1 + diff); x >= 0 && y < len; x--, y++) res[i++] = arr[y][x];\\n            }\\n            // going south => north and west => east\\n            else {\\n                for (int x = max(0, offset - rLen + 1 - diff), y = min(len - 1, offset); x < rLen && y >= 0; x++, y--) res[i++] = arr[y][x];\\n            }\\n            // flipping direction\\n            isReverse = !isReverse;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 977610,
                "title": "java-1ms-beats-100-o-mn-single-pass-explained",
                "content": "\\n```java\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if(matrix.length==0) return new int[0];\\n        boolean up = true;\\n        int rowlen = matrix.length;\\n        int collen = matrix[0].length;\\n        int[] ans = new int[rowlen*collen];\\n        int row = 0;\\n        int col = 0;\\n        int n = 0;\\n        while(n<rowlen*collen){\\n            ans[n] = matrix[row][col];            \\n            ++n; \\n            if(up){\\n                if(col==collen-1){\\n                    up = false;\\n                    ++row;\\n                    continue;\\n                }        \\n                if(row==0){\\n                    up = false;\\n                    ++col;\\n                    continue;\\n                }\\n                //no flips\\n                --row;\\n                ++col;\\n                continue;\\n            }else{\\n                if(row==rowlen-1){\\n                    up = true;\\n                    ++col;\\n                    continue;\\n                }\\n                if(col==0){\\n                    up = true;\\n                    ++row;\\n                    continue;\\n                }\\n                //no flips\\n                ++row;\\n                --col;\\n            }     \\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nThe key things in this qn is to figure out:\\n1. At what condition do we need to flip direction?\\n2. How should the `row` and `col` pointers move at the various conditions?\\n\\n## Conditions to Change Dxn\\n### While moving upwards, flip dxn if:\\n1. `row == 0`, i.e. pointer is at the top row.\\n2. `col == collen-1`, i.e. pointer is at the right edge of the matrix.\\n3.  (1) **and** (2). (e.g. Top right edge of a 3x3 matrix) \\n\\n### How should the pointers move?\\nFor (1), `row` should not change and `col` should move right.\\nFor (2), `row` should go downwards and `col` should not change.\\nFor (3), `row` should go downwards and `col` should not change.\\nBecause (3) is similar to (2), when writing the control flow we place the condition\\n```java\\nif(col==collen-1)\\n```\\nbefore the `row==0` check to avoid repetition.\\n\\n### While moving downwards, flip dxn if:\\n1. `row==rowlen-1`, i.e. pointer is at bottomost row\\n2. `col==0`, i.e. pointer is at left edge of the matrix\\n3. (1) **and** (2) (e.g. bottom-left edge of a 3x3 matrix)\\n\\n### How should the pointers move?\\nFor (1), `row` should not change and `col` should move right.\\nFor (2), `row` should go downwards and `col` should not change.\\nFor (3), `row` should not change and `col` should move right.\\nBecause (1) is similar to (3), when writing the control flow we place the condition\\n```java\\nif(row==rowlen-1)\\n```\\nbefore the other condition to avoid repetition.\\n\\nWriting this post to reinforce my own understanding after slogging away at this qn",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if(matrix.length==0) return new int[0];\\n        boolean up = true;\\n        int rowlen = matrix.length;\\n        int collen = matrix[0].length;\\n        int[] ans = new int[rowlen*collen];\\n        int row = 0;\\n        int col = 0;\\n        int n = 0;\\n        while(n<rowlen*collen){\\n            ans[n] = matrix[row][col];            \\n            ++n; \\n            if(up){\\n                if(col==collen-1){\\n                    up = false;\\n                    ++row;\\n                    continue;\\n                }        \\n                if(row==0){\\n                    up = false;\\n                    ++col;\\n                    continue;\\n                }\\n                //no flips\\n                --row;\\n                ++col;\\n                continue;\\n            }else{\\n                if(row==rowlen-1){\\n                    up = true;\\n                    ++col;\\n                    continue;\\n                }\\n                if(col==0){\\n                    up = true;\\n                    ++row;\\n                    continue;\\n                }\\n                //no flips\\n                ++row;\\n                --col;\\n            }     \\n        }\\n        return ans;\\n    }\\n}\\n```\n```java\\nif(col==collen-1)\\n```\n```java\\nif(row==rowlen-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654613,
                "title": "java-bfs-o-n-solution",
                "content": "This is like an tree structure(from top left to bottom right)\\nso I think of an BFS iterate solution.\\n\\n```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        \\n        if(matrix == null || matrix.length == 0) return new int[0];\\n        \\n        int M = matrix.length;\\n        int N = matrix[0].length;\\n        \\n        int[] answer = new int[M*N];\\n        int index = 0;\\n        \\n        Queue<int[]> queue = new ArrayDeque<>();\\n        queue.offer(new int[]{0,0});\\n        boolean odd = true;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            ArrayList<Integer> layer = new ArrayList<>();\\n            for(int i = 0; i < size; i++){\\n                int[] coordinate = queue.poll();\\n                int r = coordinate[0];\\n                int c = coordinate[1];\\n                \\n                layer.add(matrix[r][c]);\\n                if(c == 0 && r + 1 < M)//the most left roll add the botton element first;\\n                    queue.offer(new int[]{r + 1, c});\\n                if(c + 1 < N)//then add the right element;\\n                    queue.offer(new int[]{r, c + 1});\\n            }\\n            if(odd){\\n                for(int i = 0; i < layer.size(); i++){\\n                    answer[index++] = layer.get(i);\\n                }\\n            }else{\\n                for(int i = layer.size() - 1; i >=0; i--){\\n                    answer[index++] = layer.get(i);\\n                }\\n            }\\n            odd = !odd;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        \\n        if(matrix == null || matrix.length == 0) return new int[0];\\n        \\n        int M = matrix.length;\\n        int N = matrix[0].length;\\n        \\n        int[] answer = new int[M*N];\\n        int index = 0;\\n        \\n        Queue<int[]> queue = new ArrayDeque<>();\\n        queue.offer(new int[]{0,0});\\n        boolean odd = true;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            ArrayList<Integer> layer = new ArrayList<>();\\n            for(int i = 0; i < size; i++){\\n                int[] coordinate = queue.poll();\\n                int r = coordinate[0];\\n                int c = coordinate[1];\\n                \\n                layer.add(matrix[r][c]);\\n                if(c == 0 && r + 1 < M)//the most left roll add the botton element first;\\n                    queue.offer(new int[]{r + 1, c});\\n                if(c + 1 < N)//then add the right element;\\n                    queue.offer(new int[]{r, c + 1});\\n            }\\n            if(odd){\\n                for(int i = 0; i < layer.size(); i++){\\n                    answer[index++] = layer.get(i);\\n                }\\n            }else{\\n                for(int i = layer.size() - 1; i >=0; i--){\\n                    answer[index++] = layer.get(i);\\n                }\\n            }\\n            odd = !odd;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582552,
                "title": "java-11-lines-easy-to-understand",
                "content": "1. We start from left corner, and iterate through diagonals.\\n2. On each diagonal we define where will we go: in top-right direction or in bottom-left.\\n3. Then we define range of each diagonal\\n```\\npublic int[] findDiagonalOrder(int[][] matrix) {\\n\\tif (matrix.length == 0) return new int[]{};\\n\\tint rowsNum = matrix.length - 1, columnsNum = matrix[0].length - 1, i = 0;\\n\\tint[] result = new int[(rowsNum + 1) * (columnsNum + 1)];\\n\\tfor (int diagonal = 0; diagonal <= rowsNum + columnsNum; diagonal++) {\\n\\t\\tif (diagonal % 2 == 0) {\\n\\t\\t\\t// direction top_right\\n\\t\\t\\tfor (int r = Math.min(diagonal, rowsNum), c = Math.max(0, diagonal - rowsNum); r >= 0 && c <= columnsNum; r--, c++) {\\n\\t\\t\\t\\tresult[i++] = matrix[r][c];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// direction bottom_left\\n\\t\\t\\tfor (int r = Math.max(0, diagonal - columnsNum), c = Math.min(diagonal, columnsNum); r <= rowsNum && c >= 0; r++, c--) {\\n\\t\\t\\t\\tresult[i++] = matrix[r][c];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] findDiagonalOrder(int[][] matrix) {\\n\\tif (matrix.length == 0) return new int[]{};\\n\\tint rowsNum = matrix.length - 1, columnsNum = matrix[0].length - 1, i = 0;\\n\\tint[] result = new int[(rowsNum + 1) * (columnsNum + 1)];\\n\\tfor (int diagonal = 0; diagonal <= rowsNum + columnsNum; diagonal++) {\\n\\t\\tif (diagonal % 2 == 0) {\\n\\t\\t\\t// direction top_right\\n\\t\\t\\tfor (int r = Math.min(diagonal, rowsNum), c = Math.max(0, diagonal - rowsNum); r >= 0 && c <= columnsNum; r--, c++) {\\n\\t\\t\\t\\tresult[i++] = matrix[r][c];\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\t// direction bottom_left\\n\\t\\t\\tfor (int r = Math.max(0, diagonal - columnsNum), c = Math.min(diagonal, columnsNum); r <= rowsNum && c >= 0; r++, c--) {\\n\\t\\t\\t\\tresult[i++] = matrix[r][c];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 534097,
                "title": "javascript-80ms-99-iterative-commented",
                "content": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar findDiagonalOrder = function(matrix) {\\n    if (!matrix.length) return matrix;\\n\\t\\n\\tconst depth = matrix.length;\\n    const width = matrix[0].length;\\n\\t\\n    const result = [];\\n    let i = 0;\\n    let j = 0;\\n    let goUp = true; // direction marker\\n\\n    \\n    while (result.length < depth * width) { // while result is not filled up with (depth * width) elements\\n        result.push(matrix[i][j]);\\n        \\n        if (goUp) { // if direction is top-right\\n            if (j === width - 1) { // if last coloumn - move one row down and change direction\\n                i++;\\n                goUp = false;\\n            } else if (i === 0) { // else if first row - move one coloumn right and change direction\\n                j++;\\n                goUp = false;\\n            } else { // else just move diagonally to top-right\\n                i--;\\n                j++;\\n            }\\n        } else { // if direction is bottom-left\\n            if (i === depth - 1) { // if last row - move right and change direction\\n                j++;\\n                goUp = true;\\n            } else if (j === 0) { // else if first coloumn - move down and change direction\\n                i++;                   \\n                goUp = true;\\n            } else { // else just move diagonally to bottom-left\\n                i++;\\n                j--;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[][]} matrix\\n * @return {number[]}\\n */\\nvar findDiagonalOrder = function(matrix) {\\n    if (!matrix.length) return matrix;\\n\\t\\n\\tconst depth = matrix.length;\\n    const width = matrix[0].length;\\n\\t\\n    const result = [];\\n    let i = 0;\\n    let j = 0;\\n    let goUp = true; // direction marker\\n\\n    \\n    while (result.length < depth * width) { // while result is not filled up with (depth * width) elements\\n        result.push(matrix[i][j]);\\n        \\n        if (goUp) { // if direction is top-right\\n            if (j === width - 1) { // if last coloumn - move one row down and change direction\\n                i++;\\n                goUp = false;\\n            } else if (i === 0) { // else if first row - move one coloumn right and change direction\\n                j++;\\n                goUp = false;\\n            } else { // else just move diagonally to top-right\\n                i--;\\n                j++;\\n            }\\n        } else { // if direction is bottom-left\\n            if (i === depth - 1) { // if last row - move right and change direction\\n                j++;\\n                goUp = true;\\n            } else if (j === 0) { // else if first coloumn - move down and change direction\\n                i++;                   \\n                goUp = true;\\n            } else { // else just move diagonally to bottom-left\\n                i++;\\n                j--;\\n            }\\n        }\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 327652,
                "title": "generalised-way-of-dealing-with-such-problems",
                "content": "In problems where we need to print matrix in particular order, all we need is to maintain two pointers, each for row and columns. Afterwards, its all about traversing the matrix in the way the problem asks us to. \\ni.e. We maintain row pointers as r1 = 0, r2 = matrix.length-1 and column pointers as col1 = 0, col2 = matrix[0].length.\\n\\nSimilar Problems:\\n[54. Spiral Matrix](http://leetcode.com/problems/spiral-matrix/)\\n[59. Spiral Matrix II](http://leetcode.com/problems/spiral-matrix-ii/)\\n\\nIn this problems\\n\\nIn this problem, There is only one thing to take care of: when counters are equal to row or column length. This means all the elements of that particular row or column is traversed. Thus, we need to move to next row or column depending on which is exhausted.\\n\\n```\\npublic int[] findDiagonalOrder(int[][] matrix) {\\n    \\tif(matrix == null || matrix.length == 0)\\n    \\t\\treturn new int[] {};\\n    \\tint []res = new int[matrix.length*matrix[0].length];\\n    \\tint index = 0;\\n    \\tint r1 = 0, col1 = 0, r2 = matrix.length-1, col2 = matrix[0].length-1;\\n    \\twhile(r1 <= r2 && col1 <= col2) {\\n    \\t\\tfor(;r1 >= 0 && col1 <= col2;r1--,col1++)\\n    \\t\\t\\tres[index++] = matrix[r1][col1];\\n    \\t\\tr1++;\\n    \\t\\tif(col1 > col2) {\\n    \\t\\t\\tcol1--;\\n    \\t\\t\\tr1++;\\n    \\t\\t}\\n    \\t\\tfor(;r1 <= r2 && col1 >= 0;r1++, col1--)\\n    \\t\\t\\tres[index++] = matrix[r1][col1];\\n    \\t\\tcol1++;\\n    \\t\\tif(r1 > r2) {\\n    \\t\\t\\tr1--;\\n    \\t\\t\\tcol1++;\\n    \\t\\t}\\n    \\t}\\n    \\treturn res;\\n    }\\n\\t```\\nIn Spiral Matrix problem\\n```\\n\\tpublic List<Integer> spiralOrder(int[][] matrix) {\\n    \\tList<Integer> list = new ArrayList<>();\\n    \\tif(matrix == null || matrix.length == 0 || matrix[0].length == 0) return list;\\n        int r1 = 0, r2 = matrix.length-1;\\n        int c1 = 0, c2 = matrix[0].length-1;\\n    \\tint i = 0;\\n    \\t\\n    \\twhile(r1 <= r2 && c1 <= c2) {\\n    \\t\\tfor(i = c1;i <= c2;i++)\\n    \\t\\t\\tlist.add(matrix[r1][i]);\\n    \\t\\tr1++;\\n    \\t\\tfor(i = r1;i <= r2;i++)\\n    \\t\\t\\tlist.add(matrix[i][c2]);\\n    \\t\\tc2--;\\n    \\t\\tif(r1 <= r2) {\\n\\t    \\t\\tfor(i = c2;i >= c1;i--)\\n\\t    \\t\\t\\tlist.add(matrix[r2][i]);\\n\\t    \\t\\tr2--;\\n    \\t\\t}\\n    \\t\\tif(c1 <= c2) {\\n\\t    \\t\\tfor(i = r2;i >= r1;i--)\\n\\t    \\t\\t\\tlist.add(matrix[i][c1]);\\n\\t    \\t\\tc1++;\\n    \\t\\t}\\n    \\t}\\n    \\treturn list;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] findDiagonalOrder(int[][] matrix) {\\n    \\tif(matrix == null || matrix.length == 0)\\n    \\t\\treturn new int[] {};\\n    \\tint []res = new int[matrix.length*matrix[0].length];\\n    \\tint index = 0;\\n    \\tint r1 = 0, col1 = 0, r2 = matrix.length-1, col2 = matrix[0].length-1;\\n    \\twhile(r1 <= r2 && col1 <= col2) {\\n    \\t\\tfor(;r1 >= 0 && col1 <= col2;r1--,col1++)\\n    \\t\\t\\tres[index++] = matrix[r1][col1];\\n    \\t\\tr1++;\\n    \\t\\tif(col1 > col2) {\\n    \\t\\t\\tcol1--;\\n    \\t\\t\\tr1++;\\n    \\t\\t}\\n    \\t\\tfor(;r1 <= r2 && col1 >= 0;r1++, col1--)\\n    \\t\\t\\tres[index++] = matrix[r1][col1];\\n    \\t\\tcol1++;\\n    \\t\\tif(r1 > r2) {\\n    \\t\\t\\tr1--;\\n    \\t\\t\\tcol1++;\\n    \\t\\t}\\n    \\t}\\n    \\treturn res;\\n    }\\n\\t```\n```\\n\\tpublic List<Integer> spiralOrder(int[][] matrix) {\\n    \\tList<Integer> list = new ArrayList<>();\\n    \\tif(matrix == null || matrix.length == 0 || matrix[0].length == 0) return list;\\n        int r1 = 0, r2 = matrix.length-1;\\n        int c1 = 0, c2 = matrix[0].length-1;\\n    \\tint i = 0;\\n    \\t\\n    \\twhile(r1 <= r2 && c1 <= c2) {\\n    \\t\\tfor(i = c1;i <= c2;i++)\\n    \\t\\t\\tlist.add(matrix[r1][i]);\\n    \\t\\tr1++;\\n    \\t\\tfor(i = r1;i <= r2;i++)\\n    \\t\\t\\tlist.add(matrix[i][c2]);\\n    \\t\\tc2--;\\n    \\t\\tif(r1 <= r2) {\\n\\t    \\t\\tfor(i = c2;i >= c1;i--)\\n\\t    \\t\\t\\tlist.add(matrix[r2][i]);\\n\\t    \\t\\tr2--;\\n    \\t\\t}\\n    \\t\\tif(c1 <= c2) {\\n\\t    \\t\\tfor(i = r2;i >= r1;i--)\\n\\t    \\t\\t\\tlist.add(matrix[i][c1]);\\n\\t    \\t\\tc1++;\\n    \\t\\t}\\n    \\t}\\n    \\treturn list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 216501,
                "title": "short-c-solution-based-on-an-extremely-simple-invariant-no-extra-space",
                "content": "Each diagonal is just a collection of points (i,j) that satisfy i+j=k, for some constant k. For the top-left diagonal, k=0. For the bottom-right diagonal, k=m+n-2. So we just loop through the possible values of k.\\n\\nTo print each diagonal, we just loop through the possible values of i and print the value at (i,k-i), since j=k-i. The starting and ending values of i are determined by the combination of the following inequalities:\\n\\ni >= 0,\\ni <= m-1,\\nk-i >= 0,\\nk-i <= n-1.\\n\\nA simple rearrangement gives:\\n\\nmax(0, k-n+1) <= i <= min(m-1, k).\\n\\nWe switch the loop direction as we go through the diagonals.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        if (matrix.empty()) {\\n            return {};\\n        }\\n        const int m = matrix.size();\\n        const int n = matrix[0].size();\\n        vector<int> r;\\n        r.reserve(m * n);\\n        for (int k = 0; k <= m + n - 2; k++) {\\n            const int start = max(0, k - n + 1);\\n            const int end = min(m - 1, k);\\n            if ((k % 2) == 0) {\\n                for (int i = end; i >= start; i--) {\\n                    r.push_back(matrix[i][k - i]);\\n                }\\n            }\\n            else {\\n                for (int i = start; i <= end; i++) {\\n                    r.push_back(matrix[i][k - i]);\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        if (matrix.empty()) {\\n            return {};\\n        }\\n        const int m = matrix.size();\\n        const int n = matrix[0].size();\\n        vector<int> r;\\n        r.reserve(m * n);\\n        for (int k = 0; k <= m + n - 2; k++) {\\n            const int start = max(0, k - n + 1);\\n            const int end = min(m - 1, k);\\n            if ((k % 2) == 0) {\\n                for (int i = end; i >= start; i--) {\\n                    r.push_back(matrix[i][k - i]);\\n                }\\n            }\\n            else {\\n                for (int i = start; i <= end; i++) {\\n                    r.push_back(matrix[i][k - i]);\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 181272,
                "title": "java-fast-and-easy-to-understand-solution",
                "content": "````\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if(matrix.length == 0) {\\n            return new int[0];\\n        }\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[] res = new int[m*n];\\n        int i = 0, j = 0, k = 0;\\n        int cnt = 0, diags = m + n - 1;\\n        while(cnt < diags) {\\n            cnt++;\\n            if(cnt % 2 != 0) { // traverse up on odd diagonals\\n                while(i >= 0 && j < n) {\\n                    res[k++] = matrix[i--][j++];\\n                }\\n            } else {\\n                while(j >= 0 && i < m) {\\n                    res[k++] = matrix[i++][j--];\\n                }\\n            }\\n            \\n            if(i == m) {\\n                i = m - 1;\\n                j += 2;\\n            } else if(j == n) {\\n                j = n - 1;\\n                i += 2;\\n            } else if(i < 0) {\\n                i = 0;\\n            } else if(j < 0) {\\n                j = 0;\\n            } \\n        }\\n        return res;\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if(matrix.length == 0) {\\n            return new int[0];\\n        }\\n        int m = matrix.length;\\n        int n = matrix[0].length;\\n        int[] res = new int[m*n];\\n        int i = 0, j = 0, k = 0;\\n        int cnt = 0, diags = m + n - 1;\\n        while(cnt < diags) {\\n            cnt++;\\n            if(cnt % 2 != 0) { // traverse up on odd diagonals\\n                while(i >= 0 && j < n) {\\n                    res[k++] = matrix[i--][j++];\\n                }\\n            } else {\\n                while(j >= 0 && i < m) {\\n                    res[k++] = matrix[i++][j--];\\n                }\\n            }\\n            \\n            if(i == m) {\\n                i = m - 1;\\n                j += 2;\\n            } else if(j == n) {\\n                j = n - 1;\\n                i += 2;\\n            } else if(i < 0) {\\n                i = 0;\\n            } else if(j < 0) {\\n                j = 0;\\n            } \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926086,
                "title": "beginner-friendly-solution",
                "content": "# Intuition\\nJust start from zeroth row, traverse upto middle diagonal i.e till diagonals that starting from zeroth column,simlarly search for last rowth diagonals\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int n=mat.size(),m=mat[0].size();\\n        vector<int>v;\\n       int p=0,q=0,level=0,t=0;\\n            \\n            while(p<n)\\n            {\\n                vector<int>path;\\n                int i=p,j=q;\\n                while(i>=0&&j<m)\\n                {\\n                    path.push_back(mat[i][j]);\\n                    i--,j++;\\n                }\\n                if(level%2)reverse(path.begin(),path.end());\\n                for(int k=0;k<path.size();k++)\\n                v.push_back(path[k]);\\n                level++;\\n                p++;\\n            }\\n         p=n-1,q=1;\\n            while(q<m)\\n            {\\n                vector<int>path;\\n                int i=p,j=q;\\n                while(i>=0&&j<m)\\n                {\\n                    path.push_back(mat[i][j]);\\n                    i--,j++;\\n                }\\n                if(level%2)reverse(path.begin(),path.end());\\n                for(int k=0;k<path.size();k++)\\n                v.push_back(path[k]);\\n                level++;\\n                q++;\\n            }\\n            return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int n=mat.size(),m=mat[0].size();\\n        vector<int>v;\\n       int p=0,q=0,level=0,t=0;\\n            \\n            while(p<n)\\n            {\\n                vector<int>path;\\n                int i=p,j=q;\\n                while(i>=0&&j<m)\\n                {\\n                    path.push_back(mat[i][j]);\\n                    i--,j++;\\n                }\\n                if(level%2)reverse(path.begin(),path.end());\\n                for(int k=0;k<path.size();k++)\\n                v.push_back(path[k]);\\n                level++;\\n                p++;\\n            }\\n         p=n-1,q=1;\\n            while(q<m)\\n            {\\n                vector<int>path;\\n                int i=p,j=q;\\n                while(i>=0&&j<m)\\n                {\\n                    path.push_back(mat[i][j]);\\n                    i--,j++;\\n                }\\n                if(level%2)reverse(path.begin(),path.end());\\n                for(int k=0;k<path.size();k++)\\n                v.push_back(path[k]);\\n                level++;\\n                q++;\\n            }\\n            return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505732,
                "title": "java-easy-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraversing diagonally and adding elements to the arraylist(\"l\"), at even traversal reversing the arraylist and than adding it to final arraylist(\"list\"). \\nLoop Traversal:\\nLoop: 1 (reverse list)\\n0 0\\nLoop: 2\\n0 1\\n1 0\\nLoop: 3 (reverse list)\\n0 2\\n1 1\\n2 0\\nLoop: 4\\n1 2\\n2 1\\nLoop: 5 (reverse list)\\n2 2\\n[1, 2, 4, 7, 5, 3, 6, 8, 9]\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        int n = mat.length-1, m = mat[0].length-1;\\n        int row = 0, col = 0, c = 0;\\n        while(row<=n && col<=m){\\n            int i=row, j=col;\\n            ArrayList<Integer> l = new ArrayList<>();\\n            while(i>=0 && i<=n && j>=0){\\n                // System.out.println(i+\" \"+j);\\n                l.add(mat[i][j]);\\n                i++;\\n                j--;\\n            }\\n            if(c%2 == 0){\\n                Collections.reverse(l);\\n            }\\n            // System.out.println(l);\\n            list.addAll(l);\\n            c++;\\n            col++;\\n            if(col>m){\\n                row++;\\n                col = m;\\n            }\\n            // System.out.println(row+\" \"+col);\\n        }\\n        System.out.println(list);\\n        int [] arr = new int[(n+1)*(m+1)];\\n        int size = 0;\\n        for(int i: list){\\n            arr[size++] = i;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        int n = mat.length-1, m = mat[0].length-1;\\n        int row = 0, col = 0, c = 0;\\n        while(row<=n && col<=m){\\n            int i=row, j=col;\\n            ArrayList<Integer> l = new ArrayList<>();\\n            while(i>=0 && i<=n && j>=0){\\n                // System.out.println(i+\" \"+j);\\n                l.add(mat[i][j]);\\n                i++;\\n                j--;\\n            }\\n            if(c%2 == 0){\\n                Collections.reverse(l);\\n            }\\n            // System.out.println(l);\\n            list.addAll(l);\\n            c++;\\n            col++;\\n            if(col>m){\\n                row++;\\n                col = m;\\n            }\\n            // System.out.println(row+\" \"+col);\\n        }\\n        System.out.println(list);\\n        int [] arr = new int[(n+1)*(m+1)];\\n        int size = 0;\\n        for(int i: list){\\n            arr[size++] = i;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465535,
                "title": "easy-java-solution-o-n-n",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N*N) We are traversing each element once!\\n\\n- Space complexity:\\n  O(1) As no additional DS is used appart from the required one\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        \\n        int row = 0;\\n        int col = 0;\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int res [] = new int [m * n];\\n\\n        for(int i=0; i<res.length; i++) {\\n            res[i] = mat[row][col];\\n\\n            if((row + col) % 2 == 0) {\\n                // Forward diagnol\\n                if(col == n-1) {\\n                    // We cannot go right , have to go down now\\n                    row ++;\\n                } else if(row == 0) {\\n                    // We cannot go up, have to go right\\n                    col ++;\\n                } else {\\n                    row --;\\n                    col ++;\\n                }\\n            } else {\\n                // Backward diagnol\\n                if(row == m-1) {\\n                    // We cannot go down , have to go right\\n                    col ++;\\n                } else if(col == 0) {\\n                    // We cannot go left , have to go down now\\n                    row ++; \\n                } else {\\n                    row ++;\\n                    col --;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        \\n        int row = 0;\\n        int col = 0;\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int res [] = new int [m * n];\\n\\n        for(int i=0; i<res.length; i++) {\\n            res[i] = mat[row][col];\\n\\n            if((row + col) % 2 == 0) {\\n                // Forward diagnol\\n                if(col == n-1) {\\n                    // We cannot go right , have to go down now\\n                    row ++;\\n                } else if(row == 0) {\\n                    // We cannot go up, have to go right\\n                    col ++;\\n                } else {\\n                    row --;\\n                    col ++;\\n                }\\n            } else {\\n                // Backward diagnol\\n                if(row == m-1) {\\n                    // We cannot go down , have to go right\\n                    col ++;\\n                } else if(col == 0) {\\n                    // We cannot go left , have to go down now\\n                    row ++; \\n                } else {\\n                    row ++;\\n                    col --;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3261606,
                "title": "easy-cpp-code",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int nrow=mat.size(),ncol=mat[0].size();\\n        if(nrow==0)return {};\\n        vector<int>res(nrow*ncol);\\n        int row=0,col=0;\\n        int c=0;\\n        bool up=true;\\n        res[c++]=mat[row][col];\\n        while(row!=nrow-1 || col!=ncol-1){\\n            if(up){\\n                if(col==ncol-1) {row++;up=false;}\\n                else if(row==0) {col++;up=false;}\\n                else {row--;col++;}\\n            }\\n            else{\\n                if(row==nrow-1) {col++;up=true;}\\n                else if(col==0) {row++;up=true;}\\n                else {col--;row++;}\\n            }\\n            res[c++]=mat[row][col];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int nrow=mat.size(),ncol=mat[0].size();\\n        if(nrow==0)return {};\\n        vector<int>res(nrow*ncol);\\n        int row=0,col=0;\\n        int c=0;\\n        bool up=true;\\n        res[c++]=mat[row][col];\\n        while(row!=nrow-1 || col!=ncol-1){\\n            if(up){\\n                if(col==ncol-1) {row++;up=false;}\\n                else if(row==0) {col++;up=false;}\\n                else {row--;col++;}\\n            }\\n            else{\\n                if(row==nrow-1) {col++;up=true;}\\n                else if(col==0) {row++;up=true;}\\n                else {col--;row++;}\\n            }\\n            res[c++]=mat[row][col];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2940458,
                "title": "c-clean-solution-with-well-documented-code",
                "content": "# Complexity\\n- Time complexity:\\n$$O(N*M)$$\\n\\n- Space complexity:\\n$$O(N*M)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    /*\\n        This solution leverages the fact that all the elements on\\n        a diagonal have a constant sum of their coordinates (x, y)\\n    */ \\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int N = mat.size(); // number of lines of the matrix\\n        int M = mat[0].size(); // number of columns of the matrix\\n        vector<int> answer; // solution vector\\n\\n        // x will be our line coordinate. To move upwards or downwards\\n        // the diagonal we will simply increment/decrement x respectively.\\n        int x = 0; \\n        // sum will be used to identify the diagonal we are currently\\n        // working on. at any point in time we can determine the \\n        // current column coordinate by subtracting x from sum. To\\n        // move on the next diagonal we can simply increment sum.\\n        int sum = 0; \\n        // dir will indicate the moving direction on the current diagonal\\n        // when we move upwards the diagonal dir == -1, when we move\\n        // downwards the diagonal dir == 1. This will simplify the code later.\\n        int dir = -1;\\n\\n        // add will add mat[x][y] to the answer\\n        // this should be called everytime we change coordinates\\n        auto addToAnswer = [&]() {\\n            int y = sum - x;\\n            answer.push_back(mat[x][y]);\\n        };\\n\\n        // ok will check if a given x coordinate (y coordinate is determined\\n        // by sum - x) is within the matrix boundaries\\n        auto ok = [&](int x) {\\n            int y = sum - x;\\n            return x >= 0 && y >= 0 && x < N && y < M;\\n        };\\n\\n        addToAnswer();\\n\\n        // last diagonal will always consist of a single element,\\n        // specifically matrix[N - 1][M - 1]\\n        while (sum != N + M - 2) {\\n            // to move to the next diagonal we increment sum.\\n            // When we increment sum, y coordinate is incremented\\n            // automatically! This is good when we want to move to the\\n            // next diagonal by going to the right cell when we reach the \\n            // end of the current diagonal, but this won\\'t be always the case,\\n            // as sometimes we will need to move to the cell below to switch to \\n            // the next diagonal\\n            sum++;\\n            \\n            // When we reached the end of a diagonal by moving upwards\\n            // we have two cases:\\n            // 1. If we did not reach yet the rightmost column, we will move to the right cell.\\n            //    This means we do not have to change x (we incremented sum and y coordinate was\\n            //    incremented subsequently)\\n            // 2. If we did reach the rightmost column, our only option is to move cell below, which\\n            //    means we should increment x\\n\\n            // When we reached the end of a diagonal by moving downwards\\n            // we have two cases:\\n            // 1. If we did not reach yet the downmost line, we will move to the cell below.\\n            //    This means we have to increment x\\n            // 2. If we did reach the downmost line, our only option is to move right cell,\\n            //    this means we should not modify x\\n\\n            // TLDR: We should increment x (move to the cell below) only when we hit\\n            //       rightmost column at the end of a diagonal by moving upwards, or when\\n            //       we did not hit yet the lowest line at the end of a diagonal by moving downwards.\\n            if ((dir == -1 && !ok(x)) || (dir == 1 && (ok(x + 1)))) {\\n                x++;\\n            }\\n            addToAnswer();\\n\\n\\n            // we swap direction\\n            dir = -dir;\\n\\n            // we consume the current diagonal\\n            // as long as the coordinates determined by moving upwards/downwards\\n            // on the diagonal are within matrix boundaries\\n            // it\\'s important to note that we only change x coordinate, as y is \\n            // determined by sum and x\\n            while (ok(x + dir)) {\\n                x += dir;\\n                addToAnswer();\\n            }\\n        }\\n\\n        return answer;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        This solution leverages the fact that all the elements on\\n        a diagonal have a constant sum of their coordinates (x, y)\\n    */ \\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int N = mat.size(); // number of lines of the matrix\\n        int M = mat[0].size(); // number of columns of the matrix\\n        vector<int> answer; // solution vector\\n\\n        // x will be our line coordinate. To move upwards or downwards\\n        // the diagonal we will simply increment/decrement x respectively.\\n        int x = 0; \\n        // sum will be used to identify the diagonal we are currently\\n        // working on. at any point in time we can determine the \\n        // current column coordinate by subtracting x from sum. To\\n        // move on the next diagonal we can simply increment sum.\\n        int sum = 0; \\n        // dir will indicate the moving direction on the current diagonal\\n        // when we move upwards the diagonal dir == -1, when we move\\n        // downwards the diagonal dir == 1. This will simplify the code later.\\n        int dir = -1;\\n\\n        // add will add mat[x][y] to the answer\\n        // this should be called everytime we change coordinates\\n        auto addToAnswer = [&]() {\\n            int y = sum - x;\\n            answer.push_back(mat[x][y]);\\n        };\\n\\n        // ok will check if a given x coordinate (y coordinate is determined\\n        // by sum - x) is within the matrix boundaries\\n        auto ok = [&](int x) {\\n            int y = sum - x;\\n            return x >= 0 && y >= 0 && x < N && y < M;\\n        };\\n\\n        addToAnswer();\\n\\n        // last diagonal will always consist of a single element,\\n        // specifically matrix[N - 1][M - 1]\\n        while (sum != N + M - 2) {\\n            // to move to the next diagonal we increment sum.\\n            // When we increment sum, y coordinate is incremented\\n            // automatically! This is good when we want to move to the\\n            // next diagonal by going to the right cell when we reach the \\n            // end of the current diagonal, but this won\\'t be always the case,\\n            // as sometimes we will need to move to the cell below to switch to \\n            // the next diagonal\\n            sum++;\\n            \\n            // When we reached the end of a diagonal by moving upwards\\n            // we have two cases:\\n            // 1. If we did not reach yet the rightmost column, we will move to the right cell.\\n            //    This means we do not have to change x (we incremented sum and y coordinate was\\n            //    incremented subsequently)\\n            // 2. If we did reach the rightmost column, our only option is to move cell below, which\\n            //    means we should increment x\\n\\n            // When we reached the end of a diagonal by moving downwards\\n            // we have two cases:\\n            // 1. If we did not reach yet the downmost line, we will move to the cell below.\\n            //    This means we have to increment x\\n            // 2. If we did reach the downmost line, our only option is to move right cell,\\n            //    this means we should not modify x\\n\\n            // TLDR: We should increment x (move to the cell below) only when we hit\\n            //       rightmost column at the end of a diagonal by moving upwards, or when\\n            //       we did not hit yet the lowest line at the end of a diagonal by moving downwards.\\n            if ((dir == -1 && !ok(x)) || (dir == 1 && (ok(x + 1)))) {\\n                x++;\\n            }\\n            addToAnswer();\\n\\n\\n            // we swap direction\\n            dir = -dir;\\n\\n            // we consume the current diagonal\\n            // as long as the coordinates determined by moving upwards/downwards\\n            // on the diagonal are within matrix boundaries\\n            // it\\'s important to note that we only change x coordinate, as y is \\n            // determined by sum and x\\n            while (ok(x + dir)) {\\n                x += dir;\\n                addToAnswer();\\n            }\\n        }\\n\\n        return answer;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2874293,
                "title": "python-video-solution",
                "content": "I have explained this in a [video](https://youtu.be/Njt7aZYq0wA).\\n\\n`row+col` for each element identifies which column it belongs to.\\n\\nWe can use this as a `diagonal_id` and store all elements corresponding to it in a HashMap.\\n\\nIf it is **even**, then we have to traverse the list in reverse order, else in forward order.\\n\\nIf this was helpful, please upvote, like the video and subscribe to the channel.\\n\\nCheers.\\n\\n```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        \\n        R, C = len(mat), len(mat[0])\\n        \\n        diagonal_dict = defaultdict(list)\\n        \\n        for r in range(R):\\n            for c in range(C):\\n                diagonal_dict[r+c].append(mat[r][c])\\n                \\n        ans = []\\n        \\n        key = 0\\n        \\n        while key in diagonal_dict:\\n            if key%2: #odd\\n                ans.extend(diagonal_dict[key])\\n            else: #even\\n                ans.extend(diagonal_dict[key][::-1])\\n            \\n            key+=1\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "I have explained this in a [video](https://youtu.be/Njt7aZYq0wA).\\n\\n`row+col` for each element identifies which column it belongs to.\\n\\nWe can use this as a `diagonal_id` and store all elements corresponding to it in a HashMap.\\n\\nIf it is **even**, then we have to traverse the list in reverse order, else in forward order.\\n\\nIf this was helpful, please upvote, like the video and subscribe to the channel.\\n\\nCheers.\\n\\n```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        \\n        R, C = len(mat), len(mat[0])\\n        \\n        diagonal_dict = defaultdict(list)\\n        \\n        for r in range(R):\\n            for c in range(C):\\n                diagonal_dict[r+c].append(mat[r][c])\\n                \\n        ans = []\\n        \\n        key = 0\\n        \\n        while key in diagonal_dict:\\n            if key%2: #odd\\n                ans.extend(diagonal_dict[key])\\n            else: #even\\n                ans.extend(diagonal_dict[key][::-1])\\n            \\n            key+=1\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2685483,
                "title": "diagonal-traverse-clear-solution-explanation-with-picture",
                "content": "The Whole idea is to Keep Track of the Direction and Detect when we need to Go Up an When we need to Go Down\\n\\nSo in the following Picture we need to change Direction to go down According Two Condtions and Go Up According Two Condtions\\n\\n**Go Down (Direction Change ):**\\n- row === 0 && col < colLen - 1\\n- col === colLen\\n\\n**Go Up (Direction Change):**\\n- col === 0 && row < rowLen - 1\\n- row === rowLen - 1\\n\\n![image](https://assets.leetcode.com/users/images/9f8e380b-e3c2-44e7-a06e-82008b5d91d4_1665397313.3874037.png)\\n\\n**Code Section**\\n\\n```javascript\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar findDiagonalOrder = function (mat) {\\n  const rowLen = mat.length;\\n  const colLen = mat[0].length;\\n  const total = rowLen * colLen;\\n  const result = [];\\n  let k = 0;\\n  let row = 0;\\n  let col = 0;\\n  let direction = \"up\";\\n\\n  while (k < total) {\\n    result.push(mat[row][col]);\\n\\n    if (direction === \"up\") {\\n      if (row === 0 && col < colLen - 1) {\\n        col++;\\n        direction = \"down\";\\n      } else if (col === colLen - 1) {\\n        row++;\\n        direction = \"down\";\\n      } else {\\n        row--;\\n        col++;\\n      }\\n    } else {\\n      if (col === 0 && row < rowLen - 1) {\\n        row++;\\n        direction = \"up\";\\n      } else if (row === rowLen - 1) {\\n        col++;\\n        direction = \"up\";\\n      } else {\\n        row++;\\n        col--;\\n      }\\n    }\\n    k++;\\n  }\\n  return result;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Simulation"
                ],
                "code": "```javascript\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar findDiagonalOrder = function (mat) {\\n  const rowLen = mat.length;\\n  const colLen = mat[0].length;\\n  const total = rowLen * colLen;\\n  const result = [];\\n  let k = 0;\\n  let row = 0;\\n  let col = 0;\\n  let direction = \"up\";\\n\\n  while (k < total) {\\n    result.push(mat[row][col]);\\n\\n    if (direction === \"up\") {\\n      if (row === 0 && col < colLen - 1) {\\n        col++;\\n        direction = \"down\";\\n      } else if (col === colLen - 1) {\\n        row++;\\n        direction = \"down\";\\n      } else {\\n        row--;\\n        col++;\\n      }\\n    } else {\\n      if (col === 0 && row < rowLen - 1) {\\n        row++;\\n        direction = \"up\";\\n      } else if (row === rowLen - 1) {\\n        col++;\\n        direction = \"up\";\\n      } else {\\n        row++;\\n        col--;\\n      }\\n    }\\n    k++;\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2652009,
                "title": "c-efficient-use-of-hashmaps-clean-solution-with-intuition",
                "content": "```\\n// Intuition : Sum of indexes of Diagonal Elements of a matrix are same\\n// The even sum indexes are in reverse order and odd ones are in normal order\\n\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        map<int, vector<int>> mp;\\n        \\n        for(int i = 0 ; i < mat.size(); i++)\\n        {\\n            for(int j = 0 ; j < mat[i].size(); j++)\\n            {\\n                int sum = i + j;\\n                mp[sum].push_back(mat[i][j]);\\n            }\\n        }\\n        vector<int> ans;\\n        for(auto i : mp)\\n        {\\n            if(i.first % 2 == 0) // even index elements are in reverse order\\n            {\\n                for(int x = i.second.size() - 1; x >= 0; x--)\\n                {\\n                    ans.push_back(i.second[x]);\\n                }\\n            }\\n            else        // odd index elements are in normal order\\n            {\\n                for(int x = 0 ; x < i.second.size(); x++)\\n                {\\n                    ans.push_back(i.second[x]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Intuition : Sum of indexes of Diagonal Elements of a matrix are same\\n// The even sum indexes are in reverse order and odd ones are in normal order\\n\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        map<int, vector<int>> mp;\\n        \\n        for(int i = 0 ; i < mat.size(); i++)\\n        {\\n            for(int j = 0 ; j < mat[i].size(); j++)\\n            {\\n                int sum = i + j;\\n                mp[sum].push_back(mat[i][j]);\\n            }\\n        }\\n        vector<int> ans;\\n        for(auto i : mp)\\n        {\\n            if(i.first % 2 == 0) // even index elements are in reverse order\\n            {\\n                for(int x = i.second.size() - 1; x >= 0; x--)\\n                {\\n                    ans.push_back(i.second[x]);\\n                }\\n            }\\n            else        // odd index elements are in normal order\\n            {\\n                for(int x = 0 ; x < i.second.size(); x++)\\n                {\\n                    ans.push_back(i.second[x]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510031,
                "title": "python-solutions-w-explanation-o-nm-time-o-1-space-and-o-mn-time-space",
                "content": "**O(mn) time and O(1) space solution using simulation**\\n\\n```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        m, n, r, c, res, goingUp = len(mat), len(mat[0]), 0, 0, [], True\\n        while r < m and c < n:\\n            res.append(mat[r][c])\\n            if goingUp:\\n                if (r - 1) < 0 or (c + 1) >= n:\\n                    if c + 1 < n:\\n                        c += 1\\n                    else:\\n                        r += 1\\n                    goingUp = not goingUp\\n                else:\\n                    r -= 1\\n                    c += 1\\n            else:\\n                if (r + 1) >= m or (c - 1) < 0:\\n                    if (r+1) < m:\\n                        r += 1\\n                    else:\\n                        c += 1\\n                    goingUp = not goingUp\\n                else:\\n                    r += 1\\n                    c -= 1\\n        return res\\n```\\n\\n**Explanation**:\\n- When you simulate diagonal up direction, you go row - 1 and column + 1\\n- If you are about to go beyond the matrix, try first going column + 1 if it is within the the matrix else go row + 1, switch direction to go diagonal down as well.\\n- When you simulate diagonal down direction, you go row + 1 and column - 1\\n- If you are about to go beyond the matrix, try first going row + 1 if it is within the the matrix, else go column + 1, switch direction to go diagonal up.\\n- Do this until you reach the last row, last column and break out of the while loop\\n\\n**Solution using Dictionary - O(mn) time and O(mn) space**\\n\\n\\tdef findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        d, m, n, res = defaultdict(list), len(mat), len(mat[0]), []\\n\\n        for r in range(m):\\n            for c in range(n):\\n                d[r + c].append(mat[r][c])\\n\\n        for indexSum, nums in d.items():\\n            if (indexSum % 2) == 0:\\n                res.extend(nums[::-1])\\n            else:\\n                res.extend(nums)\\n        return res\\n\\t\\t\\n**Explanation:**\\n\\n- Referenced from here: https://leetcode.com/problems/diagonal-traverse/discuss/581868/Easy-Python-NO-DIRECTION-CHECKING \\n- The indices from each diagonal sum to the same amount, so row, column (0,1) summed is same as row, column (1,0) and they belong to same diagonal\\n- Thus group these indices together using a hashmap or dictionary\\n- Then add each of these elements to an array by order of the sum of their indices, if the sum of their indices is even, start from the end in reverse order, this is to simulate moving from down to up in a diagonal fashion, so going diagonal up.\\n",
                "solutionTags": [
                    "Python",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        m, n, r, c, res, goingUp = len(mat), len(mat[0]), 0, 0, [], True\\n        while r < m and c < n:\\n            res.append(mat[r][c])\\n            if goingUp:\\n                if (r - 1) < 0 or (c + 1) >= n:\\n                    if c + 1 < n:\\n                        c += 1\\n                    else:\\n                        r += 1\\n                    goingUp = not goingUp\\n                else:\\n                    r -= 1\\n                    c += 1\\n            else:\\n                if (r + 1) >= m or (c - 1) < 0:\\n                    if (r+1) < m:\\n                        r += 1\\n                    else:\\n                        c += 1\\n                    goingUp = not goingUp\\n                else:\\n                    r += 1\\n                    c -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821651,
                "title": "c-2-approaches-with-w-o-map-easy-clean-code",
                "content": "**1. Using map**\\n\\n```\\nvector<int> findDiagonalOrder(vector<vector<int>>& a)\\n    {\\n        map<int,vector<int>> mp;\\n        int m,n,i,j;\\n        m=a.size();\\n        n=a[0].size();\\n        vector<int> ans;\\n        \\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                mp[i+j].push_back(a[i][j]);\\n            }\\n        }\\n        \\n        for(auto [s,v]:mp)\\n        {\\n            if(s%2==0)\\n                reverse(v.begin(),v.end());\\n            \\n            for(auto x:v)\\n            {\\n                ans.push_back(x);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\\n\\n**2. Without map**\\n```\\nvector<int> findDiagonalOrder(vector<vector<int>>& a) {\\n        int m,n,i,j;\\n        \\n        m=a.size();\\n        n=a[0].size();\\n        i=0,j=-1;\\n        bool dir=1;\\n        vector<int> ans;\\n        \\n        while(i<m || j<n)\\n        {\\n            if(dir==1)\\n                j++;\\n            else\\n                i++;\\n            \\n            if(i>=m)\\n            {\\n                i--;\\n                j++;\\n            }\\n            else if(j>=n)\\n            {\\n                j--;\\n                i++;\\n            }\\n                \\n            while(i<m && j<n && i>=0 && j>=0)\\n            {\\n                ans.push_back(a[i][j]);\\n                \\n                if(dir)\\n                {\\n                    i--;\\n                    j++;\\n                }\\n                else\\n                {\\n                    i++;\\n                    j--;\\n                }\\n            }\\n            \\n            dir=!dir;\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Do share your suggestions & upvote if you like !!!** \\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nvector<int> findDiagonalOrder(vector<vector<int>>& a)\\n    {\\n        map<int,vector<int>> mp;\\n        int m,n,i,j;\\n        m=a.size();\\n        n=a[0].size();\\n        vector<int> ans;\\n        \\n        for(i=0;i<m;i++)\\n        {\\n            for(j=0;j<n;j++)\\n            {\\n                mp[i+j].push_back(a[i][j]);\\n            }\\n        }\\n        \\n        for(auto [s,v]:mp)\\n        {\\n            if(s%2==0)\\n                reverse(v.begin(),v.end());\\n            \\n            for(auto x:v)\\n            {\\n                ans.push_back(x);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```\n```\\nvector<int> findDiagonalOrder(vector<vector<int>>& a) {\\n        int m,n,i,j;\\n        \\n        m=a.size();\\n        n=a[0].size();\\n        i=0,j=-1;\\n        bool dir=1;\\n        vector<int> ans;\\n        \\n        while(i<m || j<n)\\n        {\\n            if(dir==1)\\n                j++;\\n            else\\n                i++;\\n            \\n            if(i>=m)\\n            {\\n                i--;\\n                j++;\\n            }\\n            else if(j>=n)\\n            {\\n                j--;\\n                i++;\\n            }\\n                \\n            while(i<m && j<n && i>=0 && j>=0)\\n            {\\n                ans.push_back(a[i][j]);\\n                \\n                if(dir)\\n                {\\n                    i--;\\n                    j++;\\n                }\\n                else\\n                {\\n                    i++;\\n                    j--;\\n                }\\n            }\\n            \\n            dir=!dir;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1820894,
                "title": "c-easy-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        vector<int>h;\\n        map<int,vector<int>>k;\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[i].size();j++)\\n            {\\n\\t\\t\\t\\t// Taking ( i+j ) as map index , push values in vector having same sum\\n\\t\\t\\t\\t\\n                k[i+j].push_back(mat[i][j]);\\n            }\\n        }\\n        for(auto c:k)\\n        {\\n            if(c.first%2==0)\\n\\t\\t\\t\\n\\t\\t\\t\\t// reversing the even rows \\n\\t\\t\\t\\t\\n                reverse(c.second.begin(),c.second.end());\\n            for(auto x : c.second)\\n                h.push_back(x);\\n        }\\n        return h;\\n            \\n    }\\n};\\n```\\n\\nIf you like do UPVOTE >>>",
                "solutionTags": [
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        vector<int>h;\\n        map<int,vector<int>>k;\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[i].size();j++)\\n            {\\n\\t\\t\\t\\t// Taking ( i+j ) as map index , push values in vector having same sum\\n\\t\\t\\t\\t\\n                k[i+j].push_back(mat[i][j]);\\n            }\\n        }\\n        for(auto c:k)\\n        {\\n            if(c.first%2==0)\\n\\t\\t\\t\\n\\t\\t\\t\\t// reversing the even rows \\n\\t\\t\\t\\t\\n                reverse(c.second.begin(),c.second.end());\\n            for(auto x : c.second)\\n                h.push_back(x);\\n        }\\n        return h;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1531133,
                "title": "java-easy-to-understand-intuition",
                "content": "**Intuition:**\\n\\nStart traversing in the upward direction with the following traversal method:\\n- when going up:  `row-- && col++`\\n- when coming down: `row++ && col--`\\n        \\nChange direction in any of the following edge cases\\n\\nEdge cases: \\n- When going up:\\n\\t- when col is last col, then move to the next row, same col\\n\\t- when row is top row, then move to the next col, same row\\n- When going down:\\n\\t- when row is last row, then move to the next col, same row    \\n\\t- when col is first col, then move to the next row, same col\\n\\n\\n**Code:**\\n```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        int rowMax = mat.length;\\n        int colMax = mat[0].length;\\n        int[] result = new int[nItems];        \\n        int nItems = rowMax * colMax;\\n        rowMax--; colMax--;\\n        boolean up = true;\\n        \\n        for(int i=0, row=0, col=0; i < nItems; i++) {\\n            result[i] = mat[row][col];\\n            if(up){\\n                if(col == colMax){ // Check this condition first before the other else-if condition otherwise you\\'ll get ArrayOutOfBoundsException\\n                    row++;\\n                    up=false;\\n                } else if (row == 0){\\n                    col++;\\n                    up=false;\\n                } else {\\n                    row--; col++;\\n                }\\n            } else {\\n                if(row == rowMax){\\n                    col++;\\n                    up = true;\\n                } else if(col == 0) {\\n                    row++;\\n                    up = true;\\n                } else {\\n                    row++; col--;\\n                }\\n            }      \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        int rowMax = mat.length;\\n        int colMax = mat[0].length;\\n        int[] result = new int[nItems];        \\n        int nItems = rowMax * colMax;\\n        rowMax--; colMax--;\\n        boolean up = true;\\n        \\n        for(int i=0, row=0, col=0; i < nItems; i++) {\\n            result[i] = mat[row][col];\\n            if(up){\\n                if(col == colMax){ // Check this condition first before the other else-if condition otherwise you\\'ll get ArrayOutOfBoundsException\\n                    row++;\\n                    up=false;\\n                } else if (row == 0){\\n                    col++;\\n                    up=false;\\n                } else {\\n                    row--; col++;\\n                }\\n            } else {\\n                if(row == rowMax){\\n                    col++;\\n                    up = true;\\n                } else if(col == 0) {\\n                    row++;\\n                    up = true;\\n                } else {\\n                    row++; col--;\\n                }\\n            }      \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1511095,
                "title": "python-simplest-solution-with-explaination-beats-95",
                "content": "```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        \"\"\"\\n            Intuition:  The sum of indexes of each diagonal is same.\\n            [\\n                  0  1   2    3\\n                0[1, 2,  3,   4],\\n                1[5, 6,  7,   8],\\n                2[9, 10, 11, 12]\\n            ]\\n            First Diagonal: ((0,0)) => Sum = 0\\n            Second Diagonal: ((0,1), (1,0)) => Sum = 1\\n            Third Diagonal: ((0,2), (1,1), (2,0)) => Sum = 2\\n            Fourth Diagonal: ((0,3), (1,2), (2,1)) => Sum = 3\\n            Fifth Diagonal: ((1,3), (2,2)) => Sum = 4\\n            Sixth Diagonal: ((2,3)) => Sum = 5\\n\\n            Keeping the above intuition in mind let\\'s save all the elements for a particular sum of indexes ranges between 0 to (m-1) + (n-1) into a 2D list.\\n            Then sequentially iterate the items of hashmap in initial order and reverse order alternatively.\\n        \"\"\"\\n        m = len(mat)\\n        n = len(mat[0])\\n        hash = [[] for _ in range((m + n - 2) + 1)]\\n\\n        for r in range(m):\\n            for c in range(n):\\n                hash[r+c].append(mat[r][c])\\n\\n        output = []\\n        i = 0\\n        while i <= m + n - 2:\\n            output += hash[i] if i % 2 else hash[i][::-1]\\n            i += 1\\n\\n        return output\\n```\\n\\n***If  you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        \"\"\"\\n            Intuition:  The sum of indexes of each diagonal is same.\\n            [\\n                  0  1   2    3\\n                0[1, 2,  3,   4],\\n                1[5, 6,  7,   8],\\n                2[9, 10, 11, 12]\\n            ]\\n            First Diagonal: ((0,0)) => Sum = 0\\n            Second Diagonal: ((0,1), (1,0)) => Sum = 1\\n            Third Diagonal: ((0,2), (1,1), (2,0)) => Sum = 2\\n            Fourth Diagonal: ((0,3), (1,2), (2,1)) => Sum = 3\\n            Fifth Diagonal: ((1,3), (2,2)) => Sum = 4\\n            Sixth Diagonal: ((2,3)) => Sum = 5\\n\\n            Keeping the above intuition in mind let\\'s save all the elements for a particular sum of indexes ranges between 0 to (m-1) + (n-1) into a 2D list.\\n            Then sequentially iterate the items of hashmap in initial order and reverse order alternatively.\\n        \"\"\"\\n        m = len(mat)\\n        n = len(mat[0])\\n        hash = [[] for _ in range((m + n - 2) + 1)]\\n\\n        for r in range(m):\\n            for c in range(n):\\n                hash[r+c].append(mat[r][c])\\n\\n        output = []\\n        i = 0\\n        while i <= m + n - 2:\\n            output += hash[i] if i % 2 else hash[i][::-1]\\n            i += 1\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1508963,
                "title": "python-solution-dictionary-sum-of-index",
                "content": "```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        # Making a dictionary of keys = (row + col) as in a Diagonal treversal line (index of row + index of col) = constant. And values of Dictionary are elements of mat\\n        myDict = {}\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                if (i+j) not in myDict:\\n                    myDict[i+j] = [mat[i][j]]\\n                else:\\n                    myDict[i+j].append(mat[i][j])\\n                    \\n        #print(myDict)\\n        \\n        ans = []\\n        # adding values of myDict Diagonally in zigzag manner\\n        zigzag = False\\n        for i in myDict:\\n            if zigzag == True:\\n                ans += myDict[i]\\n                zigzag = False\\n            else:\\n                ans += myDict[i][::-1]\\n                zigzag = True\\n    \\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        # Making a dictionary of keys = (row + col) as in a Diagonal treversal line (index of row + index of col) = constant. And values of Dictionary are elements of mat\\n        myDict = {}\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                if (i+j) not in myDict:\\n                    myDict[i+j] = [mat[i][j]]\\n                else:\\n                    myDict[i+j].append(mat[i][j])\\n                    \\n        #print(myDict)\\n        \\n        ans = []\\n        # adding values of myDict Diagonally in zigzag manner\\n        zigzag = False\\n        for i in myDict:\\n            if zigzag == True:\\n                ans += myDict[i]\\n                zigzag = False\\n            else:\\n                ans += myDict[i][::-1]\\n                zigzag = True\\n    \\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456697,
                "title": "intuitive-spiral-bfs-traversal-based-o-nm-solution",
                "content": "Think of the matrix as a directed graph, where for each node (x, y) there are only two edges-\\n* (x, y) -> (x+1, y)\\n* (x, y) -> (x, y+1)\\n\\nNow, we can just run a spiral BFS traversal of the graph using a deque. Here is my Python implementation.\\n\\n```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        nr = len(mat)\\n        nc = len(mat[0])\\n        visited = [[False for j in range(nc)]  for i in range(nr)]\\n        \\n        def valid(x, y):\\n            return x >= 0 and x < nr and y >= 0 and y < nc and not visited[x][y]\\n        \\n        dq = deque()\\n        res = []\\n        toggle = True\\n        dq.append((0,0))\\n        while dq:\\n            s = len(dq)\\n            while s:\\n                if toggle:\\n                    x, y = dq.pop()\\n                    res.append(mat[x][y])\\n                    if valid(x+1, y):\\n                        dq.appendleft((x+1, y))\\n                        visited[x+1][y] = True\\n                    if valid(x, y+1):\\n                        dq.appendleft((x, y+1))\\n                        visited[x][y+1] = True\\n                else:\\n                    x, y = dq.popleft()\\n                    res.append(mat[x][y])\\n                    if valid(x, y+1):\\n                        dq.append((x, y+1))\\n                        visited[x][y+1] = True\\n                    if valid(x+1, y):\\n                        dq.append((x+1, y))\\n                        visited[x+1][y] = True\\n                s -= 1\\n            toggle = not toggle\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        nr = len(mat)\\n        nc = len(mat[0])\\n        visited = [[False for j in range(nc)]  for i in range(nr)]\\n        \\n        def valid(x, y):\\n            return x >= 0 and x < nr and y >= 0 and y < nc and not visited[x][y]\\n        \\n        dq = deque()\\n        res = []\\n        toggle = True\\n        dq.append((0,0))\\n        while dq:\\n            s = len(dq)\\n            while s:\\n                if toggle:\\n                    x, y = dq.pop()\\n                    res.append(mat[x][y])\\n                    if valid(x+1, y):\\n                        dq.appendleft((x+1, y))\\n                        visited[x+1][y] = True\\n                    if valid(x, y+1):\\n                        dq.appendleft((x, y+1))\\n                        visited[x][y+1] = True\\n                else:\\n                    x, y = dq.popleft()\\n                    res.append(mat[x][y])\\n                    if valid(x, y+1):\\n                        dq.append((x, y+1))\\n                        visited[x][y+1] = True\\n                    if valid(x+1, y):\\n                        dq.append((x+1, y))\\n                        visited[x+1][y] = True\\n                s -= 1\\n            toggle = not toggle\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156081,
                "title": "c-simple-solution-with-explaination",
                "content": "Note that sum of row index and column index are equal in diagional lines:\\n\\n- ```row +  col = K (constant)``` for 1 diagional line\\n- ```K range from 0 ~ (m+n-1)```\\n\\n```\\nclass Solution {\\npublic:\\n       \\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        vector<int> ans;\\n        \\n        for(int i = 0; i < m+n-1; i++){ // i == row index + col index. Range 0 ~ m+n-1\\n            if(i%2){ // Add values from top to bottom\\n                for(int r = 0; r <= i && r < m; r++){\\n                    int c = i - r;\\n                    if(c < n)\\n                        ans.push_back(mat[r][c]);\\n                }        \\n            }else{ // Add values from bottom to top\\n                for(int c = 0; c <= i && c < n ; c++){\\n                    int r = i - c;\\n                    if(r < m)\\n                        ans.push_back(mat[r][c]);\\n                }        \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```row +  col = K (constant)```\n```K range from 0 ~ (m+n-1)```\n```\\nclass Solution {\\npublic:\\n       \\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        vector<int> ans;\\n        \\n        for(int i = 0; i < m+n-1; i++){ // i == row index + col index. Range 0 ~ m+n-1\\n            if(i%2){ // Add values from top to bottom\\n                for(int r = 0; r <= i && r < m; r++){\\n                    int c = i - r;\\n                    if(c < n)\\n                        ans.push_back(mat[r][c]);\\n                }        \\n            }else{ // Add values from bottom to top\\n                for(int c = 0; c <= i && c < n ; c++){\\n                    int r = i - c;\\n                    if(r < m)\\n                        ans.push_back(mat[r][c]);\\n                }        \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 985759,
                "title": "c-one-pass-o-nm-short-code",
                "content": "So the idea is we are adding `(x, y)` which is initially `-1, 1`  to our current indexes `i, j`. That will make the arrow to go `up-right` since we are decreasing row index and increasing column index. We are gonna do this until the it\\'s out of bound/range. \\nWhen the indexes, `(i, j)`, are out of bound, we need to turn back into range.  \\nThen swap `x` and `y` i.e `(1, -1)`. Which will just make the arrow to go `down-left` by decreasing the column and increasing the row.\\n\\n```\\nvector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n\\tint i = 0, j = 0;\\n\\tint n = matrix.size();\\n\\tint m = n ? matrix[0].size() : 0;\\n\\tint x = -1, y = 1;\\n\\tvector<int> res;\\n\\twhile (res.size() < n * m) {\\n\\t\\tif (i == n || j == m || j < 0 || i < 0) {\\n\\t\\t\\tswap(x, y); // if it has been upward time to reverse it and vice versa.\\n\\t\\t\\tif (j == m) // this is just to turn back to the matrix since it is out of bound\\n\\t\\t\\t\\ti += 2, j--;\\n\\t\\t\\telse if (i == n)\\n\\t\\t\\t\\tj += 2, i--;\\n\\t\\t\\telse {\\n\\t\\t\\t\\ti += i < 0;\\n\\t\\t\\t\\tj += j < 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres.push_back(matrix[i][j]);\\n\\t\\ti += x;\\n\\t\\tj += y;\\n\\t}\\n\\treturn res;\\n}\\n```\\nHope this helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n\\tint i = 0, j = 0;\\n\\tint n = matrix.size();\\n\\tint m = n ? matrix[0].size() : 0;\\n\\tint x = -1, y = 1;\\n\\tvector<int> res;\\n\\twhile (res.size() < n * m) {\\n\\t\\tif (i == n || j == m || j < 0 || i < 0) {\\n\\t\\t\\tswap(x, y); // if it has been upward time to reverse it and vice versa.\\n\\t\\t\\tif (j == m) // this is just to turn back to the matrix since it is out of bound\\n\\t\\t\\t\\ti += 2, j--;\\n\\t\\t\\telse if (i == n)\\n\\t\\t\\t\\tj += 2, i--;\\n\\t\\t\\telse {\\n\\t\\t\\t\\ti += i < 0;\\n\\t\\t\\t\\tj += j < 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres.push_back(matrix[i][j]);\\n\\t\\ti += x;\\n\\t\\tj += y;\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 985686,
                "title": "simple-c-solution-with-o-1-space",
                "content": "class Solution {\\npublic:\\n*     vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        vector<int>res;\\n        if(!matrix.size() or !matrix[0].size())return res;\\n        int f=1,i=0,j=0,m=matrix.size(),n=matrix[0].size();   //  if f=1 moving up else moving down\\n        while(i<m and j<n)\\n        {\\n            res.push_back(matrix[i][j]);\\n            if(i==m-1 and j==n-1)break;\\n            if(f)\\n            {\\n               if(i>0 and j<n-1)\\n               {\\n                   i--;\\n                   j++;\\n               }\\n                else\\n                {\\n                    f=0;                 //changing the state(f) to move down\\n                    if(j==n-1)\\n                    {\\n                        i++;\\n                    }\\n                    else\\n                    {\\n                        j++;\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                if(j>0 and i<m-1)\\n               {\\n                   i++;\\n                   j--;\\n               }\\n                else\\n                {\\n                    f=1;                    //changing the state(f) to move up\\n                    if(i==m-1)\\n                    {\\n                        j++;\\n                    }\\n                    else\\n                    {\\n                        i++;\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n*     vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        vector<int>res;\\n        if(!matrix.size() or !matrix[0].size())return res;\\n        int f=1,i=0,j=0,m=matrix.size(),n=matrix[0].size();   //  if f=1 moving up else moving down\\n        while(i<m and j<n)\\n        {\\n            res.push_back(matrix[i][j]);\\n            if(i==m-1 and j==n-1)break;\\n            if(f)\\n            {\\n               if(i>0 and j<n-1)\\n               {\\n                   i--;\\n                   j++;\\n               }",
                "codeTag": "Java"
            },
            {
                "id": 754999,
                "title": "c-easy-solution",
                "content": "```\\n\\n```public:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        int m=matrix.size();\\n        vector<int>v;\\n        if(m==0)return v;\\n        int n=matrix[0].size();\\n        int i=0,j=0;\\n        for(int i=0;i<m+n-1;i++)\\n        {\\n            if(i&1)\\n            {\\n               for(int j=i;j>=0;j--)\\n               {\\n                   if(j<n&&i-j<m)\\n                   v.push_back(matrix[i-j][j]);\\n               }\\n            }\\n            else\\n            {\\n            for(int j=i;j>=0;j--)\\n                {\\n                    if(j<m&&(i-j)<n)\\n                       v.push_back(matrix[j][i-j]);\\n                }\\n            }\\n        }\\n        \\n        return v;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 719169,
                "title": "diagonal-traversal-with-algebraic-geometry",
                "content": "I have solved the Diagonal Traverse using some basic algebraic geometry. The initial idea was to assume that diagonal is a line on the 2D plane. We can represent that line as y = -x + b. Where b is our diagonal index. From that point we have to provide extra conditions for range of x and range of b. \\nThe b range is simple [0, yMax + xMax -1]. \\nThe x range can be represented as [minX , maxX] where minX can be calculated from y = -x + b assuming that the y has to be between [0, yMax]. In that case\\n0 <= -x + b <= yMax\\n-b <= -x <= yMax  - b\\nb >= x >= b - yMax\\nOur second restriction on the x range is [0, maxX] If we combine them together we can represent it in java as: \\nminX = Math.max(0, b - yMax)\\nmaxX = Math.min(b, xMax)\\n\\nThe other requirement is to to change the direction of traversal with every new value of b. \\nint dir = 1; // 1  up, -1 down\\ndir = -dir;\\n\\n\\nThat will affect our initial value of x so\\nint x = dir == 1 ? minX : maxX; \\n\\nThe interactive demo [Matrix Traversal Animation](https://www.desmos.com/calculator/pr8ttpqcl0)\\n![image](https://assets.leetcode.com/users/images/01eced8c-4323-4824-b439-953f6a25d7f1_1593899064.1739016.png)\\n\\n\\nThe full working algorithm with time complexity O(yMax * xMax) and space complexity O(1) assuming that the additional result array is the requirement of the task:\\n\\n```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        int yMax = matrix.length;\\n        int xMax = matrix[0].length;\\n        if (yMax == 0) {\\n            return new int[0];\\n        }\\n        int [] result = new int[xMax * yMax];\\n        int pos = 0;\\n        int dir = 1;\\n        \\n        for (int b = 0; b < xMax + yMax - 1; b++) {\\n            int minX = Math.max(b - (yMax - 1), 0);\\n            int maxX = Math.min(b, xMax - 1);\\n            int x = dir == 1 ? minX : maxX;\\n            \\n            while(x >= minX && x <= maxX) {\\n                int y = -x + b;\\n                result[pos++] = matrix[y][x];\\n                x += dir;\\n            }\\n            dir = -dir;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        int yMax = matrix.length;\\n        int xMax = matrix[0].length;\\n        if (yMax == 0) {\\n            return new int[0];\\n        }\\n        int [] result = new int[xMax * yMax];\\n        int pos = 0;\\n        int dir = 1;\\n        \\n        for (int b = 0; b < xMax + yMax - 1; b++) {\\n            int minX = Math.max(b - (yMax - 1), 0);\\n            int maxX = Math.min(b, xMax - 1);\\n            int x = dir == 1 ? minX : maxX;\\n            \\n            while(x >= minX && x <= maxX) {\\n                int y = -x + b;\\n                result[pos++] = matrix[y][x];\\n                x += dir;\\n            }\\n            dir = -dir;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 653968,
                "title": "java-95-faster-o-n-m",
                "content": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if(matrix == null || matrix.length == 0)\\n            return new int[]{};\\n        int n = matrix.length, m = matrix[0].length;\\n        int total = n*m;\\n        int arr[] = new int[total];\\n        boolean up = true;\\n        for(int x = 0, i = 0, j = 0; x < total; x++){\\n            arr[x] = matrix[i][j];\\n            if(up){\\n                if(j == m-1){ i++; up = false; }\\n                else if(i == 0){ j++; up = false; }\\n                else{ i--; j++; }\\n            }\\n            else{\\n                if(i == n-1){ j++; up = true; }\\n                else if(j == 0){ i++; up =true; }\\n                else{ i++; j--; }\\n            }\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if(matrix == null || matrix.length == 0)\\n            return new int[]{}",
                "codeTag": "Java"
            },
            {
                "id": 651037,
                "title": "easiest-c-solution-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& a) {\\n        vector<int> ans;\\n        int i,j,n,m;\\n        n= a.size();\\n        if(n==0)\\n            return ans;\\n        \\n        m = a[0].size();\\n        \\n        map<int,vector<int>> map;\\n        \\n        for(i=0; i<n; i++){\\n            for(j=0; j<m; j++){\\n                map[i+j].push_back(a[i][j]);  \\n            }\\n        }\\n        \\n        for(auto itr=map.begin(); itr!=map.end(); itr++){\\n            int index = itr->first;    \\n            vector<int> temp = itr->second;\\n            if(index%2==0){\\n                for(i=temp.size()-1; i>=0; i--){\\n                    ans.push_back(temp[i]);\\n                    \\n                }\\n            }\\n            else{\\n                for(i=0; i<temp.size(); i++){\\n                    ans.push_back(temp[i]);\\n                    \\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& a) {\\n        vector<int> ans;\\n        int i,j,n,m;\\n        n= a.size();\\n        if(n==0)\\n            return ans;\\n        \\n        m = a[0].size();\\n        \\n        map<int,vector<int>> map;\\n        \\n        for(i=0; i<n; i++){\\n            for(j=0; j<m; j++){\\n                map[i+j].push_back(a[i][j]);  \\n            }\\n        }\\n        \\n        for(auto itr=map.begin(); itr!=map.end(); itr++){\\n            int index = itr->first;    \\n            vector<int> temp = itr->second;\\n            if(index%2==0){\\n                for(i=temp.size()-1; i>=0; i--){\\n                    ans.push_back(temp[i]);\\n                    \\n                }\\n            }\\n            else{\\n                for(i=0; i<temp.size(); i++){\\n                    ans.push_back(temp[i]);\\n                    \\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357154,
                "title": "simple-java-solution-beats-100-1-ms-runtime",
                "content": "Java Code::\\n\\n```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        int row = matrix.length;\\n        if(row == 0) return (new int[0]); //if empty matrix\\n        int col = matrix[0].length;\\n        int[] ans = new int[row*col];\\n        int index = 0;\\n        int i =0, j=0;\\n        \\n        while(i<row && j<col){\\n            \\n            while(i>=0 && j<col){ //moving up\\n                ans[index] = matrix[i][j];\\n                index++;\\n                j++;\\n                i--;\\n            }\\n            i++;\\n            if(j==col){ //reach beyond column\\n                i++;\\n                j--;\\n            }\\n            while(j>=0 && i<row){ //moving down\\n                ans[index] = matrix[i][j];\\n                index++;\\n                i++;\\n                j--;\\n            }\\n            j++;\\n            if(i==row){ //reach beyond row\\n                i--;\\n                j++;\\n            }\\n           // for(int tmp = 0; tmp<index;tmp++) System.out.print(ans[tmp]+\" \");\\n        }\\n        return ans;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        int row = matrix.length;\\n        if(row == 0) return (new int[0]); //if empty matrix\\n        int col = matrix[0].length;\\n        int[] ans = new int[row*col];\\n        int index = 0;\\n        int i =0, j=0;\\n        \\n        while(i<row && j<col){\\n            \\n            while(i>=0 && j<col){ //moving up\\n                ans[index] = matrix[i][j];\\n                index++;\\n                j++;\\n                i--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 225508,
                "title": "simple-intuitive-java-solution-5ms",
                "content": "```java\\npublic int[] findDiagonalOrder(int[][] matrix) {\\n  int m = matrix.length;\\n  if (m == 0)\\n    return new int[0];\\n  int n = matrix[0].length;\\n  int[] answer = new int[m*n];\\n\\n  int x = 0;\\n  int y = 0;\\n  int index = 0;\\n\\n  // (m + n - 1) repeats the diagonal\\n  for (int i = 0; i < m + n - 1; i++) {\\n    // i is even number: Right upward\\n    if (i % 2 == 0) {\\n      answer[index++] = matrix[x][y];\\n      while (x > 0 && y < matrix[0].length-1) {\\n        x--;\\n        y++;\\n        answer[index++] = matrix[x][y];\\n      }\\n\\t  // After going all the way to the right upward, decide the starting point of next left downward loop\\n      if (y != matrix[0].length-1)  y++;\\n      else x++;\\n    }\\n    // i is odd number: Left downward\\n    else {\\n      answer[index++] = matrix[x][y];\\n      while (y > 0 && x < matrix.length-1) {\\n        x++;\\n        y--;\\n        answer[index++] = matrix[x][y];\\n      }\\n      // After going all the way to the left downward, decide the starting point of next right upward loop\\n      if (x != matrix.length-1)  x++;\\n      else y++;\\n    }\\n  }\\n\\n  return answer;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int[] findDiagonalOrder(int[][] matrix) {\\n  int m = matrix.length;\\n  if (m == 0)\\n    return new int[0];\\n  int n = matrix[0].length;\\n  int[] answer = new int[m*n];\\n\\n  int x = 0;\\n  int y = 0;\\n  int index = 0;\\n\\n  // (m + n - 1) repeats the diagonal\\n  for (int i = 0; i < m + n - 1; i++) {\\n    // i is even number: Right upward\\n    if (i % 2 == 0) {\\n      answer[index++] = matrix[x][y];\\n      while (x > 0 && y < matrix[0].length-1) {\\n        x--;\\n        y++;\\n        answer[index++] = matrix[x][y];\\n      }\\n\\t  // After going all the way to the right upward, decide the starting point of next left downward loop\\n      if (y != matrix[0].length-1)  y++;\\n      else x++;\\n    }\\n    // i is odd number: Left downward\\n    else {\\n      answer[index++] = matrix[x][y];\\n      while (y > 0 && x < matrix.length-1) {\\n        x++;\\n        y--;\\n        answer[index++] = matrix[x][y];\\n      }\\n      // After going all the way to the left downward, decide the starting point of next right upward loop\\n      if (x != matrix.length-1)  x++;\\n      else y++;\\n    }\\n  }\\n\\n  return answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 224387,
                "title": "simple-bfs-python",
                "content": "```\\ndef findDiagonalOrder(self, a):        \\n        if not a: return []       \\n        m, n = len(a), len(a[0])\\n        ans = [(0, 0)]\\n        q = ans[:]\\n        for i in range(m+n-2):\\n            nxt_q = []\\n            for j, e in enumerate(q):\\n                x, y = e\\n                if j == 0 and x < m-1: nxt_q.append((x+1, y))\\n                if y < n-1: nxt_q.append((x, y+1))            \\n            q = nxt_q\\n            ans.extend(q if i % 2 == 1 else q[::-1])\\n        return [a[x][y] for x, y in ans]",
                "solutionTags": [],
                "code": "```\\ndef findDiagonalOrder(self, a):        \\n        if not a: return []       \\n        m, n = len(a), len(a[0])\\n        ans = [(0, 0)]\\n        q = ans[:]\\n        for i in range(m+n-2):\\n            nxt_q = []\\n            for j, e in enumerate(q):\\n                x, y = e\\n                if j == 0 and x < m-1: nxt_q.append((x+1, y))\\n                if y < n-1: nxt_q.append((x, y+1))            \\n            q = nxt_q\\n            ans.extend(q if i % 2 == 1 else q[::-1])\\n        return [a[x][y] for x, y in ans]",
                "codeTag": "Python3"
            },
            {
                "id": 207184,
                "title": "easy-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not matrix or not matrix[0]:\\n            return []\\n        ans = []\\n        i = j = 0\\n        M = len(matrix)\\n        N = len(matrix[0])\\n        direction = \\'up\\'\\n        while (i, j) != (M-1, N-1):\\n            ans.append(matrix[i][j])\\n            if direction == \\'up\\':\\n                if j == N-1: # already at the very right\\n                    i += 1\\n                    direction = \\'down\\'\\n                elif i == 0: # already at the very top\\n                    j += 1\\n                    direction = \\'down\\'\\n                else:\\n                    i -= 1\\n                    j += 1\\n\\n            else:\\n                if i == M-1: # already at the very bottom\\n                    j += 1\\n                    direction = \\'up\\'\\n                elif j == 0: # already at the very left\\n                    i += 1\\n                    direction = \\'up\\'\\n                else:\\n                    i += 1\\n                    j -= 1\\n\\n        ans.append(matrix[M-1][N-1])\\n\\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not matrix or not matrix[0]:\\n            return []\\n        ans = []\\n        i = j = 0\\n        M = len(matrix)\\n        N = len(matrix[0])\\n        direction = \\'up\\'\\n        while (i, j) != (M-1, N-1):\\n            ans.append(matrix[i][j])\\n            if direction == \\'up\\':\\n                if j == N-1: # already at the very right\\n                    i += 1\\n                    direction = \\'down\\'\\n                elif i == 0: # already at the very top\\n                    j += 1\\n                    direction = \\'down\\'\\n                else:\\n                    i -= 1\\n                    j += 1\\n\\n            else:\\n                if i == M-1: # already at the very bottom\\n                    j += 1\\n                    direction = \\'up\\'\\n                elif j == 0: # already at the very left\\n                    i += 1\\n                    direction = \\'up\\'\\n                else:\\n                    i += 1\\n                    j -= 1\\n\\n        ans.append(matrix[M-1][N-1])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 137005,
                "title": "using-sum-and-directions-cases",
                "content": "```\\n    def findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        if len(matrix) == 0:\\n            return []\\n        \\n        max_row = len(matrix) - 1\\n        max_col = len(matrix[0]) -1\\n        \\n        res = []\\n        row = 0\\n        col = 0\\n        \\n      \\n      \\n        \"\"\"\\n        1. Sum = row + col \\n        2. Same diagonal line has same sum. Ex (2,0)(1,1)(0,2) \\n        3. Even sum has UpRight direction. Odd sum has DownLeft direction\\n        4. UpRight either starts from row = max_row or col = 0 --> row = sum - col = sum. That\\'s why starting row = min(sum,max_row)\\n        5. DownLeft either starts from col = max_col or row = 0 --> col = sum - row = sum.  That\\'s why starting col = min(sum,max_col)\\n        \\n             0  1  2  \\n           -----------\\n        0 |  1  2  3\\n        1 |  4  5  6\\n        2 |  7  8  9\\n     \\n        \"\"\"\\n        for sum in range(max_row + max_col +1):\\n            if sum%2 == 0: # Move UpRight => need to find starting row see 4\\n                row = min(sum, max_row)\\n                col = sum - row\\n                \\n                while row >= 0 and col <= max_col:\\n                    res.append(matrix[row][col])\\n                    row -=1\\n                    col +=1\\n             \\n            else: # Move DownLeft => need to find starting col see 5\\n               col = min(sum, max_col)\\n               row = sum - col\\n               \\n               while row <= max_row and col >=0:\\n                    res.append(matrix[row][col])\\n                    row +=1\\n                    col -=1\\n        \\n        return res\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\n    def findDiagonalOrder(self, matrix):\\n        \"\"\"\\n        :type matrix: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        if len(matrix) == 0:\\n            return []\\n        \\n        max_row = len(matrix) - 1\\n        max_col = len(matrix[0]) -1\\n        \\n        res = []\\n        row = 0\\n        col = 0\\n        \\n      \\n      \\n        \"\"\"\\n        1. Sum = row + col \\n        2. Same diagonal line has same sum. Ex (2,0)(1,1)(0,2) \\n        3. Even sum has UpRight direction. Odd sum has DownLeft direction\\n        4. UpRight either starts from row = max_row or col = 0 --> row = sum - col = sum. That\\'s why starting row = min(sum,max_row)\\n        5. DownLeft either starts from col = max_col or row = 0 --> col = sum - row = sum.  That\\'s why starting col = min(sum,max_col)\\n        \\n             0  1  2  \\n           -----------\\n        0 |  1  2  3\\n        1 |  4  5  6\\n        2 |  7  8  9\\n     \\n        \"\"\"\\n        for sum in range(max_row + max_col +1):\\n            if sum%2 == 0: # Move UpRight => need to find starting row see 4\\n                row = min(sum, max_row)\\n                col = sum - row\\n                \\n                while row >= 0 and col <= max_col:\\n                    res.append(matrix[row][col])\\n                    row -=1\\n                    col +=1\\n             \\n            else: # Move DownLeft => need to find starting col see 5\\n               col = min(sum, max_col)\\n               row = sum - col\\n               \\n               while row <= max_row and col >=0:\\n                    res.append(matrix[row][col])\\n                    row +=1\\n                    col -=1\\n        \\n        return res\\n                    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 97725,
                "title": "5-lines-of-java",
                "content": "Short and quite simple: `d` iterates through every diagonal (i.e. `d < m.length + m[0].length - 1`), we calculate the start (`lo`) and end (`hi`) columns, and advance them towards each other:\\n```java\\nint[] findDiagonalOrder(int[][] m) {\\n  int[] result = new int[(m.length == 0) ? 0 : m.length * m[0].length];\\n  for (int d = 0, i = 0; i < result.length; d++)\\n    for (int lo = d - min(d, m.length - 1), hi = min(d, m[0].length - 1); lo <= hi; )\\n      result[i++] = ((d & 1) == 0) ? m[d - lo][lo++] : m[d - hi][hi--];\\n  return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nint[] findDiagonalOrder(int[][] m) {\\n  int[] result = new int[(m.length == 0) ? 0 : m.length * m[0].length];\\n  for (int d = 0, i = 0; i < result.length; d++)\\n    for (int lo = d - min(d, m.length - 1), hi = min(d, m[0].length - 1); lo <= hi; )\\n      result[i++] = ((d & 1) == 0) ? m[d - lo][lo++] : m[d - hi][hi--];\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 97758,
                "title": "all-elements-on-the-same-diagonal-have-same-row-col-values-easy-to-understand-python-solution",
                "content": "'''\\n\\n    from collections import deque\\n    class Solution(object):\\n\\n        def findDiagonalOrder(self, matrix):\\n        \\n            if not matrix or not matrix[0]:\\n                return []\\n        \\n            diagonalrow = len(matrix) + len(matrix[0]) + 1\\n            flatten = [deque() for i in xrange(diagonalrow)]\\n        \\n            for i in xrange(len(matrix)):\\n                for j in xrange(len(matrix[0])):\\n                    index = i + j\\n                    if index % 2 == 0:\\n                        flatten[index].appendleft(matrix[i][j])\\n                    else:\\n                        flatten[index].append(matrix[i][j])\\n        \\n            ans = []\\n            for seq in flatten:\\n                ans.extend(seq)\\n            \\n            return ans\\n'''",
                "solutionTags": [],
                "code": "'''\\n\\n    from collections import deque\\n    class Solution(object):\\n\\n        def findDiagonalOrder(self, matrix):\\n        \\n            if not matrix or not matrix[0]:\\n                return []\\n        \\n            diagonalrow = len(matrix) + len(matrix[0]) + 1\\n            flatten = [deque() for i in xrange(diagonalrow)]\\n        \\n            for i in xrange(len(matrix)):\\n                for j in xrange(len(matrix[0])):\\n                    index = i + j\\n                    if index % 2 == 0:\\n                        flatten[index].appendleft(matrix[i][j])\\n                    else:\\n                        flatten[index].append(matrix[i][j])\\n        \\n            ans = []\\n            for seq in flatten:\\n                ans.extend(seq)\\n            \\n            return ans\\n'''",
                "codeTag": "Java"
            },
            {
                "id": 97775,
                "title": "6-liner-c-o-m-n-print-values-by-diagonals-with-explanation",
                "content": "**Key Observation:** \\n1. For each diagonal, all entries `a[i][j]` have constant index sum `i+j`.\\n2. Print a diagonal towards upper right direction iff `i+j` is even.\\n```\\n    vector<int> findDiagonalOrder(vector<vector<int>>& a) {\\n      int m, n, L, R; vector<int> res;\\n      if ((m = a.size()) && (n = a[0].size()))\\n        for (int i=0; L=max(i-m+1,0), R=min(n-1,i), i<m+n-1; ++i)\\n          if (i%2) for (int j = R; j >= L; --j) res.push_back(a[i-j][j]);\\n          else     for (int j = L; j <= R; ++j) res.push_back(a[i-j][j]);\\n\\n      return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\n    vector<int> findDiagonalOrder(vector<vector<int>>& a) {\\n      int m, n, L, R; vector<int> res;\\n      if ((m = a.size()) && (n = a[0].size()))\\n        for (int i=0; L=max(i-m+1,0), R=min(n-1,i), i<m+n-1; ++i)\\n          if (i%2) for (int j = R; j >= L; --j) res.push_back(a[i-j][j]);\\n          else     for (int j = L; j <= R; ++j) res.push_back(a[i-j][j]);\\n\\n      return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952395,
                "title": "c-dividing-into-two-straps-easy-solution-faster-than-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        // Intution\\n        // The idea in here is really very simple. We know that by maintains two straps details i.e., First row + Last column and First column + Last row we can get the required elements but only the starting location changes in both the cases.\\n        vector<int> answer;\\n\\n        vector<pair<int, int>> strap1;\\n        vector<pair<int, int>> strap2;\\n\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        for(int i = 0 ; i < n ; i++) strap1.push_back({0, i});\\n        for(int i = 1 ; i < m ; i++) strap1.push_back({i, n - 1});\\n\\n        for(int i = 0 ; i < m ; i++) strap2.push_back({i, 0});\\n        for(int i = 1 ; i < n ; i++) strap2.push_back({m - 1, i});\\n\\n        bool toggler = false;\\n\\n        int total = strap1.size();\\n\\n        int ind = 0;\\n\\n        while(total --> 0){\\n            if(!toggler){\\n                int r = strap2[ind].first;\\n                int c = strap2[ind].second;\\n                while(r >= 0 and c < n){\\n                    answer.push_back(mat[r][c]);\\n                    r -= 1;\\n                    c += 1;\\n                }\\n            }\\n            else{\\n                int r = strap1[ind].first;\\n                int c = strap1[ind].second;\\n                while(c >= 0 and r < m){\\n                    answer.push_back(mat[r][c]);\\n                    c -= 1;\\n                    r += 1;\\n                }\\n            }\\n            if(toggler) toggler = false;\\n            else toggler = true;\\n            ind += 1;\\n        }\\n\\n        return answer;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        // Intution\\n        // The idea in here is really very simple. We know that by maintains two straps details i.e., First row + Last column and First column + Last row we can get the required elements but only the starting location changes in both the cases.\\n        vector<int> answer;\\n\\n        vector<pair<int, int>> strap1;\\n        vector<pair<int, int>> strap2;\\n\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        for(int i = 0 ; i < n ; i++) strap1.push_back({0, i});\\n        for(int i = 1 ; i < m ; i++) strap1.push_back({i, n - 1});\\n\\n        for(int i = 0 ; i < m ; i++) strap2.push_back({i, 0});\\n        for(int i = 1 ; i < n ; i++) strap2.push_back({m - 1, i});\\n\\n        bool toggler = false;\\n\\n        int total = strap1.size();\\n\\n        int ind = 0;\\n\\n        while(total --> 0){\\n            if(!toggler){\\n                int r = strap2[ind].first;\\n                int c = strap2[ind].second;\\n                while(r >= 0 and c < n){\\n                    answer.push_back(mat[r][c]);\\n                    r -= 1;\\n                    c += 1;\\n                }\\n            }\\n            else{\\n                int r = strap1[ind].first;\\n                int c = strap1[ind].second;\\n                while(c >= 0 and r < m){\\n                    answer.push_back(mat[r][c]);\\n                    c -= 1;\\n                    r += 1;\\n                }\\n            }\\n            if(toggler) toggler = false;\\n            else toggler = true;\\n            ind += 1;\\n        }\\n\\n        return answer;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605339,
                "title": "java-code-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n O(m*n)\\n\\n- Space complexity:\\nSpace complexity: O(n)\\n\\n# Code\\n```\\n//Time complexity: O(m*n)\\n//Space complexity: O(n)\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;       \\n        int[] arr = new int[m * n];\\n        int row = 0;\\n        int col = 0;\\n        int i = 0;\\n        boolean up = true;\\n        while(row<m && col<n) {\\n            //if diagonal is going up\\n            if(up) {\\n                while(row>0 && col<n-1) {\\n                    arr[i++] = mat[row][col];\\n                    row--;\\n                    col++;\\n                }\\n                arr[i++] = mat[row][col];\\n                if(col==n-1){\\n                    row++;\\n                } else{\\n                    col++;\\n                }\\n\\n            } //if diagonal is going down \\n            else {\\n                while(col>0 && row<m-1) {\\n                    arr[i++] = mat[row][col];\\n                    row++;\\n                    col--;\\n                }\\n                arr[i++] = mat[row][col];\\n                if(row==m-1){\\n                    col++;\\n                } else{\\n                    row++;\\n                }\\n            }\\n            up = !up;\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Time complexity: O(m*n)\\n//Space complexity: O(n)\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;       \\n        int[] arr = new int[m * n];\\n        int row = 0;\\n        int col = 0;\\n        int i = 0;\\n        boolean up = true;\\n        while(row<m && col<n) {\\n            //if diagonal is going up\\n            if(up) {\\n                while(row>0 && col<n-1) {\\n                    arr[i++] = mat[row][col];\\n                    row--;\\n                    col++;\\n                }\\n                arr[i++] = mat[row][col];\\n                if(col==n-1){\\n                    row++;\\n                } else{\\n                    col++;\\n                }\\n\\n            } //if diagonal is going down \\n            else {\\n                while(col>0 && row<m-1) {\\n                    arr[i++] = mat[row][col];\\n                    row++;\\n                    col--;\\n                }\\n                arr[i++] = mat[row][col];\\n                if(row==m-1){\\n                    col++;\\n                } else{\\n                    row++;\\n                }\\n            }\\n            up = !up;\\n        }\\n\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602116,
                "title": "c-easy-solution-simulating-the-movement-tc-o-n-m",
                "content": "# Intuition\\nThe problem is depicts what needs to be done. We have to traverse the matrix\\'s diagonals alternately which is shown in the image provided.\\n![image.png](https://assets.leetcode.com/users/images/0164a920-ed10-47c6-932a-acd8cdd5e7f2_1685994705.035149.png)\\nWe have to move in this sort of zigzag fashion. There\\'s nothing more to the intuition since we know that we have to simulate, so in this kind of question the approach is more important.\\n\\n\\n# Approach\\nWe start from `(0,0)` and try moving towards the **top right**. Since we\\'re at the top, we move to the next columns and change the direction to **bottom left**. We keep moving until we hit the left end. Here we have to move to the next row and **swap the direction** again. We keep repeating this until we reach the last element.\\n\\nWe have 4 condition to check (order matters):\\nWe swap the directions in all 4 cases because they mean that we\\'ve reached an edge or a corner.\\n1. if `i==0` && `dirY == -1`. In this case we\\'ve reached a top most point from where we need to check if `j==n-1` because in that case we cannot increase `j` and have to increase `i` instead. This is because if we\\'re at the last column, we need to go down because we clearly can\\'t go right.\\n2. if `i==m-1` and `dirY == 1` then it means we\\'ve reached the last row. In this case we need to increase `j` by one so that we go to the next column to move to **top right** again.\\n3. if `j==0` and `dirX==-1`. If we\\'ve reached the first column, if we\\'re at the first row we\\'ll increase `j` otherwise we\\'ll increase `i`. We\\'ve kept this condition after *2* because in case if we hit the bottom left corner, this operation will move the position out of the matrix\\'s bounds.\\n4. if `j==n-1` and `dirX==1`. This condition occurs when we\\'ve reahed the last column. So we just increase `i` and go for the next diagonal.\\n\\nIn any other case we just move the current location based on our current direction.\\nEvery iteration we add the current element to the result array,\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int m = mat.size(), n=mat[0].size();\\n        int i{0}, j{0};\\n        vector<int> res;\\n        int dirY = -1, dirX = 1;\\n        while(i!=m-1 || j!=n-1) {\\n            res.push_back(mat[i][j]);\\n            if (i==0 && dirY==-1) {\\n                if (j==n-1)\\n                    i++;\\n                else\\n                    j++;\\n                swap(dirX, dirY);\\n            }\\n            else if (i==m-1 && dirY==1) {\\n                j++;\\n                swap(dirX, dirY);\\n            }\\n            else if (j==0 && dirX==-1) {\\n                if (i==0)\\n                    j++;\\n                else\\n                    i++;\\n                swap(dirX, dirY);\\n            }\\n            else if (j==n-1 && dirX==1) {\\n                i++;\\n                swap(dirX, dirY);\\n            }\\n            else {\\n                i += dirY;\\n                j += dirX;\\n            }\\n        }\\n        res.push_back(mat[i][j]);\\n\\n        return res;\\n    }\\n};\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\nSince we\\'re traversing the entire matrix (just in a peculiar way).\\n\\n- Space complexity: $$O(1)$$\\nWe\\'re not using any extra space apart from storing the result which takes $$O(n*m)$$ space.\\n\\n\\n> ### Note\\n> - Upvote if you liked my solution\\n> - Drop a comment if you have any doubt",
                "solutionTags": [
                    "C++",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int m = mat.size(), n=mat[0].size();\\n        int i{0}, j{0};\\n        vector<int> res;\\n        int dirY = -1, dirX = 1;\\n        while(i!=m-1 || j!=n-1) {\\n            res.push_back(mat[i][j]);\\n            if (i==0 && dirY==-1) {\\n                if (j==n-1)\\n                    i++;\\n                else\\n                    j++;\\n                swap(dirX, dirY);\\n            }\\n            else if (i==m-1 && dirY==1) {\\n                j++;\\n                swap(dirX, dirY);\\n            }\\n            else if (j==0 && dirX==-1) {\\n                if (i==0)\\n                    j++;\\n                else\\n                    i++;\\n                swap(dirX, dirY);\\n            }\\n            else if (j==n-1 && dirX==1) {\\n                i++;\\n                swap(dirX, dirY);\\n            }\\n            else {\\n                i += dirY;\\n                j += dirX;\\n            }\\n        }\\n        res.push_back(mat[i][j]);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3601939,
                "title": "detailed-explanation-of-approach-and-code-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is very easy, you however have to code it very carefully as careless implementation can lead to errors due to edge cases and TLE.\\n\\nThe only directions we need to travel in are the **top right** and **bottom left** diagonal directions. We only need to keep alternating between them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe first step I took towards solving the problem was to make helper functions that traverse the array in the **top right** and **bottom left** diagonal directions.\\n\\nWe initialize three variables; n, m, dir - m and n being the indices for the matrix and dir being used to determine which direction we need to go.\\n$$n = 0$$ \\n$$m = 0$$\\n$$dir = 0$$ (\"0\"  for upward diagonal and \"1\" for downward diagonal)\\n\\nNow we simply need to loop untill we have traversed all the elements in the matrix in this manner.\\n\\nIn the helper functions, we end up in positions that are outside the matrix. hence once we return from those functions, we need to fix our position to the next element we need to traverse from.\\n\\nIn the code, this is done right after the functions are called. Dry running the first sample test case will make it extremely clear.\\n# Complexity\\n- Time complexity: Since we traverse through every element once the time complexity is **$$O(m * n)$$** where m and n are dimensions of the matrix.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: Except the output array, the space complexity of the solution is **$$O(1)$$**.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n// Answer variable is declared here for ease of access\\n    vector<int> ans;\\n    // Function to traverse in the bottom left direction and add the values to answer\\n    void bottom_left(vector<vector<int>>& mat, int& m, int& n){\\n\\n        while(m >= 0 && m < mat.size() && n >= 0 && n < mat[0].size()){\\n            ans.push_back(mat[m][n]);\\n            m++;\\n            n--;\\n        }\\n    }\\n    // Function to traverse in the top right direction and add the values to answer\\n    void top_right(vector<vector<int>>& mat, int& m, int& n){\\n\\n        while(m >= 0 && m < mat.size() && n >= 0 && n < mat[0].size()){\\n            ans.push_back(mat[m][n]);\\n            m--;\\n            n++;\\n        }\\n    }\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        // initial position is 0, 0\\n        int m = 0;\\n        int n = 0;\\n\\n        // variable to determine if we go in the top-right or bottom-left directions\\n        int dir = 0;\\n        cout << ans.size();\\n        while(ans.size() < mat.size() * mat[0].size()){\\n            if(dir == 0){\\n                // for(auto i : ans)cout << i << \" \";\\n                // cout << endl;\\n                top_right(mat, m, n);\\n\\n                if(n > mat[0].size() - 1){\\n                    m +=2;\\n                    n--;\\n                }\\n                else if(m < 0){\\n                    m++;\\n                }\\n\\n                dir = 1;\\n            }\\n            else{\\n                // for(auto i : ans)cout << i << \" \";\\n                // cout << endl;\\n                bottom_left(mat, m, n);\\n\\n                if(m >= mat.size()){\\n                    n += 2;\\n                    m--;\\n                }\\n                else if(n < 0){\\n                    n++;\\n                }\\n                dir = 0;\\n            }\\n        }\\n        // for(auto i : ans)cout << i << \" \";\\n        //         cout << endl;\\n        // cout << \"complete\" << endl;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n// Answer variable is declared here for ease of access\\n    vector<int> ans;\\n    // Function to traverse in the bottom left direction and add the values to answer\\n    void bottom_left(vector<vector<int>>& mat, int& m, int& n){\\n\\n        while(m >= 0 && m < mat.size() && n >= 0 && n < mat[0].size()){\\n            ans.push_back(mat[m][n]);\\n            m++;\\n            n--;\\n        }\\n    }\\n    // Function to traverse in the top right direction and add the values to answer\\n    void top_right(vector<vector<int>>& mat, int& m, int& n){\\n\\n        while(m >= 0 && m < mat.size() && n >= 0 && n < mat[0].size()){\\n            ans.push_back(mat[m][n]);\\n            m--;\\n            n++;\\n        }\\n    }\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        // initial position is 0, 0\\n        int m = 0;\\n        int n = 0;\\n\\n        // variable to determine if we go in the top-right or bottom-left directions\\n        int dir = 0;\\n        cout << ans.size();\\n        while(ans.size() < mat.size() * mat[0].size()){\\n            if(dir == 0){\\n                // for(auto i : ans)cout << i << \" \";\\n                // cout << endl;\\n                top_right(mat, m, n);\\n\\n                if(n > mat[0].size() - 1){\\n                    m +=2;\\n                    n--;\\n                }\\n                else if(m < 0){\\n                    m++;\\n                }\\n\\n                dir = 1;\\n            }\\n            else{\\n                // for(auto i : ans)cout << i << \" \";\\n                // cout << endl;\\n                bottom_left(mat, m, n);\\n\\n                if(m >= mat.size()){\\n                    n += 2;\\n                    m--;\\n                }\\n                else if(n < 0){\\n                    n++;\\n                }\\n                dir = 0;\\n            }\\n        }\\n        // for(auto i : ans)cout << i << \" \";\\n        //         cout << endl;\\n        // cout << \"complete\" << endl;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3600918,
                "title": "most-simplest-approach-solving-this-problem-using-map-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n        vector<int> findDiagonalOrder(vector<vector<int>>& matrix) \\n        {\\n            \\n            vector<int>ans;\\n            map<int,vector<int>>m;\\n\\n            // we are push the matrix element digonally in map\\n            for(int i=0;i<matrix.size();i++)\\n            {\\n                for(int j=0;j<matrix[0].size();j++)\\n                {\\n                    m[i+j].push_back(matrix[i][j]);\\n                }\\n            }\\n\\n            // //  print map values\\n            // for(auto i:m)\\n            // {\\n            //     cout<<i.first<<\"->\";\\n            //     for(auto j:i.second)\\n            //     {\\n            //         cout<<j<<\",\";\\n            //     }\\n\\n            //     cout<<endl;\\n            // }\\n\\n            \\n           for(auto i:m) \\n           {\\n            if((i.first)%2 == 0) \\n                reverse(i.second.begin(), i.second.end()); \\n            \\n            for(auto j: i.second) \\n            ans.push_back(j);\\n\\n        }\\n\\n\\n\\n            return ans;\\n        }\\n  \\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nclass Solution {\\npublic:\\n        vector<int> findDiagonalOrder(vector<vector<int>>& matrix) \\n        {\\n            \\n            vector<int>ans;\\n            map<int,vector<int>>m;\\n\\n            // we are push the matrix element digonally in map\\n            for(int i=0;i<matrix.size();i++)\\n            {\\n                for(int j=0;j<matrix[0].size();j++)\\n                {\\n                    m[i+j].push_back(matrix[i][j]);\\n                }\\n            }\\n\\n            // //  print map values\\n            // for(auto i:m)\\n            // {\\n            //     cout<<i.first<<\"->\";\\n            //     for(auto j:i.second)\\n            //     {\\n            //         cout<<j<<\",\";\\n            //     }\\n\\n            //     cout<<endl;\\n            // }\\n\\n            \\n           for(auto i:m) \\n           {\\n            if((i.first)%2 == 0) \\n                reverse(i.second.begin(), i.second.end()); \\n            \\n            for(auto j: i.second) \\n            ans.push_back(j);\\n\\n        }\\n\\n\\n\\n            return ans;\\n        }\\n  \\n};\\n\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3462965,
                "title": "java-beats-100-1ms-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        int[] ans = new int[m * n];\\n        int index = 0;\\n\\n        int i = 0;\\n        int j = 0;\\n        ans[index++] = mat[i][j];\\n\\n        boolean isUp = true;\\n        while(index != ans.length) {\\n            if(isUp) {\\n                j += 1;\\n\\n                while(j != 0 && i != m - 1) {\\n                    if(j < n) {\\n                        ans[index++] = mat[i][j];\\n                    }\\n                    i++;\\n                    j--;\\n                }\\n\\n                ans[index++] = mat[i][j];\\n                isUp = false;\\n            } else {\\n                i += 1;\\n\\n                while(i != 0 && j != n - 1) {\\n                    if(i < m) {\\n                        ans[index++] = mat[i][j];\\n                    }\\n                    i--;\\n                    j++;\\n                }\\n\\n                ans[index++] = mat[i][j];\\n                isUp = true;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        int[] ans = new int[m * n];\\n        int index = 0;\\n\\n        int i = 0;\\n        int j = 0;\\n        ans[index++] = mat[i][j];\\n\\n        boolean isUp = true;\\n        while(index != ans.length) {\\n            if(isUp) {\\n                j += 1;\\n\\n                while(j != 0 && i != m - 1) {\\n                    if(j < n) {\\n                        ans[index++] = mat[i][j];\\n                    }\\n                    i++;\\n                    j--;\\n                }\\n\\n                ans[index++] = mat[i][j];\\n                isUp = false;\\n            } else {\\n                i += 1;\\n\\n                while(i != 0 && j != n - 1) {\\n                    if(i < m) {\\n                        ans[index++] = mat[i][j];\\n                    }\\n                    i--;\\n                    j++;\\n                }\\n\\n                ans[index++] = mat[i][j];\\n                isUp = true;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3401921,
                "title": "c-using-recursion",
                "content": "class Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<int>v;\\n        \\n        int i = 0,j = 0;\\n        bool flag = true;\\n        dfs(mat,i,j,v,flag);\\n        \\n        return v;\\n    }\\n    \\n    void dfs(vector<vector<int>>& mat,int i,int j ,vector<int>&v ,bool &flag)\\n    {\\n        if(i>= 0 and i<mat.size() and j>= 0 and j<mat[0].size())\\n        {\\n            v.push_back(mat[i][j]);\\n            if(flag)\\n                dfs(mat,i-1,j+1,v,flag);\\n            else\\n                dfs(mat,i+1,j-1,v,flag);\\n        }\\n        else if(i < 0 and j>=0 and j<mat[0].size())\\n        {\\n            flag = false;\\n            dfs(mat,i+1,j,v,flag);\\n        }\\n        else if(j<0 and i>= 0 and i<mat.size())\\n        {\\n            flag = true;\\n            dfs(mat,i,j+1,v,flag);\\n        }\\n        else if(i<0 and j>=mat[0].size())\\n        {\\n            flag = false;\\n            dfs(mat,i+2 ,j-1,v,flag);\\n        }\\n        else if(i>=mat.size() and j<0)\\n        {\\n            flag = true;\\n            dfs(mat,i-1,j+2,v,flag);\\n        }\\n        else if(j>=mat[0].size() and i>= 0 and i<mat.size())\\n        {\\n            flag = false;\\n            dfs(mat,i+2,j-1,v,flag);\\n        }\\n        else if(i>=mat.size() and j>= 0 and j<mat[0].size())\\n        {\\n            flag = true;\\n            dfs(mat,i-1,j+2,v,flag);\\n        }\\n        return;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Matrix"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        vector<int>v;\\n        \\n        int i = 0,j = 0;\\n        bool flag = true;\\n        dfs(mat,i,j,v,flag);\\n        \\n        return v;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3209139,
                "title": "time-o-m-n-c-space-o-ans-size",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size(),i=0,j=0,k,x=0;\\n        k = m*n;\\n        vector<int> ans;\\n        while(k){\\n            // cout<<i<<\" \"<<j<<\" \"<<x<<endl;\\n            if(x){\\n                while(k&&j>=0&&i<m){\\n                    ans.push_back(mat[i][j]);\\n                    i++;\\n                    j--;\\n                    k--;\\n                }\\n                if(i<m){\\n                    j++;\\n                }else{\\n                    i = m-1;\\n                    j += 2;\\n                }\\n            }else{\\n                while(k&&i>=0&&j<n){\\n                    ans.push_back(mat[i][j]);\\n                    i--;\\n                    j++;\\n                    k--;\\n                }\\n                // cout<<i<<\" \"<<j<<endl;\\n                if(j<n){\\n                    i++;\\n                }else{\\n                    j = n-1;\\n                    i += 2;\\n                }\\n                // cout<<i<<\" \"<<j<<endl;\\n            }\\n            x ^= 1;\\n            // cout<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size(),i=0,j=0,k,x=0;\\n        k = m*n;\\n        vector<int> ans;\\n        while(k){\\n            // cout<<i<<\" \"<<j<<\" \"<<x<<endl;\\n            if(x){\\n                while(k&&j>=0&&i<m){\\n                    ans.push_back(mat[i][j]);\\n                    i++;\\n                    j--;\\n                    k--;\\n                }\\n                if(i<m){\\n                    j++;\\n                }else{\\n                    i = m-1;\\n                    j += 2;\\n                }\\n            }else{\\n                while(k&&i>=0&&j<n){\\n                    ans.push_back(mat[i][j]);\\n                    i--;\\n                    j++;\\n                    k--;\\n                }\\n                // cout<<i<<\" \"<<j<<endl;\\n                if(j<n){\\n                    i++;\\n                }else{\\n                    j = n-1;\\n                    i += 2;\\n                }\\n                // cout<<i<<\" \"<<j<<endl;\\n            }\\n            x ^= 1;\\n            // cout<<endl;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3091666,
                "title": "diagonal-traverse-cpp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        vector<int>arr;\\n        if(m==0) {\\n            return {};\\n        }\\n       // if(m==1)return mat[0];\\n        bool up=true;\\n        int row=0;\\n        int column=0;\\n        while(row<m&&column<n){\\n            arr.push_back(mat[row][column]);\\n            if(up){\\n               /* while(row>0&&column<n-1){\\n                    arr.push_back(mat[row][column]);\\n                    row--;\\n                    column++;\\n                }*/\\n                   //arr.push_back(mat[row][column]);\\n                if(column==n-1){\\n                        row++;\\n                        up=false;\\n                    }\\n                else if (row==0){\\n                        column++;\\n                        up=false;\\n                    }\\n                else{\\n                    row--;\\n                    column++;\\n                }\\n                    \\n               \\n            }\\n            else{\\n                /*while(row<n-1&&column>0){\\n                    arr.push_back(mat[row][column]);\\n                    row++;\\n                    column--;\\n                    }\\n                    arr.push_back(mat[row][column]);\\n                    */\\n                if(row==m-1){\\n                        column++;\\n                        up=true;\\n                    }\\n                else if(column==0){\\n                        row++;\\n                        up=true;\\n                    }\\n                else{\\n                    row++;\\n                    column--;\\n                }\\n            \\n        }      \\n        \\n        // up=!up; \\n        \\n    }\\n    return arr;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        vector<int>arr;\\n        if(m==0) {\\n            return {};\\n        }\\n       // if(m==1)return mat[0];\\n        bool up=true;\\n        int row=0;\\n        int column=0;\\n        while(row<m&&column<n){\\n            arr.push_back(mat[row][column]);\\n            if(up){\\n               /* while(row>0&&column<n-1){\\n                    arr.push_back(mat[row][column]);\\n                    row--;\\n                    column++;\\n                }*/\\n                   //arr.push_back(mat[row][column]);\\n                if(column==n-1){\\n                        row++;\\n                        up=false;\\n                    }\\n                else if (row==0){\\n                        column++;\\n                        up=false;\\n                    }\\n                else{\\n                    row--;\\n                    column++;\\n                }\\n                    \\n               \\n            }\\n            else{\\n                /*while(row<n-1&&column>0){\\n                    arr.push_back(mat[row][column]);\\n                    row++;\\n                    column--;\\n                    }\\n                    arr.push_back(mat[row][column]);\\n                    */\\n                if(row==m-1){\\n                        column++;\\n                        up=true;\\n                    }\\n                else if(column==0){\\n                        row++;\\n                        up=true;\\n                    }\\n                else{\\n                    row++;\\n                    column--;\\n                }\\n            \\n        }      \\n        \\n        // up=!up; \\n        \\n    }\\n    return arr;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086846,
                "title": "easy-to-understand-code-in-python",
                "content": "```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        m = len(mat)\\n        n = len(mat[0])\\n        i = 0\\n        ans = []\\n        dirc = \\'u\\'\\n        x,y = 0, 0\\n        while i<m+n-1:\\n            try:\\n                ans.append(mat[x][y])\\n            except:\\n                pass\\n            if dirc == \\'u\\':\\n                if y+1<n and x-1>=0:\\n                    x -= 1\\n                    y += 1\\n                else:0\\n                    dirc = \\'d\\'\\n                    y += 1\\n                    i += 1\\n            else:\\n                if x+1<m and y-1>=0:\\n                    x+=1\\n                    y-=1\\n                else:\\n                    dirc = \\'u\\'\\n                    x += 1\\n                    i += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        m = len(mat)\\n        n = len(mat[0])\\n        i = 0\\n        ans = []\\n        dirc = \\'u\\'\\n        x,y = 0, 0\\n        while i<m+n-1:\\n            try:\\n                ans.append(mat[x][y])\\n            except:\\n                pass\\n            if dirc == \\'u\\':\\n                if y+1<n and x-1>=0:\\n                    x -= 1\\n                    y += 1\\n                else:0\\n                    dirc = \\'d\\'\\n                    y += 1\\n                    i += 1\\n            else:\\n                if x+1<m and y-1>=0:\\n                    x+=1\\n                    y-=1\\n                else:\\n                    dirc = \\'u\\'\\n                    x += 1\\n                    i += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776203,
                "title": "kotlin-using-map",
                "content": "```kotlin\\n    fun findDiagonalOrder(mat: Array<IntArray>): IntArray {\\n        val m = mat.size\\n        val n = mat.first().size\\n        val temp = mutableMapOf<Int, MutableList<Int>>()\\n\\n        for (i in 0 .. (m + n - 2)) {\\n            temp[i] = mutableListOf()\\n        }\\n\\n        mat.indices.forEach { i ->\\n            mat[i].forEachIndexed { j, value ->\\n                temp[i + j]?.add(value)\\n            }\\n        }\\n\\n        temp.mapValues { (key, value) ->\\n            if (key and 1 == 0) value.reverse()\\n        }\\n\\n        return temp.flatMap { it.value }.toIntArray()\\n    }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```kotlin\\n    fun findDiagonalOrder(mat: Array<IntArray>): IntArray {\\n        val m = mat.size\\n        val n = mat.first().size\\n        val temp = mutableMapOf<Int, MutableList<Int>>()\\n\\n        for (i in 0 .. (m + n - 2)) {\\n            temp[i] = mutableListOf()\\n        }\\n\\n        mat.indices.forEach { i ->\\n            mat[i].forEachIndexed { j, value ->\\n                temp[i + j]?.add(value)\\n            }\\n        }\\n\\n        temp.mapValues { (key, value) ->\\n            if (key and 1 == 0) value.reverse()\\n        }\\n\\n        return temp.flatMap { it.value }.toIntArray()\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2745954,
                "title": "simple-go-solution-with-comments",
                "content": "\\n```\\nfunc findDiagonalOrder(mat [][]int) []int {\\n    \\n    // Read diagonals from top to down\\n    diagonals := make([][]int, len(mat)+len(mat[0]))\\n    for i := 0; i < len(mat); i++ {\\n        for j := 0; j < len(mat[0]); j++ {\\n            diagonals[i+j] = append(diagonals[i+j], mat[i][j])\\n        }\\n    }\\n    \\n    // Concantenate diagonals reverting even ones\\n    res := make([]int, 0, len(mat)*len(mat[0]))\\n    for diagNum, d := range diagonals {\\n        if diagNum % 2 == 0 {\\n            for i, j := 0, len(d)-1; i < j; i, j = i+1, j-1 {\\n                d[i], d[j] = d[j], d[i]\\n            }\\n        }\\n        res = append(res, d...)\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findDiagonalOrder(mat [][]int) []int {\\n    \\n    // Read diagonals from top to down\\n    diagonals := make([][]int, len(mat)+len(mat[0]))\\n    for i := 0; i < len(mat); i++ {\\n        for j := 0; j < len(mat[0]); j++ {\\n            diagonals[i+j] = append(diagonals[i+j], mat[i][j])\\n        }\\n    }\\n    \\n    // Concantenate diagonals reverting even ones\\n    res := make([]int, 0, len(mat)*len(mat[0]))\\n    for diagNum, d := range diagonals {\\n        if diagNum % 2 == 0 {\\n            for i, j := 0, len(d)-1; i < j; i, j = i+1, j-1 {\\n                d[i], d[j] = d[j], d[i]\\n            }\\n        }\\n        res = append(res, d...)\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2673108,
                "title": "c-simple-o-n-m-solution",
                "content": "Upvote if you find it helpful\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        vector<int> res;\\n        int i = 0, j = 0, n = mat.size(), m = mat[0].size(), add = -1;\\n        res.push_back(mat[i][j]);\\n        while (i < n - 1 || j < m - 1) {\\n            if (j < m - 1 && ((i == 0 && add == -1) || (i == n - 1 && add == 1))) {\\n                ++ j;\\n                add = -add;\\n            } else if ((j == 0 && add == 1) || (j == m - 1 && add == -1)) {\\n                ++ i;\\n                add = -add;\\n            } else {\\n                i += add;\\n                j -= add;\\n            }\\n            res.push_back(mat[i][j]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        vector<int> res;\\n        int i = 0, j = 0, n = mat.size(), m = mat[0].size(), add = -1;\\n        res.push_back(mat[i][j]);\\n        while (i < n - 1 || j < m - 1) {\\n            if (j < m - 1 && ((i == 0 && add == -1) || (i == n - 1 && add == 1))) {\\n                ++ j;\\n                add = -add;\\n            } else if ((j == 0 && add == 1) || (j == m - 1 && add == -1)) {\\n                ++ i;\\n                add = -add;\\n            } else {\\n                i += add;\\n                j -= add;\\n            }\\n            res.push_back(mat[i][j]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2659932,
                "title": "simplest-approach-o-m-n-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n   vector<int> findDiagonalOrder(vector<vector<int>>& mat) \\n{\\n     //we will start the diagnoal form every m+n-1  cell of l shape\\n     bool flag=true;\\n     vector<int>ans;\\n     \\n     for(int i=0;i<mat.size();i++)\\n\\t {\\n \\t   \\n\\t   for(int j=0;j<mat[i].size();j++)\\n\\t   {\\n\\t   \\t   if(j==0 or i==mat.size()-1)\\n\\t   \\t   {\\n              vector<int>temp;\\n\\t   \\t      fun(i,j,mat,temp);  \\t\\n\\t\\t\\t\\t\\n\\t\\t\\t  if(flag==false)\\n\\t\\t\\t  {\\n\\t\\t\\t    reverse(temp.begin(),temp.end());\\t\\n\\t\\t      } \\n\\t\\t\\t  ans.insert(ans.end(),temp.begin(),temp.end());\\t\\n\\t\\t\\t  flag=!flag;\\n\\t\\t   }\\n       }\\t\\n     }    \\n     return ans;\\n}\\nvoid fun(int i,int j,vector<vector<int>>&mat,vector<int>&temp)\\n{\\n\\twhile((i>=0 and i<=mat.size()-1) and (j>=0 and j<=mat[0].size()-1))\\n\\t{\\n\\t\\ttemp.push_back(mat[i][j]);\\n\\t\\ti--;\\n\\t\\tj++;\\n\\t}\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   vector<int> findDiagonalOrder(vector<vector<int>>& mat) \\n{\\n     //we will start the diagnoal form every m+n-1  cell of l shape\\n     bool flag=true;\\n     vector<int>ans;\\n     \\n     for(int i=0;i<mat.size();i++)\\n\\t {\\n \\t   \\n\\t   for(int j=0;j<mat[i].size();j++)\\n\\t   {\\n\\t   \\t   if(j==0 or i==mat.size()-1)\\n\\t   \\t   {\\n              vector<int>temp;\\n\\t   \\t      fun(i,j,mat,temp);  \\t\\n\\t\\t\\t\\t\\n\\t\\t\\t  if(flag==false)\\n\\t\\t\\t  {\\n\\t\\t\\t    reverse(temp.begin(),temp.end());\\t\\n\\t\\t      } \\n\\t\\t\\t  ans.insert(ans.end(),temp.begin(),temp.end());\\t\\n\\t\\t\\t  flag=!flag;\\n\\t\\t   }\\n       }\\t\\n     }    \\n     return ans;\\n}\\nvoid fun(int i,int j,vector<vector<int>>&mat,vector<int>&temp)\\n{\\n\\twhile((i>=0 and i<=mat.size()-1) and (j>=0 and j<=mat[0].size()-1))\\n\\t{\\n\\t\\ttemp.push_back(mat[i][j]);\\n\\t\\ti--;\\n\\t\\tj++;\\n\\t}\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574371,
                "title": "simple-java-simulation",
                "content": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] arr) {\\n        int row = arr.length; \\n        int col = arr[0].length;\\n        int[] output = new int[row * col];\\n        int r = 0;\\n        int c = 0;\\n        int k = 0;\\n        while (r < row && c < col) {\\n            // go up\\n            while (r >= 0 && c < col) {\\n                output[k++] = arr[r][c];\\n                r--;\\n                c++;\\n            }\\n            if (c < col) {\\n                r = 0;\\n            } else {\\n                c = c - 1;\\n                r = r + 2;\\n            }\\n            // go down\\n            while (r < row && c >= 0) {\\n                output[k++] = arr[r][c];\\n                r++;\\n                c--;\\n            }\\n            if (r < row) {\\n                c = 0;\\n            } else {\\n                r = r - 1;\\n                c = c + 2;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] arr) {\\n        int row = arr.length; \\n        int col = arr[0].length;\\n        int[] output = new int[row * col];\\n        int r = 0;\\n        int c = 0;\\n        int k = 0;\\n        while (r < row && c < col) {\\n            // go up\\n            while (r >= 0 && c < col) {\\n                output[k++] = arr[r][c];\\n                r--;\\n                c++;\\n            }\\n            if (c < col) {\\n                r = 0;\\n            } else {\\n                c = c - 1;\\n                r = r + 2;\\n            }\\n            // go down\\n            while (r < row && c >= 0) {\\n                output[k++] = arr[r][c];\\n                r++;\\n                c--;\\n            }\\n            if (r < row) {\\n                c = 0;\\n            } else {\\n                r = r - 1;\\n                c = c + 2;\\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541268,
                "title": "java-2-different-approaches-easy-understandable-code",
                "content": "**Please upvote if it helps you. It motivates me to work harder.**\\n*if any query, pls comment.*\\n\\n# Iterative Approach\\n\\n```\\nclass Solution {\\n    \\n    //  Time Complexity = O(N*M)\\n    //  Space Complexity = O(N*M)\\n    \\n    public int[] findDiagonalOrder(int[][] mat) {\\n        \\n\\t\\t//  Edge Cases\\n        if (mat == null) {\\n            throw new IllegalArgumentException(\"Input matrix is null\");\\n        }\\n        if (mat.length == 0 || mat[0].length == 0) {\\n            return new int[0];\\n        }\\n        //  Length of rows and columns\\n        int rows = mat.length;\\n        int columns = mat[0].length;\\n\\t\\t\\n        //  Resultant Array to put the Diagonal traversal of the given matrix          \\n        int[] result = new int[rows*columns];\\n\\t\\t//  row and column pointers\\n        int r = 0, c = 0 ;\\n        \\n        for(int i = 0 ; i < result.length ; ++i){\\n            result[i] = mat[r][c];\\n            //  if sum of row and column is even\\n            if( (r+c)%2 == 0){\\n                if(c == columns-1){\\n                    ++r;\\n                }\\n                else if(r == 0){\\n                    ++c;\\n                }   \\n                else{\\n                    --r;++c;\\n                }\\n            }\\n\\t\\t\\t//  if sum of row and column is odd\\n\\t\\t\\telse{\\n                if(r == rows-1){\\n                    ++c;\\n                }    \\n                else if (c == 0){\\n                    ++r;\\n                }   \\n                else{\\n                    ++r;--c;\\n                }\\n            } \\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n# Diagonal Arrays Approach\\n\\n![image](https://assets.leetcode.com/users/images/e45bd6f2-2768-4063-a609-7a08110e4627_1662485817.1783297.png)\\n\\n\\n```\\nclass Solution {\\n    \\n    //  Time Complexity = O(N*M)\\n    //  Space Complexity = O(N*M) This solution is space extensive since we are using different auxilliary\\n    //          data structures to store elements like Map and List apart from resultant array.\\n    \\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        \\n        //  Edge case\\n        if( matrix == null || matrix.length ==0){\\n            return new int[0];\\n        }\\n        //  Length of rows and columns\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        \\n        //  Resultant Array to put the Diagonal traversal of the given matrix  \\n        int[] result = new int[rows * cols];\\n        \\n        // The sum of indices of diagonal elements are same \\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0 ; i < rows ; i++){\\n            for( int j=0; j < cols; j++){\\n                //  If the key(i+j) doesn\\'t exist, then put it in the map\\n                if(! map.containsKey( i + j)){\\n                     map.put( i+ j, new ArrayList<>());\\n                }\\n                //  Add the element on the corresponding key(i+j)\\n                map.get(i+j).add(matrix[i][j]);\\n            }\\n        }\\n        \\n        int lastElement = rows + cols-2;\\n        int index =0;\\n        \\n        for( int diag = 0; diag <= lastElement ; diag++ ){\\n            \\n            List<Integer> list = map.get(diag);\\n            //  if diagonal is even, we get elements in reverse direction of diagonal\\n            if(diag %2 ==0){\\n                Collections.reverse(list);\\n            }\\n            for(int dt : list){\\n                result[index++]= dt;\\n            }\\n        }\\n        return result;   \\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    \\n    //  Time Complexity = O(N*M)\\n    //  Space Complexity = O(N*M)\\n    \\n    public int[] findDiagonalOrder(int[][] mat) {\\n        \\n\\t\\t//  Edge Cases\\n        if (mat == null) {\\n            throw new IllegalArgumentException(\"Input matrix is null\");\\n        }\\n        if (mat.length == 0 || mat[0].length == 0) {\\n            return new int[0];\\n        }\\n        //  Length of rows and columns\\n        int rows = mat.length;\\n        int columns = mat[0].length;\\n\\t\\t\\n        //  Resultant Array to put the Diagonal traversal of the given matrix          \\n        int[] result = new int[rows*columns];\\n\\t\\t//  row and column pointers\\n        int r = 0, c = 0 ;\\n        \\n        for(int i = 0 ; i < result.length ; ++i){\\n            result[i] = mat[r][c];\\n            //  if sum of row and column is even\\n            if( (r+c)%2 == 0){\\n                if(c == columns-1){\\n                    ++r;\\n                }\\n                else if(r == 0){\\n                    ++c;\\n                }   \\n                else{\\n                    --r;++c;\\n                }\\n            }\\n\\t\\t\\t//  if sum of row and column is odd\\n\\t\\t\\telse{\\n                if(r == rows-1){\\n                    ++c;\\n                }    \\n                else if (c == 0){\\n                    ++r;\\n                }   \\n                else{\\n                    ++r;--c;\\n                }\\n            } \\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    //  Time Complexity = O(N*M)\\n    //  Space Complexity = O(N*M) This solution is space extensive since we are using different auxilliary\\n    //          data structures to store elements like Map and List apart from resultant array.\\n    \\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        \\n        //  Edge case\\n        if( matrix == null || matrix.length ==0){\\n            return new int[0];\\n        }\\n        //  Length of rows and columns\\n        int rows = matrix.length;\\n        int cols = matrix[0].length;\\n        \\n        //  Resultant Array to put the Diagonal traversal of the given matrix  \\n        int[] result = new int[rows * cols];\\n        \\n        // The sum of indices of diagonal elements are same \\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0 ; i < rows ; i++){\\n            for( int j=0; j < cols; j++){\\n                //  If the key(i+j) doesn\\'t exist, then put it in the map\\n                if(! map.containsKey( i + j)){\\n                     map.put( i+ j, new ArrayList<>());\\n                }\\n                //  Add the element on the corresponding key(i+j)\\n                map.get(i+j).add(matrix[i][j]);\\n            }\\n        }\\n        \\n        int lastElement = rows + cols-2;\\n        int index =0;\\n        \\n        for( int diag = 0; diag <= lastElement ; diag++ ){\\n            \\n            List<Integer> list = map.get(diag);\\n            //  if diagonal is even, we get elements in reverse direction of diagonal\\n            if(diag %2 ==0){\\n                Collections.reverse(list);\\n            }\\n            for(int dt : list){\\n                result[index++]= dt;\\n            }\\n        }\\n        return result;   \\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2528271,
                "title": "faster-than-80-js-solution",
                "content": "```\\nvar findDiagonalOrder = function (mat) {\\n  let rows = mat.length;\\n  let cols = mat[0].length;\\n\\n  let d = {};\\n  for (let row = 0; row < rows; row++) {\\n    for (let col = 0; col < cols; col++) {\\n      if (!d[row + col]) d[row + col] = [];\\n      if ((row + col) % 2 === 0) d[row + col].unshift(mat[row][col]);\\n      else d[row + col].push(mat[row][col]);\\n\\n    }\\n  }\\n  return Object.values(d).flat();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findDiagonalOrder = function (mat) {\\n  let rows = mat.length;\\n  let cols = mat[0].length;\\n\\n  let d = {};\\n  for (let row = 0; row < rows; row++) {\\n    for (let col = 0; col < cols; col++) {\\n      if (!d[row + col]) d[row + col] = [];\\n      if ((row + col) % 2 === 0) d[row + col].unshift(mat[row][col]);\\n      else d[row + col].push(mat[row][col]);\\n\\n    }\\n  }\\n  return Object.values(d).flat();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2476928,
                "title": "easiest-implementation-with-beats-75-runtime-online-submission",
                "content": "``` \\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        m=len(mat)\\n        n=len(mat[0])\\n        arr=[]\\n        i,j=0,0\\n        if m==1:\\n            return mat[0]\\n        flip=1\\n        while i>=0 and j>=0 and i<m and j<n:\\n            tmp=[]\\n            r,c=i,j\\n            while r>=0 and c<n:\\n                tmp.append(mat[r][c])\\n                r,c=r-1,c+1\\n            if flip>0:\\n                arr.extend(tmp)\\n            else:\\n                arr.extend(tmp[::-1])\\n            if i<m-1:\\n                i+=1\\n            elif i==m-1:\\n                j+=1\\n            flip*=-1    \\n        \\n        return arr    \\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "``` \\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        m=len(mat)\\n        n=len(mat[0])\\n        arr=[]\\n        i,j=0,0\\n        if m==1:\\n            return mat[0]\\n        flip=1\\n        while i>=0 and j>=0 and i<m and j<n:\\n            tmp=[]\\n            r,c=i,j\\n            while r>=0 and c<n:\\n                tmp.append(mat[r][c])\\n                r,c=r-1,c+1\\n            if flip>0:\\n                arr.extend(tmp)\\n            else:\\n                arr.extend(tmp[::-1])\\n            if i<m-1:\\n                i+=1\\n            elif i==m-1:\\n                j+=1\\n            flip*=-1    \\n        \\n        return arr    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475751,
                "title": "python-clean-and-concise-one-pass-o-mn",
                "content": "```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        m, n = len(mat), len(mat[0])\\n        res = []\\n        turn = 0\\n        for k in range(m+n-1):\\n            for i in (range(min(m-1,k), max(k-n,-1), -1) if not k%2 else range(max(k-n+1,0), min(m, k+1))):\\n                res.append(mat[i][k-i])\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        m, n = len(mat), len(mat[0])\\n        res = []\\n        turn = 0\\n        for k in range(m+n-1):\\n            for i in (range(min(m-1,k), max(k-n,-1), -1) if not k%2 else range(max(k-n+1,0), min(m, k+1))):\\n                res.append(mat[i][k-i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2406808,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        M,N = len(mat), len(mat[0])\\n        diagonals = []\\n        \\n        # traverse first column\\n        for i in range(len(mat)):\\n            idx_i = i\\n            idx_j = 0\\n            diagonals.append([])\\n            while idx_i >= 0 and idx_j < N:\\n                diagonals[-1].append(mat[idx_i][idx_j])\\n                idx_i -= 1\\n                idx_j += 1\\n        \\n        # traverse last row\\n        for i in range(1, len(mat[-1])):\\n            idx_i = M-1\\n            idx_j = i\\n            diagonals.append([])\\n            while idx_j < N and idx_i>=0:\\n                diagonals[-1].append(mat[idx_i][idx_j])\\n                idx_i -= 1\\n                idx_j += 1\\n        \\n        # combine everything to answer\\n        answer = []\\n        for i, d in enumerate(diagonals):\\n            if i % 2 == 0:\\n                answer += d\\n            else:\\n                answer += d[::-1]\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        M,N = len(mat), len(mat[0])\\n        diagonals = []\\n        \\n        # traverse first column\\n        for i in range(len(mat)):\\n            idx_i = i\\n            idx_j = 0\\n            diagonals.append([])\\n            while idx_i >= 0 and idx_j < N:\\n                diagonals[-1].append(mat[idx_i][idx_j])\\n                idx_i -= 1\\n                idx_j += 1\\n        \\n        # traverse last row\\n        for i in range(1, len(mat[-1])):\\n            idx_i = M-1\\n            idx_j = i\\n            diagonals.append([])\\n            while idx_j < N and idx_i>=0:\\n                diagonals[-1].append(mat[idx_i][idx_j])\\n                idx_i -= 1\\n                idx_j += 1\\n        \\n        # combine everything to answer\\n        answer = []\\n        for i, d in enumerate(diagonals):\\n            if i % 2 == 0:\\n                answer += d\\n            else:\\n                answer += d[::-1]\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2251176,
                "title": "c-solution-detailed-w-explanation-comments",
                "content": "We need to figure out an approach to:\\n1. Maintain and change the direction of movement.\\n2. Finding the starting point after changing direction (head).\\n\\nWhile going up from down, if the down diagonal ends in the last row, the head would be the element next to its tail. Otherwise, the head would be the directly below the tail of the down diagonal.\\n\\nWhile going down from up, if the up diagonal ends in the last column, the head would be the element directly below its tail. Otherwise, the head would be to the right of the tail of the down diagonal.\\n\\nKeeping the above cases in mind, the code follows:\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size(), i = 0, j = 0;        \\n        bool dir = true; //true for upwards right, false for downwards left\\n        vector<int> res(rows*cols);\\n        res[0] = matrix[i][j];\\n        int k = 1; //counter variable for result matrix\\n        while(i != rows - 1 || j != cols - 1){\\n            if(dir){ //if upwards right motion \\n                if(j == cols - 1){ \\n                    i++; dir = false;\\n                }\\n                else if(i == 0){\\n                    j++; dir = false;\\n                }\\n                else{ \\n                    i--; j++; //to go upwards right if direction change not needed yet\\n                }\\n            }\\n            else{ //if downwards left motion\\n                if(i == rows - 1){ \\n                    j++; dir = true;\\n                }\\n                else if(j == 0) { \\n                    i++; dir = true;\\n                }\\n                else { \\n                    i++; j--; //to go downwards right if direction change not needed yet\\n                }\\n            }\\n            res[k++] = matrix[i][j]; //adding the element to our result vector\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        int rows = matrix.size(), cols = matrix[0].size(), i = 0, j = 0;        \\n        bool dir = true; //true for upwards right, false for downwards left\\n        vector<int> res(rows*cols);\\n        res[0] = matrix[i][j];\\n        int k = 1; //counter variable for result matrix\\n        while(i != rows - 1 || j != cols - 1){\\n            if(dir){ //if upwards right motion \\n                if(j == cols - 1){ \\n                    i++; dir = false;\\n                }\\n                else if(i == 0){\\n                    j++; dir = false;\\n                }\\n                else{ \\n                    i--; j++; //to go upwards right if direction change not needed yet\\n                }\\n            }\\n            else{ //if downwards left motion\\n                if(i == rows - 1){ \\n                    j++; dir = true;\\n                }\\n                else if(j == 0) { \\n                    i++; dir = true;\\n                }\\n                else { \\n                    i++; j--; //to go downwards right if direction change not needed yet\\n                }\\n            }\\n            res[k++] = matrix[i][j]; //adding the element to our result vector\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2246370,
                "title": "c-100-fast-easy-solution-without-any-formula",
                "content": "vector<int> findDiagonalOrder(vector<vector<int>>& mat) \\n    {\\n        int n=mat.size();\\n        int row=n;\\n        int col=mat[0].size();\\n        \\n        vector<int>ans;\\n        int flag=0;\\n        vector<int>tmp;\\n        \\n        // Start traversing  0 Rows to Total NUmbers of Rows : \\n        for(int k=0;k<row;k++)\\n        {\\n            int j=0;\\n            int i=k;\\n            \\n            // iterate Diagonaly 0\\'s Column To till the number of columns\\n            while(i>=0 && j<col)\\n            {\\n                tmp.push_back(mat[i][j]);\\n                j++;\\n                i--;\\n            }\\n            if(flag==0)\\n            {\\n                for(int i=0;i<tmp.size();i++)\\n                {\\n                    ans.push_back(tmp[i]);\\n                }\\n                flag=1;\\n                tmp.clear();\\n            }\\n            else\\n            {\\n                 for(int i=tmp.size()-1;i>=0;i--)\\n                    {\\n                        ans.push_back(tmp[i]);\\n                    }\\n                \\n                flag=0;\\n                tmp.clear();\\n            }\\n            \\n        }\\n        \\n        // Start traversing  1 Column to Total NUmbers of Columns :\\n        \\n        for(int k=1;k<=col-1;k++)\\n        {\\n            int i=row-1;\\n            int j=k;\\n            \\n            // iterate Diagonaly Last Row To till the possible Row(According to columns) : \\n            while(i>=0 && j<=col-1)\\n            {\\n                tmp.push_back(mat[i][j]);\\n                j++;\\n                i--;\\n            }\\n            \\n            if(flag==0)\\n            {\\n                for(int i=0;i<tmp.size();i++)\\n                {\\n                    ans.push_back(tmp[i]);\\n                }\\n                flag=1;\\n                tmp.clear();\\n            }\\n            else\\n            {\\n                 for(int i=tmp.size()-1;i>=0;i--)\\n                    {\\n                        ans.push_back(tmp[i]);\\n                    }\\n                \\n                flag=0;\\n                tmp.clear();\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Array",
                    "Matrix"
                ],
                "code": "vector<int> findDiagonalOrder(vector<vector<int>>& mat) \\n    {\\n        int n=mat.size();\\n        int row=n;\\n        int col=mat[0].size();\\n        \\n        vector<int>ans;\\n        int flag=0;\\n        vector<int>tmp;\\n        \\n        // Start traversing  0 Rows to Total NUmbers of Rows : \\n        for(int k=0;k<row;k++)\\n        {\\n            int j=0;\\n            int i=k;\\n            \\n            // iterate Diagonaly 0\\'s Column To till the number of columns\\n            while(i>=0 && j<col)\\n            {\\n                tmp.push_back(mat[i][j]);\\n                j++;\\n                i--;\\n            }\\n            if(flag==0)\\n            {\\n                for(int i=0;i<tmp.size();i++)\\n                {\\n                    ans.push_back(tmp[i]);\\n                }\\n                flag=1;\\n                tmp.clear();\\n            }\\n            else\\n            {\\n                 for(int i=tmp.size()-1;i>=0;i--)\\n                    {\\n                        ans.push_back(tmp[i]);\\n                    }\\n                \\n                flag=0;\\n                tmp.clear();\\n            }\\n            \\n        }\\n        \\n        // Start traversing  1 Column to Total NUmbers of Columns :\\n        \\n        for(int k=1;k<=col-1;k++)\\n        {\\n            int i=row-1;\\n            int j=k;\\n            \\n            // iterate Diagonaly Last Row To till the possible Row(According to columns) : \\n            while(i>=0 && j<=col-1)\\n            {\\n                tmp.push_back(mat[i][j]);\\n                j++;\\n                i--;\\n            }\\n            \\n            if(flag==0)\\n            {\\n                for(int i=0;i<tmp.size();i++)\\n                {\\n                    ans.push_back(tmp[i]);\\n                }\\n                flag=1;\\n                tmp.clear();\\n            }\\n            else\\n            {\\n                 for(int i=tmp.size()-1;i>=0;i--)\\n                    {\\n                        ans.push_back(tmp[i]);\\n                    }\\n                \\n                flag=0;\\n                tmp.clear();\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2108781,
                "title": "java-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        int[] ans=new int[mat.length*mat[0].length];\\n        int count=0;\\n        int c=0;\\n        int r=0;\\n        int col=mat[0].length;\\n        int row=mat.length;\\n        boolean up=true;\\n        for(int i=0;i<=col*row-1;i++){\\n            if(r<0 || c>=col) {\\n                // for column array out of index condition checking\\n                if(c>=col){\\n                    r+=2;\\n                    c--;\\n                }\\n                else if(r<0) r++;\\n                up=false;\\n            }\\n            else if(r>=row || c<0) {\\n                // for row array out of index condition checking\\n                if(r>=row) {\\n                    r--;\\n                    c+=2;\\n                }\\n                else if(c<0) c++;\\n                up=true;\\n            }\\n            if(up){\\n                ans[count++]=mat[r--][c++];\\n            }\\n            else{\\n                ans[count++]=mat[r++][c--];\\n            }   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        int[] ans=new int[mat.length*mat[0].length];\\n        int count=0;\\n        int c=0;\\n        int r=0;\\n        int col=mat[0].length;\\n        int row=mat.length;\\n        boolean up=true;\\n        for(int i=0;i<=col*row-1;i++){\\n            if(r<0 || c>=col) {\\n                // for column array out of index condition checking\\n                if(c>=col){\\n                    r+=2;\\n                    c--;\\n                }\\n                else if(r<0) r++;\\n                up=false;\\n            }\\n            else if(r>=row || c<0) {\\n                // for row array out of index condition checking\\n                if(r>=row) {\\n                    r--;\\n                    c+=2;\\n                }\\n                else if(c<0) c++;\\n                up=true;\\n            }\\n            if(up){\\n                ans[count++]=mat[r--][c++];\\n            }\\n            else{\\n                ans[count++]=mat[r++][c--];\\n            }   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1889017,
                "title": "c-easy-to-understand-complexity-o-mn",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size();\\n        vector<int> v;\\n        map<int, vector<int> > f;\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j){\\n                f[i + j].push_back(mat[i][j]);\\n            }\\n        }\\n        for(auto& itr : f)\\n        {\\n            if(itr.first % 2 == 0){\\n                reverse(itr.second.begin(), itr.second.end());\\n            }\\n            for(auto& i : itr.second)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n**If you like please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size();\\n        vector<int> v;\\n        map<int, vector<int> > f;\\n        for (int i = 0; i < m; ++i)\\n        {\\n            for (int j = 0; j < n; ++j){\\n                f[i + j].push_back(mat[i][j]);\\n            }\\n        }\\n        for(auto& itr : f)\\n        {\\n            if(itr.first % 2 == 0){\\n                reverse(itr.second.begin(), itr.second.end());\\n            }\\n            for(auto& i : itr.second)\\n            {\\n                v.push_back(i);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858113,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        int[] res = new int[m*n];\\n        int row = 0, col = 0;\\n        for (int i=0; i<m*n; i++) {\\n            res[i] = mat[row][col];\\n            // up arrow: sum of row and col indices is even\\n            if ((row+col) % 2 == 0) {\\n                // hit right side\\n                if (col + 1 == n) {\\n                    row++;\\n                } else if ( row == 0) {  // hit top side\\n                    col++;\\n                } else {\\n                    row--;\\n                    col++;\\n                }\\n            } \\n            // down arrow: sum of row and col indices is odd\\n            else if ((row+col) % 2 != 0) {\\n                if (row + 1 == m) { // hit bottom\\n                    col++;\\n                } else if (col == 0) { // hit left\\n                    row++;\\n                } else {\\n                    row++;\\n                    col--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        int[] res = new int[m*n];\\n        int row = 0, col = 0;\\n        for (int i=0; i<m*n; i++) {\\n            res[i] = mat[row][col];\\n            // up arrow: sum of row and col indices is even\\n            if ((row+col) % 2 == 0) {\\n                // hit right side\\n                if (col + 1 == n) {\\n                    row++;\\n                } else if ( row == 0) {  // hit top side\\n                    col++;\\n                } else {\\n                    row--;\\n                    col++;\\n                }\\n            } \\n            // down arrow: sum of row and col indices is odd\\n            else if ((row+col) % 2 != 0) {\\n                if (row + 1 == m) { // hit bottom\\n                    col++;\\n                } else if (col == 0) { // hit left\\n                    row++;\\n                } else {\\n                    row++;\\n                    col--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1838094,
                "title": "c-easy-understand-with-comments",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        int i = 0, j = 0;\\n        \\n        bool dir = true;\\n        int end = m*n;\\n        vector<int> ans(end);\\n        int start = 0;\\n        \\n        while (start<end) {\\n            ans[start] = matrix[i][j];\\n            int new_row = i + (dir ? -1 : 1);//go up/down\\n            int new_column = j + (dir == 1 ? 1 : -1);//go right/left\\n            if (new_row < 0 || new_row > m-1 || new_column < 0 || new_column > n-1) {\\n                if (dir) {//moving toward top right\\n                    //case: new_row < 0 , new_column > n-1\\n                    i += (j == n - 1 ? 1 : 0);//reach boundary, go down\\n                    j += (j < n - 1 ? 1 : 0);//keep moving to right\\n                    \\n                }else{//moving toward bottom left\\n                    //case: new_row < 0, new_column\\n                    j += (i == m - 1 ? 1 : 0);//reach bottom, move right\\n                    i += (i < m - 1 ? 1 : 0);//keep moving down\\n                }\\n               dir=!dir;    \\n            } else {\\n                i = new_row;\\n                j = new_column;\\n            }\\n            start++;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        \\n        int m = matrix.size();\\n        int n = matrix[0].size();\\n        \\n        int i = 0, j = 0;\\n        \\n        bool dir = true;\\n        int end = m*n;\\n        vector<int> ans(end);\\n        int start = 0;\\n        \\n        while (start<end) {\\n            ans[start] = matrix[i][j];\\n            int new_row = i + (dir ? -1 : 1);//go up/down\\n            int new_column = j + (dir == 1 ? 1 : -1);//go right/left\\n            if (new_row < 0 || new_row > m-1 || new_column < 0 || new_column > n-1) {\\n                if (dir) {//moving toward top right\\n                    //case: new_row < 0 , new_column > n-1\\n                    i += (j == n - 1 ? 1 : 0);//reach boundary, go down\\n                    j += (j < n - 1 ? 1 : 0);//keep moving to right\\n                    \\n                }else{//moving toward bottom left\\n                    //case: new_row < 0, new_column\\n                    j += (i == m - 1 ? 1 : 0);//reach bottom, move right\\n                    i += (i < m - 1 ? 1 : 0);//keep moving down\\n                }\\n               dir=!dir;    \\n            } else {\\n                i = new_row;\\n                j = new_column;\\n            }\\n            start++;\\n        }\\n        return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1836501,
                "title": "c-easy-compact-code",
                "content": "// \\uD83D\\uDE09\\uD83C\\uDFA1Please upvote if it helps.\\uD83C\\uDFA1\\uD83D\\uDE09\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int row=mat.size(),col=mat[0].size(),gap=0;\\n        vector<int>ans;\\n        while(gap<=row+col-2){\\n            int topRow=0,topCol=gap,bottomRow=gap,bottomCol=0;\\n            if(gap>=col) topCol=col-1,topRow=gap-col+1;\\n            if(gap>=row) bottomRow=row-1,bottomCol=gap-row+1;\\n            if(gap%2==0) for(int i=bottomRow;i>=topRow;i--) ans.push_back(mat[i][bottomCol]),bottomCol++;//bottom to top\\n            else for(int i=topRow;i<=bottomRow;i++) ans.push_back(mat[i][topCol]),topCol--;//top to bottom       \\n            ++gap;            \\n        }\\n        return ans;               \\n    }\\n};\\n\\n```\\n\\uD83C\\uDFA1 Time Complexity: \\nSince, each element in the matrix is traversed once, So TC: (Size)^2 => (row*col)^2.\\n\\n\\uD83C\\uDFA1 Space complexity:\\nO(1)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int row=mat.size(),col=mat[0].size(),gap=0;\\n        vector<int>ans;\\n        while(gap<=row+col-2){\\n            int topRow=0,topCol=gap,bottomRow=gap,bottomCol=0;\\n            if(gap>=col) topCol=col-1,topRow=gap-col+1;\\n            if(gap>=row) bottomRow=row-1,bottomCol=gap-row+1;\\n            if(gap%2==0) for(int i=bottomRow;i>=topRow;i--) ans.push_back(mat[i][bottomCol]),bottomCol++;//bottom to top\\n            else for(int i=topRow;i<=bottomRow;i++) ans.push_back(mat[i][topCol]),topCol--;//top to bottom       \\n            ++gap;            \\n        }\\n        return ans;               \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742194,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int r = mat.size(), c = mat[0].size();\\n        int i = 0, j = 0;\\n        vector<int> vec;\\n        int dir = 1;\\n        while (vec.size() < r * c) {\\n            vec.push_back(mat[i][j]);\\n            if (i == 0 && j == c - 1 && dir == 1) {\\n                ++i; dir = -1;\\n            } else if (i == 0 && dir == 1) {\\n                ++j; dir = -1;\\n            } else if (j == 0 && i == r - 1 && dir == -1) {\\n                ++j; dir = 1;\\n            } else if (j == 0 && dir == -1) {\\n                ++i; dir = 1;\\n            } else if (i == r - 1 && dir == -1) {\\n                ++j; dir = 1;\\n            } else if (j == c - 1 && dir == 1) {\\n                ++i; dir = -1;\\n            } else if (dir == 1) {\\n                --i; ++j;\\n            } else {\\n                ++i; --j;\\n            }\\n        }\\n        \\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int r = mat.size(), c = mat[0].size();\\n        int i = 0, j = 0;\\n        vector<int> vec;\\n        int dir = 1;\\n        while (vec.size() < r * c) {\\n            vec.push_back(mat[i][j]);\\n            if (i == 0 && j == c - 1 && dir == 1) {\\n                ++i; dir = -1;\\n            } else if (i == 0 && dir == 1) {\\n                ++j; dir = -1;\\n            } else if (j == 0 && i == r - 1 && dir == -1) {\\n                ++j; dir = 1;\\n            } else if (j == 0 && dir == -1) {\\n                ++i; dir = 1;\\n            } else if (i == r - 1 && dir == -1) {\\n                ++j; dir = 1;\\n            } else if (j == c - 1 && dir == 1) {\\n                ++i; dir = -1;\\n            } else if (dir == 1) {\\n                --i; ++j;\\n            } else {\\n                ++i; --j;\\n            }\\n        }\\n        \\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733920,
                "title": "c-a-different-approach-o-m-n-optimal-solution-with-intuition-explaination",
                "content": "![image](https://assets.leetcode.com/users/images/86ec34cc-5d04-498d-b084-30bb615f48a4_1643625892.9764252.jpeg)\\n```\\n//using two variable v  = to travel in vertical\\n// h  = to travel in horizontal direction\\n// v= -1 *v and h = -1 * h to change directions \\n// after each diagonal traversal\\n// whenever our diagonal is in upper diagonal half \\n// of matrix we simply need to make either i =0 form -1\\n// of j = 0 from -1 \\n// but in case of lower diagonal half we need to use \\n// different technique \\n// i just wrote down the indexs of matrix\\n// in lower diagonal half when i or j are our of range\\n// and what is starting point of next diagonal\\n// and i found a relationship and that\\'s it\\n// just observe the above old (i,j) --> new (i,j)\\n// you will get the relationship\\nvector<int> findDiagonalOrder(vector<vector<int>>& mat) \\n    {\\n        vector<int>ans;\\n        int n = mat.size(),m = mat[0].size();\\n        int v=-1,h=1,i=0,j=0;\\n        \\n        while(i!=n-1 || j!=m-1)\\n        {\\n            \\n           \\n           while(i>=0 && i<n && j>=0 && j<m)\\n           {\\n               ans.push_back(mat[i][j]);\\n               i+=v;\\n               j+=h;\\n           }\\n            \\n            if(i==n)\\n            {\\n                i=n-1;\\n                j = j+2;\\n            }\\n            else if(j==m)\\n            {\\n                j=m-1;\\n                i=i+2;\\n            }\\n            else\\n            {\\n                if(i==-1) i=0;\\n                if(j==-1) j=0;\\n            }\\n            \\n            v*=-1;\\n            h*=-1;\\n        }\\n        \\n        ans.push_back(mat[i][j]);\\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n//using two variable v  = to travel in vertical\\n// h  = to travel in horizontal direction\\n// v= -1 *v and h = -1 * h to change directions \\n// after each diagonal traversal\\n// whenever our diagonal is in upper diagonal half \\n// of matrix we simply need to make either i =0 form -1\\n// of j = 0 from -1 \\n// but in case of lower diagonal half we need to use \\n// different technique \\n// i just wrote down the indexs of matrix\\n// in lower diagonal half when i or j are our of range\\n// and what is starting point of next diagonal\\n// and i found a relationship and that\\'s it\\n// just observe the above old (i,j) --> new (i,j)\\n// you will get the relationship\\nvector<int> findDiagonalOrder(vector<vector<int>>& mat) \\n    {\\n        vector<int>ans;\\n        int n = mat.size(),m = mat[0].size();\\n        int v=-1,h=1,i=0,j=0;\\n        \\n        while(i!=n-1 || j!=m-1)\\n        {\\n            \\n           \\n           while(i>=0 && i<n && j>=0 && j<m)\\n           {\\n               ans.push_back(mat[i][j]);\\n               i+=v;\\n               j+=h;\\n           }\\n            \\n            if(i==n)\\n            {\\n                i=n-1;\\n                j = j+2;\\n            }\\n            else if(j==m)\\n            {\\n                j=m-1;\\n                i=i+2;\\n            }\\n            else\\n            {\\n                if(i==-1) i=0;\\n                if(j==-1) j=0;\\n            }\\n            \\n            v*=-1;\\n            h*=-1;\\n        }\\n        \\n        ans.push_back(mat[i][j]);\\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1719540,
                "title": "swift-easy-to-understand-o-m-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\n    func findDiagonalOrder(_ mat: [[Int]]) -> [Int] {\\n    \\n\\t\\t// Store diagonal order in output array.\\n        var output:[Int] = []\\n        \\n\\t\\t// Variables for mat row and column sizes.\\n        let n = mat.count \\n        let m = mat.first?.count ?? 0\\n        \\n\\t\\t// Variables for i and j pointers\\n        var i = 0\\n        var j = 0\\n        \\n\\t\\t// Enum for defining the traversal direction.\\n        enum Direction {\\n            case up\\n            case down\\n        }\\n        \\n\\t\\t// Variable for traversal direction\\n        var direction: Direction = .up\\n    \\n\\t\\t// Once i and j equal n and m respectively, end the loop.\\n        while i < n && j < m {\\n\\n\\t\\t\\t// 1. Store the value at mat[i][j] in the output\\n            output.append(mat[i][j])\\n\\n\\t\\t\\t// 2. Increment or decrement i and j as needed.\\n            switch direction {\\n\\t\\t\\t\\t// If traversing up...\\n                case .up:\\n\\t\\t\\t\\t\\t// Check that j+1 < m, therefore in the bounds of the array.  If not add 1 to i and change direction.  \\n                    if j + 1 == m {\\n                        direction = .down\\n                        i += 1\\n                    } else \\n\\t\\t\\t\\t\\t// Check that i-1 > 0, therefore in the bounds of the array.  If not add 1 to j and change direction.  \\n                    if i - 1 < 0  {\\n                        direction = .down\\n                        j += 1   \\n                    } else {\\n\\t\\t\\t\\t\\t\\t// Move up the array if i and j are within the bounds of the array.\\n                        i -= 1\\n                        j += 1\\n                    }\\n\\t\\t\\t\\t// If traversing down...\\n                case .down:\\n\\t\\t\\t\\t\\t// Check that i+1 < n, therefore in the bounds of the array.  If not add 1 to j and change direction.  \\n                    if i + 1 == n {\\n                        direction = .up\\n                        j += 1\\n                    } else \\n\\t\\t\\t\\t\\t// Check that j-1 > 0, therefore in the bounds of the array.  If not add 1 to 1 and change direction.  \\n                    if j - 1 < 0  {\\n                        direction = .up\\n                        i += 1\\n                    } else {\\n\\t\\t\\t\\t\\t\\t// Move down the array if i and j are within the bounds of the array.\\n                        i += 1\\n                        j -= 1\\n                    }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Done.\\n        return output\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func findDiagonalOrder(_ mat: [[Int]]) -> [Int] {\\n    \\n\\t\\t// Store diagonal order in output array.\\n        var output:[Int] = []\\n        \\n\\t\\t// Variables for mat row and column sizes.\\n        let n = mat.count \\n        let m = mat.first?.count ?? 0\\n        \\n\\t\\t// Variables for i and j pointers\\n        var i = 0\\n        var j = 0\\n        \\n\\t\\t// Enum for defining the traversal direction.\\n        enum Direction {\\n            case up\\n            case down\\n        }\\n        \\n\\t\\t// Variable for traversal direction\\n        var direction: Direction = .up\\n    \\n\\t\\t// Once i and j equal n and m respectively, end the loop.\\n        while i < n && j < m {\\n\\n\\t\\t\\t// 1. Store the value at mat[i][j] in the output\\n            output.append(mat[i][j])\\n\\n\\t\\t\\t// 2. Increment or decrement i and j as needed.\\n            switch direction {\\n\\t\\t\\t\\t// If traversing up...\\n                case .up:\\n\\t\\t\\t\\t\\t// Check that j+1 < m, therefore in the bounds of the array.  If not add 1 to i and change direction.  \\n                    if j + 1 == m {\\n                        direction = .down\\n                        i += 1\\n                    } else \\n\\t\\t\\t\\t\\t// Check that i-1 > 0, therefore in the bounds of the array.  If not add 1 to j and change direction.  \\n                    if i - 1 < 0  {\\n                        direction = .down\\n                        j += 1   \\n                    } else {\\n\\t\\t\\t\\t\\t\\t// Move up the array if i and j are within the bounds of the array.\\n                        i -= 1\\n                        j += 1\\n                    }\\n\\t\\t\\t\\t// If traversing down...\\n                case .down:\\n\\t\\t\\t\\t\\t// Check that i+1 < n, therefore in the bounds of the array.  If not add 1 to j and change direction.  \\n                    if i + 1 == n {\\n                        direction = .up\\n                        j += 1\\n                    } else \\n\\t\\t\\t\\t\\t// Check that j-1 > 0, therefore in the bounds of the array.  If not add 1 to 1 and change direction.  \\n                    if j - 1 < 0  {\\n                        direction = .up\\n                        i += 1\\n                    } else {\\n\\t\\t\\t\\t\\t\\t// Move down the array if i and j are within the bounds of the array.\\n                        i += 1\\n                        j -= 1\\n                    }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Done.\\n        return output\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677864,
                "title": "clean-python-bfs-approach",
                "content": "```python\\nfrom collections import deque\\n\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        nrows, ncols = len(mat), len(mat[0])\\n\\n        def get_neighbors(r, c):\\n            res = []\\n            delta = [(0, 1), (1, 0)]\\n            \\n            for dr, dc in delta:\\n                row = r + dr\\n                col = c + dc\\n                                \\n                if 0 <= row < nrows and 0 <= col < ncols:\\n                    res.append((row, col))\\n            return res\\n                \\n                \\n        def bfs(r, c):\\n            queue = deque()\\n            visited = set()\\n            res = []\\n            \\n            queue.append((r, c))\\n            visited.add((r, c))\\n            \\n            flip = True\\n            while queue:\\n                size = len(queue)\\n                level_res = deque()\\n                for _ in range(size):\\n                    r, c = queue.popleft()\\n                    \\n                    if flip:                \\n                        level_res.appendleft(mat[r][c])\\n                    else:\\n                        level_res.append(mat[r][c])                        \\n                    \\n                    for nr, nc in get_neighbors(r, c):\\n                        if (nr, nc) not in visited:\\n                            queue.append((nr, nc))\\n                            visited.add((nr, nc))\\n                    \\n                flip = not flip\\n                res.extend(list(level_res))\\n            return res\\n        \\n        return bfs(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nfrom collections import deque\\n\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        nrows, ncols = len(mat), len(mat[0])\\n\\n        def get_neighbors(r, c):\\n            res = []\\n            delta = [(0, 1), (1, 0)]\\n            \\n            for dr, dc in delta:\\n                row = r + dr\\n                col = c + dc\\n                                \\n                if 0 <= row < nrows and 0 <= col < ncols:\\n                    res.append((row, col))\\n            return res\\n                \\n                \\n        def bfs(r, c):\\n            queue = deque()\\n            visited = set()\\n            res = []\\n            \\n            queue.append((r, c))\\n            visited.add((r, c))\\n            \\n            flip = True\\n            while queue:\\n                size = len(queue)\\n                level_res = deque()\\n                for _ in range(size):\\n                    r, c = queue.popleft()\\n                    \\n                    if flip:                \\n                        level_res.appendleft(mat[r][c])\\n                    else:\\n                        level_res.append(mat[r][c])                        \\n                    \\n                    for nr, nc in get_neighbors(r, c):\\n                        if (nr, nc) not in visited:\\n                            queue.append((nr, nc))\\n                            visited.add((nr, nc))\\n                    \\n                flip = not flip\\n                res.extend(list(level_res))\\n            return res\\n        \\n        return bfs(0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649644,
                "title": "a-java-solution-94-26-92-58",
                "content": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        int m = mat.length;\\n        int n  = mat[0].length;\\n        int[] output = new int[m * n];\\n        int idx = 0;\\n        for(int diag = 0; diag <= m + n - 2; ++diag){\\n            if(diag % 2 == 0){\\n                for(int k = Math.max(0,diag - m + 1); k <= Math.min(diag, n - 1); ++k){\\n                    output[idx ++] = mat[diag - k][k];\\n                }\\n            }else{\\n                for(int k = Math.max(0,diag - n + 1); k <= Math.min(diag, m - 1); ++k){\\n                    output[idx ++] = mat[k][diag - k];\\n                }                \\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] mat) {\\n        int m = mat.length;\\n        int n  = mat[0].length;\\n        int[] output = new int[m * n];\\n        int idx = 0;\\n        for(int diag = 0; diag <= m + n - 2; ++diag){\\n            if(diag % 2 == 0){\\n                for(int k = Math.max(0,diag - m + 1); k <= Math.min(diag, n - 1); ++k){\\n                    output[idx ++] = mat[diag - k][k];\\n                }\\n            }else{\\n                for(int k = Math.max(0,diag - n + 1); k <= Math.min(diag, m - 1); ++k){\\n                    output[idx ++] = mat[k][diag - k];\\n                }                \\n            }\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586336,
                "title": "c-odd-even-approach",
                "content": "```\\n vector<int> findDiagonalOrder(vector<vector<int>>& x) {\\n        int n=x.size();\\n        int m=x[0].size();\\n        int r=0,c=0;\\n        vector<int>v(m*n,0);\\n        for(int i=0;i<m*n;i++)\\n        {\\n            v[i]=x[r][c];\\n            if((r+c)%2==0)\\n            {\\n                if(c==m-1)\\n                {\\n                    r++;\\n                }\\n                else if(r==0)\\n                {\\n                    c++;\\n                }\\n                else{\\n                    r--;\\n                    c++;\\n                }\\n            }\\n            else{\\n                if(r==n-1)\\n                {\\n                    c++;\\n                }\\n                else if(c==0)\\n                {\\n                    r++;\\n                    \\n                }\\n                else{\\n                    r++;\\n                    c--;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n vector<int> findDiagonalOrder(vector<vector<int>>& x) {\\n        int n=x.size();\\n        int m=x[0].size();\\n        int r=0,c=0;\\n        vector<int>v(m*n,0);\\n        for(int i=0;i<m*n;i++)\\n        {\\n            v[i]=x[r][c];\\n            if((r+c)%2==0)\\n            {\\n                if(c==m-1)\\n                {\\n                    r++;\\n                }\\n                else if(r==0)\\n                {\\n                    c++;\\n                }\\n                else{\\n                    r--;\\n                    c++;\\n                }\\n            }\\n            else{\\n                if(r==n-1)\\n                {\\n                    c++;\\n                }\\n                else if(c==0)\\n                {\\n                    r++;\\n                    \\n                }\\n                else{\\n                    r++;\\n                    c--;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1424720,
                "title": "c-solution",
                "content": "**Complexity**\\n- time: O(m * n)\\n- space: O(m * n) for the output array\\n\\n**Implementation**\\n```\\npublic class Solution {\\n    public int[] FindDiagonalOrder(int[][] mat) {\\n        \\n        int m = mat.Length, n = mat[0].Length, row = 0, col = 0;\\n        int[] res = new int[m*n];\\n        \\n        for(int i = 0; i < res.Length; i++)\\n        {\\n\\t\\t\\t// set the output array\\n            res[i] = mat[row][col];\\n\\t\\t\\t\\n\\t\\t\\t// up\\n            if((row + col) % 2 == 0)\\n            {\\n\\t\\t\\t\\t// check column first in case the top right element satisfy both col == n-1 and row == 0.\\n                if(col == n-1)\\n                    row++;\\n                else if(row == 0)\\n                    col++;\\n                else\\n                {\\n                    row--;\\n                    col++;\\n                }\\n            }\\n            else\\n            {  // down\\n\\t\\t\\t    // check row first in case the bottom left element satisfy both row == m-1 and col == 0.\\n                if(row == m-1)\\n                    col++;\\n                else if(col == 0)\\n                    row++;\\n                else\\n                {\\n                    row++;\\n                    col--;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] FindDiagonalOrder(int[][] mat) {\\n        \\n        int m = mat.Length, n = mat[0].Length, row = 0, col = 0;\\n        int[] res = new int[m*n];\\n        \\n        for(int i = 0; i < res.Length; i++)\\n        {\\n\\t\\t\\t// set the output array\\n            res[i] = mat[row][col];\\n\\t\\t\\t\\n\\t\\t\\t// up\\n            if((row + col) % 2 == 0)\\n            {\\n\\t\\t\\t\\t// check column first in case the top right element satisfy both col == n-1 and row == 0.\\n                if(col == n-1)\\n                    row++;\\n                else if(row == 0)\\n                    col++;\\n                else\\n                {\\n                    row--;\\n                    col++;\\n                }\\n            }\\n            else\\n            {  // down\\n\\t\\t\\t    // check row first in case the bottom left element satisfy both row == m-1 and col == 0.\\n                if(row == m-1)\\n                    col++;\\n                else if(col == 0)\\n                    row++;\\n                else\\n                {\\n                    row++;\\n                    col--;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368057,
                "title": "c-92-faster-with-explanation",
                "content": "Start with first element(i=0 and j=0) and push it in vector **ans**.\\nIn 2nd while loop **i** and **j**(index) is incremented or decremented based on if diagonals index sum(i+j) is even or odd. To move to next element in a diagonal **i** and **j** are changed accordingly.\\nAfter inserting all elements in a particular diagonal, 2nd while loop ends. In first while loop, inside if condition **i** and **j** are changed so that they acquire last element\\'s index of diagonal previously used. As odd index sum(i+j is odd) diagonal always starts at rightmost index so inside if we first try to increment **j** and if that is not possible we increment **i**.\\nAs even index sum(i+j is even) diagonal starts at leftmost so first we try to increment **i** and if that is not possible we increment **j**.\\n```\\nvector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n   \\n     int i=0,j=0,p,m,n;\\n        \\n     m=mat.size();\\n     n=mat[0].size();\\n     p=m*n;\\n        \\n     vector<int> ans;\\n      \\n     while(ans.size()<p)\\n      {\\n         \\n        while(i<m && i>=0 && j<n && j>=0)\\n        {\\n            \\n         ans.push_back(mat[i][j]);\\n            \\n         if((i+j)%2==0)\\n         {\\n           i--;\\n           j++;\\n         }\\n         else\\n         {\\n           i++;\\n           j--;\\n         }\\n            \\n        }\\n          \\n        if((i+j)%2==0)\\n        {\\n          i++;\\n          j--;\\n            \\n          if((j+1)<n)\\n           j++;\\n          else\\n           i++;\\n\\n        }\\n\\t\\t\\n        else\\n        {\\n          j++;\\n          i--;\\n            \\n          if((i+1)<m)\\n           i++;\\n          else\\n           j++;\\n        }\\n          \\n      }\\n        \\n      return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n   \\n     int i=0,j=0,p,m,n;\\n        \\n     m=mat.size();\\n     n=mat[0].size();\\n     p=m*n;\\n        \\n     vector<int> ans;\\n      \\n     while(ans.size()<p)\\n      {\\n         \\n        while(i<m && i>=0 && j<n && j>=0)\\n        {\\n            \\n         ans.push_back(mat[i][j]);\\n            \\n         if((i+j)%2==0)\\n         {\\n           i--;\\n           j++;\\n         }\\n         else\\n         {\\n           i++;\\n           j--;\\n         }\\n            \\n        }\\n          \\n        if((i+j)%2==0)\\n        {\\n          i++;\\n          j--;\\n            \\n          if((j+1)<n)\\n           j++;\\n          else\\n           i++;\\n\\n        }\\n\\t\\t\\n        else\\n        {\\n          j++;\\n          i--;\\n            \\n          if((i+1)<m)\\n           i++;\\n          else\\n           j++;\\n        }\\n          \\n      }\\n        \\n      return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1362542,
                "title": "c-simple-logic",
                "content": "sum of coordinates of elments in a particular diagonal is same for all elements in that diagonal.\\nso we map that sum to vector of elments.\\nso map contains elements of every diagonal in vector.\\nwe just reverse the vectors when its even indexed in map.\\nthen we just push all elments in all vectors of map to answer and return it.\\n```\\nvector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        map<int,vector<int>>s;\\n        for(int i=0;i<mat.size();i++)\\n            for(int j=0;j<mat[i].size();j++)\\n                s[i+j].push_back(mat[i][j]);\\n        vector<vector<int>>ans;\\n        for(auto c:s)\\n            ans.push_back(c.second);\\n        for(int i=0;i<ans.size();i++)\\n            if(i%2==0)\\n                reverse(ans[i].begin(),ans[i].end());\\n        vector<int>p;\\n        for(int i=0;i<ans.size();i++)\\n            for(int j=0;j<ans[i].size();j++)\\n                p.push_back(ans[i][j]);\\n        return p;\\n    }\\n\\t```\\n\\t!!**UPVOTE**!!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        map<int,vector<int>>s;\\n        for(int i=0;i<mat.size();i++)\\n            for(int j=0;j<mat[i].size();j++)\\n                s[i+j].push_back(mat[i][j]);\\n        vector<vector<int>>ans;\\n        for(auto c:s)\\n            ans.push_back(c.second);\\n        for(int i=0;i<ans.size();i++)\\n            if(i%2==0)\\n                reverse(ans[i].begin(),ans[i].end());\\n        vector<int>p;\\n        for(int i=0;i<ans.size();i++)\\n            for(int j=0;j<ans[i].size();j++)\\n                p.push_back(ans[i][j]);\\n        return p;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1362507,
                "title": "intuitive-python-solution-with-debugging-statements-to-run-through",
                "content": "No Extra Space except for specified return format.\\n\\n```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        rows = len(mat)-1  # index upperbound\\n        columns = len(mat[0])-1  # index upperbound\\n        up = False # Next iteration flag\\n        ans = [mat[0][0]]\\n        lastPoint = [0,0]\\n        \\n        while True:\\n            r,c = lastPoint\\n            \\n            # upward initialisation (row--, cols++)\\n            if up:\\n                if r<rows:\\n                    r+=1\\n                else:# No more rows. (r>= rows)\\n                    r = r  \\n                    c+=1\\n                    if c>columns:  \\n                        # No more columns too.\\n                        return ans\\n                    \\n                # print(\\'upstart\\',r,c)\\n                # boundary conditions to end upward traverse\\n                while c<=columns and r>=0:  # right_border, upper_border\\n                    print(r,c)\\n                    ans.append(mat[r][c])\\n                    lastPoint = [r,c]\\n                    r-=1\\n                    c+=1\\n                \\n                up = False\\n            \\n            # downward initailisation\\n            # row++ cols--\\n            else: \\n                if c<columns:\\n                    c+=1\\n                else: # No more Columns. (c>=columns)\\n                    c = c  \\n                    r+=1\\n                    if r>rows: \\n                        # No more Rows too.\\n                        return ans\\n                    \\n                # print(\\'godown\\',r,c)\\n                # boundary condition to end downward traverse\\n                while r<=rows and c>=0:  # down_border and left_border \\n                    print(r,c)\\n                    ans.append(mat[r][c])\\n                    lastPoint = [r,c]\\n                    r+=1\\n                    c-=1\\n                \\n                up = True\\n        \\n        # print(ans)\\n        return ans\\n                    \\n                   \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDiagonalOrder(self, mat: List[List[int]]) -> List[int]:\\n        rows = len(mat)-1  # index upperbound\\n        columns = len(mat[0])-1  # index upperbound\\n        up = False # Next iteration flag\\n        ans = [mat[0][0]]\\n        lastPoint = [0,0]\\n        \\n        while True:\\n            r,c = lastPoint\\n            \\n            # upward initialisation (row--, cols++)\\n            if up:\\n                if r<rows:\\n                    r+=1\\n                else:# No more rows. (r>= rows)\\n                    r = r  \\n                    c+=1\\n                    if c>columns:  \\n                        # No more columns too.\\n                        return ans\\n                    \\n                # print(\\'upstart\\',r,c)\\n                # boundary conditions to end upward traverse\\n                while c<=columns and r>=0:  # right_border, upper_border\\n                    print(r,c)\\n                    ans.append(mat[r][c])\\n                    lastPoint = [r,c]\\n                    r-=1\\n                    c+=1\\n                \\n                up = False\\n            \\n            # downward initailisation\\n            # row++ cols--\\n            else: \\n                if c<columns:\\n                    c+=1\\n                else: # No more Columns. (c>=columns)\\n                    c = c  \\n                    r+=1\\n                    if r>rows: \\n                        # No more Rows too.\\n                        return ans\\n                    \\n                # print(\\'godown\\',r,c)\\n                # boundary condition to end downward traverse\\n                while r<=rows and c>=0:  # down_border and left_border \\n                    print(r,c)\\n                    ans.append(mat[r][c])\\n                    lastPoint = [r,c]\\n                    r+=1\\n                    c-=1\\n                \\n                up = True\\n        \\n        # print(ans)\\n        return ans\\n                    \\n                   \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1342850,
                "title": "java-20-line-code-only-using-array-100-faster",
                "content": "Elements on the same diagonal have the same sum of their two indexes.\\nFor example:\\n![image](https://assets.leetcode.com/users/images/4899d65c-9b23-498f-836b-dbd39090225b_1626496429.7212038.jpeg)\\nThe two indexes of:\\n* 3: i = 0, j = 2  ==>>  sum = 2\\n* 5: i = 1, j = 1  ==>>  sum = 2\\n* 7: i = 2, j = 0  ==>>  sum = 2\\n\\nSo, we can traverse the original 2D array based on the sum.\\nIf sum is even, we need to traverse this diagonal from left-bottom to right-top, which means i (the index of row) will decrease meanwhile j (the index of column) = sum - i;\\nIf sum is odd, we need to traverse this diagonal from right-top to left-bottom, which means i (the index of row) will increase meanwhile j (the index of column) = sum - i.\\n\\n```\\npublic int[] findDiagonalOrder(int[][] mat) {\\n        int m = mat.length - 1;\\n        int n = mat[0].length - 1;\\n        int total = m + n;\\n        int[] res = new int[(m + 1) * (n + 1)];\\n\\n        int idx = 0;\\n        int i = 0;\\n        for (int sum = 0; sum <= total; sum++) {     // O((m+1) * (n+1))\\n            if (sum % 2 == 0) {  // sum is even ==>> i decreases\\n\\t\\t\\t\\t// If sum \\u2264 m, then i starts from sum, otherwise m;\\n                i = Math.min(sum,m);\\n\\t\\t\\t\\t// Make sure: i \\u2265 0 && j \\u2264 n  ==>>  i \\u2265 0 && sum-i \\u2264 n  ==>>  i \\u2265 0 && i \\u2265 sum-n\\n                for (; i >= Math.max(sum-n,0); i--) res[idx++] = mat[i][sum-i];\\n            } else {  // sum is odd  ==>> i increases\\n\\t\\t\\t\\t// If sum \\u2264 n, then i starts from 0, otherwise sum-n;\\n                i = Math.max(sum-n,0);\\n                for (; i <= Math.min(sum,m); i++) res[idx++] = mat[i][sum-i];\\n            }\\n        }\\n\\n        return res;\\n    }\\n```\\n\\nNote: if using `>=`, `<=` operators instead of `Math.max/min()` functions, the runtime will decrease. \\n\\nPreformance:\\nwith `>=`, `<=` operators: Runtime: 1ms (faster than 100%)   Memory: 41MB (less than 73.88%)\\nwith `Math.max/min()`: Runtime: 2ms (faster than 93.58%)   Memory: 40.8MB (less than 86.22%)",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic int[] findDiagonalOrder(int[][] mat) {\\n        int m = mat.length - 1;\\n        int n = mat[0].length - 1;\\n        int total = m + n;\\n        int[] res = new int[(m + 1) * (n + 1)];\\n\\n        int idx = 0;\\n        int i = 0;\\n        for (int sum = 0; sum <= total; sum++) {     // O((m+1) * (n+1))\\n            if (sum % 2 == 0) {  // sum is even ==>> i decreases\\n\\t\\t\\t\\t// If sum \\u2264 m, then i starts from sum, otherwise m;\\n                i = Math.min(sum,m);\\n\\t\\t\\t\\t// Make sure: i \\u2265 0 && j \\u2264 n  ==>>  i \\u2265 0 && sum-i \\u2264 n  ==>>  i \\u2265 0 && i \\u2265 sum-n\\n                for (; i >= Math.max(sum-n,0); i--) res[idx++] = mat[i][sum-i];\\n            } else {  // sum is odd  ==>> i increases\\n\\t\\t\\t\\t// If sum \\u2264 n, then i starts from 0, otherwise sum-n;\\n                i = Math.max(sum-n,0);\\n                for (; i <= Math.min(sum,m); i++) res[idx++] = mat[i][sum-i];\\n            }\\n        }\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1294757,
                "title": "fast-easy-o-1-space-0-mn-time-complexities",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int x=0,y=0,z=0;\\n        vector<int> v;\\n        bool up=true;\\n        int n=mat.size(),m=mat[0].size();\\n        while(z < n*m){\\n            int i=x,j=y;\\n            if(up){   \\n                while(i>=0 && j<m){\\n                    z++;\\n                    v.push_back(mat[i][j]);\\n                    i--;j++;\\n                }                \\n                if(j>=m){\\n                    y=j-1;\\n                    x=i+2;\\n                }\\n                else{\\n                    y=j;\\n                    x=i+1;\\n                }\\n                up=false; \\n            }else{\\n                while(j>=0 && i<n){\\n                    z++;\\n                    v.push_back(mat[i][j]);\\n                    i++;j--;\\n                }\\n                if(i>=n){\\n                    x=i-1;\\n                    y=j+2;\\n                }\\n                else{\\n                    x=i;\\n                    y=j+1;\\n                }\\n                up=true;\\n            }            \\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\\n        int x=0,y=0,z=0;\\n        vector<int> v;\\n        bool up=true;\\n        int n=mat.size(),m=mat[0].size();\\n        while(z < n*m){\\n            int i=x,j=y;\\n            if(up){   \\n                while(i>=0 && j<m){\\n                    z++;\\n                    v.push_back(mat[i][j]);\\n                    i--;j++;\\n                }                \\n                if(j>=m){\\n                    y=j-1;\\n                    x=i+2;\\n                }\\n                else{\\n                    y=j;\\n                    x=i+1;\\n                }\\n                up=false; \\n            }else{\\n                while(j>=0 && i<n){\\n                    z++;\\n                    v.push_back(mat[i][j]);\\n                    i++;j--;\\n                }\\n                if(i>=n){\\n                    x=i-1;\\n                    y=j+2;\\n                }\\n                else{\\n                    x=i;\\n                    y=j+1;\\n                }\\n                up=true;\\n            }            \\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1185204,
                "title": "java-matrix-beats-100-1ms-t-c-o-m-n-s-c-o-1",
                "content": "\\n    // O(mat.length*mat[0].length) O(mat.length*mat[0].length)\\n\\tpublic int[] findDiagonalOrder(int[][] mat) {\\n\\n\\t\\tint m = mat.length, n = mat[0].length, idx = 0, count = 0, col = 0, row = 0;\\n\\t\\tint[] ans = new int[m * n];\\n\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\n\\t\\t\\tif (count % 2 == 0) {\\n\\t\\t\\t\\tint temp = i;\\n\\t\\t\\t\\tfor (int j = 0; j < n && temp >= 0; j++)\\n\\t\\t\\t\\t\\tans[idx++] = mat[temp--][j];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint temp = row;\\n\\t\\t\\t\\tfor (int j = col; j >= 0 && temp <= m - 1; j--)\\n\\t\\t\\t\\t\\tans[idx++] = mat[temp++][j];\\n\\t\\t\\t}\\n\\n\\t\\t\\tcol++;\\n\\t\\t\\tif (col == n) {\\n\\t\\t\\t\\tcol -= 1;\\n\\t\\t\\t\\trow++;\\n\\t\\t\\t}\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\n\\t\\t\\tif (count % 2 == 0) {\\n\\t\\t\\t\\tint temp = m - 1;\\n\\t\\t\\t\\tfor (int j = i; j < n && temp >= 0; j++)\\n\\t\\t\\t\\t\\tans[idx++] = mat[temp--][j];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint temp = row;\\n\\t\\t\\t\\tfor (int j = col; j >= 0 && temp <= m - 1; j--)\\n\\t\\t\\t\\t\\tans[idx++] = mat[temp++][j];\\n\\t\\t\\t}\\n\\t\\t\\tcount++;\\n\\t\\t\\tcol++;\\n\\t\\t\\tif (col == n) {\\n\\t\\t\\t\\tcol -= 1;\\n\\t\\t\\t\\trow++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    // O(mat.length*mat[0].length) O(mat.length*mat[0].length)\\n\\tpublic int[] findDiagonalOrder(int[][] mat) {\\n\\n\\t\\tint m = mat.length, n = mat[0].length, idx = 0, count = 0, col = 0, row = 0;\\n\\t\\tint[] ans = new int[m * n];\\n\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\n\\t\\t\\tif (count % 2 == 0) {\\n\\t\\t\\t\\tint temp = i;\\n\\t\\t\\t\\tfor (int j = 0; j < n && temp >= 0; j++)\\n\\t\\t\\t\\t\\tans[idx++] = mat[temp--][j];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint temp = row;\\n\\t\\t\\t\\tfor (int j = col; j >= 0 && temp <= m - 1; j--)\\n\\t\\t\\t\\t\\tans[idx++] = mat[temp++][j];\\n\\t\\t\\t}\\n\\n\\t\\t\\tcol++;\\n\\t\\t\\tif (col == n) {\\n\\t\\t\\t\\tcol -= 1;\\n\\t\\t\\t\\trow++;\\n\\t\\t\\t}\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\n\\t\\tfor (int i = 1; i < n; i++) {\\n\\n\\t\\t\\tif (count % 2 == 0) {\\n\\t\\t\\t\\tint temp = m - 1;\\n\\t\\t\\t\\tfor (int j = i; j < n && temp >= 0; j++)\\n\\t\\t\\t\\t\\tans[idx++] = mat[temp--][j];\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tint temp = row;\\n\\t\\t\\t\\tfor (int j = col; j >= 0 && temp <= m - 1; j--)\\n\\t\\t\\t\\t\\tans[idx++] = mat[temp++][j];\\n\\t\\t\\t}\\n\\t\\t\\tcount++;\\n\\t\\t\\tcol++;\\n\\t\\t\\tif (col == n) {\\n\\t\\t\\t\\tcol -= 1;\\n\\t\\t\\t\\trow++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 986149,
                "title": "c-merry-xmas-and-coding-is-fun-only-when-you-think-correctly",
                "content": "Solution 1: \\nIdea:   Think big picture first before handling special/corner case.\\nTo be specific:\\nStep 1: always scan from top right to bottum left\\nStep 2: correct the wrong doing.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        if(matrix.empty() || matrix[0].empty()) return {};\\n        vector<int> ans;\\n        const int m = matrix.size(), n = matrix[0].size();\\n        \\n        for(int i = 0; i < m + n - 1; i++){\\n            int offset = ans.size();\\n            //Step 1 (core part): to simplify the question, always scan from top right to bottum left\\n            for(int row = max(0, i - (n-1)), col = min(i, n - 1); row < m && col >= 0; row++, col--)\\n                ans.push_back(matrix[row][col]);\\n            //Step 2: correct the outlier to ensure even-numbered diagonal numbers is bottom-left-to-top-right by reversing them.\\n            if(i%2 == 0) reverse(ans.begin() + offset, ans.end());\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nThe nasty and buggy solution is my first attemp. \\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        const int m = matrix.size(), n = matrix[0].size();\\n        for(int idx = 0; idx < m + n - 1; idx++){\\n            int i_offset = idx%2 == 0 ? 1 : -1;        \\n            int i_beg = idx%2 == 0 ? 0 : idx;\\n            int i_end = idx%2 == 0 ? idx : 0;            \\n            for(int i = i_beg; i!= i_end + i_offset; i+=i_offset){\\n                int j = idx - i;\\n                if(j<0 || j >= n || i < 0 || i >=m) continue;\\n                ans.push_back(matrix[i][j]);             \\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        if(matrix.empty() || matrix[0].empty()) return {};\\n        vector<int> ans;\\n        const int m = matrix.size(), n = matrix[0].size();\\n        \\n        for(int i = 0; i < m + n - 1; i++){\\n            int offset = ans.size();\\n            //Step 1 (core part): to simplify the question, always scan from top right to bottum left\\n            for(int row = max(0, i - (n-1)), col = min(i, n - 1); row < m && col >= 0; row++, col--)\\n                ans.push_back(matrix[row][col]);\\n            //Step 2: correct the outlier to ensure even-numbered diagonal numbers is bottom-left-to-top-right by reversing them.\\n            if(i%2 == 0) reverse(ans.begin() + offset, ans.end());\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        vector<int> ans;\\n        const int m = matrix.size(), n = matrix[0].size();\\n        for(int idx = 0; idx < m + n - 1; idx++){\\n            int i_offset = idx%2 == 0 ? 1 : -1;        \\n            int i_beg = idx%2 == 0 ? 0 : idx;\\n            int i_end = idx%2 == 0 ? idx : 0;            \\n            for(int i = i_beg; i!= i_end + i_offset; i+=i_offset){\\n                int j = idx - i;\\n                if(j<0 || j >= n || i < 0 || i >=m) continue;\\n                ans.push_back(matrix[i][j]);             \\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 985625,
                "title": "python-o-m-n-by-diagonal-index-sum-w-comment",
                "content": "Python O( m * n ) by diagonal index sum\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\\n        \\n        if not matrix:\\n            # Quick response for empty matrix\\n            return []\\n        \\n        # height and width of matrix\\n        h, w = len(matrix), len(matrix[0])\\n        \\n        \\n        # key: diagonal index sum\\n        # value: list of matrix element with corresponding diagonal index sum\\n        diagonal_element_dict = collections.defaultdict( list )\\n        \\n        for y in range(h):\\n            for x in range(w):\\n                \\n                diagonal_index_sum = y + x\\n                diagonal_element_dict[ diagonal_index_sum ].append( matrix[y][x] )\\n        \\n        \\n        ## update result with diagonal index sum to create zig-zag path\\n        result = []\\n        \\n        for diagonal_index_sum, diagonal_elements in diagonal_element_dict.items():\\n            \\n            if diagonal_index_sum % 2 == 0:\\n                # go from botoom left to top right \\u2197, wiht reverse order\\n                result += [ *reversed(diagonal_elements) ]\\n            \\n            else:\\n                # go from top right to bottom left \\u2199, with normal order\\n                result += diagonal_elements\\n                \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Matrix",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\\n        \\n        if not matrix:\\n            # Quick response for empty matrix\\n            return []\\n        \\n        # height and width of matrix\\n        h, w = len(matrix), len(matrix[0])\\n        \\n        \\n        # key: diagonal index sum\\n        # value: list of matrix element with corresponding diagonal index sum\\n        diagonal_element_dict = collections.defaultdict( list )\\n        \\n        for y in range(h):\\n            for x in range(w):\\n                \\n                diagonal_index_sum = y + x\\n                diagonal_element_dict[ diagonal_index_sum ].append( matrix[y][x] )\\n        \\n        \\n        ## update result with diagonal index sum to create zig-zag path\\n        result = []\\n        \\n        for diagonal_index_sum, diagonal_elements in diagonal_element_dict.items():\\n            \\n            if diagonal_index_sum % 2 == 0:\\n                # go from botoom left to top right \\u2197, wiht reverse order\\n                result += [ *reversed(diagonal_elements) ]\\n            \\n            else:\\n                # go from top right to bottom left \\u2199, with normal order\\n                result += diagonal_elements\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761052,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0)\\n            return new int[0];\\n        int rows = matrix.length, cols = matrix[0].length;\\n        int r = 0, c = 0, index = 0;\\n        int total = rows * cols;\\n        int[] res = new int[total];\\n        for (int k = 0; k < total; ++k){\\n            res[index++] = matrix[r][c];\\n            if ((r + c) % 2 == 0){\\n                if (c == cols - 1){\\n                    r++;\\n                } else if (r == 0){\\n                    c++;\\n                } else {\\n                    r--;\\n                    c++;\\n                }\\n            } else {\\n                if (r == rows - 1){\\n                    c++;\\n                } else if (c == 0){\\n                    r++;\\n                } else {\\n                    r++;\\n                    c--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0)\\n            return new int[0];\\n        int rows = matrix.length, cols = matrix[0].length;\\n        int r = 0, c = 0, index = 0;\\n        int total = rows * cols;\\n        int[] res = new int[total];\\n        for (int k = 0; k < total; ++k){\\n            res[index++] = matrix[r][c];\\n            if ((r + c) % 2 == 0){\\n                if (c == cols - 1){\\n                    r++;\\n                } else if (r == 0){\\n                    c++;\\n                } else {\\n                    r--;\\n                    c++;\\n                }\\n            } else {\\n                if (r == rows - 1){\\n                    c++;\\n                } else if (c == 0){\\n                    r++;\\n                } else {\\n                    r++;\\n                    c--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 711058,
                "title": "python-11-lines-easy-way-to-visualize-a-solution",
                "content": "This approach is not fast, but it is easy to understand.  \\n\\nConsider the given example:\\n\\n<img src = \"https://assets.leetcode.com/users/images/a66270b4-1897-41ff-b3a6-e647cf454f62_1593406752.1855679.png\" width = \"250px\">\\n\\nFirst diagonal traverse: all points that are **i + j = 0** distance from the origin.   **[1]**\\nSecond diagonal traverse: all the points that are **i + j = 1** distance from the origin. **[2, 4]**\\nThird: all points that are **i + j = 2** distance from the origin. **[7,5,3]**\\n\\nLet\\'s look at the final solution (```[1,2,4,7,5,3,6,8,9]```), split up into each traverse:\\n\\n```python\\n[[1],\\n[2,4],\\n[3,5,7], # <-- notice all even indexed traverses are reversed ([1] and [9] are too)\\n[6,8],\\n[9]]\\n```\\n\\nAll we have done here is append each number located at ```(i,j)``` to an array at index ```i+j```.  i.e. **1** is at ```(0,0)``` it goes into the array at index ```0```.  **6** is at ```(1,2)``` so it goes into the array at index ```3```.  \\n\\nReading from top to bottom along the second diagonal, we see **3** first, then **5**, then **7**.  This order is the opposite of what we want.  So we reverse all of the even indexed diagonals, ```[1]```, ```[3,5,7]```, and ```[9]```.  (done by ```append``` and ```appendleft```)\\n\\nThen we can return the concatenation of all the lists: ```[1] + [2,4] + [3,5,7] + [6,8] + [9]```.  (done by ```sum(res,deque())``` or ```sum(res,[])``` if you choose to use lists to store each diagonal)\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\\n        \\n        #corner case: empty matrix\\n        if not matrix: return []\\n        \\n        #matrix dimensions\\n        R, C = len(matrix), len(matrix[0])\\n        \\n        #R + C - 1 diagonal traverses will be stored in double ended queues\\n        res = [deque() for _ in range(R + C - 1)]\\n        \\n        for r in range(R):\\n            for c in range(C):\\n                dist = r + c                        #distance from origin\\n                if dist & 1:                        #r + c is odd, do not reverse numbers\\n                    res[dist].append(matrix[r][c])\\n                else:                               #r + c is even, reverse numbers\\n                    res[dist].appendleft(matrix[r][c])\\n        \\n        #concatenate diagonal traverses\\n        return sum(res,deque())\\n```",
                "solutionTags": [],
                "code": "```[1,2,4,7,5,3,6,8,9]```\n```python\\n[[1],\\n[2,4],\\n[3,5,7], # <-- notice all even indexed traverses are reversed ([1] and [9] are too)\\n[6,8],\\n[9]]\\n```\n```(i,j)```\n```i+j```\n```(0,0)```\n```0```\n```(1,2)```\n```3```\n```[1]```\n```[3,5,7]```\n```[9]```\n```append```\n```appendleft```\n```[1] + [2,4] + [3,5,7] + [6,8] + [9]```\n```sum(res,deque())```\n```sum(res,[])```\n```\\nfrom collections import deque\\nclass Solution:\\n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\\n        \\n        #corner case: empty matrix\\n        if not matrix: return []\\n        \\n        #matrix dimensions\\n        R, C = len(matrix), len(matrix[0])\\n        \\n        #R + C - 1 diagonal traverses will be stored in double ended queues\\n        res = [deque() for _ in range(R + C - 1)]\\n        \\n        for r in range(R):\\n            for c in range(C):\\n                dist = r + c                        #distance from origin\\n                if dist & 1:                        #r + c is odd, do not reverse numbers\\n                    res[dist].append(matrix[r][c])\\n                else:                               #r + c is even, reverse numbers\\n                    res[dist].appendleft(matrix[r][c])\\n        \\n        #concatenate diagonal traverses\\n        return sum(res,deque())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702813,
                "title": "python-elegant-solution",
                "content": "```\\nclass Solution:\\n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\\n        ## RC ##\\n        ## APPROACH : GREEDY ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(MxN) ##\\n\\t\\t## SPACE COMPLEXITY : O(MxN) ##\\n\\n        if not matrix: return []\\n        M = len(matrix)\\n        N = len(matrix[0])\\n        diagonals = collections.defaultdict(list)\\n        for i in range(M):\\n            for j in range(N):\\n                diagonals[i+j].append(matrix[i][j])\\n        res = []\\n        for i, d in enumerate(diagonals.values()):\\n            res.extend(d) if i % 2 == 1 else res.extend(d[::-1])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\\n        ## RC ##\\n        ## APPROACH : GREEDY ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(MxN) ##\\n\\t\\t## SPACE COMPLEXITY : O(MxN) ##\\n\\n        if not matrix: return []\\n        M = len(matrix)\\n        N = len(matrix[0])\\n        diagonals = collections.defaultdict(list)\\n        for i in range(M):\\n            for j in range(N):\\n                diagonals[i+j].append(matrix[i][j])\\n        res = []\\n        for i, d in enumerate(diagonals.values()):\\n            res.extend(d) if i % 2 == 1 else res.extend(d[::-1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 698592,
                "title": "c-solution-using-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        if(matrix.empty()) return {};\\n        map<int,vector<int>> Hash;\\n        int M = matrix.size(); int N = matrix[0].size(); \\n        vector<int> ans(M*N);\\n        int k=0;\\n        for(int i=0; i<M; i++)\\n            for(int j=0; j<N; j++)\\n                Hash[i+j].push_back(matrix[i][j]);\\n        for(auto it = Hash.begin(); it!=Hash.end(); it++) {\\n            int index = it->first;\\n            if(index%2==0) {\\n                for(int i = it->second.size()-1; i>=0; i--) {\\n                    ans[k++] = it->second[i];\\n                }\\n            } else {\\n                for(int i=0; i<it->second.size(); i++) {\\n                    ans[k++] = it->second[i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findDiagonalOrder(vector<vector<int>>& matrix) {\\n        if(matrix.empty()) return {};\\n        map<int,vector<int>> Hash;\\n        int M = matrix.size(); int N = matrix[0].size(); \\n        vector<int> ans(M*N);\\n        int k=0;\\n        for(int i=0; i<M; i++)\\n            for(int j=0; j<N; j++)\\n                Hash[i+j].push_back(matrix[i][j]);\\n        for(auto it = Hash.begin(); it!=Hash.end(); it++) {\\n            int index = it->first;\\n            if(index%2==0) {\\n                for(int i = it->second.size()-1; i>=0; i--) {\\n                    ans[k++] = it->second[i];\\n                }\\n            } else {\\n                for(int i=0; i<it->second.size(); i++) {\\n                    ans[k++] = it->second[i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599959,
                "title": "python-3-defaultdict-list",
                "content": "```\\nclass Solution:\\n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\\n        if not len(matrix) or not len(matrix[0]):\\n            return []\\n\\t\\t\\n        n, m = len(matrix), len(matrix[0])\\n        x = defaultdict(list)\\n        ret = []\\n\\t\\t\\n        for i, row in enumerate(matrix):\\n            for j, num in enumerate(row):\\n                x[i + j].append(num)\\n\\t\\t\\t\\t\\n        for key in range(n + m - 1):\\n            if key % 2:\\n                ret.extend(x[key])\\n            else:\\n                ret.extend(reversed(x[key]))\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\\n        if not len(matrix) or not len(matrix[0]):\\n            return []\\n\\t\\t\\n        n, m = len(matrix), len(matrix[0])\\n        x = defaultdict(list)\\n        ret = []\\n\\t\\t\\n        for i, row in enumerate(matrix):\\n            for j, num in enumerate(row):\\n                x[i + j].append(num)\\n\\t\\t\\t\\t\\n        for key in range(n + m - 1):\\n            if key % 2:\\n                ret.extend(x[key])\\n            else:\\n                ret.extend(reversed(x[key]))\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 598008,
                "title": "java-hash-map-solution",
                "content": "```\\nimport java.util.Map.Entry;\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] arr) {\\n        if(arr.length==0)\\n            return new int[0];\\n        \\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n\\t\\t\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tfor(int j=0;j<arr[0].length;j++) {\\n\\t\\t\\t\\tif(!map.containsKey(i+j)) {\\n\\t\\t\\t\\t\\tmap.put(i+j,new ArrayList<>());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmap.get(i+j).add(arr[i][j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tSet<Map.Entry<Integer, List<Integer>>> obj = map.entrySet();\\n\\t\\t\\n\\t\\tint odd=1,index=0;\\n        int newArr[] = new int[arr.length*arr[0].length];\\n\\t\\tfor(Entry<Integer, List<Integer>> var:obj) {\\n\\t\\t\\tList<Integer> temp = var.getValue();\\n\\t\\t\\tif(odd%2!=0)\\n\\t\\t\\t\\tCollections.reverse(temp);\\n\\t\\t\\tfor(int x:temp){\\n                newArr[index]=x;\\n                index++;\\n            }\\n\\t\\t\\todd++;\\n\\t\\t}\\n        return newArr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Map.Entry;\\nclass Solution {\\n    public int[] findDiagonalOrder(int[][] arr) {\\n        if(arr.length==0)\\n            return new int[0];\\n        \\n        Map<Integer,List<Integer>> map = new HashMap<>();\\n\\t\\t\\n\\t\\tfor(int i=0;i<arr.length;i++) {\\n\\t\\t\\tfor(int j=0;j<arr[0].length;j++) {\\n\\t\\t\\t\\tif(!map.containsKey(i+j)) {\\n\\t\\t\\t\\t\\tmap.put(i+j,new ArrayList<>());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmap.get(i+j).add(arr[i][j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tSet<Map.Entry<Integer, List<Integer>>> obj = map.entrySet();\\n\\t\\t\\n\\t\\tint odd=1,index=0;\\n        int newArr[] = new int[arr.length*arr[0].length];\\n\\t\\tfor(Entry<Integer, List<Integer>> var:obj) {\\n\\t\\t\\tList<Integer> temp = var.getValue();\\n\\t\\t\\tif(odd%2!=0)\\n\\t\\t\\t\\tCollections.reverse(temp);\\n\\t\\t\\tfor(int x:temp){\\n                newArr[index]=x;\\n                index++;\\n            }\\n\\t\\t\\todd++;\\n\\t\\t}\\n        return newArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 555562,
                "title": "solution-using-generators-in-python",
                "content": "```\\nclass Solution:\\n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\\n        if not matrix:\\n            return []\\n        return list(iterator(matrix))\\n        \\n    \\ndef iterator(matrix):\\n    m, n = len(matrix), len(matrix[0])\\n\\t# False direction means it is arrow is bottom to top and True, means arrow is moving top to bottom. (top is the first row)\\n    direction = False\\n    for i in range(m+n-1):\\n\\t\\t# go layer by layer\\n        if direction:\\n            position = (0, i) if i < n else (i-n+1, n-1)\\n            while position[0] in range(m) and position[1] in range(n):\\n                yield matrix[position[0]][position[1]]\\n                position = position[0]+1, position[1]-1\\n            direction = not direction\\n        else:\\n            position = (i, 0) if i < m else (m-1, i-m+1)\\n            while position[0] in range(m) and position[1] in range(n):\\n                yield matrix[position[0]][position[1]]\\n                position = position[0]-1, position[1]+1\\n            direction = not direction\\n\\t\\t\\t\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findDiagonalOrder(self, matrix: List[List[int]]) -> List[int]:\\n        if not matrix:\\n            return []\\n        return list(iterator(matrix))\\n        \\n    \\ndef iterator(matrix):\\n    m, n = len(matrix), len(matrix[0])\\n\\t# False direction means it is arrow is bottom to top and True, means arrow is moving top to bottom. (top is the first row)\\n    direction = False\\n    for i in range(m+n-1):\\n\\t\\t# go layer by layer\\n        if direction:\\n            position = (0, i) if i < n else (i-n+1, n-1)\\n            while position[0] in range(m) and position[1] in range(n):\\n                yield matrix[position[0]][position[1]]\\n                position = position[0]+1, position[1]-1\\n            direction = not direction\\n        else:\\n            position = (i, 0) if i < m else (m-1, i-m+1)\\n            while position[0] in range(m) and position[1] in range(n):\\n                yield matrix[position[0]][position[1]]\\n                position = position[0]-1, position[1]+1\\n            direction = not direction\\n\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 494694,
                "title": "java-clean-solution",
                "content": "Just follow these observations :\\n\\n    if up : row = row - 1, col = col + 1\\n    if down : row = row + 1, col = col - 1\\n\\n    if up and cross boundary :\\n        if right available, start from there (prev_row, col+1)\\n        else go down (prev_row + 1, col)\\n    if down and cross boundary :\\n        if down available, start from there (prev_row + 1, col)\\n        else go right (prev_row, col + 1)\\n\\nThe implementation becomes trivial after this observation.\\n\\n```\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0)\\n            return new int[0];\\n        int m = matrix.length, n = matrix[0].length;\\n        int[] res = new int[m * n];\\n        int total = m * n, cur_row = 0, cur_col = 0, i = 0;\\n        boolean up = true;\\n        while (i != total) {\\n            res[i++] = matrix[cur_row][cur_col];\\n            int prev_row = cur_row;\\n            int prev_col = cur_col;\\n            if (up) {\\n                cur_row--;\\n                cur_col++;\\n            } else {\\n                cur_row++;\\n                cur_col--;\\n            }\\n            if (up && (cur_row < 0 || cur_row > m - 1 || cur_col < 0 || cur_col > n - 1)) {\\n                if (prev_col + 1 <= n - 1) {\\n                    cur_row = prev_row;\\n                    cur_col = prev_col + 1;\\n                } else {\\n                    cur_row = prev_row + 1;\\n                    cur_col = prev_col;\\n                }\\n                up = false;\\n            } else if (!up && (cur_row < 0 || cur_row > m - 1 || cur_col < 0 || cur_col > n - 1)) {\\n                if (prev_row + 1 <= m - 1) {\\n                    cur_row = prev_row + 1;\\n                    cur_col = prev_col;\\n                } else {\\n                    cur_row = prev_row;\\n                    cur_col = prev_col + 1;\\n                }\\n                up = true;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] findDiagonalOrder(int[][] matrix) {\\n        if (matrix == null || matrix.length == 0)\\n            return new int[0];\\n        int m = matrix.length, n = matrix[0].length;\\n        int[] res = new int[m * n];\\n        int total = m * n, cur_row = 0, cur_col = 0, i = 0;\\n        boolean up = true;\\n        while (i != total) {\\n            res[i++] = matrix[cur_row][cur_col];\\n            int prev_row = cur_row;\\n            int prev_col = cur_col;\\n            if (up) {\\n                cur_row--;\\n                cur_col++;\\n            } else {\\n                cur_row++;\\n                cur_col--;\\n            }\\n            if (up && (cur_row < 0 || cur_row > m - 1 || cur_col < 0 || cur_col > n - 1)) {\\n                if (prev_col + 1 <= n - 1) {\\n                    cur_row = prev_row;\\n                    cur_col = prev_col + 1;\\n                } else {\\n                    cur_row = prev_row + 1;\\n                    cur_col = prev_col;\\n                }\\n                up = false;\\n            } else if (!up && (cur_row < 0 || cur_row > m - 1 || cur_col < 0 || cur_col > n - 1)) {\\n                if (prev_row + 1 <= m - 1) {\\n                    cur_row = prev_row + 1;\\n                    cur_col = prev_col;\\n                } else {\\n                    cur_row = prev_row;\\n                    cur_col = prev_col + 1;\\n                }\\n                up = true;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 486067,
                "title": "c-100-o-nm-with-o-1-space-calculating-the-index-with-summations",
                "content": "Basically just figured out what the closed form of the summation for number of elements above the diagonal was, then add an offset depending on whether we\\'re going up or down, and add any extra elements for non-square matrices.\\n```\\n\\nint _ = []() {\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    return 0;\\n}();\\n\\n\\nclass Solution\\n{\\npublic:\\n    // wanted to see if possible to outright calculate which index to move each element \\n    // to, which by default gives O(MN) runtime and O(1) memory (as long as the calculation is constant)\\n    vector<int> findDiagonalOrder(vector<vector<int>> &matrix)\\n    {\\n        if(matrix.empty()) return {};\\n        const int M = matrix.size(), N = matrix[0].size();\\n        vector<int> res(M * N);\\n        bool isTall = N < M;\\n        const int wid = isTall ? N : M;\\n        const int len = isTall ? M : N;\\n        for (int m = 0; m < M; m++)\\n            for (int n = 0; n < N; n++)\\n                res[getIdxOfDiagonalPos(m,n,M,N,wid,len)] = matrix[m][n];\\n        return res;\\n    }\\n    inline int getIdxOfDiagonalPos(int m, int n, int M, int N, int wid, int len) {\\n        int diag = m + n;\\n        bool goingup = !(diag & 1);\\n        int offset = goingup ? n-max(diag-M+1, 0) : m-max(diag-N+1, 0);\\n        int extra = max(min(diag - wid, len - wid),0); \\n        int idx = extra * wid; // account for extra diagonals of non-square matrices\\n        diag -= extra; // treat as if square for summations               \\n        idx += ((diag * diag + diag)>>1) + offset; // summation for triangle above diagonal\\n        if(diag>=wid) idx -= ((diag-wid)*((diag-wid)+1)); // summation adjustment for diminishing lower triangle\\n        return idx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nint _ = []() {\\n    std::ios::sync_with_stdio(false);\\n    cin.tie(NULL);\\n    return 0;\\n}();\\n\\n\\nclass Solution\\n{\\npublic:\\n    // wanted to see if possible to outright calculate which index to move each element \\n    // to, which by default gives O(MN) runtime and O(1) memory (as long as the calculation is constant)\\n    vector<int> findDiagonalOrder(vector<vector<int>> &matrix)\\n    {\\n        if(matrix.empty()) return {};\\n        const int M = matrix.size(), N = matrix[0].size();\\n        vector<int> res(M * N);\\n        bool isTall = N < M;\\n        const int wid = isTall ? N : M;\\n        const int len = isTall ? M : N;\\n        for (int m = 0; m < M; m++)\\n            for (int n = 0; n < N; n++)\\n                res[getIdxOfDiagonalPos(m,n,M,N,wid,len)] = matrix[m][n];\\n        return res;\\n    }\\n    inline int getIdxOfDiagonalPos(int m, int n, int M, int N, int wid, int len) {\\n        int diag = m + n;\\n        bool goingup = !(diag & 1);\\n        int offset = goingup ? n-max(diag-M+1, 0) : m-max(diag-N+1, 0);\\n        int extra = max(min(diag - wid, len - wid),0); \\n        int idx = extra * wid; // account for extra diagonals of non-square matrices\\n        diag -= extra; // treat as if square for summations               \\n        idx += ((diag * diag + diag)>>1) + offset; // summation for triangle above diagonal\\n        if(diag>=wid) idx -= ((diag-wid)*((diag-wid)+1)); // summation adjustment for diminishing lower triangle\\n        return idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1572713,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 1821988,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 1989721,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 1802070,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 1736846,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 2076157,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 2063927,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 2016013,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 2009929,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 1777046,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 1572713,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 1821988,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 1989721,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 1802070,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 1736846,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 2076157,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 2063927,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 2016013,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 2009929,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            },
            {
                "id": 1777046,
                "content": [
                    {
                        "username": "jleine02",
                        "content": "Hello,\\n\\nJust curious, how long would you expect this problem to take to answer assuming that you have never seen the exact problem before and are creating a solution during an interview.\\n\\nIt would be great to see expected completion times for what people would consider a beginner, intermediate, and advanced programmer.\\n\\nI\\'m just starting out and have no idea how quickly I\\'d be expected to finish this problem.\\n\\n"
                    },
                    {
                        "username": "Anshul29",
                        "content": "if youre a beginner it can easily take two hours"
                    },
                    {
                        "username": "FerhatKul",
                        "content": "It took my 2-3 hours to solve and was about to fire up my brain cells :(\\nNot sure if I can solve it again in case to be asked in an interview even tomorrow."
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Zig Zag Fashion"
                    },
                    {
                        "username": "firuz97",
                        "content": "it takes me long to solve it ((-"
                    },
                    {
                        "username": "raghavrathore7415",
                        "content": "Just like spiral traverse in matrix think of this problem as zigzag traverse in matrix"
                    },
                    {
                        "username": "sidhanttiwari03",
                        "content": "Some useful testcases, since there were none for me to test:\\n\\n1)   [[7],[9],[6]]\\n2)   [[1,2,3,4,5,6]]\\n3)   [[1]]\\n4)   [[1,2]]\\n5)   [[1,2,3,4],[5,6,7,8]]"
                    },
                    {
                        "username": "1062173198songkai",
                        "content": "This question is not clear. How do you define the diagonal of a rectangle that is not a square?\\n"
                    },
                    {
                        "username": "skandavyas20",
                        "content": "  int ar[] = new int[mat.length*mat[0].length];\\n         System.out.println(mat[0].length*mat.length);\\n        System.out.print(\"length:\" + ar.length);\\n        System.out.println(ar.length);\\n\\nfor the first example it says the length of the given matrix is 99 although mat.length and mat[0].length are 3 eaxch, explain please i am so confused"
                    },
                    {
                        "username": "terrylinooo",
                        "content": "The author\\'s code does not follow the question\\'s constraints. \\n```\\nint N = matrix.length;\\nint M = matrix[0].length;\\n```\\nAccording to the constraints:\\n```\\nm == mat.length\\nn == mat[i].length\\n```\\nThis discrepancy caused confusion and wasted a lot of my time trying to understand the differences."
                    },
                    {
                        "username": "benjamin_moses",
                        "content": "I solved it both ways and the second way did hurt my brain a bit. I had to write comments all over my code to keep it straight, but reading them might help others struggling with this. My ruby solution is 80% speed 100% memory  https://leetcode.com/problems/diagonal-traverse/submissions/886499764/"
                    }
                ]
            }
        ]
    },
    {
        "title": "Range Addition II",
        "question_content": "<p>You are given an <code>m x n</code> matrix <code>M</code> initialized with all <code>0</code>&#39;s and an array of operations <code>ops</code>, where <code>ops[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> means <code>M[x][y]</code> should be incremented by one for all <code>0 &lt;= x &lt; a<sub>i</sub></code> and <code>0 &lt;= y &lt; b<sub>i</sub></code>.</p>\n\n<p>Count and return <em>the number of maximum integers in the matrix after performing all the operations</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/10/02/ex1.jpg\" style=\"width: 750px; height: 176px;\" />\n<pre>\n<strong>Input:</strong> m = 3, n = 3, ops = [[2,2],[3,3]]\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The maximum integer in M is 2, and there are four of it in M. So return 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> m = 3, n = 3, ops = [[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3],[2,2],[3,3],[3,3],[3,3]]\n<strong>Output:</strong> 4\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> m = 3, n = 3, ops = []\n<strong>Output:</strong> 9\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= m, n &lt;= 4 * 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= ops.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>ops[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub> &lt;= m</code></li>\n\t<li><code>1 &lt;= b<sub>i</sub> &lt;= n</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 103595,
                "title": "java-solution-find-min",
                "content": "```\\npublic class Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if (ops == null || ops.length == 0) {\\n            return m * n;\\n        }\\n        \\n        int row = Integer.MAX_VALUE, col = Integer.MAX_VALUE;\\n        for(int[] op : ops) {\\n            row = Math.min(row, op[0]);\\n            col = Math.min(col, op[1]);\\n        }\\n        \\n        return row * col;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if (ops == null || ops.length == 0) {\\n            return m * n;\\n        }\\n        \\n        int row = Integer.MAX_VALUE, col = Integer.MAX_VALUE;\\n        for(int[] op : ops) {\\n            row = Math.min(row, op[0]);\\n            col = Math.min(col, op[1]);\\n        }\\n        \\n        return row * col;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103610,
                "title": "python-solution-beat-100",
                "content": "An operation [a,b] add by one for all 0 <= i < a and 0 <= j < b.\\nSo the number of maximum integers in the matrix after performing all the operations or the integers in matrix that get added by 1 by all operations are the integers that in *0 <=i<min_a* and *0<=i<min_b* or **min_a * min_b**\\n```class Solution(object):\\n    def maxCount(self, m, n, ops):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type ops: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not ops:\\n            return m*n\\n        return min(op[0] for op in ops)*min(op[1] for op in ops)",
                "solutionTags": [],
                "code": "An operation [a,b] add by one for all 0 <= i < a and 0 <= j < b.\\nSo the number of maximum integers in the matrix after performing all the operations or the integers in matrix that get added by 1 by all operations are the integers that in *0 <=i<min_a* and *0<=i<min_b* or **min_a * min_b**\\n```class Solution(object):\\n    def maxCount(self, m, n, ops):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type ops: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not ops:\\n            return m*n\\n        return min(op[0] for op in ops)*min(op[1] for op in ops)",
                "codeTag": "Java"
            },
            {
                "id": 1434377,
                "title": "python-oneliner-explained",
                "content": "We can note, that `[0, 0]` will always be increased by `1` for every range we have. What cells also will be increased by `1` for every range? It is all coordinates, where `x <= min(all x cooridnates)` and `y <= min(all y coordinates)`.\\n\\nSo we need to find minimum of all `x` coordinates and multiply it by minimum of all `y` coordinates. If we have empty update list, we need to return `m * n` (because all elements still equal to `0`) so we can add it to our `ops`. \\n\\n#### Complexity\\nTime complexity is `O(k)`, where `k` is number of updates, space complexity is `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxCount(self, m, n, ops):\\n        return min(i for i,_ in ops+[[m,n]]) * min(j for _,j in ops+[[m,n]])\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Math"
                ],
                "code": "```python\\nclass Solution:\\n    def maxCount(self, m, n, ops):\\n        return min(i for i,_ in ops+[[m,n]]) * min(j for _,j in ops+[[m,n]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434604,
                "title": "c-c-python-java-c-javascript-go-same-simple-solution",
                "content": "C:\\n```\\nint maxCount(int m, int n, int** ops, int opsSize, int* opsColSize){\\n        int min_row = m;\\n        int min_col = n;\\n        for (int i=0; i<opsSize; i++){\\n            if (ops[i][0]<min_row) min_row=ops[i][0];\\n            if (ops[i][1]<min_col) min_col=ops[i][1];\\n        }        \\n        return min_row*min_col;\\n}\\n```\\nC++:\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int min_row = m;\\n        int min_col = n;\\n        for (int i=0; i<ops.size(); i++){\\n            if (ops[i][0]<min_row) min_row=ops[i][0];\\n            if (ops[i][1]<min_col) min_col=ops[i][1];\\n        }        \\n        return min_row*min_col;\\n        \\n    }\\n};\\n```\\nPython:\\n```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        min_row = m\\n        min_col = n\\n        for i in range(len(ops)):\\n            min_row=min(min_row, ops[i][0])\\n            min_col=min(min_col, ops[i][1])\\n        return min_row*min_col\\n```\\nJava:\\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int min_row = m;\\n        int min_col = n;\\n        for (int i=0; i<ops.length; i++){\\n            if (ops[i][0]<min_row) min_row=ops[i][0];\\n            if (ops[i][1]<min_col) min_col=ops[i][1];\\n        }        \\n        return min_row*min_col;\\n        \\n    }\\n}\\n```\\nC#\\n```\\npublic class Solution {\\n    public int MaxCount(int m, int n, int[][] ops) {\\n        int min_row = m;\\n        int min_col = n;\\n        for (int i=0; i<ops.Length; i++){\\n            if (ops[i][0]<min_row) min_row=ops[i][0];\\n            if (ops[i][1]<min_col) min_col=ops[i][1];\\n        }        \\n        return min_row*min_col;\\n        \\n    }\\n}\\n```\\nJavaScript:\\n```\\nvar maxCount = function(m, n, ops) {\\n    var min_row = m;\\n    var min_col = n;\\n    for (let i=0; i<ops.length; i++){\\n        if (ops[i][0]<min_row) min_row=ops[i][0];\\n        if (ops[i][1]<min_col) min_col=ops[i][1];\\n    }        \\n    return min_row*min_col;\\n};\\n```\\nGo:\\n```\\nfunc maxCount(m int, n int, ops [][]int) int {\\n    var min_row int = m;\\n    var min_col int = n;\\n    for i:=0; i<len(ops); i++{\\n        if ops[i][0]<min_row {min_row=ops[i][0]}\\n        if ops[i][1]<min_col {min_col=ops[i][1]}\\n    }        \\n    return min_row*min_col;\\n    \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "C#",
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nint maxCount(int m, int n, int** ops, int opsSize, int* opsColSize){\\n        int min_row = m;\\n        int min_col = n;\\n        for (int i=0; i<opsSize; i++){\\n            if (ops[i][0]<min_row) min_row=ops[i][0];\\n            if (ops[i][1]<min_col) min_col=ops[i][1];\\n        }        \\n        return min_row*min_col;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int min_row = m;\\n        int min_col = n;\\n        for (int i=0; i<ops.size(); i++){\\n            if (ops[i][0]<min_row) min_row=ops[i][0];\\n            if (ops[i][1]<min_col) min_col=ops[i][1];\\n        }        \\n        return min_row*min_col;\\n        \\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        min_row = m\\n        min_col = n\\n        for i in range(len(ops)):\\n            min_row=min(min_row, ops[i][0])\\n            min_col=min(min_col, ops[i][1])\\n        return min_row*min_col\\n```\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int min_row = m;\\n        int min_col = n;\\n        for (int i=0; i<ops.length; i++){\\n            if (ops[i][0]<min_row) min_row=ops[i][0];\\n            if (ops[i][1]<min_col) min_col=ops[i][1];\\n        }        \\n        return min_row*min_col;\\n        \\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxCount(int m, int n, int[][] ops) {\\n        int min_row = m;\\n        int min_col = n;\\n        for (int i=0; i<ops.Length; i++){\\n            if (ops[i][0]<min_row) min_row=ops[i][0];\\n            if (ops[i][1]<min_col) min_col=ops[i][1];\\n        }        \\n        return min_row*min_col;\\n        \\n    }\\n}\\n```\n```\\nvar maxCount = function(m, n, ops) {\\n    var min_row = m;\\n    var min_col = n;\\n    for (let i=0; i<ops.length; i++){\\n        if (ops[i][0]<min_row) min_row=ops[i][0];\\n        if (ops[i][1]<min_col) min_col=ops[i][1];\\n    }        \\n    return min_row*min_col;\\n};\\n```\n```\\nfunc maxCount(m int, n int, ops [][]int) int {\\n    var min_row int = m;\\n    var min_col int = n;\\n    for i:=0; i<len(ops); i++{\\n        if ops[i][0]<min_row {min_row=ops[i][0]}\\n        if ops[i][1]<min_col {min_col=ops[i][1]}\\n    }        \\n    return min_row*min_col;\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103612,
                "title": "python-straightforward-with-explanation",
                "content": "Say the operations are ```[(x_1, y_1), (x_2, y_2), ..., (x_n, y_n)]```.  The top left square is clearly incremented by every operation.  If some square ```(x, y)``` has ```x >= x_i```, then it will not be marked by operation ```i```.  So all squares ```(x, y)``` with ```x >= min_i(x_i)``` do not get marked.  \\n\\nThus, when there is atleast one operation, all squares ```(x, y)``` with ```0 <= x < min(x_1, x_2, ..., x_n) and 0 <= y < min(y_1, y_2, ..., y_n)``` get marked; and there are ```min_i(x_i) * min_i(y_i)``` of them.  If there are no operations, then what is marked is the entire board.\\n\\n```\\ndef maxCount(self, R, C, ops):\\n    if not ops: return R * C\\n    X, Y = zip(*ops)\\n    return min(X) * min(Y)\\n```",
                "solutionTags": [],
                "code": "```[(x_1, y_1), (x_2, y_2), ..., (x_n, y_n)]```\n```(x, y)```\n```x >= x_i```\n```i```\n```(x, y)```\n```x >= min_i(x_i)```\n```(x, y)```\n```0 <= x < min(x_1, x_2, ..., x_n) and 0 <= y < min(y_1, y_2, ..., y_n)```\n```min_i(x_i) * min_i(y_i)```\n```\\ndef maxCount(self, R, C, ops):\\n    if not ops: return R * C\\n    X, Y = zip(*ops)\\n    return min(X) * min(Y)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1434399,
                "title": "range-addition-ii-easy-and-clean-code-w-approach-c-java-python3",
                "content": "**IDEA**\\n\\n* The result matrix is always going to be in the **top-left** of the original matrix \\n* What cells will be increased by 1 for every range?\\n\\t* All coordinates, where `x <= minimum of prev x coordinates` and `y <= minimum of prev y coordinates`.\\n* That means, we need to continue updating the minimum value of `operators[i][1]` and `operators[i][0]` bottom right corner\\n* The answer would be their multiplication \\n\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int xMin = m ;\\n        int yMin = n ;\\n        for(auto& op:ops)\\n        {\\n            xMin = min(op[0] , xMin) ;\\n            yMin = min(op[1] , yMin) ;\\n        }\\n        return xMin*yMin;\\n    }\\n};\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int xmin = m , ymin = n ;\\n        for(int op[]:ops){\\n            xmin = Math.min(xmin,op[0]);\\n            ymin = Math.min(ymin,op[1]);\\n        }\\n        return xmin*ymin;\\n    }\\n}\\n```\\n`In Python3`\\n```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        xmin = m\\n        ymin = n\\n        for i in ops:\\n            if i[0] < xmin:\\n                xmin=i[0]\\n            if i[1] < ymin:\\n                ymin=i[1]\\n        return xmin*ymin\\n```\\n**TIME COMPLEXITY- O(N)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int xMin = m ;\\n        int yMin = n ;\\n        for(auto& op:ops)\\n        {\\n            xMin = min(op[0] , xMin) ;\\n            yMin = min(op[1] , yMin) ;\\n        }\\n        return xMin*yMin;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int xmin = m , ymin = n ;\\n        for(int op[]:ops){\\n            xmin = Math.min(xmin,op[0]);\\n            ymin = Math.min(ymin,op[1]);\\n        }\\n        return xmin*ymin;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        xmin = m\\n        ymin = n\\n        for i in ops:\\n            if i[0] < xmin:\\n                xmin=i[0]\\n            if i[1] < ymin:\\n                ymin=i[1]\\n        return xmin*ymin\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434436,
                "title": "c-simple-and-easy-solution-2-lines-only",
                "content": "**Idea:**\\nWe always increment the top-left corner, and start from there.\\nThe minimum [x, y] in the ops will be the top-left part that was incremented the most.\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int res_m = m, res_n = n;\\n        \\n        for (auto op : ops) {\\n            res_m = min(res_m, op[0]); \\n            res_n = min(res_n, op[1]);\\n        }\\n            \\n        return res_m * res_n;\\n    }\\n};\\n```\\n**More consice, Only two lines:**\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        for (auto op : ops) m = min(m, op[0]), n = min(n, op[1]);\\n        return m * n;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int res_m = m, res_n = n;\\n        \\n        for (auto op : ops) {\\n            res_m = min(res_m, op[0]); \\n            res_n = min(res_n, op[1]);\\n        }\\n            \\n        return res_m * res_n;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        for (auto op : ops) m = min(m, op[0]), n = min(n, op[1]);\\n        return m * n;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434397,
                "title": "c-python3-java-easy-solution-w-approach",
                "content": "**IDEA**\\n\\n* The result matrix is always going to be in the **top-left** of the original matrix \\n* What cells will be increased by 1 for every range?\\n\\t* All coordinates, where `x <= minimum of prev x coordinates` and `y <= minimum of prev y coordinates`.\\n* That means, we need to continue updating the minimum value of `operators[i][1]` and `operators[i][0]` bottom right corner\\n* The answer would be their multiplication \\n\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int xMin = m ;\\n        int yMin = n ;\\n        for(auto& op:ops)\\n        {\\n            xMin = min(op[0] , xMin) ;\\n            yMin = min(op[1] , yMin) ;\\n        }\\n        return xMin*yMin;\\n    }\\n};\\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int xmin = m , ymin = n ;\\n        for(int op[]:ops){\\n            xmin = Math.min(xmin,op[0]);\\n            ymin = Math.min(ymin,op[1]);\\n        }\\n        return xmin*ymin;\\n    }\\n}\\n```\\n`In Python3`\\n```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        xmin = m\\n        ymin = n\\n        for i in ops:\\n            if i[0] < xmin:\\n                xmin=i[0]\\n            if i[1] < ymin:\\n                ymin=i[1]\\n        return xmin*ymin\\n```\\n**TIME COMPLEXITY- O(N)**\\n\\n* When working with 2-D arrays, always try to traverse from both ends to reduce the runtime. A more optimised version of the java solution gets it to (0ms) with \"Your runtime beats 100.00 % of java submissions.\",\\n\\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int xmin = m , ymin = n;\\n        int i = 0, j = ops.length - 1;\\n        while (i <= j) {\\n            xmin = Math.min(xmin,Math.min(ops[i][0], ops[j][0]));\\n            ymin = Math.min(ymin,Math.min(ops[i++][1], ops[j--][1]));\\n        }\\n        return xmin*ymin;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int xMin = m ;\\n        int yMin = n ;\\n        for(auto& op:ops)\\n        {\\n            xMin = min(op[0] , xMin) ;\\n            yMin = min(op[1] , yMin) ;\\n        }\\n        return xMin*yMin;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int xmin = m , ymin = n ;\\n        for(int op[]:ops){\\n            xmin = Math.min(xmin,op[0]);\\n            ymin = Math.min(ymin,op[1]);\\n        }\\n        return xmin*ymin;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        xmin = m\\n        ymin = n\\n        for i in ops:\\n            if i[0] < xmin:\\n                xmin=i[0]\\n            if i[1] < ymin:\\n                ymin=i[1]\\n        return xmin*ymin\\n```\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int xmin = m , ymin = n;\\n        int i = 0, j = ops.length - 1;\\n        while (i <= j) {\\n            xmin = Math.min(xmin,Math.min(ops[i][0], ops[j][0]));\\n            ymin = Math.min(ymin,Math.min(ops[i++][1], ops[j--][1]));\\n        }\\n        return xmin*ymin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718911,
                "title": "c-solution-explain-with-picture",
                "content": "The result matrix is always on the top-left of the origional matrix, so what we need to do is to find the intersection of matrixs in the list.\\nThat means, we just need to continue updating the minimun value of operators[i][1] and operators[i][0] to find the down-right cornor of the result matrix\\n\\n![image](https://assets.leetcode.com/users/images/1916373e-664f-45a5-ab2c-41610410822d_1593849906.3668296.png)\\n\\n```\\nint maxCount(int m, int n, int** ops, int opsSize, int* opsColSize){\\n    int res_l = m;\\n    int res_h = n;\\n    for(int i = 0; i < opsSize; i ++){\\n        if(ops[i][0] < res_l) res_l = ops[i][0];\\n        if(ops[i][1] < res_h) res_h = ops[i][1];\\n    }\\n    return res_l * res_h;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxCount(int m, int n, int** ops, int opsSize, int* opsColSize){\\n    int res_l = m;\\n    int res_h = n;\\n    for(int i = 0; i < opsSize; i ++){\\n        if(ops[i][0] < res_l) res_l = ops[i][0];\\n        if(ops[i][1] < res_h) res_h = ops[i][1];\\n    }\\n    return res_l * res_h;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 103638,
                "title": "c-short-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        for (int i = 0; i < ops.size(); ++i) {\\n            m = min(m, ops[i][0]);\\n            n = min(n, ops[i][1]);\\n        }\\n        return m*n;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        for (int i = 0; i < ops.size(); ++i) {\\n            m = min(m, ops[i][0]);\\n            n = min(n, ops[i][1]);\\n        }\\n        return m*n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434642,
                "title": "wrong-constraint-in-problem-statement",
                "content": "The problem statement gives the following constraint:\\n\\n```\\n1 <= ops.length <= 10^4\\n```\\n\\nHowever, example 3 is:\\n\\n```\\nm = 3, n = 3, ops = []\\n```\\n\\ni.e., ops.length == 0\\n\\nConstraint in problem statement should be fixed with:\\n\\n```\\n0 <= ops.length <= 10^4\\n```\\n\\n**EDIT**\\nIt is fixed now",
                "solutionTags": [],
                "code": "```\\n1 <= ops.length <= 10^4\\n```\n```\\nm = 3, n = 3, ops = []\\n```\n```\\n0 <= ops.length <= 10^4\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 103617,
                "title": "intuitive-javascript-solution",
                "content": "```\\nvar maxCount = function(m, n, ops) {\\n    let minRow = m;\\n    let minCol = n;\\n    \\n    // find overlap of the operators\\n    for (const op of ops) {\\n        minRow = Math.min(minRow, op[0]);\\n        minCol = Math.min(minCol, op[1]);\\n    }\\n    \\n    return minRow * minCol;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxCount = function(m, n, ops) {\\n    let minRow = m;\\n    let minCol = n;\\n    \\n    // find overlap of the operators\\n    for (const op of ops) {\\n        minRow = Math.min(minRow, op[0]);\\n        minCol = Math.min(minCol, op[1]);\\n    }\\n    \\n    return minRow * minCol;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1436227,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n\\t\\tdef maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n\\t\\t\\t\\treturn min([opr[0] for opr in ops])*min([opr[1] for opr in ops]) if len(ops) else m*n\\n\\t\\t\\t\\t\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\t\\tdef maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n\\t\\t\\t\\treturn min([opr[0] for opr in ops])*min([opr[1] for opr in ops]) if len(ops) else m*n\\n\\t\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234854,
                "title": "faster-than-92-68-of-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int a = m;\\n        int b = n;\\n        for (auto i: ops){\\n            if (i[0] < a){\\n                a = i[0];\\n            }\\n            if (i[1] < b){\\n                b = i[1];\\n            } \\n        }\\n        return (a * b);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int a = m;\\n        int b = n;\\n        for (auto i: ops){\\n            if (i[0] < a){\\n                a = i[0];\\n            }\\n            if (i[1] < b){\\n                b = i[1];\\n            } \\n        }\\n        return (a * b);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435867,
                "title": "java-100-clean-simple-solution-with-explanation-o-n",
                "content": "tl;dr: Find the dimensions of the bottom right corner of the quadralateral formed when all rectangles formed by `ops` is intersected. In other words, just find the minimum bounds of all rectangles, such that the starting bounds is assumed to be `m` and `n`.\\n\\nAfter finding the bottom right corner of the intersected rectangle, find the area and multiply the x and y coordinates.\\n\\n```java\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        /*\\n            Despite being an easy problem, the problem is quite tricky if you were to try to figure out a more clever way to solve it.\\n            The most straightforward way of doing it is following what the directions ask:\\n                - Increment each square from (0, 0) to (x, y) for each operation.\\n                - Iterate over the whole matrix to find the number that appears the most (we can assume that the numbers appear in a square due to the way we added it in the first bullet).\\n            This works, but this involves a lot of extra steps that are not necessary.\\n            The more clever way to solve it is to figure out what is the intersection of the bounds such that all rectangles formed by ops overlaps.\\n            We know that every formed rectangle starts at the top left (0, 0), so we just need to find the minimum of these coordinates.\\n            Once we do, we just find the area of that intersecting rectangle.\\n            \\n            Time: O(n) - the algorithm iterates over n given operations.\\n            Space: O(1) - algorithm does not user extra space.\\n        */\\n        \\n        // We just need to find the min dimensions and then multiply the coordinates\\n        int x = m, y = n;\\n        for (int[] op : ops) {\\n            x = Math.min(x, op[0]);\\n            y = Math.min(y, op[1]);\\n        }\\n        \\n        return x * y;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        /*\\n            Despite being an easy problem, the problem is quite tricky if you were to try to figure out a more clever way to solve it.\\n            The most straightforward way of doing it is following what the directions ask:\\n                - Increment each square from (0, 0) to (x, y) for each operation.\\n                - Iterate over the whole matrix to find the number that appears the most (we can assume that the numbers appear in a square due to the way we added it in the first bullet).\\n            This works, but this involves a lot of extra steps that are not necessary.\\n            The more clever way to solve it is to figure out what is the intersection of the bounds such that all rectangles formed by ops overlaps.\\n            We know that every formed rectangle starts at the top left (0, 0), so we just need to find the minimum of these coordinates.\\n            Once we do, we just find the area of that intersecting rectangle.\\n            \\n            Time: O(n) - the algorithm iterates over n given operations.\\n            Space: O(1) - algorithm does not user extra space.\\n        */\\n        \\n        // We just need to find the min dimensions and then multiply the coordinates\\n        int x = m, y = n;\\n        for (int[] op : ops) {\\n            x = Math.min(x, op[0]);\\n            y = Math.min(y, op[1]);\\n        }\\n        \\n        return x * y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518979,
                "title": "java-iterative-math-easy-solution",
                "content": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if (ops.length==0)\\n            return m*n;\\n        int row=Integer.MAX_VALUE, col=Integer.MAX_VALUE;\\n        for(int i=0;i<ops.length;i++) {\\n            row = Math.min(row,ops[i][0]);\\n            col = Math.min(col,ops[i][1]);\\n        }\\n        return row*col;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if (ops.length==0)\\n            return m*n;\\n        int row=Integer.MAX_VALUE, col=Integer.MAX_VALUE;\\n        for(int i=0;i<ops.length;i++) {\\n            row = Math.min(row,ops[i][0]);\\n            col = Math.min(col,ops[i][1]);\\n        }\\n        return row*col;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995690,
                "title": "simple-and-easy-python-4-lines-explanation-added",
                "content": "**Explanation**:\\nNo matter what the value of the largest value in the matrix is, it will always be in the overlapped part of `ops`. For example, if` ops` told you to increment everything up to `[2,2]` by one and then increment everything up to `[4,4]` by one, then the overlapped part is `[2,2]`. This part will then be incremented by **two** now. To find the overlapped part, we find the element in `ops` that has the **minimum** `a` and `b` value pairs.\\n\\n```\\nclass Solution(object):\\n    def maxCount(self, m, n, ops):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type ops: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        for i, j in ops:\\n            m = min(m, i)\\n            n = min(n, j)\\n        return m * n\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxCount(self, m, n, ops):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type ops: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        for i, j in ops:\\n            m = min(m, i)\\n            n = min(n, j)\\n        return m * n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471017,
                "title": "c-1-line-solution-with-linq",
                "content": "Just for C# beginners. \\n```\\npublic class Solution {\\n    public int MaxCount(int m, int n, int[][] ops) {\\n        return ops.Length == 0 ? m * n : ops.Select(o => o[0]).Min() * ops.Select(o => o[1]).Min();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxCount(int m, int n, int[][] ops) {\\n        return ops.Length == 0 ? m * n : ops.Select(o => o[0]).Min() * ops.Select(o => o[1]).Min();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380432,
                "title": "solution-in-python-3-one-line-beats-98",
                "content": "```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, p: List[List[int]]) -> int:\\n    \\treturn min([i[0] for i in p])*min(i[1] for i in p) if p else m*n\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, p: List[List[int]]) -> int:\\n    \\treturn min([i[0] for i in p])*min(i[1] for i in p) if p else m*n\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n(LeetCode ID)@hotmail.com",
                "codeTag": "Java"
            },
            {
                "id": 1999498,
                "title": "the-naive-brute-force-solution-that-didn-t-pass-but-here-it-is-in-python",
                "content": "1. Create empty matrix\\n2. Increment matrix by 1 based on ops\\n3. Find the largest value in the matrix\\n4. Find the count of the largest value in the matrix\\n\\nThat\\'s **FOUR** loops, for this one problem. Obviously brute force and not optimized. But this code is just to show what doing the steps manually would look like, other than other people\\'s \"find min\" that people can\\'t understand at first glance.\\n\\n```\\nclass Solution(object):\\n    def maxCount(self, m, n, ops):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type ops: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not ops:\\n            return m*n\\n        \\n        M = [[0 for x in range(m)] for y in range(n)] \\n        \\n        for r in ops:\\n            for i in range(r[0]):\\n                for j in range(r[1]):\\n                    M[i][j] += 1\\n        largest = 0\\n        for i in range(len(M)):\\n            for j in range(len(M[i])):\\n                if M[i][j] > largest:\\n                    largest = M[i][j]\\n        count = 0\\n        for a in range(len(M)):\\n            for b in range(len(M[i])):\\n                if M[a][b] == largest:\\n                    count += 1\\n        return count\\n\\n```\\n\\n**If you liked this, please upvote to support me!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxCount(self, m, n, ops):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type ops: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not ops:\\n            return m*n\\n        \\n        M = [[0 for x in range(m)] for y in range(n)] \\n        \\n        for r in ops:\\n            for i in range(r[0]):\\n                for j in range(r[1]):\\n                    M[i][j] += 1\\n        largest = 0\\n        for i in range(len(M)):\\n            for j in range(len(M[i])):\\n                if M[i][j] > largest:\\n                    largest = M[i][j]\\n        count = 0\\n        for a in range(len(M)):\\n            for b in range(len(M[i])):\\n                if M[a][b] == largest:\\n                    count += 1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842230,
                "title": "1-line-python-solution-96-faster-68ms-memory-less-than-90",
                "content": "```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        return min([x for x,y in ops])*min([y for x,y in ops]) if ops else m*n\\n```\\n-------------------\\n***----- Taha Choura -----***\\n*taha.choura@outlook.com*",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        return min([x for x,y in ops])*min([y for x,y in ops]) if ops else m*n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436248,
                "title": "javascript-easy-to-understand-reduce",
                "content": "For this problem, the most straight forward solution is trying to redo all the operations to a matrix, and traversal the final matrix to get the result.\\nBut I haven\\'t write that code, since it cost too much both on time and space. Let\\'s try to find an easy solution.\\n\\nThe first key point is - where\\'s the max integer. To find the answer for this, let\\'s look back at each operation and try to find some commonalities.\\nDuring every operation, we increase all the areas at the top left of the point, which means for every operation, the `[0, 0]` will be increased at least.\\nSo, the `[0, 0]` should be one of the max integers.\\n\\nThen, our target is to find the numbers that have the same value as `[0, 0]`. This means the numbers should be increased during every operation also. When we get there, it\\'s easy to find out that our goal is to find the intersection of all operations.\\n\\nHere\\'s the easy-reading code:\\n\\n```js\\nconst maxCount = (m, n, ops) => {\\n  let minx = m;\\n  let miny = n;\\n\\n  for (const op of ops) {\\n    op[0] < minx && (minx = op[0]);\\n    op[1] < miny && (miny = op[1]);\\n  }\\n\\n  return minx * miny;\\n};\\n```\\n\\nAnd we could make it more concise via `reduce`:\\n\\n```js\\nconst maxCount = (m, n, ops) => ops.reduce((prev, op) => (\\n  m > op[0] && (m = op[0]),\\n  n > op[1] && (n = op[1]),\\n  m * n\\n), m * n);\\n```\\n\\nEven 1 line if you want:\\n\\n```js\\nconst maxCount = (m, n, ops) => ops.reduce((prev, [x, y]) => (m > x && (m = x), n > y && (n = y), m * n), m * n);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst maxCount = (m, n, ops) => {\\n  let minx = m;\\n  let miny = n;\\n\\n  for (const op of ops) {\\n    op[0] < minx && (minx = op[0]);\\n    op[1] < miny && (miny = op[1]);\\n  }\\n\\n  return minx * miny;\\n};\\n```\n```js\\nconst maxCount = (m, n, ops) => ops.reduce((prev, op) => (\\n  m > op[0] && (m = op[0]),\\n  n > op[1] && (n = op[1]),\\n  m * n\\n), m * n);\\n```\n```js\\nconst maxCount = (m, n, ops) => ops.reduce((prev, [x, y]) => (m > x && (m = x), n > y && (n = y), m * n), m * n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1411499,
                "title": "java-simple-solution-explained-0ms-faster-than-100",
                "content": "class Solution {\\n    \\n    // Get the count of max integers\\n    // We know the cell at M[0][0] will ALWAYS be incremented for every operation,\\n    // so we only need to keep track of how many cells are incremented on EVERY operation.\\n    public int maxCount(int m, int n, int[][] ops) {\\n        \\n        // Iterate for every operator in the array\\n        for (int[] op : ops) {\\n            \\n            // If the first dimension in the operation is less than m, then our\\n            // solution set shrinks. Set m equal to that dimension.\\n            if (op[0] < m) {\\n                m = op[0];\\n            }\\n            \\n            // Same goes for the second dimension. If it is less than n, our solution\\n            // set shrinks. Set n equal to that dimension.\\n            if (op[1] < n) {\\n                n = op[1];\\n            }\\n        }\\n        \\n        // Return the number of cells that were incremented every time, m*n\\n        return m * n;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    // Get the count of max integers\\n    // We know the cell at M[0][0] will ALWAYS be incremented for every operation,\\n    // so we only need to keep track of how many cells are incremented on EVERY operation.\\n    public int maxCount(int m, int n, int[][] ops) {\\n        \\n        // Iterate for every operator in the array\\n        for (int[] op : ops) {\\n            \\n            // If the first dimension in the operation is less than m, then our\\n            // solution set shrinks. Set m equal to that dimension.\\n            if (op[0] < m) {\\n                m = op[0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 103633,
                "title": "java-simple-solution",
                "content": "```\\npublic class Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int rowMin = m;\\n        int colMin = n;\\n        for (int[] pair : ops) {\\n            rowMin = Math.min(rowMin, pair[0]);\\n            colMin = Math.min(colMin, pair[1]);\\n        }\\n        return rowMin * colMin;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int rowMin = m;\\n        int colMin = n;\\n        for (int[] pair : ops) {\\n            rowMin = Math.min(rowMin, pair[0]);\\n            colMin = Math.min(colMin, pair[1]);\\n        }\\n        return rowMin * colMin;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306258,
                "title": "598-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nInitialize two variables min_y and min_x to m and n, respectively.\\n\\nIterate through each sublist in ops and for each sublist:\\n\\nUpdate min_y to be the minimum of its current value and the first element of the sublist.\\nUpdate min_x to be the minimum of its current value and the second element of the sublist.\\nReturn the product of min_x and min_y, which is the maximum value in the resulting matrix.\\n\\nEnd of the algorithm.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        min_y = m\\n        min_x = n\\n\\n        for y, x in ops:\\n            min_y = min(min_y, y)\\n            min_x = min(min_x, x)\\n\\n        return min_x * min_y\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        min_y = m\\n        min_x = n\\n\\n        for y, x in ops:\\n            min_y = min(min_y, y)\\n            min_x = min(min_x, x)\\n\\n        return min_x * min_y\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482436,
                "title": "go-simple",
                "content": "```\\nfunc maxCount(m int, n int, ops [][]int) int {\\n    if len(ops) == 0 {\\n        return m*n\\n    }\\n    \\n    minRow, minCol := 1<<63-1, 1<<63-1\\n    \\n    for _, op := range ops {\\n        if op[0] < minRow {\\n            minRow = op[0]\\n        }\\n        \\n        if op[1] < minCol {\\n            minCol = op[1]\\n        }\\n    }\\n    \\n    return minRow * minCol\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxCount(m int, n int, ops [][]int) int {\\n    if len(ops) == 0 {\\n        return m*n\\n    }\\n    \\n    minRow, minCol := 1<<63-1, 1<<63-1\\n    \\n    for _, op := range ops {\\n        if op[0] < minRow {\\n            minRow = op[0]\\n        }\\n        \\n        if op[1] < minCol {\\n            minCol = op[1]\\n        }\\n    }\\n    \\n    return minRow * minCol\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1435447,
                "title": "java-soln-0ms",
                "content": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int x=Integer.MAX_VALUE,y=x;\\n        \\n        if(ops.length==0)\\n            return m*n;\\n\\n        for(int[] ar:ops)\\n        {\\n                x=Math.min(x,ar[0]);\\n                y=Math.min(y,ar[1]);\\n        }\\n        \\n        return x*y;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int x=Integer.MAX_VALUE,y=x;\\n        \\n        if(ops.length==0)\\n            return m*n;\\n\\n        for(int[] ar:ops)\\n        {\\n                x=Math.min(x,ar[0]);\\n                y=Math.min(y,ar[1]);\\n        }\\n        \\n        return x*y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434921,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int minRow = m;\\n        int minCol = n;\\n        \\n        for(int[] op : ops){\\n            minRow = Math.min(minRow, op[0]);\\n            minCol = Math.min(minCol, op[1]);\\n        }\\n        \\n        return minRow*minCol;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int minRow = m;\\n        int minCol = n;\\n        \\n        for(int[] op : ops){\\n            minRow = Math.min(minRow, op[0]);\\n            minCol = Math.min(minCol, op[1]);\\n        }\\n        \\n        return minRow*minCol;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434776,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        array<int,2> a;\\n        a[0] = m;\\n        a[1] = n;\\n        for(auto it : ops){\\n            if(it[0] < a[0])a[0]=it[0];                \\n            if(it[1] < a[1])a[1]=it[1];                \\n        }\\n        int res = 0;\\n        res += (a[0]*a[1]);\\n        return res;\\n    }\\n};\\n```\\n**Questions/ Discussions are welcome.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        array<int,2> a;\\n        a[0] = m;\\n        a[1] = n;\\n        for(auto it : ops){\\n            if(it[0] < a[0])a[0]=it[0];                \\n            if(it[1] < a[1])a[1]=it[1];                \\n        }\\n        int res = 0;\\n        res += (a[0]*a[1]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 948322,
                "title": "c-easy-clear-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxCount(int m, int n, vector<vector<int>>& ops) {\\n\\n\\t\\t\\tif(ops.size() == 0) return m*n;\\n\\n\\t\\t\\tint x=INT_MAX,y=INT_MAX;\\n\\n\\t\\t\\tfor(int i=0;i<ops.size();i++){\\n\\t\\t\\t\\tx = min(x,ops[i][0]);\\n\\t\\t\\t\\ty = min(y,ops[i][1]);\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn x*y;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxCount(int m, int n, vector<vector<int>>& ops) {\\n\\n\\t\\t\\tif(ops.size() == 0) return m*n;\\n\\n\\t\\t\\tint x=INT_MAX,y=INT_MAX;\\n\\n\\t\\t\\tfor(int i=0;i<ops.size();i++){\\n\\t\\t\\t\\tx = min(x,ops[i][0]);\\n\\t\\t\\t\\ty = min(y,ops[i][1]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 374724,
                "title": "simon-s-note-python3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        r_min=m\\n        c_min=n\\n        for i in ops:\\n            if i[0]<r_min:\\n                r_min=i[0]\\n            if i[1]<c_min:\\n                c_min=i[1]\\n        return r_min*c_min\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        r_min=m\\n        c_min=n\\n        for i in ops:\\n            if i[0]<r_min:\\n                r_min=i[0]\\n            if i[1]<c_min:\\n                c_min=i[1]\\n        return r_min*c_min\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103604,
                "title": "java-explanation-overlap-area-e-a-s-y",
                "content": "Imagine drawing squares on top of a grid paper. These squares are the \"ops\" parameter.\\n\\nSince the squares always start on the top right-hand corner, we gain valuable information from this.\\n\\n1. There is a guarantee to be an overlap.\\n2. What ever that overlap is, the final answer is just the area of the overlap section.\\n\\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int height = m, width = n;\\n        \\n        for(int i = 0; i < ops.length; i++) {\\n            if(ops[i][0] < height) height = ops[i][0];\\n            if(ops[i][1] < width) width = ops[i][1];\\n        }\\n        \\n        return height * width;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int height = m, width = n;\\n        \\n        for(int i = 0; i < ops.length; i++) {\\n            if(ops[i][0] < height) height = ops[i][0];\\n            if(ops[i][1] < width) width = ops[i][1];\\n        }\\n        \\n        return height * width;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3626457,
                "title": "find-the-lowest-common-indexes",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int x = m, y = n;\\n        for (auto i: ops) {\\n            x = min(x, i[0]);\\n            y = min(y, i[1]);\\n        }\\n\\n        return x*y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int x = m, y = n;\\n        for (auto i: ops) {\\n            x = min(x, i[0]);\\n            y = min(y, i[1]);\\n        }\\n\\n        return x*y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3409230,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        for (auto op : ops){\\n            m = min(m, op[0]);\\n            n = min(n, op[1]);\\n        }\\n        return m * n;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        minRow = m\\n        minCol = n\\n        for x, y in ops:\\n            minRow = min(x, minRow)\\n            minCol = min(y, minCol)\\n        return minRow*minCol\\n```\\n\\n```Java []\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int k=ops.length;\\n        for (int i=0;i<k;i++)\\n        {\\n            int z=ops[i][0] ,x=ops[i][1];\\n            n=Math.min(n,x);\\n            m=Math.min(m,z);\\n        }\\n        return (m*n);\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        for (auto op : ops){\\n            m = min(m, op[0]);\\n            n = min(n, op[1]);\\n        }\\n        return m * n;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        minRow = m\\n        minCol = n\\n        for x, y in ops:\\n            minRow = min(x, minRow)\\n            minCol = min(y, minCol)\\n        return minRow*minCol\\n```\n```Java []\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int k=ops.length;\\n        for (int i=0;i<k;i++)\\n        {\\n            int z=ops[i][0] ,x=ops[i][1];\\n            n=Math.min(n,x);\\n            m=Math.min(m,z);\\n        }\\n        return (m*n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285909,
                "title": "c-solution-98-36-time-99-27-space-minimum-factor-calc-both-axes",
                "content": "# Complexity\\n- Time complexity: O(size ops)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint maxCount(int m, int n, vector<vector<int>>& ops);\\n};\\n/***************************************************************/\\nint Solution::maxCount(int m, int n, vector<vector<int>>& ops) {\\n    int minFactorLine = m, minFactorColumn = n, i, \\n    int size = ops.size();\\n    for (i = 0; i < size; ++i){\\n        /* less most common factor calculation  in both axes */\\n        if (ops[i][0] < minFactorLine) {\\n            minFactorLine = ops[i][0];\\n        }\\n        if (ops[i][1] < minFactorColumn) {\\n            minFactorColumn = ops[i][1];\\n        } \\n    }\\n    return (minFactorLine * minFactorColumn);    \\n}\\n/***************************************************************/\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint maxCount(int m, int n, vector<vector<int>>& ops);\\n};\\n/***************************************************************/\\nint Solution::maxCount(int m, int n, vector<vector<int>>& ops) {\\n    int minFactorLine = m, minFactorColumn = n, i, \\n    int size = ops.size();\\n    for (i = 0; i < size; ++i){\\n        /* less most common factor calculation  in both axes */\\n        if (ops[i][0] < minFactorLine) {\\n            minFactorLine = ops[i][0];\\n        }\\n        if (ops[i][1] < minFactorColumn) {\\n            minFactorColumn = ops[i][1];\\n        } \\n    }\\n    return (minFactorLine * minFactorColumn);    \\n}\\n/***************************************************************/\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3131393,
                "title": "java-o-n-beats-100-simple-plain-solution",
                "content": "# Intuition\\nI\\'m surprised how many people find this task difficult...\\n\\n# Approach\\nWe know that at each operation `[a, b]` all values in range `[0..a][0..b]` will be incremented. Hence our task is to find a range which will be incremented by all operations. To do that we simply find the **minimum row and column indexes** of all operations. \\nThink about it a little: this range is the **maximum intersection** of ranges of all operations. Thus number of elements is `min_row_index * min_column_index`.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        for (var op: ops) {\\n            if (op[0] < m) m = op[0];\\n            if (op[1] < n) n = op[1];\\n        }\\n        return m * n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        for (var op: ops) {\\n            if (op[0] < m) m = op[0];\\n            if (op[1] < n) n = op[1];\\n        }\\n        return m * n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108808,
                "title": "easiest-c-solution",
                "content": "# Approach\\nThe problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\n\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\n\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\n\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements.\\n\\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        if(ops.empty()) return m*n;\\n        int min1=INT_MAX;\\n        int min2=INT_MAX;\\n        for(vector<int> v:ops)\\n        {\\n            if(v[0]<min1) min1=v[0];\\n            if(v[1]<min2) min2=v[1];\\n        }\\n        return min1*min2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        if(ops.empty()) return m*n;\\n        int min1=INT_MAX;\\n        int min2=INT_MAX;\\n        for(vector<int> v:ops)\\n        {\\n            if(v[0]<min1) min1=v[0];\\n            if(v[1]<min2) min2=v[1];\\n        }\\n        return min1*min2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2609893,
                "title": "simple-8-line-python-answer-100ms-with-diagram",
                "content": "The diagram should provide a much clearer understanding of my solution. For every operation, we are only concerned with the **tightest** overlap between each operation. As such, we need to find what is the smallest area that overlaps with one another, as the smallest area of overlap would be added on the most, hence allowing us to derive the answer. This simplest way would be to find the smallest `row` and `col` that was acted on and multiple them together. The base case we have to consider would be if the `op` array is empty, then all the spaces in `M` would be 0, hence the answer would be the size of array `M`.\\n\\n![image](https://assets.leetcode.com/users/images/bcbc3b46-9526-4aef-8cf8-37774dcb4ce3_1663845563.242525.png)\\n\\n\\n```\\ndef maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n      if not ops:\\n        return m * n\\n      \\n      #finding minimum area of overlap\\n      min_row = sys.maxsize\\n      min_col = sys.maxsize\\n      \\n      for i in ops:\\n        min_row = min(min_row, i[0])\\n        min_col = min(min_col, i[1])\\n        \\n      return min_row * min_col\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n      if not ops:\\n        return m * n\\n      \\n      #finding minimum area of overlap\\n      min_row = sys.maxsize\\n      min_col = sys.maxsize\\n      \\n      for i in ops:\\n        min_row = min(min_row, i[0])\\n        min_col = min(min_col, i[1])\\n        \\n      return min_row * min_col\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1857227,
                "title": "range-addition-ii-solution-java",
                "content": "class Solution {\\n  public int maxCount(int m, int n, int[][] ops) {\\n    int minY = m;\\n    int minX = n;\\n\\n    for (int[] op : ops) {\\n      minY = Math.min(minY, op[0]);\\n      minX = Math.min(minX, op[1]);\\n    }\\n\\n    return minX * minY;\\n  }\\n}\\n",
                "solutionTags": [
                    "Array",
                    "Math"
                ],
                "code": "class Solution {\\n  public int maxCount(int m, int n, int[][] ops) {\\n    int minY = m;\\n    int minX = n;\\n\\n    for (int[] op : ops) {\\n      minY = Math.min(minY, op[0]);\\n      minX = Math.min(minX, op[1]);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1768434,
                "title": "cpp-simple-6-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int x = m;\\n        int y = n;\\n        \\n        for(auto&it: ops){\\n            x = min(x, it[0]);\\n            y = min(y, it[1]);\\n        }\\n        \\n        return x*y;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int x = m;\\n        int y = n;\\n        \\n        for(auto&it: ops){\\n            x = min(x, it[0]);\\n            y = min(y, it[1]);\\n        }\\n        \\n        return x*y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517283,
                "title": "fast-simple-4-line-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int x = m, y =n;\\n        for(int i=0;i<ops.size();i++)\\n        {\\n            x = min(x,ops[i][0]);\\n            y = min(y,ops[i][1]);\\n        }\\n        \\n        return (x*y);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int x = m, y =n;\\n        for(int i=0;i<ops.size();i++)\\n        {\\n            x = min(x,ops[i][0]);\\n            y = min(y,ops[i][1]);\\n        }\\n        \\n        return (x*y);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1452990,
                "title": "java-0-ms-faster-than-100-00",
                "content": "```\\n public int maxCount(int m, int n, int[][] ops) {\\n\\tint minRow = m, minCol = n;\\n\\tfor (int[] op : ops) {\\n\\t\\tif (op[0] < minRow) {\\n\\t\\t\\tminRow = op[0];\\n\\t\\t}\\n\\t\\tif (op[1] < minCol) {\\n\\t\\t\\tminCol = op[1];\\n\\t\\t}\\n\\t}\\n\\treturn minRow * minCol;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n public int maxCount(int m, int n, int[][] ops) {\\n\\tint minRow = m, minCol = n;\\n\\tfor (int[] op : ops) {\\n\\t\\tif (op[0] < minRow) {\\n\\t\\t\\tminRow = op[0];\\n\\t\\t}\\n\\t\\tif (op[1] < minCol) {\\n\\t\\t\\tminCol = op[1];\\n\\t\\t}\\n\\t}\\n\\treturn minRow * minCol;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1436000,
                "title": "c-one-liner",
                "content": "**Python**\\n```python\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        return min(ops, default=[m, n], key=lambda x: x[0])[0] * min(ops, default=[m, n], key=lambda x: x[1])[1]\\n```\\n**C++**\\nThis is just for fun. Sometimes one-liners are way larger than ...\\n```cpp\\nint maxCount(int m, int n, vector<vector<int>>& o) {\\n    return min(m, o.empty() ? INT_MAX : \\n            (*min_element(begin(o), end(o), [](const auto& a, const auto& b){ return a[0] < b[0]; }))[0]) *\\n        min(n, o.empty() ? INT_MAX : \\n            (*min_element(begin(o), end(o), [](const auto& a, const auto& b){ return a[1] < b[1]; }))[1]);\\n}\\n```\\n... a \"regular\" code.\\n```cpp\\nint maxCount(int m, int n, vector<vector<int>>& ops) {\\n    for (auto &op : ops)\\n        m = min(m, op[0]), n = min(n, op[1]);\\n    return m * n;\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        return min(ops, default=[m, n], key=lambda x: x[0])[0] * min(ops, default=[m, n], key=lambda x: x[1])[1]\\n```\n```cpp\\nint maxCount(int m, int n, vector<vector<int>>& o) {\\n    return min(m, o.empty() ? INT_MAX : \\n            (*min_element(begin(o), end(o), [](const auto& a, const auto& b){ return a[0] < b[0]; }))[0]) *\\n        min(n, o.empty() ? INT_MAX : \\n            (*min_element(begin(o), end(o), [](const auto& a, const auto& b){ return a[1] < b[1]; }))[1]);\\n}\\n```\n```cpp\\nint maxCount(int m, int n, vector<vector<int>>& ops) {\\n    for (auto &op : ops)\\n        m = min(m, op[0]), n = min(n, op[1]);\\n    return m * n;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435534,
                "title": "java-range-addition-ii-compact-solution",
                "content": "Your answer is going to be the area with the most overlapping ranges in the collection. Since all overlapping ranges begin in the same corner of the matrix, another way to think about it is the answer will be the product of the smallest m and n values in the collection since the area created by those values will overlap the most with every other area. So, you can just iterate through the pairs to find the smallest m and n values given and return their product.\\n\\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        for(int[] vals : ops) {\\n            m = vals[0] < m ? vals[0] : m;\\n            n = vals[1] < n ? vals[1] : n;\\n        }\\n        return m * n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        for(int[] vals : ops) {\\n            m = vals[0] < m ? vals[0] : m;\\n            n = vals[1] < n ? vals[1] : n;\\n        }\\n        return m * n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435235,
                "title": "scala-1-line-solution",
                "content": "```\\nobject Solution {\\n    def maxCount(m: Int, n: Int, ops: Array[Array[Int]]): Int = {\\n        ops.foldLeft(Array(m, n))((op1, op2) => Array(Math.min(op1(0), op2(0)), Math.min(op1(1), op2(1)))).product\\n    }\\n}\\n```\\nTime complexity: O(N)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def maxCount(m: Int, n: Int, ops: Array[Array[Int]]): Int = {\\n        ops.foldLeft(Array(m, n))((op1, op2) => Array(Math.min(op1(0), op2(0)), Math.min(op1(1), op2(1)))).product\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1435076,
                "title": "python3",
                "content": "```\\nfrom constraints we can see its too big ,so we can\\'t make list of list,it will give memory limit error.\\nfrom observation we can see that for every row,col in ops we have to add till row,col.\\nso if we find minimum of row,col from ops,only that part (row*col) will have maximum no of element,\\nsince its minimum,so for every row,col in ops this part will get increased by 1.\\n\\ndef maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        if not ops:return m*n\\n        x,y=m,n\\n        for x_,y_ in ops:\\n            x=min(x,x_)\\n            y=min(y,y_)\\n        return x*y\\n",
                "solutionTags": [],
                "code": "```\\nfrom constraints we can see its too big ,so we can\\'t make list of list,it will give memory limit error.\\nfrom observation we can see that for every row,col in ops we have to add till row,col.\\nso if we find minimum of row,col from ops,only that part (row*col) will have maximum no of element,\\nsince its minimum,so for every row,col in ops this part will get increased by 1.\\n\\ndef maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        if not ops:return m*n\\n        x,y=m,n\\n        for x_,y_ in ops:\\n            x=min(x,x_)\\n            y=min(y,y_)\\n        return x*y\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1434644,
                "title": "c-python-java-same-solution",
                "content": "**Python :**\\n```python\\ndef maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n\\tm_m= m\\n\\tm_n = n\\n\\tfor op in ops:\\n\\t\\tm_m = min(m_m,op[0])\\n\\t\\tm_n = min(m_n,op[1])\\n\\treturn m_m * m_n\\n```\\n\\n**C++ :**\\n\\n```c++\\nint maxCount(int m, int n, vector<vector<int>>& ops) {\\n\\tint m_m= m;\\n\\tint m_n = n;\\n\\tfor (auto op :ops){\\n\\t\\tm_m = min(m_m,op[0]);\\n\\t\\tm_n = min(m_n,op[1]);\\n\\t}\\n\\treturn m_m * m_n;\\n\\t}\\n```\\n\\n\\t\\n**Java :**\\n```java\\npublic int maxCount(int m, int n, int[][] ops) {\\n        int m_m= m;\\n        int m_n = n;\\n        for (int[] op : ops){\\n            m_m = Math.min(m_m,op[0]);\\n            m_n = Math.min(m_n,op[1]);\\n        }\\n        return m_m * m_n;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```python\\ndef maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n\\tm_m= m\\n\\tm_n = n\\n\\tfor op in ops:\\n\\t\\tm_m = min(m_m,op[0])\\n\\t\\tm_n = min(m_n,op[1])\\n\\treturn m_m * m_n\\n```\n```c++\\nint maxCount(int m, int n, vector<vector<int>>& ops) {\\n\\tint m_m= m;\\n\\tint m_n = n;\\n\\tfor (auto op :ops){\\n\\t\\tm_m = min(m_m,op[0]);\\n\\t\\tm_n = min(m_n,op[1]);\\n\\t}\\n\\treturn m_m * m_n;\\n\\t}\\n```\n```java\\npublic int maxCount(int m, int n, int[][] ops) {\\n        int m_m= m;\\n        int m_n = n;\\n        for (int[] op : ops){\\n            m_m = Math.min(m_m,op[0]);\\n            m_n = Math.min(m_n,op[1]);\\n        }\\n        return m_m * m_n;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1341038,
                "title": "c-brute-force-optimal",
                "content": "```\\n//Approach-1 (Brute Force)\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int maxElem = ops.size();\\n        if(maxElem  == 0)\\n            return m*n;\\n        vector<vector<int>> t(m, vector<int>(n));\\n        int count = 0;\\n        for(vector<int> &vec : ops) {\\n            \\n            for(int i = 0; i<vec[0]; i++) {\\n                for(int j = 0; j<vec[1]; j++) {\\n                    t[i][j]++;\\n                    if(t[i][j] == maxElem)\\n                        count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n\\n```\\n//Approach-2 (Optimal : Just Find the lower most right coordinate\\n//of intersection of all queries)\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int minX = m;\\n        int minY = n;\\n        \\n        for(vector<int> &vec : ops) {\\n            minX = min(minX, vec[0]);\\n            minY = min(minY, vec[1]);\\n        }\\n        \\n        return minX*minY;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Brute Force)\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int maxElem = ops.size();\\n        if(maxElem  == 0)\\n            return m*n;\\n        vector<vector<int>> t(m, vector<int>(n));\\n        int count = 0;\\n        for(vector<int> &vec : ops) {\\n            \\n            for(int i = 0; i<vec[0]; i++) {\\n                for(int j = 0; j<vec[1]; j++) {\\n                    t[i][j]++;\\n                    if(t[i][j] == maxElem)\\n                        count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\n//Approach-2 (Optimal : Just Find the lower most right coordinate\\n//of intersection of all queries)\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int minX = m;\\n        int minY = n;\\n        \\n        for(vector<int> &vec : ops) {\\n            minX = min(minX, vec[0]);\\n            minY = min(minY, vec[1]);\\n        }\\n        \\n        return minX*minY;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 769995,
                "title": "java-count-min-cols-and-rows",
                "content": "```\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int c = n, r = m;\\n        for (int[] op : ops) {\\n            c = Math.min(c, op[1]);\\n            r = Math.min(r, op[0]);\\n        }\\n        return r * c;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int c = n, r = m;\\n        for (int[] op : ops) {\\n            c = Math.min(c, op[1]);\\n            r = Math.min(r, op[0]);\\n        }\\n        return r * c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 711300,
                "title": "c-98-13-faster-easy-to-understand",
                "content": "***Runtime: 16 ms, faster than 98.13% of C++ online submissions for Range Addition II.\\nMemory Usage: 11.3 MB, less than 57.86% of C++ online submissions for Range Addition II.***\\n\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int opxMin = m;\\n        int opyMin = n;\\n        for(auto& op:ops){\\n            opxMin = min(op[0],opxMin);\\n            opyMin = min(op[1],opyMin);\\n        }\\n        return opxMin*opyMin;\\n    }\\n};\\n```\\n\\n**Feel free to comment your doubts!!!\\nUpvote the solution, if you like.**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int opxMin = m;\\n        int opyMin = n;\\n        for(auto& op:ops){\\n            opxMin = min(op[0],opxMin);\\n            opyMin = min(op[1],opyMin);\\n        }\\n        return opxMin*opyMin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 585803,
                "title": "rust-simple-solution",
                "content": "```\\nimpl Solution {\\n    pub fn max_count(m: i32, n: i32, ops: Vec<Vec<i32>>) -> i32 {\\n        if ops.is_empty() {\\n            return m * n;\\n        }\\n        let mut m_max = i32::max_value();\\n        let mut n_max = i32::max_value();\\n        for op in ops {\\n            m_max = std::cmp::min(m_max, op[0]);\\n            n_max = std::cmp::min(n_max, op[1]);\\n        }\\n        return m_max * n_max;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_count(m: i32, n: i32, ops: Vec<Vec<i32>>) -> i32 {\\n        if ops.is_empty() {\\n            return m * n;\\n        }\\n        let mut m_max = i32::max_value();\\n        let mut n_max = i32::max_value();\\n        for op in ops {\\n            m_max = std::cmp::min(m_max, op[0]);\\n            n_max = std::cmp::min(n_max, op[1]);\\n        }\\n        return m_max * n_max;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 353307,
                "title": "python-3-solution-with-steps-thought-process",
                "content": "Approach 1: using numpy and brute force \\nnumpy. zeros runs out of memory.\\n\\n```\\n    def maxCount(self, m, n, ops):\\n        if len(ops) == 0:\\n            return \\n        grid = np.zeros((m,n), dtype = int)\\n        def additbaby(grid,s):\\n            for x in range(s[0]):\\n                for y in range(s[1]):\\n                    grid[x][y] += 1\\n                    \\n            if len(ops) != 0:\\n                additbaby(grid,ops.pop())\\n        additbaby(grid, ops.pop())\\n        return (grid == np.amax(grid)).sum()\\n```\\n\\nSolution 2:\\nbrute force without numpy (already know it would give TLE)\\n```\\nimport numpy as np\\nclass Solution(object):\\n    def maxCount(self, m, n, ops):\\n        if len(ops) == 0:\\n            return m*n\\n        grid = [[0 for i in range(n)] for j in range(m)]\\n        \\n        def additbaby(grid,s):\\n            for x in range(s[0]):\\n                for y in range(s[1]):\\n                    grid[x][y] += 1\\n                    \\n            if len(ops) != 0:\\n                additbaby(grid,ops.pop())\\n        \\n        additbaby(grid, ops.pop())\\n        return (grid == np.amax(grid)).sum()\\n            \\n```\\n\\nSolution3: took a step back and focused on what is needed? we just need the overlapped area. There you go my pythonic one liner!\\n\\n```\\nreturn m*n if len(ops) == 0 else min(num[0] for num in ops) * min(num[1] for num in ops)\\n```",
                "solutionTags": [],
                "code": "```\\n    def maxCount(self, m, n, ops):\\n        if len(ops) == 0:\\n            return \\n        grid = np.zeros((m,n), dtype = int)\\n        def additbaby(grid,s):\\n            for x in range(s[0]):\\n                for y in range(s[1]):\\n                    grid[x][y] += 1\\n                    \\n            if len(ops) != 0:\\n                additbaby(grid,ops.pop())\\n        additbaby(grid, ops.pop())\\n        return (grid == np.amax(grid)).sum()\\n```\n```\\nimport numpy as np\\nclass Solution(object):\\n    def maxCount(self, m, n, ops):\\n        if len(ops) == 0:\\n            return m*n\\n        grid = [[0 for i in range(n)] for j in range(m)]\\n        \\n        def additbaby(grid,s):\\n            for x in range(s[0]):\\n                for y in range(s[1]):\\n                    grid[x][y] += 1\\n                    \\n            if len(ops) != 0:\\n                additbaby(grid,ops.pop())\\n        \\n        additbaby(grid, ops.pop())\\n        return (grid == np.amax(grid)).sum()\\n            \\n```\n```\\nreturn m*n if len(ops) == 0 else min(num[0] for num in ops) * min(num[1] for num in ops)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319652,
                "title": "easiest-java-solution-4-liner",
                "content": "```\\npublic int maxCount(int m, int n, int[][] ops) {\\n    for (int[] op : ops) {\\n        if (op[0] < m) m = op[0];\\n        if (op[1] < n) n = op[1];\\n    }\\n    return m * n;\\n}",
                "solutionTags": [],
                "code": "```\\npublic int maxCount(int m, int n, int[][] ops) {\\n    for (int[] op : ops) {\\n        if (op[0] < m) m = op[0];\\n        if (op[1] < n) n = op[1];\\n    }\\n    return m * n;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 165261,
                "title": "easy-python-beats-100-with-explaination",
                "content": "Because it is asking us to find the biggest number in the 2D array and because the operation will alway begin at position (0,0) to position (i,j) this biggest number must be operated in every single operation.  So we just need to find the minimun number of [x,y] to know which positions are operated on every single operation.\\n\\n```\\nclass Solution(object):\\n    def maxCount(self, m, n, ops):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type ops: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not ops:\\n            return n*m\\n        minx = min([x[0] for x in ops])\\n        miny = min([y[1] for y in ops])\\n        \\n        return minx*miny\\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxCount(self, m, n, ops):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type ops: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if not ops:\\n            return n*m\\n        minx = min([x[0] for x in ops])\\n        miny = min([y[1] for y in ops])\\n        \\n        return minx*miny\\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 146865,
                "title": "easy-python",
                "content": "the minimum of the row and column of ops determines the maxCount\\n```\\nclass Solution:\\n    def maxCount(self, m, n, ops):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type ops: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        try:\\n            return min(list(zip(*ops))[0])*min(list(zip(*ops))[1]) \\n        except:\\n            return m*n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxCount(self, m, n, ops):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type ops: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        try:\\n            return min(list(zip(*ops))[0])*min(list(zip(*ops))[1]) \\n        except:\\n            return m*n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103621,
                "title": "java-easy-to-understand",
                "content": "this is my code:\\n```\\npublic class Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        for(int i=0;i<ops.length;i++){\\n            if(ops[i][0]<m) m=ops[i][0];\\n            if(ops[i][1]<n) n=ops[i][1];\\n        }\\n        return m*n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        for(int i=0;i<ops.length;i++){\\n            if(ops[i][0]<m) m=ops[i][0];\\n            if(ops[i][1]<n) n=ops[i][1];\\n        }\\n        return m*n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103620,
                "title": "c-java-clean-code",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        for (auto op : ops) {\\n//          if (op[0] == 0 || op[1] == 0)  continue;\\n            m = min(op[0], m);\\n            n = min(op[1], n);\\n        }\\n        return m * n;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\npublic class Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        for (int[] op : ops) {\\n            m = Math.min(op[0], m);\\n            n = Math.min(op[1], n);\\n        }\\n        return m * n;        \\n    }\\n}\\n```\\n\\nBecause there is no test case for operation contains 0. Without the sanity check it still pass. In fact the test implementation behind is not checking this and returns 0 for customized test case like:\\n```\\n3\\n3\\n[[2,2],[3,3], [3,0]]\\n```\\n\\n**Update**\\nThanks @sqfan pointing out this check is not needed:\\n```\\n//          if (op[0] == 0 || op[1] == 0)  continue;\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        for (auto op : ops) {\\n//          if (op[0] == 0 || op[1] == 0)  continue;\\n            m = min(op[0], m);\\n            n = min(op[1], n);\\n        }\\n        return m * n;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        for (int[] op : ops) {\\n            m = Math.min(op[0], m);\\n            n = Math.min(op[1], n);\\n        }\\n        return m * n;        \\n    }\\n}\\n```\n```\\n3\\n3\\n[[2,2],[3,3], [3,0]]\\n```\n```\\n//          if (op[0] == 0 || op[1] == 0)  continue;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920273,
                "title": "java-concise",
                "content": "# Intuition\\nSame intuition. Just shorter.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        for(int[] o:ops) {\\n            m = Math.min(m,o[0]);\\n            n = Math.min(n,o[1]);\\n        }\\n        return m*n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        for(int[] o:ops) {\\n            m = Math.min(m,o[0]);\\n            n = Math.min(n,o[1]);\\n        }\\n        return m*n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3893230,
                "title": "linear-sollution-o-n-beats-100-runtime-full-explanation",
                "content": "# Performance\\n![image.png](https://assets.leetcode.com/users/images/0b829b31-b78e-4f88-8401-1564de118258_1691728670.4208648.png)\\n\\n# Approach\\n1. For each pair `(i, j)` in ops, the code updates the values of `m` and `n` as follows:\\n\\n- `m` is updated to the minimum of `i` and the current value of `m`.\\n- `n` is updated to the minimum of `j` and the current value of `n`.\\nEssentially, these updates are shrinking the effective size of the matrix based on the operations performed. This is because for each operation `[ai, bi]`, the range of rows affected is `[0, ai)` and the range of columns affected is `[0, bi)`.\\n\\n2. After processing all operations, the method returns the result of multiplying `m` and `n`, which represents the total number of elements that have been incremented in the matrix.\\n\\nThe approach is to keep track of the smallest dimensions of the matrix that were affected by the operations and then compute the product of those dimensions to get the count of maximum integers.\\n\\n\\n\\n# Complexity\\n- ### Time Complexity:\\nThe time complexity of the code primarily depends on the number of operations in the `ops` list. Let\\'s denote the length of the `ops` list as `k`.\\n\\n1. The loop that iterates over each pair `(i, j)` in the ops list takes $O(k)$ time, as it goes through each operation once.\\n\\n2. Inside the loop, the operations `min(i, m)` and `min(j, n)` take constant time, $O(1)$, because they involve comparing two values.\\n\\nOverall, the `time complexity` of the code is $O(k)$, where `k` is the number of operations in the `ops` list.\\n\\n- ### Space Complexity:\\nThe `space complexity` of the code refers to the additional memory used by the algorithm as a function of the input size. In this code, the space complexity is primarily determined by the variables used for computation.\\n\\n1. The variables `m` and `n` are used to keep track of the smallest dimensions affected by the operations. They use constant space, $O(1)$, regardless of the input size.\\n\\n2. The input arguments `m`, `n`, and `ops` are provided to the function and do not grow with the input size. They contribute to the overall space complexity as well.\\n\\nHence, the `space complexity` of the code is $O(1)$, indicating that the amount of extra memory used by the algorithm remains constant regardless of the input size.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxCount(self, m, n, ops):\\n        for i,j in ops:\\n            m,n = min(i,m), min(j,n)\\n        return m*n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxCount(self, m, n, ops):\\n        for i,j in ops:\\n            m,n = min(i,m), min(j,n)\\n        return m*n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3677393,
                "title": "easy-c-solution-beginner-friendly-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int min_row = m;\\n        int min_col = n;\\n        for (int i=0; i<ops.size(); i++){\\n            if (ops[i][0]<min_row) min_row=ops[i][0];\\n            if (ops[i][1]<min_col) min_col=ops[i][1];\\n        }        \\n        return min_row*min_col;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int min_row = m;\\n        int min_col = n;\\n        for (int i=0; i<ops.size(); i++){\\n            if (ops[i][0]<min_row) min_row=ops[i][0];\\n            if (ops[i][1]<min_col) min_col=ops[i][1];\\n        }        \\n        return min_row*min_col;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3337466,
                "title": "javascript-one-liner-explained",
                "content": "**Approach**: since every iteration will add 1 to all elements in the submatrix that goes from [1,1] to [x,y] (using 1-index), we want to know the minimum x and y in array *ops*, because its area will have the greatest numbers (in particular, with value k, being k the number of iterations/length of *ops*).\\n\\nFirst reduce searches for those minimum values.\\nSecond reduce just multipiles them.\\n\\nIf there\\'s no values in array *ops* then one should return the size of the whole matrix, so that\\'s why the first reduce has [m,n] as its initial value.\\n\\n# Code\\n```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} ops\\n * @return {number}\\n */\\nvar maxCount = function(m, n, ops) {\\n    return ops.reduce((r,x) => [Math.min(x[0],r[0]), Math.min(x[1],r[1])], [m,n]).reduce((r,x) => r*x, 1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} ops\\n * @return {number}\\n */\\nvar maxCount = function(m, n, ops) {\\n    return ops.reduce((r,x) => [Math.min(x[0],r[0]), Math.min(x[1],r[1])], [m,n]).reduce((r,x) => r*x, 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3223083,
                "title": "javascript-69ms-click-heeree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} ops\\n * @return {number}\\n */\\nvar maxCount = function(m, n, ops) {\\n    if(ops.length === 0) return m*n;\\n    let min = [m,n];\\n    for(let [x,y] of ops) {\\n        min = [Math.min(x, min[0]), Math.min(y, min[1])];\\n    }\\n    return min[0]*min[1];\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} ops\\n * @return {number}\\n */\\nvar maxCount = function(m, n, ops) {\\n    if(ops.length === 0) return m*n;\\n    let min = [m,n];\\n    for(let [x,y] of ops) {\\n        min = [Math.min(x, min[0]), Math.min(y, min[1])];\\n    }\\n    return min[0]*min[1];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3215154,
                "title": "range-addition-ii-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int i, j, k, l, count=m*n;\\n\\n        if(ops.size()>0)\\n        {\\n            k = ops[0][0];\\n            l = ops[0][1];\\n            for(i=0 ; i<ops.size() ; i++)\\n            {\\n                for(j=0 ; j<ops[i][0] ; j++)\\n                {\\n                    if(ops[i][0]<k)\\n                    {\\n                        k = ops[i][0];\\n                    }\\n                }\\n                for(j=0 ; j<ops[i][1] ; j++)\\n                {\\n                    if(ops[i][1]<l)\\n                    {\\n                        l = ops[i][1];\\n                    }\\n                }\\n            }\\n            count = k*l;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int i, j, k, l, count=m*n;\\n\\n        if(ops.size()>0)\\n        {\\n            k = ops[0][0];\\n            l = ops[0][1];\\n            for(i=0 ; i<ops.size() ; i++)\\n            {\\n                for(j=0 ; j<ops[i][0] ; j++)\\n                {\\n                    if(ops[i][0]<k)\\n                    {\\n                        k = ops[i][0];\\n                    }\\n                }\\n                for(j=0 ; j<ops[i][1] ; j++)\\n                {\\n                    if(ops[i][1]<l)\\n                    {\\n                        l = ops[i][1];\\n                    }\\n                }\\n            }\\n            count = k*l;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797749,
                "title": "range-addition-ii-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nafter reading the question it is clearly observed  that the product of the smallest operation in ops[m][n] (where n<2;m=length of ops array) array will give the number of elments with the highest  value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nafter more refining the thought and taking some demo example i came to a conclusion that the number of elements have hightest value will be the product of the smallest number  from the first and second  column. so make a loop to trverse through array (ops) and extract the smallest from each column by using min max function.  \\n\\n# Complexity\\n- Time complexity:   O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int k=ops.length;\\n        //int minc=k,minr=0;\\n        for (int i=0;i<k;i++)\\n        {\\n            int z=ops[i][0] ,x=ops[i][1];\\n            n=Math.min(n,x);\\n            m=Math.min(m,z);\\n        }\\n        return (m*n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int k=ops.length;\\n        //int minc=k,minr=0;\\n        for (int i=0;i<k;i++)\\n        {\\n            int z=ops[i][0] ,x=ops[i][1];\\n            n=Math.min(n,x);\\n            m=Math.min(m,z);\\n        }\\n        return (m*n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569124,
                "title": "java-linear-solution",
                "content": "```\\npublic int maxCount(int m, int n, int[][] ops) {\\n\\tfor(int i = 0; i < ops.length; i++) {\\n\\t\\tm = Math.min(m, ops[i][0]);\\n\\t\\tn = Math.min(n, ops[i][1]);\\n\\t}\\n\\treturn m * n;\\n}",
                "solutionTags": [],
                "code": "```\\npublic int maxCount(int m, int n, int[][] ops) {\\n\\tfor(int i = 0; i < ops.length; i++) {\\n\\t\\tm = Math.min(m, ops[i][0]);\\n\\t\\tn = Math.min(n, ops[i][1]);\\n\\t}\\n\\treturn m * n;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2562412,
                "title": "my-solution-java",
                "content": "class Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int minM = m;\\n        int minN = n;\\n        for(int i = 0; i< ops.length; i++){\\n            if(ops[i][0]!=0&&ops[i][0]<minM){\\n                minM = ops[i][0];\\n            }\\n            if(ops[i][1]!=0&&ops[i][1]<minN){\\n                minN = ops[i][1];\\n            }\\n        }\\n        return minM*minN;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int minM = m;\\n        int minN = n;\\n        for(int i = 0; i< ops.length; i++){\\n            if(ops[i][0]!=0&&ops[i][0]<minM){\\n                minM = ops[i][0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2537678,
                "title": "js-very-easy-solution-with-o-ops-length-100",
                "content": "```\\nvar maxCount = function(m, n, ops) {\\n    if (!ops.length) return m*n;\\n    \\n    let currentX = ops[0][0];\\n    let currentY = ops[0][1];\\n\\n    for (let i = 1; i < ops.length; i++) {\\n        if ((ops[i][0] >= currentX && ops[i][1] < currentY) || (ops[i][1] < currentY && ops[i][0] >= currentX)) {\\n            currentY = ops[i][1];\\n        }\\n        \\n        if ((ops[i][0] < currentX && ops[i][1] >= currentY) || (ops[i][1] >= currentY && ops[i][0] < currentX)) {\\n            currentX = ops[i][0];\\n        }\\n        \\n        if (ops[i][1] < currentY && ops[i][0] < currentX) {\\n            currentY = ops[i][1];\\n            currentX = ops[i][0];\\n        }\\n        \\n    }\\n    \\n    return currentX * currentY;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxCount = function(m, n, ops) {\\n    if (!ops.length) return m*n;\\n    \\n    let currentX = ops[0][0];\\n    let currentY = ops[0][1];\\n\\n    for (let i = 1; i < ops.length; i++) {\\n        if ((ops[i][0] >= currentX && ops[i][1] < currentY) || (ops[i][1] < currentY && ops[i][0] >= currentX)) {\\n            currentY = ops[i][1];\\n        }\\n        \\n        if ((ops[i][0] < currentX && ops[i][1] >= currentY) || (ops[i][1] >= currentY && ops[i][0] < currentX)) {\\n            currentX = ops[i][0];\\n        }\\n        \\n        if (ops[i][1] < currentY && ops[i][0] < currentX) {\\n            currentY = ops[i][1];\\n            currentX = ops[i][0];\\n        }\\n        \\n    }\\n    \\n    return currentX * currentY;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2384660,
                "title": "c-simplest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n     \\n        int mn_i = m, mn_j = n;\\n        for(auto &i : ops)\\n            mn_i = min(mn_i, i[0]), mn_j = min(mn_j, i[1]);\\n        \\n        return mn_i * mn_j;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n     \\n        int mn_i = m, mn_j = n;\\n        for(auto &i : ops)\\n            mn_i = min(mn_i, i[0]), mn_j = min(mn_j, i[1]);\\n        \\n        return mn_i * mn_j;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347818,
                "title": "o-n-100-t-c",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n\\t\\tint row = m;\\n        int col = n;\\n        for (int i = 0; i < ops.length; i++) {\\n            row = Math.min(row, ops[i][0]);\\n            col = Math.min(col, ops[i][1]);\\n        }\\n\\n        return row * col;",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2288221,
                "title": "python-easy-understand",
                "content": "```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        for op in ops:\\n            m = min(m, op[0])\\n            n = min(n, op[1])\\n        return m*n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        for op in ops:\\n            m = min(m, op[0])\\n            n = min(n, op[1])\\n        return m*n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2281026,
                "title": "c-clean-short-four-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        for(auto it:ops){\\n            m = min(m,it[0]);\\n            n = min(n,it[1]);\\n        }\\n        return m*n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        for(auto it:ops){\\n            m = min(m,it[0]);\\n            n = min(n,it[1]);\\n        }\\n        return m*n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2251406,
                "title": "daily-leetcode-python-challenge-day-11-july-7-2022",
                "content": "```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        if not ops:\\n            return m*n\\n        else:\\n            x,y = zip(*ops)\\n            return min(x) * min(y)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        if not ops:\\n            return m*n\\n        else:\\n            x,y = zip(*ops)\\n            return min(x) * min(y)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114088,
                "title": "simple-solution-by-finding-minimum-in-row-and-column",
                "content": "Here is the code:\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n      int x=m;\\n        int y=n;\\n      for(int i=0;i<ops.size();i++)\\n      {\\n          x=min(x,ops[i][0]);\\n          y=min(y,ops[i][1]);\\n      }\\n    return x*y;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n      int x=m;\\n        int y=n;\\n      for(int i=0;i<ops.size();i++)\\n      {\\n          x=min(x,ops[i][0]);\\n          y=min(y,ops[i][1]);\\n      }\\n    return x*y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998410,
                "title": "easy-java-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int X = m,Y = n;\\n        int ele = m*n;\\n        int sz = ops.length;\\n        for(int k=0;k<sz;k++){\\n            int x = ops[k][0];\\n            int y = ops[k][1];\\n            X = Math.min(X,x);\\n            Y = Math.min(Y,y);\\n            ele = Math.min(ele,X*Y);\\n        }\\n        return ele;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int X = m,Y = n;\\n        int ele = m*n;\\n        int sz = ops.length;\\n        for(int k=0;k<sz;k++){\\n            int x = ops[k][0];\\n            int y = ops[k][1];\\n            X = Math.min(X,x);\\n            Y = Math.min(Y,y);\\n            ele = Math.min(ele,X*Y);\\n        }\\n        return ele;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924685,
                "title": "java-easy-to-understand-solution",
                "content": "Get the size of the smallest top left rectangle\\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int minRow = m;\\n        int minColumn = n;\\n        \\n        for(int[] op : ops)\\n        {\\n            minRow = Math.min(minRow, op[0]);\\n            minColumn = Math.min(minColumn, op[1]);\\n        }\\n        \\n        return minRow * minColumn;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int minRow = m;\\n        int minColumn = n;\\n        \\n        for(int[] op : ops)\\n        {\\n            minRow = Math.min(minRow, op[0]);\\n            minColumn = Math.min(minColumn, op[1]);\\n        }\\n        \\n        return minRow * minColumn;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897512,
                "title": "java-o-n-time-n-is-the-length-of-operations-array-o-1-space",
                "content": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if (ops == null || ops.length == 0) {\\n            return m * n;\\n        }\\n        \\n        int minRow = Integer.MAX_VALUE;\\n        int minCol = Integer.MAX_VALUE;\\n        for (int[] op : ops) {\\n            int row = op[0];\\n            if (row < minRow) {\\n                minRow = row;\\n            }\\n            int col = op[1];\\n            if (col < minCol) {\\n                minCol = col;\\n            }            \\n        }\\n        \\n        return minRow * minCol;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if (ops == null || ops.length == 0) {\\n            return m * n;\\n        }\\n        \\n        int minRow = Integer.MAX_VALUE;\\n        int minCol = Integer.MAX_VALUE;\\n        for (int[] op : ops) {\\n            int row = op[0];\\n            if (row < minRow) {\\n                minRow = row;\\n            }\\n            int col = op[1];\\n            if (col < minCol) {\\n                minCol = col;\\n            }            \\n        }\\n        \\n        return minRow * minCol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897102,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        for i in range(len(ops)):\\n            m=min(m,ops[i][0])\\n            n=min(n,ops[i][1])\\n        return m*n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        for i in range(len(ops)):\\n            m=min(m,ops[i][0])\\n            n=min(n,ops[i][1])\\n        return m*n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891008,
                "title": "java-clean",
                "content": "```\\npublic int maxCount(int m, int n, int[][] ops) {\\n        int minRow = m;\\n        int minColumn = n;\\n\\n        for (int[] op : ops) {\\n            if (op[0] < minRow) minRow = op[0];\\n            if (op[1] < minColumn) minColumn = op[1];\\n        }\\n\\n        return minRow * minColumn;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxCount(int m, int n, int[][] ops) {\\n        int minRow = m;\\n        int minColumn = n;\\n\\n        for (int[] op : ops) {\\n            if (op[0] < minRow) minRow = op[0];\\n            if (op[1] < minColumn) minColumn = op[1];\\n        }\\n\\n        return minRow * minColumn;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1792635,
                "title": "java-simple-explained",
                "content": "**Idea:** Find the intersection of all ops rectangles and return its area\\n>**T/S:** O(t)/O(1), where t = size(ops)\\n```\\npublic int maxCount(int m, int n, int[][] ops) {\\n\\tfor (var op : ops) {\\n\\t\\tm = Math.min(m, op[0]);\\n\\t\\tn = Math.min(n, op[1]);\\n\\t}\\n\\treturn m * n;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int maxCount(int m, int n, int[][] ops) {\\n\\tfor (var op : ops) {\\n\\t\\tm = Math.min(m, op[0]);\\n\\t\\tn = Math.min(n, op[1]);\\n\\t}\\n\\treturn m * n;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1790725,
                "title": "python-easy-o-n-time-and-o-1-space-solution",
                "content": "It\\'s just an easy question, don\\'t try to overthink it. Initially, I was trying to think of so many different complex ways to solve this problem which I later found was completely unnecessary when I looked at this question after taking a small break. It\\'s really simple, just find the minimum value of row and column from the ops array.\\n\\n```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        r, c = m, n\\n        for cell in ops:\\n            r, c = min(r, cell[0]), min(c, cell[1])\\n        return r*c\\n```\\n\\nYes, I know you can do it as a one liner but I think this looks better.\\n\\nThe one liner, in case-\\n```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        return min(ops, key=lambda x: x[0])[0] * min(ops, key=lambda y: y[1])[1] if ops else m*n\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        r, c = m, n\\n        for cell in ops:\\n            r, c = min(r, cell[0]), min(c, cell[1])\\n        return r*c\\n```\n```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        return min(ops, key=lambda x: x[0])[0] * min(ops, key=lambda y: y[1])[1] if ops else m*n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642856,
                "title": "java-easy-solution-faster-than-100",
                "content": "class Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int min1 = m;\\n        int min2 = n;\\n        \\n        for(int i = 0; i < ops.length; i++){\\n            if(ops[i][0] < min1) min1=ops[i][0];\\n            if(ops[i][1] < min2) min2=ops[i][1];\\n        }\\n        \\n        return min1*min2;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int min1 = m;\\n        int min2 = n;\\n        \\n        for(int i = 0; i < ops.length; i++){\\n            if(ops[i][0] < min1) min1=ops[i][0];\\n            if(ops[i][1] < min2) min2=ops[i][1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1638162,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int MaxCount(int m, int n, int[][] ops) {\\n        \\n        if(ops == null || ops.Length == 0)\\n            return m * n;\\n        \\n        int minX = m, minY = n;\\n        foreach(var op in ops)\\n        {\\n            minX = Math.Min(minX, op[0]);\\n            minY = Math.Min(minY, op[1]);\\n        }\\n        \\n        return minX * minY;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxCount(int m, int n, int[][] ops) {\\n        \\n        if(ops == null || ops.Length == 0)\\n            return m * n;\\n        \\n        int minX = m, minY = n;\\n        foreach(var op in ops)\\n        {\\n            minX = Math.Min(minX, op[0]);\\n            minY = Math.Min(minY, op[1]);\\n        }\\n        \\n        return minX * minY;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1593456,
                "title": "rust-0ms",
                "content": "```\\nimpl Solution {\\n    pub fn max_count(m: i32, n: i32, ops: Vec<Vec<i32>>) -> i32 {\\n        let (a, b) = ops\\n            .iter()\\n            .fold((m, n), |(x, y), v| (x.min(v[0]), y.min(v[1])));\\n        a * b\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn max_count(m: i32, n: i32, ops: Vec<Vec<i32>>) -> i32 {\\n        let (a, b) = ops\\n            .iter()\\n            .fold((m, n), |(x, y), v| (x.min(v[0]), y.min(v[1])));\\n        a * b\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1439060,
                "title": "c-clean-concise-solution-with-detailed-explaination",
                "content": "* **Solution**\\nThe solution is pretty simple, because each ops[i] = [ai, bi] means M[x][y] should be incremented by one for all 0 <= x < ai and 0 <= y < bi, we can see that if we have values of ops[i] larger than values of ops[j] then the area that ops[i] covers will overlap the area of ops[j] so the area that has larger values will be the smaller area. By this observation we can solve the problem by find the min values of a[i] and min values of b[i] then the area created from that two values will be the result. \\n\\n* **Time Complexity**\\nWe just go through all the element of the ops array so the time complexity is **O(n)**.\\n\\n* **Space Complexity**\\nBecause we just use a constant number of variables so the space complexity is **O(1)**.\\n\\n* **Source Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        if (ops.size()==0) return m*n;\\n        \\n        for (int i=1;i<ops.size();++i) {\\n            ops[0][0] = min (ops[0][0],ops[i][0]);\\n            ops[0][1] = min (ops[0][1],ops[i][1]);\\n        }\\n        return ops[0][0]*ops[0][1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        if (ops.size()==0) return m*n;\\n        \\n        for (int i=1;i<ops.size();++i) {\\n            ops[0][0] = min (ops[0][0],ops[i][0]);\\n            ops[0][1] = min (ops[0][1],ops[i][1]);\\n        }\\n        return ops[0][0]*ops[0][1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436159,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int maxCount(int m, int n, int[][] p) {\\n        for(int k[] : p)\\n        {\\n            m=Math.min(m,k[0]);\\n            n=Math.min(n,k[1]);\\n            if(m*n==1)\\n                return m*n;\\n        }\\n        return m*n;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int maxCount(int m, int n, int[][] p) {\\n        for(int k[] : p)\\n        {\\n            m=Math.min(m,k[0]);\\n            n=Math.min(n,k[1]);\\n            if(m*n==1)\\n                return m*n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1435945,
                "title": "range-addition-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        if(ops.size()==0) return m*n;\\n        int min_x = m , min_y = n;\\n        for(int i=0;i<ops.size();i++)\\n        {\\n            min_x = min(min_x,ops[i][0]);\\n            min_y = min(min_y,ops[i][1]);\\n        }\\n        return min_x*min_y;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        if(ops.size()==0) return m*n;\\n        int min_x = m , min_y = n;\\n        for(int i=0;i<ops.size();i++)\\n        {\\n            min_x = min(min_x,ops[i][0]);\\n            min_y = min(min_y,ops[i][1]);\\n        }\\n        return min_x*min_y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435796,
                "title": "c-get-the-minimum-of-each-axis-solution",
                "content": "```\\npublic class Solution {\\n    public int MaxCount(int m, int n, int[][] ops) {\\n        var minM = m;\\n        var minN = n;\\n        \\n        foreach (var op in ops)\\n        {\\n            var a = op[0];\\n            var b = op[1];\\n            \\n            minM = Math.Min(minM, a);\\n            minN = Math.Min(minN, b);            \\n        }\\n        \\n        return minM * minN;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxCount(int m, int n, int[][] ops) {\\n        var minM = m;\\n        var minN = n;\\n        \\n        foreach (var op in ops)\\n        {\\n            var a = op[0];\\n            var b = op[1];\\n            \\n            minM = Math.Min(minM, a);\\n            minN = Math.Min(minN, b);            \\n        }\\n        \\n        return minM * minN;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435629,
                "title": "java-simple-solution-in-depth-explaination",
                "content": "**Naive Solution**\\n\\tThe naive solution involves essentially doing a simulation and doing exactly what the problem says where for each pair in ```ops```, you increment the cells in the submatrix from ```(0, 0)``` to ```(a_i, b_i)```\\n```\\nclass Solution{\\n    public int maxCount(int m, int n, int[][] ops){\\n        int[][] res = new int[m][n];\\n        for(int i = 0; i < ops.length; i++){\\n            int row = ops[i][0];\\n            int col = ops[i][1];\\n            for(int j = 0; j < row; i++){\\n                for(int k = 0; k < col; k++){\\n                    res[j][k]++;\\n                }\\n            }\\n        }\\n        \\n        //maximum value is at (0, 0) because this one is always incremented\\n        int count = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(res[i][j] == res[0][0]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\nUnfortunatly due to the size constraints of the input, this method exceeds the memory limit. It uses ```O(mn)``` space, and has a time complexity of  ```O(kmn)``` in the worst case, where ```k``` is the length of ```ops```. There has got to be a better way.\\n\\n**Optimal Solution**\\nOne thing to notice about this problem is that for each pair in ```ops```, say ```(a, b)```, only the first ```a``` rows are being incremented, and only the first ```b``` columns are incremented. Thinking about it, the maximum value in the matrix would be ```k``` (length of ```ops```), which means the cells containing the maximum value are the ones that are incremented every time. \\n\\nBreaking this into rows and columns, the number of rows containing the maximum value is the minimum ```ops[i][0]``` value, because any ```ops[i][0]``` value larger than ```min(ops[i][0])``` also increments all the rows from 0 to ```min(ops[i][0])```. Similarly with the columns, the number of columns containing the maximum value is ```min(ops[i][1])``` for the same reasons as rows. With these 2 minimum values, it says how many rows and how many columns have the max value, which means the answer is ```min(ops[i][0]) * min(ops[i][1])```. \\n\\nThis can easily be translated to code, as it essentially turns into 2 minimum-finding problems. \\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int rowMin = m;\\n        int colMin = n;\\n        for(int i = 0; i < ops.length; i++){\\n            rowMin = Math.min(ops[i][0], rowMin);\\n            colMin = Math.min(ops[i][1], colMin);\\n        }\\n        return rowMin * colMin;\\n    }\\n}\\n```\\nThis solution runs in ```O(k)``` time (```k``` being the length of ```ops```). And uses ```O(1)``` space. A much better improvement from the previous solution.\\n\\nHope this helps!!",
                "solutionTags": [],
                "code": "```ops```\n```(0, 0)```\n```(a_i, b_i)```\n```\\nclass Solution{\\n    public int maxCount(int m, int n, int[][] ops){\\n        int[][] res = new int[m][n];\\n        for(int i = 0; i < ops.length; i++){\\n            int row = ops[i][0];\\n            int col = ops[i][1];\\n            for(int j = 0; j < row; i++){\\n                for(int k = 0; k < col; k++){\\n                    res[j][k]++;\\n                }\\n            }\\n        }\\n        \\n        //maximum value is at (0, 0) because this one is always incremented\\n        int count = 0;\\n        for(int i = 0; i < m; i++){\\n            for(int j = 0; j < n; j++){\\n                if(res[i][j] == res[0][0]){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```O(mn)```\n```O(kmn)```\n```k```\n```ops```\n```ops```\n```(a, b)```\n```a```\n```b```\n```k```\n```ops```\n```ops[i][0]```\n```ops[i][0]```\n```min(ops[i][0])```\n```min(ops[i][0])```\n```min(ops[i][1])```\n```min(ops[i][0]) * min(ops[i][1])```\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int rowMin = m;\\n        int colMin = n;\\n        for(int i = 0; i < ops.length; i++){\\n            rowMin = Math.min(ops[i][0], rowMin);\\n            colMin = Math.min(ops[i][1], colMin);\\n        }\\n        return rowMin * colMin;\\n    }\\n}\\n```\n```O(k)```\n```k```\n```ops```\n```O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 1435313,
                "title": "slightly-detailed-solution-considering-the-various-use-cases",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        if (m == 0 && n == 0)\\n            return 0;\\n        \\n        int min_x = m;\\n        int min_y = n;\\n        \\n        for (int i = 0; i < ops.size(); i++) {\\n            min_x = min(ops[i][0], min_x);\\n            min_y = min(ops[i][1], min_y);\\n        }\\n        \\n        if (m == 0) {\\n            return  min_y;\\n        } else if (n == 0) {\\n            return  min_x;\\n        } else {\\n            return min_x * min_y;\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        if (m == 0 && n == 0)\\n            return 0;\\n        \\n        int min_x = m;\\n        int min_y = n;\\n        \\n        for (int i = 0; i < ops.size(); i++) {\\n            min_x = min(ops[i][0], min_x);\\n            min_y = min(ops[i][1], min_y);\\n        }\\n        \\n        if (m == 0) {\\n            return  min_y;\\n        } else if (n == 0) {\\n            return  min_x;\\n        } else {\\n            return min_x * min_y;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435194,
                "title": "javascript-functional-style-literally-one-liner-time-o-n-space-o-1",
                "content": "Suprisingly, two `reduce` are quicker than a solution with an explicit loop though `ops` that I also submitted!\\n```javascript\\nvar maxCount = (m, n, ops) => ops.reduce((a, x) => Math.min(a, x[0]), m) * ops.reduce((a, x) => Math.min(a, x[1]), n);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar maxCount = (m, n, ops) => ops.reduce((a, x) => Math.min(a, x[0]), m) * ops.reduce((a, x) => Math.min(a, x[1]), n);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1435002,
                "title": "c-easy-solution-o-n-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int i;\\n        int ans1 = INT_MAX;\\n        int ans2 = INT_MAX;\\n        for(i=0; i<ops.size(); i++)\\n        {\\n\\t\\t/*number of rows column which will be increased maximum\\n\\t\\tnumber of times\\n\\t\\t*/\\n\\t\\t// And matrix fromed by this row and column will be the answer\\n            ans1 = min(ans1 ,ops[i][0] );\\n            ans2 = min(ans2 ,ops[i][1] );\\n        }\\n\\t\\t//if size of the ops will be zero then all element of matrix m X n will be zero \\n        if(ops.size() == 0){return m*n;}\\n\\t\\t\\n        return ans1*ans2;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int i;\\n        int ans1 = INT_MAX;\\n        int ans2 = INT_MAX;\\n        for(i=0; i<ops.size(); i++)\\n        {\\n\\t\\t/*number of rows column which will be increased maximum\\n\\t\\tnumber of times\\n\\t\\t*/\\n\\t\\t// And matrix fromed by this row and column will be the answer\\n            ans1 = min(ans1 ,ops[i][0] );\\n            ans2 = min(ans2 ,ops[i][1] );\\n        }\\n\\t\\t//if size of the ops will be zero then all element of matrix m X n will be zero \\n        if(ops.size() == 0){return m*n;}\\n\\t\\t\\n        return ans1*ans2;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434954,
                "title": "pythonic-solution",
                "content": "```\\ndef maxCount(self, m, n):\\n\\tfor i, j in ops:\\n\\t\\tm, n = min(m, i), min(n, j)\\n\\treturn m * n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef maxCount(self, m, n):\\n\\tfor i, j in ops:\\n\\t\\tm, n = min(m, i), min(n, j)\\n\\treturn m * n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1434893,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn max_count(m: i32, n: i32, ops: Vec<Vec<i32>>) -> i32 {\\n        if ops.len() == 0 { return m * n; }\\n        let i = ops.iter().map(|a| a[0]).min().unwrap();\\n        let j = ops.iter().map(|a| a[1]).min().unwrap();\\n        i * j\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_count(m: i32, n: i32, ops: Vec<Vec<i32>>) -> i32 {\\n        if ops.len() == 0 { return m * n; }\\n        let i = ops.iter().map(|a| a[0]).min().unwrap();\\n        let j = ops.iter().map(|a| a[1]).min().unwrap();\\n        i * j\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1434483,
                "title": "range-addition-ii-simple-solution-with-explanation",
                "content": "In this problem, all we need to do is take care of the overlapped area by each subsequent operation.\\nFor example we have : \\n0 0 0\\n0 0 0\\n0 0 0  \\nand we perform the operation: 2, 3 then the matrix becomes,\\n1 1 1\\n1 1 1\\n0 0 0\\nso for good. Now comes the second operation, say 3, 2 so the matrix becomes\\n2, 2, 1\\n2, 2, 1\\n1, 1, 0 and as you can see the \\n2 2 \\n2 2 is the overlapping region. And that is the overlapping region we need to keep track of whenever we encounter any operation.\\nSo in order to keep track of the overlapping area that each operation covers we declared two variable \\n```int  effL = m, effB = n``` and each time we encounter a operation we are goona compare the \\n```effL = min(effL, ops[i][0]); effB = min(effB, ops[i][1]);``` as the area of overlap is alway the smaller area formed by the minLenght and minBreadth. \\nand finally we return the ```area = effL * effB```. Here is the code: \\n```\\nint maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int s = ops.size();\\n        int area = m*n, effL = m, effB = n;\\n       ``` for(int i=0; i<s; i++) {\\n            effL = min(effL, ops[i][0]);\\n            effB = min(effB, ops[i][1]);\\n            area = effL * effB;\\n        }\\n        return area;\\n}\\n```\\n\\t\\n\\tPlease upvote if it helps . And suggest any improvements. Also I am open to any construction discussion. :)",
                "solutionTags": [],
                "code": "```int  effL = m, effB = n```\n```effL = min(effL, ops[i][0]); effB = min(effB, ops[i][1]);```\n```area = effL * effB```\n```\\nint maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int s = ops.size();\\n        int area = m*n, effL = m, effB = n;\\n       ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1382630,
                "title": "c-solution-o-n-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) \\n    {\\n        int min_x=m,min_y=n;\\n        for(int i=0;i<ops.size();i++)\\n        {\\n            min_x=min(min_x,ops[i][0]);\\n            min_y=min(min_y,ops[i][1]);\\n        }\\n        return min_x*min_y;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) \\n    {\\n        int min_x=m,min_y=n;\\n        for(int i=0;i<ops.size();i++)\\n        {\\n            min_x=min(min_x,ops[i][0]);\\n            min_y=min(min_y,ops[i][1]);\\n        }\\n        return min_x*min_y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346260,
                "title": "c-solution-using-single-sweep-of-input-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        \\n        \\n        if (ops.size() == 0)\\n            return m * n;\\n\\n        int endx =   ops[0][0];\\n        int endy = ops[0][1];\\n        \\n        for (int i = 1 ; i < ops.size(); i++) {\\n            if (endx > ops[i][0] )\\n                endx = ops[i][0];\\n            if (endy > ops[i][1])\\n                endy = ops[i][1];\\n            \\n        }\\n        \\n        return endx * endy;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        \\n        \\n        if (ops.size() == 0)\\n            return m * n;\\n\\n        int endx =   ops[0][0];\\n        int endy = ops[0][1];\\n        \\n        for (int i = 1 ; i < ops.size(); i++) {\\n            if (endx > ops[i][0] )\\n                endx = ops[i][0];\\n            if (endy > ops[i][1])\\n                endy = ops[i][1];\\n            \\n        }\\n        \\n        return endx * endy;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313571,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int[] range = new int[2];\\n        range[0] = 40001;\\n        range[1] = 40001;\\n        for(int[] op : ops)\\n        {\\n            if(op[0] < range[0])\\n            {\\n                range[0] = op[0];\\n            }\\n            \\n            if(op[1] < range[1])\\n            {\\n                range[1] = op[1];\\n            }\\n        }\\n        \\n        return range[0] == 40001 ? m*n : range[0]*range[1];\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int[] range = new int[2];\\n        range[0] = 40001;\\n        range[1] = 40001;\\n        for(int[] op : ops)\\n        {\\n            if(op[0] < range[0])\\n            {\\n                range[0] = op[0];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1273316,
                "title": "python-simple-one-line",
                "content": "```python\\ndef maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        return min([op[0] for op in ops], default=m)*min([op[1] for op in ops], default=n)\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        return min([op[0] for op in ops], default=m)*min([op[1] for op in ops], default=n)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1241807,
                "title": "java-2-solutions-brute-force-optimized-best-solution-beats-100-0ms",
                "content": "**Strict Brute ForceOptimised:**\\n```\\n// TC->O(n^2)\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int col[]=new int [m];\\n        int row[]=new int [n];\\n        \\n        for(int op[]:ops){\\n            for(int i=0;i<op[0];i++) col[i]++;\\n            for(int j=0;j<op[1];j++) row[j]++;\\n        }\\n        \\n        int i=0,j=0;\\n        while(i<m && col[0]==col[i]) i++;\\n        while(j<n && row[0]==row[j]) j++;\\n        \\n        return i*j;\\n    }\\n}\\n\\n```\\n\\n\\n**Best Solution:**\\n```\\n//TC->O(n)\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        for(int op[]:ops){\\n            m=Math.min(m,op[0]);\\n            n=Math.min(n,op[1]);\\n        }\\n        return m*n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// TC->O(n^2)\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int col[]=new int [m];\\n        int row[]=new int [n];\\n        \\n        for(int op[]:ops){\\n            for(int i=0;i<op[0];i++) col[i]++;\\n            for(int j=0;j<op[1];j++) row[j]++;\\n        }\\n        \\n        int i=0,j=0;\\n        while(i<m && col[0]==col[i]) i++;\\n        while(j<n && row[0]==row[j]) j++;\\n        \\n        return i*j;\\n    }\\n}\\n\\n```\n```\\n//TC->O(n)\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        for(int op[]:ops){\\n            m=Math.min(m,op[0]);\\n            n=Math.min(n,op[1]);\\n        }\\n        return m*n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1217014,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        for i in ops:\\n            m,n = min(m,i[0]), min(n,i[1])\\n        return m*n\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        for i in ops:\\n            m,n = min(m,i[0]), min(n,i[1])\\n        return m*n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011483,
                "title": "three-line-python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n\\t\\t\\tif ops == []:\\n\\t\\t\\t\\treturn m * n\\n\\t\\t\\treturn min([t[0] for t in ops]) * min([t[1] for t in ops])",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n\\t\\t\\tif ops == []:\\n\\t\\t\\t\\treturn m * n\\n\\t\\t\\treturn min([t[0] for t in ops]) * min([t[1] for t in ops])",
                "codeTag": "Java"
            },
            {
                "id": 958547,
                "title": "java-ease-fast-than-100",
                "content": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] a) {\\n        if(a.length==0) return m*n;\\n        int mmin = a[0][0];\\n        int nmin = a[0][1];\\n        int max=mmin*nmin;\\n        for(int i=1; i<a.length; i++){\\n            if(a[i][0]<mmin){\\n                mmin = a[i][0]; \\n            }\\n            if(a[i][1]<nmin){\\n                 nmin=a[i][1];\\n            }\\n        }\\n        max=mmin*nmin;\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] a) {\\n        if(a.length==0) return m*n;\\n        int mmin = a[0][0];\\n        int nmin = a[0][1];\\n        int max=mmin*nmin;\\n        for(int i=1; i<a.length; i++){\\n            if(a[i][0]<mmin){\\n                mmin = a[i][0]; \\n            }\\n            if(a[i][1]<nmin){\\n                 nmin=a[i][1];\\n            }\\n        }\\n        max=mmin*nmin;\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880138,
                "title": "1-liner-with-picture",
                "content": "**Picture**\\n\\n![image](https://assets.leetcode.com/users/images/a145b4a4-dbe1-4ae5-9a19-b52b726192fe_1601893617.3024125.png)\\n\\n\\nMathematically we are asked to find so called **minimal set**\\n\\n![image](https://assets.leetcode.com/users/images/e6dc7196-e62a-423c-921d-d6133cb85efe_1601896778.0355825.png)\\n\\n\\nthat could be shown to be equal to\\n\\n![image](https://assets.leetcode.com/users/images/3945dbec-ecea-4d9f-8bdf-63dda24d29a2_1601896901.069436.png)\\n\\n**Code**\\n\\n**time: `O(N)`; space: `O(1)`**\\n\\n- - - - - - -\\n\\n\\n```\\nint maxCount(int m, int n, vector<vector<int>>& ops)\\n{\\n\\tauto x_min{m}, y_min{n};\\n\\n\\tfor(const auto & i : ops)\\n\\t\\tx_min = min(x_min, i[0]), y_min = min(y_min, i[1]);\\n\\n\\treturn x_min*y_min;\\n}\\n```\\n- - - - - - -\\n\\nOfc, you can use `m` and `n` instead of introducing `x_min` and  `y_min`\\n```\\nint maxCount(int m, int n, vector<vector<int>>& o)\\n{\\n\\tfor(auto i{0}; i<size(o); m = min(m, o[i][0]), n = min(n, o[i++][1]));\\n\\treturn m*n;\\n}\\n```\\n\\n- - - - - - -\\nJust for fun you can squeze it all in one line\\n```\\nint maxCount(int m, int n, vector<vector<int>>& o)\\n{\\n\\treturn accumulate(begin(o), end(o), m*n, [&](auto, auto x){ return (m=min(m, x[0]))*(n=min(n, x[1])); });\\n}\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint maxCount(int m, int n, vector<vector<int>>& ops)\\n{\\n\\tauto x_min{m}, y_min{n};\\n\\n\\tfor(const auto & i : ops)\\n\\t\\tx_min = min(x_min, i[0]), y_min = min(y_min, i[1]);\\n\\n\\treturn x_min*y_min;\\n}\\n```\n```\\nint maxCount(int m, int n, vector<vector<int>>& o)\\n{\\n\\tfor(auto i{0}; i<size(o); m = min(m, o[i][0]), n = min(n, o[i++][1]));\\n\\treturn m*n;\\n}\\n```\n```\\nint maxCount(int m, int n, vector<vector<int>>& o)\\n{\\n\\treturn accumulate(begin(o), end(o), m*n, [&](auto, auto x){ return (m=min(m, x[0]))*(n=min(n, x[1])); });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 805630,
                "title": "c-simple-solution-explained-98-time-40-space",
                "content": "Another problem where performance varies wildily with the random input, regrettably (at least if you like to quickly compare your code to others\\', in terms of efficiency).\\n\\nThe core idea is to find the smallest sqaure of overlapping changes and that can be easily done computing the `minX` and `minY` of all the operations passed to us with a loop: only cells in those ranges will get all the operations performed on them.\\n\\nTo be clear: do not even think about creating this massive arrays and then updating them all the time!\\n\\nSince we initiialised both our values to `INT_MAX`, we know that if one of our coordinates still has that value, then no operations were passed and the whole matrix is set to `0`, so our result needs to be `n * m` instead of the more common `minX * minY`. \\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int minX = INT_MAX, minY = INT_MAX;\\n        for (auto e: ops) {\\n            minX = min(minX, e[0]);\\n            minY = min(minY, e[1]);\\n        }\\n        return minX == INT_MAX ? m * n : minX * minY;\\n    }\\n};\\n```\\n\\nCan we do a bit better?\\n\\nProbably, since we do not need to preserve the original values of either `m` or `n`, we can do this:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        for (auto e: ops) {\\n            m = min(m, e[0]);\\n            n = min(n, e[1]);\\n        }\\n        return m * n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int minX = INT_MAX, minY = INT_MAX;\\n        for (auto e: ops) {\\n            minX = min(minX, e[0]);\\n            minY = min(minY, e[1]);\\n        }\\n        return minX == INT_MAX ? m * n : minX * minY;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        for (auto e: ops) {\\n            m = min(m, e[0]);\\n            n = min(n, e[1]);\\n        }\\n        return m * n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679204,
                "title": "javascript-o-n-o-n-single-line",
                "content": "```\\nvar maxCount = function(m, n, ops) {\\n    return ops.reduce( (a,b) => [Math.min(a[0], b[0]), Math.min(a[1], b[1])], [m,n]).reduce( (a,b) => a * b);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxCount = function(m, n, ops) {\\n    return ops.reduce( (a,b) => [Math.min(a[0], b[0]), Math.min(a[1], b[1])], [m,n]).reduce( (a,b) => a * b);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 554261,
                "title": "ruby-o-n-with-exmplanation",
                "content": "#### Leetcode: 598. Range Addition II.\\n\\n\\nLet\\'s try some optimization. Elements increasing always starts from top left element. This mins that maximum values will be in rectangle with width of minimum `A`, and height of minimum `B`, from the `ops` array of `[A,B]` pairs.\\n\\nTo get save in variable minimum, need initialize this variable with maximum. Maximum for `A` is `m`. And for `B` in `n`. \\n\\n```Ruby\\n# 598. Range Addition II\\n# https://leetcode.com/problems/range-addition-ii/\\n# Runtime: 28 ms, faster than 100.00% of Ruby online submissions for Range Addition II.\\n# Memory Usage: 9.5 MB, less than 100.00% of Ruby online submissions for Range Addition II.\\n# @param {Integer} m\\n# @param {Integer} n\\n# @param {Integer[][]} ops\\n# @return {Integer}\\ndef max_count(m, n, ops)\\n    min_a, min_b = m,n\\n    ops.each do |(a,b)|\\n        min_a = a if a < min_a\\n        min_b = b if b < min_b\\n    end\\n    min_a * min_b\\nend",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "#### Leetcode: 598. Range Addition II.\\n\\n\\nLet\\'s try some optimization. Elements increasing always starts from top left element. This mins that maximum values will be in rectangle with width of minimum `A`, and height of minimum `B`, from the `ops` array of `[A,B]` pairs.\\n\\nTo get save in variable minimum, need initialize this variable with maximum. Maximum for `A` is `m`. And for `B` in `n`. \\n\\n```Ruby\\n# 598. Range Addition II\\n# https://leetcode.com/problems/range-addition-ii/\\n# Runtime: 28 ms, faster than 100.00% of Ruby online submissions for Range Addition II.\\n# Memory Usage: 9.5 MB, less than 100.00% of Ruby online submissions for Range Addition II.\\n# @param {Integer} m\\n# @param {Integer} n\\n# @param {Integer[][]} ops\\n# @return {Integer}\\ndef max_count(m, n, ops)\\n    min_a, min_b = m,n\\n    ops.each do |(a,b)|\\n        min_a = a if a < min_a\\n        min_b = b if b < min_b\\n    end\\n    min_a * min_b\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 501042,
                "title": "javascript-solution-using-reduce",
                "content": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} ops\\n * @return {number}\\n */\\nvar maxCount = function(m, n, ops) {\\n  const minHeight = ops.reduce((acc, cur) => Math.min(acc, cur[0]), m);\\n  const minWidth = ops.reduce((acc, cur) => Math.min(acc, cur[1]), n);\\n  return minHeight * minWidth;\\n};\\n```\\n\\nOr, one-liner:\\n\\n```\\nvar maxCount = function(m, n, ops) {\\n  return (\\n    ops.reduce((acc, cur) => Math.min(acc, cur[0]), m) *\\n    ops.reduce((acc, cur) => Math.min(acc, cur[1]), n)\\n  );\\n};\\n```\\n\\n* 69/69 cases passed (48 ms)\\n* Your runtime beats 97.67 % of javascript submissions\\n* Your memory usage beats 100 % of javascript submissions (35.2 MB)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} ops\\n * @return {number}\\n */\\nvar maxCount = function(m, n, ops) {\\n  const minHeight = ops.reduce((acc, cur) => Math.min(acc, cur[0]), m);\\n  const minWidth = ops.reduce((acc, cur) => Math.min(acc, cur[1]), n);\\n  return minHeight * minWidth;\\n};\\n```\n```\\nvar maxCount = function(m, n, ops) {\\n  return (\\n    ops.reduce((acc, cur) => Math.min(acc, cur[0]), m) *\\n    ops.reduce((acc, cur) => Math.min(acc, cur[1]), n)\\n  );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 401036,
                "title": "we-only-care-about-overlaps-python3-one-liner",
                "content": "```\\nfrom functools import reduce\\nfrom operator import mul\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        return reduce(mul, [min(x) for x in zip(*ops)]) if ops else m * n\\n```\\nImportant thing to note is the ranges all start from 0,0 and expand outwards, which means we only need to care about the **smallest overlapped area pinned at 0,0**. Thus finding the `min`s of all the ranges will yield the area with the most overlap i.e. maximum value.",
                "solutionTags": [],
                "code": "```\\nfrom functools import reduce\\nfrom operator import mul\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        return reduce(mul, [min(x) for x in zip(*ops)]) if ops else m * n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289026,
                "title": "c-5-lines-12-ms-faster-than-98-and-11-5-mb-less-than-100-of-all-c-online-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        if (ops.size() == 0)  return m*n;\\n\\n        int minChangesX = (1<<30), minChangesY = (1<<30);\\n        for (const auto& op : ops)  {\\n            minChangesY = (minChangesY > op[0]) ? op[0] : minChangesY;\\n            minChangesX = (minChangesX > op[1]) ? op[1] : minChangesX;\\n        }\\n\\n        return minChangesY * minChangesX;\\n    }\\n};\\n```\\n\\nOther solution that exceeds time limit and uses an unordered_map hash table.\\n\\n[9 Lines]\\n```\\n// Needed for allowing pair<> to be used as a key in unordered_map\\nstruct pair_hash {\\n    template <class T1, class T2>\\n    std::size_t operator () (const std::pair<T1,T2> &p) const {\\n        auto h1 = std::hash<T1>{}(p.first);\\n        auto h2 = std::hash<T2>{}(p.second);\\n\\n        // Mainly for demonstration purposes, i.e. works but is overly simple\\n        // In the real world, use sth. like boost.hash_combine\\n        return h1 ^ h2;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        if (ops.size() == 0)    return m*n;\\n        unordered_map<pair<int,int>,int, pair_hash> posToCountMap;\\n        for (int i=0; i<ops.size(); i++)\\n            for (int j=0; j<ops[i][0]; j++)\\n                for (int k=0; k<ops[i][1]; k++)\\n                    posToCountMap[pair<int,int>(j,k)]++;\\n\\n        int maxNum = posToCountMap[pair<int,int>(0,0)];\\n        int maxNumElems = 0;\\n        for (const auto& elem : posToCountMap)      maxNumElems += (elem.second == maxNum);\\n\\n        return maxNumElems;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        if (ops.size() == 0)  return m*n;\\n\\n        int minChangesX = (1<<30), minChangesY = (1<<30);\\n        for (const auto& op : ops)  {\\n            minChangesY = (minChangesY > op[0]) ? op[0] : minChangesY;\\n            minChangesX = (minChangesX > op[1]) ? op[1] : minChangesX;\\n        }\\n\\n        return minChangesY * minChangesX;\\n    }\\n};\\n```\n```\\n// Needed for allowing pair<> to be used as a key in unordered_map\\nstruct pair_hash {\\n    template <class T1, class T2>\\n    std::size_t operator () (const std::pair<T1,T2> &p) const {\\n        auto h1 = std::hash<T1>{}(p.first);\\n        auto h2 = std::hash<T2>{}(p.second);\\n\\n        // Mainly for demonstration purposes, i.e. works but is overly simple\\n        // In the real world, use sth. like boost.hash_combine\\n        return h1 ^ h2;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        if (ops.size() == 0)    return m*n;\\n        unordered_map<pair<int,int>,int, pair_hash> posToCountMap;\\n        for (int i=0; i<ops.size(); i++)\\n            for (int j=0; j<ops[i][0]; j++)\\n                for (int k=0; k<ops[i][1]; k++)\\n                    posToCountMap[pair<int,int>(j,k)]++;\\n\\n        int maxNum = posToCountMap[pair<int,int>(0,0)];\\n        int maxNumElems = 0;\\n        for (const auto& elem : posToCountMap)      maxNumElems += (elem.second == maxNum);\\n\\n        return maxNumElems;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283578,
                "title": "java-clean-solution",
                "content": "```\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if (ops == null || ops.length == 0) return m * n;\\n        int r = ops[0][0], c = ops[0][1];\\n        for (int[] p : ops) {\\n            r = Math.min(r, p[0]);\\n            c = Math.min(c, p[1]);\\n        }\\n        return r * c;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if (ops == null || ops.length == 0) return m * n;\\n        int r = ops[0][0], c = ops[0][1];\\n        for (int[] p : ops) {\\n            r = Math.min(r, p[0]);\\n            c = Math.min(c, p[1]);\\n        }\\n        return r * c;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 233586,
                "title": "c-8-ms",
                "content": "```\\nint maxCount(int m, int n, int** ops, int opsRowSize, int opsColSize) {\\n    int minRow = m;\\n    int minCol = n;\\n    for(int i = 0; i < opsRowSize; i++)\\n    {\\n        if(minRow > ops[i][0]) minRow = ops[i][0];\\n        if(minCol > ops[i][1]) minCol = ops[i][1];\\n    }\\n    return(minRow * minCol);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxCount(int m, int n, int** ops, int opsRowSize, int opsColSize) {\\n    int minRow = m;\\n    int minCol = n;\\n    for(int i = 0; i < opsRowSize; i++)\\n    {\\n        if(minRow > ops[i][0]) minRow = ops[i][0];\\n        if(minCol > ops[i][1]) minCol = ops[i][1];\\n    }\\n    return(minRow * minCol);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172967,
                "title": "c-o-updates-very-easy-to-follow",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int minRowSize = m;\\n        int minColSize = n;\\n        \\n        for(auto &o : ops){\\n            minRowSize = min(minRowSize,o[0]);\\n            minColSize = min(minColSize,o[1]);\\n        }\\n        \\n        return minRowSize*minColSize;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int minRowSize = m;\\n        int minColSize = n;\\n        \\n        for(auto &o : ops){\\n            minRowSize = min(minRowSize,o[0]);\\n            minColSize = min(minColSize,o[1]);\\n        }\\n        \\n        return minRowSize*minColSize;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103600,
                "title": "easy-to-understand-java-solution",
                "content": "The key insight to this problem is that the sub-matrix that contains the maximum integers will, after every operation, either stay the same size or shrink down. I use variables x and y to denote the sub-matrix that contains all of the maximum integers. I.e., if \\n\\n1, 1, 0\\n1, 1, 0\\n0, 0, 0\\n\\nwere our matrix, then x = 2 and y = 2. I found it useful to think through this problem by thinking about what would happen if we had 0 operations, what would happen if we had 1 operations, then 1+ operations.\\n\\n**0 operations**: If we have 0 operations, then the matrix is full of zeros, and thus, all of the zeros are our max numbers, and we have a matrix full of max numbers. Return m * n.\\n\\n**1 operation**: If we have 1 operation: [a1, b1], then the submatrix that this 1 operation is applied to becomes the submatrix that contains all of the 1's, which is our max number, since every other number will be 0. Return a1 * b1.\\n\\n**1+ operations**: Extending what we learned from the 1 operation case, what happens if we have 2 operations? Let's say our second operation is [a2, b2] There are four cases for the 2nd operation to be. \\n\\n**Case 1: a2 >= a1 and b2 >= b1**\\nIn this case the submatrix of our max numbers stays the same. We know this because the operation [a2, b2] will increment every number in our submatrix of maxes as well as more numbers. So relatively our submatrix of maxes will still be the maxes. We keep x and y the same.\\n\\n**Case 2: a2 >= a1 and b2 < b1**\\nIn this case, the submatrix of our max numbers does not stay the same. Since b2 < b1, we know that only a submatrix of our current submatrix of maxes will be incremented. Thus, we know that we must take a submatrix from our submatrix to be our new submatrix of maxes. We don't make any modifications to x since a2 >= a1, but we set y = b2.\\n\\n**Case 3: a2 < a1 and b2 >= b1**\\nSimilar logic as case 2. No modifications to y, and set x = a2.\\n\\n**Case 4: a2 < a1 and b2 < b1**\\nSimilar logic as case 2. Set x = a2 and y = b2. \\n\\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if(ops.length == 0) return m * n;\\n        int x = -1;\\n        int y = -1;\\n        for(int[] op: ops) {\\n            int a = op[0];\\n            int b = op[1];\\n            \\n            // will only set on the first iteration\\n            x = (x == -1) ? a : x;\\n            y = (y == -1) ? b : y;\\n            \\n            if(a < x) x = a;\\n            if(b < y) y = b;\\n        }\\n        return x * y;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if(ops.length == 0) return m * n;\\n        int x = -1;\\n        int y = -1;\\n        for(int[] op: ops) {\\n            int a = op[0];\\n            int b = op[1];\\n            \\n            // will only set on the first iteration\\n            x = (x == -1) ? a : x;\\n            y = (y == -1) ? b : y;\\n            \\n            if(a < x) x = a;\\n            if(b < y) y = b;\\n        }\\n        return x * y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103629,
                "title": "python-one-line",
                "content": "```\\nclass Solution(object):\\n    def maxCount(self, m, n, ops):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type ops: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        return reduce(operator.mul, map(min, zip(*ops + [[m,n]])))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxCount(self, m, n, ops):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type ops: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        return reduce(operator.mul, map(min, zip(*ops + [[m,n]])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 103641,
                "title": "concise-javascript-o-ops-solution",
                "content": "```\\nvar maxCount = function(m, n, ops) {\\n    let w = n, h = m;\\n    for (let o of ops) {\\n        w = Math.min(w, o[1]);\\n        h = Math.min(h, o[0]);\\n    }\\n    return w * h;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxCount = function(m, n, ops) {\\n    let w = n, h = m;\\n    for (let o of ops) {\\n        w = Math.min(w, o[1]);\\n        h = Math.min(h, o[0]);\\n    }\\n    return w * h;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 103645,
                "title": "clear-python-solution",
                "content": "```\\nclass Solution(object):\\n    def maxCount(self, m, n, ops):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type ops: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if ops:\\n            m = min([a for a, b in ops])\\n            n = min([b for a, b in ops])\\n        return m*n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxCount(self, m, n, ops):\\n        \"\"\"\\n        :type m: int\\n        :type n: int\\n        :type ops: List[List[int]]\\n        :rtype: int\\n        \"\"\"\\n        if ops:\\n            m = min([a for a, b in ops])\\n            n = min([b for a, b in ops])\\n        return m*n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4090320,
                "title": "java-solution-easy",
                "content": "# Complexity\\n- Time complexity:O(length of ops) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n      if(ops.length==0) return m*n;\\n      int x=Integer.MAX_VALUE;\\n      int y=Integer.MAX_VALUE;\\n      for(int[] op:ops){\\n        x=Math.min(x,op[0]);\\n        y=Math.min(y,op[1]);\\n      }\\n      return x*y;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n      if(ops.length==0) return m*n;\\n      int x=Integer.MAX_VALUE;\\n      int y=Integer.MAX_VALUE;\\n      for(int[] op:ops){\\n        x=Math.min(x,op[0]);\\n        y=Math.min(y,op[1]);\\n      }\\n      return x*y;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086366,
                "title": "java-o-n-smallest-overlapping-matrix",
                "content": "# Approach\\nThe window having the most incremented value will be the smallest overlapping window, hence find the smallest window and output the number of elements in that window by getting the product of row and column.\\n# Complexity\\n- Time complexity:\\nO(n), as the there is a single iteration through the ops.\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        /*\\n        find the smallest window [a, b] in ops\\n        find the n of elem in the window\\n        */\\n        int[] smallestOp = new int[]{m, n};\\n        for (int[] op: ops){\\n            smallestOp[0] = Math.min(op[0], smallestOp[0]);\\n            smallestOp[1] = Math.min(op[1], smallestOp[1]);\\n        }\\n\\n        return smallestOp[0] * smallestOp[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        /*\\n        find the smallest window [a, b] in ops\\n        find the n of elem in the window\\n        */\\n        int[] smallestOp = new int[]{m, n};\\n        for (int[] op: ops){\\n            smallestOp[0] = Math.min(op[0], smallestOp[0]);\\n            smallestOp[1] = Math.min(op[1], smallestOp[1]);\\n        }\\n\\n        return smallestOp[0] * smallestOp[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086199,
                "title": "java-solution-with-intuitive-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasically we have to find the size of the rectangle that was included in most operations.\\nThe main idea is that that we will always have a rectangle in the left upper corner. \\n**Why?** \\nBecause we always increase the elements of the matrix from 0 to ops\\\\[i][0] and from 0 to ops\\\\[i][1].\\nThus we have to find the smallest rectangle that ever appeared. That means that we just have to find the minimum row and column that are in our operations matrix.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if (ops.length == 0) return m * n;\\n\\n        int row = ops[0][0], col = ops[0][1];\\n\\n        for(int i = 0; i < ops.length; ++i) {\\n            if (row > ops[i][0]) row = ops[i][0];\\n            if (col > ops[i][1]) col = ops[i][1];\\n        }\\n\\n        return row * col;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if (ops.length == 0) return m * n;\\n\\n        int row = ops[0][0], col = ops[0][1];\\n\\n        for(int i = 0; i < ops.length; ++i) {\\n            if (row > ops[i][0]) row = ops[i][0];\\n            if (col > ops[i][1]) col = ops[i][1];\\n        }\\n\\n        return row * col;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080198,
                "title": "vey-very-easy-simple-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        a=[]\\n        b=[]\\n        if ops==[]:\\n            return m*n\\n        else:\\n            for i in ops:\\n                a.append(i[0])\\n            for i in ops:\\n                b.append(i[1])\\n            return min(a)*min(b)\\n\\n        \\n\\n\\n       \\n            \\n\\n            \\n        \\n        \\n        \\n\\n        \\n\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        a=[]\\n        b=[]\\n        if ops==[]:\\n            return m*n\\n        else:\\n            for i in ops:\\n                a.append(i[0])\\n            for i in ops:\\n                b.append(i[1])\\n            return min(a)*min(b)\\n\\n        \\n\\n\\n       \\n            \\n\\n            \\n        \\n        \\n        \\n\\n        \\n\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4069593,
                "title": "just-find-the-least-intersection-of-all-ops-beats-100",
                "content": "# Intuition\\n\\nWe don\\'t need to count incrementions, all we need is to find most common intersection for all operations\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where n - the number of operations\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if (ops == null || ops.length == 0) {\\n            return m * n;\\n        }\\n\\n        int x = m;\\n        int y = n;\\n\\n        for (int[] op : ops) {\\n            int opx = op[0];\\n            int opy = op[1];\\n\\n            if (opx < x) {\\n                x = opx;\\n            }\\n\\n            if (opy < y) {\\n                y = opy;\\n            }\\n        }\\n\\n        return x * y;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if (ops == null || ops.length == 0) {\\n            return m * n;\\n        }\\n\\n        int x = m;\\n        int y = n;\\n\\n        for (int[] op : ops) {\\n            int opx = op[0];\\n            int opy = op[1];\\n\\n            if (opx < x) {\\n                x = opx;\\n            }\\n\\n            if (opy < y) {\\n                y = opy;\\n            }\\n        }\\n\\n        return x * y;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061309,
                "title": "simplest-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        for(int i=0; i<ops.size(); i++){\\n            m = min(m, ops[i][0]);\\n            n = min(n, ops[i][1]);\\n        }\\n        return m*n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        for(int i=0; i<ops.size(); i++){\\n            m = min(m, ops[i][0]);\\n            n = min(n, ops[i][1]);\\n        }\\n        return m*n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059723,
                "title": "easy-to-understand-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\nsuppose it is 3x3 matrix , operation array is [[2,3],[3,2]]\\n\\n0 0 0\\n0 0 0\\n0 0 0\\n\\napply just first operation [2,3]\\n1 1 1\\n1 1 1\\n0 0 0\\n\\napply just second operation [3,2]\\n1 1 0\\n1 1 0\\n1 1 0\\n\\nadd two \\n2 2 1\\n2 2 1\\n1 1 0\\n\\nanswer is  4 , as 4 cell contains highest number 2\\n\\nso in short we have to just take intersection of all ranges\\nat start set range to max \\nrowRange : m = 3\\ncolRange : n = 3\\n\\nfirst range [2,3]\\nrowRange = min(rowRange , 2) => min(3,2) => 2\\ncolRange = min(colRange , 3) => min(3,3) => 3\\n\\nsecond range [3,2]\\nrowRange = min(rowRange , 3) => min(2,3) => 2\\ncolRange = min(colRange , 2) => min(3,2) => 2\\n\\noutput 2*2 matrix => 4 elements\\n\\n */\\n\\n\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int rowRange = m, colRange = n;\\n        for(int i=0;i<ops.length ; i++){\\n            rowRange = Math.min(rowRange , ops[i][0]);\\n            colRange = Math.min(colRange , ops[i][1]);\\n        }\\n\\n        return rowRange * colRange;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nsuppose it is 3x3 matrix , operation array is [[2,3],[3,2]]\\n\\n0 0 0\\n0 0 0\\n0 0 0\\n\\napply just first operation [2,3]\\n1 1 1\\n1 1 1\\n0 0 0\\n\\napply just second operation [3,2]\\n1 1 0\\n1 1 0\\n1 1 0\\n\\nadd two \\n2 2 1\\n2 2 1\\n1 1 0\\n\\nanswer is  4 , as 4 cell contains highest number 2\\n\\nso in short we have to just take intersection of all ranges\\nat start set range to max \\nrowRange : m = 3\\ncolRange : n = 3\\n\\nfirst range [2,3]\\nrowRange = min(rowRange , 2) => min(3,2) => 2\\ncolRange = min(colRange , 3) => min(3,3) => 3\\n\\nsecond range [3,2]\\nrowRange = min(rowRange , 3) => min(2,3) => 2\\ncolRange = min(colRange , 2) => min(3,2) => 2\\n\\noutput 2*2 matrix => 4 elements\\n\\n */\\n\\n\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        int rowRange = m, colRange = n;\\n        for(int i=0;i<ops.length ; i++){\\n            rowRange = Math.min(rowRange , ops[i][0]);\\n            colRange = Math.min(colRange , ops[i][1]);\\n        }\\n\\n        return rowRange * colRange;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049118,
                "title": "easy-c-solution-o-n-time-complexity-and-o-1-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncount the indexes which comes under the given area every time. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* use a loop for the all ops\\n* every time the index size minimum the matrix size of largest element get minimum \\n* calculate the index between resi and resj indexes\\n# Complexity\\n- Time complexity: O(n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n* * n is rows present in ops\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int resi=m, resj=n;\\n        // vector<vector<int>>v(m, vector<int>(n,0));\\n        for(int i=0; i<ops.size(); i++){\\n            if(ops[i][0]<resi) resi = ops[i][0];\\n            if(ops[i][1]<resj) resj = ops[i][1];\\n        }\\n        int res = 0;\\n        res = (resi)*(resj);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int resi=m, resj=n;\\n        // vector<vector<int>>v(m, vector<int>(n,0));\\n        for(int i=0; i<ops.size(); i++){\\n            if(ops[i][0]<resi) resi = ops[i][0];\\n            if(ops[i][1]<resj) resj = ops[i][1];\\n        }\\n        int res = 0;\\n        res = (resi)*(resj);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043936,
                "title": "min-path",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} ops\\n * @return {number}\\n */\\nvar maxCount = function(m, n, ops) {\\n    let minX = m;\\n    let minY = n;\\n\\n    for(let op of ops) {\\n      minX = Math.min(minX, op[0]);\\n      minY = Math.min(minY, op[1]);\\n    }\\n\\n    return minX * minY;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} m\\n * @param {number} n\\n * @param {number[][]} ops\\n * @return {number}\\n */\\nvar maxCount = function(m, n, ops) {\\n    let minX = m;\\n    let minY = n;\\n\\n    for(let op of ops) {\\n      minX = Math.min(minX, op[0]);\\n      minY = Math.min(minY, op[1]);\\n    }\\n\\n    return minX * minY;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4001245,
                "title": "easiest-solution-pls-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) \\n    {\\n        int r=m,c=n;\\n        for(int i=0;i<ops.size();i++)\\n        {\\n            r=min(ops[i][0],r);\\n            c=min(ops[i][1],c);\\n        }\\n        return r*c;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) \\n    {\\n        int r=m,c=n;\\n        for(int i=0;i<ops.size();i++)\\n        {\\n            r=min(ops[i][0],r);\\n            c=min(ops[i][1],c);\\n        }\\n        return r*c;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997145,
                "title": "easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nfunc maxCount(_ m: Int, _ n: Int, _ ops: [[Int]]) -> Int {\\n    \\n    guard !ops.isEmpty else {return m * n}\\n    var arr1 = [Int]()\\n    var arr2 = [Int]()\\n    \\n    for i in ops {\\n        arr1.append(i[0])\\n        arr2.append(i[1])\\n    }\\n    \\n    return arr1.min()! * arr2.min()!\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\nfunc maxCount(_ m: Int, _ n: Int, _ ops: [[Int]]) -> Int {\\n    \\n    guard !ops.isEmpty else {return m * n}\\n    var arr1 = [Int]()\\n    var arr2 = [Int]()\\n    \\n    for i in ops {\\n        arr1.append(i[0])\\n        arr2.append(i[1])\\n    }\\n    \\n    return arr1.min()! * arr2.min()!\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991154,
                "title": "easiest-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int row=m;\\n        int col=n;\\n        for(int i=0;i<ops.size();i++){\\n            if(ops[i][0]<row){\\n                row=ops[i][0];\\n            }\\n             if(ops[i][1]<col){\\n                col=ops[i][1];\\n            }\\n        }\\n        return row*col;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int row=m;\\n        int col=n;\\n        for(int i=0;i<ops.size();i++){\\n            if(ops[i][0]<row){\\n                row=ops[i][0];\\n            }\\n             if(ops[i][1]<col){\\n                col=ops[i][1];\\n            }\\n        }\\n        return row*col;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986781,
                "title": "easy-c-solution-beats-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int len = ops.size();\\n        for(int i = 0; i < len ; i++)\\n        {\\n            if(m>ops[i][0])\\n            {\\n                m = ops[i][0];\\n            }\\n\\n            if(n>ops[i][1])\\n            {\\n                n = ops[i][1];\\n            }\\n        }\\n        \\n        return m*n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int len = ops.size();\\n        for(int i = 0; i < len ; i++)\\n        {\\n            if(m>ops[i][0])\\n            {\\n                m = ops[i][0];\\n            }\\n\\n            if(n>ops[i][1])\\n            {\\n                n = ops[i][1];\\n            }\\n        }\\n        \\n        return m*n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982249,
                "title": "the-fastest-in-dart",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(ops.length)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n  int maxCount(int m, int n, List<List<int>> ops) {\\n  int minX = m;\\n  int minY = n;\\n\\n  for (var op in ops) {\\n    minX = minX < op[0] ? minX : op[0];\\n    minY = minY < op[1] ? minY : op[1];\\n  }\\n\\n  return minX * minY;\\n\\n\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int maxCount(int m, int n, List<List<int>> ops) {\\n  int minX = m;\\n  int minY = n;\\n\\n  for (var op in ops) {\\n    minX = minX < op[0] ? minX : op[0];\\n    minY = minY < op[1] ? minY : op[1];\\n  }\\n\\n  return minX * minY;\\n\\n\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981534,
                "title": "c-solution-easy",
                "content": "# Complexity\\n- Time complexity:\\n  O(N)\\n\\n- Space complexity:\\n O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int min_row = m;\\n        int min_col = n;\\n\\n        for(int i = 0; i < ops.size(); i++) {\\n            if(min_row > ops[i][0]) {\\n                min_row = ops[i][0];\\n            }\\n        } \\n\\n        for(int i = 0; i < ops.size(); i++) {\\n            if(min_col > ops[i][1]) {\\n                min_col = ops[i][1];\\n            }\\n        } \\n\\n        return min_row * min_col; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int min_row = m;\\n        int min_col = n;\\n\\n        for(int i = 0; i < ops.size(); i++) {\\n            if(min_row > ops[i][0]) {\\n                min_row = ops[i][0];\\n            }\\n        } \\n\\n        for(int i = 0; i < ops.size(); i++) {\\n            if(min_col > ops[i][1]) {\\n                min_col = ops[i][1];\\n            }\\n        } \\n\\n        return min_row * min_col; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977527,
                "title": "how-u-have-solved-if-u-were-a-computer-simple-and-intutuive",
                "content": "So the thing is how u would have approached this problem if u had to do it manually?\\n\\nif i had to do this then i would have done in this way:\\n\\nstep1: first marks the far most points (n-1) in rows first then i would have move to wards 0th row and each time if i see a new marking such that there is some marking after that then \\n``` maxvalue_for_current_marking = just_next_marking_from current  +1 ```\\n\\nmaintain a ans veriable and take max with all\\n\\nstep 2 : do it same for column as well\\n\\nat the end find farthest points who have value =ans\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    static bool mycom(vector<int> &a, vector<int>&b)\\n    {\\n        return a[1]>b[1];\\n    }\\n    int maxCount(int m, int n, vector<vector<int>>& p) \\n    {\\n        \\n        // vector<int> r(n,0);\\n        // vector<int> c(m,0);\\n        sort(p.begin(),p.end());\\n        reverse(p.begin(),p.end());\\n        map<int,int> mr;\\n        map<int,int> mc;\\n        \\n        int ans=0;\\n        for(auto i: p)\\n        {\\n            auto it= mr.lower_bound(i[0]);\\n            if(it!=mr.end())\\n            {\\n                mr[i[0]]=mr[(*it).first]+1;\\n                \\n            }else\\n            {\\n                mr[i[0]]=1;\\n            }\\n            ans= max(mr[i[0]],ans);\\n           \\n            \\n        }\\n        sort(p.begin(),p.end(),mycom);\\n        \\n        for(auto i: p)\\n        {\\n             \\n            auto it= mc.lower_bound(i[1]);\\n            if(it!=mc.end())\\n            {\\n                mc[i[1]]=mc[(*it).first]+1;\\n            }else\\n            {\\n                mc[i[1]]=1;\\n            }\\n            ans= max(mc[i[1]],ans);\\n            \\n            \\n        }\\n        cout<<ans<<endl;\\n        \\n        int x=0;\\n        int y=0;\\n        for(auto i: mr)\\n            if(i.second==ans) x=i.first;\\n        for(auto i: mc)\\n            if(i.second==ans) y=i.first;\\n        cout<<x<<\" \"<<y<<endl;\\n                        //          non  zero,    in case of zero\\n        return (x)*(y)>0 ?         x*y    :   n*m;\\n        \\n        \\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "``` maxvalue_for_current_marking = just_next_marking_from current  +1 ```\n```\\nclass Solution {\\npublic:\\n    \\n    static bool mycom(vector<int> &a, vector<int>&b)\\n    {\\n        return a[1]>b[1];\\n    }\\n    int maxCount(int m, int n, vector<vector<int>>& p) \\n    {\\n        \\n        // vector<int> r(n,0);\\n        // vector<int> c(m,0);\\n        sort(p.begin(),p.end());\\n        reverse(p.begin(),p.end());\\n        map<int,int> mr;\\n        map<int,int> mc;\\n        \\n        int ans=0;\\n        for(auto i: p)\\n        {\\n            auto it= mr.lower_bound(i[0]);\\n            if(it!=mr.end())\\n            {\\n                mr[i[0]]=mr[(*it).first]+1;\\n                \\n            }else\\n            {\\n                mr[i[0]]=1;\\n            }\\n            ans= max(mr[i[0]],ans);\\n           \\n            \\n        }\\n        sort(p.begin(),p.end(),mycom);\\n        \\n        for(auto i: p)\\n        {\\n             \\n            auto it= mc.lower_bound(i[1]);\\n            if(it!=mc.end())\\n            {\\n                mc[i[1]]=mc[(*it).first]+1;\\n            }else\\n            {\\n                mc[i[1]]=1;\\n            }\\n            ans= max(mc[i[1]],ans);\\n            \\n            \\n        }\\n        cout<<ans<<endl;\\n        \\n        int x=0;\\n        int y=0;\\n        for(auto i: mr)\\n            if(i.second==ans) x=i.first;\\n        for(auto i: mc)\\n            if(i.second==ans) y=i.first;\\n        cout<<x<<\" \"<<y<<endl;\\n                        //          non  zero,    in case of zero\\n        return (x)*(y)>0 ?         x*y    :   n*m;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3942731,
                "title": "using-a-for-loop-simplest-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmax element all around the matrix\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nloop for the smallest index so that the element below are already increased\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int x=ops.size();\\n        if(x==0){\\n            return m*n;\\n        }\\n        vector<int> v1;\\n        vector<int> v2;\\n        for(int i=0;i<x;i++){\\n            v1.push_back(ops[i][0]);\\n            v2.push_back(ops[i][1]);\\n        }\\n        cout<<\":DFG\";\\n        int d=*min_element(v1.begin(),v1.end());\\n        int f=*min_element(v2.begin(),v2.end());\\n\\n      \\n        return d*f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int x=ops.size();\\n        if(x==0){\\n            return m*n;\\n        }\\n        vector<int> v1;\\n        vector<int> v2;\\n        for(int i=0;i<x;i++){\\n            v1.push_back(ops[i][0]);\\n            v2.push_back(ops[i][1]);\\n        }\\n        cout<<\":DFG\";\\n        int d=*min_element(v1.begin(),v1.end());\\n        int f=*min_element(v2.begin(),v2.end());\\n\\n      \\n        return d*f;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3936443,
                "title": "linear-solution-in-cpp",
                "content": "\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n        int maxCount(int m, int n, vector<vector < int>> &ops)\\n        {\\n            int  x = m, y = n;\\n\\n            for (auto num: ops)\\n            {\\n                x = min(num[0], x);\\n                y = min(num[1], y);\\n            }\\n            return x * y;\\n        }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int maxCount(int m, int n, vector<vector < int>> &ops)\\n        {\\n            int  x = m, y = n;\\n\\n            for (auto num: ops)\\n            {\\n                x = min(num[0], x);\\n                y = min(num[1], y);\\n            }\\n            return x * y;\\n        }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897809,
                "title": "non-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n      int minm = m;\\n      int minn = n;\\n      for (auto a: ops) {\\n        if (a[0] < minm) minm = a[0];\\n        if (a[1] < minn) minn = a[1];\\n      }\\n\\n      return minm * minn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n      int minm = m;\\n      int minn = n;\\n      for (auto a: ops) {\\n        if (a[0] < minm) minm = a[0];\\n        if (a[1] < minn) minn = a[1];\\n      }\\n\\n      return minm * minn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3891576,
                "title": "easy-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if (ops.length==0)\\n            return m*n;\\n        int row=Integer.MAX_VALUE, col=Integer.MAX_VALUE;\\n        for(int i=0;i<ops.length;i++) {\\n            row = Math.min(row,ops[i][0]);\\n            col = Math.min(col,ops[i][1]);\\n        }\\n        return row*col;\\n    }\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int a = m;\\n        int b = n;\\n        for (auto i: ops){\\n            if (i[0] < a){\\n                a = i[0];\\n            }\\n            if (i[1] < b){\\n                b = i[1];\\n            } \\n        }\\n        return (a * b);\\n        \\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if (ops.length==0)\\n            return m*n;\\n        int row=Integer.MAX_VALUE, col=Integer.MAX_VALUE;\\n        for(int i=0;i<ops.length;i++) {\\n            row = Math.min(row,ops[i][0]);\\n            col = Math.min(col,ops[i][1]);\\n        }\\n        return row*col;\\n    }\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int a = m;\\n        int b = n;\\n        for (auto i: ops){\\n            if (i[0] < a){\\n                a = i[0];\\n            }\\n            if (i[1] < b){\\n                b = i[1];\\n            } \\n        }\\n        return (a * b);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889999,
                "title": "c-sol-efficient-by-using-logic-brain",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        if(ops.size()==0)\\n        return m*n;\\n        int i,j,row=INT_MAX,col=INT_MAX;\\n        for(i=0;i<ops.size();i++){\\n            row=min(row,ops[i][0]);\\n            col=min(col,ops[i][1]);\\n        }\\n        return row*col;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        if(ops.size()==0)\\n        return m*n;\\n        int i,j,row=INT_MAX,col=INT_MAX;\\n        for(i=0;i<ops.size();i++){\\n            row=min(row,ops[i][0]);\\n            col=min(col,ops[i][1]);\\n        }\\n        return row*col;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888973,
                "title": "easy-c-solution-math",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        if(!ops.size()) return m*n;\\n        int min1=INT_MAX,min2=INT_MAX;\\n        //finding minimum no. of row and cols because that many cells\\n        //will get incremented every time\\n        for(int i=0;i<ops.size();i++){\\n            min1=min(min1,ops[i][0]);\\n            min2=min(min2,ops[i][1]);\\n        }\\n\\n        return min1*min2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        if(!ops.size()) return m*n;\\n        int min1=INT_MAX,min2=INT_MAX;\\n        //finding minimum no. of row and cols because that many cells\\n        //will get incremented every time\\n        for(int i=0;i<ops.size();i++){\\n            min1=min(min1,ops[i][0]);\\n            min2=min(min2,ops[i][1]);\\n        }\\n\\n        return min1*min2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885958,
                "title": "100-beats-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if (ops == null || ops.length == 0) {\\n            return m * n;\\n        }\\n        \\n        int minX = m;\\n        int minY = n;\\n        \\n        for (int[] op : ops) {\\n            minX = Math.min(minX, op[0]);\\n            minY = Math.min(minY, op[1]);\\n        }\\n        \\n        return minX * minY;\\n    } \\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if (ops == null || ops.length == 0) {\\n            return m * n;\\n        }\\n        \\n        int minX = m;\\n        int minY = n;\\n        \\n        for (int[] op : ops) {\\n            minX = Math.min(minX, op[0]);\\n            minY = Math.min(minY, op[1]);\\n        }\\n        \\n        return minX * minY;\\n    } \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852957,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int x = m,y = n;\\n        for(auto i: ops){\\n            x = min(x,i[0]);\\n            y = min(y,i[1]);\\n        }\\n        return x*y;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int x = m,y = n;\\n        for(auto i: ops){\\n            x = min(x,i[0]);\\n            y = min(y,i[1]);\\n        }\\n        return x*y;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837039,
                "title": "simple-and-easiest-solution-java-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if(ops.length==0)\\n        return m*n;\\n        else if(ops.length==1)\\n        return ops[0][0]*ops[0][1];\\n        int row,column;\\n        row=column=Integer.MAX_VALUE;\\n        for(int i=0;i<ops.length;i++){\\n            if(ops[i][0]<row)\\n            row = ops[i][0];\\n            if(ops[i][1]<column)\\n            column = ops[i][1];\\n            \\n        }\\n       \\n        return row*column;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if(ops.length==0)\\n        return m*n;\\n        else if(ops.length==1)\\n        return ops[0][0]*ops[0][1];\\n        int row,column;\\n        row=column=Integer.MAX_VALUE;\\n        for(int i=0;i<ops.length;i++){\\n            if(ops[i][0]<row)\\n            row = ops[i][0];\\n            if(ops[i][1]<column)\\n            column = ops[i][1];\\n            \\n        }\\n       \\n        return row*column;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833613,
                "title": "java-python-solution-beats-100-in-both-memory-and-time-intruiging-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhat could be the number of Max Elements.\\nAt first it seems dificult, but let\\'s analyze it deeply.\\n+ The maximum sum must come from the places where max number of operations have been performed.\\n+ Max number of operations have been performed at positions where Ai is min and Bi is min too.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n+ Find the minimum element of both Ai and Bi and return multiplication of both of them.\\n### LOL :-)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if(ops.length == 0) return m*n;\\n        int min1 = ops[0][0],min2 = ops[0][1];\\n        for (int i = 0; i < ops.length ; i++) {\\n            if(ops[i][0]<min1) min1 = ops[i][0];\\n            if(ops[i][1]<min2) min2 = ops[i][1];\\n        }\\n        return min1*min2;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        if not ops:\\n            return m * n\\n\\n        min1, min2 = float(\\'inf\\'), float(\\'inf\\')\\n\\n        for i, j in ops:\\n            min1 = min(min1, i)\\n            min2 = min(min2, j)\\n\\n        return min1 * min2\\n\\n```\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if(ops.length == 0) return m*n;\\n        int min1 = ops[0][0],min2 = ops[0][1];\\n        for (int i = 0; i < ops.length ; i++) {\\n            if(ops[i][0]<min1) min1 = ops[i][0];\\n            if(ops[i][1]<min2) min2 = ops[i][1];\\n        }\\n        return min1*min2;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        if not ops:\\n            return m * n\\n\\n        min1, min2 = float(\\'inf\\'), float(\\'inf\\')\\n\\n        for i, j in ops:\\n            min1 = min(min1, i)\\n            min2 = min(min2, j)\\n\\n        return min1 * min2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827227,
                "title": "return-min-ops-1st-row-min-ops-2nd-row",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int first=INT_MAX;\\n        int second=INT_MAX;\\n        if(ops.size()==0)\\n        return m*n;\\n        for(int i=0;i<ops.size();i++)\\n        {\\n            if(ops[i][0]<first)\\n            {\\n                first=ops[i][0];\\n            }\\n             if(ops[i][1]<second)\\n            {\\n                second=ops[i][1];\\n            }\\n        }\\n        return first*second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int first=INT_MAX;\\n        int second=INT_MAX;\\n        if(ops.size()==0)\\n        return m*n;\\n        for(int i=0;i<ops.size();i++)\\n        {\\n            if(ops[i][0]<first)\\n            {\\n                first=ops[i][0];\\n            }\\n             if(ops[i][1]<second)\\n            {\\n                second=ops[i][1];\\n            }\\n        }\\n        return first*second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825383,
                "title": "kp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        cm = m\\n        nm = n\\n        for i in range(len(ops)):\\n            cm = min(cm, ops[i][0])\\n            nm = min(nm, ops[i][1])\\n        return cm*nm\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxCount(self, m: int, n: int, ops: List[List[int]]) -> int:\\n        cm = m\\n        nm = n\\n        for i in range(len(ops)):\\n            cm = min(cm, ops[i][0])\\n            nm = min(nm, ops[i][1])\\n        return cm*nm\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3801386,
                "title": "java-solution-easy-brute-force-technique-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n    if(ops.length==0){\\n      return m*n;\\n    }\\n    int row=Integer.MAX_VALUE,col=Integer.MAX_VALUE;\\n    for(int i=0;i<ops.length;i++){\\n        col=Math.min(col,ops[i][0]);\\n        row=Math.min(row,ops[i][1]);\\n      }\\n      return col*row; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n    if(ops.length==0){\\n      return m*n;\\n    }\\n    int row=Integer.MAX_VALUE,col=Integer.MAX_VALUE;\\n    for(int i=0;i<ops.length;i++){\\n        col=Math.min(col,ops[i][0]);\\n        row=Math.min(row,ops[i][1]);\\n      }\\n      return col*row; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793722,
                "title": "ts-js-solution-in-o-n",
                "content": "# Intuition\\nWe can clearly observe that which ever index will have higher number of operations that will be max number and max count.\\n\\n# Approach\\nI am just running a loop to find the least value of x and y in a matrix.\\n\\n# Complexity\\n- Time complexity:\\nTime complexity here is $$O(n)$$ where n is length of operations.\\n\\n- Space complexity:\\nSpace complexity here is $$O(1)$$ as we are only using two variables extra.\\n\\n# Code\\n```\\nfunction maxCount(m: number, n: number, ops: number[][]): number {\\n    if(!ops.length) return m*n;\\n    \\n    let x = Number.MAX_SAFE_INTEGER;\\n    let y = Number.MAX_SAFE_INTEGER\\n    for(let i=0;i<ops.length;i++){\\n       x=  Math.min(x, ops[i][0]);\\n       y=  Math.min(y, ops[i][1]);\\n       if(x==1 && y==1) break;\\n    }\\n\\n    return x*y\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction maxCount(m: number, n: number, ops: number[][]): number {\\n    if(!ops.length) return m*n;\\n    \\n    let x = Number.MAX_SAFE_INTEGER;\\n    let y = Number.MAX_SAFE_INTEGER\\n    for(let i=0;i<ops.length;i++){\\n       x=  Math.min(x, ops[i][0]);\\n       y=  Math.min(y, ops[i][1]);\\n       if(x==1 && y==1) break;\\n    }\\n\\n    return x*y\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3790476,
                "title": "extremely-simple-c-solution-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int l = m, r = n;\\n        for(auto itr : ops){\\n            if(itr[0] < l)\\n                l = itr[0];\\n            if(itr[1] < r)\\n                r = itr[1];\\n        }\\n        return l*r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n        int l = m, r = n;\\n        for(auto itr : ops){\\n            if(itr[0] < l)\\n                l = itr[0];\\n            if(itr[1] < r)\\n                r = itr[1];\\n        }\\n        return l*r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783760,
                "title": "easiest-approach-c-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nStep 1. Sort ops.\\nExample of Sorted ops:\\n2 , 3 \\n2 , 1 \\n4 , 2 \\n7 , 4\\n\\nStep 2. Iterate ops and find smallest row ops value (i) here it is 2 which is ops[0][0] always and find smallest coloumn ops value (j) here it is 1 which we can find in one iteration. \\n\\n\\nStep 3. Now our max Integer will be i*j.\\n\\nNOTE: If ops size is 0 simply return rows_size * coloumn_size i.e. m * n.\\n\\n# Complexity\\n- Time complexity:\\nO(NLogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n\\n        int maxIntegers=0;\\n        \\n        if(ops.size()>0){\\n            sort(ops.begin(), ops.end());\\n            int j=ops[0][1];\\n\\n            for(int i=0; i<ops.size()-1; i++){\\n                if(j>ops[i+1][1]) j=ops[i+1][1];\\n                if(ops[i+1][1]==1) break;\\n            }\\n            int maxIntegers = ops[0][0]*j;\\n            return maxIntegers;\\n        }\\n\\n        return m*n;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxCount(int m, int n, vector<vector<int>>& ops) {\\n\\n        int maxIntegers=0;\\n        \\n        if(ops.size()>0){\\n            sort(ops.begin(), ops.end());\\n            int j=ops[0][1];\\n\\n            for(int i=0; i<ops.size()-1; i++){\\n                if(j>ops[i+1][1]) j=ops[i+1][1];\\n                if(ops[i+1][1]==1) break;\\n            }\\n            int maxIntegers = ops[0][0]*j;\\n            return maxIntegers;\\n        }\\n\\n        return m*n;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774350,
                "title": "100-beat-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSpecial case if ops length is 0 return product of m and n\\nSimply Cheking the minimum row and column pair in ops \\nReturn the product of that row and column pair\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nJust follow the intution You will get what happened\\nBecause After all you can see the incremented sub matrix will be of row and column which is minimum in ops because it get repeated many times\\nSo A Smart Trick... LOL\\n\\n# Complexity\\n- Time complexity: O[m]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O[1] (Excluding the Input Matrix)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if (ops.length==0) return m*n;\\n\\n        int row = ops[0][0];\\n        int column = ops[0][1];\\n\\n        for (int i=0;i<ops.length;i++)\\n        {\\n            row = Math.min(ops[i][0],row);\\n            column = Math.min(ops[i][1],column);\\n        }\\n\\n        return row*column;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxCount(int m, int n, int[][] ops) {\\n        if (ops.length==0) return m*n;\\n\\n        int row = ops[0][0];\\n        int column = ops[0][1];\\n\\n        for (int i=0;i<ops.length;i++)\\n        {\\n            row = Math.min(ops[i][0],row);\\n            column = Math.min(ops[i][1],column);\\n        }\\n\\n        return row*column;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737804,
                "title": "smallest-submatrix-solution-in-typescript-and-rust",
                "content": "**The smallest submartix will get the maximum number as it\\'s affected by all operations.**\\n\\n# TypeScript\\n```\\nfunction maxCount(m: number, n: number, ops: number[][]): number {\\n    if (ops.length === 0) {\\n        return m*n;\\n    }\\n\\n    const [minA, minB] = ops.reduce(\\n        ([minA, minB], [a, b]) => [Math.min(minA, a), Math.min(minB, b)],\\n        [m, n]\\n    );\\n\\n    return minA * minB;\\n}\\n```\\n\\n# Rust\\n```\\nimpl Solution {\\n    pub fn max_count(m: i32, n: i32, ops: Vec<Vec<i32>>) -> i32 {\\n        if ops.is_empty() {\\n            return m*n\\n        }\\n\\n        let (mut a_min, mut b_min) = (m, n);\\n        for op in ops {\\n            a_min = a_min.min(op[0]);\\n            b_min = b_min.min(op[1]);\\n        }\\n\\n        a_min * b_min\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "TypeScript"
                ],
                "code": "```\\nfunction maxCount(m: number, n: number, ops: number[][]): number {\\n    if (ops.length === 0) {\\n        return m*n;\\n    }\\n\\n    const [minA, minB] = ops.reduce(\\n        ([minA, minB], [a, b]) => [Math.min(minA, a), Math.min(minB, b)],\\n        [m, n]\\n    );\\n\\n    return minA * minB;\\n}\\n```\n```\\nimpl Solution {\\n    pub fn max_count(m: i32, n: i32, ops: Vec<Vec<i32>>) -> i32 {\\n        if ops.is_empty() {\\n            return m*n\\n        }\\n\\n        let (mut a_min, mut b_min) = (m, n);\\n        for op in ops {\\n            a_min = a_min.min(op[0]);\\n            b_min = b_min.min(op[1]);\\n        }\\n\\n        a_min * b_min\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1688768,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 1777654,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 1575044,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 2066847,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 2048235,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 2010448,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 2008981,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 1991205,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 1986485,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 1981104,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 1688768,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 1777654,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 1575044,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 2066847,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 2048235,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 2010448,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 2008981,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 1991205,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 1986485,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            },
            {
                "id": 1981104,
                "content": [
                    {
                        "username": "durjoyovi76",
                        "content": "I think problem difficulty is not accurate. It deserve a medium level.\\nmany people approach problem according to difficulty so it\\'s better to place problems in proper difficulty."
                    },
                    {
                        "username": "lc7",
                        "content": "It is actually easy. You have to think laterally. Getting the runtime below 5ms was my only problem."
                    },
                    {
                        "username": "sourabhbawage",
                        "content": "[@apheleon](/apheleon) O(n) does not represent the complexity of the problem"
                    },
                    {
                        "username": "apheleon",
                        "content": "medium? it is quite a bit simple. O(n)"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "I am providing a link of my own solution at the end, but do not jump to it directly without understanding it and trying it on your own. The problem is extremely easy and based on array traversal if you know what is going on with each operation. The question asks you to return the number of maximum elements in the matrix after all the operations.\\nFirst of all, consider the base case. If no element is present in ops array, directly return m x n since all elements are maximum (equal to zero).\\nNow let\\'s say we have n number of operations in the ops array. In each operation, we are given 2 integers a & b and we have to select a sub-matrix of dimension a x b and increment each element in it by 1. If we have 3 operations [2,2], [3,3] & [2,3], and [3,4], the elements in the submatrix [2,2] get incremented in all the 4 operations. So the elements in that sub-matrix will be maximum which is equal to 2 x 2=4 elements.\\nDid you understand the pattern of increment? No matter how many elements we increase, the sub-matrix with the smallest dimensions will always have the max elements. \\nSo the problem just reduces to finding out the sub-matrix with the smallest dimensions. For that, we require the minimum element from both the first and second fields of the ops array. Let\\'s take an example:\\nIf we have an ops array like this - [[1,3],[4,2],[2,3],[3,3],[2,2]] , the minimum element from the 1st field is 1 (min(1,4,2,3,2)) and from the 2nd field is also 2 (min(3,2,3,3,2)). So the answer is 1 x 2=2. That\\'s it!!\\n\\nNow that you know the approach, give it a try. If you still don\\'t get it, feel free to refer to this solution -\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3108808/easiest-c-solution/"
                    },
                    {
                        "username": "meanup",
                        "content": "Well explained. Thank you."
                    },
                    {
                        "username": "pstanton",
                        "content": "I found it a little difficult to wrap my head around the solution, so here it is restated maybe a little simpler.\\n\\nThe thing is you **do not have to** compute all the operations as laid out in the problem. You only have to find out the number of cells with the highest value. Each input operation species dimensions x and y, and all cells in those bounds get incremented by one. To get the answer, you have to find the **smallest** set of dimensions, x and y, which are included in the input array, which is why you use Math.min() to compare with op[0] and op[1]. If those two are smaller than m and n, the bounds shrink. \\n\\nAt the end, you will have an m and n which describe the length of the rectangle\\'s horizontal and vertical dimensions. You can then mutiply them together to get the area of the max-value rectangle.\\n"
                    },
                    {
                        "username": "noblemanfreeman",
                        "content": "you actually do not need m and n if \"ops\" is empty"
                    },
                    {
                        "username": "that_himanshu",
                        "content": "it\\'s really easy Once you get it"
                    },
                    {
                        "username": "user5400vw",
                        "content": "TIL:  easy does not necessarily mean brute force is allowed :)"
                    },
                    {
                        "username": "Saurav_Singh_Rautela",
                        "content": "`Linear Solution O(N), Constant Space: `\\nhttps://leetcode.com/problems/range-addition-ii/solutions/3893230/linear-sollution-o-n-beats-100-runtime-full-explanation/"
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "Move to Medium \\uD83E\\uDD27"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Memory limit exceeded..... i don\\'t think this should be an easy problem"
                    },
                    {
                        "username": "Fich90",
                        "content": "BS problem ..."
                    }
                ]
            }
        ]
    }
]