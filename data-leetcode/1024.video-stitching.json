[
    {
        "title": "Video Stitching",
        "question_content": "You are given a series of video clips from a sporting event that lasted time seconds. These video clips can be overlapping with each other and have varying lengths.\nEach video clip is described by an array clips where clips[i] = [starti, endi] indicates that the ith clip started at starti and ended at endi.\nWe can cut these clips into segments freely.\n\tFor example, a clip [0, 7] can be cut into segments [0, 1] + [1, 3] + [3, 7].\nReturn the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event [0, time]. If the task is impossible, return -1.\n&nbsp;\nExample 1:\nInput: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10\nOutput: 3\nExplanation: We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.\nThen, we can reconstruct the sporting event as follows:\nWe cut [1,9] into segments [1,2] + [2,8] + [8,9].\nNow we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].\nExample 2:\nInput: clips = [[0,1],[1,2]], time = 5\nOutput: -1\nExplanation: We cannot cover [0,5] with only [0,1] and [1,2].\nExample 3:\nInput: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], time = 9\nOutput: 3\nExplanation: We can take clips [0,4], [4,7], and [6,9].\n&nbsp;\nConstraints:\n\t1 <= clips.length <= 100\n\t0 <= starti <= endi <= 100\n\t1 <= time <= 100",
        "solutions": [
            {
                "id": 270036,
                "title": "java-c-python-greedy-solution-o-1-space",
                "content": "## Solution 1: Sort\\n\\nTime `O(NlogN)`, Space `O(1)`\\n**Java**\\n```\\n    public int videoStitching(int[][] clips, int T) {\\n        int res = 0;\\n        Arrays.sort(clips, (a,b) ->  a[0] - b[0]);\\n        for (int i = 0, st = 0, end = 0; st < T; st = end, ++res) {\\n            for (; i < clips.length && clips[i][0] <= st; ++i)\\n                end = Math.max(end, clips[i][1]);\\n            if (st == end) return -1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(begin(clips), end(clips));\\n        int res = 0;\\n        for (auto i = 0, st = 0, end = 0; st < T; st = end, ++res) {\\n            for (; i < clips.size() && clips[i][0] <= st; ++i)\\n                end = max(end, clips[i][1]);\\n            if (st == end) return -1;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```\\n    def videoStitching(self, clips, T):\\n        end, end2, res = -1, 0, 0\\n        for i, j in sorted(clips):\\n            if end2 >= T or i > end2:\\n                break\\n            elif end < i <= end2:\\n                res, end = res + 1, end2\\n            end2 = max(end2, j)\\n        return res if end2 >= T else -1\\n```\\n\\n<br>\\n\\n## Solution 2: Sort + DP\\nSort clips first.\\nThen for each clip, update `dp[clip[0]] ~ dp[clip[1]]`.\\n\\nTime `O(NlogN + NT)`, Space `O(T)`\\n\\n**C++**\\n```\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(), clips.end());\\n        vector<int> dp(101, 101);\\n        dp[0] = 0;\\n        for (auto& c : clips)\\n            for (int i = c[0] + 1; i <= c[1]; i++)\\n                dp[i] = min(dp[i], dp[c[0]] + 1);\\n        return dp[T] >= 100 ? -1 : dp[T];\\n    }\\n```\\n\\n<br>\\n\\n## Solution 3: DP\\n\\nLoop on i form `0` to `T`,\\nloop on all `clips`,\\nIf `clip[0] <= i  <= clip[1]`, we update `dp[i]`\\n\\nTime `O(NT)`, Space `O(T)`\\n\\n**Java**\\n```\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T + 1];\\n        Arrays.fill(dp, T + 1);\\n        dp[0] = 0;\\n        for (int i = 1; i <= T && dp[i - 1] < T; i++) {\\n            for (int[] c : clips) {\\n                if (c[0] <= i && i <= c[1])\\n                    dp[i] = Math.min(dp[i], dp[c[0]] + 1);\\n            }\\n        }\\n        return dp[T] == T + 1 ? -1 : dp[T];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int videoStitching(int[][] clips, int T) {\\n        int res = 0;\\n        Arrays.sort(clips, (a,b) ->  a[0] - b[0]);\\n        for (int i = 0, st = 0, end = 0; st < T; st = end, ++res) {\\n            for (; i < clips.length && clips[i][0] <= st; ++i)\\n                end = Math.max(end, clips[i][1]);\\n            if (st == end) return -1;\\n        }\\n        return res;\\n    }\\n```\n```\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(begin(clips), end(clips));\\n        int res = 0;\\n        for (auto i = 0, st = 0, end = 0; st < T; st = end, ++res) {\\n            for (; i < clips.size() && clips[i][0] <= st; ++i)\\n                end = max(end, clips[i][1]);\\n            if (st == end) return -1;\\n        }\\n        return res;\\n    }\\n```\n```\\n    def videoStitching(self, clips, T):\\n        end, end2, res = -1, 0, 0\\n        for i, j in sorted(clips):\\n            if end2 >= T or i > end2:\\n                break\\n            elif end < i <= end2:\\n                res, end = res + 1, end2\\n            end2 = max(end2, j)\\n        return res if end2 >= T else -1\\n```\n```\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(), clips.end());\\n        vector<int> dp(101, 101);\\n        dp[0] = 0;\\n        for (auto& c : clips)\\n            for (int i = c[0] + 1; i <= c[1]; i++)\\n                dp[i] = min(dp[i], dp[c[0]] + 1);\\n        return dp[T] >= 100 ? -1 : dp[T];\\n    }\\n```\n```\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T + 1];\\n        Arrays.fill(dp, T + 1);\\n        dp[0] = 0;\\n        for (int i = 1; i <= T && dp[i - 1] < T; i++) {\\n            for (int[] c : clips) {\\n                if (c[0] <= i && i <= c[1])\\n                    dp[i] = Math.min(dp[i], dp[c[0]] + 1);\\n            }\\n        }\\n        return dp[T] == T + 1 ? -1 : dp[T];\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 269988,
                "title": "c-java-6-lines-o-n-log-n",
                "content": "# Intuition\\nWe track our current stitching position (```st```). For each iteration, we check all overlapping clips, and pick the one that advances our stitching position the furthest.\\n# Solution\\nWe sort our clips by the starting point. Since clips are sorted, we need to only analyze each clip once. For each round, we check all overlapping clips (```clips[i][0] <= st```) and advance our stitching position as far as we can (```end = max(end, clips[i][1])```).\\n\\nReturn ```-1``` if we cannot advance our stitching position (```st == end```).\\n```\\nint videoStitching(vector<vector<int>>& clips, int T, int res = 0) {\\n  sort(begin(clips), end(clips));\\n  for (auto i = 0, st = 0, end = 0; st < T; st = end, ++res) {\\n    while (i < clips.size() && clips[i][0] <= st) end = max(end, clips[i++][1]);\\n    if (st == end) return -1;\\n  }\\n  return res;\\n}\\n```\\nJava version:\\n```\\npublic int videoStitching(int[][] clips, int T) {\\n  int res = 0;\\n  Arrays.sort(clips, new Comparator<int[]>() {\\n    public int compare(int[] a, int[] b) { return a[0] - b[0]; }\\n  });\\n  for (int i = 0, st = 0, end = 0; st < T; st = end, ++res) {\\n    for (; i < clips.length && clips[i][0] <= st; ++i)\\n      end = Math.max(end, clips[i][1]);\\n    if (st == end) return -1;\\n  }\\n  return res;\\n}\\n```\\n# Complexity Analysis\\nRuntime: *O(n log n)*, where n is the number of clips. We sort all clips, and then processing each clip only once.\\nMemory: *O(1)*.",
                "solutionTags": [],
                "code": "```st```\n```clips[i][0] <= st```\n```end = max(end, clips[i][1])```\n```-1```\n```st == end```\n```\\nint videoStitching(vector<vector<int>>& clips, int T, int res = 0) {\\n  sort(begin(clips), end(clips));\\n  for (auto i = 0, st = 0, end = 0; st < T; st = end, ++res) {\\n    while (i < clips.size() && clips[i][0] <= st) end = max(end, clips[i++][1]);\\n    if (st == end) return -1;\\n  }\\n  return res;\\n}\\n```\n```\\npublic int videoStitching(int[][] clips, int T) {\\n  int res = 0;\\n  Arrays.sort(clips, new Comparator<int[]>() {\\n    public int compare(int[] a, int[] b) { return a[0] - b[0]; }\\n  });\\n  for (int i = 0, st = 0, end = 0; st < T; st = end, ++res) {\\n    for (; i < clips.length && clips[i][0] <= st; ++i)\\n      end = Math.max(end, clips[i][1]);\\n    if (st == end) return -1;\\n  }\\n  return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270680,
                "title": "c-o-n-no-sorting-greedy-explained",
                "content": "**Observation 1:** We will always pick a clip with the maximum coverage if they have same starting points.\\n\\neg: [0,3],[0,7],[0,5] -> We pick [0,7] , there is no point of picking others as the problem states that we need to minimize the number of clips picked, and this can only be done if we maximize the gap between start and end point of each clip.\\n\\n**Observation 2:** Once we start picking the clips from the minimum starting point, we only increase the count if we find a starting point greater than previously selected clip\\'s end, from then on we keep maximizing the reachable end without increasing count.\\n\\neg: [[0,4],[1,4],[2,6],[3,4],[4,7],[5,7],[6,9]], T=9\\n\\n* We select [0,4], count=1 ,selectedEnd=0,reachableEnd=4\\n* We select [1,4], start > selectedEnd we increase count=2 and reachableEnd=4, selectedEnd=4 (Previously selected end)\\n* We encounter [2,6], we increase rechableEnd=6, we don\\'t increase count asthe clip\\'s starting point is still between [0,4] (previously selected clip)\\n* Similarly We encounter [4,7], we increase reachableEnd=7.\\n* When we reach [5,7] increase count=3 as 5 > [0,4] interval\\'s end (It is here that we decide that the previously selected interval is actually [4,7] and not [1,4] where we actually increased count(step 2))\\n* We encounter [6,7] increase reachableEnd=7 and return count=3.\\n\\n```c++\\n// Similar to find #55 Jump game with count of selected indices\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n        unordered_map<int,int> max_ends(clips.size());\\n        for(vector<int> &clip:clips)                                            //Get max end for each starting point.\\n            max_ends[clip[0]]=max(max_ends[clip[0]],clip[1]);\\n        int selectedEnd=-1,reachableEnd=0,count=0;\\n        for(int i=0;i<=T;i++)\\n        {\\n            if(reachableEnd>=T||i>reachableEnd)        //If there is a break between clips or we already reached the end, return\\n                break;\\n            if(max_ends.count(i))                                 //If clip with i as starting point exists.\\n            {\\n                if(i>selectedEnd)                   //Increase the count if starting point is greater than previously selected clip end\\n                    count++,selectedEnd=reachableEnd;              //New selected clip ends at max end\\n                reachableEnd=max(reachableEnd,max_ends[i]);//Maximize reachable end till starting point is less than or equal to previously selected clip\\n            }\\n        }\\n        return reachableEnd>=T?count:-1;\\n    }\\n};\\n```\\n\\nSince, in the worst case clips.length<=100 and T<=100 O(T)=O(n)",
                "solutionTags": [],
                "code": "```c++\\n// Similar to find #55 Jump game with count of selected indices\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n        unordered_map<int,int> max_ends(clips.size());\\n        for(vector<int> &clip:clips)                                            //Get max end for each starting point.\\n            max_ends[clip[0]]=max(max_ends[clip[0]],clip[1]);\\n        int selectedEnd=-1,reachableEnd=0,count=0;\\n        for(int i=0;i<=T;i++)\\n        {\\n            if(reachableEnd>=T||i>reachableEnd)        //If there is a break between clips or we already reached the end, return\\n                break;\\n            if(max_ends.count(i))                                 //If clip with i as starting point exists.\\n            {\\n                if(i>selectedEnd)                   //Increase the count if starting point is greater than previously selected clip end\\n                    count++,selectedEnd=reachableEnd;              //New selected clip ends at max end\\n                reachableEnd=max(reachableEnd,max_ends[i]);//Maximize reachable end till starting point is less than or equal to previously selected clip\\n            }\\n        }\\n        return reachableEnd>=T?count:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707876,
                "title": "c-dp-solution-explained-thoroughly",
                "content": "**C++ Solution**\\n\\n`dp[i]` here means the minimum number of clips needed to atleast cover ith time .\\nFor Eg : `dp[3]` gives the number of clips required to atleast cover a time of 3.\\nSo returning a `dp[T]` is needed.\\n\\n**If condition requirement  `if(clip[0] <= i && i <= clip[1])` :** \\nThis If condition checks if the taken video clip\\'s starting time is smaller or equal to the `i`(which represents the max time for the clip to run or the least time we need to cover).\\n\\n`dp[i] = min(dp[i], dp[clip[0]] + 1);` tells that if we find a clip whose starting time is smaller than ith time and ending time is bigger than ith time. Then we can effectively take this clip for our use and check if this gives us minimum answer.\\nWe take the amount of clips required till starting time of taken clip and then add 1 to it.\\n\\nEnjoy :)\\n\\n```\\nint videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        vector<int> dp(T+2,T+1);\\n        dp[0] = 0;\\n        for(int i=0;i<=T;i++){\\n            for(auto clip : clips){\\n                if(clip[0] <= i && i <= clip[1]){\\n                    dp[i] = min(dp[i], dp[clip[0]] + 1);\\n                }\\n            }\\n            if(dp[i] >= T+1) return -1;\\n        }\\n        return dp[T];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nint videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        vector<int> dp(T+2,T+1);\\n        dp[0] = 0;\\n        for(int i=0;i<=T;i++){\\n            for(auto clip : clips){\\n                if(clip[0] <= i && i <= clip[1]){\\n                    dp[i] = min(dp[i], dp[clip[0]] + 1);\\n                }\\n            }\\n            if(dp[i] >= T+1) return -1;\\n        }\\n        return dp[T];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270350,
                "title": "java-dp-short-solution",
                "content": "```\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T+ 1];\\n        Arrays.fill(dp, T+1);\\n        dp[0] = 0;\\n        for(int i = 0; i <= T; i++) {\\n            for(int[] c : clips) {\\n                if(i >= c[0] && i <= c[1]) dp[i] = Math.min(dp[i], dp[c[0]] + 1);\\n            }\\n            if(dp[i] == T+1) return -1;\\n        }\\n        return dp[T];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T+ 1];\\n        Arrays.fill(dp, T+1);\\n        dp[0] = 0;\\n        for(int i = 0; i <= T; i++) {\\n            for(int[] c : clips) {\\n                if(i >= c[0] && i <= c[1]) dp[i] = Math.min(dp[i], dp[c[0]] + 1);\\n            }\\n            if(dp[i] == T+1) return -1;\\n        }\\n        return dp[T];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 269984,
                "title": "java-o-n-lgn-greedy",
                "content": "http://www.noteanddata.com/leetcode-5019-Video-Stitching-java-solution-note.html\\n\\n```\\n      public int videoStitching(int[][] clips, int T) {\\n          Arrays.sort(clips, new Comparator<int[]>() {\\n              public int compare(int[] a, int[] b) {\\n                  return a[0]-b[0];\\n              }\\n          });    \\n          int count = 0;\\n          int curend = 0;\\n          int laststart = -1;\\n          \\n          for(int i = 0; i < clips.length; ) {\\n              if(clips[i][0] > curend) {\\n                  return -1;\\n              }\\n              int maxend = curend;\\n              while(i < clips.length && clips[i][0] <= curend) { // while one clip\\'s start is before or equal to current end\\n                  maxend = Math.max(maxend, clips[i][1]); // find out the one with the max possible end\\n                  i++;\\n              }\\n              count++;\\n              curend = maxend;\\n              if(curend >= T) {\\n                  return count;    \\n              }\\n          }\\n          return -1;        \\n      }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n      public int videoStitching(int[][] clips, int T) {\\n          Arrays.sort(clips, new Comparator<int[]>() {\\n              public int compare(int[] a, int[] b) {\\n                  return a[0]-b[0];\\n              }\\n          });    \\n          int count = 0;\\n          int curend = 0;\\n          int laststart = -1;\\n          \\n          for(int i = 0; i < clips.length; ) {\\n              if(clips[i][0] > curend) {\\n                  return -1;\\n              }\\n              int maxend = curend;\\n              while(i < clips.length && clips[i][0] <= curend) { // while one clip\\'s start is before or equal to current end\\n                  maxend = Math.max(maxend, clips[i][1]); // find out the one with the max possible end\\n                  i++;\\n              }\\n              count++;\\n              curend = maxend;\\n              if(curend >= T) {\\n                  return count;    \\n              }\\n          }\\n          return -1;        \\n      }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 269976,
                "title": "screencast-of-leetcode-weekly-contest-131",
                "content": "https://www.youtube.com/watch?v=sO1OVZFA_fE&feature=youtu.be\\n\\nAfter weeks of bad performance, I finally gain some confidence this time. Thanks",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=sO1OVZFA_fE&feature=youtu.be\\n\\nAfter weeks of bad performance, I finally gain some confidence this time. Thanks",
                "codeTag": "Unknown"
            },
            {
                "id": 484877,
                "title": "python-24-ms-beats-99-jump-game-ii-o-n-time-o-1-memory",
                "content": "Idea: \\n1. Convert `clips` to the furthest point you can jump from each point. O(N)\\n2. Do a jump game O(N).\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        max_jumps = [0]*101\\n        for l,r in clips:\\n            max_jumps[l] = max(max_jumps[l], r)\\n            \\n        # it is then a jump game\\n\\t\\tres = lo = hi = 0\\n        while hi < T:\\n            lo, hi = hi, max(max_jumps[lo:hi+1])\\n            if hi <= lo: return -1\\n            res += 1\\n        return res\\n\\t\\t# AC: 24 ms, beats 99%\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        max_jumps = [0]*101\\n        for l,r in clips:\\n            max_jumps[l] = max(max_jumps[l], r)\\n            \\n        # it is then a jump game\\n\\t\\tres = lo = hi = 0\\n        while hi < T:\\n            lo, hi = hi, max(max_jumps[lo:hi+1])\\n            if hi <= lo: return -1\\n            res += 1\\n        return res\\n\\t\\t# AC: 24 ms, beats 99%\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273347,
                "title": "python-greedy",
                "content": "The intuitve heuristic is that we iterate clips with order by their starting time and keep increasing furthest ending time we can reach.\\n\\nIf the starting time of current clips is later than current furthest ending time, then stitching is not doable since none of the rest clips\\' starting time is earlier. Once furthest ending time >= T, we have finished video stitching.\\n\\nAnd to get the minimal number of clips we need, we need to remove all unncessary clips during the scan. \\nSuppose we already have clips ```[s0, e0]``` and next two clips are ```[s1, e1]``` and ```[s2, e2]```. If ```s2 <= e0```, then ```s0 <= s1 <= s2 <= e0 ``` and only one of two clips are needed. Thus, we use ```prev_end``` to store ```e0``` and each time ```s <= prev_end```, we don\\'t add up ```cnt```. Othwise, we have to add one more clip and update ```prev_end``` accordingly. The furthest ending time just gets updated each time as ```max(furthest_end, e)```.\\n```\\ndef videoStitching(clips, T):\\n\\tprev_end, end, cnt = -1, 0, 0\\n\\tfor i, j in sorted(clips):\\n\\t\\tif i > end or end >= T: break\\n\\t\\tif prev_end < i <= end: prev_end, cnt = end, cnt + 1\\n\\t\\tend = max(end, j)\\n\\treturn cnt if end >= T else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```[s0, e0]```\n```[s1, e1]```\n```[s2, e2]```\n```s2 <= e0```\n```s0 <= s1 <= s2 <= e0 ```\n```prev_end```\n```e0```\n```s <= prev_end```\n```cnt```\n```prev_end```\n```max(furthest_end, e)```\n```\\ndef videoStitching(clips, T):\\n\\tprev_end, end, cnt = -1, 0, 0\\n\\tfor i, j in sorted(clips):\\n\\t\\tif i > end or end >= T: break\\n\\t\\tif prev_end < i <= end: prev_end, cnt = end, cnt + 1\\n\\t\\tend = max(end, j)\\n\\treturn cnt if end >= T else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 270149,
                "title": "c-dp-solution-very-similar-to-minimum-number-of-refueling-stops",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        int i, j;\\n        /*\\n            dp[i] refers to the furthest valid duration that could be\\n            gained with i clips\\n            dp[i] = max(dp[i-1], clips[j][1] which clips[j][0] <= dp[i])\\n        */\\n        \\n        vector<int> dp = vector<int>(n + 1, -1);\\n        dp[0] = 0;\\n        for (i = 1; i <= n; i++) {\\n            dp[i] = dp[i-1];\\n            for (j = 0; j < n; j++) {\\n                if (clips[j][0] <= dp[i-1]) {\\n                    dp[i] = max(dp[i], clips[j][1]);\\n                }\\n            }\\n        }\\n        /*\\n\\t\\t\\twe get the smallest i such that dp[i] >= T\\n\\t\\t*/\\n        for (i = 1; i <= n; i++) {\\n            if (dp[i] >= T) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        int i, j;\\n        /*\\n            dp[i] refers to the furthest valid duration that could be\\n            gained with i clips\\n            dp[i] = max(dp[i-1], clips[j][1] which clips[j][0] <= dp[i])\\n        */\\n        \\n        vector<int> dp = vector<int>(n + 1, -1);\\n        dp[0] = 0;\\n        for (i = 1; i <= n; i++) {\\n            dp[i] = dp[i-1];\\n            for (j = 0; j < n; j++) {\\n                if (clips[j][0] <= dp[i-1]) {\\n                    dp[i] = max(dp[i], clips[j][1]);\\n                }\\n            }\\n        }\\n        /*\\n\\t\\t\\twe get the smallest i such that dp[i] >= T\\n\\t\\t*/\\n        for (i = 1; i <= n; i++) {\\n            if (dp[i] >= T) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270070,
                "title": "easy-solution-with-step-by-step-explanation",
                "content": "Take clips with maximum  ends at time one by one\\nFor example, `clips = [[0,2],[4,6],[0,1],[8,10],[1,9],[1,5],[5,9],[1,3]], T = 10`\\nLet\\'s set `start=0`\\n1. We take `[0,2]`, because it has maximum ends time between the clips (`[0,2],[0,1]`) whose starts are smaller or equal to `start` (which is `0` by now). set `start=2` end time of the selected clip(`[0,2]`)\\n2. Now we take `[1,9]`, since it has maximum ends time (`9`) between the clips whose starts are smaller or equal to `start` (which is `2` by now). set `start=9`\\n3. Finally, we take `[8,10]` with the same reason above.\\nResult is `3`.\\n```\\nvar videoStitching = function(clips, T) {\\n  let canCover = false;\\n  for(let i=0;i<clips.length;i++) {\\n    if(clips[i][1]>=T) canCover = true;\\n  }\\n  if(!canCover) return -1;\\n  \\n  let start = 0, s=0;\\n  while(start<T) {\\n    let max=-1, index=-1;\\n    for(let i=0;i<clips.length;i++) {\\n      if(clips[i][0]<=start && max<clips[i][1]) {\\n        max = clips[i][1];\\n        index = i;\\n      }\\n    }\\n    if(index==-1) return -1;\\n    start = clips[index][1];\\n    //console.log(start,clips[index],s);\\n    s++;\\n  }\\n  return s;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar videoStitching = function(clips, T) {\\n  let canCover = false;\\n  for(let i=0;i<clips.length;i++) {\\n    if(clips[i][1]>=T) canCover = true;\\n  }\\n  if(!canCover) return -1;\\n  \\n  let start = 0, s=0;\\n  while(start<T) {\\n    let max=-1, index=-1;\\n    for(let i=0;i<clips.length;i++) {\\n      if(clips[i][0]<=start && max<clips[i][1]) {\\n        max = clips[i][1];\\n        index = i;\\n      }\\n    }\\n    if(index==-1) return -1;\\n    start = clips[index][1];\\n    //console.log(start,clips[index],s);\\n    s++;\\n  }\\n  return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 269964,
                "title": "python-solution-based-on-sorting-and-end-time",
                "content": "The solution is a bit similar to 435. https://leetcode.com/problems/non-overlapping-intervals/\\n\\nThe idea is, to keep gathering intervals in a result list.\\n\\nthe different cases are:\\n\\n1. If the interval is covering a point not covered by the result list, add it to the result.\\n2. If its leaving a gap, then we cant fill that gap, hence return -1\\n3. If its overlapping, based on end time, \\n\\ta) we can either discard this one, or \\n\\tb) include this one and replace the last interval of the result or\\n\\tc) append this one \\n```\\n    def videoStitching(self, clips, T):\\n        timepoint = namedtuple(\\'timepoint\\', [\\'start\\', \\'end\\'])\\n        times = sorted([timepoint(clip[0], clip[1]) for i, clip in enumerate(clips)])\\n        res = [times[0]]\\n        for time in times:\\n            if res[-1].end >= T or time.start > res[-1].end:\\n                break\\n            if time.start == res[-1].start and time.end > res[-1].end:\\n                res[-1] = time\\n            elif time.end <= res[-1].end:\\n                continue\\n            elif time.start <= res[-1].start:\\n                res[-1] = timepoint(res[-1].start, time.end)\\n            else:\\n                res.append(timepoint(res[-1].end, time.end))\\n        return len(res) if res[0].start == 0 and res[-1].end >= T else -1\\n```",
                "solutionTags": [],
                "code": "```\\n    def videoStitching(self, clips, T):\\n        timepoint = namedtuple(\\'timepoint\\', [\\'start\\', \\'end\\'])\\n        times = sorted([timepoint(clip[0], clip[1]) for i, clip in enumerate(clips)])\\n        res = [times[0]]\\n        for time in times:\\n            if res[-1].end >= T or time.start > res[-1].end:\\n                break\\n            if time.start == res[-1].start and time.end > res[-1].end:\\n                res[-1] = time\\n            elif time.end <= res[-1].end:\\n                continue\\n            elif time.start <= res[-1].start:\\n                res[-1] = timepoint(res[-1].start, time.end)\\n            else:\\n                res.append(timepoint(res[-1].end, time.end))\\n        return len(res) if res[0].start == 0 and res[-1].end >= T else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1307648,
                "title": "from-recursion-to-dp-greedy-5-solutions-java",
                "content": "**Solutions**\\nN = size of clips array\\nT = time\\n\\n**1. Recursion**\\nTime complexity: O(2^N)\\nSpace complexity: O(N)\\n\\n```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        // sort the clips by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        return recurse(clips, time, clips.length);\\n    }\\n    \\n    private int recurse(int[][] clips, int time, int size) {\\n        // base case\\n        if (time == 0) {\\n            return 0;\\n        }\\n        else if (size == 0) {\\n            return -1;\\n        }\\n        \\n        // skip the current clip\\n        int skip = recurse(clips, time, size - 1);\\n        \\n        // take the current clip is possible\\n        int[] newClip = clips[size - 1];\\n        int take = -1;\\n        if (newClip[0] < time && newClip[1] >= time) {\\n            take = recurse(clips, newClip[0], size - 1);\\n        }\\n        \\n        // return the optimal result\\n        int res = -1;\\n        if (skip == -1 && take != -1) {\\n            res = 1 + take;\\n        }\\n        else if (skip != -1 && take == -1){\\n            res = skip;\\n        }\\n        else if (skip != -1 && take != -1) {\\n            res = Math.min(skip, 1 + take);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**2. Memoization (Top-Down)**\\nTime complexity: O(N * T)\\nSpace complexity: O(N * T)\\n\\n```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        // initialize dp table\\n        Integer[][] dp = new Integer[time + 1][clips.length + 1];\\n        for (Integer[] row: dp) {\\n            row[0] = -1;\\n        }\\n        Arrays.fill(dp[0], 0);\\n        \\n        // sort the clips by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        return recurse(clips, time, clips.length, dp);\\n    }\\n    \\n    private int recurse(int[][] clips, int time, int size, Integer[][] dp) {\\n        // check dp table\\n        if (dp[time][size] != null) {\\n            return dp[time][size];\\n        }\\n        \\n        // skip the current clip\\n        int skip = recurse(clips, time, size - 1, dp);\\n        \\n        // take the current clip is possible\\n        int[] newClip = clips[size - 1];\\n        int take = -1;\\n        if (newClip[0] < time && newClip[1] >= time) {\\n            take = recurse(clips, newClip[0], size - 1, dp);\\n        }\\n        \\n        // return the optimal result\\n        int res = -1;\\n        if (skip == -1 && take != -1) {\\n            res = 1 + take;\\n        }\\n        else if (skip != -1 && take == -1){\\n            res = skip;\\n        }\\n        else if (skip != -1 && take != -1) {\\n            res = Math.min(skip, 1 + take);\\n        }\\n        \\n        // update dp table\\n        dp[time][size] = res;\\n        return res;\\n    }\\n}\\n```\\n\\n**3. Tabulation (Bottom-Up)**\\nTime complexity: O(N * T)\\nSpace complexity: O(N * T)\\n\\n```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        // initialize dp table\\n        Integer[][] dp = new Integer[time + 1][clips.length + 1];\\n        for (Integer[] row: dp) {\\n            row[0] = -1;\\n        }\\n        Arrays.fill(dp[0], 0);\\n        \\n        // sort the clips by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        // bottom-up\\n        for (int t = 1; t <= time; t++) {\\n            for (int s = 1; s <= clips.length; s++) {\\n                // skip the current clip\\n                int skip = dp[t][s - 1];\\n\\n                // take the current clip is possible\\n                int[] newClip = clips[s - 1];\\n                int take = -1;\\n                if (newClip[0] < t && newClip[1] >= t) {\\n                    take = dp[newClip[0]][s - 1];\\n                }\\n\\n                // return the optimal result\\n                int res = -1;\\n                if (skip == -1 && take != -1) {\\n                    res = 1 + take;\\n                }\\n                else if (skip != -1 && take == -1){\\n                    res = skip;\\n                }\\n                else if (skip != -1 && take != -1) {\\n                    res = Math.min(skip, 1 + take);\\n                }\\n\\n                // update dp table\\n                dp[t][s] = res;\\n            }\\n        }\\n        \\n        return dp[time][clips.length];\\n    }\\n}\\n```\\n\\n**4. Tabulation (Bottom-Up) with Space Optimization**\\nTime complexity: O(N * T)\\nSpace complexity: O(T)\\n\\n```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        // initialize dp table\\n        Integer[] dp = new Integer[time + 1];\\n        Arrays.fill(dp, -1);\\n        dp[0] = 0;\\n        \\n        // sort the clips by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        // bottom-up\\n        for (int s = 1; s <= clips.length; s++) {\\n            Integer[] prevDp = dp;\\n            dp = new Integer[time + 1];\\n            \\n            for (int t = 0; t <= time; t++) {\\n                if (t == 0) {\\n                    dp[t] = 0;\\n                    continue;\\n                }\\n                \\n                // skip the current clip\\n                int skip = prevDp[t];\\n\\n                // take the current clip is possible\\n                int[] newClip = clips[s - 1];\\n                int take = -1;\\n                if (newClip[0] < t && newClip[1] >= t) {\\n                    take = prevDp[newClip[0]];\\n                }\\n\\n                // return the optimal result\\n                int res = -1;\\n                if (skip == -1 && take != -1) {\\n                    res = 1 + take;\\n                }\\n                else if (skip != -1 && take == -1){\\n                    res = skip;\\n                }\\n                else if (skip != -1 && take != -1) {\\n                    res = Math.min(skip, 1 + take);\\n                }\\n\\n                // update dp table\\n                dp[t] = res;\\n            }\\n        }\\n        \\n        return dp[time];\\n    }\\n}\\n```\\n\\n**5. Greedy**\\nTime complexity: O(NlogN)\\nSpace complexity: O(1)\\n\\n```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        //sort array by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        int cur = 0;\\n        int low = 0;\\n        int count = 0;\\n        while (cur < clips.length && clips[cur][0] <= low && low < time) {\\n            int maxUp = 0;\\n            \\n            while (cur < clips.length && clips[cur][0] <= low) {\\n                maxUp = Math.max(maxUp, clips[cur][1]);\\n                cur++;\\n            }\\n            \\n            count++;\\n            low = maxUp;\\n        }\\n        \\n        return low >= time ? count : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        // sort the clips by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        return recurse(clips, time, clips.length);\\n    }\\n    \\n    private int recurse(int[][] clips, int time, int size) {\\n        // base case\\n        if (time == 0) {\\n            return 0;\\n        }\\n        else if (size == 0) {\\n            return -1;\\n        }\\n        \\n        // skip the current clip\\n        int skip = recurse(clips, time, size - 1);\\n        \\n        // take the current clip is possible\\n        int[] newClip = clips[size - 1];\\n        int take = -1;\\n        if (newClip[0] < time && newClip[1] >= time) {\\n            take = recurse(clips, newClip[0], size - 1);\\n        }\\n        \\n        // return the optimal result\\n        int res = -1;\\n        if (skip == -1 && take != -1) {\\n            res = 1 + take;\\n        }\\n        else if (skip != -1 && take == -1){\\n            res = skip;\\n        }\\n        else if (skip != -1 && take != -1) {\\n            res = Math.min(skip, 1 + take);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        // initialize dp table\\n        Integer[][] dp = new Integer[time + 1][clips.length + 1];\\n        for (Integer[] row: dp) {\\n            row[0] = -1;\\n        }\\n        Arrays.fill(dp[0], 0);\\n        \\n        // sort the clips by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        return recurse(clips, time, clips.length, dp);\\n    }\\n    \\n    private int recurse(int[][] clips, int time, int size, Integer[][] dp) {\\n        // check dp table\\n        if (dp[time][size] != null) {\\n            return dp[time][size];\\n        }\\n        \\n        // skip the current clip\\n        int skip = recurse(clips, time, size - 1, dp);\\n        \\n        // take the current clip is possible\\n        int[] newClip = clips[size - 1];\\n        int take = -1;\\n        if (newClip[0] < time && newClip[1] >= time) {\\n            take = recurse(clips, newClip[0], size - 1, dp);\\n        }\\n        \\n        // return the optimal result\\n        int res = -1;\\n        if (skip == -1 && take != -1) {\\n            res = 1 + take;\\n        }\\n        else if (skip != -1 && take == -1){\\n            res = skip;\\n        }\\n        else if (skip != -1 && take != -1) {\\n            res = Math.min(skip, 1 + take);\\n        }\\n        \\n        // update dp table\\n        dp[time][size] = res;\\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        // initialize dp table\\n        Integer[][] dp = new Integer[time + 1][clips.length + 1];\\n        for (Integer[] row: dp) {\\n            row[0] = -1;\\n        }\\n        Arrays.fill(dp[0], 0);\\n        \\n        // sort the clips by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        // bottom-up\\n        for (int t = 1; t <= time; t++) {\\n            for (int s = 1; s <= clips.length; s++) {\\n                // skip the current clip\\n                int skip = dp[t][s - 1];\\n\\n                // take the current clip is possible\\n                int[] newClip = clips[s - 1];\\n                int take = -1;\\n                if (newClip[0] < t && newClip[1] >= t) {\\n                    take = dp[newClip[0]][s - 1];\\n                }\\n\\n                // return the optimal result\\n                int res = -1;\\n                if (skip == -1 && take != -1) {\\n                    res = 1 + take;\\n                }\\n                else if (skip != -1 && take == -1){\\n                    res = skip;\\n                }\\n                else if (skip != -1 && take != -1) {\\n                    res = Math.min(skip, 1 + take);\\n                }\\n\\n                // update dp table\\n                dp[t][s] = res;\\n            }\\n        }\\n        \\n        return dp[time][clips.length];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        // initialize dp table\\n        Integer[] dp = new Integer[time + 1];\\n        Arrays.fill(dp, -1);\\n        dp[0] = 0;\\n        \\n        // sort the clips by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        // bottom-up\\n        for (int s = 1; s <= clips.length; s++) {\\n            Integer[] prevDp = dp;\\n            dp = new Integer[time + 1];\\n            \\n            for (int t = 0; t <= time; t++) {\\n                if (t == 0) {\\n                    dp[t] = 0;\\n                    continue;\\n                }\\n                \\n                // skip the current clip\\n                int skip = prevDp[t];\\n\\n                // take the current clip is possible\\n                int[] newClip = clips[s - 1];\\n                int take = -1;\\n                if (newClip[0] < t && newClip[1] >= t) {\\n                    take = prevDp[newClip[0]];\\n                }\\n\\n                // return the optimal result\\n                int res = -1;\\n                if (skip == -1 && take != -1) {\\n                    res = 1 + take;\\n                }\\n                else if (skip != -1 && take == -1){\\n                    res = skip;\\n                }\\n                else if (skip != -1 && take != -1) {\\n                    res = Math.min(skip, 1 + take);\\n                }\\n\\n                // update dp table\\n                dp[t] = res;\\n            }\\n        }\\n        \\n        return dp[time];\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        //sort array by start time\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        int cur = 0;\\n        int low = 0;\\n        int count = 0;\\n        while (cur < clips.length && clips[cur][0] <= low && low < time) {\\n            int maxUp = 0;\\n            \\n            while (cur < clips.length && clips[cur][0] <= low) {\\n                maxUp = Math.max(maxUp, clips[cur][1]);\\n                cur++;\\n            }\\n            \\n            count++;\\n            low = maxUp;\\n        }\\n        \\n        return low >= time ? count : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195564,
                "title": "recursion-memoization-in-c",
                "content": "class Solution {\\npublic:\\n\\n    vector<int>dp;\\n    int solve(vector<vector<int>>& clips, int T,int idx,int last_end)\\n    {\\n        if(T<=last_end)\\n            return 0;\\n        if(idx>=clips.size() )\\n            return 100;\\n        if(dp[last_end]!=-1)\\n            return dp[last_end];\\n         if(clips[idx][0]<=last_end)\\n        {\\n            return dp[last_end]=min(solve(clips,T,idx+1,last_end),1+solve(clips,T,idx+1,clips[idx][1]));\\n        }\\n        else\\n        {\\n            return dp[last_end]=100;\\n        }\\n           \\n    }\\n    int videoStitching(vector<vector<int>>& clips, int T)\\n    {\\n        dp.resize(T+1,-1);\\n        sort(clips.begin(),clips.end());\\n        int p=solve(clips,T,0,0);\\n        if(p>=100)\\n            return -1;\\n        else\\n            return p;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int>dp;\\n    int solve(vector<vector<int>>& clips, int T,int idx,int last_end)\\n    {\\n        if(T<=last_end)\\n            return 0;\\n        if(idx>=clips.size() )\\n            return 100;\\n        if(dp[last_end]!=-1)\\n            return dp[last_end];\\n         if(clips[idx][0]<=last_end)\\n        {\\n            return dp[last_end]=min(solve(clips,T,idx+1,last_end),1+solve(clips,T,idx+1,clips[idx][1]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 466261,
                "title": "python-short-dp-solution-with-explanation",
                "content": "Define `dp(i)` as the minimum number of clips needed to cover `[0, i]` sporting event.\\nWe\\'ll get the recursion below:\\n`dp(i) = min(dp(j) + 1, dp(i)) if the clip covers [j, i] exists`\\n\\n```python\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        dp = [float(\\'inf\\')] * (T + 1)\\n        dp[0] = 0\\n        for i in range(1, T + 1):\\n            for start, end in clips:\\n                if start <= i <= end:\\n                    dp[i] = min(dp[start] + 1, dp[i])\\n        if dp[T] == float(\\'inf\\'):\\n            return -1\\n        return dp[T]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        dp = [float(\\'inf\\')] * (T + 1)\\n        dp[0] = 0\\n        for i in range(1, T + 1):\\n            for start, end in clips:\\n                if start <= i <= end:\\n                    dp[i] = min(dp[start] + 1, dp[i])\\n        if dp[T] == float(\\'inf\\'):\\n            return -1\\n        return dp[T]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270054,
                "title": "java-simple-solution-without-sorting",
                "content": "```\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dic = new int[T+1];\\n        Arrays.fill(dic,-1);\\n        for(int j = 0; j < clips.length; j++){\\n            for(int i = clips[j][0]; i <= Math.min(T,clips[j][1]); i++) dic[i]=Math.max(dic[i],clips[j][1]);\\n        }        \\n        for(int i = 0; i <= T; i++){\\n            if(dic[i]==-1) return -1;\\n        }\\n        int cur = 0;\\n        int ans = 0;\\n        int max = 0;\\n        while(max<T){\\n            max= dic[cur];\\n            ans++;\\n            cur = max;\\n        } \\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dic = new int[T+1];\\n        Arrays.fill(dic,-1);\\n        for(int j = 0; j < clips.length; j++){\\n            for(int i = clips[j][0]; i <= Math.min(T,clips[j][1]); i++) dic[i]=Math.max(dic[i],clips[j][1]);\\n        }        \\n        for(int i = 0; i <= T; i++){\\n            if(dic[i]==-1) return -1;\\n        }\\n        int cur = 0;\\n        int ans = 0;\\n        int max = 0;\\n        while(max<T){\\n            max= dic[cur];\\n            ans++;\\n            cur = max;\\n        } \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3032762,
                "title": "python-3-11-lines-w-explanation-t-m-98-81",
                "content": "Here\\'s the plan:\\n- We sort `clip` by increasing `start` and then by decreasing `end` for those clips with same `start`.\\n- We initiate `t` to keep track of the`end`of the most recent clip we use. If and when `t` equals or exceeds `time`, we return the number of clips. If we run out of clips before that happens, then we return `-1`.\\n- We iterate through clips. First, grabbing the initial clip in the sorted list. Second, we discard all clips that end before that clip\\'s`end`. \\n- Third, we acrete all clips that start before `t` in `cSet`and then select from`cSet`the clip with the greatest`end`as the new most recent clip.\\n- Fouth, we increment`ans`, flush`cSet`, and check whether we are finished.\\n\\nNote: Originally I checked whether a clip starting at zero did actually exist, but the code passed without the check, so I removed it.\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n\\n        clips.sort(key = lambda x: (x[0],-x[1]))\\n        t, cSet, ans = 0, set(), 0\\n\\n        while clips:\\n            while clips and clips[0][1] <= t: clips.pop(0)\\n            while clips and clips[0][0] <= t: cSet.add(clips.pop(0)[1])\\n\\n            if clips and not cSet: return -1\\n            t = max(cSet)\\n            ans+= 1\\n            if t >= time: return ans \\n            cSet.clear()\\n\\n        return -1\\n```\\n[https://leetcode.com/problems/video-stitching/submissions/875736467/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*log*N*) and space complexity is worstcase *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n\\n        clips.sort(key = lambda x: (x[0],-x[1]))\\n        t, cSet, ans = 0, set(), 0\\n\\n        while clips:\\n            while clips and clips[0][1] <= t: clips.pop(0)\\n            while clips and clips[0][0] <= t: cSet.add(clips.pop(0)[1])\\n\\n            if clips and not cSet: return -1\\n            t = max(cSet)\\n            ans+= 1\\n            if t >= time: return ans \\n            cSet.clear()\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834720,
                "title": "java-greedy-solution",
                "content": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] arr = new int[T+1];\\n        \\n        for(int i = 0; i < clips.length; i++){\\n            int left = Math.min(T, clips[i][0]);\\n            int right = clips[i][1];\\n            \\n            arr[left] = Math.max(arr[left], right);\\n        }\\n        int currEnd = 0, currFarthest = 0, jumps = 0;\\n        \\n        for(int i = 0; i < arr.length; i++){\\n            if(i > currFarthest)return -1;\\n            \\n            currFarthest = Math.max(currFarthest, arr[i]);\\n            \\n            if(i == currEnd && i != T){\\n                currEnd = currFarthest;\\n                jumps++;\\n            }\\n        }\\n        //if(currFarthest < T)return -1;\\n        return jumps;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] arr = new int[T+1];\\n        \\n        for(int i = 0; i < clips.length; i++){\\n            int left = Math.min(T, clips[i][0]);\\n            int right = clips[i][1];\\n            \\n            arr[left] = Math.max(arr[left], right);\\n        }\\n        int currEnd = 0, currFarthest = 0, jumps = 0;\\n        \\n        for(int i = 0; i < arr.length; i++){\\n            if(i > currFarthest)return -1;\\n            \\n            currFarthest = Math.max(currFarthest, arr[i]);\\n            \\n            if(i == currEnd && i != T){\\n                currEnd = currFarthest;\\n                jumps++;\\n            }\\n        }\\n        //if(currFarthest < T)return -1;\\n        return jumps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806748,
                "title": "c-greedy-sorting-clean-code-similar-to-leetcode-1326",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n              sort(clips.begin(), clips.end());\\n              int n = clips.size();\\n              \\n              int start = 0, reach = 0, clips_req = 0;\\n        \\n              while(reach < time){\\n                  for(auto clip : clips){\\n                      if(start >= clip[0] && start <= clip[1]) reach = max(reach, clip[1]);\\n                  }\\n                  if(start == reach) return -1;\\n                  clips_req++;\\n                  start = reach;\\n              }\\n            return clips_req;\\n              \\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n              sort(clips.begin(), clips.end());\\n              int n = clips.size();\\n              \\n              int start = 0, reach = 0, clips_req = 0;\\n        \\n              while(reach < time){\\n                  for(auto clip : clips){\\n                      if(start >= clip[0] && start <= clip[1]) reach = max(reach, clip[1]);\\n                  }",
                "codeTag": "Java"
            },
            {
                "id": 284998,
                "title": "python-timeline-solution-easy-to-understand",
                "content": "Create a Timeline list, the index is each second of starting time, value is the largest end time can be reached at this second. Search the maximum of each starting-ending interval till the end or stay fixed. \\n```\\n        //input: [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T=10\\n\\t\\t\\n        maxlen = max([i[1] for i in clips])\\n        timeline = [0]*(maxlen+1)\\n        for clipstart, clipend in clips:\\n            timeline[clipstart] = max(timeline[clipstart], clipend)\\n\\t\\t\\t\\n        //Timeline looks like: [2, 9, 0, 0, 6, 9, 0, 0, 10, 0, 0]\\n        \\n        if timeline[0] == 0: return -1\\n        start = 0; end = timeline[0]; times = 1\\n        \\n        while end < T:\\n            maxpos, maxval = max(enumerate(timeline[start:end+1]), key=lambda x: x[1])\\n            if maxval > end:\\n                end = maxval\\n                start = maxpos\\n                times += 1\\n            else:\\n                return -1\\n        return times",
                "solutionTags": [
                    "Python"
                ],
                "code": "Create a Timeline list, the index is each second of starting time, value is the largest end time can be reached at this second. Search the maximum of each starting-ending interval till the end or stay fixed. \\n```\\n        //input: [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T=10\\n\\t\\t\\n        maxlen = max([i[1] for i in clips])\\n        timeline = [0]*(maxlen+1)\\n        for clipstart, clipend in clips:\\n            timeline[clipstart] = max(timeline[clipstart], clipend)\\n\\t\\t\\t\\n        //Timeline looks like: [2, 9, 0, 0, 6, 9, 0, 0, 10, 0, 0]\\n        \\n        if timeline[0] == 0: return -1\\n        start = 0; end = timeline[0]; times = 1\\n        \\n        while end < T:\\n            maxpos, maxval = max(enumerate(timeline[start:end+1]), key=lambda x: x[1])\\n            if maxval > end:\\n                end = maxval\\n                start = maxpos\\n                times += 1\\n            else:\\n                return -1\\n        return times",
                "codeTag": "Unknown"
            },
            {
                "id": 275270,
                "title": "c-beat-100-100",
                "content": "```\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(), clips.end());\\n        int cnt = 0, cur_end = 0, pre_end = -1;\\n        for(auto& v:clips){\\n            if(v[1] <= cur_end) continue;\\n            if(v[0] > cur_end) return -1;          \\n            if(v[0] > pre_end){\\n                pre_end = cur_end;\\n                cnt++;\\n            }\\n            cur_end = v[1];           \\n            if(cur_end >= T) return cnt;            \\n        }\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(), clips.end());\\n        int cnt = 0, cur_end = 0, pre_end = -1;\\n        for(auto& v:clips){\\n            if(v[1] <= cur_end) continue;\\n            if(v[0] > cur_end) return -1;          \\n            if(v[0] > pre_end){\\n                pre_end = cur_end;\\n                cnt++;\\n            }\\n            cur_end = v[1];           \\n            if(cur_end >= T) return cnt;            \\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1746819,
                "title": "easy-greedy-solution-c",
                "content": "![image](https://assets.leetcode.com/users/images/1fc7b07e-5d48-420a-9c57-dbfd58d71e4c_1644070483.8811798.jpeg)\\n\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/bda1f9a9-eb8c-40f8-b33f-91c87a7ecc09_1644070483.9485135.jpeg)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        \\n        int min=0, max=0, ans=0;\\n        \\n        while(max<time)\\n        {\\n            for(int i=0; i<clips.size(); i++)\\n            {\\n                int left=clips[i][0];\\n                int right=clips[i][1];\\n                \\n                if(left <= min && right> max)\\n                    max=right;\\n            }\\n            \\n            if(min==max)\\n                return -1;\\n            \\n            min=max;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        \\n        int min=0, max=0, ans=0;\\n        \\n        while(max<time)\\n        {\\n            for(int i=0; i<clips.size(); i++)\\n            {\\n                int left=clips[i][0];\\n                int right=clips[i][1];\\n                \\n                if(left <= min && right> max)\\n                    max=right;\\n            }\\n            \\n            if(min==max)\\n                return -1;\\n            \\n            min=max;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790479,
                "title": "javascript-solution-greedy-approach",
                "content": "```\\nvar videoStitching = function(clips, T) {\\n    const n = clips.length;\\n    \\n    clips.sort((a, b) => a[0] - b[0]);\\n    \\n    let stitching_start = 0;\\n    let stitching_end = 0;\\n    let videos_used = 0;\\n    let index = 0;\\n    \\n    while (stitching_start < T) {\\n        while (index < n && clips[index][0] <= stitching_start) { // find the longest video that starts before our stitching_start\\n            stitching_end = Math.max(stitching_end, clips[index][1]);\\n            index++;\\n        }\\n        if (stitching_start == stitching_end) return -1; // made no advancement\\n        \\n        videos_used++;\\n        stitching_start = stitching_end;\\n    }\\n    \\n    return videos_used;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nvar videoStitching = function(clips, T) {\\n    const n = clips.length;\\n    \\n    clips.sort((a, b) => a[0] - b[0]);\\n    \\n    let stitching_start = 0;\\n    let stitching_end = 0;\\n    let videos_used = 0;\\n    let index = 0;\\n    \\n    while (stitching_start < T) {\\n        while (index < n && clips[index][0] <= stitching_start) { // find the longest video that starts before our stitching_start\\n            stitching_end = Math.max(stitching_end, clips[index][1]);\\n            index++;\\n        }\\n        if (stitching_start == stitching_end) return -1; // made no advancement\\n        \\n        videos_used++;\\n        stitching_start = stitching_end;\\n    }\\n    \\n    return videos_used;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 582535,
                "title": "c-greedy-solution-faster-than-100-100-less-memory",
                "content": "class Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n      int S = 0;\\n        int end = 0;\\n        int count = 0;\\n        while(end<T){\\n        S= end;\\n        int temp = end;\\n        for(int i = 0;i<clips.size();i++){\\n            if(clips[i][0]<=S )\\n            end = max(end,clips[i][1]);\\n        }\\n        if(end == temp )\\n            return -1;\\n        cout<<end<<endl;\\n        count++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n      int S = 0;\\n        int end = 0;\\n        int count = 0;\\n        while(end<T){\\n        S= end;\\n        int temp = end;\\n        for(int i = 0;i<clips.size();i++){\\n            if(clips[i][0]<=S )\\n            end = max(end,clips[i][1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 392489,
                "title": "java-dp-no-magic-code",
                "content": "```\\n// dp[T] - holds the minimum number of clips required to get the T seconds clip length\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T+1];\\n        Arrays.fill(dp, T + 1); // fill with T + 1 to respect Math.min\\n        dp[0] = 0;\\n        for(int videoLen=1; videoLen <= T; videoLen++){\\n            for(int c=0; c < clips.length; c++){\\n                int clipStart = clips[c][0];\\n                int cliepEnd = clips[c][1];\\n                if(clipStart <= videoLen && cliepEnd >= videoLen){\\n                    dp[videoLen] = Math.min(dp[videoLen], 1 + dp[clipStart]);\\n                }\\n            }\\n        }\\n        return dp[T] == T+1 ? -1 : dp[T];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// dp[T] - holds the minimum number of clips required to get the T seconds clip length\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T+1];\\n        Arrays.fill(dp, T + 1); // fill with T + 1 to respect Math.min\\n        dp[0] = 0;\\n        for(int videoLen=1; videoLen <= T; videoLen++){\\n            for(int c=0; c < clips.length; c++){\\n                int clipStart = clips[c][0];\\n                int cliepEnd = clips[c][1];\\n                if(clipStart <= videoLen && cliepEnd >= videoLen){\\n                    dp[videoLen] = Math.min(dp[videoLen], 1 + dp[clipStart]);\\n                }\\n            }\\n        }\\n        return dp[T] == T+1 ? -1 : dp[T];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270909,
                "title": "easy-python-dp-solution",
                "content": "\\n```\\ndef videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        dp = [T+1]*(T+1)\\n        dp[0] = 0\\n        \\n        for i in range(T+1):\\n            for clip in clips:\\n                if i>= clip[0] and i<=clip[1]:\\n                    dp[i] = min(dp[i], dp[clip[0]]+1)\\n            if dp[i] == T+1:\\n                return -1\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        dp = [T+1]*(T+1)\\n        dp[0] = 0\\n        \\n        for i in range(T+1):\\n            for clip in clips:\\n                if i>= clip[0] and i<=clip[1]:\\n                    dp[i] = min(dp[i], dp[clip[0]]+1)\\n            if dp[i] == T+1:\\n                return -1\\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1650889,
                "title": "lessons-learned",
                "content": "**A problem that has many different approaches**. \\n\\n* **Bruteforce**: **Backtracking** approach by maintaining a clipCount and choose to pick a clip and don\\'t pick a clip. O(2^n) time ans O(n) space\\n* **Dp - non LIS (tricky in identifying dp parameters)**:\\n \\xA0* Defining the parameters of overlapping states is tricky here. \\n \\xA0* Initially, I used 1d dp[] caching on current video index. This is obviously wrong since there are 2 dynamic parameters \\'current clip index\\' and \\'previous clip end time\\'. **Always cache on dynamic parameters of the state**. Thus understood dp is 2d here.  \\n \\xA0* But then the code should be modified. The final answer shouldn\\'t be dp[0th clip][having 0 start time]. Instead should be dp[any clip][having 0 start time] due to the fact that there might be multiple source nodes (clips with 0 as start time). Thus a for loop in the final seems required.\\n \\xA0 * An good to note optimization here is\\xA0the current clip index is not a relevant parameter for dp. Only previous clip end time is enough. Thus reducing dp from 2d to 1d.\\nReason (not sure if this is the teal reason): at any current clip index, that index also happens to be neglected. At this time only previous clip end time is really valued. (Unclear, gotta redo)\\n* **Dp - LIS**: \\n \\xA0* O(n\\xB2) time and O(n) space. Maybe improved to O(nlogn) time using BS instead of linear search. Gotta check though.\\n * \\xA0[Reference](https://leetcode.com/problems/video-stitching/discuss/1265887/Java-LIS-DP-Solution)\\n* \\xA0**Greedy**: Most optimal. Similar to [min refuel stops](https://leetcode.com/problems/minimum-number-of-refueling-stops/discuss/) \\n* \\xA0**BFS**: since requirement is shortest path, solvable via bfs\\n* \\xA0**Binary search on answer space**: Not sure, but I feel so.\\n\\n**Code**:\\n```\\n// Dp: Optimized version of bactracking - Pick Or Don\\'t pick\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int clipLength = clips.length;\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        System.out.println(Arrays.deepToString(clips));\\n        int[] dp = new int[101];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        int index = 0;\\n        int prevClipEndTime = 0;\\n        int minimumClipsRequired = f(clips, time, dp, index, prevClipEndTime);\\n        return minimumClipsRequired;\\n    }\\n    \\n    private int f(int[][] clips, int targetTime, int[] dp, int index, int prevClipEndTime) {\\n        // BASE\\n        if (prevClipEndTime >= targetTime) return 0;\\n        if (index >= clips.length) return -1;\\n        if (prevClipEndTime < clips[index][0]) return -1;\\n        \\n        // CACHE OUT\\n        if (dp[prevClipEndTime] != Integer.MAX_VALUE) return dp[prevClipEndTime];\\n        \\n        // OPTIMAL SUBSTRUCTURE\\n        int min = Integer.MAX_VALUE;\\n        int val = f(clips, targetTime, dp, index + 1, clips[index][1]); // Pick clip\\n        if (val != -1) min = Math.min(min, val + 1);\\n        \\n        val = f(clips, targetTime, dp, index + 1, prevClipEndTime); // Dont pick clip\\n        if (val != -1) min = Math.min(min, val);\\n        \\n        // CACHE IN\\n        dp[prevClipEndTime] = min == Integer.MAX_VALUE ? -1 : min;\\n        \\n        // RETURN\\n        return dp[prevClipEndTime];\\n    }\\n}\\n/*\\n[[0,2],[2,6],[0,3],[6,9]]\\n9\\n*/\\n```\\n\\n```\\n// LIS\\nclass Solution {\\npublic int videoStitching(int[][] clips, int T) {\\n\\n    Arrays.sort(clips, (a,b) ->  a[0] - b[0]);\\n    \\n    //Finding maximum end time\\n    int max_end=-1;\\n    for(int i=0;i<clips.length;i++){\\n        max_end = Math.max(max_end, clips[i][1]);\\n    }\\n    \\n    //if end time is Less than Target time we can\\'t cover\\n    if(max_end < T){\\n        return -1;\\n    }\\n    \\n    \\n    int dp[] = new int[clips.length];\\n    Arrays.fill(dp, clips.length+1);\\n    // As start time is always 0 so marking clips with start time 0 as 1 in dp table \\n    // which means this can be considered.\\n    for(int i=0;i<clips.length;i++){\\n        if(clips[i][0] == 0){\\n            dp[i] = 1;\\n        }\\n    }\\n    // More or less it is same as LIS only difference is we are merging the intervals and\\n\\t// looking for minimum instead of Maximum.\\n    // Example two clips [0,2] [1,4] => it can be joined if 2 >= 1 and 4 >=2\\n    // Example two clips [0,1] [4,5] => it can\\'t be joined as 1 is not >= 4\\n    \\n    for(int i=1;i<clips.length;i++){\\n        for(int j=0;j<i;j++){\\n            int a = clips[j][0];\\n            int b = clips[j][1];\\n            int c = clips[i][0];\\n            int d = clips[i][1];       \\n            if(b >= c && d>=b){\\n                dp[i] = Math.min(dp[i],dp[j]+1);\\n            }\\n        }\\n    }\\n    \\n    //To get the answer we see if target time is in bounds of clip and search for minimum.\\n        \\n    int ans=clips.length+1;\\n    for(int j= clips.length-1;j>=0;j--){\\n        int a = clips[j][0];\\n        int b = clips[j][1];\\n        if(T >= a && T<=b){\\n            ans = Math.min(ans,dp[j]);\\n        }\\n    }\\n    \\nreturn ans == clips.length+1 ? -1:ans;\\n}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Dp: Optimized version of bactracking - Pick Or Don\\'t pick\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int clipLength = clips.length;\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        System.out.println(Arrays.deepToString(clips));\\n        int[] dp = new int[101];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        int index = 0;\\n        int prevClipEndTime = 0;\\n        int minimumClipsRequired = f(clips, time, dp, index, prevClipEndTime);\\n        return minimumClipsRequired;\\n    }\\n    \\n    private int f(int[][] clips, int targetTime, int[] dp, int index, int prevClipEndTime) {\\n        // BASE\\n        if (prevClipEndTime >= targetTime) return 0;\\n        if (index >= clips.length) return -1;\\n        if (prevClipEndTime < clips[index][0]) return -1;\\n        \\n        // CACHE OUT\\n        if (dp[prevClipEndTime] != Integer.MAX_VALUE) return dp[prevClipEndTime];\\n        \\n        // OPTIMAL SUBSTRUCTURE\\n        int min = Integer.MAX_VALUE;\\n        int val = f(clips, targetTime, dp, index + 1, clips[index][1]); // Pick clip\\n        if (val != -1) min = Math.min(min, val + 1);\\n        \\n        val = f(clips, targetTime, dp, index + 1, prevClipEndTime); // Dont pick clip\\n        if (val != -1) min = Math.min(min, val);\\n        \\n        // CACHE IN\\n        dp[prevClipEndTime] = min == Integer.MAX_VALUE ? -1 : min;\\n        \\n        // RETURN\\n        return dp[prevClipEndTime];\\n    }\\n}\\n/*\\n[[0,2],[2,6],[0,3],[6,9]]\\n9\\n*/\\n```\n```\\n// LIS\\nclass Solution {\\npublic int videoStitching(int[][] clips, int T) {\\n\\n    Arrays.sort(clips, (a,b) ->  a[0] - b[0]);\\n    \\n    //Finding maximum end time\\n    int max_end=-1;\\n    for(int i=0;i<clips.length;i++){\\n        max_end = Math.max(max_end, clips[i][1]);\\n    }\\n    \\n    //if end time is Less than Target time we can\\'t cover\\n    if(max_end < T){\\n        return -1;\\n    }\\n    \\n    \\n    int dp[] = new int[clips.length];\\n    Arrays.fill(dp, clips.length+1);\\n    // As start time is always 0 so marking clips with start time 0 as 1 in dp table \\n    // which means this can be considered.\\n    for(int i=0;i<clips.length;i++){\\n        if(clips[i][0] == 0){\\n            dp[i] = 1;\\n        }\\n    }\\n    // More or less it is same as LIS only difference is we are merging the intervals and\\n\\t// looking for minimum instead of Maximum.\\n    // Example two clips [0,2] [1,4] => it can be joined if 2 >= 1 and 4 >=2\\n    // Example two clips [0,1] [4,5] => it can\\'t be joined as 1 is not >= 4\\n    \\n    for(int i=1;i<clips.length;i++){\\n        for(int j=0;j<i;j++){\\n            int a = clips[j][0];\\n            int b = clips[j][1];\\n            int c = clips[i][0];\\n            int d = clips[i][1];       \\n            if(b >= c && d>=b){\\n                dp[i] = Math.min(dp[i],dp[j]+1);\\n            }\\n        }\\n    }\\n    \\n    //To get the answer we see if target time is in bounds of clip and search for minimum.\\n        \\n    int ans=clips.length+1;\\n    for(int j= clips.length-1;j>=0;j--){\\n        int a = clips[j][0];\\n        int b = clips[j][1];\\n        if(T >= a && T<=b){\\n            ans = Math.min(ans,dp[j]);\\n        }\\n    }\\n    \\nreturn ans == clips.length+1 ? -1:ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272690,
                "title": "c-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n=clips.size();\\n        int st=0,end=0,ans=1;\\n        sort(clips.begin(),clips.end());\\n        for(int i=0;i<n;i++){\\n            if(st>=clips[i][0]){\\n                end=max(end,clips[i][1]);\\n            }\\n            else{\\n                if(end>=time)\\n                    return ans;\\n                if(end<clips[i][0])\\n                    return -1;\\n                i--;\\n                st=end;\\n                ans++;\\n            }\\n        }\\n        if(end<time)\\n            return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n=clips.size();\\n        int st=0,end=0,ans=1;\\n        sort(clips.begin(),clips.end());\\n        for(int i=0;i<n;i++){\\n            if(st>=clips[i][0]){\\n                end=max(end,clips[i][1]);\\n            }\\n            else{\\n                if(end>=time)\\n                    return ans;\\n                if(end<clips[i][0])\\n                    return -1;\\n                i--;\\n                st=end;\\n                ans++;\\n            }\\n        }\\n        if(end<time)\\n            return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117847,
                "title": "java-clean-o-n-greedy-solution-with-useful-comments",
                "content": "This problem is basically Leetcode 45. Jump Game II but construct the array (lastUntil in the solution here) by ourselves. Before you solving this problem, I strongly recommand to get familiar with these \"prototype\" questions or revisit the solutions.\\n\\n* [55. Jump Game](https://leetcode.com/problems/jump-game/discuss/1117827/Java-clean-O(N)-time-O(1)-space-Greedy-Solution-oror-with-detailed-comments)\\n* [45. Jump Game II](https://leetcode.com/problems/jump-game-ii/discuss/1117791/Java-O(1)-space-Greedy-Solution-oror-with-detailed-comments)\\n\\nOr we may check a maybe slightly harder question:\\n* [1326. Minimum Number of Taps to Open to Water a Garden](https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/discuss/1117822/Java-clean-O(n)-Greedy-Solution-oror-with-detailed-comments)\\n\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        if (T == 0) return 0;\\n        \\n        /* \\n        The array lastUntil is defined as follows: \\n        \\n        lastUntil[i] = j means assuming time [0: i-1] has been covered by some clips, \\n        j is the \"furthest\" time stamp s.t. we may add 1 more clip and cover time[i : j]  \\n        \\n        */\\n        int[] lastUntil = new int[T+1];\\n        Arrays.fill(lastUntil, -1);\\n        \\n        for (int[] clip : clips) {\\n            int start = clip[0], end = clip[1];\\n            if (start > T) continue;\\n            \\n            lastUntil[start] = Math.max(lastUntil[start], Math.min(end, T));\\n        }\\n        \\n        // far : the \"furthest\" time stamp we can cover with c clips\\n        // initially we have 1 clip, covering the time [0, lastUntil[0]]\\n        int far = lastUntil[0];\\n        int c = 1;\\n        \\n        if (far == T) return 1;\\n        \\n        // find \"furthest\" time stamp we can cover with c+1 clips\\n        int next = 0;\\n        \\n        for (int i = 0; i <= T; i++) {\\n            if (i > far) return -1;\\n            \\n            next = Math.max(next, lastUntil[i]);\\n            if (next >= T) return c+1;\\n            \\n            if (i == far) {\\n                far = next;\\n                c++;\\n            }\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        if (T == 0) return 0;\\n        \\n        /* \\n        The array lastUntil is defined as follows: \\n        \\n        lastUntil[i] = j means assuming time [0: i-1] has been covered by some clips, \\n        j is the \"furthest\" time stamp s.t. we may add 1 more clip and cover time[i : j]  \\n        \\n        */\\n        int[] lastUntil = new int[T+1];\\n        Arrays.fill(lastUntil, -1);\\n        \\n        for (int[] clip : clips) {\\n            int start = clip[0], end = clip[1];\\n            if (start > T) continue;\\n            \\n            lastUntil[start] = Math.max(lastUntil[start], Math.min(end, T));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1065994,
                "title": "one-test-case-is-wrong",
                "content": "When the input clips is  [[2,4]] and T is 0 or 1.\\nwho know why the expected result is 0?\\nShould not the expected value be -1? \\nIt can be trigered by code\\n```\\n   \\n   public static int videoStitching(int[][] clips, int T) {\\n   if (clips == null || clips.length == 0) return -1;\\n    int N = clips.length;\\n    Arrays.sort(clips, (a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\\n\\tif (T==0) return 0; //  With this line, it is accepted. But result should be -1 meaning no solution, or result>=1 meaning the minimum clips number.  0 does not make any sense. \\n    if (0 < clips[0][0]) return -1; \\n    int result = 0;\\n    int l = 0, r = 0;\\n    for (int i = 0; i < clips.length; l = r, result++) {\\n      for (; i < clips.length && clips[i][0] <= l; i++) {\\n        r = Math.max(r, clips[i][1]);\\n      }\\n      if (r == l && r < T) return -1;\\n      if (r >= T) return ++result;\\n    }\\n    return r < T ? -1 : result;\\n  }\\n```\\n\\nIf clips is [[0,0]], and T is 0.\\nThe right expected should be 1, not 0. Right?",
                "solutionTags": [],
                "code": "```\\n   \\n   public static int videoStitching(int[][] clips, int T) {\\n   if (clips == null || clips.length == 0) return -1;\\n    int N = clips.length;\\n    Arrays.sort(clips, (a, b) -> a[0] != b[0] ? a[0] - b[0] : a[1] - b[1]);\\n\\tif (T==0) return 0; //  With this line, it is accepted. But result should be -1 meaning no solution, or result>=1 meaning the minimum clips number.  0 does not make any sense. \\n    if (0 < clips[0][0]) return -1; \\n    int result = 0;\\n    int l = 0, r = 0;\\n    for (int i = 0; i < clips.length; l = r, result++) {\\n      for (; i < clips.length && clips[i][0] <= l; i++) {\\n        r = Math.max(r, clips[i][1]);\\n      }\\n      if (r == l && r < T) return -1;\\n      if (r >= T) return ++result;\\n    }\\n    return r < T ? -1 : result;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 915884,
                "title": "python-top-down-and-bottom-up-dp",
                "content": "DP is not the fastest approach since this problem can be approached greedily.  But this is a good practice problem for DP.  \\n\\n**Top Down DP:**\\nStart with 2 pointers, (i) at 0 and (j) at T.\\nAt each stage consider taking a video clip.  \\nIf we take a video clip [3, 7] for example.  \\nThen we now have 1 clip and two new **subproblems** [i, 3] and [7, T].  \\nEach time we take a clip, split the range [i, j] into subproblems until i >= j in which case 0 additional clips are needed.  \\nThe final result will be the sum of the minimum number of clips to cover each subproblem.  \\n\\n**Note:** The clip does not need to be in the middle of [i,j].  It could be clip [i-1, j+1] and cover the entire window[i,j].\\nOr it could only partially overlap with [i,j] for instance [i=5, j=9] and clip = [3, 7] or [8, 10].\\n\\n<br>\\n\\n```python\\ndef videoStitching(self, clips: List[List[int]], T: int) -> int:\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(i, j):\\n\\n\\t\\tif i >= j:\\n\\t\\t\\treturn 0\\n\\n\\t\\tbest = float(\\'inf\\')\\n\\t\\tfor s,e in clips:\\n\\t\\t\\tif s <= i and i < e < j:\\n\\t\\t\\t\\tbest = min(best, 1 + helper(e, j))\\n\\t\\t\\telif s <= i and j <= e:\\n\\t\\t\\t\\tbest = 1\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif i > s and e >= j:\\n\\t\\t\\t\\tbest = min(best, 1 + helper(i, s))\\n\\t\\t\\telif i < s and e < j:\\n\\t\\t\\t\\tbest = min(best, 1 + helper(i, s) + helper(e, j))\\n\\n\\t\\treturn best\\n\\n\\tclips = helper(0, T)\\n\\treturn clips if clips != float(\\'inf\\') else -1\\n```\\n\\n<br>\\n\\n**Bottom Up DP:**\\n```python\\ndef videoStitching(self, clips: List[List[int]], T: int) -> int:\\n\\n\\tdp = [[0 for _ in range(T+1)] for _ in range(T+1)]\\n\\n\\tfor i in range(T, -1, -1):\\n\\t\\tfor j in range(i, T+1):\\n\\n\\t\\t\\tif i >= j:\\n\\t\\t\\t\\tdp[i][j] = 0\\n\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\tbest = float(\\'inf\\')\\n\\t\\t\\tfor s,e in clips:\\n\\t\\t\\t\\tif s <= i and i < e < j:\\n\\t\\t\\t\\t\\tbest = min(best, 1 + dp[e][j])\\n\\t\\t\\t\\telif s <= i and j <= e:\\n\\t\\t\\t\\t\\tbest = 1\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\telif i > s and e >= j:\\n\\t\\t\\t\\t\\tbest = min(best, 1 + dp[i][s])\\n\\t\\t\\t\\telif i < s and e < j:\\n\\t\\t\\t\\t\\tbest = min(best, 1 + dp[i][s] + dp[e][j])\\n\\n\\t\\t\\tdp[i][j] = best\\n\\n\\treturn dp[0][T] if dp[0][T] != float(\\'inf\\') else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\ndef videoStitching(self, clips: List[List[int]], T: int) -> int:\\n\\n\\t@functools.lru_cache(None)\\n\\tdef helper(i, j):\\n\\n\\t\\tif i >= j:\\n\\t\\t\\treturn 0\\n\\n\\t\\tbest = float(\\'inf\\')\\n\\t\\tfor s,e in clips:\\n\\t\\t\\tif s <= i and i < e < j:\\n\\t\\t\\t\\tbest = min(best, 1 + helper(e, j))\\n\\t\\t\\telif s <= i and j <= e:\\n\\t\\t\\t\\tbest = 1\\n\\t\\t\\t\\tbreak\\n\\t\\t\\telif i > s and e >= j:\\n\\t\\t\\t\\tbest = min(best, 1 + helper(i, s))\\n\\t\\t\\telif i < s and e < j:\\n\\t\\t\\t\\tbest = min(best, 1 + helper(i, s) + helper(e, j))\\n\\n\\t\\treturn best\\n\\n\\tclips = helper(0, T)\\n\\treturn clips if clips != float(\\'inf\\') else -1\\n```\n```python\\ndef videoStitching(self, clips: List[List[int]], T: int) -> int:\\n\\n\\tdp = [[0 for _ in range(T+1)] for _ in range(T+1)]\\n\\n\\tfor i in range(T, -1, -1):\\n\\t\\tfor j in range(i, T+1):\\n\\n\\t\\t\\tif i >= j:\\n\\t\\t\\t\\tdp[i][j] = 0\\n\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\tbest = float(\\'inf\\')\\n\\t\\t\\tfor s,e in clips:\\n\\t\\t\\t\\tif s <= i and i < e < j:\\n\\t\\t\\t\\t\\tbest = min(best, 1 + dp[e][j])\\n\\t\\t\\t\\telif s <= i and j <= e:\\n\\t\\t\\t\\t\\tbest = 1\\n\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\telif i > s and e >= j:\\n\\t\\t\\t\\t\\tbest = min(best, 1 + dp[i][s])\\n\\t\\t\\t\\telif i < s and e < j:\\n\\t\\t\\t\\t\\tbest = min(best, 1 + dp[i][s] + dp[e][j])\\n\\n\\t\\t\\tdp[i][j] = best\\n\\n\\treturn dp[0][T] if dp[0][T] != float(\\'inf\\') else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 857124,
                "title": "simple-knapsack-variant-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long dp[105][105];\\n    long long solve(int cur,int index,vector<vector<int>>&clips,int T){\\n        if(cur>=T){\\n            return 0;\\n        }\\n        if(index>=clips.size()){\\n            return INT_MAX;\\n        }\\n        if(cur<clips[index][0]){\\n            return INT_MAX;\\n        }\\n        if(dp[cur][index]!=-1){\\n            return dp[cur][index];\\n        }\\n        long long op1 =solve(clips[index][1],index+1,clips,T)+1;\\n        long long op2 =solve(cur,index+1,clips,T);\\n        return dp[cur][index]=min(op1,op2);\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(),clips.end());\\n        memset(dp,-1,sizeof(dp));\\n        long long ans = solve(0,0,clips,T);\\n        if(ans>=INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    long long dp[105][105];\\n    long long solve(int cur,int index,vector<vector<int>>&clips,int T){\\n        if(cur>=T){\\n            return 0;\\n        }\\n        if(index>=clips.size()){\\n            return INT_MAX;\\n        }\\n        if(cur<clips[index][0]){\\n            return INT_MAX;\\n        }\\n        if(dp[cur][index]!=-1){\\n            return dp[cur][index];\\n        }\\n        long long op1 =solve(clips[index][1],index+1,clips,T)+1;\\n        long long op2 =solve(cur,index+1,clips,T);\\n        return dp[cur][index]=min(op1,op2);\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(),clips.end());\\n        memset(dp,-1,sizeof(dp));\\n        long long ans = solve(0,0,clips,T);\\n        if(ans>=INT_MAX){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386731,
                "title": "java-dp-o-n-t-100-fast-solution",
                "content": "```\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T+1];\\n\\t\\t//dp[i] stores  eding time of the activity that start before or at ithe activity and has latest ending time.\\n        for(int[] clip: clips){\\n            if(clip[0]<=T)dp[clip[0]] = Math.max( dp[clip[0]], clip[1]);\\n        }\\n        \\n        for(int i=1;i<=T;i++){\\n            dp[i] = Math.max(dp[i-1], dp[i]);    \\n        }\\n        \\n        int i=0;\\n        int count = 0;\\n        while(i<T){\\n            if(dp[i]==i)break;\\n            count +=1;\\n            i = dp[i];\\n        }\\n        return i>=T?count:-1;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T+1];\\n\\t\\t//dp[i] stores  eding time of the activity that start before or at ithe activity and has latest ending time.\\n        for(int[] clip: clips){\\n            if(clip[0]<=T)dp[clip[0]] = Math.max( dp[clip[0]], clip[1]);\\n        }\\n        \\n        for(int i=1;i<=T;i++){\\n            dp[i] = Math.max(dp[i-1], dp[i]);    \\n        }\\n        \\n        int i=0;\\n        int count = 0;\\n        while(i<T){\\n            if(dp[i]==i)break;\\n            count +=1;\\n            i = dp[i];\\n        }\\n        return i>=T?count:-1;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282413,
                "title": "java-greedy-solution-with-picture-explanation",
                "content": "![image](https://assets.leetcode.com/users/billlipeng/image_1556350273.png)\\n\\n\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n\\t\\t// sort the array \\n        Arrays.sort(clips, (o1, o2) -> {\\n            if(o1[0] < o2[0]) return -1;\\n            if(o1[0] > o2[0]) return 1;\\n            return 0;\\n        });\\n        \\n\\t\\tint curEnd = -1; //  current end\\n        int potenEnd = 0; // potiential end\\n        int count = 0; // result\\n        for(int[] c : clips) {\\n\\t\\t\\n\\t\\t\\t// if potential end reaches T, then break and return count; ----> picture 1\\n\\t\\t\\t// if c[0] >  potential end, the task is impossible, return -1 -----> picture 2\\n            if(potenEnd >= T || c[0] > potenEnd) break;\\n            \\n            if(c[0] > curEnd) {\\n\\t\\t\\t\\t// in red circle in picture 3, we should pick one more clip, and update current end\\n                count++;\\n                curEnd = potenEnd;\\n            }\\n\\t\\t\\t// update potential end;\\n            potenEnd = Math.max(potenEnd, c[1]);\\n        }\\n        return potenEnd >= T ? count : -1;  \\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n\\t\\t// sort the array \\n        Arrays.sort(clips, (o1, o2) -> {\\n            if(o1[0] < o2[0]) return -1;\\n            if(o1[0] > o2[0]) return 1;\\n            return 0;\\n        });\\n        \\n\\t\\tint curEnd = -1; //  current end\\n        int potenEnd = 0; // potiential end\\n        int count = 0; // result\\n        for(int[] c : clips) {\\n\\t\\t\\n\\t\\t\\t// if potential end reaches T, then break and return count; ----> picture 1\\n\\t\\t\\t// if c[0] >  potential end, the task is impossible, return -1 -----> picture 2\\n            if(potenEnd >= T || c[0] > potenEnd) break;\\n            \\n            if(c[0] > curEnd) {\\n\\t\\t\\t\\t// in red circle in picture 3, we should pick one more clip, and update current end\\n                count++;\\n                curEnd = potenEnd;\\n            }\\n\\t\\t\\t// update potential end;\\n            potenEnd = Math.max(potenEnd, c[1]);\\n        }\\n        return potenEnd >= T ? count : -1;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859346,
                "title": "easy-memoization-approach-c-solution-100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dp[104][104];\\n    int solve(int i, vector<vector<int>>& clips, int mx, int time){\\n        if(mx >= time) return 0;\\n        if(i >= clips.size()){\\n            return INT_MAX;\\n        }\\n        if(dp[i][mx] != -1) return dp[i][mx];\\n        if(clips[i][0] <= mx){\\n            int temp = solve(i+1,clips,max(mx,clips[i][1]),time);\\n            return dp[i][mx] = min(temp == INT_MAX ? INT_MAX : temp+1 , solve(i+1,clips,mx,time));\\n        }\\n        return dp[i][mx] = INT_MAX;\\n    }\\n\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n = clips.size();\\n        sort(clips.begin(),clips.end());\\n        if(clips[0][0] != 0) return -1;\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(0,clips,0,time);\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dp[104][104];\\n    int solve(int i, vector<vector<int>>& clips, int mx, int time){\\n        if(mx >= time) return 0;\\n        if(i >= clips.size()){\\n            return INT_MAX;\\n        }\\n        if(dp[i][mx] != -1) return dp[i][mx];\\n        if(clips[i][0] <= mx){\\n            int temp = solve(i+1,clips,max(mx,clips[i][1]),time);\\n            return dp[i][mx] = min(temp == INT_MAX ? INT_MAX : temp+1 , solve(i+1,clips,mx,time));\\n        }\\n        return dp[i][mx] = INT_MAX;\\n    }\\n\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n = clips.size();\\n        sort(clips.begin(),clips.end());\\n        if(clips[0][0] != 0) return -1;\\n        memset(dp,-1,sizeof(dp));\\n        int ans = solve(0,clips,0,time);\\n        return ans == INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690596,
                "title": "easy-c-o-n-time-t-c-o-time-s-c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe just keep the track of maximum time that can be reached from a particular starting point of time.\\n\\nNow, just take the prefix maximum value of time that can be reached till ith index. Now we will start from intial point of time and check the maximum time that can be reached from all the time stamps till that position(the maximum value is already stored in the dp) , if the value is greater than the current time then we will increase the answer count otherwise will break the loop and return the value -1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n + time)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(time)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n = clips.size();\\n        vector<int>dp(time+1,0);\\n        for(int i=0; i<n ;i++)\\n        {\\n            if(clips[i][0] > time)\\n                continue;\\n            dp[clips[i][0]] = max(dp[clips[i][0]],min(clips[i][1],time));\\n        }\\n        for(int i = 1;i<=time;i++)\\n            dp[i] = max(dp[i-1],dp[i]);\\n        int id = 0,ans = 0;\\n        while(id<time)\\n        {\\n            ans++;\\n            if(dp[id] <= id)\\n                return -1;\\n            id = dp[id];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n = clips.size();\\n        vector<int>dp(time+1,0);\\n        for(int i=0; i<n ;i++)\\n        {\\n            if(clips[i][0] > time)\\n                continue;\\n            dp[clips[i][0]] = max(dp[clips[i][0]],min(clips[i][1],time));\\n        }\\n        for(int i = 1;i<=time;i++)\\n            dp[i] = max(dp[i-1],dp[i]);\\n        int id = 0,ans = 0;\\n        while(id<time)\\n        {\\n            ans++;\\n            if(dp[id] <= id)\\n                return -1;\\n            id = dp[id];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3604726,
                "title": "c-memoized-solution-beats-100-similar-problem-added-different-than-others",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is clear from the description that we can sort the pairs, this will not gonna cahnge the result. And after checking example we can say that every new coming index should have opening time <= closing time of current index.\\n\\n **Important :** here why the every fu**ing solution is dying to use prev as a value instead of prev as an index unlike in other questions,, this is becuase we have to compulsorily add the index with {0,x} so they are parsing the value of prev==0 to ensure that first value taken is zero. You can check that method in other posts, I am doing question with the same approach as many questions ask.\\n\\n   if you dont want to change your method\\n you can use a for loop and parse the prev as prev == clips[i][1] where i is the index such that clip[i][0] == 0;\\n\\nSimilar question : [1626. Best Team With No Conflicts](https://leetcode.com/problems/best-team-with-no-conflicts/)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    int solve(int ind, int prev, vector<vector<int>>&dp, vector<vector<int>>& clips, int time){\\n        if(ind == clips.size()){\\n            if(clips[prev][1] >= time)return 0;\\n            return 1e9;\\n        }\\n        if(clips[prev][1] >= time)return 0;\\n        if(dp[ind][prev] != -1)return dp[ind][prev];\\n\\n        int take = 1e9;\\n        if(clips[ind][0] <= clips[prev][1]){\\n            take = 1+solve(ind + 1, ind, dp, clips, time);\\n        }\\n        int notTake = solve(ind + 1, prev, dp, clips, time);\\n        return dp[ind][prev] = min(take, notTake);\\n    }\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n = clips.size();\\n        vector<vector<int>>dp(n+1, vector<int>(n + 1, -1));\\n        sort(clips.begin(), clips.end());\\n        int mini = 1e9;\\n        for(int i =0; i <n ;i++){\\n            // cout<<clips[i][0] <<\" \"<<clips[i][1]<<endl;\\n            if(clips[i][0]==0)\\n                mini =  min(mini, 1 + solve(i + 1, i, dp, clips, time));\\n        }\\n        if(mini == 1e9)return -1;\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int solve(int ind, int prev, vector<vector<int>>&dp, vector<vector<int>>& clips, int time){\\n        if(ind == clips.size()){\\n            if(clips[prev][1] >= time)return 0;\\n            return 1e9;\\n        }\\n        if(clips[prev][1] >= time)return 0;\\n        if(dp[ind][prev] != -1)return dp[ind][prev];\\n\\n        int take = 1e9;\\n        if(clips[ind][0] <= clips[prev][1]){\\n            take = 1+solve(ind + 1, ind, dp, clips, time);\\n        }\\n        int notTake = solve(ind + 1, prev, dp, clips, time);\\n        return dp[ind][prev] = min(take, notTake);\\n    }\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n = clips.size();\\n        vector<vector<int>>dp(n+1, vector<int>(n + 1, -1));\\n        sort(clips.begin(), clips.end());\\n        int mini = 1e9;\\n        for(int i =0; i <n ;i++){\\n            // cout<<clips[i][0] <<\" \"<<clips[i][1]<<endl;\\n            if(clips[i][0]==0)\\n                mini =  min(mini, 1 + solve(i + 1, i, dp, clips, time));\\n        }\\n        if(mini == 1e9)return -1;\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2665151,
                "title": "c-commented-explanation-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /* Approach : Greedy */\\n    \\n    /*\\n    \\n    Observation (1):\\n    \\n    For similar starting point , we will pick that one which has the \\n\\tmaximum range , [a,b] , [a,d]. If (b>d) we will pick the interval [a,b] for \\n\\tsure as it will cover the longest distance towards the right.\\n    \\n    Observation (2):\\n    \\n    Now what we will do , when we reach the end of the choosen interval \\n\\t[a,b]. See, if (b==time) , then we are able to reach our destination so\\n\\treturn the total number of intervals we used so far. Else , we start \\n\\tsearching an interval , which has its starting point <= b and has the \\n\\tmaximum covering towards the right .\\n    \\n    */\\n    \\n    /*\\n    \\n    T.C : O(N + time)\\n    S.C : O(time)\\n    \\n    */\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        \\n        vector<int>dp(time+1,-1);\\n        \\n        for(int i=0;i<clips.size();i++){\\n            \\n            int left = min(clips[i][0],time);\\n            int right = min(clips[i][1],time);\\n            \\n            dp[left] = max(dp[left] , right);\\n            \\n        }\\n        \\n        int currmax = dp[0];\\n        \\n        int nextmax = -1;\\n        \\n        int jumps = 1;\\n        \\n        if(dp[0]==time) return 1;\\n        \\n        for(int i=0;i<=time;i++){\\n            \\n            nextmax = max(nextmax,dp[i]);\\n            \\n            if(currmax==i){\\n                \\n                currmax = nextmax;\\n                jumps++;\\n                \\n            }\\n            \\n            if(currmax == time){\\n                \\n                return jumps;\\n                \\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /* Approach : Greedy */\\n    \\n    /*\\n    \\n    Observation (1):\\n    \\n    For similar starting point , we will pick that one which has the \\n\\tmaximum range , [a,b] , [a,d]. If (b>d) we will pick the interval [a,b] for \\n\\tsure as it will cover the longest distance towards the right.\\n    \\n    Observation (2):\\n    \\n    Now what we will do , when we reach the end of the choosen interval \\n\\t[a,b]. See, if (b==time) , then we are able to reach our destination so\\n\\treturn the total number of intervals we used so far. Else , we start \\n\\tsearching an interval , which has its starting point <= b and has the \\n\\tmaximum covering towards the right .\\n    \\n    */\\n    \\n    /*\\n    \\n    T.C : O(N + time)\\n    S.C : O(time)\\n    \\n    */\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        \\n        vector<int>dp(time+1,-1);\\n        \\n        for(int i=0;i<clips.size();i++){\\n            \\n            int left = min(clips[i][0],time);\\n            int right = min(clips[i][1],time);\\n            \\n            dp[left] = max(dp[left] , right);\\n            \\n        }\\n        \\n        int currmax = dp[0];\\n        \\n        int nextmax = -1;\\n        \\n        int jumps = 1;\\n        \\n        if(dp[0]==time) return 1;\\n        \\n        for(int i=0;i<=time;i++){\\n            \\n            nextmax = max(nextmax,dp[i]);\\n            \\n            if(currmax==i){\\n                \\n                currmax = nextmax;\\n                jumps++;\\n                \\n            }\\n            \\n            if(currmax == time){\\n                \\n                return jumps;\\n                \\n            }\\n            \\n        }\\n        \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420715,
                "title": "c-easy-solution-recursion-memoization-dynamic-programming",
                "content": "```\\n//Recursion\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&clips, int time , int size){\\n        if ( time ==0 ) return 0 ; \\n        if ( size==0 ) return -1; \\n        int nottake, take=-1; \\n        nottake = solve ( clips ,time , size-1); \\n        if ( clips[size-1][0]<time && clips[size-1][1]>=time){\\n            take = solve(clips,clips[size-1][0], size-1); \\n        }\\n        int ans = -1;\\n        if ( nottake==-1 && take!=-1)\\n            ans = 1+take ; \\n        else if (nottake!=-1 && take==-1)\\n            ans = nottake ; \\n        else if ( nottake!=-1 && take!=-1) {\\n            ans = min ( nottake , 1+take) ; \\n        }\\n        return ans ; \\n    }\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort( clips.begin(), clips.end()); \\n        return solve( clips , time ,clips.size()); \\n    }\\n};\\n\\n//Memoization\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&clips, int time , int size, int dp[101][101]){\\n        if ( time ==0 ) return 0 ; \\n        if ( size==0 ) return -1; \\n        if ( dp[time][size]!=-1) return dp[time][size]; \\n        int nottake, take=-1; \\n        nottake = solve ( clips ,time , size-1,dp); \\n        if ( clips[size-1][0]<time && clips[size-1][1]>=time){\\n            take = solve(clips,clips[size-1][0], size-1,dp); \\n        }\\n        int ans = -1;\\n        if ( nottake==-1 && take!=-1)\\n            ans = 1+take ; \\n        else if (nottake!=-1 && take==-1)\\n            ans = nottake ; \\n        else if ( nottake!=-1 && take!=-1) {\\n            ans = min ( nottake , 1+take) ; \\n        }\\n        return dp[time][size]=ans ; \\n    }\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort( clips.begin(), clips.end());\\n        int dp[101][101]; \\n        memset(dp, -1 , sizeof(dp)); \\n        return solve( clips , time ,clips.size(),dp);\\n    }\\n};\\n// Dynamic Programming + Space Optimization \\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n              sort(clips.begin(), clips.end());\\n              int n = clips.size();\\n              \\n              int start = 0, reach = 0, clips_req = 0;\\n        \\n              while(reach < time){\\n                  for(auto clip : clips){\\n                      if(start >= clip[0] && start <= clip[1]) reach = max(reach, clip[1]);\\n                  }\\n                  if(start == reach) return -1;\\n                  clips_req++;\\n                  start = reach;\\n              }\\n            return clips_req;\\n              \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//Recursion\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&clips, int time , int size){\\n        if ( time ==0 ) return 0 ; \\n        if ( size==0 ) return -1; \\n        int nottake, take=-1; \\n        nottake = solve ( clips ,time , size-1); \\n        if ( clips[size-1][0]<time && clips[size-1][1]>=time){\\n            take = solve(clips,clips[size-1][0], size-1); \\n        }\\n        int ans = -1;\\n        if ( nottake==-1 && take!=-1)\\n            ans = 1+take ; \\n        else if (nottake!=-1 && take==-1)\\n            ans = nottake ; \\n        else if ( nottake!=-1 && take!=-1) {\\n            ans = min ( nottake , 1+take) ; \\n        }\\n        return ans ; \\n    }\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort( clips.begin(), clips.end()); \\n        return solve( clips , time ,clips.size()); \\n    }\\n};\\n\\n//Memoization\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&clips, int time , int size, int dp[101][101]){\\n        if ( time ==0 ) return 0 ; \\n        if ( size==0 ) return -1; \\n        if ( dp[time][size]!=-1) return dp[time][size]; \\n        int nottake, take=-1; \\n        nottake = solve ( clips ,time , size-1,dp); \\n        if ( clips[size-1][0]<time && clips[size-1][1]>=time){\\n            take = solve(clips,clips[size-1][0], size-1,dp); \\n        }\\n        int ans = -1;\\n        if ( nottake==-1 && take!=-1)\\n            ans = 1+take ; \\n        else if (nottake!=-1 && take==-1)\\n            ans = nottake ; \\n        else if ( nottake!=-1 && take!=-1) {\\n            ans = min ( nottake , 1+take) ; \\n        }\\n        return dp[time][size]=ans ; \\n    }\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort( clips.begin(), clips.end());\\n        int dp[101][101]; \\n        memset(dp, -1 , sizeof(dp)); \\n        return solve( clips , time ,clips.size(),dp);\\n    }\\n};\\n// Dynamic Programming + Space Optimization \\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n              sort(clips.begin(), clips.end());\\n              int n = clips.size();\\n              \\n              int start = 0, reach = 0, clips_req = 0;\\n        \\n              while(reach < time){\\n                  for(auto clip : clips){\\n                      if(start >= clip[0] && start <= clip[1]) reach = max(reach, clip[1]);\\n                  }\\n                  if(start == reach) return -1;\\n                  clips_req++;\\n                  start = reach;\\n              }\\n            return clips_req;\\n              \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283242,
                "title": "using-greedy-approach-without-sorting",
                "content": "Tried solving this problem using the concept of minimum number of jumps required to reach a target used in [Jump Game II](https://leetcode.com/problems/jump-game-ii/).\\nSteps: \\n1. Initialise an array of maximum size 100, with inital value of each element as INT_MIN.\\n2. From the range array, store the maximum distance that can be covered from each starting postion.\\n3. Now try to find out the minimum number of steps required to reach given distance, else return -1.\\n\\n```\\n    int findCount(vector<int> dist, int time){\\n        int count=0;\\n        int right=0,left=0;\\n        while(right<time){\\n            if(right<left)\\n                return -1;\\n            int next=0;\\n            for(int i=left;i<=right;i++){\\n                next=max(next,dist[i]);   //update the next maximum rechable distance\\n            }\\n            left=right+1;\\n            right=next;\\n            count++;                      //Increase the counter once a range is completely covered\\n        }\\n        return count;\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        vector<int> dist(100,INT_MIN);\\n        for(int i=0;i<clips.size();i++){\\n            dist[clips[i][0]]=max(dist[clips[i][0]],clips[i][1]);\\n        }\\n        return findCount(dist, time);\\n    }\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n    int findCount(vector<int> dist, int time){\\n        int count=0;\\n        int right=0,left=0;\\n        while(right<time){\\n            if(right<left)\\n                return -1;\\n            int next=0;\\n            for(int i=left;i<=right;i++){\\n                next=max(next,dist[i]);   //update the next maximum rechable distance\\n            }\\n            left=right+1;\\n            right=next;\\n            count++;                      //Increase the counter once a range is completely covered\\n        }\\n        return count;\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        vector<int> dist(100,INT_MIN);\\n        for(int i=0;i<clips.size();i++){\\n            dist[clips[i][0]]=max(dist[clips[i][0]],clips[i][1]);\\n        }\\n        return findCount(dist, time);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2176584,
                "title": "two-problems-one-solution-java-explanation",
                "content": "**1024. Video Stitching**\\n```\\n[0,2][4,6][1,5][0,3]  T = 6\\n\\n\\n    Duration    0       1       2       3       4       5       6\\n                x---------------x\\n                                                x----------------x\\n                        x--------------------------------x\\n                x------------------------x\\n                \\n                \\n            min(0)-----------------------max(3)\\n                                         min(3)----------max(5)\\n                                                         min(5)----max(6)\\n\\n```\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int min = 0;\\n        int max = 0;\\n        int total = 0;\\n        \\n        while(max<time) {\\n            \\n            for(int[] clip : clips) {\\n                int left = clip[0];\\n                int right = clip[1];\\n                \\n                if(left<=min && right >max) {\\n                    max = right;\\n                }\\n            }\\n            \\n            if(min == max) {\\n                return -1;\\n            }\\n            \\n            min = max;\\n            total++;\\n        }\\n        \\n        \\n        return total;\\n    }\\n}\\n```\\n\\n**1326. Minimum Number of Taps to Open to Water a Garden**\\n```\\n\\nclass Solution {\\n    public int minTaps(int n, int[] ranges) {\\n        int min = 0;\\n        int max = 0;\\n        int total = 0;\\n        \\n        while(max<n) {\\n         \\n            for(int i=0; i<ranges.length; i++) {\\n                int left = i - ranges[i];\\n                int right = i + ranges[i];\\n                \\n                if(left<=min && max<right) {\\n                    max = right;\\n                }\\n            }\\n            if(min == max) {\\n                return -1;\\n            }\\n            \\n            min = max;\\n            \\n            total++;\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n[0,2][4,6][1,5][0,3]  T = 6\\n\\n\\n    Duration    0       1       2       3       4       5       6\\n                x---------------x\\n                                                x----------------x\\n                        x--------------------------------x\\n                x------------------------x\\n                \\n                \\n            min(0)-----------------------max(3)\\n                                         min(3)----------max(5)\\n                                                         min(5)----max(6)\\n\\n```\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int min = 0;\\n        int max = 0;\\n        int total = 0;\\n        \\n        while(max<time) {\\n            \\n            for(int[] clip : clips) {\\n                int left = clip[0];\\n                int right = clip[1];\\n                \\n                if(left<=min && right >max) {\\n                    max = right;\\n                }\\n            }\\n            \\n            if(min == max) {\\n                return -1;\\n            }\\n            \\n            min = max;\\n            total++;\\n        }\\n        \\n        \\n        return total;\\n    }\\n}\\n```\n```\\n\\nclass Solution {\\n    public int minTaps(int n, int[] ranges) {\\n        int min = 0;\\n        int max = 0;\\n        int total = 0;\\n        \\n        while(max<n) {\\n         \\n            for(int i=0; i<ranges.length; i++) {\\n                int left = i - ranges[i];\\n                int right = i + ranges[i];\\n                \\n                if(left<=min && max<right) {\\n                    max = right;\\n                }\\n            }\\n            if(min == max) {\\n                return -1;\\n            }\\n            \\n            min = max;\\n            \\n            total++;\\n        }\\n        \\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1424243,
                "title": "c-faster-than-100-constant-space-greedy",
                "content": "##### **Greedy Choice** : Choose the interval which has the smallest starting time and longest duration and add it to the final answer\\n```\\nbool comp(const vector<int> &a, const vector<int> &b)\\n{\\n    if(a[0] == b[0])\\n        return (a[1] - a[0]) > (b[1] - b[0]);\\n    \\n    return a[0] < b[0];\\n}\\n\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) \\n    {\\n        sort(clips.begin(), clips.end(), comp);\\n        \\n        int maxtime = 0, tc = 0, i = 0;\\n        \\n        while(i < clips.size() and maxtime < time)\\n        {\\n            if(clips[i][0] > maxtime)\\n                return -1;\\n            \\n            int currmax = 0;\\n            \\n            for( ; i < clips.size() ; i++)\\n            {\\n                if(clips[i][0] <= maxtime)\\n                    currmax = max(currmax, clips[i][1]);\\n                else\\n                    break;\\n            }\\n            \\n            tc++;\\n            maxtime = currmax;\\n        }\\n        if(i >= clips.size() and maxtime < time)\\n            return -1;\\n        \\n        return tc;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nbool comp(const vector<int> &a, const vector<int> &b)\\n{\\n    if(a[0] == b[0])\\n        return (a[1] - a[0]) > (b[1] - b[0]);\\n    \\n    return a[0] < b[0];\\n}\\n\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) \\n    {\\n        sort(clips.begin(), clips.end(), comp);\\n        \\n        int maxtime = 0, tc = 0, i = 0;\\n        \\n        while(i < clips.size() and maxtime < time)\\n        {\\n            if(clips[i][0] > maxtime)\\n                return -1;\\n            \\n            int currmax = 0;\\n            \\n            for( ; i < clips.size() ; i++)\\n            {\\n                if(clips[i][0] <= maxtime)\\n                    currmax = max(currmax, clips[i][1]);\\n                else\\n                    break;\\n            }\\n            \\n            tc++;\\n            maxtime = currmax;\\n        }\\n        if(i >= clips.size() and maxtime < time)\\n            return -1;\\n        \\n        return tc;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1230255,
                "title": "java-solution-priority-queue-and-stack-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        if(time == 0)\\n            return 0;\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b) -> a[0] == b[0]?b[1]-a[1]:a[0]-b[0]);\\n        for(int[] c:clips)\\n            q.add(c);\\n        Stack<int[]> s = new Stack<>();\\n        int end=0;\\n        if(q.peek()[0] != 0)\\n            return -1;\\n        while(!q.isEmpty() && end < time){\\n            int[] lp = null;\\n            while(s.size() != 0 && s.peek()[1] < q.peek()[1] && s.peek()[1] >= q.peek()[0]) lp = s.pop();\\n            if(lp != null)\\n                s.add(lp);\\n            if(s.size() == 0 || s.peek()[1] >= q.peek()[0])\\n                s.add(q.poll());\\n            else return -1;\\n            end = s.peek()[1];\\n            while(!q.isEmpty() && q.peek()[1] <= s.peek()[1]) q.poll();\\n        }\\n        return end >= time?s.size():-1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        if(time == 0)\\n            return 0;\\n        PriorityQueue<int[]> q = new PriorityQueue<>((a,b) -> a[0] == b[0]?b[1]-a[1]:a[0]-b[0]);\\n        for(int[] c:clips)\\n            q.add(c);\\n        Stack<int[]> s = new Stack<>();\\n        int end=0;\\n        if(q.peek()[0] != 0)\\n            return -1;\\n        while(!q.isEmpty() && end < time){\\n            int[] lp = null;\\n            while(s.size() != 0 && s.peek()[1] < q.peek()[1] && s.peek()[1] >= q.peek()[0]) lp = s.pop();\\n            if(lp != null)\\n                s.add(lp);\\n            if(s.size() == 0 || s.peek()[1] >= q.peek()[0])\\n                s.add(q.poll());\\n            else return -1;\\n            end = s.peek()[1];\\n            while(!q.isEmpty() && q.peek()[1] <= s.peek()[1]) q.poll();\\n        }\\n        return end >= time?s.size():-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222700,
                "title": "1ms-100-faster-dp-solution",
                "content": "java code is:\\n# \\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        Arrays.sort(clips,(a,b)-> a[0]-b[0]);\\n        int dp[]=new int[T+1];\\n        Arrays.fill(dp,clips.length+2);\\n        dp[0]=0;\\n        for(int clip[] : clips){\\n            for(int j=clip[0];j<=clip[1]&&j<=T;j++)\\n                dp[j]=Math.min(dp[j],1+dp[clip[0]]);\\n        }\\n        return dp[T]>=clips.length+2 ? -1 : dp[T];\\n    }\\n}\\n```\\n**Please,Upvote if this is helpful**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        Arrays.sort(clips,(a,b)-> a[0]-b[0]);\\n        int dp[]=new int[T+1];\\n        Arrays.fill(dp,clips.length+2);\\n        dp[0]=0;\\n        for(int clip[] : clips){\\n            for(int j=clip[0];j<=clip[1]&&j<=T;j++)\\n                dp[j]=Math.min(dp[j],1+dp[clip[0]]);\\n        }\\n        return dp[T]>=clips.length+2 ? -1 : dp[T];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125417,
                "title": "sort-the-clips-and-one-pass-99-speed",
                "content": "Runtime: 20 ms, faster than 99.79% of Python3 online submissions for Video Stitching.\\nMemory Usage: 14.1 MB, less than 97.52% of Python3 online submissions for Video Stitching.\\n```\\nclass Solution:\\n    def videoStitching(self, clips, T: int) -> int:\\n        if T == 0:\\n            return 0\\n        clips.sort(key=lambda x: (x[0], -x[1]))\\n        if clips[0][0] <= 0:\\n            len_clips = len(clips)\\n            lst = [clips[0]]\\n            idx = 1\\n            while lst[-1][1] < T and idx < len_clips:\\n                start, end = clips[idx]\\n                if start <= lst[-1][1] < end:\\n                    if len(lst) > 1 and start <= lst[-2][1]:\\n                        lst.pop()\\n                    lst.append(clips[idx])\\n                idx += 1\\n            if lst[-1][1] >= T:\\n                return len(lst)\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips, T: int) -> int:\\n        if T == 0:\\n            return 0\\n        clips.sort(key=lambda x: (x[0], -x[1]))\\n        if clips[0][0] <= 0:\\n            len_clips = len(clips)\\n            lst = [clips[0]]\\n            idx = 1\\n            while lst[-1][1] < T and idx < len_clips:\\n                start, end = clips[idx]\\n                if start <= lst[-1][1] < end:\\n                    if len(lst) > 1 and start <= lst[-2][1]:\\n                        lst.pop()\\n                    lst.append(clips[idx])\\n                idx += 1\\n            if lst[-1][1] >= T:\\n                return len(lst)\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 986021,
                "title": "c-100-faster-greedy-approach-short-code",
                "content": "For the current time stamp, choose the clip which falls within the range and has the greatest end point. If no such clip exists, solution does not exist.\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int s =0;\\n        int n = clips.size();\\n        int ans=0;\\n        while(s <T){\\n            int md = s;\\n            for(int i=0; i<n; i++){\\n                if(clips[i][0] <= s && clips[i][1] > md){\\n                    md = max(md, clips[i][1]);\\n                }\\n            }\\n            if(md == s) return -1;\\n            s = md;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int s =0;\\n        int n = clips.size();\\n        int ans=0;\\n        while(s <T){\\n            int md = s;\\n            for(int i=0; i<n; i++){\\n                if(clips[i][0] <= s && clips[i][1] > md){\\n                    md = max(md, clips[i][1]);\\n                }\\n            }\\n            if(md == s) return -1;\\n            s = md;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827352,
                "title": "java-dp-oms-100-time-and-space-o-1-space-o-n-t-time",
                "content": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] arr  = new int[101];\\n//       Store  maximum number we can reach from given start point \\n        for(int i=0;i<clips.length;i++){\\n            arr[clips[i][0]]=Math.max(arr[clips[i][0]],clips[i][1]);\\n        }\\n//         find the maximum point we can reach until the given point\\n//         if max point we can reach from 1 is 9 and maximum point we can reach from 2 is 6 then       \\n//        update maximum point reached by 2 to 9\\n        for(int i=1;i<T+1;i++){\\n            arr[i]=Math.max(arr[i],arr[i-1]);\\n        }\\n        int steps=0;\\n//         current point\\n        int start=0;\\n        while(true){\\n//             get the maximum point for this start\\n            int lastNum=arr[start];\\n//             if this condition is true it means that all intervals starting before this point including current\\n//             start point can only reach a point which is less than or equal to current start point, so we can not \\n//            go beyond current start point ==> return -1  \\n            if(lastNum<=start)\\n                return -1;\\n            start=lastNum;\\n            steps++;\\n//             if you have reached a point which is greater than the T return steps\\n            if(lastNum>=T)\\n                return steps;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] arr  = new int[101];\\n//       Store  maximum number we can reach from given start point \\n        for(int i=0;i<clips.length;i++){\\n            arr[clips[i][0]]=Math.max(arr[clips[i][0]],clips[i][1]);\\n        }\\n//         find the maximum point we can reach until the given point\\n//         if max point we can reach from 1 is 9 and maximum point we can reach from 2 is 6 then       \\n//        update maximum point reached by 2 to 9\\n        for(int i=1;i<T+1;i++){\\n            arr[i]=Math.max(arr[i],arr[i-1]);\\n        }\\n        int steps=0;\\n//         current point\\n        int start=0;\\n        while(true){\\n//             get the maximum point for this start\\n            int lastNum=arr[start];\\n//             if this condition is true it means that all intervals starting before this point including current\\n//             start point can only reach a point which is less than or equal to current start point, so we can not \\n//            go beyond current start point ==> return -1  \\n            if(lastNum<=start)\\n                return -1;\\n            start=lastNum;\\n            steps++;\\n//             if you have reached a point which is greater than the T return steps\\n            if(lastNum>=T)\\n                return steps;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502376,
                "title": "readable-solution-to-sort-clips-by-start-o-n-logn-time",
                "content": "Steps:\\n1. Sort all clips by starting time.\\n2. Scan through sorted clips in order:\\n   1. Mark the ending time of current clip as max reachable time `maxReach`;\\n   2. Find all clips which overlap with current clip, and find the max reachable time of those clips `currentMaxReach`:\\n      - If we can reach further, i.e., `currentMaxReach > maxReach`, improve `maxReach` and count 1 more clip needed;\\n      - Otherwise, we can\\'t progress further to cover entire `[0,T]`.  \\n\\n```cpp\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n      sort(clips.begin(), clips.end()); // sort clips by start\\n      \\n      int i = 0; // clips index\\n      int maxReach = 0; // max time reachable by clips\\n      int cnt = 0; // number of clips needed\\n      \\n      while (maxReach < T) {\\n        int currentMaxReach = 0;\\n        while (i < clips.size() && clips[i][0] <= maxReach)\\n          currentMaxReach = max(currentMaxReach, clips[i++][1]);\\n        \\n        if (currentMaxReach <= maxReach) return -1; // can\\'t reach further\\n        maxReach = currentMaxReach;\\n        cnt++; // need an additional clip to reach new maxReach        \\n      }\\n      \\n      return cnt;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```cpp\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n      sort(clips.begin(), clips.end()); // sort clips by start\\n      \\n      int i = 0; // clips index\\n      int maxReach = 0; // max time reachable by clips\\n      int cnt = 0; // number of clips needed\\n      \\n      while (maxReach < T) {\\n        int currentMaxReach = 0;\\n        while (i < clips.size() && clips[i][0] <= maxReach)\\n          currentMaxReach = max(currentMaxReach, clips[i++][1]);\\n        \\n        if (currentMaxReach <= maxReach) return -1; // can\\'t reach further\\n        maxReach = currentMaxReach;\\n        cnt++; // need an additional clip to reach new maxReach        \\n      }\\n      \\n      return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 501432,
                "title": "python-greedy-solution-beat-90-base-on-start",
                "content": "n: number of clips, t: interver to fill\\nTime complexity :  O(nlogn+nt)? \\nSpace Complexity : O(t)\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        dp = [0] + [float(\\'inf\\')] * T\\n        s_clip = sorted(clips, key=lambda interval: interval[0]) #sorted by start line\\n        reachable = 0\\n        for clip in s_clip:\\n            if clip[0] > T: break\\n            if reachable < clip[0]: return -1\\n            for i in range(clip[0], min(clip[1]+1, T+1)):\\n                dp[i] = min(dp[i], dp[clip[0]]+1)\\n            if reachable < clip[1]: reachable = clip[1]\\n        return dp[T] if dp[T] != float(\\'inf\\') else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        dp = [0] + [float(\\'inf\\')] * T\\n        s_clip = sorted(clips, key=lambda interval: interval[0]) #sorted by start line\\n        reachable = 0\\n        for clip in s_clip:\\n            if clip[0] > T: break\\n            if reachable < clip[0]: return -1\\n            for i in range(clip[0], min(clip[1]+1, T+1)):\\n                dp[i] = min(dp[i], dp[clip[0]]+1)\\n            if reachable < clip[1]: reachable = clip[1]\\n        return dp[T] if dp[T] != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443591,
                "title": "greedy-algorithm-0-ms",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Video Stitching.\\nMemory Usage: 8.9 MB, less than 100.00% of C++ online submissions for Video Stitching.\\n\\n```cpp\\n// Greedy Algorithm\\n\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        // sort intervals by the end\\n        auto comp = [](auto& left, auto& right) { return left[1] < right[1]; };\\n        sort(clips.begin(), clips.end(), comp);\\n        \\n        int pos = clips.size() - 1;\\n        int ret = 0;\\n        while (pos >= 0 && T > 0) {            \\n            // greedy: find the left-most interval including T\\n            int min_left = INT_MAX;\\n            while (pos >= 0 && clips[pos][1] >= T) {\\n                if (clips[pos][0] <= T) // skip intervals on the right of T\\n                    min_left = min(min_left, clips[pos][0]);\\n                --pos;\\n            }\\n            \\n            if (min_left == INT_MAX) break;\\n            T = min_left;\\n            ++ret;\\n        }\\n        return T == 0 ? ret : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\n// Greedy Algorithm\\n\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        // sort intervals by the end\\n        auto comp = [](auto& left, auto& right) { return left[1] < right[1]; };\\n        sort(clips.begin(), clips.end(), comp);\\n        \\n        int pos = clips.size() - 1;\\n        int ret = 0;\\n        while (pos >= 0 && T > 0) {            \\n            // greedy: find the left-most interval including T\\n            int min_left = INT_MAX;\\n            while (pos >= 0 && clips[pos][1] >= T) {\\n                if (clips[pos][0] <= T) // skip intervals on the right of T\\n                    min_left = min(min_left, clips[pos][0]);\\n                --pos;\\n            }\\n            \\n            if (min_left == INT_MAX) break;\\n            T = min_left;\\n            ++ret;\\n        }\\n        return T == 0 ? ret : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349446,
                "title": "c-memoization-beats-100-time-and-93-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[105][105];\\n    int util(int T, vector< vector<int> > &clips, int idx) {\\n        if(idx < 0 && T != 0) return 1 << 30;\\n        if(T == 0) return 0;\\n        if(dp[idx][T]) return dp[idx][T];\\n\\t\\t\\n        int ans = 1<<30;\\n        for(int i = idx; i >= 0; i--) {\\n            if(clips[i][1] >= T) {\\n                ans = min(ans, 1 + util(clips[i][0], clips, i - 1));\\n            }\\n        }\\n        return dp[idx][T] = ans;\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(), clips.end(), [](const vector<int> &a, const vector<int> &b) {\\n            return a[1] < b[1];\\n        });\\n        int ans = util(T, clips, clips.size()-1);\\n        return (ans == (1<<30)) ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[105][105];\\n    int util(int T, vector< vector<int> > &clips, int idx) {\\n        if(idx < 0 && T != 0) return 1 << 30;\\n        if(T == 0) return 0;\\n        if(dp[idx][T]) return dp[idx][T];\\n\\t\\t\\n        int ans = 1<<30;\\n        for(int i = idx; i >= 0; i--) {\\n            if(clips[i][1] >= T) {\\n                ans = min(ans, 1 + util(clips[i][0], clips, i - 1));\\n            }\\n        }\\n        return dp[idx][T] = ans;\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(), clips.end(), [](const vector<int> &a, const vector<int> &b) {\\n            return a[1] < b[1];\\n        });\\n        int ans = util(T, clips, clips.size()-1);\\n        return (ans == (1<<30)) ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280814,
                "title": "straight-forward-dp-solution",
                "content": "We are looking to cover the interval [0, T].\\nSo DP state is the best solution for interval [i, j].\\nOur solution is dp[0][T];\\nWe calculate dp[i][j] when we iterate through all the clips and try to solve left from the beginning of the clip and right from the end of the clip.\\n\\n```\\n    vector<vector<int> > dp;\\n    vector<vector<int> > clips;\\n    int T;\\n\\n    int solve(int from, int to) {\\n       from = max(from, 0);\\n       to = min(to, T);\\n       if (from >= to) return 0;\\n       int &res = dp[from][to];\\n       if (res != -1) return res;\\n       res = INT_MAX;\\n       for (int i = 0; i < clips.size(); ++i) {\\n          int left = solve(from, clips[i][0]);\\n          if (left == INT_MAX) {\\n             continue;\\n          }\\n          int right = solve(clips[i][1], to);\\n          if (right == INT_MAX) {\\n             continue;\\n          }\\n          res = min(res, 1 + left + right);\\n       }\\n       return res;\\n    }\\n\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        this->clips = clips;\\n        this->T = T;\\n        dp.resize(T + 1, vector<int>(T + 1, -1));\\n        int res = solve(0, T);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<vector<int> > dp;\\n    vector<vector<int> > clips;\\n    int T;\\n\\n    int solve(int from, int to) {\\n       from = max(from, 0);\\n       to = min(to, T);\\n       if (from >= to) return 0;\\n       int &res = dp[from][to];\\n       if (res != -1) return res;\\n       res = INT_MAX;\\n       for (int i = 0; i < clips.size(); ++i) {\\n          int left = solve(from, clips[i][0]);\\n          if (left == INT_MAX) {\\n             continue;\\n          }\\n          int right = solve(clips[i][1], to);\\n          if (right == INT_MAX) {\\n             continue;\\n          }\\n          res = min(res, 1 + left + right);\\n       }\\n       return res;\\n    }\\n\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        this->clips = clips;\\n        this->T = T;\\n        dp.resize(T + 1, vector<int>(T + 1, -1));\\n        int res = solve(0, T);\\n        return res == INT_MAX ? -1 : res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270676,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int[] clip: clips) {\\n            if (!map.containsKey(clip[0])) {\\n                map.put(clip[0], new LinkedList<Integer>());\\n            }\\n            map.get(clip[0]).add(clip[1]);\\n        }\\n        if (!map.containsKey(0)) {\\n            return -1;\\n        } else {\\n            dp[0] = 0;\\n        }\\n        for(int i = 0; i <= T; i++) {\\n            if (map.containsKey(i)) {\\n                for(int value: map.get(i)) {\\n                    if (value > T) value = T;\\n                    for(int k = i+1; k <= value; k++)\\n                        dp[k] = Math.min(dp[k], dp[i]+1);\\n                }\\n            }\\n        }\\n        return dp[T] != Integer.MAX_VALUE? dp[T]: -1; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for(int[] clip: clips) {\\n            if (!map.containsKey(clip[0])) {\\n                map.put(clip[0], new LinkedList<Integer>());\\n            }\\n            map.get(clip[0]).add(clip[1]);\\n        }\\n        if (!map.containsKey(0)) {\\n            return -1;\\n        } else {\\n            dp[0] = 0;\\n        }\\n        for(int i = 0; i <= T; i++) {\\n            if (map.containsKey(i)) {\\n                for(int value: map.get(i)) {\\n                    if (value > T) value = T;\\n                    for(int k = i+1; k <= value; k++)\\n                        dp[k] = Math.min(dp[k], dp[i]+1);\\n                }\\n            }\\n        }\\n        return dp[T] != Integer.MAX_VALUE? dp[T]: -1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270634,
                "title": "c-o-n-t-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int prebound2 = 0, prebound1 = 0, newbound = 0, res = 0;\\n        vector<int> clip(T + 1, 0);\\n        for(auto i : clips)\\n            if(i[0] <= T)\\n            clip[i[0]] = max(clip[i[0]], i[1]);\\n        while(prebound2 < T){\\n            for(int i = prebound1; i <= prebound2; ++i)\\n                if(clip[i] > newbound) newbound = clip[i];\\n            if(newbound == prebound2) return -1;\\n            prebound1 = prebound2;\\n            prebound2 = newbound;\\n            ++res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int prebound2 = 0, prebound1 = 0, newbound = 0, res = 0;\\n        vector<int> clip(T + 1, 0);\\n        for(auto i : clips)\\n            if(i[0] <= T)\\n            clip[i[0]] = max(clip[i[0]], i[1]);\\n        while(prebound2 < T){\\n            for(int i = prebound1; i <= prebound2; ++i)\\n                if(clip[i] > newbound) newbound = clip[i];\\n            if(newbound == prebound2) return -1;\\n            prebound1 = prebound2;\\n            prebound2 = newbound;\\n            ++res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270192,
                "title": "python-dp-solution",
                "content": "dp[i][t] = minimum number of clips needed with length i and target t\\n\\nbase cases:\\ndp[i][0] = 1\\n\\nfor each clips start time c0\\n\\tdp[i][t] = min(dp[i-1][c0] + 1, dp[i][t])\\n```\\nclass Solution(object):\\n    def videoStitching(self, clips, T):\\n        \"\"\"\\n        :type clips: List[List[int]]\\n        :type T: int\\n        :rtype: int\\n        \"\"\"\\n        n = len(clips)\\n        clips.sort(key=lambda c: (c[0]))\\n        dp = [[float(\\'inf\\') for _ in range(T + 1)] for _ in range(n + 1)]\\n        for i in range(n + 1):\\n            dp[i][0] = 1\\n        for i in range(1, n + 1):\\n            c = clips[i-1]\\n            for t in range(0, T + 1):\\n                dp[i][t] = dp[i-1][t]\\n                if c[0] <= t <= c[1]:\\n                    if c[0] == 0:\\n                        dp[i][t] = 1\\n                    else:\\n                        dp[i][t] = min(dp[i-1][c[0]] + 1, dp[i][t])\\n        if dp[-1][-1] == float(\\'inf\\'):\\n            return -1\\n        return dp[-1][-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def videoStitching(self, clips, T):\\n        \"\"\"\\n        :type clips: List[List[int]]\\n        :type T: int\\n        :rtype: int\\n        \"\"\"\\n        n = len(clips)\\n        clips.sort(key=lambda c: (c[0]))\\n        dp = [[float(\\'inf\\') for _ in range(T + 1)] for _ in range(n + 1)]\\n        for i in range(n + 1):\\n            dp[i][0] = 1\\n        for i in range(1, n + 1):\\n            c = clips[i-1]\\n            for t in range(0, T + 1):\\n                dp[i][t] = dp[i-1][t]\\n                if c[0] <= t <= c[1]:\\n                    if c[0] == 0:\\n                        dp[i][t] = 1\\n                    else:\\n                        dp[i][t] = min(dp[i-1][c[0]] + 1, dp[i][t])\\n        if dp[-1][-1] == float(\\'inf\\'):\\n            return -1\\n        return dp[-1][-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270127,
                "title": "java-sorting-greedy-1ms",
                "content": "Greedy solution - we sort clips based on start time. Then finding max end time that we can achieve keeping start time before the prev end time. \\n\\nO(nlogn) time - sorting nlogn, plus linear time for scanning the array (every element visited once)\\nO(1) space - only state variables\\n```\\n    public int videoStitching(int[][] clips, int T) {\\n        Comparator<int[]> comp = new Comparator<int[]>() {\\n           public int compare(int[] ar1, int[] ar2) {\\n            return ar1[0] - ar2[0];    \\n           }\\n        };\\n        //sort clips based on the start time\\n        Arrays.sort(clips, comp);\\n        \\n        int res = 0;\\n        //state variables\\n        int min = 0, max = 0, i = 0;\\n        while ( i < clips.length ) {\\n            //checking if we have a gap - if prev end doesn\\'t ends before next start\\n            if (clips[i][0] > max)\\n                return -1;\\n            //rewinding forward to find the max end that has the start before the prev end\\n            int curMax = max;            \\n            while (i < clips.length && clips[i][0] <= max) {\\n                curMax = Math.max(curMax, clips[i++][1]);\\n            }\\n            //save new max end, increment the number of clips\\n            max = curMax;            \\n            res++;\\n            //check if we reach the target\\n            if (max >= T)\\n                return res;\\n        }        \\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n    public int videoStitching(int[][] clips, int T) {\\n        Comparator<int[]> comp = new Comparator<int[]>() {\\n           public int compare(int[] ar1, int[] ar2) {\\n            return ar1[0] - ar2[0];    \\n           }\\n        };\\n        //sort clips based on the start time\\n        Arrays.sort(clips, comp);\\n        \\n        int res = 0;\\n        //state variables\\n        int min = 0, max = 0, i = 0;\\n        while ( i < clips.length ) {\\n            //checking if we have a gap - if prev end doesn\\'t ends before next start\\n            if (clips[i][0] > max)\\n                return -1;\\n            //rewinding forward to find the max end that has the start before the prev end\\n            int curMax = max;            \\n            while (i < clips.length && clips[i][0] <= max) {\\n                curMax = Math.max(curMax, clips[i++][1]);\\n            }\\n            //save new max end, increment the number of clips\\n            max = curMax;            \\n            res++;\\n            //check if we reach the target\\n            if (max >= T)\\n                return res;\\n        }        \\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270004,
                "title": "leetcode-weekly-contest-131-screen-record",
                "content": "https://www.youtube.com/watch?v=bcrB6aN1pjk&feature=youtu.be\\n\\n```\\n5019. Video Stitching:\\n- O(nlogn + n*t)\\n- O(nlogn + n) sort + scan\\n\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(), clips.end());\\n        \\n         // t indicates the coverage time of selected videos([0, t]), and next_t indicates the latest time that we can cover after adding a video.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Since the current coverage time is [0, t], the interval of the next video [x, y] we need to find must satisfy x <= t.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // In all videos[x_i, y_i] that meet the criteria, obviously the video with the latest end time will be better.\\n        int n = clips.size(), ret = 0, t = 0, next_t = 0;\\n        for (int i = 0; i < n && t < T; i++) {\\n            if (clips[i][0] > t) {\\n                t = next_t;\\n                ++ret;\\n            }\\n            \\n            if (clips[i][0] > next_t) {\\n                break;\\n            }\\n            \\n            next_t = max(next_t, clips[i][1]);\\n        }\\n        \\n        if (t < T) {\\n            t = next_t;\\n            ++ret;\\n        }\\n        return t < T ? -1 : ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n5019. Video Stitching:\\n- O(nlogn + n*t)\\n- O(nlogn + n) sort + scan\\n\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(), clips.end());\\n        \\n         // t indicates the coverage time of selected videos([0, t]), and next_t indicates the latest time that we can cover after adding a video.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Since the current coverage time is [0, t], the interval of the next video [x, y] we need to find must satisfy x <= t.\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // In all videos[x_i, y_i] that meet the criteria, obviously the video with the latest end time will be better.\\n        int n = clips.size(), ret = 0, t = 0, next_t = 0;\\n        for (int i = 0; i < n && t < T; i++) {\\n            if (clips[i][0] > t) {\\n                t = next_t;\\n                ++ret;\\n            }\\n            \\n            if (clips[i][0] > next_t) {\\n                break;\\n            }\\n            \\n            next_t = max(next_t, clips[i][1]);\\n        }\\n        \\n        if (t < T) {\\n            t = next_t;\\n            ++ret;\\n        }\\n        return t < T ? -1 : ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063132,
                "title": "",
                "content": "# Intuition\\n\\u0416\\u0430\\u0434\\u043D\\u044B\\u0439 \\u0430\\u043B\\u0433\\u043E\\u0440\\u0438\\u0442\\u043C\\n\\n# Approach\\n\\u0420\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F \\u043E\\u0442\\u0431\\u043E\\u0440\\u043E\\u043C \\u043D\\u0430 \\u043A\\u0430\\u0436\\u0434\\u043E\\u043C \\u0438\\u043D\\u0442\\u0435\\u0440\\u0432\\u0430\\u043B\\u0435 \\u043B\\u0443\\u0447\\u0448\\u0435\\u0433\\u043E\\n\\n# Complexity\\n- Time complexity:\\n- O(n*log(n))\\n\\n\\n- Space complexity:\\n\\u0434\\u043E\\u043F\\u043E\\u043B\\u043D\\u0438\\u0442\\u0435\\u043B\\u044C\\u043D\\u0430\\u044F \\u043F\\u0430\\u043C\\u044F\\u0442\\u044C O(1)\\n\\n# Code\\n```\\nfunc videoStitching(clips [][]int, time int) int {\\n\\t// \\u0421\\u043E\\u0440\\u0442\\u0438\\u0440\\u0443\\u044E \\u0432\\u0441\\u0435 \\u043A\\u043B\\u0438\\u043F\\u044B \\u043F\\u043E \\u0432\\u043E\\u0437\\u0440\\u0430\\u0441\\u0442\\u0430\\u043D\\u0438\\u044E \\u043D\\u0430\\u0447\\u0430\\u043B\\u0430 \\u043A\\u0430\\u0436\\u0434\\u043E\\u0433\\u043E \\u043A\\u043B\\u0438\\u043F\\u0430.\\n\\n\\t// \\u0415\\u0441\\u043B\\u0438 \\u0437\\u0430\\u0434\\u0430\\u043D\\u043E \\u043D\\u0435 \\u0432\\u0435\\u0440\\u043D\\u043E\\u0435 \\u0434\\u043B\\u044F \\u043F\\u043E\\u0438\\u0441\\u043A\\u0430 \\u0441\\u043E\\u0441\\u0442\\u043E\\u044F\\u043D\\u0438\\u0435\\n\\tif len(clips) == 1 &&\\n\\t\\tclips[0][0] != 0 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tsort.Slice(clips, func(i, j int) bool {\\n\\t\\tif clips[i][0] < clips[j][0] {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tif clips[i][0] == clips[j][0] {\\n\\t\\t\\treturn clips[i][1] > clips[j][1]\\n\\t\\t}\\n\\n\\t\\treturn false\\n\\t})\\n\\n\\t// \\u0415\\u0441\\u043B\\u0438 \\u0437\\u0430\\u0434\\u0430\\u043D\\u043E \\u043D\\u0435 \\u0432\\u0435\\u0440\\u043D\\u043E\\u0435 \\u0434\\u043B\\u044F \\u043F\\u043E\\u0438\\u0441\\u043A\\u0430 \\u0441\\u043E\\u0441\\u0442\\u043E\\u044F\\u043D\\u0438\\u0435\\n\\tif clips[0][0] != 0 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\t// \\u041E\\u0442\\u0432\\u0435\\u0442 \\u043D\\u0430 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0443: \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E \\u043D\\u0435\\u043E\\u0431\\u0445\\u043E\\u0434\\u0438\\u043C\\u044B\\u0445 \\u043A\\u043B\\u0438\\u043F\\u043E\\u0432 \\u0434\\u043B\\u044F\\n\\t// \\u043F\\u043E\\u043A\\u0440\\u044B\\u0442\\u0438\\u044F \\u0438\\u043D\\u0442\\u0435\\u0440\\u0432\\u0430\\u043B\\u0430 [0, time]\\n\\tminCount := 1\\n\\t// \\u041C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u0430\\u044F \\u043D\\u0430 \\u0442\\u0435\\u043A\\u0443\\u0449\\u0438\\u0439 \\u043C\\u043E\\u043C\\u0435\\u043D\\u0442 \\u043D\\u0430\\u043A\\u043E\\u043F\\u043B\\u0435\\u043D\\u043D\\u0430\\u044F \\u0434\\u043B\\u0438\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0441\\u0442\\u044C \\u043A\\u043B\\u0438\\u043F\\u043E\\u0432\\n\\tmaxLasted := clips[0][1]\\n\\tfromClip := 0 // \\u043A\\u043B\\u0438\\u043F, \\u0441 \\u043A\\u043E\\u0442\\u043E\\u0440\\u043E\\u0433\\u043E \\u0441\\u043E\\u0431\\u0438\\u0440\\u0430\\u0435\\u043C\\u0441\\u044F \\u043F\\u0435\\u0440\\u0435\\u0431\\u0438\\u0440\\u0430\\u0442\\u044C\\u0441\\u044F \\u0432 \\u0441\\u043B\\u0435\\u0434\\u0443\\u044E\\u0449\\u0438\\u0439 \\u043A\\u043B\\u0438\\u043F\\n\\n\\tif maxLasted >= time {\\n\\t\\treturn minCount\\n\\t}\\n\\n\\tfor {\\n\\t\\tbestClipId := -1\\n\\t\\tmaxLastedPrev := -1\\n\\t\\t// \\u0414\\u043B\\u044F \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0433\\u043E \\u0438\\u043D\\u0442\\u0435\\u0440\\u0432\\u0430\\u043B\\u0430 \\u0438\\u0449\\u0435\\u0442\\u0441\\u044F \\u043B\\u0443\\u0447\\u0448\\u0438\\u0439 \\u0434\\u043B\\u044F \\u043F\\u0435\\u0440\\u0435\\u0445\\u043E\\u0434\\u0430\\n\\t\\t// \\u0432 \\u043F\\u0440\\u0435\\u0434\\u0435\\u043B\\u0430\\u0445 \\u0433\\u0440\\u0430\\u043D\\u0438\\u0446\\u044B \\u043A\\u043B\\u0438\\u043F\\u0430 fromClip\\n\\t\\tfor i := fromClip; i < len(clips); i++ {\\n\\t\\t\\tif clips[i][0] <= clips[fromClip][1] &&\\n\\t\\t\\t\\tmaxLasted < clips[i][1] {\\n\\t\\t\\t\\tmaxLastedPrev = maxLasted\\n\\n\\t\\t\\t\\tmaxLasted = clips[i][1]\\n\\n\\t\\t\\t\\tbestClipId = i\\n\\t\\t\\t}\\n\\n\\t\\t\\t// \\u0415\\u0441\\u043B\\u0438 \\u0434\\u043E\\u0441\\u0442\\u0438\\u0433\\u043D\\u0443\\u0442 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0442\\u043E \\u0432\\u044B\\u0445\\u043E\\u0434\\n\\t\\t\\tif maxLasted >= time {\\n\\t\\t\\t\\tminCount++\\n\\t\\t\\t\\treturn minCount\\n\\t\\t\\t}\\n\\n\\t\\t\\t// \\u0415\\u0441\\u043B\\u0438 \\u043F\\u0435\\u0440\\u0435\\u0448\\u043B\\u0438 \\u0433\\u0440\\u0430\\u043D\\u0438\\u0446\\u0443 \\u043F\\u043E\\u0438\\u0441\\u043A\\u0430 \\u043A\\u043B\\u0438\\u043F\\u043E\\u0432 \\u0437\\u0430 \\u0433\\u0440\\u0430\\u043D\\u0438\\u0446\\u0443 clips[fromClip],\\n\\t\\t\\t// \\u0442\\u043E \\u0434\\u0430\\u043B\\u044C\\u0448\\u0435 \\u043D\\u0435 \\u0438\\u0449\\u0435\\u043C\\n\\t\\t\\tif clips[i][0] > clips[fromClip][1] {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// \\u0415\\u0441\\u043B\\u0438 \\u0434\\u043E\\u0441\\u0442\\u0438\\u0433\\u043D\\u0443\\u0442 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0442\\u043E \\u0432\\u044B\\u0445\\u043E\\u0434\\n\\t\\tif maxLasted >= time {\\n\\t\\t\\tminCount++\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// \\u0435\\u0441\\u043B\\u0438 \\u043F\\u0435\\u0440\\u0435\\u0445\\u043E\\u0434 \\u043D\\u0435 \\u043E\\u0441\\u0443\\u0449\\u0435\\u0441\\u0442\\u0432\\u0438\\u043B\\u0441\\u044F, \\u0442\\u043E \\u043E\\u0442\\u0432\\u0435\\u0442\\u0430 \\u043D\\u0435\\u0442\\n\\t\\tif maxLastedPrev == -1 {\\n\\t\\t\\tminCount = -1\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// \\u0421\\u043B\\u0435\\u0434\\u0443\\u044E\\u0449\\u0438\\u0439 \\u043A\\u043B\\u0438\\u043F \\u0432 \\u043F\\u043E\\u043A\\u0440\\u044B\\u0442\\u0438\\u0438, \\u0441 \\u043A\\u043E\\u0442\\u043E\\u0440\\u043E\\u0433\\u043E \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043E\\u0441\\u0443\\u0449\\u0435\\u0441\\u0442\\u0432\\u043B\\u0451\\u043D \\u043F\\u0440\\u044B\\u0436\\u043E\\u043A\\n\\t\\t// \\u0441\\u043C\\u0435\\u0449\\u0430\\u0435\\u0442\\u0441\\u044F \\u043D\\u0430 \\u0442\\u043E\\u0442, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043F\\u0440\\u0438\\u0437\\u043D\\u0430\\u043D \\u0441\\u0430\\u043C\\u044B\\u043C \\u043B\\u0443\\u0447\\u0448\\u0438\\u043C\\n\\t\\tfromClip = bestClipId\\n\\t\\tminCount++\\n\\t}\\n\\n\\treturn minCount\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc videoStitching(clips [][]int, time int) int {\\n\\t// \\u0421\\u043E\\u0440\\u0442\\u0438\\u0440\\u0443\\u044E \\u0432\\u0441\\u0435 \\u043A\\u043B\\u0438\\u043F\\u044B \\u043F\\u043E \\u0432\\u043E\\u0437\\u0440\\u0430\\u0441\\u0442\\u0430\\u043D\\u0438\\u044E \\u043D\\u0430\\u0447\\u0430\\u043B\\u0430 \\u043A\\u0430\\u0436\\u0434\\u043E\\u0433\\u043E \\u043A\\u043B\\u0438\\u043F\\u0430.\\n\\n\\t// \\u0415\\u0441\\u043B\\u0438 \\u0437\\u0430\\u0434\\u0430\\u043D\\u043E \\u043D\\u0435 \\u0432\\u0435\\u0440\\u043D\\u043E\\u0435 \\u0434\\u043B\\u044F \\u043F\\u043E\\u0438\\u0441\\u043A\\u0430 \\u0441\\u043E\\u0441\\u0442\\u043E\\u044F\\u043D\\u0438\\u0435\\n\\tif len(clips) == 1 &&\\n\\t\\tclips[0][0] != 0 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tsort.Slice(clips, func(i, j int) bool {\\n\\t\\tif clips[i][0] < clips[j][0] {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\n\\t\\tif clips[i][0] == clips[j][0] {\\n\\t\\t\\treturn clips[i][1] > clips[j][1]\\n\\t\\t}\\n\\n\\t\\treturn false\\n\\t})\\n\\n\\t// \\u0415\\u0441\\u043B\\u0438 \\u0437\\u0430\\u0434\\u0430\\u043D\\u043E \\u043D\\u0435 \\u0432\\u0435\\u0440\\u043D\\u043E\\u0435 \\u0434\\u043B\\u044F \\u043F\\u043E\\u0438\\u0441\\u043A\\u0430 \\u0441\\u043E\\u0441\\u0442\\u043E\\u044F\\u043D\\u0438\\u0435\\n\\tif clips[0][0] != 0 {\\n\\t\\treturn -1\\n\\t}\\n\\n\\t// \\u041E\\u0442\\u0432\\u0435\\u0442 \\u043D\\u0430 \\u0437\\u0430\\u0434\\u0430\\u0447\\u0443: \\u043C\\u0438\\u043D\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u043E\\u0435 \\u0447\\u0438\\u0441\\u043B\\u043E \\u043D\\u0435\\u043E\\u0431\\u0445\\u043E\\u0434\\u0438\\u043C\\u044B\\u0445 \\u043A\\u043B\\u0438\\u043F\\u043E\\u0432 \\u0434\\u043B\\u044F\\n\\t// \\u043F\\u043E\\u043A\\u0440\\u044B\\u0442\\u0438\\u044F \\u0438\\u043D\\u0442\\u0435\\u0440\\u0432\\u0430\\u043B\\u0430 [0, time]\\n\\tminCount := 1\\n\\t// \\u041C\\u0430\\u043A\\u0441\\u0438\\u043C\\u0430\\u043B\\u044C\\u043D\\u0430\\u044F \\u043D\\u0430 \\u0442\\u0435\\u043A\\u0443\\u0449\\u0438\\u0439 \\u043C\\u043E\\u043C\\u0435\\u043D\\u0442 \\u043D\\u0430\\u043A\\u043E\\u043F\\u043B\\u0435\\u043D\\u043D\\u0430\\u044F \\u0434\\u043B\\u0438\\u0442\\u0435\\u043B\\u044C\\u043D\\u043E\\u0441\\u0442\\u044C \\u043A\\u043B\\u0438\\u043F\\u043E\\u0432\\n\\tmaxLasted := clips[0][1]\\n\\tfromClip := 0 // \\u043A\\u043B\\u0438\\u043F, \\u0441 \\u043A\\u043E\\u0442\\u043E\\u0440\\u043E\\u0433\\u043E \\u0441\\u043E\\u0431\\u0438\\u0440\\u0430\\u0435\\u043C\\u0441\\u044F \\u043F\\u0435\\u0440\\u0435\\u0431\\u0438\\u0440\\u0430\\u0442\\u044C\\u0441\\u044F \\u0432 \\u0441\\u043B\\u0435\\u0434\\u0443\\u044E\\u0449\\u0438\\u0439 \\u043A\\u043B\\u0438\\u043F\\n\\n\\tif maxLasted >= time {\\n\\t\\treturn minCount\\n\\t}\\n\\n\\tfor {\\n\\t\\tbestClipId := -1\\n\\t\\tmaxLastedPrev := -1\\n\\t\\t// \\u0414\\u043B\\u044F \\u0442\\u0435\\u043A\\u0443\\u0449\\u0435\\u0433\\u043E \\u0438\\u043D\\u0442\\u0435\\u0440\\u0432\\u0430\\u043B\\u0430 \\u0438\\u0449\\u0435\\u0442\\u0441\\u044F \\u043B\\u0443\\u0447\\u0448\\u0438\\u0439 \\u0434\\u043B\\u044F \\u043F\\u0435\\u0440\\u0435\\u0445\\u043E\\u0434\\u0430\\n\\t\\t// \\u0432 \\u043F\\u0440\\u0435\\u0434\\u0435\\u043B\\u0430\\u0445 \\u0433\\u0440\\u0430\\u043D\\u0438\\u0446\\u044B \\u043A\\u043B\\u0438\\u043F\\u0430 fromClip\\n\\t\\tfor i := fromClip; i < len(clips); i++ {\\n\\t\\t\\tif clips[i][0] <= clips[fromClip][1] &&\\n\\t\\t\\t\\tmaxLasted < clips[i][1] {\\n\\t\\t\\t\\tmaxLastedPrev = maxLasted\\n\\n\\t\\t\\t\\tmaxLasted = clips[i][1]\\n\\n\\t\\t\\t\\tbestClipId = i\\n\\t\\t\\t}\\n\\n\\t\\t\\t// \\u0415\\u0441\\u043B\\u0438 \\u0434\\u043E\\u0441\\u0442\\u0438\\u0433\\u043D\\u0443\\u0442 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0442\\u043E \\u0432\\u044B\\u0445\\u043E\\u0434\\n\\t\\t\\tif maxLasted >= time {\\n\\t\\t\\t\\tminCount++\\n\\t\\t\\t\\treturn minCount\\n\\t\\t\\t}\\n\\n\\t\\t\\t// \\u0415\\u0441\\u043B\\u0438 \\u043F\\u0435\\u0440\\u0435\\u0448\\u043B\\u0438 \\u0433\\u0440\\u0430\\u043D\\u0438\\u0446\\u0443 \\u043F\\u043E\\u0438\\u0441\\u043A\\u0430 \\u043A\\u043B\\u0438\\u043F\\u043E\\u0432 \\u0437\\u0430 \\u0433\\u0440\\u0430\\u043D\\u0438\\u0446\\u0443 clips[fromClip],\\n\\t\\t\\t// \\u0442\\u043E \\u0434\\u0430\\u043B\\u044C\\u0448\\u0435 \\u043D\\u0435 \\u0438\\u0449\\u0435\\u043C\\n\\t\\t\\tif clips[i][0] > clips[fromClip][1] {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\t// \\u0415\\u0441\\u043B\\u0438 \\u0434\\u043E\\u0441\\u0442\\u0438\\u0433\\u043D\\u0443\\u0442 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0442\\u043E \\u0432\\u044B\\u0445\\u043E\\u0434\\n\\t\\tif maxLasted >= time {\\n\\t\\t\\tminCount++\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// \\u0435\\u0441\\u043B\\u0438 \\u043F\\u0435\\u0440\\u0435\\u0445\\u043E\\u0434 \\u043D\\u0435 \\u043E\\u0441\\u0443\\u0449\\u0435\\u0441\\u0442\\u0432\\u0438\\u043B\\u0441\\u044F, \\u0442\\u043E \\u043E\\u0442\\u0432\\u0435\\u0442\\u0430 \\u043D\\u0435\\u0442\\n\\t\\tif maxLastedPrev == -1 {\\n\\t\\t\\tminCount = -1\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\n\\t\\t// \\u0421\\u043B\\u0435\\u0434\\u0443\\u044E\\u0449\\u0438\\u0439 \\u043A\\u043B\\u0438\\u043F \\u0432 \\u043F\\u043E\\u043A\\u0440\\u044B\\u0442\\u0438\\u0438, \\u0441 \\u043A\\u043E\\u0442\\u043E\\u0440\\u043E\\u0433\\u043E \\u0431\\u0443\\u0434\\u0435\\u0442 \\u043E\\u0441\\u0443\\u0449\\u0435\\u0441\\u0442\\u0432\\u043B\\u0451\\u043D \\u043F\\u0440\\u044B\\u0436\\u043E\\u043A\\n\\t\\t// \\u0441\\u043C\\u0435\\u0449\\u0430\\u0435\\u0442\\u0441\\u044F \\u043D\\u0430 \\u0442\\u043E\\u0442, \\u043A\\u043E\\u0442\\u043E\\u0440\\u044B\\u0439 \\u043F\\u0440\\u0438\\u0437\\u043D\\u0430\\u043D \\u0441\\u0430\\u043C\\u044B\\u043C \\u043B\\u0443\\u0447\\u0448\\u0438\\u043C\\n\\t\\tfromClip = bestClipId\\n\\t\\tminCount++\\n\\t}\\n\\n\\treturn minCount\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983759,
                "title": "with-similar-problems",
                "content": "# Code\\n``` java []\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        Arrays.sort(clips, (a,b)->a[0]-b[0]);\\n        int n = clips.length;\\n        int curEnd = 0, farCanReach = 0, total = 0;\\n        int i=0;\\n        while(curEnd < time) {\\n            total++;\\n            while(i<n && curEnd >= clips[i][0]) {\\n                farCanReach = Math.max(farCanReach, clips[i++][1]);\\n            }\\n            if(farCanReach == curEnd) {\\n                return -1;\\n            }\\n            curEnd = farCanReach;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        Arrays.sort(clips, (a,b)->a[0]-b[0]);\\n        int n = clips.length;\\n        int curEnd = 0, farCanReach = 0, total = 0;\\n        int i=0;\\n        while(curEnd < time) {\\n            total++;\\n            while(i<n && curEnd >= clips[i][0]) {\\n                farCanReach = Math.max(farCanReach, clips[i++][1]);\\n            }\\n            if(farCanReach == curEnd) {\\n                return -1;\\n            }\\n            curEnd = farCanReach;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551128,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\n public:\\n  int videoStitching(vector<vector<int>>& clips, int time) {\\n    int ans = 0;\\n    int end = 0;\\n    int farthest = 0;\\n\\n    sort(std::begin(clips), std::end(clips));\\n\\n    int i = 0;\\n    while (farthest < time) {\\n      while (i < clips.size() && clips[i][0] <= end)\\n        farthest = max(farthest, clips[i++][1]);\\n      if (end == farthest)\\n        return -1;\\n      ++ans;\\n      end = farthest;\\n    }\\n    return ans;\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        stack = [[0,0]]\\n        for c in sorted(clips, key=lambda c: c[0]):\\n            while len(stack) > 1 and stack[-2][1] >= c[0] and stack[-1][1] < c[1]:\\n                stack.pop()\\n            if stack[-1][1] < c[0]: break\\n            if c[1] >= time: return len(stack)\\n            stack.append(c)\\n        return -1\\n```\\n\\n```Java []\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int min = 0;\\n        int max = 0;\\n        int total = 0;\\n        \\n        while(max<time) {\\n            \\n            for(int[] clip : clips) {\\n                int left = clip[0];\\n                int right = clip[1];\\n                \\n                if(left<=min && right >max) {\\n                    max = right;\\n                }\\n            }\\n            if(min == max) {\\n                return -1;\\n            }\\n            min = max;\\n            total++;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\n public:\\n  int videoStitching(vector<vector<int>>& clips, int time) {\\n    int ans = 0;\\n    int end = 0;\\n    int farthest = 0;\\n\\n    sort(std::begin(clips), std::end(clips));\\n\\n    int i = 0;\\n    while (farthest < time) {\\n      while (i < clips.size() && clips[i][0] <= end)\\n        farthest = max(farthest, clips[i++][1]);\\n      if (end == farthest)\\n        return -1;\\n      ++ans;\\n      end = farthest;\\n    }\\n    return ans;\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        stack = [[0,0]]\\n        for c in sorted(clips, key=lambda c: c[0]):\\n            while len(stack) > 1 and stack[-2][1] >= c[0] and stack[-1][1] < c[1]:\\n                stack.pop()\\n            if stack[-1][1] < c[0]: break\\n            if c[1] >= time: return len(stack)\\n            stack.append(c)\\n        return -1\\n```\n```Java []\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int min = 0;\\n        int max = 0;\\n        int total = 0;\\n        \\n        while(max<time) {\\n            \\n            for(int[] clip : clips) {\\n                int left = clip[0];\\n                int right = clip[1];\\n                \\n                if(left<=min && right >max) {\\n                    max = right;\\n                }\\n            }\\n            if(min == max) {\\n                return -1;\\n            }\\n            min = max;\\n            total++;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3326289,
                "title": "python-greedy-with-sorting-comprehensive-explanation",
                "content": "# Intuition\\n\\nThe problem is to stitch video clips in a way that the resulting video covers the entire desired time, and we should use as few clips as possible. To achieve this, we need to select clips that start at or before the current end time and extend the video as far as possible.\\n\\n# Algorithm\\n1. Sort the input clips based on their start times.\\n2. Initialize num_clips to 0, current_end_time to 0, and i to 0.\\n3. While i is less than the number of clips:\\n    a. If clips[i][0] is greater than current_end_time, return -1.\\n    b. Initialize max_end_time to current_end_time.\\n    c. While i is less than the number of clips and clips[i][0] is less than or equal to current_end_time:\\n        - i. Update max_end_time to the maximum of max_end_time and clips[i][1].\\n        - ii. Increment i.\\nd. Increment num_clips.\\ne. Update current_end_time to max_end_time.\\nf. If current_end_time is greater than or equal to time, return num_clips.\\n4. Return -1, as the video cannot be stitched to cover the entire desired time.\\n\\n# Complexity\\n - Time complexity: $O(n \\\\cdot log(n))$, where $n$ is the number of clips. The sorting step has a time complexity of $O(n \\\\cdot log(n))$, and the rest of the algorithm takes\\n\\n- Space complexity: $O(1)$, since we only use a constant amount of additional space to store variables like num_clips, current_end_time, and max_end_time.\\n\\n# Code\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        clips.sort(key=lambda x: x[0])  \\n\\n        num_clips = 0\\n        current_end_time = 0\\n        i = 0\\n        \\n        while i < len(clips):\\n            if clips[i][0] > current_end_time:\\n                return -1\\n            \\n            max_end_time = current_end_time\\n            while i < len(clips) and clips[i][0] <= current_end_time:\\n                max_end_time = max(max_end_time, clips[i][1])\\n                i += 1\\n                \\n            num_clips += 1\\n            current_end_time = max_end_time\\n            \\n            if current_end_time >= time:\\n                return num_clips\\n            \\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        clips.sort(key=lambda x: x[0])  \\n\\n        num_clips = 0\\n        current_end_time = 0\\n        i = 0\\n        \\n        while i < len(clips):\\n            if clips[i][0] > current_end_time:\\n                return -1\\n            \\n            max_end_time = current_end_time\\n            while i < len(clips) and clips[i][0] <= current_end_time:\\n                max_end_time = max(max_end_time, clips[i][1])\\n                i += 1\\n                \\n            num_clips += 1\\n            current_end_time = max_end_time\\n            \\n            if current_end_time >= time:\\n                return num_clips\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157894,
                "title": "greedy-o-1-space-beats-100-time",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKind of a level order traversal, being greedy on the end of each clip merge which should be the higest value possible.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn) : because of the sorting\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n=clips.size();\\n        sort(clips.begin(),clips.end());\\n        int numofclips=1;\\n        int end=0;\\n        for(int i=0; i<n;){\\n            int newend=end;\\n            while(i<n && clips[i][0]<=end) newend=max(newend,clips[i++][1]);\\n            if(newend>=time) return numofclips;\\n            if(newend==end) return -1;\\n            end=newend;\\n            numofclips++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int n=clips.size();\\n        sort(clips.begin(),clips.end());\\n        int numofclips=1;\\n        int end=0;\\n        for(int i=0; i<n;){\\n            int newend=end;\\n            while(i<n && clips[i][0]<=end) newend=max(newend,clips[i++][1]);\\n            if(newend>=time) return numofclips;\\n            if(newend==end) return -1;\\n            end=newend;\\n            numofclips++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128979,
                "title": "kotlin-without-sorting",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport kotlin.math.max\\n\\nclass Solution {\\n    fun videoStitching(clips: Array<IntArray>, time: Int): Int {\\n        val cTime = mutableMapOf<Int, Int>()\\n\\n        for ((s, e) in clips) {\\n            val clip = cTime[s]\\n            if (clip != null) cTime[s] = max(clip, e)\\n            else cTime[s] = e\\n        }\\n\\n        var result = 0\\n        var i = 0\\n\\n        while (i < time) {\\n            val possPicks = cTime.filter { (k ,v) -> i in k until v }\\n            if (possPicks.isEmpty()) return -1\\n            var j = 0\\n            possPicks.forEach { (_, v) -> if (v - i > j) j = v - i }\\n            i += j\\n            result++\\n        }\\n        return result\\n    }\\n}\\n```\\n![Screen Shot 2023-02-02 at 00.17.46.png](https://assets.leetcode.com/users/images/dfc3354d-86c7-40d4-a69f-13b31b80d7a8_1675287834.3006735.png)",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nimport kotlin.math.max\\n\\nclass Solution {\\n    fun videoStitching(clips: Array<IntArray>, time: Int): Int {\\n        val cTime = mutableMapOf<Int, Int>()\\n\\n        for ((s, e) in clips) {\\n            val clip = cTime[s]\\n            if (clip != null) cTime[s] = max(clip, e)\\n            else cTime[s] = e\\n        }\\n\\n        var result = 0\\n        var i = 0\\n\\n        while (i < time) {\\n            val possPicks = cTime.filter { (k ,v) -> i in k until v }\\n            if (possPicks.isEmpty()) return -1\\n            var j = 0\\n            possPicks.forEach { (_, v) -> if (v - i > j) j = v - i }\\n            i += j\\n            result++\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2861994,
                "title": "c-dp-memoization-recursive-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n\\nvector<int>dp;\\nint solve(vector<vector<int>>& clips, int T,int idx,int last_end)\\n{\\n    if(T<=last_end)\\n        return 0;\\n    if(idx>=clips.size() )\\n        return 100;\\n    if(dp[last_end]!=-1)\\n        return dp[last_end];\\n     if(clips[idx][0]<=last_end)\\n    {\\n        return dp[last_end]=min(solve(clips,T,idx+1,last_end),1+solve(clips,T,idx+1,clips[idx][1]));\\n    }\\n    else\\n    {\\n        return dp[last_end]=100;\\n    }\\n       \\n}\\nint videoStitching(vector<vector<int>>& clips, int T)\\n{\\n    dp.resize(T+1,-1);\\n    sort(clips.begin(),clips.end());\\n    int p=solve(clips,T,0,0);\\n    if(p>=100)\\n        return -1;\\n    else\\n        return p;\\n}\\n};\\nif you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n\\nvector<int>dp;\\nint solve(vector<vector<int>>& clips, int T,int idx,int last_end)\\n{\\n    if(T<=last_end)\\n        return 0;\\n    if(idx>=clips.size() )\\n        return 100;\\n    if(dp[last_end]!=-1)\\n        return dp[last_end];\\n     if(clips[idx][0]<=last_end)\\n    {\\n        return dp[last_end]=min(solve(clips,T,idx+1,last_end),1+solve(clips,T,idx+1,clips[idx][1]));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2843131,
                "title": "cpp-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long dp[101][101];\\n    long helper(int i, int prev, vector<vector<int>>&clips, int time){\\n        if(i==clips.size()){\\n            if(time<=prev){\\n                return 0;\\n            }\\n            return 1e9;\\n        }\\n        if(dp[i][prev]!=-1) return dp[i][prev];\\n        long pick=1e9;\\n        if(clips[i][0]<=prev){\\n            pick=1+helper(i+1,clips[i][1],clips,time);\\n        }\\n        long notpick=helper(i+1,prev,clips,time);\\n        return dp[i][prev]=min(pick,notpick);\\n    }\\n    long videoStitching(vector<vector<int>>& clips, int time) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(clips.begin(),clips.end());\\n        long ans=helper(0,0,clips,time);\\n        if(ans>=1e9) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long dp[101][101];\\n    long helper(int i, int prev, vector<vector<int>>&clips, int time){\\n        if(i==clips.size()){\\n            if(time<=prev){\\n                return 0;\\n            }\\n            return 1e9;\\n        }\\n        if(dp[i][prev]!=-1) return dp[i][prev];\\n        long pick=1e9;\\n        if(clips[i][0]<=prev){\\n            pick=1+helper(i+1,clips[i][1],clips,time);\\n        }\\n        long notpick=helper(i+1,prev,clips,time);\\n        return dp[i][prev]=min(pick,notpick);\\n    }\\n    long videoStitching(vector<vector<int>>& clips, int time) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(clips.begin(),clips.end());\\n        long ans=helper(0,0,clips,time);\\n        if(ans>=1e9) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744314,
                "title": "0-1-knapsack-model",
                "content": "```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& a, int time,int ind,int prev){\\n        if(ind == a.size()){\\n            if(prev >= time){\\n                return 0;\\n            }\\n            return 1e9;\\n        }\\n        int ans = 1e9;\\n        int ans1 = fun(a,time,ind+1,prev);\\n        ans = min(ans,ans1);\\n        if(a[ind][0] <= prev){\\n            int ans2 = 1+fun(a,time,ind+1,a[ind][1]);\\n            ans = min(ans,ans2);\\n        }\\n        return ans;\\n    }\\n    int videoStitching(vector<vector<int>>& a, int time) {\\n        sort(a.begin(),a.end());\\n        int ans = fun(a,time,0,0);\\n        if(ans == 1e9){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(vector<vector<int>>& a, int time,int ind,int prev){\\n        if(ind == a.size()){\\n            if(prev >= time){\\n                return 0;\\n            }\\n            return 1e9;\\n        }\\n        int ans = 1e9;\\n        int ans1 = fun(a,time,ind+1,prev);\\n        ans = min(ans,ans1);\\n        if(a[ind][0] <= prev){\\n            int ans2 = 1+fun(a,time,ind+1,a[ind][1]);\\n            ans = min(ans,ans2);\\n        }\\n        return ans;\\n    }\\n    int videoStitching(vector<vector<int>>& a, int time) {\\n        sort(a.begin(),a.end());\\n        int ans = fun(a,time,0,0);\\n        if(ans == 1e9){\\n            return -1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736168,
                "title": "python-greedy",
                "content": "This one\\'s a real twist to the classic interval problem(s).\\nThe resolution structure remains the same for the most part, with 2 key steps:\\n* **Sorting the intervals by start ASC, [end DESC]**\\n* **Iterating through the intervals once**, keeping track of (at least) the last interval or part of it (be it the start and end of such interval, or just the end, etc).\\n\\n[I\\'m not gonna leave a full explanation but just the key cases and some considerations for the later presented code, which I tried my best to make self-explanatory. Also, there is some redundancy in it for the sake of clarity]\\n\\n-------------------\\n\\nThe first difference here is that the \"last interval\" is not going to be a definitive part of our solution. It can actually be replaced by another interval later in the iteration.\\n\\nConsider this case. Suppose you currently have a greedy solution like:\\n`solutionIntervals = [ [0,2], [1,5] ]` and you\\'re considering `[2,9]`. \\nThen `[1,5]` must be discarded in favour of `[2,9]`.\\nNow, notice you only need to keep track of the last one and the second-to-last one, for example:\\nYour clips are\\n`[ [0,4], [2,5], [3,6], [4,9] ]`\\nThen your iterations will be something like\\n0.`[0,4]` must be part of the answer\\n1.`[2,5]` contains [4, 5] which we hadn\\'t seen before so include `[2,5]` as candidate. `solutionIntervals = [ [0,4], [2,5] ]`\\n2.`[3,6]` starts before 4 and includes [5, 6], which `[2,5]` doesn\\'t. So we must discard `[2,5]` in favour of `[3,6]` to obtain [0, 6]. `solutionIntervals = [ [0,4], [3,6] ]`\\n3.`[4,9]` starts at 4, and includes [6, 9] which `[3,6]` doesn\\'t. So replace `[3,6]` by `[4,9]`. `solutionIntervals = [ [0,4], [4,9] ]`\\n\\nI know I actually owe a mathematical proof to why everything before the last element in `solutionIntervals` is a definitive part of the answer (that is an invariant of this algorithm btw), I guess it could be proven by contradiction. Do interviewers care about this? I don\\'t know for sure.\\n\\nAside from this case, all you need to do is add the current interval if it adds some bit of the video we hadn\\'t seen before (ie if end > currentEnd)\\n\\n--------------------\\n\\nThat being said, the following algorithm is of **O(NlogN)** time complexity, and **O(N)** space complexity, and it could be improved to **O(1)** (space).\\n\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef videoStitching(self, clips: List[List[int]], time: int) -> int:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Sort the clips by start time \\n\\t\\t\\t\\tclips.sort(key=lambda x: (x[0], -x[1]))\\n\\n\\t\\t\\t\\ttotal = 1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# This is a list where all of the intervals are a definitive part of our solution, except possibly the last one.\\n\\t\\t\\t\\t# This makes our code O(N) in memory, but we could actually make it O(1).\\n\\t\\t\\t\\t# I\\'ll leave that as homework for the reader(?)\\n\\t\\t\\t\\tintervals = [clips[0]]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# The first interval must always be considered. If there exists a solution at all, it is a definitive part of it.\\n\\t\\t\\t\\tcurrStart = clips[0][0]\\n\\t\\t\\t\\tcurrEnd = clips[0][1]\\n\\n\\t\\t\\t\\t# Minimum start time out of all clips is > 0 ? Forget it, the event has not been fully recorded\\n\\t\\t\\t\\tif currStart > 0:\\n\\t\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\t\\t# The first clip begins at 0 and \\n\\t\\t\\t\\tif currEnd >= time:\\n\\t\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\t\\tfor start, end in clips[1:]:\\n\\t\\t\\t\\t\\t# eg suppose you have intervals: [ [0,2], [1,9] ] and you consider [3, 4]. It must be discarded\\n\\t\\t\\t\\t\\tif end < currEnd:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\t\\t# If there is only one interval in the list, then you cannot replace it.\\n\\t\\t\\t\\t\\tif len(intervals) == 1:\\n\\t\\t\\t\\t\\t\\t# Default case where you have missing bits of the video\\n\\t\\t\\t\\t\\t\\tif start > currEnd:\\n\\t\\t\\t\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\t\\t\\t\\tcurrStart = start\\n\\t\\t\\t\\t\\t\\tcurrEnd = end\\n\\t\\t\\t\\t\\t\\tintervals.append([start, end])\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t# This is the case where you replace an interval.\\n\\t\\t\\t\\t\\t\\tif start <= intervals[-2][1] and end > currEnd:\\n\\t\\t\\t\\t\\t\\t\\tintervals.pop()\\n\\t\\t\\t\\t\\t\\t\\tcurrStart = start\\n\\t\\t\\t\\t\\t\\t\\tcurrEnd = end\\n\\t\\t\\t\\t\\t\\t\\tintervals.append([start, end])\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# Missing bits of the video again\\n\\t\\t\\t\\t\\t\\telif start > currEnd:\\n\\t\\t\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# We know we\\'re not missing anything from the video and we\\'re including parts we hadn\\'t seen before\\n\\t\\t\\t\\t\\t\\telif end > currEnd:\\n\\t\\t\\t\\t\\t\\t\\tcurrStart = start\\n\\t\\t\\t\\t\\t\\t\\tcurrEnd = end\\n\\t\\t\\t\\t\\t\\t\\tintervals.append([start, end])\\n\\n\\t\\t\\t\\t\\t# if for some reason we reach the end of the video, stop the iteration there\\n\\t\\t\\t\\t\\tif currEnd >= time:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t# return -1 if we haven\\'t actually reached the end of the video\\n\\t\\t\\t\\treturn len(intervals) if currEnd >= time else -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "This one\\'s a real twist to the classic interval problem(s).\\nThe resolution structure remains the same for the most part, with 2 key steps:\\n* **Sorting the intervals by start ASC, [end DESC]**\\n* **Iterating through the intervals once**, keeping track of (at least) the last interval or part of it (be it the start and end of such interval, or just the end, etc).\\n\\n[I\\'m not gonna leave a full explanation but just the key cases and some considerations for the later presented code, which I tried my best to make self-explanatory. Also, there is some redundancy in it for the sake of clarity]\\n\\n-------------------\\n\\nThe first difference here is that the \"last interval\" is not going to be a definitive part of our solution. It can actually be replaced by another interval later in the iteration.\\n\\nConsider this case. Suppose you currently have a greedy solution like:\\n`solutionIntervals = [ [0,2], [1,5] ]` and you\\'re considering `[2,9]`. \\nThen `[1,5]` must be discarded in favour of `[2,9]`.\\nNow, notice you only need to keep track of the last one and the second-to-last one, for example:\\nYour clips are\\n`[ [0,4], [2,5], [3,6], [4,9] ]`\\nThen your iterations will be something like\\n0.`[0,4]` must be part of the answer\\n1.`[2,5]` contains [4, 5] which we hadn\\'t seen before so include `[2,5]` as candidate. `solutionIntervals = [ [0,4], [2,5] ]`\\n2.`[3,6]` starts before 4 and includes [5, 6], which `[2,5]` doesn\\'t. So we must discard `[2,5]` in favour of `[3,6]` to obtain [0, 6]. `solutionIntervals = [ [0,4], [3,6] ]`\\n3.`[4,9]` starts at 4, and includes [6, 9] which `[3,6]` doesn\\'t. So replace `[3,6]` by `[4,9]`. `solutionIntervals = [ [0,4], [4,9] ]`\\n\\nI know I actually owe a mathematical proof to why everything before the last element in `solutionIntervals` is a definitive part of the answer (that is an invariant of this algorithm btw), I guess it could be proven by contradiction. Do interviewers care about this? I don\\'t know for sure.\\n\\nAside from this case, all you need to do is add the current interval if it adds some bit of the video we hadn\\'t seen before (ie if end > currentEnd)\\n\\n--------------------\\n\\nThat being said, the following algorithm is of **O(NlogN)** time complexity, and **O(N)** space complexity, and it could be improved to **O(1)** (space).\\n\\n\\n\\t\\tclass Solution:\\n\\t\\t\\tdef videoStitching(self, clips: List[List[int]], time: int) -> int:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Sort the clips by start time \\n\\t\\t\\t\\tclips.sort(key=lambda x: (x[0], -x[1]))\\n\\n\\t\\t\\t\\ttotal = 1\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# This is a list where all of the intervals are a definitive part of our solution, except possibly the last one.\\n\\t\\t\\t\\t# This makes our code O(N) in memory, but we could actually make it O(1).\\n\\t\\t\\t\\t# I\\'ll leave that as homework for the reader(?)\\n\\t\\t\\t\\tintervals = [clips[0]]\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# The first interval must always be considered. If there exists a solution at all, it is a definitive part of it.\\n\\t\\t\\t\\tcurrStart = clips[0][0]\\n\\t\\t\\t\\tcurrEnd = clips[0][1]\\n\\n\\t\\t\\t\\t# Minimum start time out of all clips is > 0 ? Forget it, the event has not been fully recorded\\n\\t\\t\\t\\tif currStart > 0:\\n\\t\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\t\\t# The first clip begins at 0 and \\n\\t\\t\\t\\tif currEnd >= time:\\n\\t\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\t\\tfor start, end in clips[1:]:\\n\\t\\t\\t\\t\\t# eg suppose you have intervals: [ [0,2], [1,9] ] and you consider [3, 4]. It must be discarded\\n\\t\\t\\t\\t\\tif end < currEnd:\\n\\t\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\t\\t# If there is only one interval in the list, then you cannot replace it.\\n\\t\\t\\t\\t\\tif len(intervals) == 1:\\n\\t\\t\\t\\t\\t\\t# Default case where you have missing bits of the video\\n\\t\\t\\t\\t\\t\\tif start > currEnd:\\n\\t\\t\\t\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\t\\t\\t\\tcurrStart = start\\n\\t\\t\\t\\t\\t\\tcurrEnd = end\\n\\t\\t\\t\\t\\t\\tintervals.append([start, end])\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\t# This is the case where you replace an interval.\\n\\t\\t\\t\\t\\t\\tif start <= intervals[-2][1] and end > currEnd:\\n\\t\\t\\t\\t\\t\\t\\tintervals.pop()\\n\\t\\t\\t\\t\\t\\t\\tcurrStart = start\\n\\t\\t\\t\\t\\t\\t\\tcurrEnd = end\\n\\t\\t\\t\\t\\t\\t\\tintervals.append([start, end])\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# Missing bits of the video again\\n\\t\\t\\t\\t\\t\\telif start > currEnd:\\n\\t\\t\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t# We know we\\'re not missing anything from the video and we\\'re including parts we hadn\\'t seen before\\n\\t\\t\\t\\t\\t\\telif end > currEnd:\\n\\t\\t\\t\\t\\t\\t\\tcurrStart = start\\n\\t\\t\\t\\t\\t\\t\\tcurrEnd = end\\n\\t\\t\\t\\t\\t\\t\\tintervals.append([start, end])\\n\\n\\t\\t\\t\\t\\t# if for some reason we reach the end of the video, stop the iteration there\\n\\t\\t\\t\\t\\tif currEnd >= time:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\n\\t\\t\\t\\t# return -1 if we haven\\'t actually reached the end of the video\\n\\t\\t\\t\\treturn len(intervals) if currEnd >= time else -1",
                "codeTag": "Java"
            },
            {
                "id": 2538961,
                "title": "javascript-greedy",
                "content": "```\\nvar videoStitching = function(clips, time) {\\n    clips.sort((a, b) => {\\n        if (a[0] === b[0]) {\\n            return b[1] - a[1];\\n        }\\n        else {\\n            return a[0] - b[0];\\n        }\\n    });\\n    //console.log(clips);\\n    if (clips[0][0] !== 0) {\\n        return -1;//no clip starts from 0\\n    }\\n    let currEnd = 0;\\n    let taken = 0;\\n    let nextEnd = 0;\\n\\n    let i = 0;\\n    while (i < clips.length && clips[i][0] <= currEnd) {\\n        while (i < clips.length && clips[i][0] <= currEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n\\n        taken++;\\n        currEnd = nextEnd;\\n        if (currEnd >= time) {\\n            return taken;\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nvar videoStitching = function(clips, time) {\\n    clips.sort((a, b) => {\\n        if (a[0] === b[0]) {\\n            return b[1] - a[1];\\n        }\\n        else {\\n            return a[0] - b[0];\\n        }\\n    });\\n    //console.log(clips);\\n    if (clips[0][0] !== 0) {\\n        return -1;//no clip starts from 0\\n    }\\n    let currEnd = 0;\\n    let taken = 0;\\n    let nextEnd = 0;\\n\\n    let i = 0;\\n    while (i < clips.length && clips[i][0] <= currEnd) {\\n        while (i < clips.length && clips[i][0] <= currEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n\\n        taken++;\\n        currEnd = nextEnd;\\n        if (currEnd >= time) {\\n            return taken;\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2509349,
                "title": "c-merging-overlapping-intervals",
                "content": "This problem is similiar to merge intervals problem. \\nFor each interaval that we can reach, we check for the maximum right end we can reach. Once we finish all those interavals which can be traversed, we update start. Start is a variable that tells us whether or not we can traverse current interval. \\n\\n**Break :** If while traversing the intervals, our end time(ie the max we can go in the right) becomes greater than required time, we return count. And if the end does not change, then that means our loop is stuck. So we can not move further thus we return -1 \\n\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort(clips.begin(),clips.end());\\n        int i = 0, count=0, start = 0, end = 0;\\n        while(i<clips.size()){\\n            bool flag = false;\\n            while(i<clips.size() and clips[i][0]<=start){\\n                end = max(end,clips[i][1]);\\n                i++;\\n                flag = true;\\n            }\\n            count++;\\n            start = end;\\n            if(end>=time) return count;\\n            if(!flag) return -1;\\n        }\\n        if(end>=time) return count;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort(clips.begin(),clips.end());\\n        int i = 0, count=0, start = 0, end = 0;\\n        while(i<clips.size()){\\n            bool flag = false;\\n            while(i<clips.size() and clips[i][0]<=start){\\n                end = max(end,clips[i][1]);\\n                i++;\\n                flag = true;\\n            }\\n            count++;\\n            start = end;\\n            if(end>=time) return count;\\n            if(!flag) return -1;\\n        }\\n        if(end>=time) return count;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2443812,
                "title": "c-dp-memoization-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int func(int ind, int st, int time, vector<vector<int>>& clips, vector<vector<int>> &dp)\\n    {\\n        if(st>=time)\\n        {\\n            return 0;\\n        }\\n        if(ind==clips.size())\\n        {\\n            if(st>=time)\\n            {\\n                return 0;\\n            }else\\n            {\\n                return 1e9;\\n            }\\n        }\\n        if(dp[ind][st]!=-1)\\n        {\\n            return dp[ind][st];\\n        }\\n        if(clips[ind][0]<=st)\\n        {\\n            return dp[ind][st] = min(1 + func(ind+1, clips[ind][1], time, clips, dp), func(ind+1, st, time, clips, dp));\\n        }\\n        \\n        return 1e9;   \\n        \\n    }\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort(clips.begin(), clips.end());\\n        vector<vector<int>> dp(clips.size(), vector<int> (time+1, -1));\\n        int ans = func(0, 0, time, clips, dp);\\n        if(ans>=1e9)\\n        {\\n            return -1;\\n        }else\\n        {\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(int ind, int st, int time, vector<vector<int>>& clips, vector<vector<int>> &dp)\\n    {\\n        if(st>=time)\\n        {\\n            return 0;\\n        }\\n        if(ind==clips.size())\\n        {\\n            if(st>=time)\\n            {\\n                return 0;\\n            }else\\n            {\\n                return 1e9;\\n            }\\n        }\\n        if(dp[ind][st]!=-1)\\n        {\\n            return dp[ind][st];\\n        }\\n        if(clips[ind][0]<=st)\\n        {\\n            return dp[ind][st] = min(1 + func(ind+1, clips[ind][1], time, clips, dp), func(ind+1, st, time, clips, dp));\\n        }\\n        \\n        return 1e9;   \\n        \\n    }\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort(clips.begin(), clips.end());\\n        vector<vector<int>> dp(clips.size(), vector<int> (time+1, -1));\\n        int ans = func(0, 0, time, clips, dp);\\n        if(ans>=1e9)\\n        {\\n            return -1;\\n        }else\\n        {\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2421299,
                "title": "using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort(begin(clips),end(clips));\\n        int i=0,c=0,cur=0,nx=0;\\n        if(clips[0][0]!=0) return -1;\\n        while(i<clips.size()){\\n            int t=i;\\n            while(i<clips.size() && clips[i][0]<=cur){\\n                nx=max(nx,clips[i][1]);\\n                i++;\\n            }\\n            if(t==i) return -1;\\n            cur=nx;\\n            c++;\\n            if(cur>=time)return c;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        sort(begin(clips),end(clips));\\n        int i=0,c=0,cur=0,nx=0;\\n        if(clips[0][0]!=0) return -1;\\n        while(i<clips.size()){\\n            int t=i;\\n            while(i<clips.size() && clips[i][0]<=cur){\\n                nx=max(nx,clips[i][1]);\\n                i++;\\n            }\\n            if(t==i) return -1;\\n            cur=nx;\\n            c++;\\n            if(cur>=time)return c;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315898,
                "title": "clear-explanation-with-and-without-sorting",
                "content": "#### Solution-1: Sorting the clips array\\n\\n```\\npublic int videoStitching(int[][] clips, int time) {                \\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        int start = 0, end = 0;\\n        int count = 0, startIndex = 0;\\n\\n        while (start < time) {\\n            while (startIndex < clips.length && clips[startIndex][0] <= start) {\\n                end = Math.max(end, clips[startIndex][1]);\\n                startIndex++;\\n            }\\n            if (start == end) {\\n                return -1;\\n            } else {\\n                start = end;\\n                count++;    \\n            }            \\n        }\\n        return count;\\n    }\\n```\\n\\n1. Sort the given clips array in increasing order of start times. If start times are equal then sort the array in increasing order of end times.\\n2. Traverse the sorted clips array from index = 0. \\n3. For every start time, identify the max end time that is possible. \\n4. Once we get a max end time for a start time. Increment count by 1.\\n5. Continue step-2 until out start >= time.\\n6. Return count\\n\\n\\n#### Without changing the order of the clips array\\n\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int[] map = new int[time + 1];\\n        Arrays.fill(map, -1);\\n        int count = 0, endTime = time, maxEndTime = 0;\\n\\n        // building map\\n\\t\\tfor (int i = 0; i < clips.length; i++) {\\n            int start = clips[i][0], end = clips[i][1];\\n            if (start >= time) {\\n                continue;\\n            }\\n            map[start] = Math.max(map[start], end);\\n            maxEndTime = Math.max(map[start], maxEndTime);\\n        }\\n\\t\\t\\n\\t\\t// for endtime try to get the min start time as possible.\\n        int prevEndTime = endTime;\\n        while (endTime > 0) {\\n            for (int i = 0; i < map.length; i++) {\\n                if (map[i] >= endTime) {\\n                    count++;\\n                    prevEndTime = endTime;\\n                    endTime = i;\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// There is no change in end time which represents that there is an interval miss\\n            if (prevEndTime == endTime) {\\n                return -1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n1. We maintain a map whose index represent start and map[index] represent max end. \\n2. After building the map, we follow a greedy approach to reach the end time from the minimum start index as possible. Ex: (3, 10), (5, 10). We want to choose (3,10) as it covers more intervals than (5, 10).",
                "solutionTags": [],
                "code": "```\\npublic int videoStitching(int[][] clips, int time) {                \\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        int start = 0, end = 0;\\n        int count = 0, startIndex = 0;\\n\\n        while (start < time) {\\n            while (startIndex < clips.length && clips[startIndex][0] <= start) {\\n                end = Math.max(end, clips[startIndex][1]);\\n                startIndex++;\\n            }\\n            if (start == end) {\\n                return -1;\\n            } else {\\n                start = end;\\n                count++;    \\n            }            \\n        }\\n        return count;\\n    }\\n```\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int[] map = new int[time + 1];\\n        Arrays.fill(map, -1);\\n        int count = 0, endTime = time, maxEndTime = 0;\\n\\n        // building map\\n\\t\\tfor (int i = 0; i < clips.length; i++) {\\n            int start = clips[i][0], end = clips[i][1];\\n            if (start >= time) {\\n                continue;\\n            }\\n            map[start] = Math.max(map[start], end);\\n            maxEndTime = Math.max(map[start], maxEndTime);\\n        }\\n\\t\\t\\n\\t\\t// for endtime try to get the min start time as possible.\\n        int prevEndTime = endTime;\\n        while (endTime > 0) {\\n            for (int i = 0; i < map.length; i++) {\\n                if (map[i] >= endTime) {\\n                    count++;\\n                    prevEndTime = endTime;\\n                    endTime = i;\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// There is no change in end time which represents that there is an interval miss\\n            if (prevEndTime == endTime) {\\n                return -1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313212,
                "title": "reuse-jump-game-2",
                "content": "```\\n/*\\n\\n    a clip [si, ei] covers the range from si to ei, \\n    means if we are at the timestamp si, we can go till ei, using this one single clip.\\n    \\n    means we are allowed to take a jump of ei - si from si\\n    so for every clip [si, ei] consturct an array , such that a[si] = max(a[si], ei - si);\\n    \\n    and now apply jump game 2 on this array\\n    \\n    clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10\\n    \\n    for the above test case, the array will be\\n    \\n    [2, 8, 0, 0, 2, 4, 0, 0, 2, 0, 0]\\n*/\\nclass Solution {\\npublic:\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        vector<int> a(time + 1, 0);\\n        for(auto e : clips) {\\n            int start = e[0], end = e[1];\\n            if(start < a.size()) a[start] = max(a[start], end - start);\\n        }\\n        \\n        int jumps = 0, cur_max = 0, next_max = 0;\\n        \\n        for(int i = 0; i < a.size(); i++) {\\n            if(i > next_max) return -1;\\n            next_max = max(next_max, i + a[i]);\\n            if(i == cur_max) {\\n                cur_max = next_max;\\n                if(i != a.size() - 1) jumps++;\\n            }\\n        }\\n        \\n        return jumps;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n/*\\n\\n    a clip [si, ei] covers the range from si to ei, \\n    means if we are at the timestamp si, we can go till ei, using this one single clip.\\n    \\n    means we are allowed to take a jump of ei - si from si\\n    so for every clip [si, ei] consturct an array , such that a[si] = max(a[si], ei - si);\\n    \\n    and now apply jump game 2 on this array\\n    \\n    clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], time = 10\\n    \\n    for the above test case, the array will be\\n    \\n    [2, 8, 0, 0, 2, 4, 0, 0, 2, 0, 0]\\n*/\\nclass Solution {\\npublic:\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        vector<int> a(time + 1, 0);\\n        for(auto e : clips) {\\n            int start = e[0], end = e[1];\\n            if(start < a.size()) a[start] = max(a[start], end - start);\\n        }\\n        \\n        int jumps = 0, cur_max = 0, next_max = 0;\\n        \\n        for(int i = 0; i < a.size(); i++) {\\n            if(i > next_max) return -1;\\n            next_max = max(next_max, i + a[i]);\\n            if(i == cur_max) {\\n                cur_max = next_max;\\n                if(i != a.size() - 1) jumps++;\\n            }\\n        }\\n        \\n        return jumps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212162,
                "title": "java-o-nlogn-with-detailed-explanation-no-dp-bs",
                "content": "```\\npublic int videoStitching(int[][] clips, int time) {\\n        // Sort the array by the start and then sort by the end\\n        Arrays.sort(clips, (a, b) -> \\n                    {\\n                        int result = Integer.compare(a[0], b[0]);\\n                        \\n                        if (result == 0)\\n                        {\\n                            return Integer.compare(a[1], b[1]);\\n                        }\\n                        \\n                        return result;\\n                    });\\n        \\n        // The algorithm:\\n        // We iterate through the sorted array of clips\\n        // and try to find the best candidates for stitching.\\n        // Every time we find a candidate we increase counter.\\n        int[] current = clips[0];\\n        int counter = 1;\\n        \\n        // Edge case when there is no clip starting with 0\\n        if (current[0] != 0)\\n        {\\n            return -1;\\n        }\\n        \\n        for (int i = 1; i < clips.length; i++)\\n        {\\n            // Edge case when the match length is less than \\n            // total duration of clips.\\n            if (current[1] >= time)\\n            {\\n                return counter;\\n            }\\n\\n            // If there are two clips with the same start time\\n            // we use the next one because it has end time further away \\n            // (because the array ordered by the end time in ascending order)\\n            if (clips[i][0] == current[0])\\n            {\\n                current = clips[i];\\n                continue;\\n            }\\n            \\n            // If there is a gap between clips then we can\\'t form the whole match\\n            // and return -1\\n            if (clips[i][0] > current[1])\\n                return -1;\\n            \\n            // In this case the next clip in the array\\n            // is completely covered by current clip\\n            if (current[1] >= clips[i][1])\\n                continue;\\n\\n            // Here we try to find the best candidate for current clip.\\n            // It will be the one whose end is further away and start is within\\n            // current clip so that we can stitch them together\\n            int[] best = clips[i];\\n            int j = i + 1;\\n            while (j < clips.length && clips[j][0] <= current[1])\\n            {\\n                if (clips[j][1] > best[1])\\n                {\\n                    best = clips[j];\\n                    i = j;\\n                }\\n                \\n                j++;\\n            }\\n            \\n            // Every time we find the best stitching candidate we increase the counter\\n            // and move to the next iteration\\n            counter++;\\n            current = best;\\n        }\\n        \\n        // Edge case when there are not enough clips to stitch the whole match\\n        if (current[1] < time)\\n            return -1;\\n        \\n        return counter;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int videoStitching(int[][] clips, int time) {\\n        // Sort the array by the start and then sort by the end\\n        Arrays.sort(clips, (a, b) -> \\n                    {\\n                        int result = Integer.compare(a[0], b[0]);\\n                        \\n                        if (result == 0)\\n                        {\\n                            return Integer.compare(a[1], b[1]);\\n                        }\\n                        \\n                        return result;\\n                    });\\n        \\n        // The algorithm:\\n        // We iterate through the sorted array of clips\\n        // and try to find the best candidates for stitching.\\n        // Every time we find a candidate we increase counter.\\n        int[] current = clips[0];\\n        int counter = 1;\\n        \\n        // Edge case when there is no clip starting with 0\\n        if (current[0] != 0)\\n        {\\n            return -1;\\n        }\\n        \\n        for (int i = 1; i < clips.length; i++)\\n        {\\n            // Edge case when the match length is less than \\n            // total duration of clips.\\n            if (current[1] >= time)\\n            {\\n                return counter;\\n            }\\n\\n            // If there are two clips with the same start time\\n            // we use the next one because it has end time further away \\n            // (because the array ordered by the end time in ascending order)\\n            if (clips[i][0] == current[0])\\n            {\\n                current = clips[i];\\n                continue;\\n            }\\n            \\n            // If there is a gap between clips then we can\\'t form the whole match\\n            // and return -1\\n            if (clips[i][0] > current[1])\\n                return -1;\\n            \\n            // In this case the next clip in the array\\n            // is completely covered by current clip\\n            if (current[1] >= clips[i][1])\\n                continue;\\n\\n            // Here we try to find the best candidate for current clip.\\n            // It will be the one whose end is further away and start is within\\n            // current clip so that we can stitch them together\\n            int[] best = clips[i];\\n            int j = i + 1;\\n            while (j < clips.length && clips[j][0] <= current[1])\\n            {\\n                if (clips[j][1] > best[1])\\n                {\\n                    best = clips[j];\\n                    i = j;\\n                }\\n                \\n                j++;\\n            }\\n            \\n            // Every time we find the best stitching candidate we increase the counter\\n            // and move to the next iteration\\n            counter++;\\n            current = best;\\n        }\\n        \\n        // Edge case when there are not enough clips to stitch the whole match\\n        if (current[1] < time)\\n            return -1;\\n        \\n        return counter;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2194956,
                "title": "greedy-java-explanation",
                "content": "1. Sort the clip by start time\\n2. Initially `start` time is `0`.\\n3. Get the `maximum end time` until you do not see a overlap with `start` time. (`while` loop 2)\\n4. What you are trying to do here is, with overlap from the previous start time or clip, what is the maximum end point you can reach. When there is no overlap with previous clip, 2nd while loop ends.\\n5. At any given point in time, if the start and end meets, then end point is stuck, hence there is no solution. (`return -1`).\\n6. otherwise, you found the minimum clip until the end, now we can start searching for the clip from the end point, which means map `end to start`.\\n7. count the clip.\\n8. repeat from `step 2`.\\n\\n*If i try to generalize it, minimum number of operations/steps or whatever entity to cover entire data structure,\\nwe can basically use this technique to solve the problem*\\n\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int res = 0;\\n        Arrays.sort(clips, (a,b) ->  a[0] - b[0]);\\n        int start = 0, end = 0, index = 0;\\n        while (start < time) {\\n            while (index < clips.length && clips[index][0] <= start) {\\n                end = Math.max(end, clips[index][1]);\\n                index++;\\n            }\\n            if (start == end) return -1;\\n            start = end;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int res = 0;\\n        Arrays.sort(clips, (a,b) ->  a[0] - b[0]);\\n        int start = 0, end = 0, index = 0;\\n        while (start < time) {\\n            while (index < clips.length && clips[index][0] <= start) {\\n                end = Math.max(end, clips[index][1]);\\n                index++;\\n            }\\n            if (start == end) return -1;\\n            start = end;\\n            res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106637,
                "title": "python-greedy-sorting",
                "content": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        if time == 0: \\n            return 0\\n        \\n\\t\\t# this can be simplified as  clips.sort(key = lambda x : (x[0])), we only care about start\\n        clips.sort(key = lambda x : (x[0], -x[1]))\\n\\n        ans = 0\\n        cur_end, next_end = 0, 0\\n        i, n = 0, len(clips)\\n        \\n        while i < n and clips[i][0] <=  cur_end:\\n            \\n            # greedy choose next clip\\n            while i < n and clips[i][0] <= cur_end:\\n                next_end = max(next_end, clips[i][1])\\n                i += 1\\n                \\n            \\n            # found one, update cur end\\n            ans += 1\\n            cur_end = next_end\\n            if cur_end >= time:\\n                return ans\\n            \\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        if time == 0: \\n            return 0\\n        \\n\\t\\t# this can be simplified as  clips.sort(key = lambda x : (x[0])), we only care about start\\n        clips.sort(key = lambda x : (x[0], -x[1]))\\n\\n        ans = 0\\n        cur_end, next_end = 0, 0\\n        i, n = 0, len(clips)\\n        \\n        while i < n and clips[i][0] <=  cur_end:\\n            \\n            # greedy choose next clip\\n            while i < n and clips[i][0] <= cur_end:\\n                next_end = max(next_end, clips[i][1])\\n                i += 1\\n                \\n            \\n            # found one, update cur end\\n            ans += 1\\n            cur_end = next_end\\n            if cur_end >= time:\\n                return ans\\n            \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088521,
                "title": "java-easy-o-nlogn-with-explanation",
                "content": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        //initially sort clips so that all clips with common starting point appear together\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        //initially maxReachable clip time is zero\\n        //and count of clips is zero\\n        int maxReachable = 0;\\n        int count = 0;\\n        //i is index for traversing over clips\\n        int i = 0;\\n        \\n        //loop until condition met\\n        while(maxReachable < time) {\\n            //locally we don\\'t know max where we will reach\\n            //so mark -1\\n            int localMaxReachable = -1;\\n            //while i is in range\\n            //go through clips with starting point less than maxReachable time \\n            //because these clips are reachable\\n            while(i<clips.length && clips[i][0] <= maxReachable) {\\n                //find the max reachable point from all these clips\\n                localMaxReachable = Math.max(localMaxReachable, clips[i][1]);\\n                i++;\\n            }\\n            //if after all this we still cannot reach further than current reachable\\n            //then we are stuck and therefore return -1\\n            if(localMaxReachable <= maxReachable)   return -1;\\n            \\n            //otherwise, new maxReachable should be changed\\n            maxReachable = localMaxReachable;\\n            //and we will increase count of clips needed\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        //initially sort clips so that all clips with common starting point appear together\\n        Arrays.sort(clips, (a, b) -> a[0] - b[0]);\\n        \\n        //initially maxReachable clip time is zero\\n        //and count of clips is zero\\n        int maxReachable = 0;\\n        int count = 0;\\n        //i is index for traversing over clips\\n        int i = 0;\\n        \\n        //loop until condition met\\n        while(maxReachable < time) {\\n            //locally we don\\'t know max where we will reach\\n            //so mark -1\\n            int localMaxReachable = -1;\\n            //while i is in range\\n            //go through clips with starting point less than maxReachable time \\n            //because these clips are reachable\\n            while(i<clips.length && clips[i][0] <= maxReachable) {\\n                //find the max reachable point from all these clips\\n                localMaxReachable = Math.max(localMaxReachable, clips[i][1]);\\n                i++;\\n            }\\n            //if after all this we still cannot reach further than current reachable\\n            //then we are stuck and therefore return -1\\n            if(localMaxReachable <= maxReachable)   return -1;\\n            \\n            //otherwise, new maxReachable should be changed\\n            maxReachable = localMaxReachable;\\n            //and we will increase count of clips needed\\n            count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2080624,
                "title": "c-short-clear-recursive-memoization",
                "content": "**Recursive Approach**\\n```\\nclass Solution {\\npublic:\\n    static bool comp(const vector<int>& a,const vector<int>& b){\\n        if(a[0] == b[0]){\\n            return a[1] < b[1];\\n        }\\n        return a[0] < b[0];\\n    }\\n    \\n    int helper(vector<vector<int>>& clips, int time, int prev, int idx){\\n        \\n        // base cases\\n        if(prev >= time){\\n            return 0; // ending time reached\\n        }\\n        \\n        if(idx >= clips.size()){\\n             return INT_MAX-1;   // ending time not reachable\\n        }\\n        \\n        // skip\\n        int skip = helper(clips, time, prev, idx+1);\\n        \\n        // include video clip if overlapping\\n        int pick = INT_MAX;\\n        auto currClip = clips[idx];\\n        if(currClip[0] <= prev){\\n            prev = max(prev, currClip[1]);\\n            pick = 1 + helper(clips, time, prev, idx+1);\\n        }\\n        \\n        return min(skip, pick);\\n    }\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        \\n        sort(clips.begin(), clips.end(), comp);// increasing order\\n        int prev = 0;\\n        int start = 0;\\n        \\n        int minimumClips = helper(clips, time, prev, start);\\n        \\n        if(minimumClips == INT_MAX-1){\\n            return -1;\\n        }\\n        return minimumClips;\\n    }\\n};\\n```\\n\\n**Memoization**\\n```\\nusing vv_t = vector<vector<int>>;\\n\\nclass Solution {\\npublic:\\n    static bool comp(const vector<int>& a,const vector<int>& b){\\n        if(a[0] == b[0]){\\n            return a[1] < b[1];\\n        }\\n        return a[0] < b[0];\\n    }\\n    \\n    int helper(vv_t& clips, int time, int prev, int idx, vv_t& dp){\\n        \\n        // base cases\\n        if(prev >= time){\\n            return 0; // ending time reached\\n        }\\n        \\n        if(idx >= clips.size()){\\n             return INT_MAX-1;  // ending time not reachable\\n        }\\n        \\n        // we are taking min(prev, time) because clips ending time may exceeds the expected given time and it is considered valid\\n        //example: [[0,4],[2,8]] time = 5\\n        // output: 2\\n        \\n        if(dp[idx][min(prev, time)] != -1){\\n            return dp[idx][prev];\\n        }\\n        \\n        // skip\\n        int skip = helper(clips, time, prev, idx+1, dp);\\n        \\n        // include video clip if overlapping\\n        int pick = INT_MAX;\\n        auto currClip = clips[idx];\\n        if(currClip[0] <= prev){\\n            prev = max(prev, currClip[1]);\\n            pick = 1 + helper(clips, time, prev, idx+1, dp);\\n        }\\n         \\n        return dp[idx][min(prev, time)] = min(skip, pick);\\n    }\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        constexpr int INF = INT_MAX-1;\\n        int n = clips.size();\\n        int prev = 0;\\n        int start = 0;\\n        \\n        sort(clips.begin(), clips.end(), comp);// increasing order\\n        \\n        vv_t dp(n+1, vector<int>(time+1, -1));\\n        \\n        int minimumClips = helper(clips, time, prev, start, dp);\\n        \\n        if(minimumClips == INT_MAX-1){\\n            return -1;\\n        }\\n        return minimumClips;\\n    }\\n};\\n```\\n\\n\\n**Tabulation**\\n```\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(const vector<int>& a,const vector<int>& b){\\n        if(a[0] == b[0]){\\n            return a[1] < b[1];\\n        }\\n        return a[0] < b[0];\\n    }\\n    \\n    int helper(vector<vector<int>>& clips, int time, int prev, int idx){\\n        \\n        // base cases\\n        if(prev >= time){\\n            return 0; // ending time reached\\n        }\\n        \\n        if(idx >= clips.size()){\\n             return INT_MAX-1;   // ending time not reachable\\n        }\\n        \\n        // skip\\n        int skip = helper(clips, time, prev, idx+1);\\n        \\n        // include video clip if overlapping\\n        int pick = INT_MAX;\\n        auto currClip = clips[idx];\\n        if(currClip[0] <= prev){\\n            prev = max(prev, currClip[1]);\\n            pick = 1 + helper(clips, time, prev, idx+1);\\n        }\\n        \\n        return min(skip, pick);\\n    }\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        \\n        sort(clips.begin(), clips.end(), comp);// increasing order\\n        int prev = 0;\\n        int start = 0;\\n        \\n        int minimumClips = helper(clips, time, prev, start);\\n        \\n        if(minimumClips == INT_MAX-1){\\n            return -1;\\n        }\\n        return minimumClips;\\n    }\\n};\\n```\n```\\nusing vv_t = vector<vector<int>>;\\n\\nclass Solution {\\npublic:\\n    static bool comp(const vector<int>& a,const vector<int>& b){\\n        if(a[0] == b[0]){\\n            return a[1] < b[1];\\n        }\\n        return a[0] < b[0];\\n    }\\n    \\n    int helper(vv_t& clips, int time, int prev, int idx, vv_t& dp){\\n        \\n        // base cases\\n        if(prev >= time){\\n            return 0; // ending time reached\\n        }\\n        \\n        if(idx >= clips.size()){\\n             return INT_MAX-1;  // ending time not reachable\\n        }\\n        \\n        // we are taking min(prev, time) because clips ending time may exceeds the expected given time and it is considered valid\\n        //example: [[0,4],[2,8]] time = 5\\n        // output: 2\\n        \\n        if(dp[idx][min(prev, time)] != -1){\\n            return dp[idx][prev];\\n        }\\n        \\n        // skip\\n        int skip = helper(clips, time, prev, idx+1, dp);\\n        \\n        // include video clip if overlapping\\n        int pick = INT_MAX;\\n        auto currClip = clips[idx];\\n        if(currClip[0] <= prev){\\n            prev = max(prev, currClip[1]);\\n            pick = 1 + helper(clips, time, prev, idx+1, dp);\\n        }\\n         \\n        return dp[idx][min(prev, time)] = min(skip, pick);\\n    }\\n    \\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        constexpr int INF = INT_MAX-1;\\n        int n = clips.size();\\n        int prev = 0;\\n        int start = 0;\\n        \\n        sort(clips.begin(), clips.end(), comp);// increasing order\\n        \\n        vv_t dp(n+1, vector<int>(time+1, -1));\\n        \\n        int minimumClips = helper(clips, time, prev, start, dp);\\n        \\n        if(minimumClips == INT_MAX-1){\\n            return -1;\\n        }\\n        return minimumClips;\\n    }\\n};\\n```\n```\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598548,
                "title": "greedy-java",
                "content": "[LC1326](https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/discuss/1598562/greedy-java)\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        if(T == 0) return 0;\\n        int[] dp = new int[T + 1];\\n        Arrays.fill(dp, -1);\\n        \\n        for(int i = 0; i < clips.length; i++){\\n            int start = clips[i][0], end = clips[i][1];\\n            if(start > T) continue;\\n            dp[start] = Math.max(dp[start], Math.min(end, T));\\n        }\\n        \\n        int next = 0;\\n        int furthest = 0;\\n        int count = 0;\\n        \\n        for(int i = 0; i <= T; i++){\\n            next = Math.max(next, dp[i]);\\n            if(i == furthest){\\n                furthest = next;\\n                count++;\\n                if(furthest >= T){\\n                    return count;\\n                }\\n            }\\n        }\\n        return furthest >= T? count : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        if(T == 0) return 0;\\n        int[] dp = new int[T + 1];\\n        Arrays.fill(dp, -1);\\n        \\n        for(int i = 0; i < clips.length; i++){\\n            int start = clips[i][0], end = clips[i][1];\\n            if(start > T) continue;\\n            dp[start] = Math.max(dp[start], Math.min(end, T));\\n        }\\n        \\n        int next = 0;\\n        int furthest = 0;\\n        int count = 0;\\n        \\n        for(int i = 0; i <= T; i++){\\n            next = Math.max(next, dp[i]);\\n            if(i == furthest){\\n                furthest = next;\\n                count++;\\n                if(furthest >= T){\\n                    return count;\\n                }\\n            }\\n        }\\n        return furthest >= T? count : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1505429,
                "title": "c-faster-than-100-time-o-n-space-o-1",
                "content": "we can change the problem to [Jump Game](https://leetcode.com/problems/jump-game-ii/), because it only has 100 clips\\nTime: O(n)\\nSpace: O(1)\\n```\\nint ans = 0, n = clips.size(), stop = 0, nextstop = 0;\\nint dp[101] = {0};\\nfor(int i = 0; i < n; i++){\\n\\tdp[clips[i][0]] = max(dp[clips[i][0]], clips[i][1]);\\n}\\nint i;\\nfor(i = 0; i <= stop && i < time; i++){\\n\\tnextstop = max(nextstop, dp[i]);\\n\\tif(stop == i){\\n\\t\\tans++;\\n\\t\\tstop = nextstop;\\n\\t}\\n}\\nreturn stop >= time? ans: -1;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint ans = 0, n = clips.size(), stop = 0, nextstop = 0;\\nint dp[101] = {0};\\nfor(int i = 0; i < n; i++){\\n\\tdp[clips[i][0]] = max(dp[clips[i][0]], clips[i][1]);\\n}\\nint i;\\nfor(i = 0; i <= stop && i < time; i++){\\n\\tnextstop = max(nextstop, dp[i]);\\n\\tif(stop == i){\\n\\t\\tans++;\\n\\t\\tstop = nextstop;\\n\\t}\\n}\\nreturn stop >= time? ans: -1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1500050,
                "title": "python-greedy-sort-o-n-o-nlogn-with-explanation",
                "content": "The first idea that come to my mind is to cover as much interval as possible, which is the intuition of sorting the clips array by:\\n1. increasing start time, which allows us to detect void intervals (like [1,3], then [5,7], 4 is not covered, then we can simply return -1)\\n2. decreasing ending time if the start times are the same, which allows maximizing the interval size (like [1,8] comes before [1,2], we use [1,8])\\n\\nAfter that, we can go with a one-pass solution:\\n1. We use the very first item in the array, which should cover 0 as the starttime, then as far as possible for the endtime\\n2. Then we can ignore all intervals with the same starttime. (This idea can be further improved in the code)\\n3. A tricky part comes, like if we have [0,4] in our hand, we should choose [4,7] favor than [2,6], and [4,5], because [4,7] has farther endtime then both, while the starttime is either smaller or equal to the previous endtime (in the code: last_right variable).\\n4. We continue until either we reach a farther endtime than our target, or we come to the end of the array and the target is yet not covered.\\n5. Then we can write our own code, and be careful for the edge cases.\\n\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        if not clips:\\n            return -1\\n        clips.sort(key=lambda x: (x[0], -x[1]))\\n        if clips[0][0] != 0:\\n            return -1\\n        cur_left, cur_right = clips[0][0], clips[0][1]\\n        i = count = 0\\n        while cur_right < time:\\n            if i == len(clips):\\n                return -1\\n            while i < len(clips) and clips[i][0] == cur_left:\\n                i += 1\\n            last_right = cur_right\\n            while i < len(clips) and last_right >= clips[i][0]:\\n                cur_right = max(cur_right, clips[i][1])\\n                i += 1\\n            if i < len(clips) and clips[i][0] > cur_right:\\n                return -1\\n            count += 1\\n            cur_left = clips[i-1][0]\\n        return count+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        if not clips:\\n            return -1\\n        clips.sort(key=lambda x: (x[0], -x[1]))\\n        if clips[0][0] != 0:\\n            return -1\\n        cur_left, cur_right = clips[0][0], clips[0][1]\\n        i = count = 0\\n        while cur_right < time:\\n            if i == len(clips):\\n                return -1\\n            while i < len(clips) and clips[i][0] == cur_left:\\n                i += 1\\n            last_right = cur_right\\n            while i < len(clips) and last_right >= clips[i][0]:\\n                cur_right = max(cur_right, clips[i][1])\\n                i += 1\\n            if i < len(clips) and clips[i][0] > cur_right:\\n                return -1\\n            count += 1\\n            cur_left = clips[i-1][0]\\n        return count+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479233,
                "title": "c-greedy-solution",
                "content": "Please Upvote if you like the Solution!\\n\\n     int videoStitching(vector<vector<int>>& clips, int time)\\n     {\\n        int start=0;\\n        int end=0;\\n        int count=0;\\n        \\n        while(end<time)\\n        {\\n            for(int i=0;i<clips.size();i++)\\n            {\\n                if(clips[i][0]<=start && clips[i][1]>end)\\n                {\\n                    end=clips[i][1];\\n                }\\n            }\\n            if(start==end)\\n                return -1;\\n            start=end;\\n            count++;\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "Please Upvote if you like the Solution!\\n\\n     int videoStitching(vector<vector<int>>& clips, int time)\\n     {\\n        int start=0;\\n        int end=0;\\n        int count=0;\\n        \\n        while(end<time)\\n        {\\n            for(int i=0;i<clips.size();i++)\\n            {\\n                if(clips[i][0]<=start && clips[i][1]>end)\\n                {\\n                    end=clips[i][1];\\n                }\\n            }\\n            if(start==end)\\n                return -1;\\n            start=end;\\n            count++;\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1475038,
                "title": "java-0ms-commented",
                "content": "This ran initially in 0ms. When I added the comments it slowed down a bit.\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        List<Integer> startend = new ArrayList<> (time + 1);\\n        // create a list (can create an array) that holds the maximum end time for each start time\\n        for (int i = 0; i <= time; i++) {\\n            startend.add(-1);\\n        }\\n        // store the maximum end time for each start time. \\n        for (int[] clip : clips) {\\n            // might have time = 5 and clip[0] = 8. This will cause an error. The if statement avoids it\\n            if (clip[0] > time) continue;\\n            int tempend = Math.min(time, clip[1]);\\n            startend.set(clip[0], Math.max(startend.get(clip[0]), tempend)); \\n        }\\n        // for a complete clip we need to start from 0\\n        int start = 0;\\n        int end = startend.get(0);\\n        // if we didn\\'t find previously any clip that starts from 0 we return -1; we can\\'t complete the clip\\n        if (end == -1) return -1;\\n        // otherwise, we found 1 clip that can be useful. so we start counting from 1\\n        int count = 1;\\n        // we repeat the pattern until we reach the end time\\n        while (end < time) {\\n            // we need to find a clip (after start) that ends after end.\\n            int max = end;\\n            for (int i = start + 1; i <= end; i++){\\n                if (startend.get(i) > max) max = startend.get(i);\\n            }\\n            // if we didn\\'t find a clip that ends after our end, we are stuck and can\\'t continue\\n            if (max == end) return -1;\\n            // otherwise we need to start searching from where we used to end till the newly found end (max)\\n            start = end;\\n            end = max;\\n            // if we succeeded to find a new end, then we stiched another clip and we can increase our count\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        List<Integer> startend = new ArrayList<> (time + 1);\\n        // create a list (can create an array) that holds the maximum end time for each start time\\n        for (int i = 0; i <= time; i++) {\\n            startend.add(-1);\\n        }\\n        // store the maximum end time for each start time. \\n        for (int[] clip : clips) {\\n            // might have time = 5 and clip[0] = 8. This will cause an error. The if statement avoids it\\n            if (clip[0] > time) continue;\\n            int tempend = Math.min(time, clip[1]);\\n            startend.set(clip[0], Math.max(startend.get(clip[0]), tempend)); \\n        }\\n        // for a complete clip we need to start from 0\\n        int start = 0;\\n        int end = startend.get(0);\\n        // if we didn\\'t find previously any clip that starts from 0 we return -1; we can\\'t complete the clip\\n        if (end == -1) return -1;\\n        // otherwise, we found 1 clip that can be useful. so we start counting from 1\\n        int count = 1;\\n        // we repeat the pattern until we reach the end time\\n        while (end < time) {\\n            // we need to find a clip (after start) that ends after end.\\n            int max = end;\\n            for (int i = start + 1; i <= end; i++){\\n                if (startend.get(i) > max) max = startend.get(i);\\n            }\\n            // if we didn\\'t find a clip that ends after our end, we are stuck and can\\'t continue\\n            if (max == end) return -1;\\n            // otherwise we need to start searching from where we used to end till the newly found end (max)\\n            start = end;\\n            end = max;\\n            // if we succeeded to find a new end, then we stiched another clip and we can increase our count\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430859,
                "title": "java-is-sorting-really-needed",
                "content": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int currentEnd = 0, lastStart = 0, res = 0;\\n        while (currentEnd < time) {\\n            for (int i = 0; i < clips.length; i++) {\\n                if (clips[i][0] <= lastStart)\\n                    currentEnd = Math.max(currentEnd, clips[i][1]);\\n            }\\n            \\n            if (currentEnd == lastStart)\\n                return -1;\\n            \\n            lastStart = currentEnd;\\n            res++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int currentEnd = 0, lastStart = 0, res = 0;\\n        while (currentEnd < time) {\\n            for (int i = 0; i < clips.length; i++) {\\n                if (clips[i][0] <= lastStart)\\n                    currentEnd = Math.max(currentEnd, clips[i][1]);\\n            }\\n            \\n            if (currentEnd == lastStart)\\n                return -1;\\n            \\n            lastStart = currentEnd;\\n            res++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409409,
                "title": "python3-neat-implementation",
                "content": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        \\n        clips.sort(key = lambda x:x[1], reverse = True)\\n        clips.sort(key = lambda x:x[0])\\n        if clips[0][0] > 0: return -1  \\n        count = 0\\n        \\n        # take first clip\\n        curr_farthest = clips[0][1]\\n        curr_clip = 0  \\n        count += 1\\n        \\n        while curr_farthest < time:\\n            \\n            next_farthest = -1\\n            i = curr_clip\\n            \\n            while i < len(clips) and clips[i][0] <= curr_farthest :\\n                next_farthest = max(next_farthest, clips[i][1])\\n                i += 1\\n                \\n            if next_farthest <= curr_farthest: return -1\\n            \\n            curr_farthest = next_farthest\\n            curr_clip = i\\n            count += 1\\n            \\n            \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        \\n        clips.sort(key = lambda x:x[1], reverse = True)\\n        clips.sort(key = lambda x:x[0])\\n        if clips[0][0] > 0: return -1  \\n        count = 0\\n        \\n        # take first clip\\n        curr_farthest = clips[0][1]\\n        curr_clip = 0  \\n        count += 1\\n        \\n        while curr_farthest < time:\\n            \\n            next_farthest = -1\\n            i = curr_clip\\n            \\n            while i < len(clips) and clips[i][0] <= curr_farthest :\\n                next_farthest = max(next_farthest, clips[i][1])\\n                i += 1\\n                \\n            if next_farthest <= curr_farthest: return -1\\n            \\n            curr_farthest = next_farthest\\n            curr_clip = i\\n            count += 1\\n            \\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367857,
                "title": "explanation-fo-dp-solution",
                "content": "`dp[i]` is the minimum number of intervals required to reach  `time = i`\\nIn English, the dp array is answering the question : What is the fewest number of clips I can use so that my result includes events at `time  = i`?\\n\\nIf we have three clips `[[1,5], [1,10], [1, 100]]` - it\\'s obvious which one we should choose right? We should choose the one with the biggest range `[1-100]` because we want the fewest clips. This logic is what this DP solution is trying to do. For every `time = i`, we go through every clip and try to choose the best clip for that time. In previous example, the best clip range for `time = 1` is `[1,100]`. \\n\\n**Example:**\\nLet\\'s say we added another clip [50, 60], and we now have `[[1,5], [1,10],  [50,60], [1,100]]`. When we get to `time = 50`, we would first try `[50,60]` before `[1, 100]`. \\n\\nUsing our equation, `dp[i] = Math.min(dp[i], dp[start] + 1)`, `dp[50]=Math.min(100, 51)`, resulting in `dp[50] = 51`. How do we interpret this? Because we haven\\'t seen any other clip that covers `time=50`, we must assume the worst case, which is all other clips before this one only cover 1 second.\\n\\nWhen we arrive to clip `[1, 100]`, we see that this clip covers `time = 50`, we can potentially reuse this range to minimize our clips that we assumed in the worst case previously. We know this covers `time = 50` because of `if(i >= start && i <= end)`. Since we can reuse this range, we can choose between the minimum of how many clips it takes to make the start of this range and the current `time = i`\\n\\n```\\nclass Solution {\\n   public int videoStitching(int[][] clips, int T) {\\n    int[] dp = new int[T+ 1];\\n    Arrays.fill(dp, T+1);\\n    dp[0] = 0;\\n     \\n    for(int i = 1; i <= T; i++) {\\n      for(int[] c : clips) {\\n        int start = c[0];\\n        int end = c[1];\\n        if(i >= start && i <= end) { // Time at `i` is within clip range\\n          /*\\n          dp[start] covers dp[i] in this if statement\\n          If this clip starting here can cover dp[i], we want to check\\n          if it is better than a previous clip that covered i\\n          */\\n          dp[i] = Math.min(dp[i], dp[start] + 1);\\n        }\\n      }\\n    }\\n   if(dp[T] == T+1) return -1;\\n    return dp[T];\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n   public int videoStitching(int[][] clips, int T) {\\n    int[] dp = new int[T+ 1];\\n    Arrays.fill(dp, T+1);\\n    dp[0] = 0;\\n     \\n    for(int i = 1; i <= T; i++) {\\n      for(int[] c : clips) {\\n        int start = c[0];\\n        int end = c[1];\\n        if(i >= start && i <= end) { // Time at `i` is within clip range\\n          /*\\n          dp[start] covers dp[i] in this if statement\\n          If this clip starting here can cover dp[i], we want to check\\n          if it is better than a previous clip that covered i\\n          */\\n          dp[i] = Math.min(dp[i], dp[start] + 1);\\n        }\\n      }\\n    }\\n   if(dp[T] == T+1) return -1;\\n    return dp[T];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357550,
                "title": "c-o-n-log-n-sort-greedy",
                "content": "```\\n\\tint videoStitching(vector<vector<int>>& clips, int time) {\\n        sort(clips.begin(),clips.end(),[](vector<int>& a, vector<int>& b){\\n            return a[0]<b[0];\\n        });\\n        int curr=0;\\n        int i=0;\\n        int n=clips.size();\\n        int ans=0;\\n        while(i<n){\\n            int best=-1;\\n            while(i<n && clips[i][0]<=curr){\\n                if(best==-1 ||\\xA0clips[i][1]>clips[best][1]){\\n                    best=i;\\n                }\\n                i++;\\n            }\\n            if(best==-1){\\n                return curr>=time?ans:-1;\\n            }else{\\n                ans++;\\n                curr=clips[best][1];\\n                if(curr>=time){\\n                    return ans;\\n                }\\n            }   \\n        }\\n        return curr>=time?ans:-1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tint videoStitching(vector<vector<int>>& clips, int time) {\\n        sort(clips.begin(),clips.end(),[](vector<int>& a, vector<int>& b){\\n            return a[0]<b[0];\\n        });\\n        int curr=0;\\n        int i=0;\\n        int n=clips.size();\\n        int ans=0;\\n        while(i<n){\\n            int best=-1;\\n            while(i<n && clips[i][0]<=curr){\\n                if(best==-1 ||\\xA0clips[i][1]>clips[best][1]){\\n                    best=i;\\n                }\\n                i++;\\n            }\\n            if(best==-1){\\n                return curr>=time?ans:-1;\\n            }else{\\n                ans++;\\n                curr=clips[best][1];\\n                if(curr>=time){\\n                    return ans;\\n                }\\n            }   \\n        }\\n        return curr>=time?ans:-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314525,
                "title": "c-o-n-2-100-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n       int ans=0,cur_min=0;\\n       while(cur_min<time){\\n             int cur_max=INT_MIN;\\n             for(int i=0; i<clips.size(); i++){\\n                 if(clips[i][0]<=cur_min)cur_max=max(cur_max,clips[i][1]);\\n             }\\n           if(cur_max==INT_MIN || cur_max==cur_min)return -1;\\n           ans++;\\n           cur_min=cur_max;\\n       }\\n       return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n       int ans=0,cur_min=0;\\n       while(cur_min<time){\\n             int cur_max=INT_MIN;\\n             for(int i=0; i<clips.size(); i++){\\n                 if(clips[i][0]<=cur_min)cur_max=max(cur_max,clips[i][1]);\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1205476,
                "title": "test-case-55-seems-wrong",
                "content": "```\\n\\nInput: [[2,4]]\\n0\\nOutput: -1\\nExpected: 0\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nInput: [[2,4]]\\n0\\nOutput: -1\\nExpected: 0\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1157480,
                "title": "c-solution-gready-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        sort(clips.begin(), clips.end(), [] (vector<int>& p, vector<int>& q) {\\n            return p[0] <  q[0];\\n        });\\n        int ans = 0;\\n        int start = 0;\\n        int j = 0;\\n        while(start < T) {\\n            int max_right = start;\\n            while(j < n && clips[j][0] <= start) {\\n                max_right = max(max_right, clips[j][1]);\\n                j++;\\n            }\\n            if(max_right <= start) {\\n                return -1;\\n            }\\n            start = max_right;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const int INF = 1e9 + 7;\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        sort(clips.begin(), clips.end(), [] (vector<int>& p, vector<int>& q) {\\n            return p[0] <  q[0];\\n        });\\n        int ans = 0;\\n        int start = 0;\\n        int j = 0;\\n        while(start < T) {\\n            int max_right = start;\\n            while(j < n && clips[j][0] <= start) {\\n                max_right = max(max_right, clips[j][1]);\\n                j++;\\n            }\\n            if(max_right <= start) {\\n                return -1;\\n            }\\n            start = max_right;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103376,
                "title": "concise-java-greedy-and-swift-dp",
                "content": "Java using greedy algorithm because it turns out in this particular case the local optimals amounts to global optimal:\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        Arrays.sort(clips, (a,b)-> a[0]-b[0]);\\n        int minCount=0;\\n        for (int i=0, beg=0, end=0; beg<T; beg=end,++minCount) {\\n            for (; i<clips.length && clips[i][0]<=beg; ++i) end=Math.max(end, clips[i][1]);\\n            if (beg==end) return -1;\\n        }\\n        return minCount;\\n    }\\n}\\n```\\nSwift DP approach, slower but it is an algorithm that is generalized and could be used where greedy does not yield global optimal:\\n```\\nclass Solution {\\n    func videoStitching(_ clips: [[Int]], _ T: Int) -> Int {\\n        // dp[0..T] where dp[t]=mininum_intervals_needed_to_reach_t\\n        var dp:[Int]=Array(repeating:T+1,count:T+1)\\n        dp[0]=0\\n        if T==0 {return T}\\n        //where adds a filter to allow early termination, if t-1 is not reachable, so must be t\\n        for t in 1...T where dp[t-1]<T+1 { \\n            for clip in clips {\\n                if clip[0]<=t && t<=clip[1] {\\n                    dp[t]=min(dp[t], dp[clip[0]]+1)\\n                }\\n            }\\n        }\\n        return dp[T]==T+1 ? -1: dp[T]\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        Arrays.sort(clips, (a,b)-> a[0]-b[0]);\\n        int minCount=0;\\n        for (int i=0, beg=0, end=0; beg<T; beg=end,++minCount) {\\n            for (; i<clips.length && clips[i][0]<=beg; ++i) end=Math.max(end, clips[i][1]);\\n            if (beg==end) return -1;\\n        }\\n        return minCount;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func videoStitching(_ clips: [[Int]], _ T: Int) -> Int {\\n        // dp[0..T] where dp[t]=mininum_intervals_needed_to_reach_t\\n        var dp:[Int]=Array(repeating:T+1,count:T+1)\\n        dp[0]=0\\n        if T==0 {return T}\\n        //where adds a filter to allow early termination, if t-1 is not reachable, so must be t\\n        for t in 1...T where dp[t-1]<T+1 { \\n            for clip in clips {\\n                if clip[0]<=t && t<=clip[1] {\\n                    dp[t]=min(dp[t], dp[clip[0]]+1)\\n                }\\n            }\\n        }\\n        return dp[T]==T+1 ? -1: dp[T]\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072551,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        vector<int> jumps(T+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(clips[i][0]>T)continue;\\n            jumps[clips[i][0]] = max(jumps[clips[i][0]],clips[i][1]);\\n        }\\n        int cur = 0, back_up = -1, cnt =0;\\n        for(int i=0;i<=T;i++)\\n        {\\n            if(cur<i)return -1;\\n            back_up = max(back_up, jumps[i]);\\n            if( cur == i && i!=T)\\n            {\\n                cur = back_up;\\n                back_up = -1;\\n                cnt++;\\n            }\\n        }\\n        return (cur<T?-1:cnt);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        vector<int> jumps(T+1,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(clips[i][0]>T)continue;\\n            jumps[clips[i][0]] = max(jumps[clips[i][0]],clips[i][1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1056299,
                "title": "c-memo",
                "content": "```\\nint INF=1000;\\nclass Solution {\\npublic:\\n    vector<vector<int>>clip;\\n    vector<vector<vector<int>>>dp;\\n    int get(int i,int s,int l)\\n    {\\n        if(i>=clip.size())\\n            return INF;\\n        if(clip[i][0]>s)\\n            return INF;\\n        if(clip[i][0]<=s && clip[i][1]>=l)\\n            return 1;\\n        if(dp[i][s][l]!=-1)\\n            return dp[i][s][l];\\n        int res;\\n        res=min(1+get(i+1,clip[i][1],l),get(i+1,s,l));\\n        return dp[i][s][l]=res;\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n        sort(clips.begin(),clips.end());\\n        clip=clips;\\n        if(T==0)\\n            return 0;\\n        if(clips[0][0]!=0)\\n            return -1;\\n        dp.resize(clips.size(),vector<vector<int>>(T+1,vector<int>(T+1,-1)));\\n        int res=get(0,0,T);\\n        return res>=INF?-1:res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint INF=1000;\\nclass Solution {\\npublic:\\n    vector<vector<int>>clip;\\n    vector<vector<vector<int>>>dp;\\n    int get(int i,int s,int l)\\n    {\\n        if(i>=clip.size())\\n            return INF;\\n        if(clip[i][0]>s)\\n            return INF;\\n        if(clip[i][0]<=s && clip[i][1]>=l)\\n            return 1;\\n        if(dp[i][s][l]!=-1)\\n            return dp[i][s][l];\\n        int res;\\n        res=min(1+get(i+1,clip[i][1],l),get(i+1,s,l));\\n        return dp[i][s][l]=res;\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n        sort(clips.begin(),clips.end());\\n        clip=clips;\\n        if(T==0)\\n            return 0;\\n        if(clips[0][0]!=0)\\n            return -1;\\n        dp.resize(clips.size(),vector<vector<int>>(T+1,vector<int>(T+1,-1)));\\n        int res=get(0,0,T);\\n        return res>=INF?-1:res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015164,
                "title": "ugly-greedy-solution-but-it-is-fast",
                "content": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        clips.sort()\\n        if T==0:\\n            return 0\\n        last = 0\\n        cnt=1\\n        first = 0\\n        i=0\\n        while i< len(clips):\\n            \\n            if clips[i][0]==first:\\n                last = clips[i][1]\\n                if last >=T:\\n                    return cnt\\n            elif clips[i][0]>first:      \\n                cnt+=1\\n                if clips[i][0]>last:\\n                    return -1\\n                else:\\n                    temp = last\\n                    while i<len(clips) and clips[i][0]<=temp:\\n                        last = max(last, clips[i][1])\\n                        if last>=T:\\n                            return cnt\\n                        i+=1\\n                    \\n                    if i == len(clips):\\n                        if T>last:\\n                            return -1\\n                        return cnt\\n                    first = clips[i][0]\\n            i+=1\\n        if clips[-1][1]== T:\\n            return cnt+1\\n        if T>last:\\n            return -1\\n        return cnt",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        clips.sort()\\n        if T==0:\\n            return 0\\n        last = 0\\n        cnt=1\\n        first = 0\\n        i=0\\n        while i< len(clips):\\n            \\n            if clips[i][0]==first:\\n                last = clips[i][1]\\n                if last >=T:\\n                    return cnt\\n            elif clips[i][0]>first:      \\n                cnt+=1\\n                if clips[i][0]>last:\\n                    return -1\\n                else:\\n                    temp = last\\n                    while i<len(clips) and clips[i][0]<=temp:\\n                        last = max(last, clips[i][1])\\n                        if last>=T:\\n                            return cnt\\n                        i+=1\\n                    \\n                    if i == len(clips):\\n                        if T>last:\\n                            return -1\\n                        return cnt\\n                    first = clips[i][0]\\n            i+=1\\n        if clips[-1][1]== T:\\n            return cnt+1\\n        if T>last:\\n            return -1\\n        return cnt",
                "codeTag": "Java"
            },
            {
                "id": 963483,
                "title": "idea",
                "content": "- \"we can cut a clip\" means for an interval, we can use any parts of it. \\n-  we don\\'t care how to cut it, we care how it could help us cover the range ```0..T```\\n- Given the requirement, we need to make sure each number in ```0,1,2,...,T``` will be covered.\\n- we would like to check them one by one: \\n\\t- so, why not check ```0``` first, then ```1```, then ```2```, ... ?\\n- Therefore, we may need to sort the clips (intervals) so that they are better corresponding to the order of from ```0``` to ```T```\\n\\n- Lets start. **Now we firstly need to cover** ```0```. How to cover it? For intervals represented as ```[a,b]```, every interval satisfying ```a<=0<=b``` should be considered.\\n- Okay, so maybe after checking, we find ```many``` intervals they all satisfy ```a<=0<=b```, what to do with them?\\n- We would think: why not just choose the interval with greatest ```b``` ? (greedy)\\n- The followings will be natural:\\n\\t- ok we have chosen the one with greatest ```b```. **We have covered** ```0```, but also looks like by the way we have also covered every number between ```0..b```\\n\\t- we don\\'t need to think about cover ```1..b``` anymore\\n\\t- **next step we just need to think about how to cover** ```b```\\n- What do we do?\\n\\t- We repeat the above method to find intervals satisfying ```a_new<=b<=b_new```\\n\\t- so on so forth!\\n\\t- Until we get a **new** ```b``` such that ```b>=T```,\\n\\t- we\\'re done.\\n\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        clips.sort()\\n        \\n        t = 0\\n        curmax = -1\\n        res = 0\\n        \\n        for clip in clips:\\n            if clip[0] <= t:\\n                curmax = max(curmax, clip[1])\\n            else:\\n                t = curmax\\n                res += 1\\n                if t < clip[0]:\\n                    return -1\\n                else:\\n                    curmax = clip[1]\\n            if curmax >= T:\\n                return res + 1\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```0..T```\n```0,1,2,...,T```\n```0```\n```1```\n```2```\n```0```\n```T```\n```0```\n```[a,b]```\n```a<=0<=b```\n```many```\n```a<=0<=b```\n```b```\n```b```\n```0```\n```0..b```\n```1..b```\n```b```\n```a_new<=b<=b_new```\n```b```\n```b>=T```\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        clips.sort()\\n        \\n        t = 0\\n        curmax = -1\\n        res = 0\\n        \\n        for clip in clips:\\n            if clip[0] <= t:\\n                curmax = max(curmax, clip[1])\\n            else:\\n                t = curmax\\n                res += 1\\n                if t < clip[0]:\\n                    return -1\\n                else:\\n                    curmax = clip[1]\\n            if curmax >= T:\\n                return res + 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957420,
                "title": "java-accepted-greedy-0ms",
                "content": "**GREEDY APPROACH** \\n\\nFirst sort the array so that we skip un - necessary comparisons\\nStarting from start=0,  we try and go till start=T, and at each time try to reach the furthest distance , so that we minimise the number of intervals.\\nThe core idea is quite similar to *jump game* question where we have to reach the end in minimum jumps.\\n\\n```\\n\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int count =0;\\n        int start=0;\\n        int i=0;\\n        Arrays.sort(clips, (a,b)->a[0]-b[0]);\\n        \\n        while(start<T)\\n        {\\n            int max = -1 ;\\n            boolean exist =false;\\n            for(;i<clips.length && start>=clips[i][0];i++)\\n            {\\n            //  System.out.println(Arrays.toString(clips[i]));\\n                if(max < clips[i][1])\\n                {\\n                    max=clips[i][1];\\n                    exist=true;\\n                }\\n                \\n            }\\n         //   System.out.println(max);\\n           \\n            if(!exist)\\n                return -1;\\n            count++;\\n            start =  max;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int count =0;\\n        int start=0;\\n        int i=0;\\n        Arrays.sort(clips, (a,b)->a[0]-b[0]);\\n        \\n        while(start<T)\\n        {\\n            int max = -1 ;\\n            boolean exist =false;\\n            for(;i<clips.length && start>=clips[i][0];i++)\\n            {\\n            //  System.out.println(Arrays.toString(clips[i]));\\n                if(max < clips[i][1])\\n                {\\n                    max=clips[i][1];\\n                    exist=true;\\n                }\\n                \\n            }\\n         //   System.out.println(max);\\n           \\n            if(!exist)\\n                return -1;\\n            count++;\\n            start =  max;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923972,
                "title": "python3-commented-faster-than-95-51",
                "content": "*Runtime: 28 ms, faster than 95.51% of Python3 online submissions for Video Stitching.\\nMemory Usage: 14.3 MB, less than 100.00% of Python3 online submissions for Video Stitching.*\\n\\n```python\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], target: int) -> int:\\n        if not clips:\\n            return -1\\n        # sort by earliest start and furtest end\\n        sorted_clips = sorted(clips, key=lambda clip: (clip[0], -clip[1]))\\n        # currently covered\\n        covered_left, covered_right = sorted_clips[0]\\n        # special case 0 not covered?\\n        if not covered_left <= 0 <= covered_right:\\n            return -1\\n        # keep track of the clips used\\n        min_clips = 1\\n        # explore the rest of the clips\\n        i = 1\\n        while i < len(sorted_clips):\\n            # check if we are done covering the target\\n            if target <= covered_right:\\n                return min_clips\\n            # check if the coverage is continuos\\n            left, right = sorted_clips[i]\\n            if not left <= covered_right:\\n                return -1\\n            # greedy choose the furthest each time\\n            while i < len(sorted_clips) and sorted_clips[i][0] <= covered_right:\\n                right = max(right, sorted_clips[i][1])\\n                i += 1\\n            # update covered interval\\n            covered_right = right\\n            min_clips += 1\\n            i += 1\\n        # we used all the clips but the target is still out of range?\\n        if not target <= right:\\n            return -1\\n        return min_clips\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], target: int) -> int:\\n        if not clips:\\n            return -1\\n        # sort by earliest start and furtest end\\n        sorted_clips = sorted(clips, key=lambda clip: (clip[0], -clip[1]))\\n        # currently covered\\n        covered_left, covered_right = sorted_clips[0]\\n        # special case 0 not covered?\\n        if not covered_left <= 0 <= covered_right:\\n            return -1\\n        # keep track of the clips used\\n        min_clips = 1\\n        # explore the rest of the clips\\n        i = 1\\n        while i < len(sorted_clips):\\n            # check if we are done covering the target\\n            if target <= covered_right:\\n                return min_clips\\n            # check if the coverage is continuos\\n            left, right = sorted_clips[i]\\n            if not left <= covered_right:\\n                return -1\\n            # greedy choose the furthest each time\\n            while i < len(sorted_clips) and sorted_clips[i][0] <= covered_right:\\n                right = max(right, sorted_clips[i][1])\\n                i += 1\\n            # update covered interval\\n            covered_right = right\\n            min_clips += 1\\n            i += 1\\n        # we used all the clips but the target is still out of range?\\n        if not target <= right:\\n            return -1\\n        return min_clips\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921334,
                "title": "simple-greedy-problem-java-combine-two-problems",
                "content": "There are two problems which are identical, It has same logic and approch. Both problems solved with Greedy.\\n1024. Video Stitching\\n1326. Minimum Number of Taps to Open to Water a Garden\\n\\n```\\n/*  [0,2][4,6][1,5][0,3]  T = 6\\n\\n\\n    Duration    0       1       2       3       4       5       6\\n                x---------------x\\n                                                x----------------x\\n                        x--------------------------------x\\n                x------------------------x\\n                \\n                \\n            min(0)-----------------------max(3)\\n                                         min(3)----------max(5)\\n                                                         min(5)----max(6)\\n\\n*/\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int min =0;\\n        int max =0;\\n        int total = 0;\\n        \\n        while(max<T) {             //Maximum value is crossing the total time\\n            for(int[] clip : clips) {\\n                int left = clip[0];\\n                int right = clip[1];\\n                \\n                if(left<=min && max<right) {    \\n                    max = right;\\n                }\\n            }\\n            if(min == max) {    //If solution could not be possibele.\\n                return -1;\\n            }\\n            min = max;  //Setting min to max for next incoming clip\\n            total++;\\n        }\\n        return total;\\n    }\\n}\\n```\\n1326. Minimum Number of Taps to Open to Water a Garden \\nFor this problem, please see a picture in describe, they have described very well to give visual impact.\\n```\\nclass Solution {\\n    public int minTaps(int n, int[] ranges) {\\n        int min = 0;\\n        int max = 0;\\n        int total = 0;\\n        int idx = 0;\\n        \\n        while(max<n) {                //  If maximum value is crossing the nober of taps\\n            for(int i=idx; i<ranges.length; i++) {\\n                if(i-ranges[i]<=min && max<i+ranges[i]){\\n                    max= i + ranges[i];   //Setting Maximum from the ranges\\n                    idx = i;\\n                }\\n            }\\n            if(min == max) return -1;   //Suppose there is no solution possible\\n            min = max;                  // Setting Minimum to start a new range\\n            total++;\\n        }\\n        return total;\\n    }\\n}\\n```\\nPlease upvote if you like.",
                "solutionTags": [
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\n/*  [0,2][4,6][1,5][0,3]  T = 6\\n\\n\\n    Duration    0       1       2       3       4       5       6\\n                x---------------x\\n                                                x----------------x\\n                        x--------------------------------x\\n                x------------------------x\\n                \\n                \\n            min(0)-----------------------max(3)\\n                                         min(3)----------max(5)\\n                                                         min(5)----max(6)\\n\\n*/\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int min =0;\\n        int max =0;\\n        int total = 0;\\n        \\n        while(max<T) {             //Maximum value is crossing the total time\\n            for(int[] clip : clips) {\\n                int left = clip[0];\\n                int right = clip[1];\\n                \\n                if(left<=min && max<right) {    \\n                    max = right;\\n                }\\n            }\\n            if(min == max) {    //If solution could not be possibele.\\n                return -1;\\n            }\\n            min = max;  //Setting min to max for next incoming clip\\n            total++;\\n        }\\n        return total;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int minTaps(int n, int[] ranges) {\\n        int min = 0;\\n        int max = 0;\\n        int total = 0;\\n        int idx = 0;\\n        \\n        while(max<n) {                //  If maximum value is crossing the nober of taps\\n            for(int i=idx; i<ranges.length; i++) {\\n                if(i-ranges[i]<=min && max<i+ranges[i]){\\n                    max= i + ranges[i];   //Setting Maximum from the ranges\\n                    idx = i;\\n                }\\n            }\\n            if(min == max) return -1;   //Suppose there is no solution possible\\n            min = max;                  // Setting Minimum to start a new range\\n            total++;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907548,
                "title": "o-n-no-sorting-based-on-jump-game",
                "content": "This problem is actually same with jump game.\\nFirst we build jump distance array:\\n```\\n        //for every position befor T, we find the max distance from this position\\n        for (int[] clip : clips) {\\n            if (clip[0] < T) {\\n                maxEnd[clip[0]] = Math.max(maxEnd[clip[0]], clip[1]);\\n            }\\n        }\\n```\\n\\nThen, we compute like jump game \\nbtw, jump game is actually a BFS pattern problem.\\nSo, for every step, we try to gain the max distance we can jump.\\nIf we arrive current max distance, we update the max distance by max, and res+=1;\\n\\n```\\n        int max = 0, res = 0, curMax = 0;\\n\\t\\t\\n        for (int i = 0; i < T; i++) {\\n            max = Math.max(max, maxEnd[i]);\\n            if (i == max) {\\n                return -1;\\n            }\\n            if (i == curMax) {\\n                res++;\\n                curMax = max;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\nThe complete code is :\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n\\t\\t//part one: build the step-distance 1-D array\\n        int[] maxEnd = new int[T];                \\n        for (int[] clip : clips) {\\n            if (clip[0] < T) {\\n                maxEnd[clip[0]] = Math.max(maxEnd[clip[0]], clip[1]);\\n            }\\n        }\\n        \\n\\t\\t//part two: solve it likes jump game \\n        int max = 0, res = 0, curMax = 0;\\n        for (int i = 0; i < T; i++) {\\n            max = Math.max(max, maxEnd[i]);\\n            if (i == max) {\\n                return -1;\\n            }\\n            if (i == curMax) {\\n                res++;\\n                curMax = max;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n\\n```\\nThe time complexity is O(n)",
                "solutionTags": [],
                "code": "```\\n        //for every position befor T, we find the max distance from this position\\n        for (int[] clip : clips) {\\n            if (clip[0] < T) {\\n                maxEnd[clip[0]] = Math.max(maxEnd[clip[0]], clip[1]);\\n            }\\n        }\\n```\n```\\n        int max = 0, res = 0, curMax = 0;\\n\\t\\t\\n        for (int i = 0; i < T; i++) {\\n            max = Math.max(max, maxEnd[i]);\\n            if (i == max) {\\n                return -1;\\n            }\\n            if (i == curMax) {\\n                res++;\\n                curMax = max;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n\\t\\t//part one: build the step-distance 1-D array\\n        int[] maxEnd = new int[T];                \\n        for (int[] clip : clips) {\\n            if (clip[0] < T) {\\n                maxEnd[clip[0]] = Math.max(maxEnd[clip[0]], clip[1]);\\n            }\\n        }\\n        \\n\\t\\t//part two: solve it likes jump game \\n        int max = 0, res = 0, curMax = 0;\\n        for (int i = 0; i < T; i++) {\\n            max = Math.max(max, maxEnd[i]);\\n            if (i == max) {\\n                return -1;\\n            }\\n            if (i == curMax) {\\n                res++;\\n                curMax = max;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 896344,
                "title": "java-dp-solution-with-explanation",
                "content": "Take reference of this example to understand:\\n```\\nint[][] arr = {{0,1},{6,8},{0,2},{5,6},{0,4},{0,3},{6,7},{1,3},{4,7},{1,4},{2,5},{2,6},{3,4},{4,5},{5,7},{6,9}};\\n```\\n\\n1. Sort the clips by start time.\\n2. \"normalise the input\". This means if there is any interval after sorting with same start time then pick the one with highest end time, like in above example if we have ``[0,1], [0,2], [0,3], [0,4]`` then it is obvious that if we pick ``[0,4] `` then it will contribute to min length.\\n3. As a part of normalisation also check if there is an interval which fully merges in the interval just retrieved above, then ignore it. For instance we had interval ``[0,4]`` now adding ``[2,4]`` will not contribute to anything so do not add it in out normalised list.\\n4. Now After running above 3 steps my list will only contain \\n\\n```\\n0,4\\n2,6\\n4,7\\n6,9\\n```\\n\\nNow convert this question to https://leetcode.com/problems/jump-game-ii/ and solve it using a DP array where dp[i] denotes min number of steps required to reach i\\n\\nNow my jump array will be as below:\\n``[4,0,6,0,7,0,9,0,0]``\\n\\nThis means that I can move from index 0 to index 4 or I can move from index 2 to index 6.\\n\\nfor my dp i am using two loops. I fix my first loop and move the second loop till max index defined in value of first loop and ask myself a simple question.\\n\\nWhat is the min steps required to move to index j from index i.\\n\\n```\\npackage com.practice.queue;\\n\\nimport java.util.*;\\n\\n//https://leetcode.com/problems/video-stitching/\\npublic class VideoStitching {\\n    public int videoStitching(int[][] clips, int T) {\\n        if(clips == null || clips.length <=0) {\\n            return -1;\\n        }\\n        Arrays.sort(clips, (a, b) -> Integer.compare(a[0], b[0]));\\n        if(clips[clips.length - 1][1] < T) {\\n            return  -1;\\n        }\\n        List<int[]> list = new ArrayList<>();\\n        list.add(clips[0]);\\n        for(int i=1;i<clips.length;i++) {\\n            int start = clips[i][0];\\n            int end = clips[i][1];\\n\\n            int prevStart = list.get(list.size() - 1)[0];\\n            int prevEnd = list.get(list.size() - 1)[1];\\n\\n            if(prevStart == start) {\\n                if(end > prevEnd) {\\n                    list.remove(list.size() - 1);\\n                    list.add(clips[i]);\\n                }\\n                continue;\\n            }\\n            if (start <= prevEnd && end <= prevEnd) {\\n                continue;\\n            }\\n            list.add(clips[i]);\\n        }\\n        int[] dp = new int[T + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n\\n        int[] jump = new int[T + 1];\\n        Arrays.fill(jump, 0);\\n        for(int[] current: list) {\\n            if(current[0] >= T) {\\n                continue;\\n            }\\n            jump[current[0]] = current[1];\\n        }\\n\\n        for(int i=0;i<T;i++) {\\n            if(jump[i] == 0) {\\n                continue;\\n            }\\n            int j = i + 1;\\n            for(;j <= jump[i] && j <= T;j++) {\\n                dp[j] = Math.min(dp[j], 1 + dp[i]);\\n            }\\n\\n        }\\n        for(int i=0;i<=T;i++) {\\n            if(dp[i] == Integer.MAX_VALUE) {\\n                return -1;\\n            }\\n        }\\n        return dp[T] == Integer.MAX_VALUE ? -1 : dp[T];\\n    }\\n\\n    public static void main(String args[]) {\\n        VideoStitching videoStitching =  new VideoStitching();\\n        int[][] arr = {{0,1},{6,8},{0,2},{5,6},{0,4},{0,3},{6,7},{1,3},{4,7},{1,4},{2,5},{2,6},{3,4},{4,5},{5,7},{6,9}};\\n\\n        videoStitching.videoStitching(arr, 9);\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint[][] arr = {{0,1},{6,8},{0,2},{5,6},{0,4},{0,3},{6,7},{1,3},{4,7},{1,4},{2,5},{2,6},{3,4},{4,5},{5,7},{6,9}};\\n```\n```\\n0,4\\n2,6\\n4,7\\n6,9\\n```\n```\\npackage com.practice.queue;\\n\\nimport java.util.*;\\n\\n//https://leetcode.com/problems/video-stitching/\\npublic class VideoStitching {\\n    public int videoStitching(int[][] clips, int T) {\\n        if(clips == null || clips.length <=0) {\\n            return -1;\\n        }\\n        Arrays.sort(clips, (a, b) -> Integer.compare(a[0], b[0]));\\n        if(clips[clips.length - 1][1] < T) {\\n            return  -1;\\n        }\\n        List<int[]> list = new ArrayList<>();\\n        list.add(clips[0]);\\n        for(int i=1;i<clips.length;i++) {\\n            int start = clips[i][0];\\n            int end = clips[i][1];\\n\\n            int prevStart = list.get(list.size() - 1)[0];\\n            int prevEnd = list.get(list.size() - 1)[1];\\n\\n            if(prevStart == start) {\\n                if(end > prevEnd) {\\n                    list.remove(list.size() - 1);\\n                    list.add(clips[i]);\\n                }\\n                continue;\\n            }\\n            if (start <= prevEnd && end <= prevEnd) {\\n                continue;\\n            }\\n            list.add(clips[i]);\\n        }\\n        int[] dp = new int[T + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n\\n        int[] jump = new int[T + 1];\\n        Arrays.fill(jump, 0);\\n        for(int[] current: list) {\\n            if(current[0] >= T) {\\n                continue;\\n            }\\n            jump[current[0]] = current[1];\\n        }\\n\\n        for(int i=0;i<T;i++) {\\n            if(jump[i] == 0) {\\n                continue;\\n            }\\n            int j = i + 1;\\n            for(;j <= jump[i] && j <= T;j++) {\\n                dp[j] = Math.min(dp[j], 1 + dp[i]);\\n            }\\n\\n        }\\n        for(int i=0;i<=T;i++) {\\n            if(dp[i] == Integer.MAX_VALUE) {\\n                return -1;\\n            }\\n        }\\n        return dp[T] == Integer.MAX_VALUE ? -1 : dp[T];\\n    }\\n\\n    public static void main(String args[]) {\\n        VideoStitching videoStitching =  new VideoStitching();\\n        int[][] arr = {{0,1},{6,8},{0,2},{5,6},{0,4},{0,3},{6,7},{1,3},{4,7},{1,4},{2,5},{2,6},{3,4},{4,5},{5,7},{6,9}};\\n\\n        videoStitching.videoStitching(arr, 9);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866265,
                "title": "confused-why-dp-at-all-if-you-already-sort-them-first",
                "content": "Both the question and the hints indicate that we should consider DP, which is what many people including myself have tried. In these DP solutions we sort the input clips first by their starting point, and then apply DP. However once they are sorted, why apply DP (O(TN)) instead of simply go through the sorted list (O(N))?\\n\\nMy solution with sorting but not DP (faster than ~90%, but not the point)\\n```\\n\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        if (T == 0) {\\n            return 0;\\n        }\\n                \\n        std::sort(clips.begin(), clips.end(), [](const std::vector<int> &lhs, const std::vector<int> &rhs){\\n           if (lhs[0] != rhs[0]) {\\n               return lhs[0] < rhs[0];\\n           } else {\\n               return lhs[1] > rhs[1];\\n           }\\n        });\\n        \\n\\t\\t// The max value that we can reach so far.\\n        int max_seen = 0;\\n\\t\\t// The previous max_seen, from which we try to determine the current candiate interval.\\n        int start_point = 0;\\n\\t\\t// Number of interval needed to reconstruct the video.\\n        int interval_count = 0; \\n\\t\\t\\n\\t\\t// Instead of DP, simply go through all the clips in one pass.\\n        for (const std::vector<int> &clip : clips) {\\n            if (clip[1] <= max_seen) {\\n                continue;\\n            } else if (max_seen < clip[0]) {\\n                return -1;\\n            }\\n            \\n            if (clip[0] > start_point) {\\n                // Part of the current clip is not covered by the previous interval, \\n\\t\\t\\t\\t// so start a new candidate interval.\\n                start_point = max_seen;\\n                 ++interval_count;\\n            } \\n\\n            if (clip[1] >= T) {\\n                return ++interval_count;\\n            }\\n            max_seen = clip[1];\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        if (T == 0) {\\n            return 0;\\n        }\\n                \\n        std::sort(clips.begin(), clips.end(), [](const std::vector<int> &lhs, const std::vector<int> &rhs){\\n           if (lhs[0] != rhs[0]) {\\n               return lhs[0] < rhs[0];\\n           } else {\\n               return lhs[1] > rhs[1];\\n           }\\n        });\\n        \\n\\t\\t// The max value that we can reach so far.\\n        int max_seen = 0;\\n\\t\\t// The previous max_seen, from which we try to determine the current candiate interval.\\n        int start_point = 0;\\n\\t\\t// Number of interval needed to reconstruct the video.\\n        int interval_count = 0; \\n\\t\\t\\n\\t\\t// Instead of DP, simply go through all the clips in one pass.\\n        for (const std::vector<int> &clip : clips) {\\n            if (clip[1] <= max_seen) {\\n                continue;\\n            } else if (max_seen < clip[0]) {\\n                return -1;\\n            }\\n            \\n            if (clip[0] > start_point) {\\n                // Part of the current clip is not covered by the previous interval, \\n\\t\\t\\t\\t// so start a new candidate interval.\\n                start_point = max_seen;\\n                 ++interval_count;\\n            } \\n\\n            if (clip[1] >= T) {\\n                return ++interval_count;\\n            }\\n            max_seen = clip[1];\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847705,
                "title": "c-knapsack-and-dfs-dp-approaches-explained",
                "content": "For the **Knapsack** idea, at a starting time, for the given clip, you have 2 options; you can either select the clip or choose to not select it. The time should also be part of DP state, because  our decision might change if we have encountered the clip at a different time.\\n**Time Complexity: O(N * T)**\\n\\nFor the **DFS** idea, ```dp(i)``` represents the number of clips you further need given that you have selected the clip ```i```. So, run a dfs checking for all possible options from ```i+1```. \\n**Time Complexity: O(N^2)**\\n\\nSince, in both the cases, its easier only when the clips are ordered according to their starting time, we sort them.\\n```\\nDFS DP\\nint memo[100];\\nint dp(int i,vector<vector<int>>& arr, int time,int T)\\n{\\n\\tif(time>=T)\\n\\t\\treturn 0;\\n\\telse if(i>=arr.size())\\n\\t\\treturn 1000;\\n\\telse if(memo[i]!=-1)\\n\\t\\treturn memo[i];\\n\\telse\\n\\t{\\n\\t\\tint q=1000;\\n\\t\\tfor(int j=i+1;j<arr.size()&&time>=arr[j][0];++j)\\n\\t\\t\\tq=min(q,1+dp(j,arr,max(time,arr[j][1]),T));\\n\\t\\treturn memo[i]=q;\\n\\t}\\n}\\nint videoStitching(vector<vector<int>>& clips, int T) \\n{\\n\\tsort(clips.begin(),clips.end());\\n\\tmemset(memo,-1,sizeof(memo));\\n\\tint ret=1000;\\n\\tfor(int i=0;i<clips.size();++i)\\n\\t\\tif(clips[i][0]==0)\\n\\t\\t\\tret=min(ret,1+dp(i,clips,clips[i][1],T));\\n\\treturn ret<1000?ret:-1;\\n}\\n\\n\\t```\\nKnapsack DP\\n\\nvector<vector<int>> memo;\\nint dp(int i,int t,vector<vector<int>>& clips,int T)\\n{\\n\\tif(i>=clips.size())\\n\\t{\\n\\t\\tif(t>=T)\\n\\t\\t\\treturn 0;\\n\\t\\telse return 101;\\n\\t}\\n\\tif(memo[i][t]!=-1)\\n\\t\\treturn memo[i][t];\\n\\tint not_taken=dp(i+1,t,clips,T);\\n\\tint taken=101;\\n\\tif(clips[i][0]<=t)\\n\\t\\ttaken=1+dp(i+1,max(t,clips[i][1]),clips,T);\\n\\treturn memo[i][t]=min(taken,not_taken);\\n}\\nint videoStitching(vector<vector<int>>& clips, int T) {\\n\\tsort(clips.begin(),clips.end());\\n\\tmemo.resize(clips.size(),vector<int>(100+1,-1));\\n\\tint val=dp(0,0,clips,T);\\n\\treturn val<=clips.size()?val:-1;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dp(i)```\n```i```\n```i+1```\n```\\nDFS DP\\nint memo[100];\\nint dp(int i,vector<vector<int>>& arr, int time,int T)\\n{\\n\\tif(time>=T)\\n\\t\\treturn 0;\\n\\telse if(i>=arr.size())\\n\\t\\treturn 1000;\\n\\telse if(memo[i]!=-1)\\n\\t\\treturn memo[i];\\n\\telse\\n\\t{\\n\\t\\tint q=1000;\\n\\t\\tfor(int j=i+1;j<arr.size()&&time>=arr[j][0];++j)\\n\\t\\t\\tq=min(q,1+dp(j,arr,max(time,arr[j][1]),T));\\n\\t\\treturn memo[i]=q;\\n\\t}\\n}\\nint videoStitching(vector<vector<int>>& clips, int T) \\n{\\n\\tsort(clips.begin(),clips.end());\\n\\tmemset(memo,-1,sizeof(memo));\\n\\tint ret=1000;\\n\\tfor(int i=0;i<clips.size();++i)\\n\\t\\tif(clips[i][0]==0)\\n\\t\\t\\tret=min(ret,1+dp(i,clips,clips[i][1],T));\\n\\treturn ret<1000?ret:-1;\\n}\\n\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 833691,
                "title": "c-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n        if(clips.size() == 0)\\n            return -1;\\n        \\n        sort(clips.begin(), clips.end(), \\n            [&](vector<int> &a, vector<int> &b)\\n            {\\n                return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);\\n            });\\n        \\n        \\n\\n        int idx = 0;\\n        for(int i = 0; i < clips.size(); i++){\\n            if(clips[i][0] != clips[idx][0])\\n                swap(clips[++idx], clips[i]);\\n        }\\n\\n        clips.resize(1 + idx);\\n        \\n        if(clips[0][0] != 0)\\n            return -1;\\n        \\n        vector<int> frag(T + 1, INT_MAX);\\n        for(int i = 0; i <= clips[0][1] && i <= T; i++)\\n            frag[i] = 1;\\n\\n        for(int i = 1; i < clips.size() && clips[i][0] < T; i++) \\n        {\\n            if(frag[clips[i][0]] == INT_MAX)\\n                return -1;\\n            else {\\n                int cnt = frag[clips[i][0]];\\n                for(int j = clips[i][0]; j <= clips[i][1] && j <= T; j++)\\n                    frag[j] = min(frag[j], cnt + 1);\\n            }\\n        }\\n        \\n        return frag.back() == INT_MAX ? -1 : frag.back();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n        if(clips.size() == 0)\\n            return -1;\\n        \\n        sort(clips.begin(), clips.end(), \\n            [&](vector<int> &a, vector<int> &b)\\n            {\\n                return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);\\n            });\\n        \\n        \\n\\n        int idx = 0;\\n        for(int i = 0; i < clips.size(); i++){\\n            if(clips[i][0] != clips[idx][0])\\n                swap(clips[++idx], clips[i]);\\n        }\\n\\n        clips.resize(1 + idx);\\n        \\n        if(clips[0][0] != 0)\\n            return -1;\\n        \\n        vector<int> frag(T + 1, INT_MAX);\\n        for(int i = 0; i <= clips[0][1] && i <= T; i++)\\n            frag[i] = 1;\\n\\n        for(int i = 1; i < clips.size() && clips[i][0] < T; i++) \\n        {\\n            if(frag[clips[i][0]] == INT_MAX)\\n                return -1;\\n            else {\\n                int cnt = frag[clips[i][0]];\\n                for(int j = clips[i][0]; j <= clips[i][1] && j <= T; j++)\\n                    frag[j] = min(frag[j], cnt + 1);\\n            }\\n        }\\n        \\n        return frag.back() == INT_MAX ? -1 : frag.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833273,
                "title": "top-down-and-bottom-up-dp",
                "content": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        memo = []\\n        for i in range(T+1):\\n            memo.append([-1 for _ in range(T+1)])\\n            \\n        def dp(left, right):\\n            # print(left, right)\\n            if left >= right:\\n                return 0\\n            if memo[left][right] != -1:\\n                return memo[left][right]\\n\\n            ret = float(\"inf\")\\n            for cleft, cright in clips:\\n                if cleft <= left and cright <= left or cleft >= right and cright >= right:\\n                    continue\\n                ret = min(ret, 1 + dp(left, cleft) + dp(cright, right))\\n            memo[left][right] = ret\\n            return ret\\n        \\n        ret = dp(0, T)\\n        return ret if ret != float(\"inf\") else -1\\n```\\n\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        clips.sort(key = lambda x: (x[0], x[1]))\\n        memo = []\\n        for left in range(T+1):\\n            memo.append([float(\"inf\") for _ in range(T+1)])\\n            for right in range(T+1):\\n                if left >= right:\\n                    memo[left][right] = 0 \\n            \\n        for l in range(1, T+2):\\n            for left in range(T+1):\\n                right = left + l - 1\\n                # print(left, right)\\n                if right > T:\\n                    break\\n                for cleft, cright in clips:\\n                    if cleft <= left and cright <= left:\\n                        continue\\n                    if cleft >= right and cright >= right:\\n                        break\\n                    p1 = memo[left][cleft]\\n                    p2 = memo[cright][right] if cright <= right else 0\\n                    memo[left][right] = min(memo[left][right], 1 + p1 + p2)\\n        return memo[0][T] if memo[0][T] != float(\"inf\") else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        memo = []\\n        for i in range(T+1):\\n            memo.append([-1 for _ in range(T+1)])\\n            \\n        def dp(left, right):\\n            # print(left, right)\\n            if left >= right:\\n                return 0\\n            if memo[left][right] != -1:\\n                return memo[left][right]\\n\\n            ret = float(\"inf\")\\n            for cleft, cright in clips:\\n                if cleft <= left and cright <= left or cleft >= right and cright >= right:\\n                    continue\\n                ret = min(ret, 1 + dp(left, cleft) + dp(cright, right))\\n            memo[left][right] = ret\\n            return ret\\n        \\n        ret = dp(0, T)\\n        return ret if ret != float(\"inf\") else -1\\n```\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        clips.sort(key = lambda x: (x[0], x[1]))\\n        memo = []\\n        for left in range(T+1):\\n            memo.append([float(\"inf\") for _ in range(T+1)])\\n            for right in range(T+1):\\n                if left >= right:\\n                    memo[left][right] = 0 \\n            \\n        for l in range(1, T+2):\\n            for left in range(T+1):\\n                right = left + l - 1\\n                # print(left, right)\\n                if right > T:\\n                    break\\n                for cleft, cright in clips:\\n                    if cleft <= left and cright <= left:\\n                        continue\\n                    if cleft >= right and cright >= right:\\n                        break\\n                    p1 = memo[left][cleft]\\n                    p2 = memo[cright][right] if cright <= right else 0\\n                    memo[left][right] = min(memo[left][right], 1 + p1 + p2)\\n        return memo[0][T] if memo[0][T] != float(\"inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 821273,
                "title": "dp-explained-beats-92-c",
                "content": "\\n> Approach \\n1. You might have figured out we need a travesal scheme.\\n2. Also you would have thought to order the clips in increasing order of `{start, end}` time\\n2. For travesal, did you think of some kind of `BFS`?\\n3. You are correct, we attempt this problem by a similar approach. \\n4. Since we have sorted things will be easy \\n5. We try to combine the `clip[i] {st, en}` with `clip[j] {beg, fin} ` , where `j > i and j < n` only when \\n\\ta. when the ovelapp is partial, i.e `clip[j]` should not be completly inside `clip[i]`.\\n\\tb. We come up with following formula for merging \\n\\tc. `(st < beg && beg <= en && en < fin)`\\n\\t\\n6. While merging we store the minimimum (merged) for each clip\\n\\n\\n> Algorithm \\n\\n```\\nint videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        sort(clips.begin(), clips.end());\\n        \\n        vector<int> minFromHere(n, 2*T);\\n\\t\\t// a high value \\n        int ans = 2*T;\\n        \\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t// starting and ending time \\n            int st = clips[i][0];\\n            int en = clips[i][1];\\n            \\n            if(st == 0) {\\n\\t\\t\\t\\t// first clip\\n                minFromHere[i] = 1;\\n            }\\n            \\n            if(en >= T) {\\n\\t\\t\\t\\t// last clip update ans \\n                ans = min(ans, minFromHere[i]);\\n                continue;\\n            }\\n            \\n\\t\\t\\t// for all the intermediate clips \\n            for(int j=i+1; j<n; j++) {\\n\\t\\t\\t\\t// starting and ending time\\n                int beg = clips[j][0];\\n                int fin = clips[j][1];\\n                    \\n                if(st < beg && beg <= en && en < fin) {\\n\\t\\t\\t\\t\\t// valid clip \\n                    minFromHere[j] = min(minFromHere[j], minFromHere[i] + 1);\\n                }\\n            }\\n        }\\n        \\n        return (ans == 2*T? -1: ans);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Breadth-First Search"
                ],
                "code": "```\\nint videoStitching(vector<vector<int>>& clips, int T) {\\n        int n = clips.size();\\n        sort(clips.begin(), clips.end());\\n        \\n        vector<int> minFromHere(n, 2*T);\\n\\t\\t// a high value \\n        int ans = 2*T;\\n        \\n        for(int i=0; i<n; i++) {\\n\\t\\t\\t// starting and ending time \\n            int st = clips[i][0];\\n            int en = clips[i][1];\\n            \\n            if(st == 0) {\\n\\t\\t\\t\\t// first clip\\n                minFromHere[i] = 1;\\n            }\\n            \\n            if(en >= T) {\\n\\t\\t\\t\\t// last clip update ans \\n                ans = min(ans, minFromHere[i]);\\n                continue;\\n            }\\n            \\n\\t\\t\\t// for all the intermediate clips \\n            for(int j=i+1; j<n; j++) {\\n\\t\\t\\t\\t// starting and ending time\\n                int beg = clips[j][0];\\n                int fin = clips[j][1];\\n                    \\n                if(st < beg && beg <= en && en < fin) {\\n\\t\\t\\t\\t\\t// valid clip \\n                    minFromHere[j] = min(minFromHere[j], minFromHere[i] + 1);\\n                }\\n            }\\n        }\\n        \\n        return (ans == 2*T? -1: ans);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 789021,
                "title": "super-easy-java-solution-0ms-100-better",
                "content": "class Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        \\n        int min = 0;\\n        int max = 0;\\n        int count = 0;\\n        \\n        while(max<T)\\n        {\\n            for(int i=0;i<clips.length;i++)\\n            {\\n                int left = clips[i][0];\\n                int right = clips[i][1];\\n                \\n                if(left<=min && right>max)\\n                {\\n                    max = right;\\n                }\\n               \\n            }\\n             if(min==max) return -1;\\n                min=max;\\n                count++;\\n        }\\n        return count;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        \\n        int min = 0;\\n        int max = 0;\\n        int count = 0;\\n        \\n        while(max<T)\\n        {\\n            for(int i=0;i<clips.length;i++)\\n            {\\n                int left = clips[i][0];\\n                int right = clips[i][1];\\n                \\n                if(left<=min && right>max)\\n                {\\n                    max = right;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 733035,
                "title": "python-simple-using-1-d-dp-o-t-len-clips",
                "content": "```\\n# Written with love by atm1504\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        dp=[float(\"inf\")]*(T+1)\\n        dp[0]=0\\n        for i in range(1,T+1):\\n            for x in clips:\\n                if x[1]>=i>x[0]:\\n                    dp[i]=min(dp[i],dp[x[0]]+1)\\n        if dp[T]==float(\"inf\"):\\n            return -1\\n        return dp[T]\\n        \\n```",
                "solutionTags": [],
                "code": "```\\n# Written with love by atm1504\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        dp=[float(\"inf\")]*(T+1)\\n        dp[0]=0\\n        for i in range(1,T+1):\\n            for x in clips:\\n                if x[1]>=i>x[0]:\\n                    dp[i]=min(dp[i],dp[x[0]]+1)\\n        if dp[T]==float(\"inf\"):\\n            return -1\\n        return dp[T]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 541302,
                "title": "simple-c-sorting-method",
                "content": "```\\nint videoStitching(vector<vector<int>>& clips, int T) {\\n\\tsort(clips.begin(), clips.end());\\n\\n\\tint cnt = 1;\\n\\tint curr = 0, next = INT_MIN;\\n\\n\\tfor (vector<int>& val : clips) {\\n\\t\\tif (val[0] <= curr) next = max(next, val[1]);\\n\\t\\telse if (val[0] > next) return -1;\\n\\t\\telse {\\n\\t\\t\\t++cnt;\\n\\t\\t\\tcurr = next;\\n\\t\\t\\tnext = max(next, val[1]);\\n\\t\\t}\\n\\n\\t\\tif (next >= T) return cnt;\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint videoStitching(vector<vector<int>>& clips, int T) {\\n\\tsort(clips.begin(), clips.end());\\n\\n\\tint cnt = 1;\\n\\tint curr = 0, next = INT_MIN;\\n\\n\\tfor (vector<int>& val : clips) {\\n\\t\\tif (val[0] <= curr) next = max(next, val[1]);\\n\\t\\telse if (val[0] > next) return -1;\\n\\t\\telse {\\n\\t\\t\\t++cnt;\\n\\t\\t\\tcurr = next;\\n\\t\\t\\tnext = max(next, val[1]);\\n\\t\\t}\\n\\n\\t\\tif (next >= T) return cnt;\\n\\t}\\n\\n\\treturn -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526433,
                "title": "o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        vector<int> intervals(T + 1, 0);  \\n        for (auto &clip : clips) {\\n            if (clip[0] <= T) {\\n                intervals[clip[0]] = min(T, max(intervals[clip[0]], clip[1]));\\n            }\\n        }\\n        int p0 = -1, p1 = intervals[0], cnt = 1;\\n        for (int i = 1; i <= T && p1 >= i; i++) {\\n            if (intervals[i] > p1) {\\n                if (i <= p0) p1 = intervals[i];\\n                else {\\n                    p0 = p1;\\n                    p1 = intervals[i];\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return p1 >= T ? cnt : -1;    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        vector<int> intervals(T + 1, 0);  \\n        for (auto &clip : clips) {\\n            if (clip[0] <= T) {\\n                intervals[clip[0]] = min(T, max(intervals[clip[0]], clip[1]));\\n            }\\n        }\\n        int p0 = -1, p1 = intervals[0], cnt = 1;\\n        for (int i = 1; i <= T && p1 >= i; i++) {\\n            if (intervals[i] > p1) {\\n                if (i <= p0) p1 = intervals[i];\\n                else {\\n                    p0 = p1;\\n                    p1 = intervals[i];\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return p1 >= T ? cnt : -1;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 496820,
                "title": "java-priorityqueue-solution-in-1ms",
                "content": "```\\npublic int videoStitching(int[][] clips, int T) {\\n\\tPriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n\\tfor (int[] clip : clips) pq.offer(clip);\\n\\tint res = 0;\\n\\tint end = 0;\\n\\twhile (!pq.isEmpty() && end < T) {\\n\\t\\tif (pq.peek()[0] > end) return -1;\\n\\t\\tint nextEnd = 0;\\n\\t\\twhile (!pq.isEmpty() && pq.peek()[0] <= end) {\\n\\t\\t\\tnextEnd = Math.max(nextEnd, pq.poll()[1]);\\n\\t\\t}\\n\\t\\tend = nextEnd;\\n\\t\\tres++;\\n\\t}\\n\\treturn end >= T ? res : -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int videoStitching(int[][] clips, int T) {\\n\\tPriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n\\tfor (int[] clip : clips) pq.offer(clip);\\n\\tint res = 0;\\n\\tint end = 0;\\n\\twhile (!pq.isEmpty() && end < T) {\\n\\t\\tif (pq.peek()[0] > end) return -1;\\n\\t\\tint nextEnd = 0;\\n\\t\\twhile (!pq.isEmpty() && pq.peek()[0] <= end) {\\n\\t\\t\\tnextEnd = Math.max(nextEnd, pq.poll()[1]);\\n\\t\\t}\\n\\t\\tend = nextEnd;\\n\\t\\tres++;\\n\\t}\\n\\treturn end >= T ? res : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 486056,
                "title": "without-sort-space-o-1-time-worst-o-n-2-average-o-n-m",
                "content": "This solution uses no DP and beats 100% LC runtime.\\n\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int max = 0;\\n        int start = 0, j = 0, i;\\n        while(start < T) {\\n            i = 0;\\n            while(i < clips.length) {\\n                if(start >= clips[i][0] && max < clips[i][1])\\n                    max = clips[i][1];\\n                i++;\\n            }\\n            if(start == max) return -1;\\n            j++;\\n            start = max;\\n        }\\n        return j < clips.length + 1 ? j : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int max = 0;\\n        int start = 0, j = 0, i;\\n        while(start < T) {\\n            i = 0;\\n            while(i < clips.length) {\\n                if(start >= clips[i][0] && max < clips[i][1])\\n                    max = clips[i][1];\\n                i++;\\n            }\\n            if(start == max) return -1;\\n            j++;\\n            start = max;\\n        }\\n        return j < clips.length + 1 ? j : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484775,
                "title": "easy-solution-using-greedy-and-dp-in-java",
                "content": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int n=clips.length;\\n        Arrays.sort(clips,(a,b)->(a[0]==b[0]?b[1]-a[1]:a[0]-b[0]));\\n        int[] dp=new int[n];\\n        if(clips[0][0]!=0)\\n            return -1;\\n        dp[0]=1;\\n        if(clips[0][1]==T)\\n            return 1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0)\\n                dp[i]=n+1;\\n            for(int j=0;j<i;j++)\\n            {\\n             if(clips[i][1]>clips[j][1] && clips[i][0]<=clips[j][1])\\n             {\\n                 dp[i]=Math.min(dp[i],dp[j]+1);\\n             }\\n            }\\n            if(clips[i][1]>=T)\\n            {\\n                if(dp[i]==n+1)\\n                    continue;\\n                else\\n                    return dp[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\nSimilar Question:https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int n=clips.length;\\n        Arrays.sort(clips,(a,b)->(a[0]==b[0]?b[1]-a[1]:a[0]-b[0]));\\n        int[] dp=new int[n];\\n        if(clips[0][0]!=0)\\n            return -1;\\n        dp[0]=1;\\n        if(clips[0][1]==T)\\n            return 1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i>0)\\n                dp[i]=n+1;\\n            for(int j=0;j<i;j++)\\n            {\\n             if(clips[i][1]>clips[j][1] && clips[i][0]<=clips[j][1])\\n             {\\n                 dp[i]=Math.min(dp[i],dp[j]+1);\\n             }\\n            }\\n            if(clips[i][1]>=T)\\n            {\\n                if(dp[i]==n+1)\\n                    continue;\\n                else\\n                    return dp[i];\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436077,
                "title": "bfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        unordered_map<int,vector<int>> map;\\n        for(auto clip : clips){\\n            map[clip[0]].push_back(clip[1]);\\n        }\\n        queue<int> q;\\n        vector<bool> visited(T+1, false);\\n        q.push(0);\\n        int num = 0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i = 0; i<size; i++){\\n                int curr = q.front();\\n                q.pop();\\n                if(curr==T){\\n                    return num;\\n                }\\n                for(int j : map[curr]){\\n                    for(int k = 0; k<=j; k++){\\n                        if(visited[k]==false){\\n                            visited[k] = true;\\n                            q.push(k);\\n                        }\\n                    }\\n                }\\n            }\\n            num++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        unordered_map<int,vector<int>> map;\\n        for(auto clip : clips){\\n            map[clip[0]].push_back(clip[1]);\\n        }\\n        queue<int> q;\\n        vector<bool> visited(T+1, false);\\n        q.push(0);\\n        int num = 0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i = 0; i<size; i++){\\n                int curr = q.front();\\n                q.pop();\\n                if(curr==T){\\n                    return num;\\n                }\\n                for(int j : map[curr]){\\n                    for(int k = 0; k<=j; k++){\\n                        if(visited[k]==false){\\n                            visited[k] = true;\\n                            q.push(k);\\n                        }\\n                    }\\n                }\\n            }\\n            num++;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398684,
                "title": "java-solution-has-clearly-explanation-time-o-nlogn-space-o-1",
                "content": "``` Problem is finding minimum of merging clips to make a clip: [0, T]\\n1. First clips must start from zero.\\n2. If next clips doesn\\'t overlap with current merged clip or overlap but they have endTime shorted than endTime of current merged clip, return -1.\\n3. If they have multiple overlap, only merge with an overlap which have longest endTime.\\n\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        \\n        if (clips.length == 0) return -1;\\n        Arrays.sort(clips, (a, b) -> (a[0] - b[0]));\\n        if (clips[0][0] > 0) return -1; // because clips doesn\\'t start from zero;\\n        \\n        int[] lastClip = new int[]{0, 0};\\n        int count = 0, i = 0;\\n        while(i < clips.length && lastClip[1] < T) {\\n            \\n            int[] nextClip = null;\\n            int maxEnd = 0;\\n            while(i < clips.length && isOverlap(lastClip, clips[i])) {\\n                if (maxEnd < clips[i][1]) {\\n                    maxEnd = clips[i][1];\\n                    nextClip = clips[i];\\n                }\\n                i++;\\n            }\\n            \\n            \\n            if (nextClip == null || nextClip[1] <= lastClip[1]) return -1;\\n            // because the length of clips couldn\\'t increase, so They never have endTime >= T\\n            \\n            lastClip[1] = nextClip[1];\\n            count++;\\n        }\\n        \\n        return lastClip[1] >= T ? count : -1;\\n    }\\n    \\n    private boolean isOverlap(int[] clip1, int[] clip2) {\\n        return clip1[1] >= clip2[0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` Problem is finding minimum of merging clips to make a clip: [0, T]\\n1. First clips must start from zero.\\n2. If next clips doesn\\'t overlap with current merged clip or overlap but they have endTime shorted than endTime of current merged clip, return -1.\\n3. If they have multiple overlap, only merge with an overlap which have longest endTime.\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 395401,
                "title": "0ms-faster-than-100-o-n-c-simple-traversal-of-array-once-o-1-storage",
                "content": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> a, vector<int> b)\\n    {\\n        return a[1] < b[1];\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n        sort(clips.begin(), clips.end(), comp);\\n        int n = clips.size();\\n        int val = T;\\n        int check = T;\\n        int steps = 0;\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            while (i >= 0 && clips[i][1] >= val)\\n            {\\n                check = min(check, clips[i][0]);\\n                if (check == 0)\\n                    return steps + 1;\\n                i--;\\n            }\\n            steps++;\\n            if (check == val)\\n                return -1;\\n            val = check;\\n            check = val;\\n            i++;\\n        }\\n        if (val != 0)\\n            return -1;\\n        return steps;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool comp(vector<int> a, vector<int> b)\\n    {\\n        return a[1] < b[1];\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int T) \\n    {\\n        sort(clips.begin(), clips.end(), comp);\\n        int n = clips.size();\\n        int val = T;\\n        int check = T;\\n        int steps = 0;\\n        for (int i = n - 1; i >= 0; i--)\\n        {\\n            while (i >= 0 && clips[i][1] >= val)\\n            {\\n                check = min(check, clips[i][0]);\\n                if (check == 0)\\n                    return steps + 1;\\n                i--;\\n            }\\n            steps++;\\n            if (check == val)\\n                return -1;\\n            val = check;\\n            check = val;\\n            i++;\\n        }\\n        if (val != 0)\\n            return -1;\\n        return steps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 370350,
                "title": "python-o-n-greedy-solution-75-runtime-100-memory",
                "content": "Not sure why this got tagged as DP - while I\\'m sure DP is a valid approach, a greedy approach seems far more intuitive.\\n\\nSort in increasing order by start time, then in decreasing order by end time.\\n\\nPick the first clip, then move to the right until you find the largest end time for the next clip whose start time is <= that of your previous clip. Repeat until you hit T (return number of clips used) or exceed the array bounds (return -1).\\n\\n```\\nclass Solution(object):\\n    def videoStitching(self, clips, T):\\n        \"\"\"\\n        :type clips: List[List[int]]\\n        :type T: int\\n        :rtype: int\\n        \"\"\"\\n        clips.sort(key=lambda x:(x[0],-x[1]))\\n        # If lowest time isn\\'t 0, we cannot cover the event\\n        if clips[0][0]>0: return -1\\n        ans = 1\\n        end = clips[0][1]\\n        use = 0\\n        while end < T:\\n            i = use+1\\n            tmp = end\\n            if clips[i][0]>end: return -1\\n            while i < len(clips) and clips[i][0]<=end:\\n                if clips[i][1]>tmp:\\n                    tmp = clips[i][1]\\n                    use = i\\n                i += 1\\n            end = tmp\\n            ans += 1\\n            if i>=len(clips) and end<T: return -1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def videoStitching(self, clips, T):\\n        \"\"\"\\n        :type clips: List[List[int]]\\n        :type T: int\\n        :rtype: int\\n        \"\"\"\\n        clips.sort(key=lambda x:(x[0],-x[1]))\\n        # If lowest time isn\\'t 0, we cannot cover the event\\n        if clips[0][0]>0: return -1\\n        ans = 1\\n        end = clips[0][1]\\n        use = 0\\n        while end < T:\\n            i = use+1\\n            tmp = end\\n            if clips[i][0]>end: return -1\\n            while i < len(clips) and clips[i][0]<=end:\\n                if clips[i][1]>tmp:\\n                    tmp = clips[i][1]\\n                    use = i\\n                i += 1\\n            end = tmp\\n            ans += 1\\n            if i>=len(clips) and end<T: return -1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312543,
                "title": "c-dp-solution-4ms-no-sorting",
                "content": "class Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int dp[205];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=0;i<clips.size();i++){\\n            if(dp[clips[i][0]]<clips[i][1]) dp[clips[i][0]] = clips[i][1];\\n        }\\n        for(int i=1;i<205;i++){\\n            dp[i] = max(dp[i],dp[i-1]);\\n        }\\n        int i=0,ans=0;\\n        while(i<T ){\\n            if(dp[i]<=i){\\n                ans=-1;\\n                break;\\n            }\\n            i = dp[i];\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        int dp[205];\\n        memset(dp,0,sizeof(dp));\\n        for(int i=0;i<clips.size();i++){\\n            if(dp[clips[i][0]]<clips[i][1]) dp[clips[i][0]] = clips[i][1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 307135,
                "title": "java-solution-using-buckets-no-sorting-o-n",
                "content": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        List<int[]>[] buckets = new ArrayList[101];\\n        for(int[] clip : clips) {\\n            if(buckets[clip[0]] == null) buckets[clip[0]] = new ArrayList<>();\\n            buckets[clip[0]].add(clip);\\n        }\\n        int start = 0, end = 0;\\n        int res = 0;\\n        while(end < T) {\\n            int next = end;\\n            for(int i = start; i <= end; i++) {\\n                List<int[]> bucket = buckets[i];\\n                if(bucket == null) continue;\\n                for(int[] clip : bucket) {\\n                    if(clip[1] > next) {\\n                        next = clip[1];\\n                        start = clip[0];\\n                    }\\n                }\\n            }\\n            if(next == end) return -1;\\n            end = next;\\n            res++;\\n            //System.out.println(start + \" \" + end);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        List<int[]>[] buckets = new ArrayList[101];\\n        for(int[] clip : clips) {\\n            if(buckets[clip[0]] == null) buckets[clip[0]] = new ArrayList<>();\\n            buckets[clip[0]].add(clip);\\n        }\\n        int start = 0, end = 0;\\n        int res = 0;\\n        while(end < T) {\\n            int next = end;\\n            for(int i = start; i <= end; i++) {\\n                List<int[]> bucket = buckets[i];\\n                if(bucket == null) continue;\\n                for(int[] clip : bucket) {\\n                    if(clip[1] > next) {\\n                        next = clip[1];\\n                        start = clip[0];\\n                    }\\n                }\\n            }\\n            if(next == end) return -1;\\n            end = next;\\n            res++;\\n            //System.out.println(start + \" \" + end);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 304932,
                "title": "c-greedy-0ms-with-explanation",
                "content": "```\\n1. sort the clips by starting value, if with the same starting value, sort by ending value.\\n    same idea can apply to many interval questions.\\n2. every time pick a node, whose starting point is no larger than your current starting value.\\n    Among them, choose the one with largest ending point.\\n3. last round\\'s ending point will be the starting point next round.\\n4. if current search cannot reach a suitable node, fail\\n    if cuurent ending point is no less than T, succeed\\n```\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n\\t\\t/* sort first, which make complexity to be O(N*logN) */\\n        sort(clips.begin(),clips.end(),[](auto &i1, auto &i2){\\n           if(i1[0] == i2[0]) return i1[1] < i2[1];\\n            else return i1[0] < i2[0];});\\n        \\n        int idx = 0,cnt = 0,head = 0,longest_end = -1, end_idx = -1;\\n        while(idx < clips.size()){\\n            for(;idx < clips.size();idx++){\\n\\t\\t\\t\\t/* choose largest ending point among the nodes whose starting point is no larger than head */\\n                if(clips[idx][0] <= head){\\n                    if(clips[idx][1] > longest_end)\\n                        longest_end = clips[idx][1], end_idx = idx;\\n                }\\n                else\\n                    break;\\n            }\\n            cnt++;\\n            if(longest_end >= T)   // found node can END the requirement, succeed. \\n                return cnt;\\n            else if(end_idx == -1) // find nothing in this round, fail\\n                return -1;\\n            head = longest_end;\\n            end_idx = -1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n1. sort the clips by starting value, if with the same starting value, sort by ending value.\\n    same idea can apply to many interval questions.\\n2. every time pick a node, whose starting point is no larger than your current starting value.\\n    Among them, choose the one with largest ending point.\\n3. last round\\'s ending point will be the starting point next round.\\n4. if current search cannot reach a suitable node, fail\\n    if cuurent ending point is no less than T, succeed\\n```\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n\\t\\t/* sort first, which make complexity to be O(N*logN) */\\n        sort(clips.begin(),clips.end(),[](auto &i1, auto &i2){\\n           if(i1[0] == i2[0]) return i1[1] < i2[1];\\n            else return i1[0] < i2[0];});\\n        \\n        int idx = 0,cnt = 0,head = 0,longest_end = -1, end_idx = -1;\\n        while(idx < clips.size()){\\n            for(;idx < clips.size();idx++){\\n\\t\\t\\t\\t/* choose largest ending point among the nodes whose starting point is no larger than head */\\n                if(clips[idx][0] <= head){\\n                    if(clips[idx][1] > longest_end)\\n                        longest_end = clips[idx][1], end_idx = idx;\\n                }\\n                else\\n                    break;\\n            }\\n            cnt++;\\n            if(longest_end >= T)   // found node can END the requirement, succeed. \\n                return cnt;\\n            else if(end_idx == -1) // find nothing in this round, fail\\n                return -1;\\n            head = longest_end;\\n            end_idx = -1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303094,
                "title": "easy-short-fast-python-solution",
                "content": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n\\n        clips.sort(key=lambda x:x[0])\\n        start = ending = count = i = 0\\n        \\n        while i < len(clips):\\n\\t\\t    # find the latest time that can be covered by adding one segment\\n            while (i < len(clips)) and (clips[i][0] <= start) :\\n                ending = max(ending, clips[i][1])    \\n                i += 1\\n            count += 1    #added a segment\\n            if ending >= T:    # we are done\\n                return count\\n            if ending == start:    # we couldn\\'t move forward in time, and haven\\'t reached T\\n                return -1\\n            start = ending    # prepare for adding another segment \\n        \\n\\t\\t# there is no valid solution if after going through all segments, we haven\\'t reached T\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n\\n        clips.sort(key=lambda x:x[0])\\n        start = ending = count = i = 0\\n        \\n        while i < len(clips):\\n\\t\\t    # find the latest time that can be covered by adding one segment\\n            while (i < len(clips)) and (clips[i][0] <= start) :\\n                ending = max(ending, clips[i][1])    \\n                i += 1\\n            count += 1    #added a segment\\n            if ending >= T:    # we are done\\n                return count\\n            if ending == start:    # we couldn\\'t move forward in time, and haven\\'t reached T\\n                return -1\\n            start = ending    # prepare for adding another segment \\n        \\n\\t\\t# there is no valid solution if after going through all segments, we haven\\'t reached T\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301910,
                "title": "c-greedy-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(),clips.end(), [](vector<int>& a, vector<int>& b) {\\n            if(a[0]<b[0]) return true;\\n            if(a[0]==b[0] && a[1]<b[1]) return true;\\n            else return false;\\n        });\\n        if(clips[0][0]!=0) return -1;\\n        int count = 0;\\n        int num = 0;\\n        int i = 0;\\n        for(i=0; i<clips.size();) {\\n            int maxR = INT_MIN;\\n            while((i<clips.size()) && (clips[i][0]<=num)) {\\n                maxR = max(maxR,clips[i][1]);\\n                i++;\\n            }\\n            num = maxR;\\n            count++;\\n            if(num>=T) break;\\n            else if(i>=clips.size() || num==INT_MIN) return -1;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        sort(clips.begin(),clips.end(), [](vector<int>& a, vector<int>& b) {\\n            if(a[0]<b[0]) return true;\\n            if(a[0]==b[0] && a[1]<b[1]) return true;\\n            else return false;\\n        });\\n        if(clips[0][0]!=0) return -1;\\n        int count = 0;\\n        int num = 0;\\n        int i = 0;\\n        for(i=0; i<clips.size();) {\\n            int maxR = INT_MIN;\\n            while((i<clips.size()) && (clips[i][0]<=num)) {\\n                maxR = max(maxR,clips[i][1]);\\n                i++;\\n            }\\n            num = maxR;\\n            count++;\\n            if(num>=T) break;\\n            else if(i>=clips.size() || num==INT_MIN) return -1;\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296262,
                "title": "easy-to-understand-c-greedy-algo",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        if(T == 0)\\n            return 0;\\n        \\n        // running time is N*LOG(N) + N\\n        \\n        // sort clips from starting point, and if starting points are equal, \\n        // then by shortest to longest\\n        \\n        std::sort(clips.begin(), clips.end(), [](const vector<int>& lhs, const vector<int>& rhs) {\\n            int lhsLen = lhs[1] - lhs[0];\\n            int rhsLen = rhs[1] - rhs[0];\\n            if(lhs[0] == rhs[0])\\n                return lhsLen < rhsLen;\\n            return lhs[0] < rhs[0];\\n        });\\n        \\n        // we need to have SOME clip starting at 0\\n        if(clips[0][0] != 0)\\n            return -1;\\n        \\n        // ordered from left to right, largest to smallest\\n        int numClips = 0;\\n        int n = (int)clips.size();\\n        \\n        // marker represents the furthest point we can reach in a clip\\n        // \\n        // example:\\n        //\\n        // [0 1]\\n        // [0, 1, 2, 3]  <-- marker will become 3, now search all clips with start <= 3\\n        //          [3, 4]\\n        //          [3, 4, 5]\\n        //       [2, 3, 4, 5, 6, 7] <-- marker will become 7\\n        //\\n        //      this continues until marker is at or past T.\\n        //      \\n        \\n        int marker = 0;\\n        int i = 0;\\n        \\n        // greedy algorithm: trying to reach T as quickly as possible.\\n        \\n        while(i < n) {\\n            \\n            // determine which clip will get us out the furthest\\n            \\n            int best = -1;\\n            while(i < n && clips[i][0] <= marker) {\\n                if(clips[i][1] > best)\\n                    best = clips[i][1];\\n                i++;\\n            }\\n            \\n            marker = best;            \\n            numClips++;\\n            \\n            if(marker >= T)\\n                break;\\n            \\n            if(i >= n || best == -1)\\n                return -1;\\n        }\\n        \\n        return numClips;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        if(T == 0)\\n            return 0;\\n        \\n        // running time is N*LOG(N) + N\\n        \\n        // sort clips from starting point, and if starting points are equal, \\n        // then by shortest to longest\\n        \\n        std::sort(clips.begin(), clips.end(), [](const vector<int>& lhs, const vector<int>& rhs) {\\n            int lhsLen = lhs[1] - lhs[0];\\n            int rhsLen = rhs[1] - rhs[0];\\n            if(lhs[0] == rhs[0])\\n                return lhsLen < rhsLen;\\n            return lhs[0] < rhs[0];\\n        });\\n        \\n        // we need to have SOME clip starting at 0\\n        if(clips[0][0] != 0)\\n            return -1;\\n        \\n        // ordered from left to right, largest to smallest\\n        int numClips = 0;\\n        int n = (int)clips.size();\\n        \\n        // marker represents the furthest point we can reach in a clip\\n        // \\n        // example:\\n        //\\n        // [0 1]\\n        // [0, 1, 2, 3]  <-- marker will become 3, now search all clips with start <= 3\\n        //          [3, 4]\\n        //          [3, 4, 5]\\n        //       [2, 3, 4, 5, 6, 7] <-- marker will become 7\\n        //\\n        //      this continues until marker is at or past T.\\n        //      \\n        \\n        int marker = 0;\\n        int i = 0;\\n        \\n        // greedy algorithm: trying to reach T as quickly as possible.\\n        \\n        while(i < n) {\\n            \\n            // determine which clip will get us out the furthest\\n            \\n            int best = -1;\\n            while(i < n && clips[i][0] <= marker) {\\n                if(clips[i][1] > best)\\n                    best = clips[i][1];\\n                i++;\\n            }\\n            \\n            marker = best;            \\n            numClips++;\\n            \\n            if(marker >= T)\\n                break;\\n            \\n            if(i >= n || best == -1)\\n                return -1;\\n        }\\n        \\n        return numClips;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281761,
                "title": "python-dp-solution-with-explanation",
                "content": "1. Sort the input clips and initialize dp list of size T+1 with each element as -1\\n2. Iterate ```i``` over clips until exhausted or dp[T+1] has a value other than -1\\n3. If ```clips[i][0]``` is 0 then to get to any point up to ```clips[i][1]``` is at most 1 step\\n4. Otherwise if ```clips[i][0]``` is -1 that means there is a gap and we cannot get to T\\n5. Finally, min steps to get to anywhere between ```clips[i][0]``` and ```clips[i][1]``` is min of min steps to get to ```dp[clips[i][0]] + 1``` or the previously seen min\\n```\\nclass Solution(object):\\n    def videoStitching(self, clips, T):\\n        \"\"\"\\n        :type clips: List[List[int]]\\n        :type T: int\\n        :rtype: int\\n        \"\"\"\\n        clips.sort()\\n    \\n        if clips[0][0] != 0:\\n            return -1\\n        if T == 0:\\n            return 1\\n    \\n        dp = [-1] * (T+1)\\n        \\n        i = 0\\n        while i < len(clips) and dp[T] == -1:\\n            start, end = clips[i][0], clips[i][1]\\n            if start == 0:\\n                for j in range(start, min(end+1, T+1)):\\n                    dp[j] = 1\\n            elif dp[start] == -1:\\n                return -1\\n            else:\\n                for j in range(start, min(end+1, T+1)):\\n                    if dp[j] == -1:\\n                        dp[j] = dp[start] + 1\\n                    else:\\n                        dp[j] = min(dp[j], dp[start] + 1)\\n            i += 1\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```i```\n```clips[i][0]```\n```clips[i][1]```\n```clips[i][0]```\n```clips[i][0]```\n```clips[i][1]```\n```dp[clips[i][0]] + 1```\n```\\nclass Solution(object):\\n    def videoStitching(self, clips, T):\\n        \"\"\"\\n        :type clips: List[List[int]]\\n        :type T: int\\n        :rtype: int\\n        \"\"\"\\n        clips.sort()\\n    \\n        if clips[0][0] != 0:\\n            return -1\\n        if T == 0:\\n            return 1\\n    \\n        dp = [-1] * (T+1)\\n        \\n        i = 0\\n        while i < len(clips) and dp[T] == -1:\\n            start, end = clips[i][0], clips[i][1]\\n            if start == 0:\\n                for j in range(start, min(end+1, T+1)):\\n                    dp[j] = 1\\n            elif dp[start] == -1:\\n                return -1\\n            else:\\n                for j in range(start, min(end+1, T+1)):\\n                    if dp[j] == -1:\\n                        dp[j] = dp[start] + 1\\n                    else:\\n                        dp[j] = min(dp[j], dp[start] + 1)\\n            i += 1\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280516,
                "title": "o-n-log-n-c-solution",
                "content": "The sorting is O(n log n). Although there are two nested while loops every element is actually touched once - and so the loops are O(n).\\n\\n```\\npublic class Solution \\n{\\n    public int VideoStitching(int[][] clips, int T) \\n    {\\n        int N = clips.GetLength(0);\\n        clips = clips.OrderBy(a => a[0]).ToArray();\\n        \\n        int s = 0, e = 0;\\n        int k = 0;\\n        int count = 0;\\n        while (k < N && e < T)\\n        {\\n            int max = e;\\n            int ns=-1, ne=-1;\\n            while(k < N && clips[k][0] <= e)\\n            {\\n                if (clips[k][1] > max)\\n                {\\n                    ns = clips[k][0];\\n                    ne = clips[k][1];\\n                    max = ne;\\n                }\\n                \\n                k++;\\n            }\\n            \\n            if (ns == -1) // could use ne == -1 as well\\n                break;\\n            \\n            s = ns;\\n            e = ne;\\n            count++;\\n        }\\n        \\n        return e>=T ? count : -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int VideoStitching(int[][] clips, int T) \\n    {\\n        int N = clips.GetLength(0);\\n        clips = clips.OrderBy(a => a[0]).ToArray();\\n        \\n        int s = 0, e = 0;\\n        int k = 0;\\n        int count = 0;\\n        while (k < N && e < T)\\n        {\\n            int max = e;\\n            int ns=-1, ne=-1;\\n            while(k < N && clips[k][0] <= e)\\n            {\\n                if (clips[k][1] > max)\\n                {\\n                    ns = clips[k][0];\\n                    ne = clips[k][1];\\n                    max = ne;\\n                }\\n                \\n                k++;\\n            }\\n            \\n            if (ns == -1) // could use ne == -1 as well\\n                break;\\n            \\n            s = ns;\\n            e = ne;\\n            count++;\\n        }\\n        \\n        return e>=T ? count : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274649,
                "title": "theoretical-explanation-o-n-log-n",
                "content": "Sort the intervals by start and end. This is important for ensuring that we cover all the gaps.\\n\\n`clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10`\\nbecomes\\n`clips = [[0,2],[1,5],[1,9],[4,6],[5,9],[8,10]]`\\n\\nDefine some assumptions\\n* We define mininum required clips as `m`. (m >= 1)\\n* The first `m-1` clips are finalized and will never be modified. \\n* The `m`th clip can be modified.\\n* The `m` clips will always form a continuous interval, where the clips overlap. If this assumption is false, the algorithm must terminate immediately.\\n* Define the finalized interval  `I1 = [0, E1]`, which covers all the start values of `m` clips using the combined intervals of the first `m - 1` clips. `(E1 >= start for each (start, end))`.   \\n* Define the entire visible interval as `I2 = [0, E2]`, which covers all the end values of the first `m` clips using the combined intervals of `m` clips `(E2 >= end for each (start, end))`. If the entire visible interval covers [0, T], we are done.\\n* E1 <= E2 because `m-1` clips will always cover less than `m` clips\\n* Initially, E1 = 0, E2 = 0, m = 1.\\n\\nWe notice a few things for a new interval [start, end]:\\n1. If start is outside `I2` (start > E2), there is a gap between E2 and end that isn\\'t covered. The algorithm should terminate and return -1 because any future clip will have a start value >= start (the list is sorted by start) and will never be able to cover the gap.\\n2. If start value is outside `I1` and within `I2` (E1 < start <= E2), we need to increment `m` by 1 because we can\\'t replce the `m`th clip and still maintain that `I2` is continuous and the clips are overlapping. If we tried to replace the `m`th clip, we would have two intervals [0,E1] and [start,end] that do not overlap (overlap requires that start <= E1, but in this case start > E1) and this is an invalid configuration.\\n3. If start is within `I1` (start <= E1), we can replace the `m`th clip with the new interval if it is able to expand `I2` (the entire visible interval). This is because `I2` is still continuous and the clips overlap.\\n4. If end >= T, `I2` covers [0, T] and we can finalize the `m`th clip because we have covered the entire interval. \\n \\nWe can try to run this algorithm manually using the example data:\\nInitially, finalized interval `I1` is [0,0], entire interval `I2` is [0,0]. \\n`clips = [[0,2],[1,5],[1,9],[4,6],[5,9],[8,10]], T = 10`.\\n1. For interval [0,2], finalized interval is [0,0], entire interval is [0,2], m = 1. (cover with [0,2])\\n2. For interval [1,5], finalized interval is [0,2], entire interval is [0,5], m = 2  (cover with [0,2],[1,5], can\\'t replace 1st clip so we add a 2nd clip)\\n3. For interval [1,9], finalized interval is [0,2], entire interval is [0,9], m = 2 (cover with [0,2],[1,9], replace 2nd clip)\\n4. For interval [4,6], finalized interval is [0,9], entire interval is [0,9], m = 3 (cover with [0,2],[1,9],[4,6], can\\'t replace 2nd clip so we add a 3rd clip)\\n5. For interval [5,9], finalized interval is [0,9], entire interval is [0,9], m = 3 (cover with [0,2],[1,9],[4,6], don\\'t replace 3rd clip because [5,9] doesn\\'t expand possibly reachable interval)\\n6. For interval [8,10], finalized interval is [0,9], entire interval is [0,10], m = 3 (cover with [0,2],[1,9],[8,10], replace 3rd clip. Terminate here and return 3 because end = 10 and end >= T)\\n\\nCode in Python:\\n```\\ne1 = 0 # finalized interval (0, e1)   \\ne2 = 0 # entire visible interval (0, e2)\\nm = 1\\nfor (start, end) in sorted(clips):\\n\\tif start > e2: # there is a gap between e2 and start\\n\\t\\tbreak\\n\\telif start > e1: # e1 < start <= e2\\n\\t\\te1 = e2  # expand finalized interval to include mth clip\\n\\t\\tm += 1 # can\\'t replace mth clip, add another clip\\n\\t\\t\\n\\te2 = max(e2, end) # expand entire visible interval\\n\\tif e2 >= T: # entire visible interval covered [0, T]\\n\\t\\treturn m\\n\\nreturn -1\\n```",
                "solutionTags": [],
                "code": "```\\ne1 = 0 # finalized interval (0, e1)   \\ne2 = 0 # entire visible interval (0, e2)\\nm = 1\\nfor (start, end) in sorted(clips):\\n\\tif start > e2: # there is a gap between e2 and start\\n\\t\\tbreak\\n\\telif start > e1: # e1 < start <= e2\\n\\t\\te1 = e2  # expand finalized interval to include mth clip\\n\\t\\tm += 1 # can\\'t replace mth clip, add another clip\\n\\t\\t\\n\\te2 = max(e2, end) # expand entire visible interval\\n\\tif e2 >= T: # entire visible interval covered [0, T]\\n\\t\\treturn m\\n\\nreturn -1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 273263,
                "title": "java-o-n-solution",
                "content": "``` \\npublic int videoStitching(int[][] clips, int T) {\\n        if(T==0) return 0;\\n        int ans = 0, max = 0, i;\\n        int[] tmp= new int[101];\\n        for(int[] clip:clips) tmp[clip[0]] = Math.max(tmp[clip[0]], clip[1]);\\n        int index = tmp[0];\\n        for(i=0; i <= index; i++){\\n            max = Math.max(tmp[i], max);\\n            if(i == index){\\n                ans++;\\n                if(index==max || i>=T) break;\\n                index = max;\\n            } \\n        }\\n        return i>=T?ans:-1;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` \\npublic int videoStitching(int[][] clips, int T) {\\n        if(T==0) return 0;\\n        int ans = 0, max = 0, i;\\n        int[] tmp= new int[101];\\n        for(int[] clip:clips) tmp[clip[0]] = Math.max(tmp[clip[0]], clip[1]);\\n        int index = tmp[0];\\n        for(i=0; i <= index; i++){\\n            max = Math.max(tmp[i], max);\\n            if(i == index){\\n                ans++;\\n                if(index==max || i>=T) break;\\n                index = max;\\n            } \\n        }\\n        return i>=T?ans:-1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 271973,
                "title": "java-o-nlogn-with-clear-explanation",
                "content": "**This problem can be thought of as follows**: Imagine clips as a buses going from a point x1 to point x2. Then the stitching task in this case translates into finding the minimum number of bus-change to reach the destination.\\n\\nSo, the greedy approach is as follows - from any point take a bus that takes you furthest. This works because we can get down at any intermediate point to catch next suitable bus. \\n- sort the buses schedules according to the start position.\\n- Create a `checkpoint` at the furthest point we can reach from `0` i.e. starting position. \\n- Next suitable bus is the one which has its `start` to the left of this checkpoint and takes us furthest\\n- create a checkpoint here and repeat the steps.\\n\\nThe code is as follows:\\n\\n```\\nclass Solution {\\n    \\n    public int videoStitching(int[][] clips, int T) {\\n        Arrays.sort(clips, new Comparator<int[]>(){\\n            // ...a...b...\\n            @Override\\n            public int compare(int[] b, int[] a){\\n                return b[0] - a[0];\\n            }\\n        });\\n        \\n        int stitches=0, reach=0, checkpoint=0, i=0, j=0;\\n        \\n\\t\\t// while the destination (T) is not reached\\n        for(i = 0; i < clips.length && checkpoint < T; stitches++ ){\\n            if(clips[i][0] <= checkpoint){\\n\\t\\t\\t\\t// how far can we reach? from left of prev checkpoint\\n                for(j=i; j < clips.length && clips[j][0] <= checkpoint; j++){\\n                    reach = clips[j][1] > reach ? clips[j][1] : reach;\\n                }\\n                checkpoint = reach;\\n                i = j;\\n            } else {\\n                // if the start is beyond the previous checkpoint, the task becomes impossible\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// return the count if the destination is reached\\n        return (checkpoint < T) ? -1 : stitches;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int videoStitching(int[][] clips, int T) {\\n        Arrays.sort(clips, new Comparator<int[]>(){\\n            // ...a...b...\\n            @Override\\n            public int compare(int[] b, int[] a){\\n                return b[0] - a[0];\\n            }\\n        });\\n        \\n        int stitches=0, reach=0, checkpoint=0, i=0, j=0;\\n        \\n\\t\\t// while the destination (T) is not reached\\n        for(i = 0; i < clips.length && checkpoint < T; stitches++ ){\\n            if(clips[i][0] <= checkpoint){\\n\\t\\t\\t\\t// how far can we reach? from left of prev checkpoint\\n                for(j=i; j < clips.length && clips[j][0] <= checkpoint; j++){\\n                    reach = clips[j][1] > reach ? clips[j][1] : reach;\\n                }\\n                checkpoint = reach;\\n                i = j;\\n            } else {\\n                // if the start is beyond the previous checkpoint, the task becomes impossible\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// return the count if the destination is reached\\n        return (checkpoint < T) ? -1 : stitches;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271296,
                "title": "java-o-nlogn-solution",
                "content": "```\\n\\n\\t1. Sort intervals based on start\\n\\t2. keep track of max and previous max, if a new interval overlaps with the previous interval, update the max. \\n\\t3. Increase the previous max and count only if new interval does not overlap with the last chosen interval. This means we are replacing the last chosen interval with the current one.\\n\\teg:: [0,5] [1,8] [1,9] T=9 \\n\\tAfter [0,5] max=5, pmax=0  \\n\\tAfter [1,8] max=8, pmax=5 \\n\\tAfter [1,9] max=9, pmax=5. Replaced [1,8] with [1,9]\\n\\n```\\n\\tpublic int videoStitching(int[][] clips, int T) {\\n\\n\\t\\tArrays.sort(clips, (a,b)->a[0]-b[0]);\\n\\t\\tint count=0;\\n\\t\\tint pmax = -1;\\n\\t\\tint max = 0;\\n\\t\\tint index=0;\\n\\t\\twhile(max<T && index<clips.length){\\n\\t\\t\\tif(clips[index][0]<=max && clips[index][1]>=max){\\n\\t\\t\\t\\tif(clips[index][0]>pmax){\\n\\t\\t\\t\\t\\t count++;\\n\\t\\t\\t\\t\\t pmax=max;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmax=clips[index][1];\\n\\t\\t\\t}\\n\\t\\t\\tindex++;\\n\\t\\t}\\n\\t\\tif(max<T) return -1;\\n\\t\\treturn count;\\n\\t}\\n```\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\t1. Sort intervals based on start\\n\\t2. keep track of max and previous max, if a new interval overlaps with the previous interval, update the max. \\n\\t3. Increase the previous max and count only if new interval does not overlap with the last chosen interval. This means we are replacing the last chosen interval with the current one.\\n\\teg:: [0,5] [1,8] [1,9] T=9 \\n\\tAfter [0,5] max=5, pmax=0  \\n\\tAfter [1,8] max=8, pmax=5 \\n\\tAfter [1,9] max=9, pmax=5. Replaced [1,8] with [1,9]\\n\\n```\n```\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270834,
                "title": "java-solution",
                "content": "**Idea**\\nAfter sorting, keep choosing clips that can push `maxEnd` as much as possible without causing gaps (i.e. the incoming clips should start before `currEnd`. `currEnd` denotes the last known `maxEnd`). \\n\\n```\\npublic int videoStitching(int[][] c, int T) {\\n        Arrays.sort(c, new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] c1, int[] c2){\\n               return c1[0]-c2[0];\\n           } \\n        });\\n        \\n        int currEnd = 0, maxEnd = 0, count = 0, i = 0;\\n        while(i < c.length){\\n            if(c[i][0] > currEnd)\\n                return -1;\\n            while(i < c.length && c[i][0] <= currEnd){\\n                maxEnd = Math.max(maxEnd, c[i][1]);\\n                i++;\\n            }\\n            ++count;\\n            currEnd = maxEnd;\\n            if(currEnd >= T)\\n                return count;\\n        }\\n        return currEnd < T ? -1 : count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int videoStitching(int[][] c, int T) {\\n        Arrays.sort(c, new Comparator<int[]>(){\\n            @Override\\n            public int compare(int[] c1, int[] c2){\\n               return c1[0]-c2[0];\\n           } \\n        });\\n        \\n        int currEnd = 0, maxEnd = 0, count = 0, i = 0;\\n        while(i < c.length){\\n            if(c[i][0] > currEnd)\\n                return -1;\\n            while(i < c.length && c[i][0] <= currEnd){\\n                maxEnd = Math.max(maxEnd, c[i][1]);\\n                i++;\\n            }\\n            ++count;\\n            currEnd = maxEnd;\\n            if(currEnd >= T)\\n                return count;\\n        }\\n        return currEnd < T ? -1 : count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270198,
                "title": "dp-c",
                "content": "\\u8FD9\\u662Fcontest130\\u7684\\u538B\\u8F74\\u9898\\u3002\\n\\u8981\\u60F3\\u5168\\u8986\\u76D6\\uFF0C\\u5219\\u80AF\\u5B9A\\u662F\\u96C6\\u5408\\u4E4B\\u95F4\\u6709\\u4EA4\\u96C6\\u3002\\n\\u56E0\\u6B64\\u6211\\u4EEC\\u5148\\u6309\\u7167\\u5934\\u6392\\u5E8F\\uFF0C\\u7136\\u540E\\u9488\\u5BF9\\u6BCF\\u4E00\\u4E2A\\u533A\\u95F4\\uFF0C\\u57FA\\u4E8E\\u5B83\\u524D\\u9762\\u7684\\u5408\\u9002\\u533A\\u95F4\\u5F97\\u5230\\u81EA\\u5DF1\\u7684\\u6700\\u4F18\\u89E3\\u3002\\n``` \\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        vector<int> dp(clips.size(),INT_MAX);\\n        auto cmp=[](vector<int> &a, vector<int> &b){\\n            return a[0]<b[0];\\n        };\\n        sort(clips.begin(),clips.end(),cmp);\\n        if(clips[0][0]!=0) return -1;\\n        for(int i=0;i<clips.size();i++){\\n            if(clips[i][0]==0) \\n                dp[i]=1;\\n        }\\n        for(int i=0;i<clips.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(dp[j]!=INT_MAX && clips[j][1]>=clips[i][0]){\\n                    dp[i]=min(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        int res=INT_MAX;\\n        for(int i=0;i<clips.size();i++){ \\n            if(clips[i][1]>=T) // \\u53EA\\u904D\\u5386\\u8FD9\\u4E9B\\u96C6\\u5408\\u6765\\u5F97\\u5230\\u5168\\u5C40\\u6700\\u4F18\\u89E3\\n                res=min(res,dp[i]);\\n        }\\n        if(res==INT_MAX) return -1;\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` \\n    int videoStitching(vector<vector<int>>& clips, int T) {\\n        vector<int> dp(clips.size(),INT_MAX);\\n        auto cmp=[](vector<int> &a, vector<int> &b){\\n            return a[0]<b[0];\\n        };\\n        sort(clips.begin(),clips.end(),cmp);\\n        if(clips[0][0]!=0) return -1;\\n        for(int i=0;i<clips.size();i++){\\n            if(clips[i][0]==0) \\n                dp[i]=1;\\n        }\\n        for(int i=0;i<clips.size();i++){\\n            for(int j=0;j<i;j++){\\n                if(dp[j]!=INT_MAX && clips[j][1]>=clips[i][0]){\\n                    dp[i]=min(dp[i],dp[j]+1);\\n                }\\n            }\\n        }\\n        int res=INT_MAX;\\n        for(int i=0;i<clips.size();i++){ \\n            if(clips[i][1]>=T) // \\u53EA\\u904D\\u5386\\u8FD9\\u4E9B\\u96C6\\u5408\\u6765\\u5F97\\u5230\\u5168\\u5C40\\u6700\\u4F18\\u89E3\\n                res=min(res,dp[i]);\\n        }\\n        if(res==INT_MAX) return -1;\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 270082,
                "title": "python-dp",
                "content": "* We can sort the videos according to their end time. So the last video\\'s start time is equal or larger than T, the last video will not be included. That is DP[i][j] = DP[i][j - 1]\\n* If the last video\\'s start time is smaller than T, We need to look at it\\'s end time. If it\\'s end time is larger than T, we will make a new time clips[i - 1][1] (endtime) as new T if we include the last video. Otherwise we just ignore the last video. That is DP[i][j] = min(DP[i - 1][j], DP[i - 1][clips[i - 1][1]] + 1)\\n*  If the last video\\'s end time is smaller than T, there is no way we can get the time span [0, T] covered, since the clips are sorted by their ending times. So DP[i][j] = inf\\n\\nBelow is the code implementation\\n\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        \\'\\'\\'\\n        DP[i][T] = DP[i - 1][T] if T <= clips[i - 1][0]\\n        else\\n        DP[i][T] = DP[i - 1][clips[i - 1][0]] + 1 or DP[i - 1][T] whichever is smaller\\n        \\n        \\'\\'\\'\\n        clips = sorted(clips, key = lambda x:x[::-1])\\n        n = len(clips)\\n        inf = float(\\'inf\\')\\n        DP = [[inf for j in range(T + 1)] for i in range(n + 1)]\\n        \\n        DP[0][0] = 0\\n        \\n        for i in range(1, n + 1):\\n            DP[i][0] = 0\\n        for j in range(1, T + 1):\\n            DP[0][j] = inf\\n            \\n        for i in range(1, n + 1):\\n            for j in range(1, T + 1):\\n                if clips[i - 1][0] >= j:\\n                    DP[i][j] = DP[i - 1][j]\\n                else:\\n                    if j <= clips[i - 1][1]: #now only need to cover to clips[i - 1][0] if clips[i] is included\\n                        DP[i][j] = min(DP[i - 1][clips[i - 1][0]] + 1, DP[i - 1][j])\\n                    else: #\\n                        DP[i][j] = inf\\n        return DP[n][T] if DP[n][T] < inf else -1\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], T: int) -> int:\\n        \\'\\'\\'\\n        DP[i][T] = DP[i - 1][T] if T <= clips[i - 1][0]\\n        else\\n        DP[i][T] = DP[i - 1][clips[i - 1][0]] + 1 or DP[i - 1][T] whichever is smaller\\n        \\n        \\'\\'\\'\\n        clips = sorted(clips, key = lambda x:x[::-1])\\n        n = len(clips)\\n        inf = float(\\'inf\\')\\n        DP = [[inf for j in range(T + 1)] for i in range(n + 1)]\\n        \\n        DP[0][0] = 0\\n        \\n        for i in range(1, n + 1):\\n            DP[i][0] = 0\\n        for j in range(1, T + 1):\\n            DP[0][j] = inf\\n            \\n        for i in range(1, n + 1):\\n            for j in range(1, T + 1):\\n                if clips[i - 1][0] >= j:\\n                    DP[i][j] = DP[i - 1][j]\\n                else:\\n                    if j <= clips[i - 1][1]: #now only need to cover to clips[i - 1][0] if clips[i] is included\\n                        DP[i][j] = min(DP[i - 1][clips[i - 1][0]] + 1, DP[i - 1][j])\\n                    else: #\\n                        DP[i][j] = inf\\n        return DP[n][T] if DP[n][T] < inf else -1\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 270032,
                "title": "java-o-n-t-solution-same-to-jump-game-ii",
                "content": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T + 1];\\n        for (int[] clip: clips) {\\n            if (clip[0] < T + 1)\\n                dp[clip[0]] = Math.max(dp[clip[0]], Math.min(clip[1], T));\\n        }\\n        int jump = 0;\\n        int nextmax = 0;\\n        int curmax = dp[0];\\n        for (int i = 0; i < T + 1; i++) {\\n            nextmax = Math.max(nextmax, dp[i]);\\n            if (i == curmax || i == T) {\\n                \\n                jump++;\\n                if (nextmax == i) {\\n                    return i == T ? jump : -1;\\n                }\\n                curmax = nextmax;\\n            }\\n        }\\n        return jump;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int T) {\\n        int[] dp = new int[T + 1];\\n        for (int[] clip: clips) {\\n            if (clip[0] < T + 1)\\n                dp[clip[0]] = Math.max(dp[clip[0]], Math.min(clip[1], T));\\n        }\\n        int jump = 0;\\n        int nextmax = 0;\\n        int curmax = dp[0];\\n        for (int i = 0; i < T + 1; i++) {\\n            nextmax = Math.max(nextmax, dp[i]);\\n            if (i == curmax || i == T) {\\n                \\n                jump++;\\n                if (nextmax == i) {\\n                    return i == T ? jump : -1;\\n                }\\n                curmax = nextmax;\\n            }\\n        }\\n        return jump;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 269990,
                "title": "greedy-approach-o-n-log-n",
                "content": "This problem is similar to  <a href=\"https://www.geeksforgeeks.org/activity-selection-problem-greedy-algo-1/\"> Activity selection problem </a>\\n\\nThe idea consists in choose the maximum end interval given a start of video.\\n* For example:  If I\\'m at minute <code>5</code> of the video and I have the following intervals <code>[3-6], [7-10], [4-9] </code>. I will choose <code>[4-9]</code> because that contains number <code>5</code> and have the maximum end of video. (<code> [7-10] </code> not contains the minute <code>5</code>). \\n* Then you will update the start time, and repeat the proccess until you get a <code>start time >=T</code>\\n\\n\\n**C++**\\n<code>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint videoStitching(vector<vector<int>>& clips, int T) {\\n\\t\\t\\tint start=0;\\n\\t\\t\\tint count=0;\\n\\t\\t\\t\\n\\t\\t\\twhile(true){\\n\\t\\t\\t\\tint maxend =-1;\\n\\t\\t\\t\\tfor(int i=0;i<clips.size();i++){\\n\\t\\t\\t\\t\\tint end= clips[i][1];\\n\\t\\t\\t\\t\\tif(end>maxend &&  clips[i][0]<=start && end>start){\\n\\t\\t\\t\\t\\t\\tmaxend=end;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tstart=maxend;\\n\\t\\t\\t\\tif(start>=T)return count; //goal\\n\\t\\t\\t\\tif(start==-1)return -1; // its not possible improve start time\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};\\t\\n</code>\\n\\n<b>Complexity time </b>\\n* O(n^2) where n is the lengh of clips\\n\\nIt\\'s possible improve the solution in O(n*log(n)) if you sort the array by the start of video. Then find in constant time (two pointers) given a start time <code>(S)</code>, an interval with maximum end where their start is greater or equal than <code>S</code>\\n\\n<code>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint videoStitching(vector<vector<int>>& clips, int T) {\\n\\t\\t\\tvector<pair<int,int> >v;\\t\\n\\t\\t\\tfor(int i=0;i<clips.size();i++)\\n\\t\\t\\t\\tv.push_back(make_pair(clips[i][0],clips[i][1]));\\n\\t\\t\\tsort(v.begin(),v.end());\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tint start=0;           \\n\\t\\t\\tint count=0;\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<v.size(); ){\\n\\t\\t\\t\\tif(v[i].first>start)return -1;// there are no video that contains start\\n\\t\\t\\t\\tint maxend=-1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\twhile(i<v.size()  && v[i].first<=start){\\n\\t\\t\\t\\t\\tmaxend=max(maxend,v[i].second);\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\tif(maxend>=T)return count;\\n\\t\\t\\t\\tif(maxend<=start)return -1;//no increase start\\n\\t\\t\\t\\tstart=maxend;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};\\t\\n</code>\\n\\n<b>Complexity time </b>\\n* O(nlog(n)) where n is the lengh of clips",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint videoStitching(vector<vector<int>>& clips, int T) {\\n\\t\\t\\tint start=0;\\n\\t\\t\\tint count=0;\\n\\t\\t\\t\\n\\t\\t\\twhile(true){\\n\\t\\t\\t\\tint maxend =-1;\\n\\t\\t\\t\\tfor(int i=0;i<clips.size();i++){\\n\\t\\t\\t\\t\\tint end= clips[i][1];\\n\\t\\t\\t\\t\\tif(end>maxend &&  clips[i][0]<=start && end>start){\\n\\t\\t\\t\\t\\t\\tmaxend=end;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4102040,
                "title": "c-implementation-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing similar approach to merging intervals\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWithout using DP, we can actually take the maximum possible length we can receive (provided the mini and maxi (initialised with 0)).\\n# Complexity\\n- Time complexity: O(n*n) worst case but n <- (1,100) so feasible\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int count = 0;\\n        int mini=0;\\n        int maxi=0;\\n        while(maxi<time){\\n            for(int i=0;i<clips.size();i++){\\n                int start=clips[i][0];\\n                int end=clips[i][1];\\n                if(start<=mini && end>=maxi){\\n                    maxi=end;\\n                }\\n            }\\n            if(mini==maxi) return -1;\\n            mini=maxi;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int count = 0;\\n        int mini=0;\\n        int maxi=0;\\n        while(maxi<time){\\n            for(int i=0;i<clips.size();i++){\\n                int start=clips[i][0];\\n                int end=clips[i][1];\\n                if(start<=mini && end>=maxi){\\n                    maxi=end;\\n                }\\n            }\\n            if(mini==maxi) return -1;\\n            mini=maxi;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086427,
                "title": "ruby-solution-with-sorting-explained-100-67",
                "content": "# Intuition\\nSort the clips, then iterated through them.  Add a new clip whenever necessary, and return -1 if there\\'s a missing gap.  Return the number of clips once you get to time.\\n\\n# Approach\\n1. Sort the clips.\\n2. Initialize curr_end (the ending time of the last clip), total (number of clips used), and i at 0.\\n3. Iterate through the rest of the clips.\\n    - If the next clip doesn\\'t intersect with curr_end, it\\'s impossible to cover the full interval, so return -1.\\n    - Otherwise, look through all clips that could be merged with the current one and choose the one with the latest ending time.  (Since the clips are sorted, you can increment i and won\\'t need to check those clips again.)  Add 1 to total.\\n4. At the end, return the total number of clips you\\'ve used if you cover the full interval, -1 otherwise.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\ndef video_stitching(clips, time)\\n    clips.sort!\\n    curr_end = 0\\n    total = 0\\n    i = 0\\n\\n    until i == clips.length || curr_end >= time\\n        return -1 if clips[i][0] > curr_end\\n        max = clips[0][1]\\n\\n        if i != clips.length && clips[i][0] <= curr_end\\n            until i == clips.length || clips[i][0] > curr_end\\n                max = clips[i][1] if clips[i][1] > max\\n                i += 1\\n            end\\n        else\\n            i += 1\\n        end\\n        \\n        total += 1\\n        curr_end = max\\n    end\\n\\n    curr_end >= time ? total : -1\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef video_stitching(clips, time)\\n    clips.sort!\\n    curr_end = 0\\n    total = 0\\n    i = 0\\n\\n    until i == clips.length || curr_end >= time\\n        return -1 if clips[i][0] > curr_end\\n        max = clips[0][1]\\n\\n        if i != clips.length && clips[i][0] <= curr_end\\n            until i == clips.length || clips[i][0] > curr_end\\n                max = clips[i][1] if clips[i][1] > max\\n                i += 1\\n            end\\n        else\\n            i += 1\\n        end\\n        \\n        total += 1\\n        curr_end = max\\n    end\\n\\n    curr_end >= time ? total : -1\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4002006,
                "title": "python3-dfs-memoization",
                "content": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n\\n        # sort clips by start time\\n        clips.sort(key=lambda x : x[0])\\n\\n        # if we don\\'t have a clip starting at time 0, the problem is impossible\\n        if clips[0][0] != 0:\\n            return -1\\n\\n        # memoization\\n        cache = {} # clip index : min number of steps it takes to get to the end\\n\\n        # dfs portion\\n        def dfs(clip_index):\\n\\n            # avoid repeated work\\n            if clip_index in cache:\\n                return cache[clip_index]\\n            \\n            # base case, we found a clip that reaches the end\\n            if clips[clip_index][1] >= time:\\n                cache[clip_index] = 1\\n                return 1\\n            \\n            # dfs future clips\\n            res = float(\\'inf\\')\\n            for i in range(clip_index + 1, len(clips)):\\n\\n                curr_clip = clips[clip_index]\\n                next_clip = clips[i]\\n\\n                # ensure that we are actually going forward and that the end of the current clip and the start of the next clip are connected\\n                if next_clip[0] > curr_clip[0] and next_clip[0] <= curr_clip[1] and next_clip[1] > curr_clip[1]:\\n                    res = min(res, 1 + dfs(i))\\n\\n            cache[clip_index] = res\\n            return res\\n        \\n        # find the best clip to start with -> [0, greatest end time]\\n        start_index = 0\\n        for i in range(1, len(clips)):\\n            if clips[i][0] != 0:\\n                break\\n            if clips[i][1] > clips[start_index][1]:\\n                start_index = i\\n        \\n        # call dfs\\n        res = dfs(start_index)\\n        if res == float(\\'inf\\'):\\n            return -1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n\\n        # sort clips by start time\\n        clips.sort(key=lambda x : x[0])\\n\\n        # if we don\\'t have a clip starting at time 0, the problem is impossible\\n        if clips[0][0] != 0:\\n            return -1\\n\\n        # memoization\\n        cache = {} # clip index : min number of steps it takes to get to the end\\n\\n        # dfs portion\\n        def dfs(clip_index):\\n\\n            # avoid repeated work\\n            if clip_index in cache:\\n                return cache[clip_index]\\n            \\n            # base case, we found a clip that reaches the end\\n            if clips[clip_index][1] >= time:\\n                cache[clip_index] = 1\\n                return 1\\n            \\n            # dfs future clips\\n            res = float(\\'inf\\')\\n            for i in range(clip_index + 1, len(clips)):\\n\\n                curr_clip = clips[clip_index]\\n                next_clip = clips[i]\\n\\n                # ensure that we are actually going forward and that the end of the current clip and the start of the next clip are connected\\n                if next_clip[0] > curr_clip[0] and next_clip[0] <= curr_clip[1] and next_clip[1] > curr_clip[1]:\\n                    res = min(res, 1 + dfs(i))\\n\\n            cache[clip_index] = res\\n            return res\\n        \\n        # find the best clip to start with -> [0, greatest end time]\\n        start_index = 0\\n        for i in range(1, len(clips)):\\n            if clips[i][0] != 0:\\n                break\\n            if clips[i][1] > clips[start_index][1]:\\n                start_index = i\\n        \\n        # call dfs\\n        res = dfs(start_index)\\n        if res == float(\\'inf\\'):\\n            return -1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989957,
                "title": "java-greedy-o-n-time-complexity-0ms-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int[] dp = new int[time+1];\\n\\n        for(int i=0; i<clips.length; i++) {\\n            int left = clips[i][0];\\n            int right = clips[i][1];\\n\\n            if(left > time) left = time;\\n            if(right > time) right = time;\\n\\n            if(right > dp[left]) dp[left] = right;\\n        }\\n        \\n        int max = -1;\\n        int pos = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<=time; i++) {\\n            if(i > pos) return -1;\\n\\n            max = Math.max(max, dp[i]);\\n\\n            if(i == pos) {\\n                count++;\\n                pos = max;\\n            }\\n\\n            if(pos >= time) break;\\n        }\\n\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int[] dp = new int[time+1];\\n\\n        for(int i=0; i<clips.length; i++) {\\n            int left = clips[i][0];\\n            int right = clips[i][1];\\n\\n            if(left > time) left = time;\\n            if(right > time) right = time;\\n\\n            if(right > dp[left]) dp[left] = right;\\n        }\\n        \\n        int max = -1;\\n        int pos = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<=time; i++) {\\n            if(i > pos) return -1;\\n\\n            max = Math.max(max, dp[i]);\\n\\n            if(i == pos) {\\n                count++;\\n                pos = max;\\n            }\\n\\n            if(pos >= time) break;\\n        }\\n\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989910,
                "title": "dp-with-memoization-to-return-the-paths-as-well-not-just-min-values",
                "content": "# Intuition\\nMost of the programs just use track the min number. In most real world problems we need the actual clips as well.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        clips.sort(key = lambda x: x[0])\\n        cache = {}\\n        rv = float(\\'inf\\')\\n        for i in range(len(clips)):\\n            if clips[i][0] == 0:\\n                x = self.stitch(clips, time, i, cache)\\n                if len(x) > 0:\\n                    rv = min(rv, len(x))\\n            else:\\n                break \\n        return rv if rv < float(\\'inf\\') else -1\\n    \\n    def stitch(self, clips, target, index, cache):\\n        if index in cache:\\n            return cache[index]\\n        current = clips[index]\\n        if current[0] <= target <= current[1]:\\n            return [current]\\n        glb_min = []\\n        for nxti in range(index+1, len(clips)):\\n            nxt = clips[nxti]\\n            if nxt[0] > current[1]:\\n                #If the next index beginning is greater than current end:\\n                break\\n            elif current[0] <= nxt[0] <= current[1] and nxt[1] > current[1]:\\n                # If there is beginning intercept and next end > current end\\n                valr = self.stitch(clips, target, nxti, cache)\\n                val = [i for i in valr]\\n                if len(val) > 0:\\n                    val.append(current)\\n                if len(val) > 0:\\n                    if len(glb_min) == 0:\\n                        glb_min = val\\n                    else:\\n                        glb_min = val if len(val) < len(glb_min) else glb_min\\n        cache[index] = glb_min\\n        return glb_min\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n        clips.sort(key = lambda x: x[0])\\n        cache = {}\\n        rv = float(\\'inf\\')\\n        for i in range(len(clips)):\\n            if clips[i][0] == 0:\\n                x = self.stitch(clips, time, i, cache)\\n                if len(x) > 0:\\n                    rv = min(rv, len(x))\\n            else:\\n                break \\n        return rv if rv < float(\\'inf\\') else -1\\n    \\n    def stitch(self, clips, target, index, cache):\\n        if index in cache:\\n            return cache[index]\\n        current = clips[index]\\n        if current[0] <= target <= current[1]:\\n            return [current]\\n        glb_min = []\\n        for nxti in range(index+1, len(clips)):\\n            nxt = clips[nxti]\\n            if nxt[0] > current[1]:\\n                #If the next index beginning is greater than current end:\\n                break\\n            elif current[0] <= nxt[0] <= current[1] and nxt[1] > current[1]:\\n                # If there is beginning intercept and next end > current end\\n                valr = self.stitch(clips, target, nxti, cache)\\n                val = [i for i in valr]\\n                if len(val) > 0:\\n                    val.append(current)\\n                if len(val) > 0:\\n                    if len(glb_min) == 0:\\n                        glb_min = val\\n                    else:\\n                        glb_min = val if len(val) < len(glb_min) else glb_min\\n        cache[index] = glb_min\\n        return glb_min\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989601,
                "title": "greedy-soln-0ms",
                "content": "```\\nclass Pair implements Comparable<Pair>{\\n    int s,e;\\n    Pair(int s,int e){\\n        this.s=s;this.e=e;\\n    }\\n    @Override\\n    public int compareTo(Pair that){\\n        return this.s-that.s;\\n    }\\n}\\nclass Solution {\\n    public int videoStitching(int[][] ar, int time) {\\n        int n=ar.length;\\n        List<Pair>li=new ArrayList<>();\\n        for(int i=0;i<ar.length;i++){\\n            li.add(new Pair(ar[i][0],ar[i][1]));\\n        }\\n        Collections.sort(li);\\n        if(li.get(0).s!=0)return -1;\\n        int i=0;\\n        int prev=li.get(i).e;\\n                while(i<n && li.get(i).s==0){\\n                    prev=Math.max(prev,li.get(i).e);\\n                    i++;\\n                }\\n        int ans=1;\\n        if(prev>=time)return ans;\\n        while(i<n){\\n            int j=i;\\n            if(li.get(j).s<=prev){\\n                int max=li.get(i).e;\\n                while(j<n && li.get(j).s<=prev){\\n                    max=Math.max(max,li.get(j).e);\\n                    j++;\\n                }\\n                ans++;\\n                prev=max;\\n                if(max>=time)return ans;\\n            }\\n            if(i!=j)i=j;\\n            else return -1;\\n        }\\n        if(prev<time)return -1;\\n        return ans;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Pair implements Comparable<Pair>{\\n    int s,e;\\n    Pair(int s,int e){\\n        this.s=s;this.e=e;\\n    }\\n    @Override\\n    public int compareTo(Pair that){\\n        return this.s-that.s;\\n    }\\n}\\nclass Solution {\\n    public int videoStitching(int[][] ar, int time) {\\n        int n=ar.length;\\n        List<Pair>li=new ArrayList<>();\\n        for(int i=0;i<ar.length;i++){\\n            li.add(new Pair(ar[i][0],ar[i][1]));\\n        }\\n        Collections.sort(li);\\n        if(li.get(0).s!=0)return -1;\\n        int i=0;\\n        int prev=li.get(i).e;\\n                while(i<n && li.get(i).s==0){\\n                    prev=Math.max(prev,li.get(i).e);\\n                    i++;\\n                }\\n        int ans=1;\\n        if(prev>=time)return ans;\\n        while(i<n){\\n            int j=i;\\n            if(li.get(j).s<=prev){\\n                int max=li.get(i).e;\\n                while(j<n && li.get(j).s<=prev){\\n                    max=Math.max(max,li.get(j).e);\\n                    j++;\\n                }\\n                ans++;\\n                prev=max;\\n                if(max>=time)return ans;\\n            }\\n            if(i!=j)i=j;\\n            else return -1;\\n        }\\n        if(prev<time)return -1;\\n        return ans;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 3985573,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) \\n    {\\n        int currend,nextend,ans;\\n        currend=0;\\n        nextend=0;\\n        ans=0;\\n\\n        vector<int> v(101);\\n\\n        for(int i=0;i<clips.size();i++)\\n        {\\n            v[clips[i][0]]=max(v[clips[i][0]],clips[i][1]);\\n        }\\n\\n        //for(int i=0;i<time+1;i++)\\n        //{\\n        //    cout<<v[i]<<\" \";\\n        //}\\n\\n        for(int i=0;i<=time;i++)\\n        {\\n            if(i>nextend)\\n            {\\n                return -1;\\n            }\\n\\n            if(i>currend)\\n            {\\n                ans++;\\n                currend=nextend;\\n            }\\n\\n            nextend=max(nextend,v[i]);\\n        }\\n\\n        return ans;    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) \\n    {\\n        int currend,nextend,ans;\\n        currend=0;\\n        nextend=0;\\n        ans=0;\\n\\n        vector<int> v(101);\\n\\n        for(int i=0;i<clips.size();i++)\\n        {\\n            v[clips[i][0]]=max(v[clips[i][0]],clips[i][1]);\\n        }\\n\\n        //for(int i=0;i<time+1;i++)\\n        //{\\n        //    cout<<v[i]<<\" \";\\n        //}\\n\\n        for(int i=0;i<=time;i++)\\n        {\\n            if(i>nextend)\\n            {\\n                return -1;\\n            }\\n\\n            if(i>currend)\\n            {\\n                ans++;\\n                currend=nextend;\\n            }\\n\\n            nextend=max(nextend,v[i]);\\n        }\\n\\n        return ans;    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3985472,
                "title": "easy-c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        \\n        //DP[I]  min clips to make time of i value film\\n        vector<int> maxi(105,-1);\\n        sort(clips.begin(),clips.end());\\n        for(auto i:clips)\\n        {\\n            int l=i[0];\\n            int r=i[1];\\n            for(int i=l;i<=r;i++)\\n            {\\n                maxi[i]=max(maxi[i],r);\\n            }\\n        }\\n        int cnt=0;\\n        int t=0;\\n        while(t<time)\\n        {\\n            int nexT=maxi[t];\\n            if(nexT==-1 || nexT==t)\\n                return -1;\\n            t=nexT;\\n            cnt++;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        \\n        //DP[I]  min clips to make time of i value film\\n        vector<int> maxi(105,-1);\\n        sort(clips.begin(),clips.end());\\n        for(auto i:clips)\\n        {\\n            int l=i[0];\\n            int r=i[1];\\n            for(int i=l;i<=r;i++)\\n            {\\n                maxi[i]=max(maxi[i],r);\\n            }\\n        }\\n        int cnt=0;\\n        int t=0;\\n        while(t<time)\\n        {\\n            int nexT=maxi[t];\\n            if(nexT==-1 || nexT==t)\\n                return -1;\\n            t=nexT;\\n            cnt++;\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984319,
                "title": "c-dp-take-nottake",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int idx,int en,vector<vector<int>>& clips,int time)\\n    {\\n        if(idx>=clips.size())\\n        {\\n            if(en>=time)\\n            return 0;\\n            return INT_MAX-1;\\n        }\\n        if(dp[idx][en]!=-1)\\n        return dp[idx][en];\\n        int tak = INT_MAX;\\n        if(clips[idx][0]<=en && clips[idx][1]>=en)\\n        {\\n            tak = 1+solve(idx+1,max(en,clips[idx][1]),clips,time);\\n        }\\n        int notTak = solve(idx+1,en,clips,time);\\n        return dp[idx][en] = min(tak,notTak);\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(clips.begin(),clips.end());\\n        int ans = solve(0,0,clips,time);\\n        return ans==INT_MAX-1?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(int idx,int en,vector<vector<int>>& clips,int time)\\n    {\\n        if(idx>=clips.size())\\n        {\\n            if(en>=time)\\n            return 0;\\n            return INT_MAX-1;\\n        }\\n        if(dp[idx][en]!=-1)\\n        return dp[idx][en];\\n        int tak = INT_MAX;\\n        if(clips[idx][0]<=en && clips[idx][1]>=en)\\n        {\\n            tak = 1+solve(idx+1,max(en,clips[idx][1]),clips,time);\\n        }\\n        int notTak = solve(idx+1,en,clips,time);\\n        return dp[idx][en] = min(tak,notTak);\\n    }\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        memset(dp,-1,sizeof(dp));\\n        sort(clips.begin(),clips.end());\\n        int ans = solve(0,0,clips,time);\\n        return ans==INT_MAX-1?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984043,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nint cmp(const void*a,const void*b){\\n    int *aa=*(int**)a;\\n    int *bb=*(int**)b;\\n    \\n    if(aa[0]==bb[0]) return aa[1]-bb[1];\\n    return aa[0]-bb[0];\\n}\\nint videoStitching(int** clips, int clipsSize, int* clipsColSize, int time){\\n    qsort(clips,clipsSize,sizeof(int*),cmp);\\n    if(clips[0][0]!=0) return -1;\\n    \\n    int idx=-1;\\n    for(int i=0;i<clipsSize;i++) printf(\"%d %d\\\\n\",clips[i][0],clips[i][1]);\\n    printf(\"---------\\\\n\");\\n    for(int i=0;i<clipsSize;i++){\\n        if(idx!=-1) printf(\"%d %d\\\\n\",clips[idx][0],clips[idx][1]);\\n        int left=clips[i][0],right=clips[i][1];\\n        if(idx!=-1 && clips[idx][1] >=time) return idx+1;\\n        if(idx!=-1 && left>clips[idx][1]) return -1;\\n        if(idx==-1){\\n            idx++;\\n            clips[idx][0]=clips[i][0];\\n            clips[idx][1]=clips[i][1];\\n        }else if(left==clips[idx][0] && right>=clips[idx][1]){\\n            clips[idx][1]=right;\\n            continue;\\n        }else if(left>=clips[idx][0] && right<=clips[idx][1]){\\n            continue;\\n        }else if(left<clips[idx][0]&&right>clips[idx][1]){\\n            while(idx!=-1 && left<clips[idx][0]&&right>clips[idx][1]){\\n                idx--;\\n            }\\n            left=fmax(clips[idx][1],clips[i][0]);\\n            clips[++idx][0]=left;\\n            clips[idx][1]=right;\\n        }\\n        else if(left<=clips[idx][1] && right>clips[idx][1]){\\n            left=fmax(clips[idx][1],clips[i][0]);\\n            clips[++idx][0]=left;\\n            clips[idx][1]=right;\\n        }\\n    \\n    }\\n    if(clips[idx][1]<time) return -1;\\n    return  idx+1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint cmp(const void*a,const void*b){\\n    int *aa=*(int**)a;\\n    int *bb=*(int**)b;\\n    \\n    if(aa[0]==bb[0]) return aa[1]-bb[1];\\n    return aa[0]-bb[0];\\n}\\nint videoStitching(int** clips, int clipsSize, int* clipsColSize, int time){\\n    qsort(clips,clipsSize,sizeof(int*),cmp);\\n    if(clips[0][0]!=0) return -1;\\n    \\n    int idx=-1;\\n    for(int i=0;i<clipsSize;i++) printf(\"%d %d\\\\n\",clips[i][0],clips[i][1]);\\n    printf(\"---------\\\\n\");\\n    for(int i=0;i<clipsSize;i++){\\n        if(idx!=-1) printf(\"%d %d\\\\n\",clips[idx][0],clips[idx][1]);\\n        int left=clips[i][0],right=clips[i][1];\\n        if(idx!=-1 && clips[idx][1] >=time) return idx+1;\\n        if(idx!=-1 && left>clips[idx][1]) return -1;\\n        if(idx==-1){\\n            idx++;\\n            clips[idx][0]=clips[i][0];\\n            clips[idx][1]=clips[i][1];\\n        }else if(left==clips[idx][0] && right>=clips[idx][1]){\\n            clips[idx][1]=right;\\n            continue;\\n        }else if(left>=clips[idx][0] && right<=clips[idx][1]){\\n            continue;\\n        }else if(left<clips[idx][0]&&right>clips[idx][1]){\\n            while(idx!=-1 && left<clips[idx][0]&&right>clips[idx][1]){\\n                idx--;\\n            }\\n            left=fmax(clips[idx][1],clips[i][0]);\\n            clips[++idx][0]=left;\\n            clips[idx][1]=right;\\n        }\\n        else if(left<=clips[idx][1] && right>clips[idx][1]){\\n            left=fmax(clips[idx][1],clips[i][0]);\\n            clips[++idx][0]=left;\\n            clips[idx][1]=right;\\n        }\\n    \\n    }\\n    if(clips[idx][1]<time) return -1;\\n    return  idx+1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983941,
                "title": "greedy-beats-100-no-sorting",
                "content": "# Intuition\\nThis is a similar problem to Jump Game 2. At each point store the maximum value we can go to and then you can copy paste the template for finding the minimum count.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        vector<int> start(101,0);\\n        for(auto clip:clips){\\n            int a=clip[0];\\n            int b=clip[1];\\n            start[a]=max(start[a],b);\\n        }\\n        \\n        int end = 0, farCanReach = 0, cnt = 0;\\n        \\n        for (int i = 0;end < time; end = farCanReach) {\\n            cnt++;\\n            \\n            while (i < start.size() && i <= end) {\\n                farCanReach = max(farCanReach, start[i++]);\\n            }\\n            \\n            if (end == farCanReach) return -1; // if the farCanReach isn\\'t updated then we cannot move further from it and never got to end\\n        }\\n        \\n        return cnt;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        vector<int> start(101,0);\\n        for(auto clip:clips){\\n            int a=clip[0];\\n            int b=clip[1];\\n            start[a]=max(start[a],b);\\n        }\\n        \\n        int end = 0, farCanReach = 0, cnt = 0;\\n        \\n        for (int i = 0;end < time; end = farCanReach) {\\n            cnt++;\\n            \\n            while (i < start.size() && i <= end) {\\n                farCanReach = max(farCanReach, start[i++]);\\n            }\\n            \\n            if (end == farCanReach) return -1; // if the farCanReach isn\\'t updated then we cannot move further from it and never got to end\\n        }\\n        \\n        return cnt;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954064,
                "title": "c-easy-clean-code-dp",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int tt(int i,vector<vector<int>> &c,int t,vector<int> &dp,int p)\\n    {\\n       if(i>=c.size()) return INT_MAX;\\n       if(c[i][1]>=t) return 1;\\n       if(dp[i]!=-1) return dp[i];\\n\\n       int s=INT_MAX;\\n       for(int j=i+1;j<c.size();j++)\\n       if(c[j][0]<=p)\\n       s=min(s,tt(j,c,t,dp,c[j][1]));\\n\\n       if(s!=INT_MAX)\\n       return dp[i]=s+1;\\n       return dp[i]=s;\\n    }\\n    int videoStitching(vector<vector<int>>& c, int t) {\\n        sort(c.begin(),c.end());\\n        int n=c.size(),ans=INT_MAX;\\n        vector<int> dp(n+1,-1);\\n        \\n        for(int i=0;i<n;i++)\\n         if(c[i][0]==0)\\n         ans=min(ans,tt(i,c,t,dp,c[i][1]));\\n\\n        return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n```\\n![cat.png](https://assets.leetcode.com/users/images/35cf7558-fbac-4042-a81d-39cfdfe578e5_1692876425.0175996.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tt(int i,vector<vector<int>> &c,int t,vector<int> &dp,int p)\\n    {\\n       if(i>=c.size()) return INT_MAX;\\n       if(c[i][1]>=t) return 1;\\n       if(dp[i]!=-1) return dp[i];\\n\\n       int s=INT_MAX;\\n       for(int j=i+1;j<c.size();j++)\\n       if(c[j][0]<=p)\\n       s=min(s,tt(j,c,t,dp,c[j][1]));\\n\\n       if(s!=INT_MAX)\\n       return dp[i]=s+1;\\n       return dp[i]=s;\\n    }\\n    int videoStitching(vector<vector<int>>& c, int t) {\\n        sort(c.begin(),c.end());\\n        int n=c.size(),ans=INT_MAX;\\n        vector<int> dp(n+1,-1);\\n        \\n        for(int i=0;i<n;i++)\\n         if(c[i][0]==0)\\n         ans=min(ans,tt(i,c,t,dp,c[i][1]));\\n\\n        return ans==INT_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948907,
                "title": "java-100-no-dp-simple-greedy-approach-tc-o-n",
                "content": "# Intuition\\nSo the intuition is from a time what maxTime I can cover directly without any new Interval. Now if I want to increase MaxReach Time. I have to search from current time to maxReact Time, where can I go directly in one go and so on untill we reach maxReach becomes time.\\n\\n# Approach\\nJust dry run it you will understand\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int[] end = new int[time + 1];\\n        for(int i = 0; i < clips.length; i++){\\n            int left = clips[i][0];\\n            if(left > time){\\n                continue;\\n            }\\n            int right = Math.min(time, clips[i][1]);\\n            int maxRight = Math.max(right, end[left]);\\n            end[left] = maxRight;\\n        }\\n\\n        int maxReach = end[0];\\n        int cnt = 1;\\n        int st = 0;\\n        while(maxReach < time){\\n            if(st > maxReach){\\n                cnt = -1;\\n                break;\\n            }\\n            cnt++; int newReach = st;\\n            while(st <= maxReach){\\n                newReach = Math.max(newReach, end[st]);\\n                st++;\\n            }\\n            maxReach = newReach;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int[] end = new int[time + 1];\\n        for(int i = 0; i < clips.length; i++){\\n            int left = clips[i][0];\\n            if(left > time){\\n                continue;\\n            }\\n            int right = Math.min(time, clips[i][1]);\\n            int maxRight = Math.max(right, end[left]);\\n            end[left] = maxRight;\\n        }\\n\\n        int maxReach = end[0];\\n        int cnt = 1;\\n        int st = 0;\\n        while(maxReach < time){\\n            if(st > maxReach){\\n                cnt = -1;\\n                break;\\n            }\\n            cnt++; int newReach = st;\\n            while(st <= maxReach){\\n                newReach = Math.max(newReach, end[st]);\\n                st++;\\n            }\\n            maxReach = newReach;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873668,
                "title": "dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n      n,i = len(clips),1\\n      clips.sort(key = lambda x : (x[0] , -x[1])) \\n      ans = [clips[0]]\\n      # pruning the original array \\n      while i < n:\\n        if clips[i][0] != ans[-1][0] : \\n          ans.append(clips[i]) \\n        while i < n and (clips[i][0] == ans[-1][0] or clips[i][1] <= ans[-1][1] ): i += 1 \\n      dp = [-1 for _ in range(len(ans) + 1)]\\n      def f(i):\\n        if i < n and ans[i][1] >= time : return 1 \\n        if dp[i] != -1 : return dp[i]\\n        best = 123456 \\n        for j in range(i+1,len(ans)):\\n          x = ans[i][1] \\n          if x < ans[j][1] and x >= ans[j][0] : \\n            best = min(best , 1 + f(j)) \\n        dp[i] = best \\n        return best \\n      value = f(0)\\n      print(ans)\\n      if value == 123456 or ans[0][0] != 0 : return -1 \\n      return value\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def videoStitching(self, clips: List[List[int]], time: int) -> int:\\n      n,i = len(clips),1\\n      clips.sort(key = lambda x : (x[0] , -x[1])) \\n      ans = [clips[0]]\\n      # pruning the original array \\n      while i < n:\\n        if clips[i][0] != ans[-1][0] : \\n          ans.append(clips[i]) \\n        while i < n and (clips[i][0] == ans[-1][0] or clips[i][1] <= ans[-1][1] ): i += 1 \\n      dp = [-1 for _ in range(len(ans) + 1)]\\n      def f(i):\\n        if i < n and ans[i][1] >= time : return 1 \\n        if dp[i] != -1 : return dp[i]\\n        best = 123456 \\n        for j in range(i+1,len(ans)):\\n          x = ans[i][1] \\n          if x < ans[j][1] and x >= ans[j][0] : \\n            best = min(best , 1 + f(j)) \\n        dp[i] = best \\n        return best \\n      value = f(0)\\n      print(ans)\\n      if value == 123456 or ans[0][0] != 0 : return -1 \\n      return value\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869700,
                "title": "c-greedy-approach-beats-100-of-c-solutions",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n\\\\log{n})$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int largest = 0, prev = -1, cnt = 0;\\n        sort(clips.begin(), clips.end(), [] (const vector<int>& l, const vector<int>& r) {\\n            return l[0] == r[0] ? l[1] > r[1] : l[0] < r[0];\\n        });\\n        for (const vector<int>& c : clips) {\\n            if (c[0] > largest) return -1;\\n            if (c[1] <= largest) continue;\\n            if (prev == -1 || c[0] > prev) {\\n                prev = largest;\\n                ++ cnt;\\n            }\\n            largest = c[1];\\n            if (c[1] >= time) break;\\n        }\\n        if (largest < time) return -1;\\n        return cnt;\\n    }\\n};\\n```\\n**Please upvote if u like the solution :)**",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int videoStitching(vector<vector<int>>& clips, int time) {\\n        int largest = 0, prev = -1, cnt = 0;\\n        sort(clips.begin(), clips.end(), [] (const vector<int>& l, const vector<int>& r) {\\n            return l[0] == r[0] ? l[1] > r[1] : l[0] < r[0];\\n        });\\n        for (const vector<int>& c : clips) {\\n            if (c[0] > largest) return -1;\\n            if (c[1] <= largest) continue;\\n            if (prev == -1 || c[0] > prev) {\\n                prev = largest;\\n                ++ cnt;\\n            }\\n            largest = c[1];\\n            if (c[1] >= time) break;\\n        }\\n        if (largest < time) return -1;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869339,
                "title": "reduce-to-jump-game-ii",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReduce the problem to https://leetcode.com/problems/jump-game-ii/\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Convert the input to the Jump Game II problem\\n    * Map all the clips to a timeline by start time (which is essentially a counting sort)\\n    * Store max end time at each index\\n* Solve it greedily by maintaining current and max reach (end time)\\n\\n# Complexity\\n- Time complexity: $$O(max(M, N))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWhere M is `clips.len()` and N is `time`\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn video_stitching(clips: Vec<Vec<i32>>, time: i32) -> i32 {\\n        let timeline = clips.into_iter().fold(vec![0; time as usize], |mut acc, v| {\\n            let i = v[0] as usize;\\n            if i < acc.len() { acc[i] = acc[i].max(v[1] as usize); }\\n            acc\\n        });\\n\\n        let mut cur_reach = 0;\\n        let mut max_reach = 0;\\n        let mut ans = 0;\\n        for (start, end) in timeline.into_iter().enumerate() {\\n            max_reach = max_reach.max(end);\\n\\n            if start > cur_reach { return -1; }\\n            if start == cur_reach {\\n                ans += 1;\\n                cur_reach = max_reach;\\n            }\\n        }\\n\\n        if cur_reach >= time as usize { ans } else { -1 }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn video_stitching(clips: Vec<Vec<i32>>, time: i32) -> i32 {\\n        let timeline = clips.into_iter().fold(vec![0; time as usize], |mut acc, v| {\\n            let i = v[0] as usize;\\n            if i < acc.len() { acc[i] = acc[i].max(v[1] as usize); }\\n            acc\\n        });\\n\\n        let mut cur_reach = 0;\\n        let mut max_reach = 0;\\n        let mut ans = 0;\\n        for (start, end) in timeline.into_iter().enumerate() {\\n            max_reach = max_reach.max(end);\\n\\n            if start > cur_reach { return -1; }\\n            if start == cur_reach {\\n                ans += 1;\\n                cur_reach = max_reach;\\n            }\\n        }\\n\\n        if cur_reach >= time as usize { ans } else { -1 }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3866627,
                "title": "100-faster-for-beginner-to-advance-learner",
                "content": "\\nclass Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int maxLength=0, minLength= 0, total = 0;\\n        while(maxLength<time){\\n            for(int i=0;i<clips.length;i++) {\\n                int l = clips[i][0];\\n                int r = clips[i][1];\\n                if(l<=minLength && r>maxLength)\\n                    maxLength = r;\\n            }\\n            if(minLength == maxLength)\\n                return -1;\\n            minLength = maxLength;\\n            total ++;\\n        }\\n        return total;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int videoStitching(int[][] clips, int time) {\\n        int maxLength=0, minLength= 0, total = 0;\\n        while(maxLength<time){\\n            for(int i=0;i<clips.length;i++) {\\n                int l = clips[i][0];\\n                int r = clips[i][1];\\n                if(l<=minLength && r>maxLength)\\n                    maxLength = r;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1573370,
                "content": [
                    {
                        "username": "Dirk41",
                        "content": "I saw so many great solutions, and they are brililant! I feel so dump everytime when I don\\'t have a clue. Instead of just understading how solutino works, I am very curious how do people come up with those solutions ? What is the thought process ? I don\\'t know where to start when I face such a problem."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This question is similar to https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/"
                    },
                    {
                        "username": "tumba_umba",
                        "content": "Explain me, please!\\ngiven input \\n[[0,5],[1,6],[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19],[15,20],[16,21],[17,22],[18,23],[19,24],[20,25],[21,26],[22,27],[23,28],[24,29],[25,30],[26,31],[27,32],[28,33],[29,34],[30,35],[31,36],[32,37],[33,38],[34,39],[35,40],[36,41],[37,42],[38,43],[39,44],[40,45],[41,46],[42,47],[43,48],[44,49],[45,50],[46,51],[47,52],[48,53],[49,54]]\\n50\\nExpected output is 10.\\nBut my solution output 9 and take this segment \\n[0, 5]\\n[6, 11]\\n[12, 17]\\n[18, 23]\\n[24, 29]\\n[30, 35]\\n[36, 41]\\n[42, 47]\\n[48, 53]\\nI don\\'t understand why it isn\\'t correct!"
                    },
                    {
                        "username": "layyy",
                        "content": "similar problems:\\njump game 2 and minimum number of taps to open to water a garden"
                    },
                    {
                        "username": "vectoreal",
                        "content": "It is hard"
                    },
                    {
                        "username": "dragonman164",
                        "content": "clips = [[0,5],[6,8]]\\ntime = 7 \\nWhy expected output of this test case is -1? \\nAll intervals are covered from [0,7] for this case."
                    },
                    {
                        "username": "dragonman164",
                        "content": "[@avishekh159](/avishekh159)  Thanks"
                    },
                    {
                        "username": "avishekh159",
                        "content": "The reason being , the interval [5,6] isn\\'t covered \\nAlthough at first glance it looks , everything\\'s covered , but its not.\\nSo that\\'s the reason it gives as WA"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1966622,
                "content": [
                    {
                        "username": "Dirk41",
                        "content": "I saw so many great solutions, and they are brililant! I feel so dump everytime when I don\\'t have a clue. Instead of just understading how solutino works, I am very curious how do people come up with those solutions ? What is the thought process ? I don\\'t know where to start when I face such a problem."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This question is similar to https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/"
                    },
                    {
                        "username": "tumba_umba",
                        "content": "Explain me, please!\\ngiven input \\n[[0,5],[1,6],[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19],[15,20],[16,21],[17,22],[18,23],[19,24],[20,25],[21,26],[22,27],[23,28],[24,29],[25,30],[26,31],[27,32],[28,33],[29,34],[30,35],[31,36],[32,37],[33,38],[34,39],[35,40],[36,41],[37,42],[38,43],[39,44],[40,45],[41,46],[42,47],[43,48],[44,49],[45,50],[46,51],[47,52],[48,53],[49,54]]\\n50\\nExpected output is 10.\\nBut my solution output 9 and take this segment \\n[0, 5]\\n[6, 11]\\n[12, 17]\\n[18, 23]\\n[24, 29]\\n[30, 35]\\n[36, 41]\\n[42, 47]\\n[48, 53]\\nI don\\'t understand why it isn\\'t correct!"
                    },
                    {
                        "username": "layyy",
                        "content": "similar problems:\\njump game 2 and minimum number of taps to open to water a garden"
                    },
                    {
                        "username": "vectoreal",
                        "content": "It is hard"
                    },
                    {
                        "username": "dragonman164",
                        "content": "clips = [[0,5],[6,8]]\\ntime = 7 \\nWhy expected output of this test case is -1? \\nAll intervals are covered from [0,7] for this case."
                    },
                    {
                        "username": "dragonman164",
                        "content": "[@avishekh159](/avishekh159)  Thanks"
                    },
                    {
                        "username": "avishekh159",
                        "content": "The reason being , the interval [5,6] isn\\'t covered \\nAlthough at first glance it looks , everything\\'s covered , but its not.\\nSo that\\'s the reason it gives as WA"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1569473,
                "content": [
                    {
                        "username": "Dirk41",
                        "content": "I saw so many great solutions, and they are brililant! I feel so dump everytime when I don\\'t have a clue. Instead of just understading how solutino works, I am very curious how do people come up with those solutions ? What is the thought process ? I don\\'t know where to start when I face such a problem."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This question is similar to https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/"
                    },
                    {
                        "username": "tumba_umba",
                        "content": "Explain me, please!\\ngiven input \\n[[0,5],[1,6],[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19],[15,20],[16,21],[17,22],[18,23],[19,24],[20,25],[21,26],[22,27],[23,28],[24,29],[25,30],[26,31],[27,32],[28,33],[29,34],[30,35],[31,36],[32,37],[33,38],[34,39],[35,40],[36,41],[37,42],[38,43],[39,44],[40,45],[41,46],[42,47],[43,48],[44,49],[45,50],[46,51],[47,52],[48,53],[49,54]]\\n50\\nExpected output is 10.\\nBut my solution output 9 and take this segment \\n[0, 5]\\n[6, 11]\\n[12, 17]\\n[18, 23]\\n[24, 29]\\n[30, 35]\\n[36, 41]\\n[42, 47]\\n[48, 53]\\nI don\\'t understand why it isn\\'t correct!"
                    },
                    {
                        "username": "layyy",
                        "content": "similar problems:\\njump game 2 and minimum number of taps to open to water a garden"
                    },
                    {
                        "username": "vectoreal",
                        "content": "It is hard"
                    },
                    {
                        "username": "dragonman164",
                        "content": "clips = [[0,5],[6,8]]\\ntime = 7 \\nWhy expected output of this test case is -1? \\nAll intervals are covered from [0,7] for this case."
                    },
                    {
                        "username": "dragonman164",
                        "content": "[@avishekh159](/avishekh159)  Thanks"
                    },
                    {
                        "username": "avishekh159",
                        "content": "The reason being , the interval [5,6] isn\\'t covered \\nAlthough at first glance it looks , everything\\'s covered , but its not.\\nSo that\\'s the reason it gives as WA"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 2038518,
                "content": [
                    {
                        "username": "Dirk41",
                        "content": "I saw so many great solutions, and they are brililant! I feel so dump everytime when I don\\'t have a clue. Instead of just understading how solutino works, I am very curious how do people come up with those solutions ? What is the thought process ? I don\\'t know where to start when I face such a problem."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This question is similar to https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/"
                    },
                    {
                        "username": "tumba_umba",
                        "content": "Explain me, please!\\ngiven input \\n[[0,5],[1,6],[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19],[15,20],[16,21],[17,22],[18,23],[19,24],[20,25],[21,26],[22,27],[23,28],[24,29],[25,30],[26,31],[27,32],[28,33],[29,34],[30,35],[31,36],[32,37],[33,38],[34,39],[35,40],[36,41],[37,42],[38,43],[39,44],[40,45],[41,46],[42,47],[43,48],[44,49],[45,50],[46,51],[47,52],[48,53],[49,54]]\\n50\\nExpected output is 10.\\nBut my solution output 9 and take this segment \\n[0, 5]\\n[6, 11]\\n[12, 17]\\n[18, 23]\\n[24, 29]\\n[30, 35]\\n[36, 41]\\n[42, 47]\\n[48, 53]\\nI don\\'t understand why it isn\\'t correct!"
                    },
                    {
                        "username": "layyy",
                        "content": "similar problems:\\njump game 2 and minimum number of taps to open to water a garden"
                    },
                    {
                        "username": "vectoreal",
                        "content": "It is hard"
                    },
                    {
                        "username": "dragonman164",
                        "content": "clips = [[0,5],[6,8]]\\ntime = 7 \\nWhy expected output of this test case is -1? \\nAll intervals are covered from [0,7] for this case."
                    },
                    {
                        "username": "dragonman164",
                        "content": "[@avishekh159](/avishekh159)  Thanks"
                    },
                    {
                        "username": "avishekh159",
                        "content": "The reason being , the interval [5,6] isn\\'t covered \\nAlthough at first glance it looks , everything\\'s covered , but its not.\\nSo that\\'s the reason it gives as WA"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 2011402,
                "content": [
                    {
                        "username": "Dirk41",
                        "content": "I saw so many great solutions, and they are brililant! I feel so dump everytime when I don\\'t have a clue. Instead of just understading how solutino works, I am very curious how do people come up with those solutions ? What is the thought process ? I don\\'t know where to start when I face such a problem."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This question is similar to https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/"
                    },
                    {
                        "username": "tumba_umba",
                        "content": "Explain me, please!\\ngiven input \\n[[0,5],[1,6],[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19],[15,20],[16,21],[17,22],[18,23],[19,24],[20,25],[21,26],[22,27],[23,28],[24,29],[25,30],[26,31],[27,32],[28,33],[29,34],[30,35],[31,36],[32,37],[33,38],[34,39],[35,40],[36,41],[37,42],[38,43],[39,44],[40,45],[41,46],[42,47],[43,48],[44,49],[45,50],[46,51],[47,52],[48,53],[49,54]]\\n50\\nExpected output is 10.\\nBut my solution output 9 and take this segment \\n[0, 5]\\n[6, 11]\\n[12, 17]\\n[18, 23]\\n[24, 29]\\n[30, 35]\\n[36, 41]\\n[42, 47]\\n[48, 53]\\nI don\\'t understand why it isn\\'t correct!"
                    },
                    {
                        "username": "layyy",
                        "content": "similar problems:\\njump game 2 and minimum number of taps to open to water a garden"
                    },
                    {
                        "username": "vectoreal",
                        "content": "It is hard"
                    },
                    {
                        "username": "dragonman164",
                        "content": "clips = [[0,5],[6,8]]\\ntime = 7 \\nWhy expected output of this test case is -1? \\nAll intervals are covered from [0,7] for this case."
                    },
                    {
                        "username": "dragonman164",
                        "content": "[@avishekh159](/avishekh159)  Thanks"
                    },
                    {
                        "username": "avishekh159",
                        "content": "The reason being , the interval [5,6] isn\\'t covered \\nAlthough at first glance it looks , everything\\'s covered , but its not.\\nSo that\\'s the reason it gives as WA"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 2006991,
                "content": [
                    {
                        "username": "Dirk41",
                        "content": "I saw so many great solutions, and they are brililant! I feel so dump everytime when I don\\'t have a clue. Instead of just understading how solutino works, I am very curious how do people come up with those solutions ? What is the thought process ? I don\\'t know where to start when I face such a problem."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This question is similar to https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/"
                    },
                    {
                        "username": "tumba_umba",
                        "content": "Explain me, please!\\ngiven input \\n[[0,5],[1,6],[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19],[15,20],[16,21],[17,22],[18,23],[19,24],[20,25],[21,26],[22,27],[23,28],[24,29],[25,30],[26,31],[27,32],[28,33],[29,34],[30,35],[31,36],[32,37],[33,38],[34,39],[35,40],[36,41],[37,42],[38,43],[39,44],[40,45],[41,46],[42,47],[43,48],[44,49],[45,50],[46,51],[47,52],[48,53],[49,54]]\\n50\\nExpected output is 10.\\nBut my solution output 9 and take this segment \\n[0, 5]\\n[6, 11]\\n[12, 17]\\n[18, 23]\\n[24, 29]\\n[30, 35]\\n[36, 41]\\n[42, 47]\\n[48, 53]\\nI don\\'t understand why it isn\\'t correct!"
                    },
                    {
                        "username": "layyy",
                        "content": "similar problems:\\njump game 2 and minimum number of taps to open to water a garden"
                    },
                    {
                        "username": "vectoreal",
                        "content": "It is hard"
                    },
                    {
                        "username": "dragonman164",
                        "content": "clips = [[0,5],[6,8]]\\ntime = 7 \\nWhy expected output of this test case is -1? \\nAll intervals are covered from [0,7] for this case."
                    },
                    {
                        "username": "dragonman164",
                        "content": "[@avishekh159](/avishekh159)  Thanks"
                    },
                    {
                        "username": "avishekh159",
                        "content": "The reason being , the interval [5,6] isn\\'t covered \\nAlthough at first glance it looks , everything\\'s covered , but its not.\\nSo that\\'s the reason it gives as WA"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1698492,
                "content": [
                    {
                        "username": "Dirk41",
                        "content": "I saw so many great solutions, and they are brililant! I feel so dump everytime when I don\\'t have a clue. Instead of just understading how solutino works, I am very curious how do people come up with those solutions ? What is the thought process ? I don\\'t know where to start when I face such a problem."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This question is similar to https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/"
                    },
                    {
                        "username": "tumba_umba",
                        "content": "Explain me, please!\\ngiven input \\n[[0,5],[1,6],[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19],[15,20],[16,21],[17,22],[18,23],[19,24],[20,25],[21,26],[22,27],[23,28],[24,29],[25,30],[26,31],[27,32],[28,33],[29,34],[30,35],[31,36],[32,37],[33,38],[34,39],[35,40],[36,41],[37,42],[38,43],[39,44],[40,45],[41,46],[42,47],[43,48],[44,49],[45,50],[46,51],[47,52],[48,53],[49,54]]\\n50\\nExpected output is 10.\\nBut my solution output 9 and take this segment \\n[0, 5]\\n[6, 11]\\n[12, 17]\\n[18, 23]\\n[24, 29]\\n[30, 35]\\n[36, 41]\\n[42, 47]\\n[48, 53]\\nI don\\'t understand why it isn\\'t correct!"
                    },
                    {
                        "username": "layyy",
                        "content": "similar problems:\\njump game 2 and minimum number of taps to open to water a garden"
                    },
                    {
                        "username": "vectoreal",
                        "content": "It is hard"
                    },
                    {
                        "username": "dragonman164",
                        "content": "clips = [[0,5],[6,8]]\\ntime = 7 \\nWhy expected output of this test case is -1? \\nAll intervals are covered from [0,7] for this case."
                    },
                    {
                        "username": "dragonman164",
                        "content": "[@avishekh159](/avishekh159)  Thanks"
                    },
                    {
                        "username": "avishekh159",
                        "content": "The reason being , the interval [5,6] isn\\'t covered \\nAlthough at first glance it looks , everything\\'s covered , but its not.\\nSo that\\'s the reason it gives as WA"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1670067,
                "content": [
                    {
                        "username": "Dirk41",
                        "content": "I saw so many great solutions, and they are brililant! I feel so dump everytime when I don\\'t have a clue. Instead of just understading how solutino works, I am very curious how do people come up with those solutions ? What is the thought process ? I don\\'t know where to start when I face such a problem."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This question is similar to https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/"
                    },
                    {
                        "username": "tumba_umba",
                        "content": "Explain me, please!\\ngiven input \\n[[0,5],[1,6],[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19],[15,20],[16,21],[17,22],[18,23],[19,24],[20,25],[21,26],[22,27],[23,28],[24,29],[25,30],[26,31],[27,32],[28,33],[29,34],[30,35],[31,36],[32,37],[33,38],[34,39],[35,40],[36,41],[37,42],[38,43],[39,44],[40,45],[41,46],[42,47],[43,48],[44,49],[45,50],[46,51],[47,52],[48,53],[49,54]]\\n50\\nExpected output is 10.\\nBut my solution output 9 and take this segment \\n[0, 5]\\n[6, 11]\\n[12, 17]\\n[18, 23]\\n[24, 29]\\n[30, 35]\\n[36, 41]\\n[42, 47]\\n[48, 53]\\nI don\\'t understand why it isn\\'t correct!"
                    },
                    {
                        "username": "layyy",
                        "content": "similar problems:\\njump game 2 and minimum number of taps to open to water a garden"
                    },
                    {
                        "username": "vectoreal",
                        "content": "It is hard"
                    },
                    {
                        "username": "dragonman164",
                        "content": "clips = [[0,5],[6,8]]\\ntime = 7 \\nWhy expected output of this test case is -1? \\nAll intervals are covered from [0,7] for this case."
                    },
                    {
                        "username": "dragonman164",
                        "content": "[@avishekh159](/avishekh159)  Thanks"
                    },
                    {
                        "username": "avishekh159",
                        "content": "The reason being , the interval [5,6] isn\\'t covered \\nAlthough at first glance it looks , everything\\'s covered , but its not.\\nSo that\\'s the reason it gives as WA"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\n```"
                    }
                ]
            },
            {
                "id": 1631316,
                "content": [
                    {
                        "username": "Dirk41",
                        "content": "I saw so many great solutions, and they are brililant! I feel so dump everytime when I don\\'t have a clue. Instead of just understading how solutino works, I am very curious how do people come up with those solutions ? What is the thought process ? I don\\'t know where to start when I face such a problem."
                    },
                    {
                        "username": "ALS_Venky",
                        "content": "This question is similar to https://leetcode.com/problems/minimum-number-of-taps-to-open-to-water-a-garden/description/"
                    },
                    {
                        "username": "tumba_umba",
                        "content": "Explain me, please!\\ngiven input \\n[[0,5],[1,6],[2,7],[3,8],[4,9],[5,10],[6,11],[7,12],[8,13],[9,14],[10,15],[11,16],[12,17],[13,18],[14,19],[15,20],[16,21],[17,22],[18,23],[19,24],[20,25],[21,26],[22,27],[23,28],[24,29],[25,30],[26,31],[27,32],[28,33],[29,34],[30,35],[31,36],[32,37],[33,38],[34,39],[35,40],[36,41],[37,42],[38,43],[39,44],[40,45],[41,46],[42,47],[43,48],[44,49],[45,50],[46,51],[47,52],[48,53],[49,54]]\\n50\\nExpected output is 10.\\nBut my solution output 9 and take this segment \\n[0, 5]\\n[6, 11]\\n[12, 17]\\n[18, 23]\\n[24, 29]\\n[30, 35]\\n[36, 41]\\n[42, 47]\\n[48, 53]\\nI don\\'t understand why it isn\\'t correct!"
                    },
                    {
                        "username": "layyy",
                        "content": "similar problems:\\njump game 2 and minimum number of taps to open to water a garden"
                    },
                    {
                        "username": "vectoreal",
                        "content": "It is hard"
                    },
                    {
                        "username": "dragonman164",
                        "content": "clips = [[0,5],[6,8]]\\ntime = 7 \\nWhy expected output of this test case is -1? \\nAll intervals are covered from [0,7] for this case."
                    },
                    {
                        "username": "dragonman164",
                        "content": "[@avishekh159](/avishekh159)  Thanks"
                    },
                    {
                        "username": "avishekh159",
                        "content": "The reason being , the interval [5,6] isn\\'t covered \\nAlthough at first glance it looks , everything\\'s covered , but its not.\\nSo that\\'s the reason it gives as WA"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n```"
                    },
                    {
                        "username": "wodxuming",
                        "content": "\\xB7\\xB7\\xB7\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\xB7\\xB7\\xB7"
                    },
                    {
                        "username": "wodxuming",
                        "content": "```\\nclass Solution {\\nint videoStitching(int[][] clips, int T) {\\n    if (T == 0) return 0;\\n    // inc sort \\n    Arrays.sort(clips, (a, b) -> {\\n        if (a[0] == b[0]) {\\n            return b[1] - a[1];\\n        }\\n        return a[0] - b[0];\\n    });\\n\\n    int res = 0;\\n\\n    int curEnd = 0, nextEnd = 0;\\n    int i = 0, n = clips.length;\\n    while (i < n && clips[i][0] <= curEnd) {\\n        while (i < n && clips[i][0] <= curEnd) {\\n            nextEnd = Math.max(nextEnd, clips[i][1]);\\n            i++;\\n        }\\n        res++;\\n        curEnd = nextEnd;\\n        if (curEnd >= T) {\\n            return res;\\n        }\\n    }\\n    return -1;\\n}\\n}\\n\\n```"
                    }
                ]
            }
        ]
    }
]