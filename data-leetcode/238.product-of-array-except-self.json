[
    {
        "title": "Count and Say",
        "question_content": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\n\n\tcountAndSay(1) = \"1\"\n\tcountAndSay(n) is the way you would \"say\" the digit string from countAndSay(n-1), which is then converted into a different digit string.\n\nTo determine how you \"say\" a digit string, split it into the minimal number of substrings such that each substring contains exactly one unique digit. Then for each substring, say the number of digits, then say the digit. Finally, concatenate every said digit.\nFor example, the saying and conversion for digit string \"3322251\":\nGiven a positive integer n, return the nth term of the count-and-say sequence.\n&nbsp;\nExample 1:\n\nInput: n = 1\nOutput: \"1\"\nExplanation: This is the base case.\n\nExample 2:\n\nInput: n = 4\nOutput: \"1211\"\nExplanation:\ncountAndSay(1) = \"1\"\ncountAndSay(2) = say \"1\" = one 1 = \"11\"\ncountAndSay(3) = say \"11\" = two 1's = \"21\"\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\"\n\n&nbsp;\nConstraints:\n\n\t1 <= n <= 30",
        "solutions": [
            {
                "id": 15995,
                "title": "examples-of-nth-sequence",
                "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I'm going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n     1.     1\\n     2.     11\\n     3.     21\\n     4.     1211\\n     5.     111221 \\n     6.     312211\\n     7.     13112221\\n     8.     1113213211\\n     9.     31131211131221\\n     10.   13211311123113112211\\n\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!",
                "solutionTags": [],
                "code": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I'm going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n     1.     1\\n     2.     11\\n     3.     21\\n     4.     1211\\n     5.     111221 \\n     6.     312211\\n     7.     13112221\\n     8.     1113213211\\n     9.     31131211131221\\n     10.   13211311123113112211\\n\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!",
                "codeTag": "Unknown"
            },
            {
                "id": 15999,
                "title": "4-5-lines-python-solutions",
                "content": "**Solution 1** ... using a regular expression\\n\\n    def countAndSay(self, n):\\n        s = '1'\\n        for _ in range(n - 1):\\n            s = re.sub(r'(.)\\\\1*', lambda m: str(len(m.group(0))) + m.group(1), s)\\n        return s\\n\\n---\\n\\n**Solution 2** ... using a regular expression\\n\\n    def countAndSay(self, n):\\n        s = '1'\\n        for _ in range(n - 1):\\n            s = ''.join(str(len(group)) + digit\\n                        for group, digit in re.findall(r'((.)\\\\2*)', s))\\n        return s\\n\\n---\\n\\n**Solution 3** ... using `groupby`\\n\\n    def countAndSay(self, n):\\n        s = '1'\\n        for _ in range(n - 1):\\n            s = ''.join(str(len(list(group))) + digit\\n                        for digit, group in itertools.groupby(s))\\n        return s",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Solution 1** ... using a regular expression\\n\\n    def countAndSay(self, n):\\n        s = '1'\\n        for _ in range(n - 1):\\n            s = re.sub(r'(.)\\\\1*', lambda m: str(len(m.group(0))) + m.group(1), s)\\n        return s\\n\\n---\\n\\n**Solution 2** ... using a regular expression\\n\\n    def countAndSay(self, n):\\n        s = '1'\\n        for _ in range(n - 1):\\n            s = ''.join(str(len(group)) + digit\\n                        for group, digit in re.findall(r'((.)\\\\2*)', s))\\n        return s\\n\\n---\\n\\n**Solution 3** ... using `groupby`\\n\\n    def countAndSay(self, n):\\n        s = '1'\\n        for _ in range(n - 1):\\n            s = ''.join(str(len(list(group))) + digit\\n                        for digit, group in itertools.groupby(s))\\n        return s",
                "codeTag": "Python3"
            },
            {
                "id": 16040,
                "title": "straightforward-java-solution",
                "content": "     public class Solution {\\n        public String countAndSay(int n) {\\n            String s = \"1\";\\n            for(int i = 1; i < n; i++){\\n                s = countIdx(s);\\n            }\\n            return s;\\n        }\\n        \\n        public String countIdx(String s){\\n            StringBuilder sb = new StringBuilder();\\n            char c = s.charAt(0);\\n            int count = 1;\\n            for(int i = 1; i < s.length(); i++){\\n                if(s.charAt(i) == c){\\n                    count++;\\n                }\\n                else\\n                {\\n                    sb.append(count);\\n                    sb.append(c);\\n                    c = s.charAt(i);\\n                    count = 1;\\n                }\\n            }\\n            sb.append(count);\\n            sb.append(c);\\n            return sb.toString();\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String countAndSay(int n) {\\n            String s = \"1\";\\n            for(int i = 1; i < n; i++){\\n                s = countIdx(s);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 16043,
                "title": "c-solution-easy-understand",
                "content": "    string countAndSay(int n) {\\n        if (n == 0) return \"\";\\n        string res = \"1\";\\n        while (--n) {\\n            string cur = \"\";\\n            for (int i = 0; i < res.size(); i++) {\\n                int count = 1;\\n                 while ((i + 1 < res.size()) && (res[i] == res[i + 1])){\\n                    count++;    \\n                    i++;\\n                }\\n                cur += to_string(count) + res[i];\\n            }\\n            res = cur;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    string countAndSay(int n) {\\n        if (n == 0) return \"\";\\n        string res = \"1\";\\n        while (--n) {\\n            string cur = \"\";\\n            for (int i = 0; i < res.size(); i++) {\\n                int count = 1;\\n                 while ((i + 1 < res.size()) && (res[i] == res[i + 1])){\\n                    count++;    \\n                    i++;\\n                }\\n                cur += to_string(count) + res[i];\\n            }\\n            res = cur;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 16044,
                "title": "simple-python-solution",
                "content": "Idea here is keep track of the first letter in the sequence and count consecutive occurances.  Once you encounter a new letter you add the previous count and letter to the chain.  Repeat n-1 times (since we seeded the initial '1' case).  We always update temp after the inner loop since we will never have already added the last sequence.\\n\\n         def countAndSay(self, n):\\n            s = '1'\\n            for _ in range(n-1):\\n                let, temp, count = s[0], '', 0\\n                for l in s:\\n                    if let == l:\\n                        count += 1\\n                    else:\\n                        temp += str(count)+let\\n                        let = l\\n                        count = 1\\n                temp += str(count)+let\\n                s = temp\\n            return s",
                "solutionTags": [
                    "Python"
                ],
                "code": "Idea here is keep track of the first letter in the sequence and count consecutive occurances.  Once you encounter a new letter you add the previous count and letter to the chain.  Repeat n-1 times (since we seeded the initial '1' case).  We always update temp after the inner loop since we will never have already added the last sequence.\\n\\n         def countAndSay(self, n):\\n            s = '1'\\n            for _ in range(n-1):\\n                let, temp, count = s[0], '', 0\\n                for l in s:\\n                    if let == l:\\n                        count += 1\\n                    else:\\n                        temp += str(count)+let\\n                        let = l\\n                        count = 1\\n                temp += str(count)+let\\n                s = temp\\n            return s",
                "codeTag": "Python3"
            },
            {
                "id": 16000,
                "title": "show-an-answer-in-java",
                "content": "I found nobody answered this question in Java. Actually I got some trouble even this question is not so hard.\\n\\nMaybe many other people had some trouble too. So I put my answer here.\\n\\n\\n\\n    public class Solution {\\n        public String countAndSay(int n) {\\n    \\t    \\tStringBuilder curr=new StringBuilder(\"1\");\\n    \\t    \\tStringBuilder prev;\\n    \\t    \\tint count;\\n    \\t    \\tchar say;\\n    \\t        for (int i=1;i<n;i++){\\n    \\t        \\tprev=curr;\\n    \\t \\t        curr=new StringBuilder();       \\n    \\t \\t        count=1;\\n    \\t \\t        say=prev.charAt(0);\\n    \\t \\t        \\n    \\t \\t        for (int j=1,len=prev.length();j<len;j++){\\n    \\t \\t        \\tif (prev.charAt(j)!=say){\\n    \\t \\t        \\t\\tcurr.append(count).append(say);\\n    \\t \\t        \\t\\tcount=1;\\n    \\t \\t        \\t\\tsay=prev.charAt(j);\\n    \\t \\t        \\t}\\n    \\t \\t        \\telse count++;\\n    \\t \\t        }\\n    \\t \\t        curr.append(count).append(say);\\n    \\t        }\\t       \\t        \\n    \\t        return curr.toString();\\n            \\n        }\\n    }\\n\\n@code StringBuilder.append() is the default way to append one string to another. While I have tried String.cancate(),which is not working properly.\\n\\nAny comment is welcomed.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String countAndSay(int n) {\\n    \\t    \\tStringBuilder curr=new StringBuilder(\"1\");\\n    \\t    \\tStringBuilder prev;\\n    \\t    \\tint count;\\n    \\t    \\tchar say;\\n    \\t        for (int i=1;i<n;i++){\\n    \\t        \\tprev=curr;\\n    \\t \\t        curr=new StringBuilder();       \\n    \\t \\t        count=1;\\n    \\t \\t        say=prev.charAt(0);\\n    \\t \\t        \\n    \\t \\t        for (int j=1,len=prev.length();j<len;j++){\\n    \\t \\t        \\tif (prev.charAt(j)!=say){\\n    \\t \\t        \\t\\tcurr.append(count).append(say);\\n    \\t \\t        \\t\\tcount=1;\\n    \\t \\t        \\t\\tsay=prev.charAt(j);\\n    \\t \\t        \\t}",
                "codeTag": "Java"
            },
            {
                "id": 2716207,
                "title": "c-easy-detailed-explaination-optimized",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Intuition :**\\n```\\nn = 1: return 1 is the base case\\nn = 2: return count of last entry i.e. 1 1\\nn = 3: return count of last entry i.e. two 1\\'s so 21\\nn = 4: we have one 2 and one 1 so 1211\\nn = 5: , we have one 1 and one 2 and two 1\\'s so -> 111221\\nn = 6: we have three 1\\'s, two 2\\'s and one 1 so -> 312211\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> 13112221\\n...\\nn = i: return counts in front of the number for entry of i-1 case\\n```\\n\\n**The following are sequence from n=1 to n=10:**\\n```\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\n```\\ncredits for sequences @xin15\\n\\n**Ques)** What does `s=s+\"&\"` means, why do we add \"&\" at the end?\\n**Ans =>** Whenever we get a character that is unequal to the previous character,we add the previous add our answer for the previous number to the string temp. So for the last number in the string we wont get any inequality and hence it wont get added to string temp. This is why we added a random character at the end so that random character becomes unequal to the last character of the actual string and we could get the desired answer.\\n\\nTake example \"1211\".\\nHere you can not count the last \\'1\\'.\\n\\nBut you can in this example \"1211$\"\\nif(s[j]==s[j-1]){\\n      cnt++;\\n}\\nto count the last one you\\'ve to include an ending character.\\n\\n```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        // base case\\n        if(n==1)\\n            return \"1\";\\n        if(n==2)\\n            return \"11\";\\n        \\n        // take a string equals 11\\n        string str = \"11\";\\n        \\n        // now we need the value of nth term so we loop from 3 -> n\\n        for(int i=3; i<=n ; i++)\\n        {\\n            // temp will have the ans of the next iteration i.e value of the next ith data\\n            string temp = \"\";\\n            str = str+\"&\"; // add a delimeter at the end\\n            int cnt = 1; // counter \\n            \\n            // now loop from 1st value to last value\\n            for(int j = 1; j<str.length(); j++)\\n            {\\n                // this condition should be satisfied, if not that means new number has started occurring\\n                if(str[j]!=str[j-1])\\n                {\\n                    temp = temp + to_string(cnt); // add the counter to temp\\n                    temp = temp + str[j-1]; // add the data of the counter\\n                    cnt = 1; // reset the counter to 1\\n                }\\n                else\\n                    cnt++; // just count the freq of that number\\n            }\\n            \\n            // after one complete traversal, make str equal to temp;\\n            str = temp;\\n        }\\n        \\n    return str;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/cda3b0c2-39b5-43e1-99dd-0f8086af8ee6_1666055856.180599.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nn = 1: return 1 is the base case\\nn = 2: return count of last entry i.e. 1 1\\nn = 3: return count of last entry i.e. two 1\\'s so 21\\nn = 4: we have one 2 and one 1 so 1211\\nn = 5: , we have one 1 and one 2 and two 1\\'s so -> 111221\\nn = 6: we have three 1\\'s, two 2\\'s and one 1 so -> 312211\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> 13112221\\n...\\nn = i: return counts in front of the number for entry of i-1 case\\n```\n```\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\n```\n```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        // base case\\n        if(n==1)\\n            return \"1\";\\n        if(n==2)\\n            return \"11\";\\n        \\n        // take a string equals 11\\n        string str = \"11\";\\n        \\n        // now we need the value of nth term so we loop from 3 -> n\\n        for(int i=3; i<=n ; i++)\\n        {\\n            // temp will have the ans of the next iteration i.e value of the next ith data\\n            string temp = \"\";\\n            str = str+\"&\"; // add a delimeter at the end\\n            int cnt = 1; // counter \\n            \\n            // now loop from 1st value to last value\\n            for(int j = 1; j<str.length(); j++)\\n            {\\n                // this condition should be satisfied, if not that means new number has started occurring\\n                if(str[j]!=str[j-1])\\n                {\\n                    temp = temp + to_string(cnt); // add the counter to temp\\n                    temp = temp + str[j-1]; // add the data of the counter\\n                    cnt = 1; // reset the counter to 1\\n                }\\n                else\\n                    cnt++; // just count the freq of that number\\n            }\\n            \\n            // after one complete traversal, make str equal to temp;\\n            str = temp;\\n        }\\n        \\n    return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201832,
                "title": "it-s-a-good-question-let-me-explain-it",
                "content": "When I first read the question, I don\\'t really understand what is this question meaning. Actually it is very simple.\\nEverthing start 1, 1 is 1, nothing else.\\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That\\'s why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\\n....\\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let\\'s count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\\n\\n\\tclass Solution:\\n\\t\\tdef countAndSay(self, n):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type n: int\\n\\t\\t\\t:rtype: str\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif n == 1:\\n\\t\\t\\t\\treturn \"1\"\\n\\t\\t\\treturn self.count(self.countAndSay(n - 1))\\n\\t\\t\\t\\n\\t\\tdef count(self , s):\\n\\t\\t\\tc = s[0]\\n\\t\\t\\tcount = 1\\n\\t\\t\\tres = \"\"\\n\\t\\t\\tfor char in s[1 : ]:\\n\\t\\t\\t\\tif char == c:\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres  = res + str(count) + c\\n\\t\\t\\t\\t\\tc = char\\n\\t\\t\\t\\t\\tcount = 1\\n\\t\\t\\tres = res + str(count) + c\\n\\t\\t\\treturn res\\neasy question , but good, just need to understand it",
                "solutionTags": [],
                "code": "When I first read the question, I don\\'t really understand what is this question meaning. Actually it is very simple.\\nEverthing start 1, 1 is 1, nothing else.\\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That\\'s why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\\n....\\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let\\'s count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\\n\\n\\tclass Solution:\\n\\t\\tdef countAndSay(self, n):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type n: int\\n\\t\\t\\t:rtype: str\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tif n == 1:\\n\\t\\t\\t\\treturn \"1\"\\n\\t\\t\\treturn self.count(self.countAndSay(n - 1))\\n\\t\\t\\t\\n\\t\\tdef count(self , s):\\n\\t\\t\\tc = s[0]\\n\\t\\t\\tcount = 1\\n\\t\\t\\tres = \"\"\\n\\t\\t\\tfor char in s[1 : ]:\\n\\t\\t\\t\\tif char == c:\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres  = res + str(count) + c\\n\\t\\t\\t\\t\\tc = char\\n\\t\\t\\t\\t\\tcount = 1\\n\\t\\t\\tres = res + str(count) + c\\n\\t\\t\\treturn res\\neasy question , but good, just need to understand it",
                "codeTag": "Java"
            },
            {
                "id": 2716134,
                "title": "easy-java-superfast-solution",
                "content": "# Upote if you like the solution\\n\\n\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        return new String[]{\"1\", \"11\", \"21\", \"1211\", \"111221\", \"312211\", \"13112221\", \"1113213211\", \"31131211131221\", \"13211311123113112211\", \"11131221133112132113212221\", \"3113112221232112111312211312113211\", \"1321132132111213122112311311222113111221131221\", \"11131221131211131231121113112221121321132132211331222113112211\", \"311311222113111231131112132112311321322112111312211312111322212311322113212221\", \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\", \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\", \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\", \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\", \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\", \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"}\\n[n - 1];\\n    }}\\n```\\n\\n\\n# IF THE SOLUTION WORKED FOR YOU PLEASE UPVOTE IT............",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        return new String[]{\"1\", \"11\", \"21\", \"1211\", \"111221\", \"312211\", \"13112221\", \"1113213211\", \"31131211131221\", \"13211311123113112211\", \"11131221133112132113212221\", \"3113112221232112111312211312113211\", \"1321132132111213122112311311222113111221131221\", \"11131221131211131231121113112221121321132132211331222113112211\", \"311311222113111231131112132112311321322112111312211312111322212311322113212221\", \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\", \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\", \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\", \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\", \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\", \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"}\\n[n - 1];\\n    }}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1525671,
                "title": "simple-c-recursive-solution",
                "content": "This function makes `n` recursive calls, since we start from `n` and end at `1` (base case)\\n\\n```\\nstring countAndSay(int n, string s = \"1\") { // initial value of the string is \"1\"\\n    if(n==1) return s; // base case, when n recursive calls are finished\\n\\t\\n    int i=0, j, len = s.size(); // \\'len\\' is the length of the string \\'s\\'\\n    string res = \"\"; // result after we \\'say\\' the string \\'s\\'\\n\\t\\n\\t// \\'i\\' starts from index 0\\n    while(i<len) {\\n        j=i; // fix \\'j\\' as the current position (i)\\n\\t\\t\\n\\t\\t// increment the value of \\'i\\' till valid position\\n        while(i<len && s[i]==s[j]) i++;\\n\\t\\t\\n\\t\\t// substring with same values as s[j] is [j,i-1] & \"i-j\" is the count of that value\\n\\t\\t// add the concatenation of (count + s[j]) to the result \\n        res += to_string(i-j) + s[j];\\n    }\\n\\t\\n\\t// recursively, call the same function by decrementing the count\\n\\t// and update the result \\'res\\', which will be the next string \\'s\\'\\n    return countAndSay(n-1, res);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nstring countAndSay(int n, string s = \"1\") { // initial value of the string is \"1\"\\n    if(n==1) return s; // base case, when n recursive calls are finished\\n\\t\\n    int i=0, j, len = s.size(); // \\'len\\' is the length of the string \\'s\\'\\n    string res = \"\"; // result after we \\'say\\' the string \\'s\\'\\n\\t\\n\\t// \\'i\\' starts from index 0\\n    while(i<len) {\\n        j=i; // fix \\'j\\' as the current position (i)\\n\\t\\t\\n\\t\\t// increment the value of \\'i\\' till valid position\\n        while(i<len && s[i]==s[j]) i++;\\n\\t\\t\\n\\t\\t// substring with same values as s[j] is [j,i-1] & \"i-j\" is the count of that value\\n\\t\\t// add the concatenation of (count + s[j]) to the result \\n        res += to_string(i-j) + s[j];\\n    }\\n\\t\\n\\t// recursively, call the same function by decrementing the count\\n\\t// and update the result \\'res\\', which will be the next string \\'s\\'\\n    return countAndSay(n-1, res);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16382,
                "title": "python-easy-to-understand-iterative-and-recursive-solutions",
                "content": "```\\nclass Solution(object):\\n    def countAndSay(self, n):\\n        ret = \"1\"\\n        for _ in range(n-1):\\n            ret = self.nextStep(ret)\\n        return ret\\n    \\n    def nextStep(self, s):\\n        i, ret = 0, \"\"\\n        while i < len(s):\\n            count = 1\\n            while i+1 < len(s) and s[i+1] == s[i]:\\n                count += 1\\n                i += 1\\n            ret += str(count) + s[i]\\n            i += 1\\n        return ret\\n    \\n    def countAndSay1(self, n):\\n        if n == 1:\\n            return \"1\"\\n        s = self.countAndSay(n-1)\\n        i, ret = 0, \"\"\\n        while i < len(s):\\n            count = 1\\n            while i+1 < len(s) and s[i+1] == s[i]:\\n                count += 1\\n                i += 1\\n            ret += str(count) + s[i]\\n            i += 1\\n        return ret\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countAndSay(self, n):\\n        ret = \"1\"\\n        for _ in range(n-1):\\n            ret = self.nextStep(ret)\\n        return ret\\n    \\n    def nextStep(self, s):\\n        i, ret = 0, \"\"\\n        while i < len(s):\\n            count = 1\\n            while i+1 < len(s) and s[i+1] == s[i]:\\n                count += 1\\n                i += 1\\n            ret += str(count) + s[i]\\n            i += 1\\n        return ret\\n    \\n    def countAndSay1(self, n):\\n        if n == 1:\\n            return \"1\"\\n        s = self.countAndSay(n-1)\\n        i, ret = 0, \"\"\\n        while i < len(s):\\n            count = 1\\n            while i+1 < len(s) and s[i+1] == s[i]:\\n                count += 1\\n                i += 1\\n            ret += str(count) + s[i]\\n            i += 1\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391236,
                "title": "javascript-97-25-not-clever",
                "content": "When you only have 30 options\\n```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar countAndSay = function(n) {\\narr = [ \"\",\\'1\\',\\n  \\'11\\',\\n  \\'21\\',\\n  \\'1211\\',\\n  \\'111221\\',\\n  \\'312211\\',\\n  \\'13112221\\',\\n  \\'1113213211\\',\\n  \\'31131211131221\\',\\n  \\'13211311123113112211\\',\\n  \\'11131221133112132113212221\\',\\n  \\'3113112221232112111312211312113211\\',\\n  \\'1321132132111213122112311311222113111221131221\\',\\n  \\'11131221131211131231121113112221121321132132211331222113112211\\',\\n  \\'311311222113111231131112132112311321322112111312211312111322212311322113212221\\',\\n  \\'132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\\',\\n  \\'11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\\',\\n  \\'31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\\',\\n  \\'1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\\',\\n  \\'11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\\',\\n  \\'311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n  \\'132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\',\\n  \\'111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\\',\\n  \\'3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\\',\\n  \\'132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n  \\'1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\',\\n  \\'31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\\',\\n  \\'13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\\',\\n  \\'11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n  \\'3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\' ]\\n    return arr[n]\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar countAndSay = function(n) {\\narr = [ \"\",\\'1\\',\\n  \\'11\\',\\n  \\'21\\',\\n  \\'1211\\',\\n  \\'111221\\',\\n  \\'312211\\',\\n  \\'13112221\\',\\n  \\'1113213211\\',\\n  \\'31131211131221\\',\\n  \\'13211311123113112211\\',\\n  \\'11131221133112132113212221\\',\\n  \\'3113112221232112111312211312113211\\',\\n  \\'1321132132111213122112311311222113111221131221\\',\\n  \\'11131221131211131231121113112221121321132132211331222113112211\\',\\n  \\'311311222113111231131112132112311321322112111312211312111322212311322113212221\\',\\n  \\'132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\\',\\n  \\'11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\\',\\n  \\'31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\\',\\n  \\'1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\\',\\n  \\'11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\\',\\n  \\'311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n  \\'132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\',\\n  \\'111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\\',\\n  \\'3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\\',\\n  \\'132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n  \\'1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\',\\n  \\'31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\\',\\n  \\'13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\\',\\n  \\'11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n  \\'3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\' ]\\n    return arr[n]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1351839,
                "title": "swift-count-and-say-test-cases",
                "content": "```swift\\nclass Solution {\\n    func countAndSay(_ n: Int) -> String {\\n        guard n > 1 && n <= 30 else { return \"1\" }\\n        \\n        let prev = countAndSay(n - 1)\\n        var curr = prev.first!, count = 0, result = \"\"\\n        \\n        prev.forEach {\\n            if $0 != curr {\\n                result += \"\\\\(count)\\\\(curr)\"\\n                count = 1\\n                curr = $0\\n            } else {\\n                count += 1\\n            }\\n        }\\n        result += \"\\\\(count)\\\\(curr)\"\\n        return result\\n        \\n    }\\n}\\n```\\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        XCTAssertEqual(s.countAndSay(1), \"1\")\\n    }\\n    func test1() {\\n        XCTAssertEqual(s.countAndSay(4), \"1211\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func countAndSay(_ n: Int) -> String {\\n        guard n > 1 && n <= 30 else { return \"1\" }\\n        \\n        let prev = countAndSay(n - 1)\\n        var curr = prev.first!, count = 0, result = \"\"\\n        \\n        prev.forEach {\\n            if $0 != curr {\\n                result += \"\\\\(count)\\\\(curr)\"\\n                count = 1\\n                curr = $0\\n            } else {\\n                count += 1\\n            }\\n        }\\n        result += \"\\\\(count)\\\\(curr)\"\\n        return result\\n        \\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 2 tests, with 0 failures (0 unexpected) in 0.006 (0.008) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func test0() {\\n        XCTAssertEqual(s.countAndSay(1), \"1\")\\n    }\\n    func test1() {\\n        XCTAssertEqual(s.countAndSay(4), \"1211\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16325,
                "title": "super-simple-javascript-solution-if-anyone-is-interested",
                "content": "    var countAndSay = function(n) {\\n        var str = '1';\\n        for (var i=1; i < n; i++) {\\n            var strArray = str.split('');\\n            str ='';\\n            var count = 1;\\n            // Loop through current nth level line\\n            for (var j=0; j < strArray.length; j++) {\\n                // Next digit is different\\n                if (strArray[j] !== strArray[j+1]) {\\n                    // Go to next non-matching digit\\n                    str += count + strArray[j];\\n                    count = 1;\\n                }\\n                else {\\n                    count++;\\n                }\\n            }\\n        }\\n        return str;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var countAndSay = function(n) {\\n        var str = '1';\\n        for (var i=1; i < n; i++) {\\n            var strArray = str.split('');\\n            str ='';\\n            var count = 1;\\n            // Loop through current nth level line\\n            for (var j=0; j < strArray.length; j++) {\\n                // Next digit is different\\n                if (strArray[j] !== strArray[j+1]) {\\n                    // Go to next non-matching digit\\n                    str += count + strArray[j];\\n                    count = 1;\\n                }\\n                else {\\n                    count++;\\n                }\\n            }\\n        }\\n        return str;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1239584,
                "title": "c-easy-to-understand-0ms-100-faster",
                "content": "```\\n string countAndSay(int n) \\n    {\\n        if(n == 1)\\n          return \"1\";\\n        if(n == 2)\\n          return \"11\";\\n          \\n        string str = \"11\";\\n        \\n        for(int i = 3; i <= n; i++)\\n         {\\n             str += \\'$\\';\\n             int len = str.length();\\n             \\n             int cnt = 1;\\n             string tmp = \"\";\\n             \\n             for(int j = 1; j < len; j++)\\n              {\\n                  if(str[j] != str[j - 1])\\n                    {\\n                        tmp += cnt + \\'0\\';\\n                        tmp += str[j - 1];\\n                        cnt = 1;\\n                    }\\n                   else\\n                     cnt++;\\n              }\\n            str = tmp;  \\n         }\\n         \\n        return str;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n string countAndSay(int n) \\n    {\\n        if(n == 1)\\n          return \"1\";\\n        if(n == 2)\\n          return \"11\";\\n          \\n        string str = \"11\";\\n        \\n        for(int i = 3; i <= n; i++)\\n         {\\n             str += \\'$\\';\\n             int len = str.length();\\n             \\n             int cnt = 1;\\n             string tmp = \"\";\\n             \\n             for(int j = 1; j < len; j++)\\n              {\\n                  if(str[j] != str[j - 1])\\n                    {\\n                        tmp += cnt + \\'0\\';\\n                        tmp += str[j - 1];\\n                        cnt = 1;\\n                    }\\n                   else\\n                     cnt++;\\n              }\\n            str = tmp;  \\n         }\\n         \\n        return str;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16446,
                "title": "c-iterative-solution-with-explanation-easy-to-understand",
                "content": "<h1>Renewed Solution</h1>\\n\\nThe key point here is to find the maximum consecutive identical numbers, which means, for example:\\n\\nSay there is a array like this `[1, 1, 2, 3, 4, 4, 5, 5, 5]`, we will need to divide the array into different segments like this, `[1, 1]`, `[2]`, `[3]`, `[4, 4]`, `[5, 5, 5]`. Only in this way, can we count the occurrence of each consecutive segments and convert them into `\"21 12 13 24 35\"`. \\n\\nThe description of the problem is misleading and I struggled for a while, after some searching I found the right explanation. The number `n` has nothing to do with the algorithm directly, but but only control the number of iteration.\\n\\nThe problem can be solved by using iterative algorithm.\\n\\n<h2>Code</h2>\\n\\n    string countAndSay(int n)\\n    {\\n        string curr_str;\\n\\n\\t\\t// The initial case, when n = 1\\n\\t\\tcurr_str += '1';\\n\\n\\t\\t// The iterative case, when n > 1\\n\\t\\tfor (int i = 0; i < n - 1; i++)\\n\\t\\t{\\n\\t\\t\\tstring buffer;\\n\\n\\t\\t\\t// Handle the current string\\n\\t\\t\\tint index = 0;\\n\\t\\t\\tfor (int index = 0; index < curr_str.size(); ++index)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Count the occurance of each digit\\n\\t\\t\\t\\tint cnt = 1; // At least one occurance\\n\\t\\t\\t\\t\\n\\t\\t\\t\\twhile (index + 1 < curr_str.size() and curr_str[index + 1] == curr_str[index]) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbuffer.push_back(cnt + '0');\\n\\t\\t\\t\\tbuffer.push_back(curr_str[index]);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Update the current string\\n\\t\\t\\tcurr_str = buffer;\\n\\t\\t}\\n\\n\\t\\treturn curr_str;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "<h1>Renewed Solution</h1>\\n\\nThe key point here is to find the maximum consecutive identical numbers, which means, for example:\\n\\nSay there is a array like this `[1, 1, 2, 3, 4, 4, 5, 5, 5]`, we will need to divide the array into different segments like this, `[1, 1]`, `[2]`, `[3]`, `[4, 4]`, `[5, 5, 5]`. Only in this way, can we count the occurrence of each consecutive segments and convert them into `\"21 12 13 24 35\"`. \\n\\nThe description of the problem is misleading and I struggled for a while, after some searching I found the right explanation. The number `n` has nothing to do with the algorithm directly, but but only control the number of iteration.\\n\\nThe problem can be solved by using iterative algorithm.\\n\\n<h2>Code</h2>\\n\\n    string countAndSay(int n)\\n    {\\n        string curr_str;\\n\\n\\t\\t// The initial case, when n = 1\\n\\t\\tcurr_str += '1';\\n\\n\\t\\t// The iterative case, when n > 1\\n\\t\\tfor (int i = 0; i < n - 1; i++)\\n\\t\\t{\\n\\t\\t\\tstring buffer;\\n\\n\\t\\t\\t// Handle the current string\\n\\t\\t\\tint index = 0;\\n\\t\\t\\tfor (int index = 0; index < curr_str.size(); ++index)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// Count the occurance of each digit\\n\\t\\t\\t\\tint cnt = 1; // At least one occurance\\n\\t\\t\\t\\t\\n\\t\\t\\t\\twhile (index + 1 < curr_str.size() and curr_str[index + 1] == curr_str[index]) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tbuffer.push_back(cnt + '0');\\n\\t\\t\\t\\tbuffer.push_back(curr_str[index]);\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Update the current string\\n\\t\\t\\tcurr_str = buffer;\\n\\t\\t}\\n\\n\\t\\treturn curr_str;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2717257,
                "title": "short-c-explained-solution-beginner-friendly-by-mr-coder",
                "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0)\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    string countAndSay(int n, string prevs = \"1\") {\\n    if(n==1) return prevs;\\n    int i=0, j, len = prevs.size();\\n    string currs = \"\";\\n    while(i<len) {\\n        j=i;\\n        while(i<len && prevs[i]==prevs[j]) i++;\\n        currs += to_string(i-j) + prevs[j];\\n    }\\n    return countAndSay(n-1, currs);\\n}\\n}; \\n```\\n**If you find my solution helpful please upvote it.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n, string prevs = \"1\") {\\n    if(n==1) return prevs;\\n    int i=0, j, len = prevs.size();\\n    string currs = \"\";\\n    while(i<len) {\\n        j=i;\\n        while(i<len && prevs[i]==prevs[j]) i++;\\n        currs += to_string(i-j) + prevs[j];\\n    }\\n    return countAndSay(n-1, currs);\\n}\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716459,
                "title": "java-easy-solution-100-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if (n <= 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        StringBuilder sb = new StringBuilder(\"1\");\\n        for (int i = 2; i <= n; i++) {\\n            sb = getNextState(sb);\\n        }\\n        return sb.toString();\\n    }\\n\\n    private StringBuilder getNextState(StringBuilder curSb) {\\n        StringBuilder nextSb = new StringBuilder();\\n        int len = curSb.length();\\n        int i = 0;\\n\\t\\t\\n        while (i < len) {\\n            char c = curSb.charAt(i++);\\n            int count = 1;\\n            while (i < len && c == curSb.charAt(i)) {\\n                count++;\\n                i++;\\n            }\\n            nextSb.append(count).append(c);\\n        }\\n\\t\\t\\n        return nextSb;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if (n <= 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        StringBuilder sb = new StringBuilder(\"1\");\\n        for (int i = 2; i <= n; i++) {\\n            sb = getNextState(sb);\\n        }\\n        return sb.toString();\\n    }\\n\\n    private StringBuilder getNextState(StringBuilder curSb) {\\n        StringBuilder nextSb = new StringBuilder();\\n        int len = curSb.length();\\n        int i = 0;\\n\\t\\t\\n        while (i < len) {\\n            char c = curSb.charAt(i++);\\n            int count = 1;\\n            while (i < len && c == curSb.charAt(i)) {\\n                count++;\\n                i++;\\n            }\\n            nextSb.append(count).append(c);\\n        }\\n\\t\\t\\n        return nextSb;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16413,
                "title": "16-line-clean-recursion-c-solution",
                "content": "    class Solution {\\n    public:\\n        string countAndSay(int n) {\\n            if(n==1) return \"1\"; // base case\\n            string res,tmp = countAndSay(n-1); // recursion\\n            char c= tmp[0];\\n            int count=1;\\n            for(int i=1;i<tmp.size();i++)\\n                if(tmp[i]==c)\\n                    count++;\\n                else {\\n                    res+=to_string(count);\\n                    res.push_back(c);\\n                    c=tmp[i];\\n                    count=1;\\n                }\\n            res+=to_string(count);\\n            res.push_back(c);\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        string countAndSay(int n) {\\n            if(n==1) return \"1\"; // base case\\n            string res,tmp = countAndSay(n-1); // recursion\\n            char c= tmp[0];\\n            int count=1;\\n            for(int i=1;i<tmp.size();i++)\\n                if(tmp[i]==c)\\n                    count++;\\n                else {\\n                    res+=to_string(count);\\n                    res.push_back(c);\\n                    c=tmp[i];\\n                    count=1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2716528,
                "title": "easiest-way-to-solve-this-problem-13-line-of-code-only",
                "content": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if(n==1):\\n            return(\"1\")\\n        x=self.countAndSay(n-1)\\n        i=0\\n        s=\"\"\\n        while(i<len(x)):\\n            ch=x[i]\\n            ns=0\\n            while(i<len(x) and x[i]==ch):\\n                ns+=1\\n                i+=1\\n            s+=str(ns)\\n            s+=ch\\n        return(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if(n==1):\\n            return(\"1\")\\n        x=self.countAndSay(n-1)\\n        i=0\\n        s=\"\"\\n        while(i<len(x)):\\n            ch=x[i]\\n            ns=0\\n            while(i<len(x) and x[i]==ch):\\n                ns+=1\\n                i+=1\\n            s+=str(ns)\\n            s+=ch\\n        return(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716511,
                "title": "easy-python-solution-recursive-approach",
                "content": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n==1:\\n            return \"1\"\\n        x=self.countAndSay(n-1)\\n        s=\"\"\\n        y=x[0]\\n        ct=1\\n        for i in range(1,len(x)):\\n            if x[i]==y:\\n                ct+=1\\n            else:\\n                s+=str(ct)\\n                s+=str(y)\\n                y=x[i]\\n                ct=1\\n        s+=str(ct)\\n        s+=str(y)\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n==1:\\n            return \"1\"\\n        x=self.countAndSay(n-1)\\n        s=\"\"\\n        y=x[0]\\n        ct=1\\n        for i in range(1,len(x)):\\n            if x[i]==y:\\n                ct+=1\\n            else:\\n                s+=str(ct)\\n                s+=str(y)\\n                y=x[i]\\n                ct=1\\n        s+=str(ct)\\n        s+=str(y)\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379255,
                "title": "javascript-regex-solution-with-explainative-comments",
                "content": "```\\nvar countAndSay = function(n) {\\n    let res = \\'1\\';\\n    for (let i = 1; i < n; i++) {\\n\\t\\t// let say at the beginning of the loop we have \\'11222333\\' (two 1s three 2s three 3s)\\n\\t\\t\\n        res = res.replace(/((\\\\d)\\\\2*)/g, \\'$1-\\')                        \\n\\t\\t\\t\\t // after the replacement we have: \\'11-222-333-\\'\\n                 .split(\\'-\\')                                                        \\n\\t\\t\\t\\t // we have: [ \\'11\\', \\'222\\', \\'333\\', \\'\\' ]\\n                 .map(str => str ? `${str.length}${str[0]}` : \\'\\') \\n\\t\\t\\t\\t // [ \\'21\\', \\'32\\', \\'33\\', \\'\\' ]\\n                 .join(\\'\\');                                                       \\n\\t\\t\\t\\t // \\'213232\\' (what we want)\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countAndSay = function(n) {\\n    let res = \\'1\\';\\n    for (let i = 1; i < n; i++) {\\n\\t\\t// let say at the beginning of the loop we have \\'11222333\\' (two 1s three 2s three 3s)\\n\\t\\t\\n        res = res.replace(/((\\\\d)\\\\2*)/g, \\'$1-\\')                        \\n\\t\\t\\t\\t // after the replacement we have: \\'11-222-333-\\'\\n                 .split(\\'-\\')                                                        \\n\\t\\t\\t\\t // we have: [ \\'11\\', \\'222\\', \\'333\\', \\'\\' ]\\n                 .map(str => str ? `${str.length}${str[0]}` : \\'\\') \\n\\t\\t\\t\\t // [ \\'21\\', \\'32\\', \\'33\\', \\'\\' ]\\n                 .join(\\'\\');                                                       \\n\\t\\t\\t\\t // \\'213232\\' (what we want)\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 254369,
                "title": "clean-short-java-solution",
                "content": "```java\\npublic String countAndSay(int n) {\\n\\tif(n == 1) return \"1\";\\n\\n\\tStringBuilder res = new StringBuilder();\\n\\n\\tString s = countAndSay(n-1) + \"0\"; \\n\\tfor(int i=0, c=1; i < s.length()-1; i++, c++){\\n\\t\\tif(s.charAt(i+1) != s.charAt(i)){\\n\\t\\t\\tres.append(c).append(s.charAt(i));\\n\\t\\t\\tc = 0;  \\n\\t\\t}\\n\\t}\\n\\n\\treturn res.toString();\\n}\\n```\\n\\n \\n .\\n .\\n .\\n .\\n \\n \\n\\nWith comments:\\n\\n```java\\n// for the nth number, you just need to count characters of the (n-1)th number,\\n// for the (n-1)th number, you just need to count characters of  the (n-2)th number,\\n// ...\\n\\npublic String countAndSay(int n) {\\n\\tif(n == 1) return \"1\";\\n\\n\\tStringBuilder res = new StringBuilder();\\n\\n\\t// recursively call for (n-1) th number, \"0\" is only for the edge case at the end of the loop with `s.charAt(i+1)`\\n\\tString s = countAndSay(n-1) + \"0\"; \\n\\n\\tfor(int i=0, c=1; i < s.length()-1; i++, c++){\\n\\t\\t// if next digit is different, then append the count so far `c` and the digit itself, then set count `c` to zero\\n\\t\\tif(s.charAt(i+1) != s.charAt(i)){\\n\\t\\t\\tres.append(c).append(s.charAt(i));\\n\\t\\t\\tc = 0;  \\n\\t\\t}\\n\\t}\\n\\n\\treturn res.toString();\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic String countAndSay(int n) {\\n\\tif(n == 1) return \"1\";\\n\\n\\tStringBuilder res = new StringBuilder();\\n\\n\\tString s = countAndSay(n-1) + \"0\"; \\n\\tfor(int i=0, c=1; i < s.length()-1; i++, c++){\\n\\t\\tif(s.charAt(i+1) != s.charAt(i)){\\n\\t\\t\\tres.append(c).append(s.charAt(i));\\n\\t\\t\\tc = 0;  \\n\\t\\t}\\n\\t}\\n\\n\\treturn res.toString();\\n}\\n```\n```java\\n// for the nth number, you just need to count characters of the (n-1)th number,\\n// for the (n-1)th number, you just need to count characters of  the (n-2)th number,\\n// ...\\n\\npublic String countAndSay(int n) {\\n\\tif(n == 1) return \"1\";\\n\\n\\tStringBuilder res = new StringBuilder();\\n\\n\\t// recursively call for (n-1) th number, \"0\" is only for the edge case at the end of the loop with `s.charAt(i+1)`\\n\\tString s = countAndSay(n-1) + \"0\"; \\n\\n\\tfor(int i=0, c=1; i < s.length()-1; i++, c++){\\n\\t\\t// if next digit is different, then append the count so far `c` and the digit itself, then set count `c` to zero\\n\\t\\tif(s.charAt(i+1) != s.charAt(i)){\\n\\t\\t\\tres.append(c).append(s.charAt(i));\\n\\t\\t\\tc = 0;  \\n\\t\\t}\\n\\t}\\n\\n\\treturn res.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 642001,
                "title": "javascript-100-runtime-super-easy-recursive",
                "content": "```\\nvar countAndSay = function(n) {\\n    if (n === 1) return \\'1\\';\\n    \\n    return countAndSay(n-1)\\n        .match(/1+|2+|3+/g)\\n        .reduce((acc, nums) => acc += `${nums.length}${nums[0]}`, \\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar countAndSay = function(n) {\\n    if (n === 1) return \\'1\\';\\n    \\n    return countAndSay(n-1)\\n        .match(/1+|2+|3+/g)\\n        .reduce((acc, nums) => acc += `${nums.length}${nums[0]}`, \\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16113,
                "title": "how-to-proof-the-count-is-always-less-than-10",
                "content": "At first, I solved this problem with the considering of the cases when COUNT is greater than 9, which can not be handled using:`curString +=count+'0';`, since it is more than one digit. And I solved it using `itoa`. But when I thinked about the problem, it seems that the COUNT is always less than 10, even 4. Then I re-writed the solution and also accepted by OJ.\\n\\nCan you guys help me proof it?\\nMy code:\\n\\n    class Solution {\\n    public:\\n        string countAndSay(int n) {\\n    \\t\\tstring prevString;\\n    \\t\\tstring curString = \"1\";\\n    \\t\\tfor (int i = 1; i<n; ++i){\\n    \\t\\t\\tprevString = curString;\\n    \\t\\t\\tcurString = \"\";\\n    \\t\\t\\tint count = 1;\\n    \\t\\t\\tchar digit = prevString[0];\\n    \\t\\t\\tfor (int j = 1; j<prevString.length(); ++j){\\n    \\t\\t\\t\\tif (prevString[j] == digit){\\n    \\t\\t\\t\\t\\t++count;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\telse{\\n    \\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t\\tcurString +=count+'0'; //myItoa(count);\\n    \\t\\t\\t\\t\\tcurString += digit;\\n    \\t\\t\\t\\t\\tdigit = prevString[j];\\n    \\t\\t\\t\\t\\tcount = 1;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t\\tcurString += count+'0';//myItoa(count);\\n    \\t\\t\\tcurString += digit;\\n    \\t\\t}\\n    \\t\\treturn curString;\\n        }\\n    /*private:\\n    \\tstring myItoa(int i){\\n    \\t\\tstring str;\\n    \\t\\twhile (i){\\n    \\t\\t\\tstr += i%10+'0';\\n    \\t\\t\\ti /=10;\\n    \\t\\t}\\n    \\t\\treverse(str.begin(), str.end());\\n    \\t\\treturn str;\\n    \\t}*/\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string countAndSay(int n) {\\n    \\t\\tstring prevString;\\n    \\t\\tstring curString = \"1\";\\n    \\t\\tfor (int i = 1; i<n; ++i){\\n    \\t\\t\\tprevString = curString;\\n    \\t\\t\\tcurString = \"\";\\n    \\t\\t\\tint count = 1;\\n    \\t\\t\\tchar digit = prevString[0];\\n    \\t\\t\\tfor (int j = 1; j<prevString.length(); ++j){\\n    \\t\\t\\t\\tif (prevString[j] == digit){\\n    \\t\\t\\t\\t\\t++count;\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 172315,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def countAndSay(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        if n == 1:\\n            return \"1\"\\n        prev = \"1\"\\n        res = \"\"\\n        for i in range(1, n):\\n            count = 1\\n            for j in range(len(prev)-1):\\n                if prev[j] == prev[j+1]:\\n                    count += 1\\n                else:\\n                    res += str(count)+prev[j]\\n                    count = 1\\n            res += str(count)+prev[-1]\\n            prev = res\\n            res = \"\"\\n        return prev\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def countAndSay(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        if n == 1:\\n            return \"1\"\\n        prev = \"1\"\\n        res = \"\"\\n        for i in range(1, n):\\n            count = 1\\n            for j in range(len(prev)-1):\\n                if prev[j] == prev[j+1]:\\n                    count += 1\\n                else:\\n                    res += str(count)+prev[j]\\n                    count = 1\\n            res += str(count)+prev[-1]\\n            prev = res\\n            res = \"\"\\n        return prev\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716712,
                "title": "java-4-solutions",
                "content": "# 4.regulation\\n```\\n    //4.regulation\\n    //Runtime: 26 ms, faster than 35.45% of Java online submissions for Count and Say.\\n    //Memory Usage: 42.9 MB, less than 44.11% of Java online submissions for Count and Say.\\n    public String countAndSay(int n) {\\n        StringBuilder currStr = new StringBuilder(\"1\");\\n        Pattern pattern = Pattern.compile(\"(.)\\\\\\\\1*\");\\n        for (int i = 1; i < n; ++i) {\\n            Matcher m = pattern.matcher(currStr);\\n            StringBuilder sb = new StringBuilder();\\n            while (m.find())\\n                sb.append(m.group().length() + String.valueOf(m.group().charAt(0)));\\n            currStr = sb;\\n        }\\n        return currStr.toString();\\n    }\\n```\\n# 3.iteration\\n```\\n    //3.iteration\\n    //Runtime: 9 ms, faster than 56.22% of Java online submissions for Count and Say.\\n    //Memory Usage: 41.3 MB, less than 86.39% of Java online submissions for Count and Say.\\n    public String countAndSay_3(int n) {\\n        StringBuilder currStr = new StringBuilder(\"1\");\\n\\n        for (int k = 0; k < n - 1; k++) {\\n            StringBuilder sb = new StringBuilder();\\n            int count = 1;\\n            for (int i = 1; i < currStr.length(); i++) {\\n                if (currStr.charAt(i) == currStr.charAt(i - 1)) count++;\\n                else{\\n                    sb.append(count).append(currStr.charAt(i - 1));\\n                    count = 1;\\n                }\\n            }\\n            sb.append(count).append(currStr.charAt(currStr.length()-1));\\n            currStr = sb;\\n        }\\n        return currStr.toString();\\n    }\\n```\\n# 2.recursion\\n```\\n    //2.recursion\\n    //Runtime: 3 ms, faster than 93.92% of Java online submissions for Count and Say.\\n    //Memory Usage: 41.4 MB, less than 83.82% of Java online submissions for Count and Say.\\n    public String countAndSay_2(int n) {\\n        if (n == 1) return \"1\";\\n        String s = countAndSay_2(n - 1);\\n\\n        //say\\n        StringBuilder sb = new StringBuilder();\\n        int count = 1;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) == s.charAt(i - 1)) count++;\\n            else{\\n                sb.append(count).append(s.charAt(i - 1));\\n                count = 1;\\n            }\\n        }\\n        sb.append(count).append(s.charAt(s.length() - 1));\\n        return sb.toString();\\n    }\\n```\\n# 1.two helpers\\n```\\n    //1.two helpers\\n    //Runtime: 11 ms, faster than 51.50% of Java online submissions for Count and Say.\\n    //Memory Usage: 46.9 MB, less than 30.84% of Java online submissions for Count and Say.\\n    // Time: O(4^(n/3))\\n    public String countAndSay_1(int n) {\\n        if (n == 1) return \"1\";\\n        String x = \"1\";\\n        for (int i = 0; i < n - 1; i++)\\n            x = helper_say(helper_count(x));\\n        return x;\\n    }\\n\\n    private List<String[]> helper_count(String s){\\n        List<String[]> list = new ArrayList<>();\\n\\n        int count = 1;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) == s.charAt(i - 1)) count++;\\n            else{\\n                list.add(new String[]{String.valueOf(s.charAt(i - 1)), String.valueOf(count)});\\n                count = 1;\\n            }\\n        }\\n        list.add(new String[]{String.valueOf(s.charAt(s.length() - 1)), String.valueOf(count)});\\n        return list;\\n    }\\n\\n    private String helper_say(List<String[]> list){\\n        StringBuilder sb = new StringBuilder();\\n        for (String[] node: list)\\n            sb.append(node[1]).append(node[0]);\\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    //4.regulation\\n    //Runtime: 26 ms, faster than 35.45% of Java online submissions for Count and Say.\\n    //Memory Usage: 42.9 MB, less than 44.11% of Java online submissions for Count and Say.\\n    public String countAndSay(int n) {\\n        StringBuilder currStr = new StringBuilder(\"1\");\\n        Pattern pattern = Pattern.compile(\"(.)\\\\\\\\1*\");\\n        for (int i = 1; i < n; ++i) {\\n            Matcher m = pattern.matcher(currStr);\\n            StringBuilder sb = new StringBuilder();\\n            while (m.find())\\n                sb.append(m.group().length() + String.valueOf(m.group().charAt(0)));\\n            currStr = sb;\\n        }\\n        return currStr.toString();\\n    }\\n```\n```\\n    //3.iteration\\n    //Runtime: 9 ms, faster than 56.22% of Java online submissions for Count and Say.\\n    //Memory Usage: 41.3 MB, less than 86.39% of Java online submissions for Count and Say.\\n    public String countAndSay_3(int n) {\\n        StringBuilder currStr = new StringBuilder(\"1\");\\n\\n        for (int k = 0; k < n - 1; k++) {\\n            StringBuilder sb = new StringBuilder();\\n            int count = 1;\\n            for (int i = 1; i < currStr.length(); i++) {\\n                if (currStr.charAt(i) == currStr.charAt(i - 1)) count++;\\n                else{\\n                    sb.append(count).append(currStr.charAt(i - 1));\\n                    count = 1;\\n                }\\n            }\\n            sb.append(count).append(currStr.charAt(currStr.length()-1));\\n            currStr = sb;\\n        }\\n        return currStr.toString();\\n    }\\n```\n```\\n    //2.recursion\\n    //Runtime: 3 ms, faster than 93.92% of Java online submissions for Count and Say.\\n    //Memory Usage: 41.4 MB, less than 83.82% of Java online submissions for Count and Say.\\n    public String countAndSay_2(int n) {\\n        if (n == 1) return \"1\";\\n        String s = countAndSay_2(n - 1);\\n\\n        //say\\n        StringBuilder sb = new StringBuilder();\\n        int count = 1;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) == s.charAt(i - 1)) count++;\\n            else{\\n                sb.append(count).append(s.charAt(i - 1));\\n                count = 1;\\n            }\\n        }\\n        sb.append(count).append(s.charAt(s.length() - 1));\\n        return sb.toString();\\n    }\\n```\n```\\n    //1.two helpers\\n    //Runtime: 11 ms, faster than 51.50% of Java online submissions for Count and Say.\\n    //Memory Usage: 46.9 MB, less than 30.84% of Java online submissions for Count and Say.\\n    // Time: O(4^(n/3))\\n    public String countAndSay_1(int n) {\\n        if (n == 1) return \"1\";\\n        String x = \"1\";\\n        for (int i = 0; i < n - 1; i++)\\n            x = helper_say(helper_count(x));\\n        return x;\\n    }\\n\\n    private List<String[]> helper_count(String s){\\n        List<String[]> list = new ArrayList<>();\\n\\n        int count = 1;\\n        for (int i = 1; i < s.length(); i++) {\\n            if (s.charAt(i) == s.charAt(i - 1)) count++;\\n            else{\\n                list.add(new String[]{String.valueOf(s.charAt(i - 1)), String.valueOf(count)});\\n                count = 1;\\n            }\\n        }\\n        list.add(new String[]{String.valueOf(s.charAt(s.length() - 1)), String.valueOf(count)});\\n        return list;\\n    }\\n\\n    private String helper_say(List<String[]> list){\\n        StringBuilder sb = new StringBuilder();\\n        for (String[] node: list)\\n            sb.append(node[1]).append(node[0]);\\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716472,
                "title": "count-and-say-question-explanation-easy-simple-code",
                "content": "If you are not able to crack the question statement, let\\'s understand the pattern through the sequence from n=1 to n=10.\\n```\\n n      val\\n 1.     1                                                  (0 times 1) = 0\\n 2.     11                                                 (1 times 1) = 1\\n 3.     21                                                 (2 times 1) = 2\\n 4.     1211                                                and so on\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.    13211311123113112211\\n```\\nFrom here, we can see that the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nNow let\\'s write the recursive code for this.\\n```\\nstring countAndSay(int n) {\\n        if(n == 1){\\n            return \"1\";\\n        }\\n        string s = countAndSay(n - 1);\\n        string ans = \"\";\\n        for(int i = 0; i<s.size(); i++){\\n            int count = 1;\\n            while(i < (s.size() - 1) and (s[i] == s[i + 1])){\\n                i++;\\n                count++;\\n            }\\n            ans.append(to_string(count) + s[i]);\\n        }\\n        return ans;\\n    }\\n```\\nEasy, right?",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n n      val\\n 1.     1                                                  (0 times 1) = 0\\n 2.     11                                                 (1 times 1) = 1\\n 3.     21                                                 (2 times 1) = 2\\n 4.     1211                                                and so on\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.    13211311123113112211\\n```\n```\\nstring countAndSay(int n) {\\n        if(n == 1){\\n            return \"1\";\\n        }\\n        string s = countAndSay(n - 1);\\n        string ans = \"\";\\n        for(int i = 0; i<s.size(); i++){\\n            int count = 1;\\n            while(i < (s.size() - 1) and (s[i] == s[i + 1])){\\n                i++;\\n                count++;\\n            }\\n            ans.append(to_string(count) + s[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16354,
                "title": "c-solution-runtime-o-n-space-o-n",
                "content": "Please see the comments in the code. \\nThe solution is quite straight-forward. We generate k-th string, and from k-th string we generate k+1-th string, until we generate n-th string.\\nWe use string-helper to save temporary result, \\nI'm sure there is a way for in-place solution also.\\n\\n    class Solution {\\n    public:\\n    \\n        std::string countAndSay(int n) {\\n        \\n        \\tif (0 == n) return \"\";  \\n        \\tif (1 == n) return \"1\";\\n        \\t\\n        \\tstd::string res=\"1\";\\n        \\tstd::string s;\\n        \\n        \\tfor (int i = 1; i < n; i++){    // run from starting to generate second string\\n        \\n        \\t\\tint len = res.size();\\n                \\n                //cheack all digits in the string\\n        \\t\\tfor (int j = 0; j < len; j++){  \\n        \\t\\t    \\n        \\t\\t    int count=1; // we have at least 1 occourence of each digit\\n        \\n                    // get the number of times same digit occurred (be carefull with the end of the string)\\n    \\t\\t\\t\\twhile ((j + 1 < len) && (res[j] == res[j + 1])){\\n    \\t\\t\\t\\t\\tcount++;    \\n    \\t\\t\\t\\t\\tj++;        // we need to keep increasing the index inside of the string\\n    \\t\\t\\t\\t}\\n                    \\n                    // add to new string \"count\"+\"digit itself\"\\n        \\t\\t\\ts += std::to_string(count) + res[j];\\n        \\t\\t}\\n        \\n                // save temporary result\\n        \\t\\tres = s;\\n        \\t\\t\\n        \\t\\t// clean our string-helper\\n        \\t\\ts.clear();\\n        \\n        \\t}\\n        \\n        \\treturn res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\n        std::string countAndSay(int n) {\\n        \\n        \\tif (0 == n) return \"\";  \\n        \\tif (1 == n) return \"1\";\\n        \\t\\n        \\tstd::string res=\"1\";\\n        \\tstd::string s;\\n        \\n        \\tfor (int i = 1; i < n; i++){    // run from starting to generate second string\\n        \\n        \\t\\tint len = res.size();\\n                \\n                //cheack all digits in the string\\n        \\t\\tfor (int j = 0; j < len; j++){  \\n        \\t\\t    \\n        \\t\\t    int count=1; // we have at least 1 occourence of each digit\\n        \\n                    // get the number of times same digit occurred (be carefull with the end of the string)\\n    \\t\\t\\t\\twhile ((j + 1 < len) && (res[j] == res[j + 1])){\\n    \\t\\t\\t\\t\\tcount++;    \\n    \\t\\t\\t\\t\\tj++;        // we need to keep increasing the index inside of the string\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1312932,
                "title": "java-recursive-easy-solution-with-explaination",
                "content": "class Solution {\\n\\n\\t\\tpublic String countAndSay(int n){ \\n\\t\\t\\tif(n == 1) return \"1\";  //if n==1 simply return \"1\"\\n\\t\\t\\t\\n\\t\\t\\tString s = countAndSay(n-1);  // else make recursive calls until n==1\\n\\t\\t\\t\\n\\t\\t\\tStringBuilder str = new StringBuilder(); // create string builder or string buffer object for easy mutations\\n\\t\\t\\t\\n\\t\\t\\tint count = 1 , i = 0; // count of every character is atleast 1 so take count as 1\\n\\t\\t\\t\\n\\t\\t\\twhile(i < s.length()){ // main loop\\n\\t\\t\\t\\n\\t\\t\\t\\tchar ch = s.charAt(i++); // store charcter at i and increment i\\n\\t\\t\\t\\t\\n\\t\\t\\t\\twhile(i < s.length() && s.charAt(i) == ch){ // create a loop to count the number of adjacent characters in string\\n\\t\\t\\t\\t\\ti++;    count++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tstr.append(count).append(ch); // add count and current character to str\\n\\t\\t\\t\\tcount = 1; // reset count to 1\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\treturn str.toString(); // return str as string\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\n\\t\\tpublic String countAndSay(int n){ \\n\\t\\t\\tif(n == 1) return \"1\";  //if n==1 simply return \"1\"\\n\\t\\t\\t\\n\\t\\t\\tString s = countAndSay(n-1);  // else make recursive calls until n==1\\n\\t\\t\\t\\n\\t\\t\\tStringBuilder str = new StringBuilder(); // create string builder or string buffer object for easy mutations\\n\\t\\t\\t\\n\\t\\t\\tint count = 1 , i = 0; // count of every character is atleast 1 so take count as 1\\n\\t\\t\\t\\n\\t\\t\\twhile(i < s.length()){ // main loop\\n\\t\\t\\t\\n\\t\\t\\t\\tchar ch = s.charAt(i++); // store charcter at i and increment i\\n\\t\\t\\t\\t\\n\\t\\t\\t\\twhile(i < s.length() && s.charAt(i) == ch){ // create a loop to count the number of adjacent characters in string\\n\\t\\t\\t\\t\\ti++;    count++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1546382,
                "title": "java-simple-iterative-solution-generating-all-states-from-1-to-n",
                "content": "```java\\n/**\\n * Find each state starting from 1st to nth.\\n * \\n * Time Complexity: O(L(1) + L(2) + L(3) + ... + L(N-1) + L(N))\\n *\\n * Space Complexity: O(L(N-1) + L(N))\\n *\\n * N = Input number. L(N) = Length of Nth state\\n */\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if (n <= 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        StringBuilder sb = new StringBuilder(\"1\");\\n        for (int i = 2; i <= n; i++) {\\n            sb = getNextState(sb);\\n        }\\n        return sb.toString();\\n    }\\n\\n    private StringBuilder getNextState(StringBuilder curSb) {\\n        StringBuilder nextSb = new StringBuilder();\\n        int len = curSb.length();\\n        int i = 0;\\n\\t\\t\\n        while (i < len) {\\n            char c = curSb.charAt(i++);\\n            int count = 1;\\n            while (i < len && c == curSb.charAt(i)) {\\n                count++;\\n                i++;\\n            }\\n            nextSb.append(count).append(c);\\n        }\\n\\t\\t\\n        return nextSb;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Iterator"
                ],
                "code": "```java\\n/**\\n * Find each state starting from 1st to nth.\\n * \\n * Time Complexity: O(L(1) + L(2) + L(3) + ... + L(N-1) + L(N))\\n *\\n * Space Complexity: O(L(N-1) + L(N))\\n *\\n * N = Input number. L(N) = Length of Nth state\\n */\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if (n <= 0) {\\n            throw new IllegalArgumentException(\"Invalid input\");\\n        }\\n\\n        StringBuilder sb = new StringBuilder(\"1\");\\n        for (int i = 2; i <= n; i++) {\\n            sb = getNextState(sb);\\n        }\\n        return sb.toString();\\n    }\\n\\n    private StringBuilder getNextState(StringBuilder curSb) {\\n        StringBuilder nextSb = new StringBuilder();\\n        int len = curSb.length();\\n        int i = 0;\\n\\t\\t\\n        while (i < len) {\\n            char c = curSb.charAt(i++);\\n            int count = 1;\\n            while (i < len && c == curSb.charAt(i)) {\\n                count++;\\n                i++;\\n            }\\n            nextSb.append(count).append(c);\\n        }\\n\\t\\t\\n        return nextSb;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565435,
                "title": "easy-to-understand-javascript",
                "content": "Recursive:\\n```\\nconst countAndSay = (n, str = \\'1\\') => {\\n  if (n === 1) {\\n    return str;\\n  }\\n  let newStr = \\'\\',\\n    count = 0,\\n    say = str[0];\\n  for (let i = 0; i < str.length; i += 1) {\\n    if (str[i] === say) {\\n      count += 1;\\n    } else {\\n      newStr += count + say;\\n      count = 1;\\n      say = str[i];\\n    }\\n  }\\n  return countAndSay(n - 1, newStr + count + say);\\n};\\n```\\nIterative:\\n```\\nconst countAndSay = n => {\\n  let str = \\'1\\';\\n  while (n > 1) {\\n    let newStr = \\'\\',\\n      count = 0,\\n      say = str[0];\\n    for (let i = 0; i < str.length; i += 1) {\\n      if (str[i] === say) {\\n        count += 1;\\n      } else {\\n        newStr += count + say;\\n        count = 1;\\n        say = str[i];\\n      }\\n    }\\n    str = newStr + count + say;\\n    n -= 1;\\n  }\\n  return str;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nconst countAndSay = (n, str = \\'1\\') => {\\n  if (n === 1) {\\n    return str;\\n  }\\n  let newStr = \\'\\',\\n    count = 0,\\n    say = str[0];\\n  for (let i = 0; i < str.length; i += 1) {\\n    if (str[i] === say) {\\n      count += 1;\\n    } else {\\n      newStr += count + say;\\n      count = 1;\\n      say = str[i];\\n    }\\n  }\\n  return countAndSay(n - 1, newStr + count + say);\\n};\\n```\n```\\nconst countAndSay = n => {\\n  let str = \\'1\\';\\n  while (n > 1) {\\n    let newStr = \\'\\',\\n      count = 0,\\n      say = str[0];\\n    for (let i = 0; i < str.length; i += 1) {\\n      if (str[i] === say) {\\n        count += 1;\\n      } else {\\n        newStr += count + say;\\n        count = 1;\\n        say = str[i];\\n      }\\n    }\\n    str = newStr + count + say;\\n    n -= 1;\\n  }\\n  return str;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 406880,
                "title": "super-fast-solution",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\n\\nvar list = {\\n  \"0\": \"1\",\\n  \"1\": \"1\",\\n  \"2\": \"11\",\\n  \"3\": \"21\",\\n  \"4\": \"1211\",\\n  \"5\": \"111221\",\\n  \"6\": \"312211\",\\n  \"7\": \"13112221\",\\n  \"8\": \"1113213211\",\\n  \"9\": \"31131211131221\",\\n  \"10\": \"13211311123113112211\",\\n  \"11\": \"11131221133112132113212221\",\\n  \"12\": \"3113112221232112111312211312113211\",\\n  \"13\": \"1321132132111213122112311311222113111221131221\",\\n  \"14\": \"11131221131211131231121113112221121321132132211331222113112211\",\\n  \"15\": \"311311222113111231131112132112311321322112111312211312111322212311322113212221\",\\n  \"16\": \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\",\\n  \"17\": \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\",\\n  \"18\": \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\",\\n  \"19\": \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\",\\n  \"20\": \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\",\\n  \"21\": \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\",\\n  \"22\": \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\",\\n  \"23\": \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\",\\n  \"24\": \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\",\\n  \"25\": \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\",\\n  \"26\": \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\",\\n  \"27\": \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\",\\n  \"28\": \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\",\\n  \"29\": \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\",\\n  \"30\": \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n}\\n\\nvar countAndSay = function(n) {\\n  return list[n]\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\n\\nvar list = {\\n  \"0\": \"1\",\\n  \"1\": \"1\",\\n  \"2\": \"11\",\\n  \"3\": \"21\",\\n  \"4\": \"1211\",\\n  \"5\": \"111221\",\\n  \"6\": \"312211\",\\n  \"7\": \"13112221\",\\n  \"8\": \"1113213211\",\\n  \"9\": \"31131211131221\",\\n  \"10\": \"13211311123113112211\",\\n  \"11\": \"11131221133112132113212221\",\\n  \"12\": \"3113112221232112111312211312113211\",\\n  \"13\": \"1321132132111213122112311311222113111221131221\",\\n  \"14\": \"11131221131211131231121113112221121321132132211331222113112211\",\\n  \"15\": \"311311222113111231131112132112311321322112111312211312111322212311322113212221\",\\n  \"16\": \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\",\\n  \"17\": \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\",\\n  \"18\": \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\",\\n  \"19\": \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\",\\n  \"20\": \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\",\\n  \"21\": \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\",\\n  \"22\": \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\",\\n  \"23\": \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\",\\n  \"24\": \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\",\\n  \"25\": \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\",\\n  \"26\": \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\",\\n  \"27\": \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\",\\n  \"28\": \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\",\\n  \"29\": \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\",\\n  \"30\": \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n}\\n\\nvar countAndSay = function(n) {\\n  return list[n]\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716238,
                "title": "java-100-0ms-4-different-solutions-w-video-explanation",
                "content": "*Please **Upvote** if you find the Explanation helpful*\\n\\n**Video Explanation**\\n[Count and Say | YouTube](https://www.youtube.com/watch?v=7ZvswJFUl5M&feature=youtu.be)\\n\\n**Java Solution**\\n```\\n//3ms\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String s = \"1\";\\n        for(int i=2;i<=n;i++){\\n            s = countIndex(s);\\n        }\\n        return s;\\n    }\\n    \\n    public String countIndex(String s){\\n        StringBuilder sb = new StringBuilder();\\n        char c = s.charAt(0);\\n        int count = 1;\\n        for(int i=1;i<s.length();i++){\\n            if(s.charAt(i) == c)\\n                count++;\\n            else{\\n                sb.append(count);\\n                sb.append(c);\\n                c = s.charAt(i);\\n                count=1;\\n            }\\n        }\\n        sb.append(count);\\n        sb.append(c);\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n\\n*Using Recursion*\\n```\\n//2ms\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n == 1) return \"1\";\\n        String s = countAndSay(n-1);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        char ch = \\'!\\';\\n        int num = 0;\\n        int i = 0;\\n        while(i<s.length()){\\n            if(s.charAt(i)!=ch){\\n                if(num>0){\\n                    sb.append(num);\\n                    sb.append(ch);\\n                }        \\n                num = 0;\\n                ch = s.charAt(i);\\n            }\\n            num++;\\n            i++;\\n        }\\n        sb.append(num);\\n        sb.append(ch);\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n*Using HashMap*\\n```\\n//1ms\\nclass Solution {\\n     private static final Map<Integer, String> resultsCache = new HashMap<>();\\n\\n        public String countAndSay(int n) {\\n            if(resultsCache.containsKey(n)) {\\n                return resultsCache.get(n);\\n            }\\n\\n            if (n == 1) {\\n                return \"1\";\\n            }\\n\\n            String result = say(countAndSay(n - 1));\\n            resultsCache.put(n, result);\\n            return  result;\\n        }\\n\\n        private String say(String number) {\\n            int currentIndex = 0;\\n            StringBuilder result = new StringBuilder();\\n            while (currentIndex <= number.length() - 1) {\\n                int nextIndex = findNextDifferentIndex(number, currentIndex);\\n\\n                result.append(nextIndex - currentIndex);\\n                result.append(number.charAt(currentIndex));\\n\\n                currentIndex = nextIndex;\\n            }\\n\\n            return result.toString();\\n        }\\n\\n        private int findNextDifferentIndex(String number, int index) {\\n            char currentDigit = number.charAt(index);\\n            int currentIndex = index;\\n            while (currentIndex <= number.length() -1) {\\n                currentIndex = currentIndex + 1;\\n                if (currentIndex == number.length() || currentDigit != number.charAt(currentIndex)) {\\n                    return currentIndex;\\n                }\\n            }\\n\\n            return number.length() - 1;\\n        }\\n}\\n```\\n\\n\\n*Kind of the worst approach*\\n```\\n//0ms\\nclass Solution {\\n    public String countAndSay(int n) {\\n        return new String[]{\"1\", \"11\", \"21\", \"1211\", \"111221\", \"312211\", \"13112221\", \"1113213211\", \"31131211131221\", \"13211311123113112211\", \"11131221133112132113212221\", \"3113112221232112111312211312113211\", \"1321132132111213122112311311222113111221131221\", \"11131221131211131231121113112221121321132132211331222113112211\", \"311311222113111231131112132112311321322112111312211312111322212311322113212221\", \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\", \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\", \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\", \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\", \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\", \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\",\"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"}\\n[n - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n//3ms\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String s = \"1\";\\n        for(int i=2;i<=n;i++){\\n            s = countIndex(s);\\n        }\\n        return s;\\n    }\\n    \\n    public String countIndex(String s){\\n        StringBuilder sb = new StringBuilder();\\n        char c = s.charAt(0);\\n        int count = 1;\\n        for(int i=1;i<s.length();i++){\\n            if(s.charAt(i) == c)\\n                count++;\\n            else{\\n                sb.append(count);\\n                sb.append(c);\\n                c = s.charAt(i);\\n                count=1;\\n            }\\n        }\\n        sb.append(count);\\n        sb.append(c);\\n        return sb.toString();\\n    }\\n}\\n```\n```\\n//2ms\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n == 1) return \"1\";\\n        String s = countAndSay(n-1);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        char ch = \\'!\\';\\n        int num = 0;\\n        int i = 0;\\n        while(i<s.length()){\\n            if(s.charAt(i)!=ch){\\n                if(num>0){\\n                    sb.append(num);\\n                    sb.append(ch);\\n                }        \\n                num = 0;\\n                ch = s.charAt(i);\\n            }\\n            num++;\\n            i++;\\n        }\\n        sb.append(num);\\n        sb.append(ch);\\n        return sb.toString();\\n    }\\n}\\n```\n```\\n//1ms\\nclass Solution {\\n     private static final Map<Integer, String> resultsCache = new HashMap<>();\\n\\n        public String countAndSay(int n) {\\n            if(resultsCache.containsKey(n)) {\\n                return resultsCache.get(n);\\n            }\\n\\n            if (n == 1) {\\n                return \"1\";\\n            }\\n\\n            String result = say(countAndSay(n - 1));\\n            resultsCache.put(n, result);\\n            return  result;\\n        }\\n\\n        private String say(String number) {\\n            int currentIndex = 0;\\n            StringBuilder result = new StringBuilder();\\n            while (currentIndex <= number.length() - 1) {\\n                int nextIndex = findNextDifferentIndex(number, currentIndex);\\n\\n                result.append(nextIndex - currentIndex);\\n                result.append(number.charAt(currentIndex));\\n\\n                currentIndex = nextIndex;\\n            }\\n\\n            return result.toString();\\n        }\\n\\n        private int findNextDifferentIndex(String number, int index) {\\n            char currentDigit = number.charAt(index);\\n            int currentIndex = index;\\n            while (currentIndex <= number.length() -1) {\\n                currentIndex = currentIndex + 1;\\n                if (currentIndex == number.length() || currentDigit != number.charAt(currentIndex)) {\\n                    return currentIndex;\\n                }\\n            }\\n\\n            return number.length() - 1;\\n        }\\n}\\n```\n```\\n//0ms\\nclass Solution {\\n    public String countAndSay(int n) {\\n        return new String[]{\"1\", \"11\", \"21\", \"1211\", \"111221\", \"312211\", \"13112221\", \"1113213211\", \"31131211131221\", \"13211311123113112211\", \"11131221133112132113212221\", \"3113112221232112111312211312113211\", \"1321132132111213122112311311222113111221131221\", \"11131221131211131231121113112221121321132132211331222113112211\", \"311311222113111231131112132112311321322112111312211312111322212311322113212221\", \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\", \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\", \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\", \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\", \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\", \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\",\"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"}\\n[n - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716132,
                "title": "java-0ms-solution",
                "content": "# Upote if you like the solution\\n\\n\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        return new String[]{\"1\", \"11\", \"21\", \"1211\", \"111221\", \"312211\", \"13112221\", \"1113213211\", \"31131211131221\", \"13211311123113112211\", \"11131221133112132113212221\", \"3113112221232112111312211312113211\", \"1321132132111213122112311311222113111221131221\", \"11131221131211131231121113112221121321132132211331222113112211\", \"311311222113111231131112132112311321322112111312211312111322212311322113212221\", \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\", \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\", \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\", \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\", \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\", \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"}\\n[n - 1];\\n    }}\\n```\\n\\n\\n# IF THE SOLUTION WORKED FOR YOU PLEASE UPVOTE IT............",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        return new String[]{\"1\", \"11\", \"21\", \"1211\", \"111221\", \"312211\", \"13112221\", \"1113213211\", \"31131211131221\", \"13211311123113112211\", \"11131221133112132113212221\", \"3113112221232112111312211312113211\", \"1321132132111213122112311311222113111221131221\", \"11131221131211131231121113112221121321132132211331222113112211\", \"311311222113111231131112132112311321322112111312211312111322212311322113212221\", \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\", \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\", \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\", \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\", \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\", \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\", \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\", \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\", \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\", \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"}\\n[n - 1];\\n    }}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905788,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func countAndSay(_ n: Int) -> String {\\n        func helper(_ s: String, _ n: Int) -> String {\\n            guard n > 1 else { return s }\\n            var string = \"\"\\n            var prev: Character?\\n            var count: Int = 1\\n\\n            for c in s {\\n                if let prev = prev {\\n                    if c == prev {\\n                        count += 1\\n                    } else {\\n                        string += \"\\\\(count)\\\\(prev)\"\\n                        count = 1\\n                    }\\n                }\\n                prev = c\\n            }\\n            string += \"\\\\(count)\\\\(prev!)\"\\n            return helper(string, n - 1)\\n        }\\n\\n        return helper(\"1\", n)\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countAndSay(_ n: Int) -> String {\\n        func helper(_ s: String, _ n: Int) -> String {\\n            guard n > 1 else { return s }\\n            var string = \"\"\\n            var prev: Character?\\n            var count: Int = 1\\n\\n            for c in s {\\n                if let prev = prev {\\n                    if c == prev {\\n                        count += 1\\n                    } else {\\n                        string += \"\\\\(count)\\\\(prev)\"\\n                        count = 1\\n                    }\\n                }\\n                prev = c\\n            }\\n            string += \"\\\\(count)\\\\(prev!)\"\\n            return helper(string, n - 1)\\n        }\\n\\n        return helper(\"1\", n)\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367155,
                "title": "c-simple-clean-and-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        string res = \"1\", tmp;\\n        n--;\\n        \\n        while (n) {\\n            tmp = \"\";\\n            \\n\\t\\t\\t// Count the number of contiguous same character in previous string to build current string\\n            for (int i = 0; i < res.size(); i++) {\\n                int count = 1;\\n                \\n                while (i + 1 < res.size() && res[i] == res[i+1]) {\\n                    count++; i++;\\n                }\\n                \\n                tmp += to_string(count) + res[i];\\n            }\\n            \\n            res = tmp;\\n            n--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        string res = \"1\", tmp;\\n        n--;\\n        \\n        while (n) {\\n            tmp = \"\";\\n            \\n\\t\\t\\t// Count the number of contiguous same character in previous string to build current string\\n            for (int i = 0; i < res.size(); i++) {\\n                int count = 1;\\n                \\n                while (i + 1 < res.size() && res[i] == res[i+1]) {\\n                    count++; i++;\\n                }\\n                \\n                tmp += to_string(count) + res[i];\\n            }\\n            \\n            res = tmp;\\n            n--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16184,
                "title": "java-easy-to-read-also-fast",
                "content": "    public String countAndSay(int n) {\\n        String ret = \"\"+1;\\n        \\n        while(--n  > 0)\\n            ret = apply(ret);\\n        \\n        return ret;\\n    }\\n    \\n    String apply(String s){\\n        StringBuilder ret = new StringBuilder();\\n        \\n        for(int i = 0, count =0; i  < s.length() ; ){\\n            while(i + count < s.length() && s.charAt(i) == s.charAt(i + count))\\n                count ++;\\n                    \\n            ret.append(count).append(s.charAt(i));\\n            i += count; \\n            count = 0;\\n        }\\n        \\n        return ret.toString();\\n    }",
                "solutionTags": [],
                "code": "    public String countAndSay(int n) {\\n        String ret = \"\"+1;\\n        \\n        while(--n  > 0)\\n            ret = apply(ret);\\n        \\n        return ret;\\n    }\\n    \\n    String apply(String s){\\n        StringBuilder ret = new StringBuilder();\\n        \\n        for(int i = 0, count =0; i  < s.length() ; ){\\n            while(i + count < s.length() && s.charAt(i) == s.charAt(i + count))\\n                count ++;\\n                    \\n            ret.append(count).append(s.charAt(i));\\n            i += count; \\n            count = 0;\\n        }\\n        \\n        return ret.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3780964,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n+k)$$ where k is the variable length of the strings formed.\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n==1)\\n        {\\n            return \"1\";\\n        }\\n        if(n==2)\\n        {\\n            return \"11\";\\n        }\\n        StringBuilder nm=new StringBuilder();\\n        nm.append(\"11\");\\n        for(int i=3;i<=n;i++)\\n        {\\n            StringBuilder kk=new StringBuilder();\\n            task(nm.toString(),kk);\\n            nm.setLength(0);\\n            nm.append(kk);\\n        }\\n        return nm.toString();\\n    }\\n    public void task(String s, StringBuilder nm)\\n    {\\n        int count=1;\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(s.charAt(i) == s.charAt(i+1))\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                nm.append(count);\\n                nm.append(s.charAt(i));\\n                count=1;\\n            }\\n        }\\n        nm.append(count);\\n        nm.append(s.charAt(s.length()-1));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n==1)\\n        {\\n            return \"1\";\\n        }\\n        if(n==2)\\n        {\\n            return \"11\";\\n        }\\n        StringBuilder nm=new StringBuilder();\\n        nm.append(\"11\");\\n        for(int i=3;i<=n;i++)\\n        {\\n            StringBuilder kk=new StringBuilder();\\n            task(nm.toString(),kk);\\n            nm.setLength(0);\\n            nm.append(kk);\\n        }\\n        return nm.toString();\\n    }\\n    public void task(String s, StringBuilder nm)\\n    {\\n        int count=1;\\n        for(int i=0;i<s.length()-1;i++)\\n        {\\n            if(s.charAt(i) == s.charAt(i+1))\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                nm.append(count);\\n                nm.append(s.charAt(i));\\n                count=1;\\n            }\\n        }\\n        nm.append(count);\\n        nm.append(s.charAt(s.length()-1));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654250,
                "title": "easy-c-solution-faster-than-80",
                "content": "```class Solution {\\npublic:\\n    string say(string s){\\n        string ans = \"\";\\n        for(int i = 0; i < s.size(); i++){\\n            int count = 1;\\n            while(i+1 < s.size() && s[i] == s[i+1]){\\n                i++;\\n                count++;\\n            }\\n            ans+=(to_string(count)+s[i]);\\n        }\\n        return ans;\\n    }\\n    string countAndSay(int n) {\\n        if(n == 1) return \"1\";\\n        return say(countAndSay(n-1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```class Solution {\\npublic:\\n    string say(string s){\\n        string ans = \"\";\\n        for(int i = 0; i < s.size(); i++){\\n            int count = 1;\\n            while(i+1 < s.size() && s[i] == s[i+1]){\\n                i++;\\n                count++;\\n            }\\n            ans+=(to_string(count)+s[i]);\\n        }\\n        return ans;\\n    }\\n    string countAndSay(int n) {\\n        if(n == 1) return \"1\";\\n        return say(countAndSay(n-1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 725764,
                "title": "c-naive-approach-easy-to-understand",
                "content": "***Runtime: 4 ms, faster than 86.31% of C++ online submissions for Count and Say.\\nMemory Usage: 6.1 MB, less than 98.62% of C++ online submissions for Count and Say.***\\n```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        string result = \"1\",current;\\n        while(--n){\\n            current = \"\";\\n            for(int i=0;i<result.size();i++){\\n                int count = 1;\\n                while(i < result.size()-1 && result[i] == result[i+1]){\\n                    count++;\\n                    i++;\\n                }\\n                current +=  to_string(count) + result[i] ;\\n            }\\n            result = current;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        string result = \"1\",current;\\n        while(--n){\\n            current = \"\";\\n            for(int i=0;i<result.size();i++){\\n                int count = 1;\\n                while(i < result.size()-1 && result[i] == result[i+1]){\\n                    count++;\\n                    i++;\\n                }\\n                current +=  to_string(count) + result[i] ;\\n            }\\n            result = current;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 462775,
                "title": "python-4-lines-recursive-beat-99",
                "content": "Use groupby to group the output string, then replace the output with the count-and-say logic (numbers of instances followed by the key).\\n\\n```\\nfrom itertools import groupby\\n\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        output = \\'1\\'\\n        for i in range(n-1):\\n            output = \\'\\'.join([str(len(list(g))) + k for k, g in groupby(output)])\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom itertools import groupby\\n\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        output = \\'1\\'\\n        for i in range(n-1):\\n            output = \\'\\'.join([str(len(list(g))) + k for k, g in groupby(output)])\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16359,
                "title": "the-fastest-js-solution-116ms",
                "content": "    var countAndSay = function(n) {\\n      var start = '1';\\n      var result = '';\\n      var tmp = 1;\\n      for (i=0; i<n-1; i++){\\n        //tmp will count all repeats\\n        for (var j=0; j<start.length; j++){\\n          if(start[j] !== start[j+1] || j == start.length - 1){\\n            result += tmp + start[j];\\n            tmp = 1;\\n          } else {\\n            tmp +=1;\\n          }\\n        }\\n        start = result;\\n        result = '';\\n      }\\n      return start;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var countAndSay = function(n) {\\n      var start = '1';\\n      var result = '';\\n      var tmp = 1;\\n      for (i=0; i<n-1; i++){\\n        //tmp will count all repeats\\n        for (var j=0; j<start.length; j++){\\n          if(start[j] !== start[j+1] || j == start.length - 1){\\n            result += tmp + start[j];\\n            tmp = 1;\\n          } else {\\n            tmp +=1;\\n          }\\n        }\\n        start = result;\\n        result = '';\\n      }\\n      return start;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3749690,
                "title": "explanation-of-question-with-example-and-proper-explanation-of-code",
                "content": "# Explanation of question\\nn==1 --> 1(base case) --> one(count) 1 so next  will be 1 1\\nn==2 --> 1 1 --> two(count) 1\\'s--> 2 1\\nn==3 --> 2 1 --> one(count) 2 one(count) --->1 2 1 1\\nn==4 --> 1 2 1 1\\nwe are given n,we have to give the corresponding sequence(string).\\nHere count is contiguous occrenece i.e. if there 1 1 2 1 then there two contigous 1, one 2 and one 1. \\n\\n# Approach\\n- We will start the recursion with base case i.e. we pass string=\"1\" in the recusrsive function(solve).\\n- Then in the string we will count the number of contiguous occurences and convert that count into string and append it to the string ans along with the character whose occurences we counted.\\n- Then traverse for the contiguous count of other character until the end of string. \\n- Then we will pass the resulting string i.e. ans(containing the sequence) to the next recursive call and will perform the above operations again on this string in next recursion call until we encounter the base case. \\n\\n# Complexity\\n- Time complexity:\\nO(N*N)\\nRecursive O(N) calls * for loop counting the contiguous occurences O(N).\\n\\n- Space complexity:\\nO(N)-Recursive stack (Auxilary space).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string solve(string s,int n)\\n    {\\n        if(n==1)//base case\\n        {\\n            return s;\\n        }\\n        //count contiguous occurences of characters\\n        int freq=1;\\n        char ch=s[0];\\n        string ans=\"\";\\n        s+=\"#\";//append because occurence of last element is pushed in else statement\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if(s[i]==ch)\\n            {\\n                //freq+1 till same character is coming\\n                freq++;\\n            }\\n            else\\n            {\\n                //different character encountered\\n                // push the occurence of last character along with last character\\n                ans+=to_string(freq)+ch;\\n                freq=1;//restart the count to count the other character\\n                ch=s[i];\\n            }\\n        }\\n        return solve(ans,n-1);//recursive call\\n    }\\n    string countAndSay(int n) {\\n        return solve(\"1\",n);//start sequence with base case\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string solve(string s,int n)\\n    {\\n        if(n==1)//base case\\n        {\\n            return s;\\n        }\\n        //count contiguous occurences of characters\\n        int freq=1;\\n        char ch=s[0];\\n        string ans=\"\";\\n        s+=\"#\";//append because occurence of last element is pushed in else statement\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if(s[i]==ch)\\n            {\\n                //freq+1 till same character is coming\\n                freq++;\\n            }\\n            else\\n            {\\n                //different character encountered\\n                // push the occurence of last character along with last character\\n                ans+=to_string(freq)+ch;\\n                freq=1;//restart the count to count the other character\\n                ch=s[i];\\n            }\\n        }\\n        return solve(ans,n-1);//recursive call\\n    }\\n    string countAndSay(int n) {\\n        return solve(\"1\",n);//start sequence with base case\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717433,
                "title": "python-elegant-short-recursive-iterative",
                "content": "## Recursive version:\\n\\n```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(2^n)\\n    Memory: O(2^n)\\n    \"\"\"\\n\\n    def countAndSay(self, n: int) -> str:\\n        if n == 1:\\n            return \\'1\\'\\n        return self.make_count(self.countAndSay(n - 1))\\n\\n    @staticmethod\\n    def make_count(n: str) -> str:\\n        return \\'\\'.join(f\\'{sum(1 for _ in gr)}{key}\\' for key, gr in groupby(n))\\n```\\n\\n## Iterative version:\\n\\n```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(2^n)\\n    Memory: O(2^n)\\n    \"\"\"\\n\\n    def countAndSay(self, n: int) -> str:\\n        string = \\'1\\'\\n        \\n        for _ in range(n - 1):\\n            string = self.make_count(string)\\n\\n        return string\\n\\n    @staticmethod\\n    def make_count(n: str) -> str:\\n        return \\'\\'.join(f\\'{sum(1 for _ in gr)}{key}\\' for key, gr in groupby(n))\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(2^n)\\n    Memory: O(2^n)\\n    \"\"\"\\n\\n    def countAndSay(self, n: int) -> str:\\n        if n == 1:\\n            return \\'1\\'\\n        return self.make_count(self.countAndSay(n - 1))\\n\\n    @staticmethod\\n    def make_count(n: str) -> str:\\n        return \\'\\'.join(f\\'{sum(1 for _ in gr)}{key}\\' for key, gr in groupby(n))\\n```\n```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(2^n)\\n    Memory: O(2^n)\\n    \"\"\"\\n\\n    def countAndSay(self, n: int) -> str:\\n        string = \\'1\\'\\n        \\n        for _ in range(n - 1):\\n            string = self.make_count(string)\\n\\n        return string\\n\\n    @staticmethod\\n    def make_count(n: str) -> str:\\n        return \\'\\'.join(f\\'{sum(1 for _ in gr)}{key}\\' for key, gr in groupby(n))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668741,
                "title": "python-99-faster-not-recursive",
                "content": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        output = \\'1\\'\\n        \\n        for i in range(2, n+1):\\n            res = \\'\\'\\n            cur = output[0]\\n            count = 1\\n            for x in output[1:]:\\n                if x == cur:\\n                    count += 1\\n                else:\\n                    res += str(count) + cur\\n                    count = 1\\n                    cur = x\\n                \\n            res += str(count) + cur\\n            output = \\'\\'.join(res)\\n            \\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        output = \\'1\\'\\n        \\n        for i in range(2, n+1):\\n            res = \\'\\'\\n            cur = output[0]\\n            count = 1\\n            for x in output[1:]:\\n                if x == cur:\\n                    count += 1\\n                else:\\n                    res += str(count) + cur\\n                    count = 1\\n                    cur = x\\n                \\n            res += str(count) + cur\\n            output = \\'\\'.join(res)\\n            \\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 235906,
                "title": "simple-javascript-and-regex",
                "content": "**Javascript**\\n\\nNot the fastest, but a pretty short solution.\\n\\n```\\nvar countAndSay = function(n) {\\n  for (z = 0, returnString = \"1\"; z < n - 1; z++) {\\n    returnString = returnString.match(/(.)\\\\1*/g).reduce((acc, val) => acc + `${val.length}${val[0]}`, \"\");\\n  }\\n  return returnString;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvar countAndSay = function(n) {\\n  for (z = 0, returnString = \"1\"; z < n - 1; z++) {\\n    returnString = returnString.match(/(.)\\\\1*/g).reduce((acc, val) => acc + `${val.length}${val[0]}`, \"\");\\n  }\\n  return returnString;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16342,
                "title": "simple-java-recursion-with-no-extra-function",
                "content": "Since the function itself accepting an integer and return a String, internally we can call this function with n-1 recursively. Therefore, no extra function is required. Also we just need to keep a counter to track how many times a character appears without adding a variable to track 'previous char'\\n\\n    public String countAndSay(int n) {\\n        if (n == 1) {\\n            return \"1\";\\n        }\\n\\n        String prevStr = countAndSay(n - 1);\\n\\n        StringBuffer sb = new StringBuffer();\\n\\n        int count = 0;\\n        int ptr = 0;\\n        while (ptr < prevStr.length()) {\\n            count++;\\n\\n            char curChar = prevStr.charAt(ptr);\\n            if (ptr + 1 >= prevStr.length() || curChar != prevStr.charAt(ptr + 1)) {\\n                sb.append(count).append(curChar);\\n\\n                count = 0;\\n            }\\n\\n            ptr++;\\n        }\\n\\n        return sb.toString();\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "Since the function itself accepting an integer and return a String, internally we can call this function with n-1 recursively. Therefore, no extra function is required. Also we just need to keep a counter to track how many times a character appears without adding a variable to track 'previous char'\\n\\n    public String countAndSay(int n) {\\n        if (n == 1) {\\n            return \"1\";\\n        }\\n\\n        String prevStr = countAndSay(n - 1);\\n\\n        StringBuffer sb = new StringBuffer();\\n\\n        int count = 0;\\n        int ptr = 0;\\n        while (ptr < prevStr.length()) {\\n            count++;\\n\\n            char curChar = prevStr.charAt(ptr);\\n            if (ptr + 1 >= prevStr.length() || curChar != prevStr.charAt(ptr + 1)) {\\n                sb.append(count).append(curChar);\\n\\n                count = 0;\\n            }\\n\\n            ptr++;\\n        }\\n\\n        return sb.toString();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3409791,
                "title": "easy-code-java-solution",
                "content": "Please **UPVOTE** if you like my solution!\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n == 1){\\n            return \"1\";\\n        }\\n        String st = \"11\";\\n        int j = 0;\\n        for(int i = 0;i<n-2;i++){\\n            int count = 1;\\n            String s = \"\";\\n            for( j = 0;j<st.length()-1;j++){\\n                if(st.charAt(j) == st.charAt(j+1)){\\n                    count++;\\n                }\\n                else{\\n                    s += Integer.toString(count);\\n                    s += st.charAt(j);\\n                    count = 1;\\n                }\\n            }\\n            s += Integer.toString(count);\\n            s += st.charAt(j);\\n            st = s;\\n        }\\n        return st;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n == 1){\\n            return \"1\";\\n        }\\n        String st = \"11\";\\n        int j = 0;\\n        for(int i = 0;i<n-2;i++){\\n            int count = 1;\\n            String s = \"\";\\n            for( j = 0;j<st.length()-1;j++){\\n                if(st.charAt(j) == st.charAt(j+1)){\\n                    count++;\\n                }\\n                else{\\n                    s += Integer.toString(count);\\n                    s += st.charAt(j);\\n                    count = 1;\\n                }\\n            }\\n            s += Integer.toString(count);\\n            s += st.charAt(j);\\n            st = s;\\n        }\\n        return st;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259802,
                "title": "python-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        # Initial condition for output\\n        output = \\'1\\'\\n        \\n        while n > 1:\\n            # Use two pointers to count identical elements in the string\\n            # Start from first element in the string\\n            i = j = 0\\n\\t\\t\\t\\n            # Make copy of output string\\n            temp_str = output\\n\\t\\t\\t\\n            # Restart output string\\n            output = \\'\\'\\n\\t\\t\\t\\n            # While end sequence pointer (j) is less than length of the string\\n            while j < len(temp_str):\\n\\t\\t\\t\\n                # If elements are the same at start (i) and end (j) of sequence\\n                if temp_str[i] == temp_str[j]:\\n\\t\\t\\t\\t\\n                    # We increment j\\n                    j += 1\\n                else:\\n\\t\\t\\t\\t\\n                    # If elements are different we count how many elements are between i and j and add it to the output string\\n                    # Sequence is [\\'count\\' + \\'element\\'] : example: \\'21\\',  count = 1, element = \\'2\\' and count = 1, element = \\'1\\',  makes it 1211\\n                    output += str(j - i) + temp_str[i]\\n\\t\\t\\t\\t\\t\\n                    # Restart the sequence \\n                    i = j\\n\\t\\t\\t\\t\\t\\n            # Once we reach the end of the list we add the count and element to the output string\\n            output += str(j - i) + temp_str[i]\\n\\t\\t\\t\\n\\t\\t\\t# The output string will go back to the top of the loop if n > 1 and then script will run again with new output string\\n            n -= 1\\n\\n        return output\\n```\\nTime complexity is O(n2^n)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        # Initial condition for output\\n        output = \\'1\\'\\n        \\n        while n > 1:\\n            # Use two pointers to count identical elements in the string\\n            # Start from first element in the string\\n            i = j = 0\\n\\t\\t\\t\\n            # Make copy of output string\\n            temp_str = output\\n\\t\\t\\t\\n            # Restart output string\\n            output = \\'\\'\\n\\t\\t\\t\\n            # While end sequence pointer (j) is less than length of the string\\n            while j < len(temp_str):\\n\\t\\t\\t\\n                # If elements are the same at start (i) and end (j) of sequence\\n                if temp_str[i] == temp_str[j]:\\n\\t\\t\\t\\t\\n                    # We increment j\\n                    j += 1\\n                else:\\n\\t\\t\\t\\t\\n                    # If elements are different we count how many elements are between i and j and add it to the output string\\n                    # Sequence is [\\'count\\' + \\'element\\'] : example: \\'21\\',  count = 1, element = \\'2\\' and count = 1, element = \\'1\\',  makes it 1211\\n                    output += str(j - i) + temp_str[i]\\n\\t\\t\\t\\t\\t\\n                    # Restart the sequence \\n                    i = j\\n\\t\\t\\t\\t\\t\\n            # Once we reach the end of the list we add the count and element to the output string\\n            output += str(j - i) + temp_str[i]\\n\\t\\t\\t\\n\\t\\t\\t# The output string will go back to the top of the loop if n > 1 and then script will run again with new output string\\n            n -= 1\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916951,
                "title": "short",
                "content": "```\\nstring countAndSay(int n) \\n{\\n\\tif(n==1) return \"1\";\\n\\tauto s = countAndSay(n-1) + \\' \\';\\n\\tstring out;\\n\\tfor(auto i{0}, j{0}; i<size(s); ++i)\\n\\t\\tif(s[i]!=s[j]) out += to_string(i-j)+s[i-1], j=i;\\n\\treturn out;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring countAndSay(int n) \\n{\\n\\tif(n==1) return \"1\";\\n\\tauto s = countAndSay(n-1) + \\' \\';\\n\\tstring out;\\n\\tfor(auto i{0}, j{0}; i<size(s); ++i)\\n\\t\\tif(s[i]!=s[j]) out += to_string(i-j)+s[i-1], j=i;\\n\\treturn out;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 422076,
                "title": "go-solution-using-string-builder-0ms-beats-100-speed-memory",
                "content": "Go strings are immutable, so whenever we attempt to update a string within a loop we are actually creating a new string on every iteration.\\nFor this problem we only require to _append_/_write_ to the string while we are working with it, so there\\'s a helper from the Go standard library that comes handy: `strings.Builder`. \\nYou can take a look at its code at https://golang.org/src/strings/builder.go\\n\\n```go\\nimport (\\n    \"strconv\"\\n    \"strings\"\\n)\\n\\nfunc countAndSay(n int) string {\\n    seq := \"\"\\n    for i:=0; i<n; i++ {\\n        seq = countAndSayHelper(seq)\\n    }\\n    return seq\\n}\\n\\nfunc countAndSayHelper(prev string) string {\\n    if prev == \"\" {\\n        return \"1\"\\n    }\\n    var result strings.Builder\\n    count := 1\\n    for i:=1; i < len(prev); i++ {\\n        if prev[i] == prev[i-1] {\\n            count++\\n        } else {\\n            result.WriteString(strconv.Itoa(count)) \\n            result.WriteByte(prev[i-1])\\n            count = 1\\n        }\\n    }\\n    result.WriteString(strconv.Itoa(count)) \\n    result.WriteByte(prev[len(prev)-1])\\n    return result.String()\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String"
                ],
                "code": "```go\\nimport (\\n    \"strconv\"\\n    \"strings\"\\n)\\n\\nfunc countAndSay(n int) string {\\n    seq := \"\"\\n    for i:=0; i<n; i++ {\\n        seq = countAndSayHelper(seq)\\n    }\\n    return seq\\n}\\n\\nfunc countAndSayHelper(prev string) string {\\n    if prev == \"\" {\\n        return \"1\"\\n    }\\n    var result strings.Builder\\n    count := 1\\n    for i:=1; i < len(prev); i++ {\\n        if prev[i] == prev[i-1] {\\n            count++\\n        } else {\\n            result.WriteString(strconv.Itoa(count)) \\n            result.WriteByte(prev[i-1])\\n            count = 1\\n        }\\n    }\\n    result.WriteString(strconv.Itoa(count)) \\n    result.WriteByte(prev[len(prev)-1])\\n    return result.String()\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 233913,
                "title": "java-solution-beats-96-70",
                "content": "```\\npublic String countAndSay(int n) {\\n        if(n == 1)\\n            return \"1\";\\n        \\n        String value = countAndSay(n - 1);\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < value.length(); i++) {\\n            int count = 1;\\n            while(i < value.length() - 1 && value.charAt(i) == value.charAt(i + 1)) {\\n                count++;\\n                i++;\\n            }\\n            sb.append(count);\\n            sb.append(value.charAt(i));\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String countAndSay(int n) {\\n        if(n == 1)\\n            return \"1\";\\n        \\n        String value = countAndSay(n - 1);\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < value.length(); i++) {\\n            int count = 1;\\n            while(i < value.length() - 1 && value.charAt(i) == value.charAt(i + 1)) {\\n                count++;\\n                i++;\\n            }\\n            sb.append(count);\\n            sb.append(value.charAt(i));\\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16019,
                "title": "easy-readable-6ms-recursive-code",
                "content": "The current result are always read and count the previous result, so...\\n\\n----------\\n\\n\\n\\t    string res, tmp;\\n    \\tif (n == 1)  return \"1\";\\n    \\twhile (n>0){\\n    \\t\\tint count = 1;\\n    \\t\\tres = countAndSay(--n);\\n    \\t\\ttmp = \"\";\\n    \\t\\tfor (int i = 0; i<res.size(); i++){\\n    \\t\\t\\tif (res[i] == res[i + 1])\\tcount++;\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\ttmp += to_string(count) + res[i];\\n    \\t\\t\\t\\tcount = 1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn tmp;\\n    \\t}\\n    }",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "The current result are always read and count the previous result, so...\\n\\n----------\\n\\n\\n\\t    string res, tmp;\\n    \\tif (n == 1)  return \"1\";\\n    \\twhile (n>0){\\n    \\t\\tint count = 1;\\n    \\t\\tres = countAndSay(--n);\\n    \\t\\ttmp = \"\";\\n    \\t\\tfor (int i = 0; i<res.size(); i++){\\n    \\t\\t\\tif (res[i] == res[i + 1])\\tcount++;\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\ttmp += to_string(count) + res[i];\\n    \\t\\t\\t\\tcount = 1;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn tmp;\\n    \\t}\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3412863,
                "title": "java-recursion-good-to-go",
                "content": "![photo_2023-04-13_18-38-05.jpg](https://assets.leetcode.com/users/images/f569c4b0-aaf7-4aa2-8efc-fce17ed7a43d_1681391306.9197733.jpeg)\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n) call stack space and a string builder is used\\n\\n# Code\\n```\\nclass Solution {\\n    int counter; \\n    public String countAndSay(int n) {\\n        if(n==1) return \"1\" ;\\n        String s= countAndSay(n-1);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n        counter ++;\\n        if(i==s.length()-1 ||s.charAt(i)!=s.charAt(i+1)){\\n            sb.append(counter).append(s.charAt(i));\\n            counter=0;\\n        }\\n        }\\n    return sb.toString();    \\n    }\\n}\\n\\n![471ac8c9-5c1b-4052-a76c-b8019c47bb11_1679937665.6666765.png](https://assets.leetcode.com/users/images/55b6e259-0aa1-43f8-b07c-1fa12cf13b01_1681391180.1980383.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int counter; \\n    public String countAndSay(int n) {\\n        if(n==1) return \"1\" ;\\n        String s= countAndSay(n-1);\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n        counter ++;\\n        if(i==s.length()-1 ||s.charAt(i)!=s.charAt(i+1)){\\n            sb.append(counter).append(s.charAt(i));\\n            counter=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2718001,
                "title": "python-rust-c-smart-concise-solution-using-separators-with-detailed-comments",
                "content": "**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n**** \\n**Comment.** There are many somewhat similar solutions to this problem here on LeetCode. For the sake of diversity, I provide a different solution using separators. Given that the maximal size of the problem is *n=30*, it turns out that the **run-time** is not bad at all, while the **write-time** (and ease of perception) is awesome. \\n**** \\n**Python.** This [**solution**](https://leetcode.com/submissions/detail/825127932/) employs separators to guide iteration through blocks of repeating digits. It demonstrated **37 ms runtime (99.10%)** and used **14.1 MB memory (16.06%)**. Time complexity is exponential: **O(expN)**. Space complexity is exponential: **O(expN)**.\\n```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        \\n        # [1] only 3 repetitiotns of any digit is possible, thus,\\n        #     we can list all possible boundaries between blocks\\n        sep = { \"12\" : \"1|2\", \"21\" : \"2|1\", \"13\" : \"1|3\", \\n                \"31\" : \"3|1\", \"23\" : \"2|3\", \"32\" : \"3|2\"}\\n        \\n        say = \"1\"\\n        \\n        # [2] at each iteration:\\n        #     - first, place separators between blocks\\n        #     - second, split using separators and build new saying\\n        for _ in range(n-1):\\n            for w, r in sep.items(): say = say.replace(w, r)\\n            say = \"\".join([f\"{len(b)}{b[0]}\" for b in say.split(\"|\")])\\n            \\n        return say\\n```\\n**** \\n**Rust.** This [**solution**](https://leetcode.com/submissions/detail/825130109/) employs separators to guide iteration through blocks of repeating digits. It demonstrated **2 ms runtime (72.92%)** and used **2.3 MB memory (20.83%)**. Time complexity is exponential: **O(expN)**. Space complexity is exponential: **O(expN)**.\\n```\\nimpl Solution \\n{\\n    pub fn count_and_say(n: i32) -> String \\n    {\\n        // [1] only 3 repetitions of any digit is possible, thus,\\n        //     we can list all possible boundaries between blocks\\n        let sep = [(\"12\", \"1|2\"), (\"21\", \"2|1\"), (\"13\", \"1|3\"),\\n                   (\"31\", \"3|1\"), (\"23\", \"2|3\"), (\"32\", \"3|2\")];\\n        \\n        let mut say = String::from(\"1\");\\n        \\n        // [2] at each iteration:\\n        //     - first, place separators between blocks\\n        //     - second, split using separators and build new saying\\n        for _ in 0..n-1\\n        {\\n            say = sep.iter()\\n                     .fold(say, |s, &r| s.replace(r.0, r.1));\\n\\n            say = say.split(\"|\")\\n                     .map(|s| format!(\"{}{}\", s.len(), s.chars().nth(0).unwrap()))\\n                     .fold(String::with_capacity(4500), |s, add| s + &add);\\n        }\\n\\n        return say;\\n    }\\n}\\n```\\n**** \\n**\\u0421++.** This [**solution**](https://leetcode.com/submissions/detail/825141001/) employs separators to guide iteration through blocks of repeating digits. It demonstrated **108 ms runtime (14.61%)** and used **30.2 MB memory (21.61%)**. Time complexity is exponential: **O(expN)**. Space complexity is exponential: **O(expN)**.\\n```\\nclass Solution \\n{\\npublic:\\n    string countAndSay(int n) \\n    {\\n        // [1] only 3 repetitions of any digit is possible, thus,\\n        //     we can list all possible boundaries between blocks\\n        map<string,string> sep = {{\"12\", \"1|2\"}, {\"21\", \"2|1\"}, {\"13\", \"1|3\"},\\n                                  {\"31\", \"3|1\"}, {\"23\", \"2|3\"}, {\"32\", \"3|2\"}};\\n        \\n        string say = \"1\";\\n        string block;\\n        \\n        // [2] on each iteration:\\n        //     - first, place separators between blocks\\n        //     - second, split using separators and build new saying\\n        for (int i = 0; i < n-1; ++i)\\n        {\\n            for(auto [src, dst]: sep) \\n                say = regex_replace(say, regex(src), dst);\\n            \\n            istringstream ss(say);\\n            string new_say = \"\";\\n            new_say.reserve(4500);\\n            while(getline(ss, block, \\'|\\')) \\n                new_say += to_string(block.size()) + block[0];\\n            say = new_say;\\n        }\\n        \\n        return say;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C",
                    "Rust"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        \\n        # [1] only 3 repetitiotns of any digit is possible, thus,\\n        #     we can list all possible boundaries between blocks\\n        sep = { \"12\" : \"1|2\", \"21\" : \"2|1\", \"13\" : \"1|3\", \\n                \"31\" : \"3|1\", \"23\" : \"2|3\", \"32\" : \"3|2\"}\\n        \\n        say = \"1\"\\n        \\n        # [2] at each iteration:\\n        #     - first, place separators between blocks\\n        #     - second, split using separators and build new saying\\n        for _ in range(n-1):\\n            for w, r in sep.items(): say = say.replace(w, r)\\n            say = \"\".join([f\"{len(b)}{b[0]}\" for b in say.split(\"|\")])\\n            \\n        return say\\n```\n```\\nimpl Solution \\n{\\n    pub fn count_and_say(n: i32) -> String \\n    {\\n        // [1] only 3 repetitions of any digit is possible, thus,\\n        //     we can list all possible boundaries between blocks\\n        let sep = [(\"12\", \"1|2\"), (\"21\", \"2|1\"), (\"13\", \"1|3\"),\\n                   (\"31\", \"3|1\"), (\"23\", \"2|3\"), (\"32\", \"3|2\")];\\n        \\n        let mut say = String::from(\"1\");\\n        \\n        // [2] at each iteration:\\n        //     - first, place separators between blocks\\n        //     - second, split using separators and build new saying\\n        for _ in 0..n-1\\n        {\\n            say = sep.iter()\\n                     .fold(say, |s, &r| s.replace(r.0, r.1));\\n\\n            say = say.split(\"|\")\\n                     .map(|s| format!(\"{}{}\", s.len(), s.chars().nth(0).unwrap()))\\n                     .fold(String::with_capacity(4500), |s, add| s + &add);\\n        }\\n\\n        return say;\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\npublic:\\n    string countAndSay(int n) \\n    {\\n        // [1] only 3 repetitions of any digit is possible, thus,\\n        //     we can list all possible boundaries between blocks\\n        map<string,string> sep = {{\"12\", \"1|2\"}, {\"21\", \"2|1\"}, {\"13\", \"1|3\"},\\n                                  {\"31\", \"3|1\"}, {\"23\", \"2|3\"}, {\"32\", \"3|2\"}};\\n        \\n        string say = \"1\";\\n        string block;\\n        \\n        // [2] on each iteration:\\n        //     - first, place separators between blocks\\n        //     - second, split using separators and build new saying\\n        for (int i = 0; i < n-1; ++i)\\n        {\\n            for(auto [src, dst]: sep) \\n                say = regex_replace(say, regex(src), dst);\\n            \\n            istringstream ss(say);\\n            string new_say = \"\";\\n            new_say.reserve(4500);\\n            while(getline(ss, block, \\'|\\')) \\n                new_say += to_string(block.size()) + block[0];\\n            say = new_say;\\n        }\\n        \\n        return say;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716733,
                "title": "recursive-iterative-c-soln",
                "content": "# Complexity\\n- Time complexity: O(2^n)\\n Let\\'s say that every string has no duplicate numbers together , therefore lets asssume size for n=1 is 1 , 2 is 2, 3 is 4, 4 is 8 , 5 is 16 i.e. 2^(n-1) in worst case.  So overall complexity is a G.P. from 2^(1-1),2^(2-1),....,2^(n-1) which sums up to \\n  **g.p. sum = a(r^n - 1)/r-1** \\nwhere a = 1,r = 2.\\n  **So complexity becomes 2^n - 1.**\\n\\n **However ,it works for n=30 because all levels don\\'t necessarily doubles.**\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Recursive Solution\\n```\\n    string countAndSay(int n) {\\n         if(n==1)return \"1\";\\n         string small = countAndSay(n-1);\\n         small+=\\'#\\';\\n         string ans = \"\";\\n         int cnt = 0;\\n         char k = small[0];\\n         for(char c:small){\\n            if(c!=k){\\n                ans+= (cnt+\\'0\\');\\n                ans+= k;\\n                cnt = 0; }\\n            k = c;\\n            cnt++; }\\n        return ans; }\\n```\\n \\n\\n# Iterative Solution \\n```\\n    string countAndSay(int n) {\\n        string start = \"1\";\\n        while(n-- >1){\\n           vector<int> num;\\n           int cnt = 0,ele = -1;\\n           for(int i =0;i<start.size();i++){\\n              if(ele==-1){\\n                  ele = start[i]-\\'0\\';\\n                  cnt++;\\n                  continue;\\n              }\\n              if(ele!=start[i]-\\'0\\'){\\n                  num.push_back(cnt);\\n                  num.push_back(ele);\\n                  ele = start[i]-\\'0\\',cnt=1;\\n              }\\n              else{\\n                  cnt++; }\\n           }\\n           if(ele!=-1){\\n               num.push_back(cnt);\\n               num.push_back(ele);\\n           }\\n            start = \"\";\\n           for(int a:num){\\n               start += (a+\\'0\\');\\n           } }\\n        return start ;\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n    string countAndSay(int n) {\\n         if(n==1)return \"1\";\\n         string small = countAndSay(n-1);\\n         small+=\\'#\\';\\n         string ans = \"\";\\n         int cnt = 0;\\n         char k = small[0];\\n         for(char c:small){\\n            if(c!=k){\\n                ans+= (cnt+\\'0\\');\\n                ans+= k;\\n                cnt = 0; }\\n            k = c;\\n            cnt++; }\\n        return ans; }\\n```\n```\\n    string countAndSay(int n) {\\n        string start = \"1\";\\n        while(n-- >1){\\n           vector<int> num;\\n           int cnt = 0,ele = -1;\\n           for(int i =0;i<start.size();i++){\\n              if(ele==-1){\\n                  ele = start[i]-\\'0\\';\\n                  cnt++;\\n                  continue;\\n              }\\n              if(ele!=start[i]-\\'0\\'){\\n                  num.push_back(cnt);\\n                  num.push_back(ele);\\n                  ele = start[i]-\\'0\\',cnt=1;\\n              }\\n              else{\\n                  cnt++; }\\n           }\\n           if(ele!=-1){\\n               num.push_back(cnt);\\n               num.push_back(ele);\\n           }\\n            start = \"\";\\n           for(int a:num){\\n               start += (a+\\'0\\');\\n           } }\\n        return start ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716650,
                "title": "c-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n**Problem Statement**\\n\\n\\t n      val\\n\\t 1.     1                                                  Base Case\\n\\t 2.     11                                                 (1 times 1) = 1\\n\\t 3.     21                                                 (2 times 1) = 2\\n\\t 4.     1211                                                and so on\\n\\n----------------------------------------------\\t\\n\\t\\n\\tstring countAndSay(int n) {\\n        \\n        if(n==1) return \"1\";                       //if n==1, return \"1\"\\n        if(n==2) return \"11\";                      //if n==2, return \"11\"\\n        \\n        string s=\"11\";                             //initialise s = \"11\"\\n        \\n        for(int i=3;i<=n;i++){\\n            \\n            string temp=\"\";                        //empty string, temp\\n            s+= \\'$\\';                               //append a random character, therefore, s = \"11$\"\\n            int count=1;                           //initially count = 1\\n            \\n            for(int j=1;j<s.size();j++){           //traverse string s from idx 1 to s.size()\\n                \\n                if(s[j]!=s[j-1]){                  //if curr_character and prev_character doesn\\'t match\\n                    \\n                    temp+= to_string(count);       //First,  add count to temp string\\n                    temp+= s[j-1];                 //Second, add the character (prev_character)\\n                    count=1;                       //Third,  reset the count\\n                }\\n                else count++;                      //if curr_character and prev_character match, increment count\\n                \\n            }\\n            \\n            s=temp;                                //Update string s wuth temp\\n        }\\n        \\n        return s;                                  //return s\\n    }",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n**Problem Statement**\\n\\n\\t n      val\\n\\t 1.     1                                                  Base Case\\n\\t 2.     11                                                 (1 times 1) = 1\\n\\t 3.     21                                                 (2 times 1) = 2\\n\\t 4.     1211                                                and so on\\n\\n----------------------------------------------\\t\\n\\t\\n\\tstring countAndSay(int n) {\\n        \\n        if(n==1) return \"1\";                       //if n==1, return \"1\"\\n        if(n==2) return \"11\";                      //if n==2, return \"11\"\\n        \\n        string s=\"11\";                             //initialise s = \"11\"\\n        \\n        for(int i=3;i<=n;i++){\\n            \\n            string temp=\"\";                        //empty string, temp\\n            s+= \\'$\\';                               //append a random character, therefore, s = \"11$\"\\n            int count=1;                           //initially count = 1\\n            \\n            for(int j=1;j<s.size();j++){           //traverse string s from idx 1 to s.size()\\n                \\n                if(s[j]!=s[j-1]){                  //if curr_character and prev_character doesn\\'t match\\n                    \\n                    temp+= to_string(count);       //First,  add count to temp string\\n                    temp+= s[j-1];                 //Second, add the character (prev_character)\\n                    count=1;                       //Third,  reset the count\\n                }\\n                else count++;                      //if curr_character and prev_character match, increment count\\n                \\n            }\\n            \\n            s=temp;                                //Update string s wuth temp\\n        }\\n        \\n        return s;                                  //return s\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2716284,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        res = \"\"\\n        ct = 1\\n        if n == 1:\\n            return \"1\"\\n        prev =  self.countAndSay(n - 1)\\n        for i in range(len(prev)):\\n            if  i == len(prev) - 1 or prev[i] != prev[i + 1]   :\\n                res += str(ct) + prev[i]\\n                ct = 1\\n            else :\\n                ct +=1\\n        return res\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        res = \"\"\\n        ct = 1\\n        if n == 1:\\n            return \"1\"\\n        prev =  self.countAndSay(n - 1)\\n        for i in range(len(prev)):\\n            if  i == len(prev) - 1 or prev[i] != prev[i + 1]   :\\n                res += str(ct) + prev[i]\\n                ct = 1\\n            else :\\n                ct +=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470058,
                "title": "100-java-intuitive-recursion-method",
                "content": "Intuitive Java Recursion approach\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n == 1) return \"1\";\\n        String res = countAndSay(n-1);\\n        StringBuilder ans = new StringBuilder();\\n        int left = 0, right = 0;\\n        while(right < res.length()){\\n            int counter = 0;\\n            while(right<res.length() && res.charAt(left) == res.charAt(right)){\\n                counter++;\\n                right++;\\n            }\\n            ans.append(counter);\\n            ans.append(res.charAt(left));\\n            left = right;\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n == 1) return \"1\";\\n        String res = countAndSay(n-1);\\n        StringBuilder ans = new StringBuilder();\\n        int left = 0, right = 0;\\n        while(right < res.length()){\\n            int counter = 0;\\n            while(right<res.length() && res.charAt(left) == res.charAt(right)){\\n                counter++;\\n                right++;\\n            }\\n            ans.append(counter);\\n            ans.append(res.charAt(left));\\n            left = right;\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1268267,
                "title": "python-1-line",
                "content": "This is a real python 1-liner, no tricks, no `;` for grouping multiple statements on a single line. The core of it is using `itertools.groupby` to help us count the number of chars easily and then doing that `n-1` times.\\n```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        return reduce(lambda s, _: \\'\\'.join(str(sum(1 for _ in g))+k for k, g in groupby(s)), range(n-1), \\'1\\')\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        return reduce(lambda s, _: \\'\\'.join(str(sum(1 for _ in g))+k for k, g in groupby(s)), range(n-1), \\'1\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343305,
                "title": "100-runtime-python-code-o-1-runtime-unbeatable-easy-to-understand",
                "content": "Don\\'t worry, i created a program to provide this whole code, i didn\\'t calculate each count-and-say sequence part on my own ^^\\n\\nThis is of course a joke, don\\'t take that solution serious. But it\\'s a different way tho\\n\\n```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        \\n        if n == 1: return \"1\"\\n        if n == 2: return \"11\"\\n        if n == 3: return \"21\"\\n        if n == 4: return \"1211\"\\n        if n == 5: return \"111221\"\\n        if n == 6: return \"312211\"\\n        if n == 7: return \"13112221\"\\n        if n == 8: return \"1113213211\"\\n        if n == 9: return \"31131211131221\"\\n        if n == 10: return \"13211311123113112211\"\\n        if n == 11: return \"11131221133112132113212221\"\\n        if n == 12: return \"3113112221232112111312211312113211\"\\n        if n == 13: return \"1321132132111213122112311311222113111221131221\"\\n        if n == 14: return \"11131221131211131231121113112221121321132132211331222113112211\"\\n        if n == 15: return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\"\\n        if n == 16: return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\"\\n        if n == 17: return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\"\\n        if n == 18: return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\"\\n        if n == 19: return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\"\\n        if n == 20: return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\"\\n        if n == 21: return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n        if n == 22: return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n        if n == 23: return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"\\n        if n == 24: return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"\\n        if n == 25: return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n        if n == 26: return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n        if n == 27: return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"\\n        if n == 28: return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"\\n        if n == 29: return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n        if n == 30: return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        \\n        if n == 1: return \"1\"\\n        if n == 2: return \"11\"\\n        if n == 3: return \"21\"\\n        if n == 4: return \"1211\"\\n        if n == 5: return \"111221\"\\n        if n == 6: return \"312211\"\\n        if n == 7: return \"13112221\"\\n        if n == 8: return \"1113213211\"\\n        if n == 9: return \"31131211131221\"\\n        if n == 10: return \"13211311123113112211\"\\n        if n == 11: return \"11131221133112132113212221\"\\n        if n == 12: return \"3113112221232112111312211312113211\"\\n        if n == 13: return \"1321132132111213122112311311222113111221131221\"\\n        if n == 14: return \"11131221131211131231121113112221121321132132211331222113112211\"\\n        if n == 15: return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\"\\n        if n == 16: return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\"\\n        if n == 17: return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\"\\n        if n == 18: return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\"\\n        if n == 19: return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\"\\n        if n == 20: return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\"\\n        if n == 21: return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n        if n == 22: return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n        if n == 23: return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"\\n        if n == 24: return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"\\n        if n == 25: return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n        if n == 26: return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n        if n == 27: return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"\\n        if n == 28: return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"\\n        if n == 29: return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n        if n == 30: return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16314,
                "title": "very-short-fast-6ms-and-concise-java-solution-easy-to-understand-and-implement",
                "content": "    public class Solution {\\n        public String countAndSay(int n) {\\n            String s = \"1\";\\n            for (int i = 1; i < n; i++) {\\n                StringBuilder sb = new StringBuilder();\\n                for (int j = 1, count = 1; j <= s.length(); j++) {\\n                    if (j == s.length() || s.charAt(j - 1) != s.charAt(j)) {\\n                        sb.append(count);\\n                        sb.append(s.charAt(j - 1));\\n                        count = 1;\\n                    } else count++;\\n                }\\n                s = sb.toString();\\n            }\\n            return s;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String countAndSay(int n) {\\n            String s = \"1\";\\n            for (int i = 1; i < n; i++) {\\n                StringBuilder sb = new StringBuilder();\\n                for (int j = 1, count = 1; j <= s.length(); j++) {\\n                    if (j == s.length() || s.charAt(j - 1) != s.charAt(j)) {\\n                        sb.append(count);\\n                        sb.append(s.charAt(j - 1));\\n                        count = 1;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 16214,
                "title": "0ms-c-language-solution",
                "content": "    char* countAndSay(int n) {\\n        if( n == 1 ) return \"1\";\\n    \\tchar *cur = malloc(2), *tmp;\\n    \\tcur[0] = '1';\\n    \\tcur[1] = 0;\\n    \\t\\n    \\tint len, idx, j, count;\\n    \\tfor(int i = 2; i <= n; ++i)\\n    \\t{\\n    \\t\\tlen = strlen(cur);\\n    \\t\\ttmp = malloc(len * 3);\\n    \\t\\tmemset(tmp, 0, len * 3);\\n    \\t\\tcount = 1;\\n    \\t\\tfor(idx = 1, j = 0; idx < len; ++idx)\\n    \\t\\t{\\n    \\t\\t\\tif(cur[idx] == cur[idx-1])\\n            \\t{\\n                \\t++count;\\n            \\t}\\n    \\t\\t\\telse\\n            \\t{\\n                \\ttmp[j++] = '0' + count;\\n                \\ttmp[j++] = cur[idx-1];\\n                \\tcount = 1;\\n            \\t}\\n    \\t\\t}//end of for\\n    \\t\\ttmp[j++] = '0' + count;\\n        \\ttmp[j++] = cur[len-1];\\n    \\t\\tfree(cur);\\n    \\t\\tcur = tmp;\\n    \\t}\\t\\n    \\treturn cur;\\n    }",
                "solutionTags": [],
                "code": "    char* countAndSay(int n) {\\n        if( n == 1 ) return \"1\";\\n    \\tchar *cur = malloc(2), *tmp;\\n    \\tcur[0] = '1';\\n    \\tcur[1] = 0;\\n    \\t\\n    \\tint len, idx, j, count;\\n    \\tfor(int i = 2; i <= n; ++i)\\n    \\t{\\n    \\t\\tlen = strlen(cur);\\n    \\t\\ttmp = malloc(len * 3);\\n    \\t\\tmemset(tmp, 0, len * 3);\\n    \\t\\tcount = 1;\\n    \\t\\tfor(idx = 1, j = 0; idx < len; ++idx)\\n    \\t\\t{\\n    \\t\\t\\tif(cur[idx] == cur[idx-1])\\n            \\t{\\n                \\t++count;\\n            \\t}\\n    \\t\\t\\telse\\n            \\t{\\n                \\ttmp[j++] = '0' + count;\\n                \\ttmp[j++] = cur[idx-1];\\n                \\tcount = 1;\\n            \\t}\\n    \\t\\t}//end of for\\n    \\t\\ttmp[j++] = '0' + count;\\n        \\ttmp[j++] = cur[len-1];\\n    \\t\\tfree(cur);\\n    \\t\\tcur = tmp;\\n    \\t}\\t\\n    \\treturn cur;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4067885,
                "title": "best-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        string ans = \"1\";\\n        int i = 1;\\n        while (i < n) {\\n            string cur = \"\";\\n            for (int j = 0; j < ans.size(); j++) {\\n                int count = 1;\\n                while (j + 1 < ans.size() && ans[j] == ans[j + 1]) {\\n                    count++;\\n                    j++;\\n                }    \\n                cur += to_string(count) + ans[j];    \\n            } \\n            ans = cur; \\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        string ans = \"1\";\\n        int i = 1;\\n        while (i < n) {\\n            string cur = \"\";\\n            for (int j = 0; j < ans.size(); j++) {\\n                int count = 1;\\n                while (j + 1 < ans.size() && ans[j] == ans[j + 1]) {\\n                    count++;\\n                    j++;\\n                }    \\n                cur += to_string(count) + ans[j];    \\n            } \\n            ans = cur; \\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088073,
                "title": "javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/k9DpVGXO7H8\\n\\n# Code\\n```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar countAndSay = function(n) {\\n    if(n == 1) return \"1\"\\n    let str = countAndSay(n-1)\\n\\n    let res = \"\"\\n    let j = 0;\\n    for(let i =0; i<str.length;i++){\\n        while(str[i] == str[j]) j++\\n\\n        res += j-i +str[i]\\n        i = j-1\\n    }\\n    return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar countAndSay = function(n) {\\n    if(n == 1) return \"1\"\\n    let str = countAndSay(n-1)\\n\\n    let res = \"\"\\n    let j = 0;\\n    for(let i =0; i<str.length;i++){\\n        while(str[i] == str[j]) j++\\n\\n        res += j-i +str[i]\\n        i = j-1\\n    }\\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716464,
                "title": "c-recursive-solution-with-explanation",
                "content": "# Recursive Approch:\\n**BASE CASE**\\n* First Base Case : - if(n == 1) then return \"1\";\\n* Second Base Case :- if(n == 2)then return \"11\";\\n\\n**RECURSIVE CALL**\\n* Call the fun(n-1) until it didn\\'t reached Base Case;\\n* When function hit the base case,then move procesing part of code;\\n\\n**PROCESSING**\\n* Store the resultant string into string x;\\n* if x[i] == x[i+1]the increase the counter;\\n* when if the case where x[i] != x[i+1] , then simply store the counter and then store the value of string;\\n\\n**CODE :-**\\n\\n```\\n    string countAndSay(int n) {\\n        int count = 1;string ans = \"\";\\n        if(n == 1)return \"1\";\\n        if(n == 2)return \"11\";\\n        string x = countAndSay(n-1);\\n        for(int i = 0;i<x.size();i++){\\n            if(x[i] == x[i+1]){\\n                count++;\\n            }\\n            else{\\n                ans+=to_string(count);\\n                ans+=x[i];\\n                count = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n    string countAndSay(int n) {\\n        int count = 1;string ans = \"\";\\n        if(n == 1)return \"1\";\\n        if(n == 2)return \"11\";\\n        string x = countAndSay(n-1);\\n        for(int i = 0;i<x.size();i++){\\n            if(x[i] == x[i+1]){\\n                count++;\\n            }\\n            else{\\n                ans+=to_string(count);\\n                ans+=x[i];\\n                count = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716104,
                "title": "daily-leetcoding-challenge-october-day-18",
                "content": "This problem is the Daily LeetCoding Challenge for October, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-and-say/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/count-and-say/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2689768,
                "title": "c-easy-fast-and-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n==1) return \"1\";\\n        \\n        string str = countAndSay(n-1);\\n        \\n        string res = \"\";\\n        int s = str.size();\\n        int i = 0;\\n        while(i<s)\\n        {\\n            char c = str[i];\\n            int count = 0;\\n            while(i<s and str[i]==c)\\n            {\\n                count++;\\n                i++;\\n            }\\n            res+=\\'0\\'+count;\\n            res+=c;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**UPVOTE**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n==1) return \"1\";\\n        \\n        string str = countAndSay(n-1);\\n        \\n        string res = \"\";\\n        int s = str.size();\\n        int i = 0;\\n        while(i<s)\\n        {\\n            char c = str[i];\\n            int count = 0;\\n            while(i<s and str[i]==c)\\n            {\\n                count++;\\n                i++;\\n            }\\n            res+=\\'0\\'+count;\\n            res+=c;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327540,
                "title": "2-solutions-recursion-iterative",
                "content": "\\n\\n**\\u2705 Recursive approach!**\\n\\n> Thanks for [fx19316\\'s post](https://leetcode.com/problems/count-and-say/discuss/201832/It\\'s-a-good-question-let-me-explain-it.) I understood it, So here I am sharing it in my way.\\n\\n1. What do we know and how can we use it.\\n    -   Let\\'s stat with example, suppose we have 4\\'th term \"1211\", how can we find 5\\'th term, then 6\\'th and so on.\\n        -   **4\\'th** - \"1211\"\\n        -   **5\\'th** - \"1-1 1-2 2-1s\" = \"111221\"\\n        -   **6\\'th** - \"3-1s 2-2s 1-1\" = \"312211\"\\n        -   **7\\'th** - \"<ins>1-3</ins> <ins>1-1</ins> <ins>2-2s</ins> <ins>2-1s</ins>\" = \"13 11 22 21\" = \"13112221\"\\n    - So from \"n-1\\'th\" term, we can find \"n\\'th\" term.\\n    - We just need to **count the number** and **say the number.**\\n\\n2. Algorithm.\\n    - **Base case:** for n = 1, we just return \"1\"\\n    - Get \"n-1\\'th\" term.\\n    - count the numbers of \"n-1\\'th\" term and get *count-say* string.\\n    - return final result as *count-say* string.\\n\\n\\n**C++ Code**\\n```cpp\\nclass Solution {\\n    // Simple function which return \\'count-say` string.\\n    // Just read it once, you will get the idea.\\n    string countSayStrFun(string s)\\n    {\\n        int count = 1;\\n        string res = \"\";\\n        int n = s.size();\\n        for (int i = 1; i < n; i++) {\\n            if (s[i] == s[i - 1]) {\\n                count++;\\n            } else {\\n                res += to_string(count) + s[i - 1];\\n                count = 1;\\n            }\\n        }\\n        res += to_string(count) + s[s.size() - 1];\\n        return res;\\n    }\\n\\npublic:\\n    string countAndSay(int n)\\n    {\\n        if (n == 1) return \"1\"; // base case - first term is \"1\"\\n\\n        // believe that it will return n-1\\'th term\\n        string prevTerm = countAndSay(n - 1); \\n\\n        // Now just count the numbers and say the number.\\n        string countSayStr = countSayStrFun(prevTerm);\\n        \\n        return countSayStr;\\n    }\\n};\\n```\\n\\n---\\n\\n**\\u2705 Iterative approach!**\\n- Same as recursive if you observe.\\n\\n**C++ Code**\\n```cpp\\nclass Solution {\\npublic:\\n    string countAndSay(int n)\\n    {\\n        string s = \"1\";\\n        for (int i = 1; i < n; i++) {\\n            string t = \"\";\\n            int cnt = 1;\\n            for (int j = 1; j < s.size(); j++) {\\n                if (s[j] == s[j - 1])\\n                    cnt++;\\n                else {\\n                    t += to_string(cnt) + s[j - 1];\\n                    cnt = 1;\\n                }\\n            }\\n            t += to_string(cnt) + s[s.size() - 1];\\n            s = t;\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n**Please upvote if you find it useful.**",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\n    // Simple function which return \\'count-say` string.\\n    // Just read it once, you will get the idea.\\n    string countSayStrFun(string s)\\n    {\\n        int count = 1;\\n        string res = \"\";\\n        int n = s.size();\\n        for (int i = 1; i < n; i++) {\\n            if (s[i] == s[i - 1]) {\\n                count++;\\n            } else {\\n                res += to_string(count) + s[i - 1];\\n                count = 1;\\n            }\\n        }\\n        res += to_string(count) + s[s.size() - 1];\\n        return res;\\n    }\\n\\npublic:\\n    string countAndSay(int n)\\n    {\\n        if (n == 1) return \"1\"; // base case - first term is \"1\"\\n\\n        // believe that it will return n-1\\'th term\\n        string prevTerm = countAndSay(n - 1); \\n\\n        // Now just count the numbers and say the number.\\n        string countSayStr = countSayStrFun(prevTerm);\\n        \\n        return countSayStr;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string countAndSay(int n)\\n    {\\n        string s = \"1\";\\n        for (int i = 1; i < n; i++) {\\n            string t = \"\";\\n            int cnt = 1;\\n            for (int j = 1; j < s.size(); j++) {\\n                if (s[j] == s[j - 1])\\n                    cnt++;\\n                else {\\n                    t += to_string(cnt) + s[j - 1];\\n                    cnt = 1;\\n                }\\n            }\\n            t += to_string(cnt) + s[s.size() - 1];\\n            s = t;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456688,
                "title": "c-easy-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) \\n    {\\n        // base case\\n        if (n == 1) {\\n            return \"1\";\\n        }\\n        // recursive case\\n        else {\\n            // store result of n - 1\\n            string s = countAndSay(n - 1);\\n            // stores result for n\\n            string result = \"\";\\n            // variables for adding the values\\n            char ch = s[0];\\n            int t = 0;\\n            \\n            //iterate over the string\\n            for (int i = 0; i < s.length(); i++) {\\n                // if char is same, increment\\n                if (ch == s[i]) {\\n                    t++;\\n                }\\n                // if char is differnet,\\n                else {\\n                    // add the values to result\\n                    result += to_string(t) + ch;\\n                    // reset variables\\n                    ch = s[i];\\n                    t = 1;\\n                }\\n            }\\n            // add the case when string contains only 1 character\\n            result += to_string(t) + ch;\\n            // return final result\\n            return result;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) \\n    {\\n        // base case\\n        if (n == 1) {\\n            return \"1\";\\n        }\\n        // recursive case\\n        else {\\n            // store result of n - 1\\n            string s = countAndSay(n - 1);\\n            // stores result for n\\n            string result = \"\";\\n            // variables for adding the values\\n            char ch = s[0];\\n            int t = 0;\\n            \\n            //iterate over the string\\n            for (int i = 0; i < s.length(); i++) {\\n                // if char is same, increment\\n                if (ch == s[i]) {\\n                    t++;\\n                }\\n                // if char is differnet,\\n                else {\\n                    // add the values to result\\n                    result += to_string(t) + ch;\\n                    // reset variables\\n                    ch = s[i];\\n                    t = 1;\\n                }\\n            }\\n            // add the case when string contains only 1 character\\n            result += to_string(t) + ch;\\n            // return final result\\n            return result;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372052,
                "title": "iterative-java-solution-used-string-builder",
                "content": "\\tclass Solution {\\n    public String countAndSay(int n) {\\n        if(n<=0) return \"\";\\n        \\n        String res = \"1\";\\n        for(int i=1; i<=n-1; i++){\\n            StringBuilder cur = new StringBuilder();\\n            for(int j=0; j<res.length(); j++){\\n                int count = 1;\\n                while(j+1 < res.length() && res.charAt(j) == res.charAt(j+1)){\\n                    count++;\\n                    j++;\\n                }\\n                \\n                cur.append(count).append(res.charAt(j));\\n            }\\n            res = cur.toString();\\n        }\\n        \\n        return res;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n<=0) return \"\";\\n        \\n        String res = \"1\";\\n        for(int i=1; i<=n-1; i++){\\n            StringBuilder cur = new StringBuilder();\\n            for(int j=0; j<res.length(); j++){\\n                int count = 1;\\n                while(j+1 < res.length() && res.charAt(j) == res.charAt(j+1)){\\n                    count++;\\n                    j++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1190634,
                "title": "c-easy-and-clean-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n == 1)\\n            return \"1\";\\n        string s = countAndSay(n-1), res=\"\";\\n        int sz = s.size(), cnt = 1;\\n        for(int i=1; i<sz; i++) {\\n            if(s[i] == s[i-1])\\n                cnt++;\\n            else {\\n                res += to_string(cnt)+s[i-1];\\n                cnt = 1;\\n            }\\n        }\\n        res += to_string(cnt)+s[sz-1];\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n == 1)\\n            return \"1\";\\n        string s = countAndSay(n-1), res=\"\";\\n        int sz = s.size(), cnt = 1;\\n        for(int i=1; i<sz; i++) {\\n            if(s[i] == s[i-1])\\n                cnt++;\\n            else {\\n                res += to_string(cnt)+s[i-1];\\n                cnt = 1;\\n            }\\n        }\\n        res += to_string(cnt)+s[sz-1];\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835293,
                "title": "kotlin-using-sequences",
                "content": "Kotlin sequences really showing their beauty on this task :)\\nWe just need to give the sequence:\\n* a place to begin - the string \"1\"\\n* a rule to generate the next element, given the previous one\\n\\nFor our successor function (`::next`), given an input string `s`, we can loop over `s`, counting up until the character changes, then adding the `count` and current character to our result `res`, repeating until we reach the end of the string. We then simply return `res`. Job done!\\n```\\n    fun countAndSay(n: Int): String {\\n        // our function to generate the next term of the sequence\\n        fun next(s: String): String {\\n\\n            var res = \"\"\\n            var count: Int\\n            var i = 0\\n            while (i<s.length) {\\n                count = 1\\n                while (i+1<s.length && s[i]==s[i+1]) {\\n                    i++\\n                    count++\\n                }\\n                res += \"$count${s[i++]}\"\\n            }\\n            return res\\n        }\\n        // create the sequence, starting with \"1\", return the nth element\\n        return generateSequence(\"1\", ::next).take(n).last()\\n        \\n    }",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "Kotlin sequences really showing their beauty on this task :)\\nWe just need to give the sequence:\\n* a place to begin - the string \"1\"\\n* a rule to generate the next element, given the previous one\\n\\nFor our successor function (`::next`), given an input string `s`, we can loop over `s`, counting up until the character changes, then adding the `count` and current character to our result `res`, repeating until we reach the end of the string. We then simply return `res`. Job done!\\n```\\n    fun countAndSay(n: Int): String {\\n        // our function to generate the next term of the sequence\\n        fun next(s: String): String {\\n\\n            var res = \"\"\\n            var count: Int\\n            var i = 0\\n            while (i<s.length) {\\n                count = 1\\n                while (i+1<s.length && s[i]==s[i+1]) {\\n                    i++\\n                    count++\\n                }\\n                res += \"$count${s[i++]}\"\\n            }\\n            return res\\n        }\\n        // create the sequence, starting with \"1\", return the nth element\\n        return generateSequence(\"1\", ::next).take(n).last()\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 441559,
                "title": "fastest-smallest-space-java-solution-100-runtime-100-memory",
                "content": "BEHOLD!\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String s = \"\";\\n         switch (n) {\\n            case 1: s = \"1\"; break;\\n            case 2: s = \"11\"; break;\\n            case 3: s = \"21\"; break;\\n            case 4: s = \"1211\"; break;\\n            case 5: s = \"111221\"; break;\\n            case 6: s = \"312211\"; break;\\n            case 7: s = \"13112221\"; break;\\n            case 8: s = \"1113213211\"; break;\\n            case 9: s = \"31131211131221\"; break;\\n            case 10: s = \"13211311123113112211\"; break;\\n            case 11: s = \"11131221133112132113212221\"; break;\\n            case 12: s = \"3113112221232112111312211312113211\"; break;\\n            case 13: s = \"1321132132111213122112311311222113111221131221\"; break;\\n            case 14: s = \"11131221131211131231121113112221121321132132211331222113112211\"; break;\\n            case 15: s = \"311311222113111231131112132112311321322112111312211312111322212311322113212221\"; break;\\n            case 16: s = \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\"; break;\\n            case 17: s = \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\"; break;\\n            case 18: s = \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\"; break;\\n            case 19: s = \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\"; break;\\n            case 20: s = \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\"; break;\\n            case 21: s = \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"; break;\\n            case 22: s = \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"; break;\\n            case 23: s = \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"; break;\\n            case 24: s = \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"; break;\\n            case 25: s = \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"; break;\\n            case 26: s = \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"; break;\\n            case 27: s = \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"; break;\\n            case 28: s = \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"; break;\\n            case 29: s = \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"; break;\\n            case 30: s = \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"; break;\\n            default: break;\\n         }\\n        return s;\\n    }\\n}\\n```\\nBy the way, I got the numbers by making a different (less God-like) solution first. Just in case anyone thought I cheated wholesale; here it is:\\n\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String s = \"\";\\n         switch (n) {\\n            case 1: s = \"1\"; break;\\n            case 2: s = \"11\"; break;\\n            case 3: s = \"21\"; break;\\n            case 4: s = \"1211\"; break;\\n            case 5: s = \"111221\"; break;\\n            case 6: s = \"312211\"; break;\\n            case 7: s = \"13112221\"; break;\\n            case 8: s = \"1113213211\"; break;\\n            case 9: s = \"31131211131221\"; break;\\n            case 10: s = \"13211311123113112211\"; break;\\n            default: break;\\n         }\\n        \\n        if (n > 10) {\\n            s = \"13211311123113112211\";\\n            String ans;\\n            for (int i = 10; i < n; i++) {\\n               ans = \"\";\\n               int count = 0;\\n               char num = s.charAt(0);\\n               for (int j = 0; j < s.length(); ++j) {\\n                  char thisNum = s.charAt(j);\\n                  if (thisNum == num) {\\n                     count++;\\n                  }\\n                  else {\\n                     ans += count; ans += num;\\n                     num = thisNum;\\n                     count = 1;\\n                  }\\n\\n                  if (j == s.length() - 1) {\\n                     ans += count; ans += num;\\n                  }\\n               }\\n               s = ans;\\n            }\\n         }\\n        return s;\\n    }\\n}\\n```\\nThanks for reading (and withholding your jealousy of my 1337 programming skills).",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String s = \"\";\\n         switch (n) {\\n            case 1: s = \"1\"; break;\\n            case 2: s = \"11\"; break;\\n            case 3: s = \"21\"; break;\\n            case 4: s = \"1211\"; break;\\n            case 5: s = \"111221\"; break;\\n            case 6: s = \"312211\"; break;\\n            case 7: s = \"13112221\"; break;\\n            case 8: s = \"1113213211\"; break;\\n            case 9: s = \"31131211131221\"; break;\\n            case 10: s = \"13211311123113112211\"; break;\\n            case 11: s = \"11131221133112132113212221\"; break;\\n            case 12: s = \"3113112221232112111312211312113211\"; break;\\n            case 13: s = \"1321132132111213122112311311222113111221131221\"; break;\\n            case 14: s = \"11131221131211131231121113112221121321132132211331222113112211\"; break;\\n            case 15: s = \"311311222113111231131112132112311321322112111312211312111322212311322113212221\"; break;\\n            case 16: s = \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\"; break;\\n            case 17: s = \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\"; break;\\n            case 18: s = \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\"; break;\\n            case 19: s = \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\"; break;\\n            case 20: s = \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\"; break;\\n            case 21: s = \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"; break;\\n            case 22: s = \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"; break;\\n            case 23: s = \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"; break;\\n            case 24: s = \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"; break;\\n            case 25: s = \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"; break;\\n            case 26: s = \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"; break;\\n            case 27: s = \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"; break;\\n            case 28: s = \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"; break;\\n            case 29: s = \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"; break;\\n            case 30: s = \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"; break;\\n            default: break;\\n         }\\n        return s;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String s = \"\";\\n         switch (n) {\\n            case 1: s = \"1\"; break;\\n            case 2: s = \"11\"; break;\\n            case 3: s = \"21\"; break;\\n            case 4: s = \"1211\"; break;\\n            case 5: s = \"111221\"; break;\\n            case 6: s = \"312211\"; break;\\n            case 7: s = \"13112221\"; break;\\n            case 8: s = \"1113213211\"; break;\\n            case 9: s = \"31131211131221\"; break;\\n            case 10: s = \"13211311123113112211\"; break;\\n            default: break;\\n         }\\n        \\n        if (n > 10) {\\n            s = \"13211311123113112211\";\\n            String ans;\\n            for (int i = 10; i < n; i++) {\\n               ans = \"\";\\n               int count = 0;\\n               char num = s.charAt(0);\\n               for (int j = 0; j < s.length(); ++j) {\\n                  char thisNum = s.charAt(j);\\n                  if (thisNum == num) {\\n                     count++;\\n                  }\\n                  else {\\n                     ans += count; ans += num;\\n                     num = thisNum;\\n                     count = 1;\\n                  }\\n\\n                  if (j == s.length() - 1) {\\n                     ans += count; ans += num;\\n                  }\\n               }\\n               s = ans;\\n            }\\n         }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373414,
                "title": "python-92-faster-simple-solution",
                "content": "I honestly hated this problem. Took me an hour to understand this one. [Explantation Here](https://www.geeksforgeeks.org/look-and-say-sequence/)\\n```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n == 0: return \\'\\'\\n        if n == 1: return \\'1\\'\\n        \\n        s = \\'1\\'\\n        \\n        for _ in range(n-1):\\n            prev, count = s[0], 0\\n            newS = \\'\\'\\n\\t\\t\\t\\n            for l in s:\\n                if prev != l:\\n                    newS += str(count) + prev\\n                    prev, count = l, 1\\n                else: count += 1\\n\\t\\t\\t\\t\\t\\n            newS += str(count) + prev\\n            s = newS\\n        \\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n == 0: return \\'\\'\\n        if n == 1: return \\'1\\'\\n        \\n        s = \\'1\\'\\n        \\n        for _ in range(n-1):\\n            prev, count = s[0], 0\\n            newS = \\'\\'\\n\\t\\t\\t\\n            for l in s:\\n                if prev != l:\\n                    newS += str(count) + prev\\n                    prev, count = l, 1\\n                else: count += 1\\n\\t\\t\\t\\t\\t\\n            newS += str(count) + prev\\n            s = newS\\n        \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 188519,
                "title": "the-most-dodgy-solution-on-earth",
                "content": "class Solution {\n    public String countAndSay(int n) {\n        if (n==1) return \"1\";\n        if (n==2) return \"11\";\n        if (n==3) return \"21\";\n        if (n==4) return \"1211\";\n        if (n==5) return \"111221\";\n        if (n==6) return \"312211\";\n        if (n==7) return \"13112221\";\n        if (n==8) return \"1113213211\";\n        if (n==9) return \"31131211131221\";\n        if (n==10) return \"13211311123113112211\";\n        if (n==11) return \"11131221133112132113212221\";\n        if (n==12) return \"3113112221232112111312211312113211\";\n        if (n==13) return \"1321132132111213122112311311222113111221131221\";\n        if (n==14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n==15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        //if (n==16) return \"1\";\n        //if (n==17) return \"1\";\n        //if (n==18) return \"1\";\n        //if (n==19) return \"1\";\n        if (n==20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        //if (n==21) return \"1\";\n        //if (n==22) return \"1\";\n        //if (n==23) return \"1\";\n        //if (n==24) return \"1\";\n        if (n==25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        //if (n==26) return \"1\";\n        //if (n==27) return \"1\";\n        //if (n==28) return \"1\";\n        //if (n==29) return \"1\";\n        if (n==30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"\";\n    }\n}",
                "solutionTags": [],
                "code": "class Solution {\n    public String countAndSay(int n) {\n        if (n==1) return \"1\";\n        if (n==2) return \"11\";\n        if (n==3) return \"21\";\n        if (n==4) return \"1211\";\n        if (n==5) return \"111221\";\n        if (n==6) return \"312211\";\n        if (n==7) return \"13112221\";\n        if (n==8) return \"1113213211\";\n        if (n==9) return \"31131211131221\";\n        if (n==10) return \"13211311123113112211\";\n        if (n==11) return \"11131221133112132113212221\";\n        if (n==12) return \"3113112221232112111312211312113211\";\n        if (n==13) return \"1321132132111213122112311311222113111221131221\";\n        if (n==14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n==15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        //if (n==16) return \"1\";\n        //if (n==17) return \"1\";\n        //if (n==18) return \"1\";\n        //if (n==19) return \"1\";\n        if (n==20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        //if (n==21) return \"1\";\n        //if (n==22) return \"1\";\n        //if (n==23) return \"1\";\n        //if (n==24) return \"1\";\n        if (n==25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        //if (n==26) return \"1\";\n        //if (n==27) return \"1\";\n        //if (n==28) return \"1\";\n        //if (n==29) return \"1\";\n        if (n==30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"\";\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3525420,
                "title": "awesome-logic-in-python3",
                "content": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        first=\"1\"\\n        for i in range(n-1):\\n            new=\"\"\\n            count=1\\n            current=first[0]\\n            for c in first[1:]:\\n                if current==c:\\n                    count+=1\\n                else:\\n                    new+=str(count)+current\\n                    current=c\\n                    count=1\\n            new+=str(count)+current\\n            first=new\\n        return first\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        first=\"1\"\\n        for i in range(n-1):\\n            new=\"\"\\n            count=1\\n            current=first[0]\\n            for c in first[1:]:\\n                if current==c:\\n                    count+=1\\n                else:\\n                    new+=str(count)+current\\n                    current=c\\n                    count=1\\n            new+=str(count)+current\\n            first=new\\n        return first\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518596,
                "title": "java-solution-for-count-and-say-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe \"Count and Say\" sequence describes a pattern where each term is obtained by reading the previous term and counting the number of consecutive occurrences of each digit.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Handle the edge case where n is less than or equal to 0 by returning null.\\n2. Initialize a variable result with the initial term of the sequence, which is \"1\".\\n3. Use a loop to generate the next term in the sequence n times:\\n- Inside the loop, create a StringBuilder named sb to build the next term.\\n- Initialize a counter count to 1 to keep track of the consecutive occurrences of a digit.\\n- Iterate through the characters of the result string starting from the second character.\\n- Compare each character with the previous character. If they are the same, increment the count.\\n- If the characters are different, append the count followed by the previous character to sb, reset the count to 1, and continue to the next character.\\n- After the inner loop completes, append the final count and the last character of the result string to sb.\\n- Update the result to the generated string in sb.\\n4. Return the final result string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is O(n * k), where n is the given input and k is the length of the longest term in the \"Count and Say\" sequence up to the nth term. In each iteration of the loop, the code iterates through the characters of the result string to build the next term. Therefore, the time complexity is proportional to the length of the longest term, which is k.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code is O(k), where k is the length of the longest term in the \"Count and Say\" sequence up to the nth term. It is due to the use of the StringBuilder to build the next term. The space required for the result string and the temporary variables is negligible compared to the length of the longest term, making the space complexity O(k).\\n\\n# Code\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if (n <= 0)\\n            return null;\\n        String result = \"1\";\\n        int i = 1;\\n        while (i < n) \\n        {\\n            StringBuilder sb = new StringBuilder();\\n            int count = 1;\\n            for (int j = 1; j < result.length(); j++) \\n            {\\n                if (result.charAt(j) == result.charAt(j - 1)) \\n                {\\n                    count++;\\n                }\\n                else \\n                {\\n                    sb.append(count);\\n                    sb.append(result.charAt(j - 1));\\n                    count = 1;\\n                }\\n            }\\n            sb.append(count);\\n            sb.append(result.charAt(result.length() - 1));\\n            result = sb.toString();\\n            i++;\\n        }\\n        return result;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if (n <= 0)\\n            return null;\\n        String result = \"1\";\\n        int i = 1;\\n        while (i < n) \\n        {\\n            StringBuilder sb = new StringBuilder();\\n            int count = 1;\\n            for (int j = 1; j < result.length(); j++) \\n            {\\n                if (result.charAt(j) == result.charAt(j - 1)) \\n                {\\n                    count++;\\n                }\\n                else \\n                {\\n                    sb.append(count);\\n                    sb.append(result.charAt(j - 1));\\n                    count = 1;\\n                }\\n            }\\n            sb.append(count);\\n            sb.append(result.charAt(result.length() - 1));\\n            result = sb.toString();\\n            i++;\\n        }\\n        return result;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3222117,
                "title": "count-and-say-sequence-generating-digit-strings-with-a-recursive-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem requires us to generate a sequence of strings that follows a specific pattern. The pattern for each string in the sequence is determined by applying a count-and-say algorithm to the previous string in the sequence. To generate the nth string in the sequence, we need to apply the count-and-say algorithm recursively on the (n-1)th string in the sequence.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a recursive approach to generate the sequence of strings. If n is equal to 1, we simply return the string \"1\" as it is the first string in the sequence. Otherwise, we recursively call the countAndSay function with n-1 to get the previous string in the sequence. We then iterate through the previous string and apply the count-and-say algorithm to generate the current string in the sequence.\\n\\nTo apply the count-and-say algorithm, we iterate through the previous string from left to right, keeping track of the current digit and a count of how many times we have seen this digit consecutively. When we encounter a different digit, we append the count and the digit to our result string and reset the count to 1. We continue this process until we reach the end of the string.\\n# Complexity\\n- Time complexity: The algorithm iterates through each character in the input string once to generate the output string. Hence, the time complexity is $$O(N*M)$$, where N is the input integer and M is the length of the longest string in the sequence. In practice, since the length of the strings in the sequence grows exponentially with N, the actual time complexity of the algorithm is closer to $$O(2^N)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of the algorithm is $$O(M)$$, where M is the length of the longest string in the sequence. In practice, since the length of the strings in the sequence grows exponentially with N, the actual space complexity of the algorithm is closer to $$O(2^N)$$.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n == 1:\\n            return \"1\"\\n        prev = self.countAndSay(n-1)\\n        result = \"\"\\n        count = 1\\n        digit = prev[0]\\n        for i in range(1, len(prev)):\\n            if prev[i] == digit:\\n                count += 1\\n            else:\\n                result += str(count) + digit\\n                count = 1\\n                digit = prev[i]\\n        result += str(count) + digit\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n == 1:\\n            return \"1\"\\n        prev = self.countAndSay(n-1)\\n        result = \"\"\\n        count = 1\\n        digit = prev[0]\\n        for i in range(1, len(prev)):\\n            if prev[i] == digit:\\n                count += 1\\n            else:\\n                result += str(count) + digit\\n                count = 1\\n                digit = prev[i]\\n        result += str(count) + digit\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103174,
                "title": "easy-100-in-runtime-beginners-simple-loop-solution-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe only have to call the function n times and update the string every time and pass that string as the input\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake a string pass it to a function  count which is called n times.\\nIn function count we count the no of occurence and add that no with the no which is occuring to the string\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N) with 100% \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string count(string p)\\n    {\\n        int k=0;\\n        string l=\"\";\\n        // we take m as \\'k\\' so we can check first character of string\\n        char m=\\'k\\';\\n        for(int i=0;i<p.length();i++)\\n        {\\n            //if new type of char is there then we will insert\\n            //k and that no in our string and reset value of k and m\\n            if(m!=p[i])\\n            {\\n                if(m!=\\'k\\')\\n                {\\n                   l+=(char)k+48;\\n                   l+=m;\\n                }\\n                k=0;\\n                m=p[i];\\n            }\\n            k++;\\n        }\\n        // for inserting last character\\n        l+=(char)k+48;\\n        l+=m;\\n        cout<<l<<endl;\\n        return l;\\n    }\\n    string countAndSay(int n) {\\n        string p=\"1\";\\n        for(int i=2;i<=n;i++)\\n        {\\n            p=count(p);\\n        }\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string count(string p)\\n    {\\n        int k=0;\\n        string l=\"\";\\n        // we take m as \\'k\\' so we can check first character of string\\n        char m=\\'k\\';\\n        for(int i=0;i<p.length();i++)\\n        {\\n            //if new type of char is there then we will insert\\n            //k and that no in our string and reset value of k and m\\n            if(m!=p[i])\\n            {\\n                if(m!=\\'k\\')\\n                {\\n                   l+=(char)k+48;\\n                   l+=m;\\n                }\\n                k=0;\\n                m=p[i];\\n            }\\n            k++;\\n        }\\n        // for inserting last character\\n        l+=(char)k+48;\\n        l+=m;\\n        cout<<l<<endl;\\n        return l;\\n    }\\n    string countAndSay(int n) {\\n        string p=\"1\";\\n        for(int i=2;i<=n;i++)\\n        {\\n            p=count(p);\\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2718543,
                "title": "c-using-map-easy-and-simple-code",
                "content": "class Solution {\\n    \\nprivate:\\n    vector<vector<int>> make_map(string &arr){\\n        int n = arr.size();\\n        vector<vector<int>> map;\\n        \\n        int temp = 1, mx = 0;\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(arr[i]==arr[i+1]) temp++;\\n            \\n            else {\\n                map.push_back( {arr[i]-\\'0\\',temp});\\n                temp = 1;\\n            }\\n        }\\n        if(arr[n-1]!=arr[n-2]) map.push_back({arr[n-1]-\\'0\\',1});\\n        else if(arr[n-1]==arr[n-2]) map.push_back({arr[n-1]-\\'0\\',temp});\\n        \\n\\n        return map;\\n    } \\n    \\n    string make_string(vector<vector<int>> &map){\\n        string ans = \"\";\\n        for(auto&i:map) {\\n            ans+= (i[1]) +\\'0\\';\\n            ans+= (i[0]) +\\'0\\';\\n        }\\n        \\n        return ans;\\n    }\\npublic:\\n    string countAndSay(int n) {\\n        if(n==1) return \"1\";\\n        if(n==2) return \"11\";\\n        if(n==3) return \"21\";\\n        \\n        string ans = \"1211\";\\n        if(n==4) return ans;\\n        \\n        for(int i= 4;i<n;i++){\\n           vector<vector<int>> temp = make_map(ans);\\n           ans = make_string(temp);\\n          //  cout<<ans<<endl;\\n        }\\n        \\n        \\n        //Test\\n//         string fuck = \"1211\";\\n//         vector<vector<int>> temp = make_map(fuck);\\n//         ans = make_string(temp);\\n        \\n//         for(auto&i:temp) cout<<i[0]<<\" \"<<i[1]<<endl;\\n        \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\nprivate:\\n    vector<vector<int>> make_map(string &arr){\\n        int n = arr.size();\\n        vector<vector<int>> map;\\n        \\n        int temp = 1, mx = 0;\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(arr[i]==arr[i+1]) temp++;\\n            \\n            else {\\n                map.push_back( {arr[i]-\\'0\\',temp}",
                "codeTag": "Java"
            },
            {
                "id": 2717850,
                "title": "easy-to-understand-c",
                "content": "If you find help from this code for good understanding, please Upvote.\\n```\\nclass Solution {\\npublic:\\n    string solve(int n){\\n        int cnt = 1;\\n        string s = \"1\";\\n        for(int i=2; i<=n; i++){\\n            int l = 0, r = 0;\\n            string ans = \"\";\\n            while(r < s.size()){\\n                int cnt = 0;\\n                while(r < s.size() and s[l] == s[r]){ // check similar character \\n                    cnt++;\\n                    r++;\\n                }\\n                ans += cnt+\\'0\\';\\n                ans += s[l];\\n                l = r;\\n            }\\n           s = ans; \\n        }\\n        return s;\\n    }\\n    string countAndSay(int n) {\\n        return solve(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string solve(int n){\\n        int cnt = 1;\\n        string s = \"1\";\\n        for(int i=2; i<=n; i++){\\n            int l = 0, r = 0;\\n            string ans = \"\";\\n            while(r < s.size()){\\n                int cnt = 0;\\n                while(r < s.size() and s[l] == s[r]){ // check similar character \\n                    cnt++;\\n                    r++;\\n                }\\n                ans += cnt+\\'0\\';\\n                ans += s[l];\\n                l = r;\\n            }\\n           s = ans; \\n        }\\n        return s;\\n    }\\n    string countAndSay(int n) {\\n        return solve(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717340,
                "title": "rust-four-solutions-with-comments",
                "content": "We solve this by simulation. Starting with the base case, iteratively or recursively compute the next entry by grouping the digits, and appending the length of the group and the common group digit to the result.\\n\\nImplementation notes:\\n* I\\'d rather not muck around with using strings for computing the intermediate result. Using a vector with an integer element type is so much simpler and more efficient. We reformat to a string for the return value.\\n* I prefer an iterative approach here to keep things concise and efficient. If we use recursion, we should take care to implement it to allow for tail recursion, so that we are efficient with the stack. I included such a solution as well.\\n* If `group_by` wasn\\'t a nightly feature, we could have used that to make an even more concise and more functional solution. But we can\\'t use that here, so I went for a two-pointer approach to group the digits.\\n* `extend` and `once` make for a concise way to add elements to `next`.\\n\\n**Iterative (More Imperative)**\\n\\n```\\nuse std::iter::once;\\n\\nimpl Solution {\\n    pub fn count_and_say(n: i32) -> String {\\n        let mut curr = vec![1];\\n        for _ in 1..n {\\n            let mut next = vec![];\\n            let mut slow = 0;\\n            for fast in 0..=curr.len() {\\n                if fast == curr.len() || curr[slow] != curr[fast] {\\n                    next.extend(once((fast - slow) as u8).chain(once(curr[slow] as u8)));\\n                    slow = fast;\\n                }\\n            }\\n            curr = next;\\n        }\\n        curr.into_iter().map(|digit| (digit + b\\'0\\') as char).collect()\\n    }\\n}\\n```\\n\\n**Iterative (More Functional)**\\n\\n```\\nuse std::iter::once;\\n\\nimpl Solution {\\n    pub fn count_and_say(n: i32) -> String {\\n        (1..n).fold(vec![1], |curr, _| {\\n            let mut next = vec![];\\n            let mut slow = 0;\\n            for fast in 0..=curr.len() {\\n                if fast == curr.len() || curr[slow] != curr[fast] {\\n                    next.extend(once((fast - slow) as u8).chain(once(curr[slow] as u8)));\\n                    slow = fast;\\n                }\\n            }\\n            next\\n        }).into_iter().map(|digit| (digit + b\\'0\\') as char).collect()\\n    }\\n}\\n```\\n\\n**Recursive with Tail Recursion**\\n\\n```\\nuse std::iter::once;\\n\\nimpl Solution {\\n    fn recurse(curr: &[u8], left: i32) -> Vec<u8> {\\n        if left == 1 {\\n            curr.to_vec()\\n        } else {\\n            let mut next = vec![];\\n            let mut slow = 0;\\n            for fast in 0..=curr.len() {\\n                if fast == curr.len() || curr[slow] != curr[fast] {\\n                    next.extend(once((fast - slow) as u8).chain(once(curr[slow] as u8)));\\n                    slow = fast;\\n                }\\n            }\\n            Self::recurse(&next, left - 1)\\n        }\\n    }\\n\\n    pub fn count_and_say(n: i32) -> String {\\n        Self::recurse(&[1], n).into_iter().map(|digit| (digit + b\\'0\\') as char).collect()\\n    }\\n}\\n```\\n\\n**I Just Had To :P**\\n\\n```\\nconst ANSWERS: [&str; 30] =\\n[\"1\"\\n,\"11\"      \\n,\"21\"      \\n,\"1211\"    \\n,\"111221\"  \\n,\"312211\"  \\n,\"13112221\"\\n,\"1113213211\"\\n,\"31131211131221\"\\n,\"13211311123113112211\"\\n,\"11131221133112132113212221\"\\n,\"3113112221232112111312211312113211\"\\n,\"1321132132111213122112311311222113111221131221\"\\n,\"11131221131211131231121113112221121321132132211331222113112211\"\\n,\"311311222113111231131112132112311321322112111312211312111322212311322113212221\"\\n,\"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\"\\n,\"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\"\\n,\"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\"\\n,\"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\"\\n,\"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\"\\n,\"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n,\"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n,\"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"\\n,\"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"\\n,\"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n,\"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n,\"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"\\n,\"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"\\n,\"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n,\"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"];\\n\\nimpl Solution {\\n    pub fn count_and_say(n: i32) -> String {\\n        ANSWERS[(n - 1) as usize].to_string()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::iter::once;\\n\\nimpl Solution {\\n    pub fn count_and_say(n: i32) -> String {\\n        let mut curr = vec![1];\\n        for _ in 1..n {\\n            let mut next = vec![];\\n            let mut slow = 0;\\n            for fast in 0..=curr.len() {\\n                if fast == curr.len() || curr[slow] != curr[fast] {\\n                    next.extend(once((fast - slow) as u8).chain(once(curr[slow] as u8)));\\n                    slow = fast;\\n                }\\n            }\\n            curr = next;\\n        }\\n        curr.into_iter().map(|digit| (digit + b\\'0\\') as char).collect()\\n    }\\n}\\n```\n```\\nuse std::iter::once;\\n\\nimpl Solution {\\n    pub fn count_and_say(n: i32) -> String {\\n        (1..n).fold(vec![1], |curr, _| {\\n            let mut next = vec![];\\n            let mut slow = 0;\\n            for fast in 0..=curr.len() {\\n                if fast == curr.len() || curr[slow] != curr[fast] {\\n                    next.extend(once((fast - slow) as u8).chain(once(curr[slow] as u8)));\\n                    slow = fast;\\n                }\\n            }\\n            next\\n        }).into_iter().map(|digit| (digit + b\\'0\\') as char).collect()\\n    }\\n}\\n```\n```\\nuse std::iter::once;\\n\\nimpl Solution {\\n    fn recurse(curr: &[u8], left: i32) -> Vec<u8> {\\n        if left == 1 {\\n            curr.to_vec()\\n        } else {\\n            let mut next = vec![];\\n            let mut slow = 0;\\n            for fast in 0..=curr.len() {\\n                if fast == curr.len() || curr[slow] != curr[fast] {\\n                    next.extend(once((fast - slow) as u8).chain(once(curr[slow] as u8)));\\n                    slow = fast;\\n                }\\n            }\\n            Self::recurse(&next, left - 1)\\n        }\\n    }\\n\\n    pub fn count_and_say(n: i32) -> String {\\n        Self::recurse(&[1], n).into_iter().map(|digit| (digit + b\\'0\\') as char).collect()\\n    }\\n}\\n```\n```\\nconst ANSWERS: [&str; 30] =\\n[\"1\"\\n,\"11\"      \\n,\"21\"      \\n,\"1211\"    \\n,\"111221\"  \\n,\"312211\"  \\n,\"13112221\"\\n,\"1113213211\"\\n,\"31131211131221\"\\n,\"13211311123113112211\"\\n,\"11131221133112132113212221\"\\n,\"3113112221232112111312211312113211\"\\n,\"1321132132111213122112311311222113111221131221\"\\n,\"11131221131211131231121113112221121321132132211331222113112211\"\\n,\"311311222113111231131112132112311321322112111312211312111322212311322113212221\"\\n,\"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\"\\n,\"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\"\\n,\"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\"\\n,\"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\"\\n,\"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\"\\n,\"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n,\"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n,\"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"\\n,\"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"\\n,\"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n,\"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"\\n,\"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\"\\n,\"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\"\\n,\"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\"\\n,\"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\"];\\n\\nimpl Solution {\\n    pub fn count_and_say(n: i32) -> String {\\n        ANSWERS[(n - 1) as usize].to_string()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2717054,
                "title": "python-iterative-solution-o-nm-time-o-m-space",
                "content": "```\\n# * Iterative Solution | O(nm) Time | O(m) Space\\n# * n -> The given input | m -> The length of string\\n\\n\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        res = [\"1\"]\\n        n -= 1\\n        while n:\\n            cur_val = []\\n            i = 0\\n            while i < len(res):\\n                cur_count = 1\\n                while i + 1 < len(res) and res[i] == res[i + 1]:\\n                    cur_count += 1\\n                    i += 1\\n\\n                cur_val.extend([str(cur_count), res[i]])\\n                i += 1\\n\\n            res = cur_val\\n            n -= 1\\n\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\n# * Iterative Solution | O(nm) Time | O(m) Space\\n# * n -> The given input | m -> The length of string\\n\\n\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        res = [\"1\"]\\n        n -= 1\\n        while n:\\n            cur_val = []\\n            i = 0\\n            while i < len(res):\\n                cur_count = 1\\n                while i + 1 < len(res) and res[i] == res[i + 1]:\\n                    cur_count += 1\\n                    i += 1\\n\\n                cur_val.extend([str(cur_count), res[i]])\\n                i += 1\\n\\n            res = cur_val\\n            n -= 1\\n\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717007,
                "title": "simple-and-short-solution-easy-understandable",
                "content": "```\\n    string countAndSay(int n) {\\n        if(n==1)\\n            return \"1\";\\n        string prev=\"1\";\\n        for(int i=2;i<=n;i++){\\n            string cur=\"\";\\n            int cnt=0;\\n            char ch=prev[0];\\n            for(char j:prev){\\n                if(ch==j){\\n                    cnt++;\\n                }\\n                else{\\n                    cur+=to_string(cnt)+ch;\\n                    cnt=1;\\n                    ch=j;\\n                }\\n            }\\n            cur+=to_string(cnt)+ch;\\n            prev=cur;\\n        }\\n        return prev;\\n    }\\n\\t",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n    string countAndSay(int n) {\\n        if(n==1)\\n            return \"1\";\\n        string prev=\"1\";\\n        for(int i=2;i<=n;i++){\\n            string cur=\"\";\\n            int cnt=0;\\n            char ch=prev[0];\\n            for(char j:prev){\\n                if(ch==j){\\n                    cnt++;\\n                }\\n                else{\\n                    cur+=to_string(cnt)+ch;\\n                    cnt=1;\\n                    ch=j;\\n                }\\n            }\\n            cur+=to_string(cnt)+ch;\\n            prev=cur;\\n        }\\n        return prev;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2716587,
                "title": "easy-to-understand-simple-solution",
                "content": "```\\nclass Solution\\n{\\n    string getCurrentSequence(string &previous)\\n    {\\n        string current;\\n        int counter = 1;\\n\\n        for (int idx = 1; idx < previous.length(); idx++)\\n        {\\n            if (previous[idx - 1] == previous[idx])\\n            {\\n                counter += 1;\\n            }\\n            else\\n            {\\n                current += to_string(counter);\\n                current.push_back(previous[idx - 1]);\\n                counter = 1;\\n            }\\n        }\\n\\n        current += to_string(counter);\\n        current.push_back(previous.back());\\n\\n        return current;\\n    }\\n\\n    public:\\n        string countAndSay(int n)\\n        {\\n            if (n == 1)\\n                return \"1\";\\n\\n            string previous = countAndSay(n - 1);\\n            return getCurrentSequence(previous);\\n        }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\n    string getCurrentSequence(string &previous)\\n    {\\n        string current;\\n        int counter = 1;\\n\\n        for (int idx = 1; idx < previous.length(); idx++)\\n        {\\n            if (previous[idx - 1] == previous[idx])\\n            {\\n                counter += 1;\\n            }\\n            else\\n            {\\n                current += to_string(counter);\\n                current.push_back(previous[idx - 1]);\\n                counter = 1;\\n            }\\n        }\\n\\n        current += to_string(counter);\\n        current.push_back(previous.back());\\n\\n        return current;\\n    }\\n\\n    public:\\n        string countAndSay(int n)\\n        {\\n            if (n == 1)\\n                return \"1\";\\n\\n            string previous = countAndSay(n - 1);\\n            return getCurrentSequence(previous);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707034,
                "title": "c-java-0-ms-100-00-faster-easy-solution",
                "content": "````\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        vector<string> v;\\n        string s=\"\";\\n        v.push_back(s);\\n        for(int i=1;i<=n;i++){\\n            s=v[i-1];\\n            if(s==\"\") v.push_back(\"1\");\\n            else{\\n                string ans=\"\";\\n                int count=1,flag=1;\\n                for(int i=0;i<s.size()-1;++i){\\n                    if(s[i+1]==s[i]){\\n                        count++;\\n                    }\\n                    else{\\n                        ans+=(count+\\'0\\');\\n                        ans+=s[i];\\n                        count=1;\\n                    }  \\n                }\\n                if(flag==1){\\n                    ans+=(count+\\'0\\');\\n                    ans+=s[s.size()-1];\\n                }\\n                v.push_back(ans);\\n            }\\n        }\\n        return v[n];\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "String",
                    "Recursion",
                    "Iterator"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        vector<string> v;\\n        string s=\"\";\\n        v.push_back(s);\\n        for(int i=1;i<=n;i++){\\n            s=v[i-1];\\n            if(s==\"\") v.push_back(\"1\");\\n            else{\\n                string ans=\"\";\\n                int count=1,flag=1;\\n                for(int i=0;i<s.size()-1;++i){\\n                    if(s[i+1]==s[i]){\\n                        count++;\\n                    }\\n                    else{\\n                        ans+=(count+\\'0\\');\\n                        ans+=s[i];\\n                        count=1;\\n                    }  \\n                }\\n                if(flag==1){\\n                    ans+=(count+\\'0\\');\\n                    ans+=s[s.size()-1];\\n                }\\n                v.push_back(ans);\\n            }\\n        }\\n        return v[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2348106,
                "title": "c-solution-comments-easy-n-simple-faster-than-73-and-97",
                "content": "Here I tried to use the memoized approach in case of multiple test cases, so we have the precomputed table upto n=30. \\n(For a faster result, see below)\\n```\\n// initialized a vector of strings for each n==1 to n==30\\nvector<string> s{31, \"\"};\\n\\n// function to calculate the requires string\\nvoid calc(){\\n\\t// initialized the n=1, n=2 pos for s as \"1\", and \"11\" respectively.\\n\\ts[1] = \"1\", s[2] = \"11\";\\n\\t\\n\\t// initialized a count variable to keep track of consecutive same digits.\\n\\tint count=0;\\n\\n\\t// since we already have till 2, we start from 3.\\n\\tfor(int j=3; j<31; j++){\\n\\t\\tint pos=0;\\n\\t\\t// for each loop, we traverse through the previous string\\n\\t\\twhile(i<s[j-1].length()){\\n\\t\\t\\tcount =1;\\n\\t\\t\\t// here char c to keep track of the current character I\\'m checking\\n\\t\\t\\tchar c = s[j-1][pos];\\n\\t\\t\\t\\n\\t\\t\\t// whenever I encounter a same string, I increase count and the pos by 1\\n\\t\\t\\twhile(pos+1<s[j-1].length() && s[j-1][pos]==s[j-1][pos+1])\\n\\t\\t\\t\\tpos++, count++;\\n\\t\\t\\t\\t\\n\\t\\t\\t// when I don\\'t see consecutive digits same, I break out of loop and add it to string\\n\\t\\t\\ts[j] = s[j] + to_string(count) + (c);\\n\\t\\t\\tpos++;\\n\\t\\t}\\n\\t}\\n}\\n\\nstring countAndSay(int n) {\\n\\tcalc();\\n\\treturn s[n];\\n}\\n```\\n\\nFor a faster runtime: you can pass an argument to calc, so that the calc function only runs for that many times, decreasing the space and time usage, which gives you faster than other methods.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Memoization"
                ],
                "code": "```\\n// initialized a vector of strings for each n==1 to n==30\\nvector<string> s{31, \"\"};\\n\\n// function to calculate the requires string\\nvoid calc(){\\n\\t// initialized the n=1, n=2 pos for s as \"1\", and \"11\" respectively.\\n\\ts[1] = \"1\", s[2] = \"11\";\\n\\t\\n\\t// initialized a count variable to keep track of consecutive same digits.\\n\\tint count=0;\\n\\n\\t// since we already have till 2, we start from 3.\\n\\tfor(int j=3; j<31; j++){\\n\\t\\tint pos=0;\\n\\t\\t// for each loop, we traverse through the previous string\\n\\t\\twhile(i<s[j-1].length()){\\n\\t\\t\\tcount =1;\\n\\t\\t\\t// here char c to keep track of the current character I\\'m checking\\n\\t\\t\\tchar c = s[j-1][pos];\\n\\t\\t\\t\\n\\t\\t\\t// whenever I encounter a same string, I increase count and the pos by 1\\n\\t\\t\\twhile(pos+1<s[j-1].length() && s[j-1][pos]==s[j-1][pos+1])\\n\\t\\t\\t\\tpos++, count++;\\n\\t\\t\\t\\t\\n\\t\\t\\t// when I don\\'t see consecutive digits same, I break out of loop and add it to string\\n\\t\\t\\ts[j] = s[j] + to_string(count) + (c);\\n\\t\\t\\tpos++;\\n\\t\\t}\\n\\t}\\n}\\n\\nstring countAndSay(int n) {\\n\\tcalc();\\n\\treturn s[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2097846,
                "title": "easy-java-solution-using-recursion",
                "content": "```\\npublic String countAndSay(int n) {\\n        String fRes = \"\";\\n        if(n == 1) return \"1\";\\n        else{\\n            String res = countAndSay(n-1);\\n            int count = 1;\\n            int i;\\n            for(i=0; i<res.length()-1; i++){\\n                if(res.charAt(i) == res.charAt(i+1)) count++;\\n                else{\\n                    fRes+= Integer.toString(count)+res.charAt(i);\\n                    count = 1;\\n                }\\n            }\\n            fRes+= Integer.toString(count)+res.charAt(i);\\n        }\\n        return fRes;\\n    }\\n```\\n**Please upvote if you appreciate the solution**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic String countAndSay(int n) {\\n        String fRes = \"\";\\n        if(n == 1) return \"1\";\\n        else{\\n            String res = countAndSay(n-1);\\n            int count = 1;\\n            int i;\\n            for(i=0; i<res.length()-1; i++){\\n                if(res.charAt(i) == res.charAt(i+1)) count++;\\n                else{\\n                    fRes+= Integer.toString(count)+res.charAt(i);\\n                    count = 1;\\n                }\\n            }\\n            fRes+= Integer.toString(count)+res.charAt(i);\\n        }\\n        return fRes;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2009234,
                "title": "c-100-faster-solution-easy-code-with-explanation",
                "content": "```\\n string countAndSay(int n) \\n    {\\n        string str=\"11\";\\n        if(n==1) return \"1\";\\n        if(n==2) return \"11\";\\n        n-=2; //Becase for n=1 and n=2 i\\'ve already stored the answer so i need to substract the size\\n        while(n--)\\n        {\\n          int count=1;\\n          string temp=\"\";\\n          for(int i=0;i<str.size();i++)\\n          {\\n\\t\\t   //If str[i]!=str[i+1] than i will have only 1 element with frequency one so count will 1 and say will str[i];\\n             if((i+1 < str.size()) and str[i]!=str[i+1])\\n             {\\n\\t\\t\\t    //Push Count\\n                temp.push_back(\\'1\\');\\n\\t\\t\\t\\t//Push Say\\n                temp.push_back(str[i]);\\n             }\\n\\t\\t\\t //Else i will count all the frequency of the charactor and than count will be No. of freq. and say will be str[i]\\n             else\\n             {\\n\\t\\t\\t   //Count total no. of freq. if they are same\\n                 while((i+1<str.size()) and str[i]==str[i+1])\\n                 {\\n                     count++;\\n                     i++;\\n                 }\\n\\t\\t\\t\\t  //Push Count\\n                 temp+=to_string(count);\\n\\t\\t\\t\\t  //Push Say\\n                 temp.push_back(str[i]);       \\n                 count=1;\\n             }\\n          }\\n\\t\\t     //Update str \\n              str = temp;\\n\\t\\t\\t  //Repeat this step n times \\n         }\\n        return str;\\n    }\\n     \\t//This Code is contributed By SOHAIL KHAN\\n\\t\\t//Please Upvote if you find it HELPFULL \\n\\t\\t//Let me know in the comment section if you still have doubts\\n\\t\\t//Thankyou\\n\\t\\t//#Happycoding ;-)\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\n string countAndSay(int n) \\n    {\\n        string str=\"11\";\\n        if(n==1) return \"1\";\\n        if(n==2) return \"11\";\\n        n-=2; //Becase for n=1 and n=2 i\\'ve already stored the answer so i need to substract the size\\n        while(n--)\\n        {\\n          int count=1;\\n          string temp=\"\";\\n          for(int i=0;i<str.size();i++)\\n          {\\n\\t\\t   //If str[i]!=str[i+1] than i will have only 1 element with frequency one so count will 1 and say will str[i];\\n             if((i+1 < str.size()) and str[i]!=str[i+1])\\n             {\\n\\t\\t\\t    //Push Count\\n                temp.push_back(\\'1\\');\\n\\t\\t\\t\\t//Push Say\\n                temp.push_back(str[i]);\\n             }\\n\\t\\t\\t //Else i will count all the frequency of the charactor and than count will be No. of freq. and say will be str[i]\\n             else\\n             {\\n\\t\\t\\t   //Count total no. of freq. if they are same\\n                 while((i+1<str.size()) and str[i]==str[i+1])\\n                 {\\n                     count++;\\n                     i++;\\n                 }\\n\\t\\t\\t\\t  //Push Count\\n                 temp+=to_string(count);\\n\\t\\t\\t\\t  //Push Say\\n                 temp.push_back(str[i]);       \\n                 count=1;\\n             }\\n          }\\n\\t\\t     //Update str \\n              str = temp;\\n\\t\\t\\t  //Repeat this step n times \\n         }\\n        return str;\\n    }\\n     \\t//This Code is contributed By SOHAIL KHAN\\n\\t\\t//Please Upvote if you find it HELPFULL \\n\\t\\t//Let me know in the comment section if you still have doubts\\n\\t\\t//Thankyou\\n\\t\\t//#Happycoding ;-)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1943045,
                "title": "java-recursion-solution-with-explain",
                "content": "Firstly, we need to confirm our base case\\n```\\nif(n == 1){\\n\\treturn \"1\";\\n}\\n```\\nThen we create a counter and a pointer, go through n - 1 string. Count number of same char, and if pointer met with a different integer, add the counter number and previous integer into stringbuilder. \\n\\nOne reminder is, when adding string to stringbuilder\\ndo\\n```\\n\\tstringBuilder.append(String.valueOf(counter)).append(prev);\\n\\tinstead of\\n\\tstringBuilder.append(String.valueOf(counter + prev));\\n```\\nusing append is faster than suming string\\n\\nComplete code\\n```\\npublic String countAndSay(int n) {\\n        if(n == 1){\\n            return \"1\";\\n        }\\n        String t = countAndSay(n - 1);\\n        StringBuilder stringBuilder = new StringBuilder();\\n        int counter = 1;\\n        char lastInteger = t.charAt(0);\\n        for(int i = 1; i < t.length(); i++){\\n            if(t.charAt(i) == t.charAt(i-1)){\\n                counter++;\\n            }else{\\n                stringBuilder.append(counter).append(lastInteger);\\n                lastInteger = t.charAt(i);\\n                counter = 1;\\n            }\\n        }\\n        stringBuilder.append(counter).append(lastInteger);\\n        return stringBuilder.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nif(n == 1){\\n\\treturn \"1\";\\n}\\n```\n```\\n\\tstringBuilder.append(String.valueOf(counter)).append(prev);\\n\\tinstead of\\n\\tstringBuilder.append(String.valueOf(counter + prev));\\n```\n```\\npublic String countAndSay(int n) {\\n        if(n == 1){\\n            return \"1\";\\n        }\\n        String t = countAndSay(n - 1);\\n        StringBuilder stringBuilder = new StringBuilder();\\n        int counter = 1;\\n        char lastInteger = t.charAt(0);\\n        for(int i = 1; i < t.length(); i++){\\n            if(t.charAt(i) == t.charAt(i-1)){\\n                counter++;\\n            }else{\\n                stringBuilder.append(counter).append(lastInteger);\\n                lastInteger = t.charAt(i);\\n                counter = 1;\\n            }\\n        }\\n        stringBuilder.append(counter).append(lastInteger);\\n        return stringBuilder.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1890608,
                "title": "100-fastest-typescript-solution",
                "content": "```\\ntype Group = [number, string]\\nconst results: { [key: string]: string } = { \"1\": \"1\" }\\n\\nfunction countAndSay(n: number): string {\\n  if (n > 30) { throw new Error(\"Max n exceeded\") }\\n\\n  if (!results[n]) { results[n] = sayGroup(getGroups(countAndSay(n - 1))) }\\n  return results[n]\\n}\\n\\nfunction sayGroup(groups: Group[]): string {\\n  return groups\\n         .map(([count, symbol]) => { return `${count}${symbol}` })\\n         .join(\"\")\\n}\\n\\nfunction getGroups(str: string) {\\n  const groups: [number, string][] = []\\n  let lastGroup: [number, string]\\n\\n  str.split(\"\").reduce((prev, curr, i) => {\\n    if (prev !== curr) {\\n      lastGroup = [0, curr]\\n      groups.push(lastGroup)\\n    }\\n\\n    lastGroup[0]++\\n    return curr\\n  }, \"\")\\n\\n  return groups\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Group = [number, string]\\nconst results: { [key: string]: string } = { \"1\": \"1\" }\\n\\nfunction countAndSay(n: number): string {\\n  if (n > 30) { throw new Error(\"Max n exceeded\") }\\n\\n  if (!results[n]) { results[n] = sayGroup(getGroups(countAndSay(n - 1))) }\\n  return results[n]\\n}\\n\\nfunction sayGroup(groups: Group[]): string {\\n  return groups\\n         .map(([count, symbol]) => { return `${count}${symbol}` })\\n         .join(\"\")\\n}\\n\\nfunction getGroups(str: string) {\\n  const groups: [number, string][] = []\\n  let lastGroup: [number, string]\\n\\n  str.split(\"\").reduce((prev, curr, i) => {\\n    if (prev !== curr) {\\n      lastGroup = [0, curr]\\n      groups.push(lastGroup)\\n    }\\n\\n    lastGroup[0]++\\n    return curr\\n  }, \"\")\\n\\n  return groups\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1834726,
                "title": "c-simple-code-easy-to-understand",
                "content": "**Upvote if you like the solution**\\n```\\nstring countAndSay(int n) {\\n        string res=\"1\";\\n        while(--n){\\n            string temp=\"\";\\n            int sze=res.size();\\n            \\n            for(int j=0;j<sze;){\\n                int count=0,left=j,right=j;\\n                while(right<sze && res[left]==res[right]){\\n                    count++;\\n                    right++;\\n                }\\n                j=right;\\n                \\n                temp+=to_string(count)+res[left];\\n            }\\n            res=temp;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "**Upvote if you like the solution**\\n```\\nstring countAndSay(int n) {\\n        string res=\"1\";\\n        while(--n){\\n            string temp=\"\";\\n            int sze=res.size();\\n            \\n            for(int j=0;j<sze;){\\n                int count=0,left=j,right=j;\\n                while(right<sze && res[left]==res[right]){\\n                    count++;\\n                    right++;\\n                }\\n                j=right;\\n                \\n                temp+=to_string(count)+res[left];\\n            }\\n            res=temp;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1596269,
                "title": "problem-explanation-java-solution",
                "content": "I think the problem was not explained very clearly. There are two things to understand:\\n\\n1. **countAndSay** is the way you would read out the string. Let\\'s just call it the compressed version of a string.\\n\\t- For example: If I gave you a random string \"22233413\" you would compress it based on the counts of repeating characters. \\n\\t- So you would see it like this: \"222 - 33 - 4 - 1- 3\" and compress it to \"32 - 23 - 14 - 11 - 13\"  because there are three 2\\'s, two 3\\'s, one 4, two 1\\'s, one 3 in the input string. \\n\\t- Hence, the countAndSay equivalent (or the compressed version) of \"22233413\" is \"3223141113\".\\n\\n2. **What the problem wants?**\\n\\t- Let us first understand the base case. If n=1, we do not perform a countAndSay on it. We just assume it\\'s countAndSay equivalent (or compressed representation) will be \"1\".\\n\\t- Now, for given int n, we return the compressed string of countAndSay(n-1). *This is key to understanding the question.*\\n\\t- Consider the example of input n=2. Remember the compressed string of 1 is \"1\"\\n\\t- so for n=2, countAndSay(2) = compress(countAndSay(2-1)) = compress(countAndSay(1)) = compress(\"1\")  = \"11\" because there is one 1 in \"1\". \\n\\t- So this way, countAndSay(3) = compress(countAndSay(2)) = compress(\"11\") = \"21\" because there are two 1\\'s.\\n\\nI hope this helps you understand what the question is about. \\n\\n```\\nclass Solution {\\n    \\n    public String countAndSay(int n) {\\n        //store compressed version for each integer upto n \\n        String[] memo = new String[n];\\n        \\n        //base case i.e. countAndSay equivalent of n = 1\\n        memo[0] = \"1\";\\n        \\n\\t\\t//for each i < n, we compute the compressed version of i - 1\\n        for(int i=1; i<n; i++){\\n            memo[i] = compress(memo[i-1].toCharArray());\\n        }\\n        \\n        return memo[n-1];\\n    }\\n    \\n    //build the compressed string\\n    public String compress(char[] c){\\n        int count = 1;\\n        StringBuilder ans = new StringBuilder();\\n        \\n        for(int i=1; i<c.length; i++){\\n            if(c[i] == c[i-1]){\\n                count++;\\n            }else{\\n                ans.append(count).append(c[i-1]);\\n                count = 1;\\n            }\\n        }\\n        \\n        ans.append(count).append(c[c.length-1]);\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String countAndSay(int n) {\\n        //store compressed version for each integer upto n \\n        String[] memo = new String[n];\\n        \\n        //base case i.e. countAndSay equivalent of n = 1\\n        memo[0] = \"1\";\\n        \\n\\t\\t//for each i < n, we compute the compressed version of i - 1\\n        for(int i=1; i<n; i++){\\n            memo[i] = compress(memo[i-1].toCharArray());\\n        }\\n        \\n        return memo[n-1];\\n    }\\n    \\n    //build the compressed string\\n    public String compress(char[] c){\\n        int count = 1;\\n        StringBuilder ans = new StringBuilder();\\n        \\n        for(int i=1; i<c.length; i++){\\n            if(c[i] == c[i-1]){\\n                count++;\\n            }else{\\n                ans.append(count).append(c[i-1]);\\n                count = 1;\\n            }\\n        }\\n        \\n        ans.append(count).append(c[c.length-1]);\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231949,
                "title": "100-faster-easy-code",
                "content": "***Do upvote if you like the solution to keep me motivated*** \\uD83D\\uDE0A\\u270C\\n```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n == 1) return \"1\";\\n        if(n == 2) return \"11\";\\n        string s = \"11\";\\n        for(int i=3 ; i<=n ; i++)\\n        {\\n            s+=\"$\"; // to check last character\\n            string t = \"\";\\n            int count = 1;\\n            for(int j=1 ; j<s.length() ; j++)\\n            {\\n                if(s[j]!=s[j-1])\\n                {\\n                    t += count + \\'0\\';\\n                    t += s[j-1];\\n                    count = 1;\\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n            }\\n            s = t;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n == 1) return \"1\";\\n        if(n == 2) return \"11\";\\n        string s = \"11\";\\n        for(int i=3 ; i<=n ; i++)\\n        {\\n            s+=\"$\"; // to check last character\\n            string t = \"\";\\n            int count = 1;\\n            for(int j=1 ; j<s.length() ; j++)\\n            {\\n                if(s[j]!=s[j-1])\\n                {\\n                    t += count + \\'0\\';\\n                    t += s[j-1];\\n                    count = 1;\\n                }\\n                else\\n                {\\n                    count++;\\n                }\\n            }\\n            s = t;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 985543,
                "title": "c-iterative-solution",
                "content": "```\\nstring countAndSay(int n) {\\n            if(n==1) return \"1\";\\n            if(n==2) return \"11\";\\n            string s = \"11\";\\n            for(int i = 3;i<=n;i++)\\n            {\\n                    string temp = \"\";\\n                    s=s+\\'&\\';\\n                    int c = 1;\\n                    for(int j = 1;j<s.length();j++)\\n                    {\\n                            if(s[j] == s[j-1]) c++;\\n                            else\\n                            {\\n                                    temp+= to_string(c);\\n                                    temp+=s[j-1];\\n                                    c=1;\\n                            }\\n                            \\n                    }\\n                 s=temp;\\n            }\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "```\\nstring countAndSay(int n) {\\n            if(n==1) return \"1\";\\n            if(n==2) return \"11\";\\n            string s = \"11\";\\n            for(int i = 3;i<=n;i++)\\n            {\\n                    string temp = \"\";\\n                    s=s+\\'&\\';\\n                    int c = 1;\\n                    for(int j = 1;j<s.length();j++)\\n                    {\\n                            if(s[j] == s[j-1]) c++;\\n                            else\\n                            {\\n                                    temp+= to_string(c);\\n                                    temp+=s[j-1];\\n                                    c=1;\\n                            }\\n                            \\n                    }\\n                 s=temp;\\n            }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 929252,
                "title": "js-one-line-solution-with-regex",
                "content": "```\\nreturn n === 1 ? \\'1\\' : countAndSay(n - 1).match(/(.)\\\\1*/g).map(match => match.length + match[0]).join(\\'\\');\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nreturn n === 1 ? \\'1\\' : countAndSay(n - 1).match(/(.)\\\\1*/g).map(match => match.length + match[0]).join(\\'\\');\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 413224,
                "title": "python-recursion-solution-12ms-99",
                "content": "```\\n# Runtime: 12 ms, faster than 99.00% of Python online submissions for Count and Say.\\n\\nclass Solution(object):\\n    def countAndSay(self, n):\\n        if n <= 1:\\n            return \"1\"\\n        prevCountAndSay = self.countAndSay(n - 1)\\n        last = None\\n        occurrence = None\\n        output = \"\"\\n        for i in prevCountAndSay:\\n            if last is not None:\\n                if i == last:\\n                    occurrence += 1\\n                else:\\n                    output += str(occurrence) + last\\n                    occurrence = 1\\n            else:\\n                occurrence = 1\\n            last = i\\n        return output if occurrence is None else output + str(occurrence) + last\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n# Runtime: 12 ms, faster than 99.00% of Python online submissions for Count and Say.\\n\\nclass Solution(object):\\n    def countAndSay(self, n):\\n        if n <= 1:\\n            return \"1\"\\n        prevCountAndSay = self.countAndSay(n - 1)\\n        last = None\\n        occurrence = None\\n        output = \"\"\\n        for i in prevCountAndSay:\\n            if last is not None:\\n                if i == last:\\n                    occurrence += 1\\n                else:\\n                    output += str(occurrence) + last\\n                    occurrence = 1\\n            else:\\n                occurrence = 1\\n            last = i\\n        return output if occurrence is None else output + str(occurrence) + last\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 379838,
                "title": "java-simple-solution-beats-100",
                "content": "We have to build up to the nth # and count how many occurences there are\\n```\\npublic String countAndSay(int n) {\\n        String s = \"1\"; // base \\n        for(int i = 1; i < n; i++){ // build the numbers from 1 to n\\n            s = nextNumber(s);\\n        }\\n        return s; // return result\\n    }\\n    private static String nextNumber(String s){ // our helper method\\n        StringBuilder result = new StringBuilder(); // create new StringBuilder\\n        for(int i = 0; i < s.length(); i++){ // take in previous # and prepare to run across it\\n            int count = 1; // initialize how many times we\\'ve seen a #\\n            while(i + 1 < s.length() && s.charAt(i) == s.charAt(i+1)){ // while we don\\'t run off the end \\n\\t\\t\\t// and we\\'re still on the same #\\n                i++; // increment our pointer\\n                count++; // increment how many times we\\'ve seen that #\\n            }\\n            result.append(count).append(s.charAt(i)); // and append the count and then the #\\n        }\\n        return result.toString(); // and finally return\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String countAndSay(int n) {\\n        String s = \"1\"; // base \\n        for(int i = 1; i < n; i++){ // build the numbers from 1 to n\\n            s = nextNumber(s);\\n        }\\n        return s; // return result\\n    }\\n    private static String nextNumber(String s){ // our helper method\\n        StringBuilder result = new StringBuilder(); // create new StringBuilder\\n        for(int i = 0; i < s.length(); i++){ // take in previous # and prepare to run across it\\n            int count = 1; // initialize how many times we\\'ve seen a #\\n            while(i + 1 < s.length() && s.charAt(i) == s.charAt(i+1)){ // while we don\\'t run off the end \\n\\t\\t\\t// and we\\'re still on the same #\\n                i++; // increment our pointer\\n                count++; // increment how many times we\\'ve seen that #\\n            }\\n            result.append(count).append(s.charAt(i)); // and append the count and then the #\\n        }\\n        return result.toString(); // and finally return\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 376384,
                "title": "java-hint-and-solution",
                "content": "OK I found this question quite hard to understand and my inital solutions were \"timing out\" at n=5.  I realized I had not understood the problem correctly.\\n\\nMy tip is run the code for n=6 and n=7 to see more of the pattern - then it\\'s easier to understand the problem:\\n\\nn=1:   1\\nn=2:   11\\nn=3:   21\\nn=4:   1211\\nn=5:   111221\\nn=6:   312211\\nn=7:   13112221\\n\\nNotice how at n=5 the \\'111\\' is translated to \\'31\\' in the next iteration (at n=6).  \\'111\\' means \"3 ones\" so convert to the number of times that number occured, followed by the value (i.e. \\'31\\').  This helped me understand the problem correctly.\\n\\nHere\\'s my final solution below using recrsion:\\n\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if (n == 0) return \"1\";\\n        if (n == 1) return \"1\";\\n        if (n == 2) return \"11\";\\n        \\n        String current = countAndSay(n-1);\\n        \\n        int pos = 1;\\n        char prev = current.charAt(0);\\n        int count = 1;\\n        \\n        StringBuffer sb = new StringBuffer();\\n        \\n        while (pos < current.length()) {\\n            if (current.charAt(pos) == prev) {\\n                count++;\\n            }\\n            else {\\n                sb.append(count);\\n                sb.append(prev);\\n                count = 1;\\n                prev = current.charAt(pos);\\n            }\\n            \\n            if (pos+1 == current.length()) {\\n                sb.append(count);\\n                sb.append(prev);\\n            }\\n            \\n            pos++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if (n == 0) return \"1\";\\n        if (n == 1) return \"1\";\\n        if (n == 2) return \"11\";\\n        \\n        String current = countAndSay(n-1);\\n        \\n        int pos = 1;\\n        char prev = current.charAt(0);\\n        int count = 1;\\n        \\n        StringBuffer sb = new StringBuffer();\\n        \\n        while (pos < current.length()) {\\n            if (current.charAt(pos) == prev) {\\n                count++;\\n            }\\n            else {\\n                sb.append(count);\\n                sb.append(prev);\\n                count = 1;\\n                prev = current.charAt(pos);\\n            }\\n            \\n            if (pos+1 == current.length()) {\\n                sb.append(count);\\n                sb.append(prev);\\n            }\\n            \\n            pos++;\\n        }\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248980,
                "title": "java-solution-from-pratik",
                "content": "**Solution 1:**\\n\\n**Algorithm:**\\n1. We compute the `N`<sup>th</sup> number by iteratively applying the given rule `N - 1` times.\\n1. Since we are counting digits, it is natural to use strings to represent the integers in the sequence. Specifically going from `i`<sup>th</sup> number to the `(i + 1)`<sup>th</sup> number entails scanning the digits from the most significant to least significant, counting the number of consecutive equal digits, and writing these counts.\\n\\n**Time complexity:** O(N * 2<sup>N</sup>)\\n- The precise time complexity is a function of the lengths of the terms, which is extremely hard to analyze.\\n- Each successive number can have at most twice as many digits as the previous number and this happens when all digits are different [`21` -> `1211`]. This means a maximum length number has length no more than 2<sup>N</sup>.\\n- Since there are `N` iterations and the work in each iteration is proportional to the length of the number computed in the iteration (which is 2<sup>N</sup>). So the simple bound on the time complexity is O(N * 2<sup>N</sup>)\\n\\n**Space complexity:** O(2<sup>N</sup>), space required for the `StringBuilder`. The generaed `N`<sup>th</sup> term for a number `N` can have a length of at most 2<sup>N</sup>.\\n\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String s = \"1\";\\n\\n        for (int i = 1; i < n; i++) {\\n            s = nextNumber(s);\\n        }\\n        return s;\\n    }\\n\\n    private String nextNumber(String s) {\\n        StringBuilder stringBuilder = new StringBuilder();\\n        int count = 1;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i < s.length() - 1 && s.charAt(i) == s.charAt(i + 1)) {\\n                count++;\\n            } else {\\n                stringBuilder.append(count);\\n                stringBuilder.append(s.charAt(i));\\n                count = 1;\\n            }\\n        }\\n        return stringBuilder.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String s = \"1\";\\n\\n        for (int i = 1; i < n; i++) {\\n            s = nextNumber(s);\\n        }\\n        return s;\\n    }\\n\\n    private String nextNumber(String s) {\\n        StringBuilder stringBuilder = new StringBuilder();\\n        int count = 1;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (i < s.length() - 1 && s.charAt(i) == s.charAt(i + 1)) {\\n                count++;\\n            } else {\\n                stringBuilder.append(count);\\n                stringBuilder.append(s.charAt(i));\\n                count = 1;\\n            }\\n        }\\n        return stringBuilder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 16274,
                "title": "my-simple-java-solution",
                "content": "    public class Solution {\\n        public String countAndSay(int n) {\\n            if(n <= 0) return \"\";\\n            String init = \"1\";\\n            while(n-- > 1){\\n                init = say(init);\\n            }\\n            return init;\\n        }\\n        public String say(String str){\\n            if(str.length() < 1) return \"\";\\n            int count = 1;\\n            StringBuilder sb = new StringBuilder();\\n            char c = str.charAt(0);\\n            if(str.length() == 1){\\n                sb.append(count);\\n                sb.append(c);\\n                return sb.toString();\\n            }\\n            for(int i = 1; i < str.length(); i ++){\\n                if(str.charAt(i) == str.charAt(i - 1)){\\n                    count ++;\\n                }else{\\n                    sb.append(count);\\n                    sb.append(c);\\n                    count = 1;\\n                    c = str.charAt(i);\\n                }\\n            }\\n            sb.append(count);\\n            sb.append(c);\\n            return sb.toString();\\n        }\\n    }\\nA simple java solution, say function is to return the next item in the sequence using the previous item.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String countAndSay(int n) {\\n            if(n <= 0) return \"\";\\n            String init = \"1\";\\n            while(n-- > 1){\\n                init = say(init);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 16388,
                "title": "simple-java-solution",
                "content": "\\n    public String countAndSay(int n) {\\n        if (n <= 0) {return \"\";}\\n        String res = \"1\";\\n        for (int i = 1; i < n; i++) {\\n            String pre = res;\\n            res = \"\";\\n            char temp = pre.charAt(0);\\n            int count = 1;\\n            for (int j = 1; j < pre.length(); j++) {\\n                if (pre.charAt(j) != temp) {\\n                    res = res + count + temp;\\n                    temp = pre.charAt(j);\\n                    count = 1;\\n                } else {\\n                    count++;\\n                }\\n            }\\n            res = res + count + temp;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public String countAndSay(int n) {\\n        if (n <= 0) {return \"\";}\\n        String res = \"1\";\\n        for (int i = 1; i < n; i++) {\\n            String pre = res;\\n            res = \"\";\\n            char temp = pre.charAt(0);\\n            int count = 1;\\n            for (int j = 1; j < pre.length(); j++) {\\n                if (pre.charAt(j) != temp) {\\n                    res = res + count + temp;\\n                    temp = pre.charAt(j);\\n                    count = 1;\\n                } else {\\n                    count++;\\n                }\\n            }\\n            res = res + count + temp;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 16244,
                "title": "accepted-python-solution-not-efficiency-but-easy-to-read",
                "content": "    class Solution:\\n    # @return a string\\n    def countAndSay(self, n):\\n        s = ['1']\\n        result = '1'\\n        # The n-th sequance, input 1 should output '1'\\n        for i in range(n-1):\\n            start = 0\\n            temp = []\\n            # Process one sequence, scan from start to end\\n            while start < len(s):\\n                count = 1\\n                next = start + 1\\n                # Scan until s[next] is different\\n                while next < len(s) and s[start] == s[next]:\\n                    next += 1\\n                    count += 1\\n                # Get the new items in\\n                temp.append(str(count))\\n                temp.append(s[start])\\n                # Start from next one\\n                start = next\\n            # Concatenate list into string, using \",\" as separator in default \\n            result = ''.join(temp)\\n            s = temp\\n        return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @return a string\\n    def countAndSay(self, n):\\n        s = ['1']\\n        result = '1'\\n        # The n-th sequance, input 1 should output '1'\\n        for i in range(n-1):\\n            start = 0\\n            temp = []\\n            # Process one sequence, scan from start to end\\n            while start < len(s):\\n                count = 1\\n                next = start + 1\\n                # Scan until s[next] is different\\n                while next < len(s) and s[start] == s[next]:\\n                    next += 1\\n                    count += 1\\n                # Get the new items in\\n                temp.append(str(count))\\n                temp.append(s[start])\\n                # Start from next one\\n                start = next\\n            # Concatenate list into string, using \",\" as separator in default \\n            result = ''.join(temp)\\n            s = temp\\n        return result",
                "codeTag": "Java"
            },
            {
                "id": 16471,
                "title": "9-line-solution-in-python",
                "content": "    class Solution:\\n    def countAndSay(self, n):\\n        say = '1'\\n        for i in xrange(n - 1):\\n            next = ''\\n            for item in [list(g) for k, g in itertools.groupby(say)]:\\n                next += str(len(item)) + str(item[0])\\n            say = next\\n        return say",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    def countAndSay(self, n):\\n        say = '1'\\n        for i in xrange(n - 1):\\n            next = ''\\n            for item in [list(g) for k, g in itertools.groupby(say)]:\\n                next += str(len(item)) + str(item[0])\\n            say = next\\n        return say",
                "codeTag": "Java"
            },
            {
                "id": 3884789,
                "title": "beginners-level-easy-solution-easy-understandable",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String val=\"1\";\\n        for (int i=0;i<n-1;i++)\\n        {\\n            char ch=val.charAt(0);\\n            StringBuilder sb=new StringBuilder();\\n            int count=1;\\n            for (int j=1;j<val.length();j++)\\n            {\\n                if (ch!=val.charAt(j))\\n                {\\n                    \\n                    sb.append(count);\\n                    sb.append(ch);\\n                    count=0;\\n                    ch=val.charAt(j);\\n                }\\n                count++;\\n            }\\n            sb.append(count);\\n            sb.append(ch);\\n            val=sb.toString();\\n        }\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        String val=\"1\";\\n        for (int i=0;i<n-1;i++)\\n        {\\n            char ch=val.charAt(0);\\n            StringBuilder sb=new StringBuilder();\\n            int count=1;\\n            for (int j=1;j<val.length();j++)\\n            {\\n                if (ch!=val.charAt(j))\\n                {\\n                    \\n                    sb.append(count);\\n                    sb.append(ch);\\n                    count=0;\\n                    ch=val.charAt(j);\\n                }\\n                count++;\\n            }\\n            sb.append(count);\\n            sb.append(ch);\\n            val=sb.toString();\\n        }\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860139,
                "title": "simple-c-100-faster-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\nO(n*len) len = size of string returned in the worst case.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) for n recursion calls.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstring fun (string str1 )\\n{\\n    str1 +=\" \"; //to capture the last count \\n    int len = str1.size();\\n    int count =1;\\n    string ans= \"\";\\n\\n    for ( int i =0; i< len-1 ;i++)\\n    {\\n        if(str1[i+1] == str1[i]) count++;\\n        else {\\n            ans+=(\\'0\\'+count);\\n            ans+=str1[i];\\n            count =1;\\n        }\\n    }\\n    return ans ;\\n}\\n\\n    string countAndSay(int n) {\\n        if(n==1)\\n        return \"1\";\\n        string x=fun(countAndSay(n-1));\\n        return x;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstring fun (string str1 )\\n{\\n    str1 +=\" \"; //to capture the last count \\n    int len = str1.size();\\n    int count =1;\\n    string ans= \"\";\\n\\n    for ( int i =0; i< len-1 ;i++)\\n    {\\n        if(str1[i+1] == str1[i]) count++;\\n        else {\\n            ans+=(\\'0\\'+count);\\n            ans+=str1[i];\\n            count =1;\\n        }\\n    }\\n    return ans ;\\n}\\n\\n    string countAndSay(int n) {\\n        if(n==1)\\n        return \"1\";\\n        string x=fun(countAndSay(n-1));\\n        return x;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777236,
                "title": "easy-solution-by-using-loops-that-s-it-with-95-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n==1)\\n        return \"1\";\\n        else if(n==2)\\n        return \"11\";\\n        string ans=\"11\";\\n        for(int i=3;i<=n;i++){\\n            string temp=\"\";\\n            ans+=\\'@\\';\\n            int count=1;\\n            for(int j=1;j<ans.size();j++){\\n                if(ans[j]!=ans[j-1]){\\n                    temp+=to_string(count);\\n                    temp+=ans[j-1];\\n                    count=1;\\n                }\\n                else\\n                count++;\\n            }\\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};\\n/* UPVOTE IF THE SOLUTION WAS HELPFUL FOR YOU */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n==1)\\n        return \"1\";\\n        else if(n==2)\\n        return \"11\";\\n        string ans=\"11\";\\n        for(int i=3;i<=n;i++){\\n            string temp=\"\";\\n            ans+=\\'@\\';\\n            int count=1;\\n            for(int j=1;j<ans.size();j++){\\n                if(ans[j]!=ans[j-1]){\\n                    temp+=to_string(count);\\n                    temp+=ans[j-1];\\n                    count=1;\\n                }\\n                else\\n                count++;\\n            }\\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};\\n/* UPVOTE IF THE SOLUTION WAS HELPFUL FOR YOU */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740215,
                "title": "count-and-say-o-m-n-javascript-memory-95-45-meaningful-vars",
                "content": "```\\nvar countAndSay = function (n) {\\n    let start = \"1\"\\n    while (--n) {\\n        let tempStart = \"\"\\n        let frequency = 1\\n        for (let index = 0; index < start.length; index++) {\\n            if (start[index] !== start[index + 1]) {\\n                tempStart += `${frequency}${start[index]}`\\n                frequency = 1\\n            } else {\\n                frequency += 1\\n            }\\n        }\\n        start = tempStart\\n    }\\n    return start\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countAndSay = function (n) {\\n    let start = \"1\"\\n    while (--n) {\\n        let tempStart = \"\"\\n        let frequency = 1\\n        for (let index = 0; index < start.length; index++) {\\n            if (start[index] !== start[index + 1]) {\\n                tempStart += `${frequency}${start[index]}`\\n                frequency = 1\\n            } else {\\n                frequency += 1\\n            }\\n        }\\n        start = tempStart\\n    }\\n    return start\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3662639,
                "title": "easy-dynamic-programming-tabulation-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursive method can take to much time complexity for big n values .\\nso use DP.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe Approach is very simple first if n==1 push \"1\" and for other value of n take previous value in a string then count the no. of same elements in string with maintaing then count as c and current value as curr then if there is a change push the value into string..\\ndo these even after the loop ends for the last value of c and curr.\\nafter that push that into the dp array..\\nreturn the dp[n-1];\\n.. this can be more simplified using memorization.\\n\\nIf found helpful please upvote\\n\\n# Complexity\\n- Time complexity:\\n- O(n) as array of n size is traversed\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n) as array of n size is created\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    vector<string>dp;\\npublic:\\nvoid func(int x)\\n    {\\n        string s = dp[x-1];\\n        string ans=\"\";\\n        int i, n= s.length();\\n        int curr=0,c=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(i==0) \\n            {\\n                curr=s[i]-\\'0\\';\\n                c++;\\n            }\\n            else{\\n                if(s[i]!=s[i-1])\\n                {   \\n                   string temp=\"\";\\n       temp+=to_string(c);\\n       temp+=to_string(curr);\\n       ans+=temp;\\n                    c=1;\\n                    curr=s[i]-\\'0\\';\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n        }\\n       string temp=\"\";\\n       temp+=to_string(c);\\n       temp+=to_string(curr);\\n       ans+=temp;\\n        dp[x]=ans;\\n    }\\n    string countAndSay(int n) {\\n        dp.resize(n);\\n        dp[0]=\"1\";\\n        for(int i=1;i<n;i++)\\n        {\\n            func(i);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n    vector<string>dp;\\npublic:\\nvoid func(int x)\\n    {\\n        string s = dp[x-1];\\n        string ans=\"\";\\n        int i, n= s.length();\\n        int curr=0,c=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(i==0) \\n            {\\n                curr=s[i]-\\'0\\';\\n                c++;\\n            }\\n            else{\\n                if(s[i]!=s[i-1])\\n                {   \\n                   string temp=\"\";\\n       temp+=to_string(c);\\n       temp+=to_string(curr);\\n       ans+=temp;\\n                    c=1;\\n                    curr=s[i]-\\'0\\';\\n                }\\n                else{\\n                    c++;\\n                }\\n            }\\n        }\\n       string temp=\"\";\\n       temp+=to_string(c);\\n       temp+=to_string(curr);\\n       ans+=temp;\\n        dp[x]=ans;\\n    }\\n    string countAndSay(int n) {\\n        dp.resize(n);\\n        dp[0]=\"1\";\\n        for(int i=1;i<n;i++)\\n        {\\n            func(i);\\n        }\\n        return dp[n-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288774,
                "title": "python-solution-dp-with-sample-output",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        dp = [ \"\" for i in range(0,n+1)]\\n        dp[1] = \"1 \"\\n        i = 2 ;\\n        while( i < n+1 ):\\n            print(f\\'i:{i} dp[{i-1}]:{dp[i-1]}\\')\\n            c = 0 \\n            for j in range(0,len(dp[i-1])-1):\\n                if( dp[i-1][j] == dp[i-1][j+1]):\\n                    c += 1;\\n                else:\\n                    dp[i] += chr(c+1+ord(\\'0\\')) + dp[i-1][j] ;\\n                    c=0;\\n            dp[i] += \\' \\';\\n            i +=1\\n            \\n\\n        return dp[-1][:-1];\\n\\n```\\n\\n```\\ni:2 dp[1]:1 \\ni:3 dp[2]:11 \\ni:4 dp[3]:21 \\ni:5 dp[4]:1211 \\ni:6 dp[5]:111221 \\ni:7 dp[6]:312211 \\ni:8 dp[7]:13112221 \\ni:9 dp[8]:1113213211 \\ni:10 dp[9]:31131211131221 \\ni:11 dp[10]:13211311123113112211 \\ni:12 dp[11]:11131221133112132113212221 \\ni:13 dp[12]:3113112221232112111312211312113211 \\ni:14 dp[13]:1321132132111213122112311311222113111221131221 \\ni:15 dp[14]:11131221131211131231121113112221121321132132211331222113112211\\n```\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        dp = [ \"\" for i in range(0,n+1)]\\n        dp[1] = \"1 \"\\n        i = 2 ;\\n        while( i < n+1 ):\\n            print(f\\'i:{i} dp[{i-1}]:{dp[i-1]}\\')\\n            c = 0 \\n            for j in range(0,len(dp[i-1])-1):\\n                if( dp[i-1][j] == dp[i-1][j+1]):\\n                    c += 1;\\n                else:\\n                    dp[i] += chr(c+1+ord(\\'0\\')) + dp[i-1][j] ;\\n                    c=0;\\n            dp[i] += \\' \\';\\n            i +=1\\n            \\n\\n        return dp[-1][:-1];\\n\\n```\n```\\ni:2 dp[1]:1 \\ni:3 dp[2]:11 \\ni:4 dp[3]:21 \\ni:5 dp[4]:1211 \\ni:6 dp[5]:111221 \\ni:7 dp[6]:312211 \\ni:8 dp[7]:13112221 \\ni:9 dp[8]:1113213211 \\ni:10 dp[9]:31131211131221 \\ni:11 dp[10]:13211311123113112211 \\ni:12 dp[11]:11131221133112132113212221 \\ni:13 dp[12]:3113112221232112111312211312113211 \\ni:14 dp[13]:1321132132111213122112311311222113111221131221 \\ni:15 dp[14]:11131221131211131231121113112221121321132132211331222113112211\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3246378,
                "title": "beats-100-easy-basic-recursion-fastest-c",
                "content": "# Intuition\\n- the basic idea or intution behind this question is\\n- it\\'s just a recursion that has a base case of n=\"1\"\\n- after n=2 call for n-1 that means call for \"1\" , the result should return \"11\" \\n the first character is count of the second character of the string passed in call\\n- for n=3 (call(n-1) means for n==2) string for call =\"11\" it will return \"21\"\\n - it goes a follows until n\\n \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- create a say function , which return a string , it will always return a even length string in which every odd term will return the frequency of its consecutive even term\\n- the say(\"44455\")  should return \"3425\" it means there are 3 four\\'s and 2 five\\'s\\n- \\n```c++ []\\nstring say(string a){\\n        int i=0,j=0,cnt=0;\\n        string ans=\"\";\\n        for(int j=0;j<a.length();j++){\\n            if(a[i]==a[j]) cnt++;\\n            else{\\n                \\n                ans+=char(cnt+\\'0\\');\\n                ans+=a[i];\\n                i=j;\\n                cnt=1;\\n            }\\n        }\\n         ans+=char(cnt+\\'0\\');\\n         ans+=a[i];\\n         return ans;\\n    }\\n```\\n- and after call form 1 to n\\n- return ur ans\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n    string say(string a){\\n        int i=0,j=0,cnt=0;\\n        string ans=\"\";\\n        for(int j=0;j<a.length();j++){\\n            if(a[i]==a[j]) cnt++;\\n            else{\\n                \\n                ans+=char(cnt+\\'0\\');\\n                ans+=a[i];\\n                i=j;\\n                cnt=1;\\n            }\\n        }\\n         ans+=char(cnt+\\'0\\');\\n         ans+=a[i];\\n         return ans;\\n    }\\npublic:\\n    string countAndSay(int n) {\\n        if(n==1) return \"1\";\\n        string temp=\"1\";\\n        int k=1;\\n        while(k<n){\\n            temp = say(temp);\\n            k++;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```c++ []\\nstring say(string a){\\n        int i=0,j=0,cnt=0;\\n        string ans=\"\";\\n        for(int j=0;j<a.length();j++){\\n            if(a[i]==a[j]) cnt++;\\n            else{\\n                \\n                ans+=char(cnt+\\'0\\');\\n                ans+=a[i];\\n                i=j;\\n                cnt=1;\\n            }\\n        }\\n         ans+=char(cnt+\\'0\\');\\n         ans+=a[i];\\n         return ans;\\n    }\\n```\n```\\nclass Solution {\\n    private:\\n    string say(string a){\\n        int i=0,j=0,cnt=0;\\n        string ans=\"\";\\n        for(int j=0;j<a.length();j++){\\n            if(a[i]==a[j]) cnt++;\\n            else{\\n                \\n                ans+=char(cnt+\\'0\\');\\n                ans+=a[i];\\n                i=j;\\n                cnt=1;\\n            }\\n        }\\n         ans+=char(cnt+\\'0\\');\\n         ans+=a[i];\\n         return ans;\\n    }\\npublic:\\n    string countAndSay(int n) {\\n        if(n==1) return \"1\";\\n        string temp=\"1\";\\n        int k=1;\\n        while(k<n){\\n            temp = say(temp);\\n            k++;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2886415,
                "title": "fully-explained-append-the-count-o-n-java",
                "content": "# Problem says :\\n```\\nFind the n\\u2019th term in Look-and-say (Or Count and Say) Sequence.\\nThe look-and-say sequence is the sequence of the below integers: \\n1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, \\u2026 \\n```\\n# Approach :\\n```\\nHow is the above sequence generated? \\n\\nn\\u2019th term is generated by reading (n-1)\\u2019th term.\\n\\nThe first term is \"1\"\\n\\nSecond term is \"11\", generated by reading first term as \"One 1\" \\n(There is one 1 in previous term)\\n\\nThird term is \"21\", generated by reading second term as \"Two 1\"\\n\\nFourth term is \"1211\", generated by reading third term as \"One 2 One 1\" \\n\\nand so on\\n```\\n\\n# How to find n\\u2019th term? \\n```\\nInput: n = 3\\nOutput: 21\\n\\nInput: n = 5\\nOutput: 111221\\n\\nThe idea is simple, we generate all terms from 1 to n. First, \\ntwo terms are initialized as \\u201C1\\u201D and \\u201C11\\u201D, and all other terms\\nare generated using previous terms. To generate a term using the\\nprevious term, we scan the previous term. While scanning a term,\\nwe simply keep track of the count of all consecutive characters. \\nFor a sequence of the same characters, we append the count followed\\nby the character to generate the next term.\\n```\\n```\\nIf you find this solution easy to understand and helpful, then \\nplease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\n\\n# Code (Explained in Comments)\\n```\\nclass Solution \\n{\\n    public String countAndSay(int n) \\n    {\\n        // Base cases\\n        if(n==1)\\n          return \"1\";\\n        if(n==2)\\n          return \"11\";\\n        // Find n\\'th term by generating\\n        // all terms from 3 to n-1.\\n        // Every term is generated\\n        // using previous term\\n     \\n        // Initialize previous term\\n        String str=\"11\";\\n        for(int i=3;i<=n;i++)\\n        {\\n            // In below for loop, previous\\n            // character is processed in\\n            // current iteration. That is\\n            // why a dummy character is\\n            // added to make sure that loop\\n            // runs one extra iteration.\\n            str+=\\'$\\';\\n\\n            int len=str.length();\\n            int cnt=1; // Initialize count\\n                     // of matching chars\\n            String tmp=\"\";// Initialize i\\'th\\n                         // term in series\\n            char[] arr=str.toCharArray();\\n            // Process previous term\\n            // to find the next term\\n            for(int j=1;j<len;j++)\\n            {\\n                // If current character\\n                // doesn\\'t match\\n                if(arr[j]!=arr[j-1])\\n                {\\n                    // Append count of\\n                    // str[j-1] to temp\\n                    tmp += cnt + 0;\\n    \\n                    // Append str[j-1]\\n                    tmp += arr[j - 1];\\n    \\n                    // Reset count\\n                    cnt = 1;\\n                }\\n                // If matches, then increment\\n                // count of matching characters\\n                else\\n                  cnt++;  \\n            }\\n            // Update str\\n            str=tmp;\\n        }\\n       return str; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nFind the n\\u2019th term in Look-and-say (Or Count and Say) Sequence.\\nThe look-and-say sequence is the sequence of the below integers: \\n1, 11, 21, 1211, 111221, 312211, 13112221, 1113213211, \\u2026 \\n```\n```\\nHow is the above sequence generated? \\n\\nn\\u2019th term is generated by reading (n-1)\\u2019th term.\\n\\nThe first term is \"1\"\\n\\nSecond term is \"11\", generated by reading first term as \"One 1\" \\n(There is one 1 in previous term)\\n\\nThird term is \"21\", generated by reading second term as \"Two 1\"\\n\\nFourth term is \"1211\", generated by reading third term as \"One 2 One 1\" \\n\\nand so on\\n```\n```\\nInput: n = 3\\nOutput: 21\\n\\nInput: n = 5\\nOutput: 111221\\n\\nThe idea is simple, we generate all terms from 1 to n. First, \\ntwo terms are initialized as \\u201C1\\u201D and \\u201C11\\u201D, and all other terms\\nare generated using previous terms. To generate a term using the\\nprevious term, we scan the previous term. While scanning a term,\\nwe simply keep track of the count of all consecutive characters. \\nFor a sequence of the same characters, we append the count followed\\nby the character to generate the next term.\\n```\n```\\nIf you find this solution easy to understand and helpful, then \\nplease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\n```\\nclass Solution \\n{\\n    public String countAndSay(int n) \\n    {\\n        // Base cases\\n        if(n==1)\\n          return \"1\";\\n        if(n==2)\\n          return \"11\";\\n        // Find n\\'th term by generating\\n        // all terms from 3 to n-1.\\n        // Every term is generated\\n        // using previous term\\n     \\n        // Initialize previous term\\n        String str=\"11\";\\n        for(int i=3;i<=n;i++)\\n        {\\n            // In below for loop, previous\\n            // character is processed in\\n            // current iteration. That is\\n            // why a dummy character is\\n            // added to make sure that loop\\n            // runs one extra iteration.\\n            str+=\\'$\\';\\n\\n            int len=str.length();\\n            int cnt=1; // Initialize count\\n                     // of matching chars\\n            String tmp=\"\";// Initialize i\\'th\\n                         // term in series\\n            char[] arr=str.toCharArray();\\n            // Process previous term\\n            // to find the next term\\n            for(int j=1;j<len;j++)\\n            {\\n                // If current character\\n                // doesn\\'t match\\n                if(arr[j]!=arr[j-1])\\n                {\\n                    // Append count of\\n                    // str[j-1] to temp\\n                    tmp += cnt + 0;\\n    \\n                    // Append str[j-1]\\n                    tmp += arr[j - 1];\\n    \\n                    // Reset count\\n                    cnt = 1;\\n                }\\n                // If matches, then increment\\n                // count of matching characters\\n                else\\n                  cnt++;  \\n            }\\n            // Update str\\n            str=tmp;\\n        }\\n       return str; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780507,
                "title": "c-beats-95-in-runtime-with-comments-beginner-s-solution",
                "content": "class Solution {\\npublic:\\n    \\n    string transform(string s)\\n    {\\n        char curr = s[0];\\n        int curr_freq = 1;\\n        string ans = \"\";\\n        \\n        for (int i = 1; i < s.length(); i++)\\n        {\\n            /* If current character is same as \\n                the last we increase the frequency by 1 */\\n            if (s[i] == curr)   \\n            {    \\n                curr_freq++;\\n            }\\n            else\\n            {\\n                /* If new character is encountered then we add the last \\n                character\\'s frequency followed by the last character\\n                itself to the answer string*/\\n                \\n                ans += (char)(curr_freq + \\'0\\'); // adding Frequency to ans\\n                ans += (char)(curr);    //adding the character to the answer\\n                curr = s[i];\\n                curr_freq = 1;\\n            }\\n        }\\n        \\n        /* when we exit the loop the last character is \\n        yet to be added to the string since the \"else\"\\n        block won\\'t be executed for the last character*/\\n        \\n        ans += (char)(curr_freq + \\'0\\');\\n        ans += (char)(curr);\\n        \\n        return ans;\\n    }\\n    \\n    string countAndSay(int n) {\\n        if (n == 1)\\n            return \"1\";\\n        \\n        /*Recursively Calling for N-1 till we reach N = 1\\n        And in each recursive call we call the function \\n        \"transform\" which transforms the string into \\n        a count and say form. Then we return the transformed \\n        string as our answer for that value of N*/\\n        \\n        string x = transform(countAndSay(n-1));\\n        \\n        return x;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    string transform(string s)\\n    {\\n        char curr = s[0];\\n        int curr_freq = 1;\\n        string ans = \"\";\\n        \\n        for (int i = 1; i < s.length(); i++)\\n        {\\n            /* If current character is same as \\n                the last we increase the frequency by 1 */\\n            if (s[i] == curr)   \\n            {    \\n                curr_freq++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2718181,
                "title": "c-easy-to-understand-solution-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n == 1)\\n        {\\n            return \"1\";\\n        }\\n\\n        string s = countAndSay(n-1);\\n        string ans = \"\";\\n        int count = 1;\\n        char prev = s[0], c;\\n\\n        for(int i = 1; i < s.size(); i++)\\n        {\\n            if(prev == s[i])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                ans.push_back(\\'0\\'+count);\\n                ans.push_back(prev);\\n                prev = s[i];\\n                count = 1;\\n            }\\n        }\\n        ans.push_back(\\'0\\'+count);\\n        ans.push_back(prev);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n == 1)\\n        {\\n            return \"1\";\\n        }\\n\\n        string s = countAndSay(n-1);\\n        string ans = \"\";\\n        int count = 1;\\n        char prev = s[0], c;\\n\\n        for(int i = 1; i < s.size(); i++)\\n        {\\n            if(prev == s[i])\\n            {\\n                count++;\\n            }\\n            else\\n            {\\n                ans.push_back(\\'0\\'+count);\\n                ans.push_back(prev);\\n                prev = s[i];\\n                count = 1;\\n            }\\n        }\\n        ans.push_back(\\'0\\'+count);\\n        ans.push_back(prev);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718061,
                "title": "easy-java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public static String countAndSay(int n) {\\n        if(n==1) return \"1\";\\n        String ans=helper(countAndSay(n-1));\\n        return ans;\\n    }\\n\\t\\n\\tprivate static String helper(String str) {\\n\\t\\tString ans=\"\";\\n\\t\\tfor(int i=str.length()-1;i>=0;i--) {\\n\\t\\t\\tint count=1;\\n\\t\\t\\twhile(i>0) {\\n\\t\\t\\t\\tif(str.charAt(i)==str.charAt(i-1)) {\\n\\t\\t\\t\\t\\ti--;\\n                    count++;\\n\\t\\t\\t\\t}else break;\\n\\t\\t\\t}\\n            \\n\\t\\t\\tans=Integer.toString(count)+str.charAt(i)+ans;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n}\\n```\\n\\nmore optimize way is welcomed",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static String countAndSay(int n) {\\n        if(n==1) return \"1\";\\n        String ans=helper(countAndSay(n-1));\\n        return ans;\\n    }\\n\\t\\n\\tprivate static String helper(String str) {\\n\\t\\tString ans=\"\";\\n\\t\\tfor(int i=str.length()-1;i>=0;i--) {\\n\\t\\t\\tint count=1;\\n\\t\\t\\twhile(i>0) {\\n\\t\\t\\t\\tif(str.charAt(i)==str.charAt(i-1)) {\\n\\t\\t\\t\\t\\ti--;\\n                    count++;\\n\\t\\t\\t\\t}else break;\\n\\t\\t\\t}\\n            \\n\\t\\t\\tans=Integer.toString(count)+str.charAt(i)+ans;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717786,
                "title": "java-simple-recursive-solution-with-explanation-and-comments",
                "content": "**Intution**\\n\\n* We know that when n = 1 then answer is \"1\", which is the base case.\\n* Now if we have to make the **count and say string** we have to start preparing the string form n = 1 to any given n.\\n* example if n = 5 : Recursion explaination\\n\\t* we have to calculate 5 using the prev number 4 -> \"111221\" for n = 5.\\n\\t* 4 will created from 3 -> \"1211\" for n = 4.\\n\\t* 3 from 2 -> \"21\" for n = 3.\\n\\t* 2 from 1 -> \"11\" for n = 2.\\n\\t* At last for 1 -> \"1\" for n = 1.\\n\\n**Time complexity will be O(N)** , where n = the input number.\\n\\n```\\npublic String countAndSay(int n) {\\n        // Recursive function to give us output.\\n        return solve(n);\\n        \\n    }\\n    \\n    public String solve(int n){\\n        \\n\\t\\t// Base case when our n == 1 we have to return \"1\".\\n        if(n == 1){\\n            return \"1\";\\n        }\\n        \\n\\t\\t// We will make recursion call to \"n - 1\" and get the output of previous number.\\t\\t\\n        String prev = solve(n - 1);\\n        \\n\\t\\t// Count will be 1 at the starting because we are going to iterate the string from 1st index.\\n        int count = 1;\\n        \\n\\t\\t// To store the current count and say string.\\n\\t\\t// The answer will be created in the postorder because we need the previous result.\\n\\t\\t// postorder means after all the previous recursion calls is completed till here.\\n        StringBuilder ans = new StringBuilder();\\n        \\n\\t\\t// index\\n        int i = 1;        \\n        \\n\\t\\t\\n        while(i < prev.length()){\\n\\t\\t\\n\\t\\t// We have to compare previous and current characters of the string \"prev\" \\n\\t\\t\\n            char prevChar = prev.charAt(i - 1);\\n            char currChar = prev.charAt(i);\\n            \\n\\t\\t// When prevChar != currChar we have add it our answer first add the \"count\" and then add the \"prevChar\".\\n            if(prevChar != currChar){\\n                ans.append(count);\\n                ans.append(prevChar);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Reset the count.\\n                count = 1;\\n            } else {\\n\\t\\t\\t\\t// Increement count if prevChar and currChar is equal.\\n                count++;\\n            }\\n            \\n\\t\\t\\t// Increement the index.\\n            i++;\\n        }\\n\\t\\t\\n\\t\\t// At the last when our iteration is over add the count and lastChar of the string \"prev\" to the answer.\\n\\t\\t// because our while loop will run till last index and it can\\'t able to compare the lastChar with the next char\\n\\t\\t// Therefore the lastChar is not included in the answer.\\n        ans.append(count);\\n        ans.append(prev.charAt(prev.length() - 1));\\n        \\n\\t\\t// return the answer.\\n        return ans.toString();\\n    }\\n```\\n\\nPlease UpVote !!!",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic String countAndSay(int n) {\\n        // Recursive function to give us output.\\n        return solve(n);\\n        \\n    }\\n    \\n    public String solve(int n){\\n        \\n\\t\\t// Base case when our n == 1 we have to return \"1\".\\n        if(n == 1){\\n            return \"1\";\\n        }\\n        \\n\\t\\t// We will make recursion call to \"n - 1\" and get the output of previous number.\\t\\t\\n        String prev = solve(n - 1);\\n        \\n\\t\\t// Count will be 1 at the starting because we are going to iterate the string from 1st index.\\n        int count = 1;\\n        \\n\\t\\t// To store the current count and say string.\\n\\t\\t// The answer will be created in the postorder because we need the previous result.\\n\\t\\t// postorder means after all the previous recursion calls is completed till here.\\n        StringBuilder ans = new StringBuilder();\\n        \\n\\t\\t// index\\n        int i = 1;        \\n        \\n\\t\\t\\n        while(i < prev.length()){\\n\\t\\t\\n\\t\\t// We have to compare previous and current characters of the string \"prev\" \\n\\t\\t\\n            char prevChar = prev.charAt(i - 1);\\n            char currChar = prev.charAt(i);\\n            \\n\\t\\t// When prevChar != currChar we have add it our answer first add the \"count\" and then add the \"prevChar\".\\n            if(prevChar != currChar){\\n                ans.append(count);\\n                ans.append(prevChar);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Reset the count.\\n                count = 1;\\n            } else {\\n\\t\\t\\t\\t// Increement count if prevChar and currChar is equal.\\n                count++;\\n            }\\n            \\n\\t\\t\\t// Increement the index.\\n            i++;\\n        }\\n\\t\\t\\n\\t\\t// At the last when our iteration is over add the count and lastChar of the string \"prev\" to the answer.\\n\\t\\t// because our while loop will run till last index and it can\\'t able to compare the lastChar with the next char\\n\\t\\t// Therefore the lastChar is not included in the answer.\\n        ans.append(count);\\n        ans.append(prev.charAt(prev.length() - 1));\\n        \\n\\t\\t// return the answer.\\n        return ans.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716914,
                "title": "easy-java-solution-with-explanation-faster-than-93-92",
                "content": "![image](https://assets.leetcode.com/users/images/1d60139f-4d75-419b-b33c-3cbe546362b7_1666070354.8036132.png)\\n\\n# Explanation: \\nThe question is very simple when you understand it.\\n\\nEvery number **n** will start from **1** . \\nThe base case is: encoding of **1** is **1**.\\n\\nThen we go to the next number that is **2**. If we wanna know this result, we need to count the previous result, which is \"**1**\". That\\'s why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\\nNow we keep going, the last result is **foo(2) = \"11\"**, so there are 2 \"1\" in the result, so this time the result is **\"21\"**.\\nNext for number **3**, we know last result was \"21\", which means there are one \"2\"s and one \"1\"s, the result will be **foo(3) = \"1211\"**\\n....\\nNow, for your understanding try and solve this: if the **(n-1) th** result is **\"122211233333127755\"**, what is the **n th** result? Let\\'s count it. one \"1\"s, three \"2\"s, two \"1\"s, one \"2\" , five \"3\"s , one \"1\"s , one \"2\"s, two \"7\"s, and two \"5\"s. Therefore, the result is **\"113221125311122725\"**\\nSo, if we wanna know the **n th result, we just need to count the (n - 1)th result, and the first result is \"1\"**. The calculation for each letter will follow the pattern **(count)(letter)**.\\n\\n# Solution:\\n\\n1. Recursive approach:\\n\\n```\\nclass Solution {\\n    Map<Integer, String> say = new HashMap<>();\\n    public String countAndSay(int n) {\\n        say.put(1, \"1\");\\n        say.put(2, \"11\");\\n        String res = helper(n);\\n        return res;\\n    }\\n    private String helper(int n){\\n        if(say.containsKey(n))\\n            return say.get(n);\\n        StringBuilder prevPattern = new StringBuilder(helper(n-1));\\n        StringBuilder currentPattern = new StringBuilder();\\n        int count=1;\\n        for(int i=1; i<prevPattern.length(); i++){\\n            if(prevPattern.charAt(i-1)!=prevPattern.charAt(i)){\\n                currentPattern.append(count).append(prevPattern.charAt(i-1));\\n\\t\\t\\t\\t// reset the count to 1 for new characters\\n                count=1;\\n            }\\n            else{\\n\\t\\t\\t\\t// update the count\\n                count++;\\n            }\\n        }\\n        // we didn\\'t check the last character..so, need to check\\n        currentPattern.append(count).append(prevPattern.charAt(prevPattern.length()-1));\\n        say.put(n, currentPattern.toString());\\n        return say.get(n);\\n    }\\n}\\n```\\n\\n<hr>\\n\\n2. Iterative Solution:\\n\\n\\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n        if(n==3){\\n            return \"21\";\\n        }\\n        String s = countAndSay(n-1);\\n        int start = 0; // starting index\\n        int count = 1;\\n        StringBuilder builder = new StringBuilder();\\n        while(start < s.length()){\\n            char prev = s.charAt(start);\\n            int index = start+1;\\n            while(index<s.length() && prev == s.charAt(index)){\\n                count++;\\n                index++;\\n            }\\n            builder.append(count);//add counter to back of string\\n            builder.append(prev); // add prev char after counter\\n            start = index; // update start to last index that had differnt char\\n            count = 1; // update count var back to 1\\n        }\\n        return builder.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, String> say = new HashMap<>();\\n    public String countAndSay(int n) {\\n        say.put(1, \"1\");\\n        say.put(2, \"11\");\\n        String res = helper(n);\\n        return res;\\n    }\\n    private String helper(int n){\\n        if(say.containsKey(n))\\n            return say.get(n);\\n        StringBuilder prevPattern = new StringBuilder(helper(n-1));\\n        StringBuilder currentPattern = new StringBuilder();\\n        int count=1;\\n        for(int i=1; i<prevPattern.length(); i++){\\n            if(prevPattern.charAt(i-1)!=prevPattern.charAt(i)){\\n                currentPattern.append(count).append(prevPattern.charAt(i-1));\\n\\t\\t\\t\\t// reset the count to 1 for new characters\\n                count=1;\\n            }\\n            else{\\n\\t\\t\\t\\t// update the count\\n                count++;\\n            }\\n        }\\n        // we didn\\'t check the last character..so, need to check\\n        currentPattern.append(count).append(prevPattern.charAt(prevPattern.length()-1));\\n        say.put(n, currentPattern.toString());\\n        return say.get(n);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n        if(n==3){\\n            return \"21\";\\n        }\\n        String s = countAndSay(n-1);\\n        int start = 0; // starting index\\n        int count = 1;\\n        StringBuilder builder = new StringBuilder();\\n        while(start < s.length()){\\n            char prev = s.charAt(start);\\n            int index = start+1;\\n            while(index<s.length() && prev == s.charAt(index)){\\n                count++;\\n                index++;\\n            }\\n            builder.append(count);//add counter to back of string\\n            builder.append(prev); // add prev char after counter\\n            start = index; // update start to last index that had differnt char\\n            count = 1; // update count var back to 1\\n        }\\n        return builder.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716807,
                "title": "c-short-simple-solution-for-beginners-comments-added",
                "content": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) \\n    {\\n        if(n==1) return \"1\";\\n        if(n==2) return \"11\";\\n        \\n        string res = \"11\";\\n        \\n        for(int i=3;i<=n;i++)                     // outer loop for reaching to the Nth integer\\n        {\\n            string curr = \"\";                     // for storing the count and say of the current integer\\n            res += \"*\";                           // add * because we check for j-1 so when we reach to the last , we need to add last value count and say as well\\n            int cnt = 1;                          // curr value count\\n            \\n            for(int j=1;j<res.length();j++)       // loop over the prev value count and say\\n            {\\n                if(res[j]==res[j-1])\\n                {\\n                    cnt++;\\n                }\\n                else\\n                {\\n                    curr += to_string(cnt);        // if not matching then addup the count\\n                    curr += res[j-1];              // that int\\n                    cnt = 1;                       // reset cnt as 1 for next value\\n                }\\n            }\\n            res = curr;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) \\n    {\\n        if(n==1) return \"1\";\\n        if(n==2) return \"11\";\\n        \\n        string res = \"11\";\\n        \\n        for(int i=3;i<=n;i++)                     // outer loop for reaching to the Nth integer\\n        {\\n            string curr = \"\";                     // for storing the count and say of the current integer\\n            res += \"*\";                           // add * because we check for j-1 so when we reach to the last , we need to add last value count and say as well\\n            int cnt = 1;                          // curr value count\\n            \\n            for(int j=1;j<res.length();j++)       // loop over the prev value count and say\\n            {\\n                if(res[j]==res[j-1])\\n                {\\n                    cnt++;\\n                }\\n                else\\n                {\\n                    curr += to_string(cnt);        // if not matching then addup the count\\n                    curr += res[j-1];              // that int\\n                    cnt = 1;                       // reset cnt as 1 for next value\\n                }\\n            }\\n            res = curr;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716773,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n == 1:\\n            return \"1\"\\n        \\n        def mapToCntArr(n):\\n            if n == 1:\\n                return [[1,1]]\\n            tmp = str(n)\\n            cnt = 1\\n            res = []\\n            for i in range(1,len(tmp)):\\n                if tmp[i] == tmp[i-1]:\\n                    cnt += 1\\n                else:\\n                    res.append([tmp[i-1],cnt])\\n                    cnt = 1\\n            res.append([tmp[-1],cnt])\\n            return res\\n        \\n        def pairsToInteger(arr):\\n            tmp = \"\"\\n            for dig , freq in arr:\\n                tmp += str(freq) + str(dig)\\n            return tmp\\n        \\n        ans = \"1\"\\n        # print(mapToCntArr(12345))\\n        for i in range(n-1):\\n            arrOfPairs = mapToCntArr(ans)\\n            ans = pairsToInteger(arrOfPairs)\\n            # print(arrOfPairs,ans)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n == 1:\\n            return \"1\"\\n        \\n        def mapToCntArr(n):\\n            if n == 1:\\n                return [[1,1]]\\n            tmp = str(n)\\n            cnt = 1\\n            res = []\\n            for i in range(1,len(tmp)):\\n                if tmp[i] == tmp[i-1]:\\n                    cnt += 1\\n                else:\\n                    res.append([tmp[i-1],cnt])\\n                    cnt = 1\\n            res.append([tmp[-1],cnt])\\n            return res\\n        \\n        def pairsToInteger(arr):\\n            tmp = \"\"\\n            for dig , freq in arr:\\n                tmp += str(freq) + str(dig)\\n            return tmp\\n        \\n        ans = \"1\"\\n        # print(mapToCntArr(12345))\\n        for i in range(n-1):\\n            arrOfPairs = mapToCntArr(ans)\\n            ans = pairsToInteger(arrOfPairs)\\n            # print(arrOfPairs,ans)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716682,
                "title": "python-classic-count-and-say-problem-99-faster-fastest-solution",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n==1: return \\'1\\'\\n        \\n        res = [\\'1\\']\\n        for i in range(n-1):\\n            i = 0\\n            s = res[-1]\\n            curr_s = \\'\\'\\n            j = 0\\n            while i<len(s):\\n                c = 0\\n                while j<len(s) and s[i] == s[j]:\\n                    c+=1\\n                    j+=1\\n                curr_s += str(c)\\n                curr_s += str(s[i])\\n                i = j\\n                \\n            res.append(curr_s)\\n        \\n        return res[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        if n==1: return \\'1\\'\\n        \\n        res = [\\'1\\']\\n        for i in range(n-1):\\n            i = 0\\n            s = res[-1]\\n            curr_s = \\'\\'\\n            j = 0\\n            while i<len(s):\\n                c = 0\\n                while j<len(s) and s[i] == s[j]:\\n                    c+=1\\n                    j+=1\\n                curr_s += str(c)\\n                curr_s += str(s[i])\\n                i = j\\n                \\n            res.append(curr_s)\\n        \\n        return res[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716342,
                "title": "js-2-approaches-with-explanation-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/count-and-say.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar countAndSay = function(n) {\\n    let s = \\'1\\';\\n    \\n  while (n > 1) {\\n    let count = 0;\\n    let next = \\'\\';\\n\\n    for (let i = 0; i <= s.length; i++) {\\n      if (i === s.length || (i > 0 && s[i] !== s[i - 1])) {\\n        next += count + s[i - 1]; // Say\\n        count = 0;\\n      }\\n\\n      count++; // Count\\n    }\\n\\n    s = next;\\n    n--;\\n  }\\n\\n  return s;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar countAndSay = function(n) {\\n    let s = \\'1\\';\\n    \\n  while (n > 1) {\\n    let count = 0;\\n    let next = \\'\\';\\n\\n    for (let i = 0; i <= s.length; i++) {\\n      if (i === s.length || (i > 0 && s[i] !== s[i - 1])) {\\n        next += count + s[i - 1]; // Say\\n        count = 0;\\n      }\\n\\n      count++; // Count\\n    }\\n\\n    s = next;\\n    n--;\\n  }\\n\\n  return s;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2716224,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\n//Upvote If You Like The Solution\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> fun(string &digit)\\n    {\\n        vector<pair<int,int>> ans;\\n        if(digit.size()==1) \\n        {\\n            ans.push_back({1,1});\\n            return ans;\\n        }\\n        char prev=digit[0];\\n        int cnt=0;\\n        int i=0;\\n        while(i<digit.size())\\n        {\\n            if(digit[i]==prev)\\n                cnt++;\\n            else\\n            {\\n                ans.push_back({cnt,prev-\\'0\\'});\\n                cnt=0;\\n                prev=digit[i];\\n                i--;\\n            }\\n            i++;\\n        }\\n        ans.push_back({cnt,prev-\\'0\\'});\\n        return ans;\\n    }\\n    string count_And_Say(vector<pair<int,int>> &digit)\\n    {\\n        string ans=\"\";\\n        for(auto &it:digit)\\n        {\\n            int temp=it.first*10+it.second;\\n            string s1=to_string(temp);\\n            ans+=s1;\\n        }\\n        return ans;\\n    }\\n    string countAndSay(int n) {\\n        string digit=\"1\";\\n        for(int i=2;i<=n;i++)\\n        {\\n            vector<pair<int,int>> ans=fun(digit);\\n            digit=\"\";\\n            digit=count_And_Say(ans);\\n        }\\n        return digit;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n//Upvote If You Like The Solution\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> fun(string &digit)\\n    {\\n        vector<pair<int,int>> ans;\\n        if(digit.size()==1) \\n        {\\n            ans.push_back({1,1});\\n            return ans;\\n        }\\n        char prev=digit[0];\\n        int cnt=0;\\n        int i=0;\\n        while(i<digit.size())\\n        {\\n            if(digit[i]==prev)\\n                cnt++;\\n            else\\n            {\\n                ans.push_back({cnt,prev-\\'0\\'});\\n                cnt=0;\\n                prev=digit[i];\\n                i--;\\n            }\\n            i++;\\n        }\\n        ans.push_back({cnt,prev-\\'0\\'});\\n        return ans;\\n    }\\n    string count_And_Say(vector<pair<int,int>> &digit)\\n    {\\n        string ans=\"\";\\n        for(auto &it:digit)\\n        {\\n            int temp=it.first*10+it.second;\\n            string s1=to_string(temp);\\n            ans+=s1;\\n        }\\n        return ans;\\n    }\\n    string countAndSay(int n) {\\n        string digit=\"1\";\\n        for(int i=2;i<=n;i++)\\n        {\\n            vector<pair<int,int>> ans=fun(digit);\\n            digit=\"\";\\n            digit=count_And_Say(ans);\\n        }\\n        return digit;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261946,
                "title": "c-easy-simple-solution-count-and-say",
                "content": "class Solution {\\npublic:\\n    string countAndSay(int n) {\\n       string s=\"1\",ns;\\n        for(int i=2;i<=n;++i){\\n            for(int j=0;j<s.size();++j){\\n                int freq=1;\\n                while(j+1<s.size() && s[j+1]==s[j]){\\n                    ++freq;\\n                    ++j;\\n                }\\n                ns+=to_string(freq)+s[j];\\n            }\\n            s=ns;\\n            ns.clear();\\n        }\\n        return s;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    string countAndSay(int n) {\\n       string s=\"1\",ns;\\n        for(int i=2;i<=n;++i){\\n            for(int j=0;j<s.size();++j){\\n                int freq=1;\\n                while(j+1<s.size() && s[j+1]==s[j]){\\n                    ++freq;\\n                    ++j;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2160802,
                "title": "easy-explanation-in-c-with-given-algorithm",
                "content": "I guess you too thought the same after reading the question : \"what the f-ck wrong with this question\" but belive there is nothing much to do after understanding it once  \\n1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n\\nits a recursive function to find a string with a similar type of pattern for n times \\n\\nlets understand with an example n=6\\nwe start from n=1\\nquestion says we have the string \"1\" \\nnow, for second iteration n=2 and s=\"1\" get from previous iteration\\nwe have the string s=\"1\" , in which we can count how many times the first character i.e. the frequency of the character (that is one) is present store both frequency and character in the temporary string res (\"11\") where first character is frequency and second is the character itself so the iteration shifts to next \\n\\nnow , n=3  we have s=\"11\"\\nso repeat the process extract first character count the consecutive frequence and store it in a variable i.e count=2 , update the string res(\"21\") and shifted to the next iteration \\n\\nfor n=4 ,we have s=\"21\"\\ncount the first character which is \\'2\\' we have one time update the string res=\"12\" (here we can say we have 2 one times ) now count the second character \\'1\\' which we have only one time so add it to string res=\"12\" + \"11\"  and go to next iteration \\n\\nn=5, and s=\"1211\"\\ncount first character \\'1\\' we have one times --> update res=res+\"11\"\\nsecond character \\'2\\' we have one times -->update res=res+\"12\"\\nthird character \\'1\\' we have two times --> update res=res+\"21\"\\n\\nso, final answer is s=\"111221\"\\nso i guess you got the drill so calculate yourself for n=6,7 etc...\\n\\n\\nhere\\'s the code :\\n\\n\\tstring countAndSay(int n)\\n\\t{\\n\\t\\t\\tif(n==1)\\n\\t\\t\\t\\treturn \"1\";\\n\\t\\t\\tstring s=countAndSay(n-1);\\n\\t\\t\\tstring res=\"\";\\n\\t\\t\\tchar ch=s[0];int count =1;\\n\\t\\t\\tfor(int i=1;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(ch==s[i])\\n\\t\\t\\t\\t\\tcount ++;\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tres+=to_string(count );\\n\\t\\t\\t\\t\\tres+=ch;\\n\\t\\t\\t\\t\\tch=s[i];\\n\\t\\t\\t\\t\\tcount=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tres+=to_string(count);\\n\\t\\t\\tres+=ch;\\n\\t\\t\\treturn res;\\n        \\n    }\\n\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "I guess you too thought the same after reading the question : \"what the f-ck wrong with this question\" but belive there is nothing much to do after understanding it once  \\n1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n\\nits a recursive function to find a string with a similar type of pattern for n times \\n\\nlets understand with an example n=6\\nwe start from n=1\\nquestion says we have the string \"1\" \\nnow, for second iteration n=2 and s=\"1\" get from previous iteration\\nwe have the string s=\"1\" , in which we can count how many times the first character i.e. the frequency of the character (that is one) is present store both frequency and character in the temporary string res (\"11\") where first character is frequency and second is the character itself so the iteration shifts to next \\n\\nnow , n=3  we have s=\"11\"\\nso repeat the process extract first character count the consecutive frequence and store it in a variable i.e count=2 , update the string res(\"21\") and shifted to the next iteration \\n\\nfor n=4 ,we have s=\"21\"\\ncount the first character which is \\'2\\' we have one time update the string res=\"12\" (here we can say we have 2 one times ) now count the second character \\'1\\' which we have only one time so add it to string res=\"12\" + \"11\"  and go to next iteration \\n\\nn=5, and s=\"1211\"\\ncount first character \\'1\\' we have one times --> update res=res+\"11\"\\nsecond character \\'2\\' we have one times -->update res=res+\"12\"\\nthird character \\'1\\' we have two times --> update res=res+\"21\"\\n\\nso, final answer is s=\"111221\"\\nso i guess you got the drill so calculate yourself for n=6,7 etc...\\n\\n\\nhere\\'s the code :\\n\\n\\tstring countAndSay(int n)\\n\\t{\\n\\t\\t\\tif(n==1)\\n\\t\\t\\t\\treturn \"1\";\\n\\t\\t\\tstring s=countAndSay(n-1);\\n\\t\\t\\tstring res=\"\";\\n\\t\\t\\tchar ch=s[0];int count =1;\\n\\t\\t\\tfor(int i=1;i<s.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(ch==s[i])\\n\\t\\t\\t\\t\\tcount ++;\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tres+=to_string(count );\\n\\t\\t\\t\\t\\tres+=ch;\\n\\t\\t\\t\\t\\tch=s[i];\\n\\t\\t\\t\\t\\tcount=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tres+=to_string(count);\\n\\t\\t\\tres+=ch;\\n\\t\\t\\treturn res;\\n        \\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1851876,
                "title": "simple-python-solution-with-explaination",
                "content": "the main reason for adding \"#\" at end because the last char will not be ever equal to \"#\" while comparing so we start with first string as \"1#\" and we iterate n-1 times since already we taken 1 time \"1\" into consideration and then we initialize the count as 1 and a temp variable and we run the a loop until the length of array -1 because we will compare the current character and its next character if they are same we will just increment the count else we will add the count and the character to temp string and make c as 1 then this pattern repeats if we dont keep \"#\" at end then the last character will not be checked and its a problem though writing out side for loop we can solve but by adding \"#\" this character makes our code look lot simpler!\\noutside the for loop ans will be replaced with temp variable and \"#\" and decrement the n count when n==1 the while will be ended then we return ans string upto last before since the last charcater consists of \"#\".\\n\\n```\\n        ans=\"1#\"\\n        while n-1:\\n            c=1\\n            temp=\"\"\\n            for i in range(len(ans)-1):\\n                if ans[i]==ans[i+1]:\\n                    c+=1\\n                else:\\n                    temp+=str(c)\\n                    temp+=ans[i]\\n                    c=1\\n            ans=temp+\"#\"\\n            n-=1\\n        return ans[:-1]\\n```\\n\\n**PLEASE UPVOTE IF U FIND THIS AS HELPFUL**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\n        ans=\"1#\"\\n        while n-1:\\n            c=1\\n            temp=\"\"\\n            for i in range(len(ans)-1):\\n                if ans[i]==ans[i+1]:\\n                    c+=1\\n                else:\\n                    temp+=str(c)\\n                    temp+=ans[i]\\n                    c=1\\n            ans=temp+\"#\"\\n            n-=1\\n        return ans[:-1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1705398,
                "title": "simplest-program-using-recursion-with-explanation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n == 1)\\n            return \"1\";\\n        else {\\n            string x = countAndSay(n-1);                    // recursion\\n            string res = \"\";                                // result will be appended in this\\n            char temp = x[0];                               // storing first character of the string\\n            int count = 0;\\n            for(int i = 0; i < x.size(); i++) {\\n                if(temp == x[i])                            // checking the number of times the will appear continuously\\n                    count++;\\n                else {\\n                    res += to_string(count) + temp;         // when another number arrives, append the previous number\\n                    temp = x[i];                            // update temp\\n                    count = 1;                              // count the occurence of the new number\\n                }\\n            }\\n            res += to_string(count) + temp;                 // to append the last number\\n            return res;\\n         }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n == 1)\\n            return \"1\";\\n        else {\\n            string x = countAndSay(n-1);                    // recursion\\n            string res = \"\";                                // result will be appended in this\\n            char temp = x[0];                               // storing first character of the string\\n            int count = 0;\\n            for(int i = 0; i < x.size(); i++) {\\n                if(temp == x[i])                            // checking the number of times the will appear continuously\\n                    count++;\\n                else {\\n                    res += to_string(count) + temp;         // when another number arrives, append the previous number\\n                    temp = x[i];                            // update temp\\n                    count = 1;                              // count the occurence of the new number\\n                }\\n            }\\n            res += to_string(count) + temp;                 // to append the last number\\n            return res;\\n         }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1503718,
                "title": "python-iterative-solution-95-75-run-time-99-88-space",
                "content": "I have been seeing a lot of solutions here, but they were mostly recursive. Personally, I believe an iterative way would be easier to read, and take up less space in the stack\\n\\nWithout further ado, here\\'s my solution:\\n```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        curr_string = \"1\"\\n        for iteration in range(2, n+1):\\n            prev_char = curr_string[0]\\n            count = 0\\n            \\n            new_string = \"\"\\n            \\n            for curr_char in curr_string:\\n                if curr_char == prev_char:\\n                    count += 1\\n                else:\\n                    new_string += str(count)\\n                    new_string += prev_char\\n                    prev_char = curr_char\\n                    count = 1\\n                    prev_char = curr_char\\n\\t\\t\\t\\t\\t\\n            new_string += str(count)\\n            new_string += prev_char\\n            curr_string = new_string\\n\\n        return curr_string\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        curr_string = \"1\"\\n        for iteration in range(2, n+1):\\n            prev_char = curr_string[0]\\n            count = 0\\n            \\n            new_string = \"\"\\n            \\n            for curr_char in curr_string:\\n                if curr_char == prev_char:\\n                    count += 1\\n                else:\\n                    new_string += str(count)\\n                    new_string += prev_char\\n                    prev_char = curr_char\\n                    count = 1\\n                    prev_char = curr_char\\n\\t\\t\\t\\t\\t\\n            new_string += str(count)\\n            new_string += prev_char\\n            curr_string = new_string\\n\\n        return curr_string\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374730,
                "title": "simple-c-recursive-approach",
                "content": "```\\nclass Solution {\\npublic:   \\n    string countAndSay(int p) {\\n        \\n        if(p == 1)  return \"1\";\\n        \\n        string curr = \"\";\\n        string prev = countAndSay(p-1);\\n        int c = 0;\\n        \\n        for(int i = 0; i < prev.size(); i++){\\n            c += 1;\\n            if(i == prev.size()-1 || prev[i] != prev[i+1]){\\n                curr += to_string(c);\\n                curr += prev[i];\\n                c = 0;\\n            }\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:   \\n    string countAndSay(int p) {\\n        \\n        if(p == 1)  return \"1\";\\n        \\n        string curr = \"\";\\n        string prev = countAndSay(p-1);\\n        int c = 0;\\n        \\n        for(int i = 0; i < prev.size(); i++){\\n            c += 1;\\n            if(i == prev.size()-1 || prev[i] != prev[i+1]){\\n                curr += to_string(c);\\n                curr += prev[i];\\n                c = 0;\\n            }\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292720,
                "title": "python-3-easy-recursion-88-faster",
                "content": "```\\nclass Solution:\\n    def rec(self, s, n):\\n        \\n        count = 0\\n        ans = \\'\\'\\n        prev = \\'\\'\\n        i = 0\\n        print(f\\'n={n}\\')\\n        while i < len(s):\\n            \\n            if s[i] == prev:\\n                count +=1\\n            else:\\n                if count != 0:\\n                    ans += (str(count) + prev)\\n                count = 1\\n                prev = s[i]\\n            i+=1\\n        ans += (str(count)+prev)\\n        \\n        if n == 1:\\n            return ans\\n        else:\\n            return self.rec(ans, n-1)\\n    \\n    def countAndSay(self, n: int) -> str:\\n        if n == 1:\\n            return \\'1\\'\\n        return self.rec(\\'1\\', n-1)\\n        \\n        \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def rec(self, s, n):\\n        \\n        count = 0\\n        ans = \\'\\'\\n        prev = \\'\\'\\n        i = 0\\n        print(f\\'n={n}\\')\\n        while i < len(s):\\n            \\n            if s[i] == prev:\\n                count +=1\\n            else:\\n                if count != 0:\\n                    ans += (str(count) + prev)\\n                count = 1\\n                prev = s[i]\\n            i+=1\\n        ans += (str(count)+prev)\\n        \\n        if n == 1:\\n            return ans\\n        else:\\n            return self.rec(ans, n-1)\\n    \\n    def countAndSay(self, n: int) -> str:\\n        if n == 1:\\n            return \\'1\\'\\n        return self.rec(\\'1\\', n-1)\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1274868,
                "title": "0-ms-c-solution-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n==1) {\\n            return \"1\";\\n        }\\n\\t\\t\\n        if(n==2) {\\n            return \"11\";\\n        }\\n        \\n        else {\\n\\t\\t\\n            string str = countAndSay(n-1);\\n            int i = 0;\\n            string res = \"\";\\n\\t\\t\\t\\n            while(i < str.length()) {\\n\\t\\t\\t\\n                int count = 0;\\n                char digit = str.at(i);\\n\\t\\t\\t\\t\\n                while(i< str.length() && str.at(i) == digit) {\\n                    count++;\\n                    i++;\\n                }\\n\\t\\t\\t\\t\\n                res.push_back(count + \\'0\\');\\n                res.push_back(digit);\\n            }\\n\\t\\t\\t\\n            return res;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if(n==1) {\\n            return \"1\";\\n        }\\n\\t\\t\\n        if(n==2) {\\n            return \"11\";\\n        }\\n        \\n        else {\\n\\t\\t\\n            string str = countAndSay(n-1);\\n            int i = 0;\\n            string res = \"\";\\n\\t\\t\\t\\n            while(i < str.length()) {\\n\\t\\t\\t\\n                int count = 0;\\n                char digit = str.at(i);\\n\\t\\t\\t\\t\\n                while(i< str.length() && str.at(i) == digit) {\\n                    count++;\\n                    i++;\\n                }\\n\\t\\t\\t\\t\\n                res.push_back(count + \\'0\\');\\n                res.push_back(digit);\\n            }\\n\\t\\t\\t\\n            return res;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228561,
                "title": "java-99-74-faster-similar-to-string-compression-lc-443",
                "content": "Use Helper funciton to determine count of each character similar to https://leetcode.com/problems/string-compression/\\n\\n```\\n    public String countAndSay(int n) {\\n\\t    String s = \"1\";\\n\\t\\tif (n == 1) \\n\\t\\t\\treturn s;\\n        for (int i = 1; i < n; i++) {\\n            s = helper(s);\\n        }\\n        return s;\\n    }\\n\\n    private String helper(String num) {\\n        StringBuilder n = new StringBuilder();\\n        int i = 0, j = 0;\\n        while (i < num.length()) { // get each character count \\n            while (j < num.length() && num.charAt(j) == num.charAt(i)) {\\n                j++;\\n            }\\n            int freq = j-i; \\n            n.append(freq).append(num.charAt(i)); //store freq followed by character to stringbuilder\\n            i = j;\\n        }\\n        return n.toString();\\n    }\\n```\\t",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n    public String countAndSay(int n) {\\n\\t    String s = \"1\";\\n\\t\\tif (n == 1) \\n\\t\\t\\treturn s;\\n        for (int i = 1; i < n; i++) {\\n            s = helper(s);\\n        }\\n        return s;\\n    }\\n\\n    private String helper(String num) {\\n        StringBuilder n = new StringBuilder();\\n        int i = 0, j = 0;\\n        while (i < num.length()) { // get each character count \\n            while (j < num.length() && num.charAt(j) == num.charAt(i)) {\\n                j++;\\n            }\\n            int freq = j-i; \\n            n.append(freq).append(num.charAt(i)); //store freq followed by character to stringbuilder\\n            i = j;\\n        }\\n        return n.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1184571,
                "title": "c-very-easy-to-understand-with-comment-solution",
                "content": "```\\nstring result = \"1\",current;\\n        \\n\\t\\twhile(--n){\\n        \\n\\t\\tcurrent = \"\";//making an empty string to store final count +value\\n            for(int i=0;i<result.size();i++){\\n                int count = 1;//count start from 1 every time reset \\n                while(i < result.size()-1 && result[i] == result[i+1]){\\n                    count++;\\n                    i++;//if we found same values in the string make cout++ and also check for end of string \\n                }\\n                current +=  to_string(count) + result[i] ; // to_string function is inbuilt used to change integer or any other value to string type and here we merged two string count then how much value\\n\\t\\t\\t\\t}\\n            result = current; //make result =current to check for next sequence\\n        }\\n        return result;//return\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring result = \"1\",current;\\n        \\n\\t\\twhile(--n){\\n        \\n\\t\\tcurrent = \"\";//making an empty string to store final count +value\\n            for(int i=0;i<result.size();i++){\\n                int count = 1;//count start from 1 every time reset \\n                while(i < result.size()-1 && result[i] == result[i+1]){\\n                    count++;\\n                    i++;//if we found same values in the string make cout++ and also check for end of string \\n                }\\n                current +=  to_string(count) + result[i] ; // to_string function is inbuilt used to change integer or any other value to string type and here we merged two string count then how much value\\n\\t\\t\\t\\t}\\n            result = current; //make result =current to check for next sequence\\n        }\\n        return result;//return\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1087853,
                "title": "c-simple-solution-faster-than-100-c-submissions",
                "content": "* The idea is simple. We store the previous state in vector of pairs(count, character). \\n* After that we make a string from this vector and again we need to clear this vector and insert pairs of this string in vector. The process continue till n.\\n```\\nstring countAndSay(int n) {\\n        string ans = \"1\";\\n        vector<pair<char, char>> v;\\n        v.push_back({\\'1\\', \\'1\\'});\\n        for(int i = 2; i <= n; i++){\\n            string res;\\n            for(auto e : v){\\n                res += e.first;\\n                res += e.second;\\n            }\\n            ans = res;\\n            v.clear();\\n            int cnt = 1;\\n            for(int j = 0; j < res.length(); j++){\\n                if(j == res.length()-1){\\n                    char a = \\'0\\' + cnt; // type cast int to char.\\n                    v.push_back({a, res[j]});\\n                    break;\\n                }\\n                if(res[j] != res[j+1]){\\n                    char a = \\'0\\' + cnt;\\n                    v.push_back({a, res[j]});\\n                    cnt = 1;\\n                }else{\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "* The idea is simple. We store the previous state in vector of pairs(count, character). \\n* After that we make a string from this vector and again we need to clear this vector and insert pairs of this string in vector. The process continue till n.\\n```\\nstring countAndSay(int n) {\\n        string ans = \"1\";\\n        vector<pair<char, char>> v;\\n        v.push_back({\\'1\\', \\'1\\'});\\n        for(int i = 2; i <= n; i++){\\n            string res;\\n            for(auto e : v){\\n                res += e.first;\\n                res += e.second;\\n            }\\n            ans = res;\\n            v.clear();\\n            int cnt = 1;\\n            for(int j = 0; j < res.length(); j++){\\n                if(j == res.length()-1){\\n                    char a = \\'0\\' + cnt; // type cast int to char.\\n                    v.push_back({a, res[j]});\\n                    break;\\n                }\\n                if(res[j] != res[j+1]){\\n                    char a = \\'0\\' + cnt;\\n                    v.push_back({a, res[j]});\\n                    cnt = 1;\\n                }else{\\n                    cnt++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 980746,
                "title": "swift-readable-solution",
                "content": "```\\nclass Solution {\\n    func countAndSay(_ n: Int) -> String {\\n        guard n > 1 else { return \"1\" }\\n        return countString(from: countAndSay(n-1))\\n    }\\n    func countString(from inp: String) -> String {\\n        let list = Array(inp)\\n        var result = \"\"\\n        \\n        var elem: Character = list[0]\\n        var count = 1\\n        \\n        for index in 1..<list.count {\\n            let char = list[index]\\n            if char != elem {\\n                result +=  \"\\\\(count)\\\\(elem)\"\\n                elem = char\\n                count = 1\\n            } else {\\n                count += 1\\n            }\\n        }\\n        \\n        result += \"\\\\(count)\\\\(elem)\"\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func countAndSay(_ n: Int) -> String {\\n        guard n > 1 else { return \"1\" }\\n        return countString(from: countAndSay(n-1))\\n    }\\n    func countString(from inp: String) -> String {\\n        let list = Array(inp)\\n        var result = \"\"\\n        \\n        var elem: Character = list[0]\\n        var count = 1\\n        \\n        for index in 1..<list.count {\\n            let char = list[index]\\n            if char != elem {\\n                result +=  \"\\\\(count)\\\\(elem)\"\\n                elem = char\\n                count = 1\\n            } else {\\n                count += 1\\n            }\\n        }\\n        \\n        result += \"\\\\(count)\\\\(elem)\"\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922913,
                "title": "python-crazy-fast-constant-time-space",
                "content": "```\\ndef countAndSay(self, n: int) -> str:\\n        d = [\\'1\\',\\n\\'11\\',\\n\\'21\\',\\n\\'1211\\',\\n\\'111221\\',\\n\\'312211\\',\\n\\'13112221\\',\\n\\'1113213211\\',\\n\\'31131211131221\\',\\n\\'13211311123113112211\\',\\n\\'11131221133112132113212221\\',\\n\\'3113112221232112111312211312113211\\',\\n\\'1321132132111213122112311311222113111221131221\\',\\n\\'11131221131211131231121113112221121321132132211331222113112211\\',\\n\\'311311222113111231131112132112311321322112111312211312111322212311322113212221\\',\\n\\'132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\\',\\n\\'11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\\',\\n\\'31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\\',\\n\\'1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\\',\\n\\'11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\\',\\n\\'311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n\\'132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\',\\n\\'111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\\',\\n\\'3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\\',\\n\\'132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n\\'1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\',\\n\\'31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\\',\\n\\'13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\\',\\n\\'11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n\\'3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\']\\n        return d[n - 1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef countAndSay(self, n: int) -> str:\\n        d = [\\'1\\',\\n\\'11\\',\\n\\'21\\',\\n\\'1211\\',\\n\\'111221\\',\\n\\'312211\\',\\n\\'13112221\\',\\n\\'1113213211\\',\\n\\'31131211131221\\',\\n\\'13211311123113112211\\',\\n\\'11131221133112132113212221\\',\\n\\'3113112221232112111312211312113211\\',\\n\\'1321132132111213122112311311222113111221131221\\',\\n\\'11131221131211131231121113112221121321132132211331222113112211\\',\\n\\'311311222113111231131112132112311321322112111312211312111322212311322113212221\\',\\n\\'132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\\',\\n\\'11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\\',\\n\\'31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\\',\\n\\'1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\\',\\n\\'11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\\',\\n\\'311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n\\'132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\',\\n\\'111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\\',\\n\\'3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\\',\\n\\'132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n\\'1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\',\\n\\'31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\\',\\n\\'13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\\',\\n\\'11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\\',\\n\\'3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\\']\\n        return d[n - 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 847301,
                "title": "java-easy-video-tutorial",
                "content": "https://www.youtube.com/watch?v=INl9Ha294E0",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=INl9Ha294E0",
                "codeTag": "Unknown"
            },
            {
                "id": 825688,
                "title": "c-simple-easy-to-read-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if (n == 1)\\n            return \"1\";\\n        \\n        string prev = countAndSay(n-1);\\n        string cur = \"\";\\n        int count = 1;\\n        \\n        for (int i = 0; i < prev.length()-1; i++) {\\n            if (prev[i] == prev[i+1]) {\\n                count++;\\n            }\\n            else {\\n                cur += to_string(count);\\n                cur += prev[i];\\n                count = 1;\\n            }\\n        }\\n        \\n        cur += to_string(count);\\n        cur += prev.back();\\n        \\n        return cur;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string countAndSay(int n) {\\n        if (n == 1)\\n            return \"1\";\\n        \\n        string prev = countAndSay(n-1);\\n        string cur = \"\";\\n        int count = 1;\\n        \\n        for (int i = 0; i < prev.length()-1; i++) {\\n            if (prev[i] == prev[i+1]) {\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 823441,
                "title": "go-straightforward-simple-recursion",
                "content": "```\\nfunc countAndSay(n int) string {\\n\\tif n == 1 {\\n\\t\\treturn \"1\"\\n\\t}\\n\\tprev := countAndSay(n - 1)\\n\\tvar say string\\n\\tcount := 0\\n\\tfor i := range prev {\\n\\t\\tcount++\\n\\t\\tif i == len(prev)-1 || prev[i] != prev[i+1] {\\n\\t\\t\\tsay += strconv.Itoa(count) + prev[i:i+1]\\n\\t\\t\\tcount = 0\\n\\t\\t}\\n\\t}\\n\\treturn say\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countAndSay(n int) string {\\n\\tif n == 1 {\\n\\t\\treturn \"1\"\\n\\t}\\n\\tprev := countAndSay(n - 1)\\n\\tvar say string\\n\\tcount := 0\\n\\tfor i := range prev {\\n\\t\\tcount++\\n\\t\\tif i == len(prev)-1 || prev[i] != prev[i+1] {\\n\\t\\t\\tsay += strconv.Itoa(count) + prev[i:i+1]\\n\\t\\t\\tcount = 0\\n\\t\\t}\\n\\t}\\n\\treturn say\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 643996,
                "title": "python-solution",
                "content": "Runtime: 32 ms, faster than 80.65% of Python3 online submissions for Count and Say. \\nMemory Usage: 14.1 MB, less than 6.38% of Python3 online submissions for Count and Say.\\n```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        \\n        if n <= 1:\\n            return \\'1\\'\\n        \\n        s = \\'1\\'\\n        \\n        for i in range(n-1):\\n            \\n            previous,count = s[0],0\\n            new = \\'\\'\\n            \\n            for current in s:\\n                if previous != current:\\n                    new += str(count) + previous\\n                    previous,count = current,1\\n                \\n                else:\\n                    count += 1\\n                    \\n            new += str(count) + previous\\n            s = new\\n        return s\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countAndSay(self, n: int) -> str:\\n        \\n        if n <= 1:\\n            return \\'1\\'\\n        \\n        s = \\'1\\'\\n        \\n        for i in range(n-1):\\n            \\n            previous,count = s[0],0\\n            new = \\'\\'\\n            \\n            for current in s:\\n                if previous != current:\\n                    new += str(count) + previous\\n                    previous,count = current,1\\n                \\n                else:\\n                    count += 1\\n                    \\n            new += str(count) + previous\\n            s = new\\n        return s\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 616415,
                "title": "4-ms-c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n        string recurseSol(string s,int i,int n){\\n        if(i==n){\\n            return s;\\n        }\\n        else{\\n            string nextStr;\\n            stack<char> st;\\n            for(int i=0;i<s.length();++i){\\n                if(st.empty()){\\n                    st.push(s[i]);\\n                }\\n                else if(!st.empty() && s[i]==st.top()){\\n                    st.push(s[i]);\\n                }\\n                else{\\n                    nextStr+=to_string(st.size());\\n                    nextStr+=st.top();\\n                    while(!st.empty()){\\n                        st.pop();\\n                    }\\n                    st.push(s[i]);\\n                }\\n            }\\n            if(!st.empty()){\\n                    nextStr+=to_string(st.size());\\n                    nextStr+=st.top();\\n                    while(!st.empty()){\\n                        st.pop();\\n                    }\\n            }\\n            return recurseSol(nextStr,i+1,n);\\n            \\n        }\\n    }\\n    \\n    string countAndSay(int n) {\\n        return recurseSol(\"1\",1,n);\\n    }\\n\\n};```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        string recurseSol(string s,int i,int n){\\n        if(i==n){\\n            return s;\\n        }\\n        else{\\n            string nextStr;\\n            stack<char> st;\\n            for(int i=0;i<s.length();++i){\\n                if(st.empty()){\\n                    st.push(s[i]);\\n                }\\n                else if(!st.empty() && s[i]==st.top()){\\n                    st.push(s[i]);\\n                }\\n                else{\\n                    nextStr+=to_string(st.size());\\n                    nextStr+=st.top();\\n                    while(!st.empty()){\\n                        st.pop();\\n                    }\\n                    st.push(s[i]);\\n                }\\n            }\\n            if(!st.empty()){\\n                    nextStr+=to_string(st.size());\\n                    nextStr+=st.top();\\n                    while(!st.empty()){\\n                        st.pop();\\n                    }\\n            }\\n            return recurseSol(nextStr,i+1,n);\\n            \\n        }\\n    }\\n    \\n    string countAndSay(int n) {\\n        return recurseSol(\"1\",1,n);\\n    }\\n\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 593675,
                "title": "clean-regex",
                "content": "```\\nvar countAndSay = function(n) {\\n    var parse = \\'1\\'\\n\\n    for ( var i = 1; i < n; i++ ) {\\n        parse = parse\\n            .match(/(.)\\\\1+|./g)\\n            .map( x => x.length + x[0] )\\n            .join(\\'\\')\\n    }\\n    \\n    return parse\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countAndSay = function(n) {\\n    var parse = \\'1\\'\\n\\n    for ( var i = 1; i < n; i++ ) {\\n        parse = parse\\n            .match(/(.)\\\\1+|./g)\\n            .map( x => x.length + x[0] )\\n            .join(\\'\\')\\n    }\\n    \\n    return parse\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 510583,
                "title": "python3-recursion-with-brief-explanation-faster-than-74",
                "content": "```\\n# base case:\\nif n == 1:\\n    return \"1\"\\n\\n# recursive case:\\nprev = self.countAndSay(n - 1)\\nresult = \"\"\\ncnt = 1\\nfor i in range(1, len(prev)):\\n    # add into count\\n    if prev[i] == prev[i - 1]:\\n        cnt += 1\\n    # start of new digit\\n    else:\\n        result += (str(cnt) + prev[i - 1])\\n        cnt = 1\\nresult += (str(cnt) + prev[-1])\\nreturn result\\n```\\nDon\\'t forget to upvote my post if you like my solution, thanks a lot :)",
                "solutionTags": [],
                "code": "```\\n# base case:\\nif n == 1:\\n    return \"1\"\\n\\n# recursive case:\\nprev = self.countAndSay(n - 1)\\nresult = \"\"\\ncnt = 1\\nfor i in range(1, len(prev)):\\n    # add into count\\n    if prev[i] == prev[i - 1]:\\n        cnt += 1\\n    # start of new digit\\n    else:\\n        result += (str(cnt) + prev[i - 1])\\n        cnt = 1\\nresult += (str(cnt) + prev[-1])\\nreturn result\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 498299,
                "title": "iterative-javascript-solution-56ms",
                "content": "Don\\'t love this brute force solution but it\\'s fast for a finite input and I didn\\'t see a similiar one posted. \\n\\n```\\nvar countAndSay = function(n) {\\n    if(n === 1) return \"1\";\\n    let string = \"1\";\\n    for(let i = 0; i < n - 1; i++){\\n       string = countChars(string); \\n    }\\n    return string;\\n};\\n\\nfunction countChars(string){\\n    let idx = 0;\\n    let char = \"\";\\n    let count = 0;\\n    let result = \"\";\\n    \\n    while(idx < string.length){\\n        char = string[idx];\\n        while(string[idx] === char){\\n            count++;\\n            idx++;\\n        }\\n        result += count + char;\\n        count = 0;\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar countAndSay = function(n) {\\n    if(n === 1) return \"1\";\\n    let string = \"1\";\\n    for(let i = 0; i < n - 1; i++){\\n       string = countChars(string); \\n    }\\n    return string;\\n};\\n\\nfunction countChars(string){\\n    let idx = 0;\\n    let char = \"\";\\n    let count = 0;\\n    let result = \"\";\\n    \\n    while(idx < string.length){\\n        char = string[idx];\\n        while(string[idx] === char){\\n            count++;\\n            idx++;\\n        }\\n        result += count + char;\\n        count = 0;\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 462161,
                "title": "recursive-java-solution-commented-runtime-beats-99-memory-beats-100",
                "content": "```\\npublic String countAndSay(int n) {\\n\\t// base cases\\n\\tif(n == 1)\\n\\t\\treturn \"1\";\\n\\tif(n == 2)\\n\\t\\treturn \"11\";\\n\\t\\t\\n\\t// recursive call on n-1\\n\\tString str = countAndSay(n-1);\\n\\t\\n\\tStringBuilder sb = new StringBuilder();\\n\\t\\n\\t// holding the count of the precedding character\\n\\tint tempCount = 1;\\n\\tfor(int i = 1; i < str.length(); i++){\\n\\t\\tif(str.charAt(i) == str.charAt(i-1))\\n\\t\\t\\ttempCount+=1;\\n\\t\\t// done with consecutive digits\\n\\t\\telse{\\n\\t\\t\\tsb.append(tempCount);\\n\\t\\t\\tsb.append(str.charAt(i-1));\\n\\t\\t\\ttempCount = 1;  // reset\\n\\t\\t}\\n\\t}\\n\\t// wrapping up the last digit\\n\\tsb.append(tempCount);\\n\\tsb.append(str.charAt(str.length()-1));\\n\\t\\n\\treturn sb.toString();\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic String countAndSay(int n) {\\n\\t// base cases\\n\\tif(n == 1)\\n\\t\\treturn \"1\";\\n\\tif(n == 2)\\n\\t\\treturn \"11\";\\n\\t\\t\\n\\t// recursive call on n-1\\n\\tString str = countAndSay(n-1);\\n\\t\\n\\tStringBuilder sb = new StringBuilder();\\n\\t\\n\\t// holding the count of the precedding character\\n\\tint tempCount = 1;\\n\\tfor(int i = 1; i < str.length(); i++){\\n\\t\\tif(str.charAt(i) == str.charAt(i-1))\\n\\t\\t\\ttempCount+=1;\\n\\t\\t// done with consecutive digits\\n\\t\\telse{\\n\\t\\t\\tsb.append(tempCount);\\n\\t\\t\\tsb.append(str.charAt(i-1));\\n\\t\\t\\ttempCount = 1;  // reset\\n\\t\\t}\\n\\t}\\n\\t// wrapping up the last digit\\n\\tsb.append(tempCount);\\n\\tsb.append(str.charAt(str.length()-1));\\n\\t\\n\\treturn sb.toString();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427652,
                "title": "js-iterative-solution",
                "content": "```\\nvar countAndSay = function(n) {\\n  let res = \\'1\\';\\n  \\n  while (n > 1) {\\n    let temp = \\'\\';\\n    let cur = \\'\\';\\n    \\n    for (let i = 0; i < res.length; i++) {      \\n      cur += res[i];\\n      \\n      if (res[i] !== res[i + 1]) {\\n        temp += `${cur.length}${cur[0]}`;\\n        cur = \\'\\';\\n      }\\n    };\\n    \\n    res = temp;\\n    \\n    n--;\\n  }\\n  \\n  return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar countAndSay = function(n) {\\n  let res = \\'1\\';\\n  \\n  while (n > 1) {\\n    let temp = \\'\\';\\n    let cur = \\'\\';\\n    \\n    for (let i = 0; i < res.length; i++) {      \\n      cur += res[i];\\n      \\n      if (res[i] !== res[i + 1]) {\\n        temp += `${cur.length}${cur[0]}`;\\n        cur = \\'\\';\\n      }\\n    };\\n    \\n    res = temp;\\n    \\n    n--;\\n  }\\n  \\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260092,
                "title": "java-solution-with-recursion-beats-100",
                "content": "```\\nclass Solution {\\n    public static String countAndSay(int n) {\\n        return helper(n, \"1\");\\n    }\\n\\n    public static String helper(int n, String str) {\\n        if (n == 1) {\\n            return str;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        char[] nums = str.toCharArray();\\n        char pre = nums[0];\\n        int count = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == pre) {\\n                count++;\\n            }\\n            else {\\n                sb.append(count);\\n                sb.append(pre);\\n                pre = nums[i];\\n                count = 1;\\n            }\\n        }\\n        // add the occurrence number of the last few numbers to the \"str\"\\n        sb.append(count);\\n        sb.append(pre);\\n        return helper(n-1, sb.toString());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static String countAndSay(int n) {\\n        return helper(n, \"1\");\\n    }\\n\\n    public static String helper(int n, String str) {\\n        if (n == 1) {\\n            return str;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        char[] nums = str.toCharArray();\\n        char pre = nums[0];\\n        int count = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] == pre) {\\n                count++;\\n            }\\n            else {\\n                sb.append(count);\\n                sb.append(pre);\\n                pre = nums[i];\\n                count = 1;\\n            }\\n        }\\n        // add the occurrence number of the last few numbers to the \"str\"\\n        sb.append(count);\\n        sb.append(pre);\\n        return helper(n-1, sb.toString());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 161826,
                "title": "javascript-regexp-oneliner-with-explanation",
                "content": "Just split the string to strings of the same digits so `\\'1223334444\\'` would become `[\\'1\\', \\'22\\', \\'333\\', \\'4444\\']`. You know what to do next :)\\n```\\nconst countAndSay = function(n) {\\n  return n > 1 ? countAndSay(n - 1).match(/(\\\\d)\\\\1*/g).map(D => D.length + D[0]).join(\\'\\') : \\'1\\'\\n}\\n```\\nOr, without recursion\\n```\\nvar countAndSay = function(n) {\\n  let result = \\'1\\'\\n  while(--n)\\n    result = result\\n      .match(/(\\\\d)\\\\1*/g)\\n      .map(sameDigits => sameDigits.length + sameDigits[0])\\n      .join(\\'\\')\\n  return result\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nconst countAndSay = function(n) {\\n  return n > 1 ? countAndSay(n - 1).match(/(\\\\d)\\\\1*/g).map(D => D.length + D[0]).join(\\'\\') : \\'1\\'\\n}\\n```\n```\\nvar countAndSay = function(n) {\\n  let result = \\'1\\'\\n  while(--n)\\n    result = result\\n      .match(/(\\\\d)\\\\1*/g)\\n      .map(sameDigits => sameDigits.length + sameDigits[0])\\n      .join(\\'\\')\\n  return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 16047,
                "title": "swift-solution-29ms-90",
                "content": "```\\nclass Solution {\\n    func countAndSay(_ n: Int) -> String {\\n        \\n        if n == 1 {\\n            return \"1\"\\n        }\\n        \\n        var currentTerm: String = \"1\"\\n        var newTerm = \"\"\\n        var count = 0\\n        var char: Character = currentTerm.characters.first!\\n        \\n        for i in 2...n {\\n            newTerm = \"\"\\n            count = 0\\n            char = currentTerm.characters.first!\\n            \\n            for currentChar in currentTerm.characters {\\n                if currentChar == char {\\n                    count += 1\\n                } else {\\n                    newTerm += \"\\\\(count)\\\\(char)\"\\n                    char = currentChar\\n                    count = 1\\n                }\\n            }\\n            \\n            newTerm += \"\\\\(count)\\\\(char)\"\\n            currentTerm = newTerm\\n        }\\n        \\n        return currentTerm\\n    }\\n}\\n```\\n\\nFairly fast & straightforward.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func countAndSay(_ n: Int) -> String {\\n        \\n        if n == 1 {\\n            return \"1\"\\n        }\\n        \\n        var currentTerm: String = \"1\"\\n        var newTerm = \"\"\\n        var count = 0\\n        var char: Character = currentTerm.characters.first!\\n        \\n        for i in 2...n {\\n            newTerm = \"\"\\n            count = 0\\n            char = currentTerm.characters.first!\\n            \\n            for currentChar in currentTerm.characters {\\n                if currentChar == char {\\n                    count += 1\\n                } else {\\n                    newTerm += \"\\\\(count)\\\\(char)\"\\n                    char = currentChar\\n                    count = 1\\n                }\\n            }\\n            \\n            newTerm += \"\\\\(count)\\\\(char)\"\\n            currentTerm = newTerm\\n        }\\n        \\n        return currentTerm\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570800,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1566016,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1650611,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1567821,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1724185,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1566471,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1650192,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1576549,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1649804,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1568855,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1570800,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1566016,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1650611,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1567821,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1724185,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1566471,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1650192,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1576549,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1649804,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1568855,
                "content": [
                    {
                        "username": "MMehdiMousavi",
                        "content": "I got this problem in a mock assessment, wasted a bunch of time on this and it was incredibly frustrating. questions like this have incredibly unclear premise and frustrating test cases. the explanations are inadequate and frankly no wonder this question has so many dislikes.\\nLeetcode needs to exclude problems with high dislike ratio from assessments. thank you for coming to my ted talk."
                    },
                    {
                        "username": "seanajohnston",
                        "content": "Agreed. The explanation of how to formulate and answer is horrible and the examples don\\'t help in the least."
                    },
                    {
                        "username": "mikekaufman4",
                        "content": "n = 1: return **1** is the base case\\nn = 2: return count of last entry i.e. **1 1**\\nn = 3: return count of last entry i.e. two 1\\'s so **21**\\nn=4: we have one 2 and one 1 so **1211**\\nn=5: , we have one 1 and one 2 and two 1\\'s so -> **111221**\\nn=6: we have three 1\\'s, two 2\\'s and one 1 so ->  **312211**\\nn = 7: we have one 3, one 1, two 2\\'s and two 1\\'s -> **13112221**\\n...\\nn = i: return counts in front of the number for entry of  i-1 case"
                    },
                    {
                        "username": "me0830code",
                        "content": "Thanks bro."
                    },
                    {
                        "username": "tj3n123",
                        "content": "This is easier to understand than whatever they write in the description"
                    },
                    {
                        "username": "ketapi05",
                        "content": "Really!!!! Thank you for such a deep explanation."
                    },
                    {
                        "username": "elenaoat",
                        "content": "I wish they explained that in the problem description :S"
                    },
                    {
                        "username": "JohnCornflakes",
                        "content": "Thank you for the explanation, the problem finally made sense after reading this"
                    },
                    {
                        "username": "gordoniahk",
                        "content": "Thanks for your explanation, Leetcode really need to know revise their example to at least reach n=5! "
                    },
                    {
                        "username": "xu3u04bj6",
                        "content": "I counldn\\'t even understand the question itself until I saw your explaination, thank you so much!"
                    },
                    {
                        "username": "KevinJM17",
                        "content": "Great explanation. Was able to solve it afterwards :)"
                    },
                    {
                        "username": "72engineers",
                        "content": "guys, no worries, the company that asked this question in an interview does not deserve you work for. Go practise some more valuable questions."
                    },
                    {
                        "username": "dong12",
                        "content": "why 1  Expected: \"1\"?  isn't it \"11\"?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Samathingamajig](/Samathingamajig) Bro wanna play some minecraft sometimes?"
                    },
                    {
                        "username": "Samathingamajig",
                        "content": "Just think of `n` as the number of times you need to apply the algorithm minus 1. So if you were to use looping, instead of looping on the interval `[0, n)`, either loop `[1, n)` or `[0, n-1)`"
                    },
                    {
                        "username": "ertugrul024",
                        "content": "#Question Explanation \n\nWhen I first read the question, I don't really understand what is this question meaning. Actually it is very simple.\nEverthing start 1, 1 is 1, nothing else.\nThen we go to the next one. If we wanna know this result, we need to count the previous result, which is \"1\". That's why the title of the question is \"Count and Say\". The last result is \"1\", just one \"1\", so this result is \"11\"\nNow we keep going, the last result is \"11\", so there are 2 \"1\" in the result, so this time the result is \"21\".\nFor this time, we know last result is \"21\", which means there are one \"2\" and one \"1\", the result is \"1211\"\n....\nNow we do a test, if the (n-1)th result is \"12212333312111238\"(I typed it randomly), what is the n th result? Let's count it. one \"1\", two \"2\", one \"1\" , one \"2\" , four\"3\" , one \"1\" , one \"2\", three\"1\", one \"2\", one\"3\" and one \"8\".Therefore, the result is \"1122111243111231121318\"\nObviously, if we wanna know the n th result, we just need to count the (n - 1)th result, and the first result is \"1\". No explanation.\n\nhopes this saves your lot of time........... \n\ncredit - @fx19316\nhttps://leetcode.com/problems/count-and-say/solutions/201832/it-s-a-good-question-let-me-explain-it/?orderBy=most_votes"
                    },
                    {
                        "username": "shanenescarimoro",
                        "content": "If even just the first half of your post was written on the description this question could have been much more liked."
                    },
                    {
                        "username": "spm999",
                        "content": "thank uuu"
                    },
                    {
                        "username": "khibach2004",
                        "content": "thank you very much\\n"
                    },
                    {
                        "username": "imankulov53",
                        "content": "Thank you for your explanation, it\\'s really helped me to understand and solve the task"
                    },
                    {
                        "username": "jinhping",
                        "content": "I am confused why input 1; output shoud be  1 instead of 11;\\nAlso, input 2, what is the output ? \\n\\nMore examples would be really helpful for me to understand this question."
                    },
                    {
                        "username": "rajneshrat",
                        "content": "may be that is starting string, it may be any string they have chosen it as 1"
                    },
                    {
                        "username": "mondeca",
                        "content": "I don\\'t understand why this question is guiding you towards recursion.  It seems like a fairly straightforward problem to solve.  Just iterate over the string, counting the length of the substring of identical numbers, and when the numbers change, add count and number to the output string.\\n\\nWith recursion, an input of 999999 would run a million times, but iterating over the string would only run six times.\\n\\nOr am I way off base here?"
                    },
                    {
                        "username": "ategale",
                        "content": "[@Javacks](/Javacks) I don\\'t think it asks to actually do it recursively? Iterative solution is much easier and intuitive imho..."
                    },
                    {
                        "username": "kuelf",
                        "content": "Yes you are way off base. The input will not be greater than 30. See constrains. "
                    },
                    {
                        "username": "mondeca",
                        "content": "[@Javacks](/Javacks) I think I finally got there.  The example of 3322251 is what\\'s leading me to think the answer is to just parse the digits.  But 3322251 isn\\'t the input n.  n is between 1 and 30, and they\\'re looking for the nth result in the sequence that\\'s built up from 1.\\n\\nI definitely read it wrong, but it is a very weird problem, and not communicated well when the most prominent example leads you down the wrong path."
                    },
                    {
                        "username": "Javacks",
                        "content": "It is asking you to be recursive because the string that you are gonna iterate will be based on n-1. I think that you are referring when it says \"two ones\", you are going to add \"21\" to your string. Once that your string is done, you need to return it, so that you work on countAndSay(n).\n\nI hope that my answer did not cause you more confusion. :C\n\nEdit: Here is my solution, but if you wanna try, just read my explanation on it without looking at the actual code:\nhttps://leetcode.com/problems/count-and-say/solutions/2719401/c-explained-and-easy-to-understand-using-recursion/"
                    },
                    {
                        "username": "heera-jaiswal",
                        "content": "I had been asked same question in google onsite interview. And then they asked followup question if you have to store output string of length m for very large input n, how do you store them in memory?\\n\\nProposed Solution: \\nAt at point, one must be combing 2 strings like to get recurring digits\\ns1= p, a times x\\ns2= b times y, q\\ns=paxbyq\\nwhere p<>a, x<>y, y<>p\\nmax possible length of same digits in result can be = 3 (when a=x=b)\\nSo the output will only contain 1,2,3 digits. Hence just 2 bits can be used represent either one of these 3 digits. And a byte can store total 4 digits. 2 bits represention of 0 can used to pad a byte.\\nExample: \"12\" => 00000110\\n1321 => 01111001\\nMemory size required to store length m output  = m//4+1 bytes\\n\\n"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=wvpe4ldKTW0) this video for the better explanation of the problem and the solution.\\nhttps://www.youtube.com/watch?v=wvpe4ldKTW0"
                    },
                    {
                        "username": "niravjain",
                        "content": "While a lot of people are posting their solutions, anyone care to discuss the best time \\n and space complexity they achieved?\\n\\nFor my solution,\\nTime complexity: O(k * n), where k is the length of the largest sequence till n\\nSpace complexity: O(n), to store all previous results up to n-1.\\n\\nAnyone got better complexities than these?"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) The power of GigaChads"
                    },
                    {
                        "username": "Demaxl",
                        "content": "[@DamianIvanochko](/DamianIvanochko) tf? how you even know im black"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "[@Demaxl](/Demaxl) good job lil nigga"
                    },
                    {
                        "username": "Demaxl",
                        "content": "I got ,\\n\\nTC: O(n*m) where n is the input given and m is the length of the previous say string countAndSay(n-1)\\n\\nSC: O(1) because I realized you dont really need to store the previously computed values just set them as the previous string"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Wanna play some minecraft bedrock sometimes?"
                    },
                    {
                        "username": "Shreya262",
                        "content": "TC =O(n*k)\\nSC= O(1)\\nwhat I got."
                    },
                    {
                        "username": "rahul_xt",
                        "content": "I have got the same complexity. But can use k in your complexity when it itself is unpredictive ?"
                    }
                ]
            },
            {
                "id": 1814421,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 1567819,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 1568858,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 1770537,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 1569540,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 1568857,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 1570140,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 1567820,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 1567822,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 2069155,
                "content": [
                    {
                        "username": "madpoly",
                        "content": "incredibly vague and confusing. Why is 4 1211? I really dont get it, why isnt it 14? In the example above its like this eg. 332215 which is 23-22-11-15. Then the examples on the bottom are completely different?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "because you are receiving not the string to decode, but number of iterations to do, starting from the base case 1 -> \"1\" "
                    },
                    {
                        "username": "xinyu05103",
                        "content": "Did anybody know the time complexity for this?"
                    },
                    {
                        "username": "chengjaimin",
                        "content": "   the test case input is 1, and the expected output is \"1\",why? i think the output should be \"11\""
                    },
                    {
                        "username": "zB0y",
                        "content": "I don\\'t know whether the way the question was written has changed in the past few years, but, given that most the complaints (justifying their dislike to the question) are from at least two years ago or more, and assuming the question has been edited in that span of time, I believe the question, in its current written state, is actually very articulate and straightforward! This is a good question and I suggest people come back to it, and (possibly?) change their dislikes to likes!"
                    },
                    {
                        "username": "AnitAgg",
                        "content": "I am unable to generalize with the given problem statement. Do you mind simplyfing it for me"
                    },
                    {
                        "username": "xuehuiping",
                        "content": " Input: 1\\nOutput: \"11\"\\nExpected: \"1\" \\n\\nIs \"11\" not right answer?"
                    },
                    {
                        "username": "wilsoncursino",
                        "content": "I just can\\'t see the point of asking this question in a interview... What are the signals the interviewer will get out of this question? \\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "If he think that you don\\'t know about recursion"
                    },
                    {
                        "username": "jarc",
                        "content": "I get accepted by simulating the process. Does anyone have a better solution? Thanks."
                    },
                    {
                        "username": "Ethan",
                        "content": "Input:\\t2\\nOutput:\\t\"12\"\\nExpected:\\t\"11\""
                    },
                    {
                        "username": "invincibleAAK",
                        "content": "It a confusing question. I would surely not be able solve it even though I did solve it after going through the discussions. I wonder what we are supposed to do in the real interview ."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Balls."
                    }
                ]
            },
            {
                "id": 2068396,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 2066370,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 2062122,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 2048197,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 2047041,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 2043573,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 2035631,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 1914664,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 1831027,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 1650572,
                "content": [
                    {
                        "username": "ankitwasankar",
                        "content": "Till now I was not able to understand answers. Now I started not understanding questions.\\n `feeling dumb`"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "You\\'re indian you will solve it with ease"
                    },
                    {
                        "username": "CGU110B1029060",
                        "content": "Easy 0ms Solution.\n```\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        if (n == 1) return \"1\";\n        if (n == 2) return \"11\";\n        if (n == 3) return \"21\";\n        if (n == 4) return \"1211\";\n        if (n == 5) return \"111221\";\n        if (n == 6) return \"312211\";\n        if (n == 7) return \"13112221\";\n        if (n == 8) return \"1113213211\";\n        if (n == 9) return \"31131211131221\";\n        if (n == 10) return \"13211311123113112211\";\n        if (n == 11) return \"11131221133112132113212221\";\n        if (n == 12) return \"3113112221232112111312211312113211\";\n        if (n == 13) return \"1321132132111213122112311311222113111221131221\";\n        if (n == 14) return \"11131221131211131231121113112221121321132132211331222113112211\";\n        if (n == 15) return \"311311222113111231131112132112311321322112111312211312111322212311322113212221\";\n        if (n == 16) return \"132113213221133112132113311211131221121321131211132221123113112221131112311332111213211322211312113211\";\n        if (n == 17) return \"11131221131211132221232112111312212321123113112221121113122113111231133221121321132132211331121321231231121113122113322113111221131221\";\n        if (n == 18) return \"31131122211311123113321112131221123113112211121312211213211321322112311311222113311213212322211211131221131211132221232112111312111213111213211231131122212322211331222113112211\";\n        if (n == 19) return \"1321132132211331121321231231121113112221121321132122311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112111331121113122112132113213211121332212311322113212221\";\n        if (n == 20) return \"11131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 21) return \"311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311122122111312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 22) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113213221133122112231131122211211131221131112311332211211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 23) return \"111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121113222123112221221321132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 24) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 25) return \"132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132132211231232112311321322112311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312111312212231131122211311123113322112111312211312111322111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113213221132213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121132211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 26) return \"1113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123211211131211121311121321123113111231131122112213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122113221122112133221121113122113121113222123211211131211121311121321123113213221121113122113121113222113221113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        if (n == 27) return \"31131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321322123211211131211121332211231131122211311122122111312211213211312111322211231131122211311123113322112111331121113112221121113122113111231133221121113122113121113222123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221123113112221131112311332111213122112311311123112111331121113122112132113311213211321222122111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112132113213221133112132123123112111311222112132113311213211231232112311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122211311123113322113223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331221122311311222112111312211311123113322112132113213221133122211332111213112221133211322112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122211331121321232221121113122113121122132112311321322112111312211312111322211213111213122112132113121113222112132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212321121113121112133221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213212312311211131122211213211331121321122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311222113111221221113122112132113121113222112132113213221133122211332111213322112132113213221132231131122211311123113322112111312211312111322212321121113122123211231131122113221123113221113122112132113213211121332212311322113212221\";\n        if (n == 28) return \"13211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221232112111312211312113211223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321322113311213212322211322132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212311222122132113213221123113112221133112132123222112111312211312111322212311322123123112111321322123122113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132132211331221122311311222112111312211311123113322112111312211312111322212311322123123112112322211211131221131211132221132213211321322113311213212322211231131122211311123113321112131221123113112211121312211213211321222113222112132113223113112221121113122113121113123112112322111213211322211312113211\";\n        if (n == 29) return \"11131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211132221121311121312211213211312111322211213211321322113311213212322211231131122211311123113223112111311222112132113311213211221121332211211131221131211132221231122212213211321322112311311222113311213212322211211131221131211132221232112111312111213322112131112131221121321131211132221121321132132212321121113121112133221121321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122112131112131221121321132132211231131122111213122112311311222113111221131221221321132132211331121321231231121113112221121321133112132112211213322112311311222113111231133211121312211231131122211322311311222112111312211311123113322112132113212231121113112221121321132122211322212221121123222112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311222112111331121113112221121113122113121113222112132113213221232112111312111213322112311311222113111221221113122112132113121113222112311311222113111221132221231221132221222112112322211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212321121113121112133221132211131221131211132221232112111312111213322112132113213221133112132113221321123113213221121113122123211211131221222112112322211231131122211311123113321112132132112211131221131211132221121321132132212321121113121112133221123113112221131112311332111213211322111213111213211231131211132211121311222113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331121321232221123123211231132132211231131122211331121321232221123113112221131112311332111213122112311311123112112322211211131221131211132221232112111312211322111312211213211312111322211231131122111213122112311311221132211221121332211213211321322113311213212312311211131211131221223113112221131112311332211211131221131211132211121312211231131112311211232221121321132132211331121321231231121113112221121321133112132112211213322112312321123113213221123113112221133112132123222112311311222113111231132231121113112221121321133112132112211213322112311311222113111231133211121312211231131112311211133112111312211213211312111322211231131122111213122112311311221132211221121332211211131221131211132221232112111312111213111213211231132132211211131221232112111312211213111213122112132113213221123113112221133112132123222112111312211312111322212311222122132113213221123113112221133112132123222112311311222113111231133211121321132211121311121321122112133221123113112221131112311332211322111312211312111322212321121113121112133221121321132132211331121321231231121113112221121321132122311211131122211211131221131211322113322112111312211322132113213221123113112221131112311311121321122112132231121113122113322113111221131221\";\n        if (n == 30) return \"3113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112212211131221121321131211132221123113112221131112311332211211133112111311222112111312211311123113322112111312211312111322212321121113121112133221121321132132211331121321132213211231132132211211131221232112111312212221121123222112311311222113111231133211121321321122111312211312111322211213211321322123211211131211121332211231131122211311123113321112131221123113111231121123222112111331121113112221121113122113111231133221121113122113121113221112131221123113111231121123222112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211231131122211311123113321112131221123113111231121113311211131221121321131211132221123113112211121312211231131122211211133112111311222112111312211312111322211213211321223112111311222112132113213221133122211311221122111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321132132211322132113213221123113112221133112132123222112111312211312112213211231132132211211131221131211322113321132211221121332211213211321322113311213212312311211131122211213211331121321123123211231131122211211131221131112311332211213211321223112111311222112132113213221123123211231132132211231131122211311123113322112111312211312111322111213122112311311123112112322211213211321322113312211223113112221121113122113111231133221121321132132211331222113321112131122211332113221122112133221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213122112311311123112112322211322311311222113111231133211121312211231131112311211232221121113122113121113222123211211131221132211131221121321131211132221123113112211121312211231131122113221122112133221121321132132211331121321231231121113121113122122311311222113111231133221121113122113121113221112131221123113111231121123222112132113213221133112132123123112111312211322311211133112111312211213211311123113223112111321322123122113222122211211232221121113122113121113222123211211131211121311121321123113213221121113122123211211131221121311121312211213211321322112311311222113311213212322211211131221131211221321123113213221121113122113121113222112131112131221121321131211132221121321132132211331121321232221123113112221131112311322311211131122211213211331121321122112133221121113122113121113222123112221221321132132211231131122211331121321232221121113122113121113222123211211131211121332211213111213122112132113121113222112132113213221232112111312111213322112132113213221133112132123123112111311222112132113311213211221121332211231131122211311123113321112131221123113112221132231131122211211131221131112311332211213211321223112111311222112132113212221132221222112112322211211131221131211132221232112111312111213111213211231131112311311221122132113213221133112132123222112311311222113111231132231121113112221121321133112132112211213322112111312211312111322212321121113121112131112132112311321322112111312212321121113122122211211232221121311121312211213211312111322211213211321322123211211131211121332211213211321322113311213211322132112311321322112111312212321121113122122211211232221121321132132211331121321231231121113112221121321133112132112312321123113112221121113122113111231133221121321132122311211131122211213211321222113222122211211232221123113112221131112311332111213122112311311123112111331121113122112132113121113222112311311221112131221123113112221121113311211131122211211131221131211132221121321132132212321121113121112133221123113112221131112311332111213213211221113122113121113222112132113213221232112111312111213322112132113213221133112132123123112111312211322311211133112111312212221121123222112132113213221133112132123222113223113112221131112311332111213122112311311123112112322211211131221131211132221232112111312111213111213211231132132211211131221131211221321123113213221123113112221131112211322212322211231131122211322111312211312111322211213211321322113311213211331121113122122211211132213211231131122212322211331222113112211\";\n        return \"Joke!\";\n    }\n};\n```"
                    },
                    {
                        "username": "Demaxl",
                        "content": "You\\'re hired"
                    },
                    {
                        "username": "TanishkDhaka",
                        "content": "//**this description is from geekforgeek this problem is mentioned as easy on gfg hope this helps **//\nGiven an integer n. Return the nth row of the following look-and-say pattern.\n1\n11\n21\n1211\n111221\nLook-and-Say Pattern:\n\nTo generate a member of the sequence from the previous member, read off the digits of the previous member, counting the number of digits in groups of the same digit. For example:\n\n1 is read off as \"one 1\" or 11.\n11 is read off as \"two 1s\" or 21.\n21 is read off as \"one 2, then one 1\" or 1211.\n1211 is read off as \"one 1, one 2, then two 1s\" or 111221.\n111221 is read off as \"three 1s, two 2s, then one 1\" or 312211."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "good job lil nigga"
                    },
                    {
                        "username": "gsahu07",
                        "content": "[Count and...](https://i.gifer.com/7BTj.gif)"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "you look like geek"
                    },
                    {
                        "username": "GONZALOBLUE",
                        "content": "Used for Pinterest ML Phone screening"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "okay thanks for the information"
                    },
                    {
                        "username": "fkie4",
                        "content": "this is gay"
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "Super gay\\uD83D\\uDC80"
                    },
                    {
                        "username": "dimitryku",
                        "content": "I can\\'t understand, why there are a lot of comments about how difficult it is to understand this task. Maybe they changed its description, but for now it is really clear. You just need to make recursive algorythm, that is counting consecuentive identical numbers of previous result with base case of 1 -> \"1\". \\nPersonally I spent 5 minutes and got 50%, 39% solution on C++. Not really good result, but in no time."
                    },
                    {
                        "username": "alexdodge",
                        "content": "I think the wording for this question must have changed, based on some of the old comments.  As it is, it seems pretty straightforward.\\n\\nI\\'m unclear why this is a \"medium\", unless there\\'s some algorithmic trick I\\'m missing.  If there is a non-obvious algorithm for this, it\\'d be nice if that was hinted at in the assignment, maybe with an additional constraint on time or space complexity."
                    },
                    {
                        "username": "mcmattman",
                        "content": "Debugging this is giving me an aneurysm."
                    },
                    {
                        "username": "codewhisperer__",
                        "content": "This is a fun and very easy problem."
                    }
                ]
            },
            {
                "id": 1576903,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 1575022,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 1574357,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 1574071,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 1572255,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 1571850,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 1571095,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 1575288,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 1568856,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 2057602,
                "content": [
                    {
                        "username": "gouravgouravtiwari4",
                        "content": "![image](https://assets.leetcode.com/users/images/4b01501d-5e67-4891-bd22-8887e854d393_1655324370.1430545.png)\\n"
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Isn\\'t this a good problem? It tests some nice recursive intuition and your ability to handle duplicates in strings as well."
                    },
                    {
                        "username": "WFAN633",
                        "content": "It requires the nth term...\\nFor example, if the n is 11. we need to find the 11th term.. \\nI saw many solutions set the outer loop in the range(n-1) which means it will generate to n-1th terms..\\nBC the range is start from index 0, and ends before n-1.\\nI am confused that why we set the limit to n-1 not n????\\nwhy it is not range(n)???????????"
                    },
                    {
                        "username": "jayshreegohil",
                        "content": "Hi, I am having hard time understanding the problem statement. Should the sum of the int words in output result into the input?"
                    },
                    {
                        "username": "leifan",
                        "content": "From Wiki, it says \"the terms eventually grow in length by about 30% per generation.\". So I think the time complexity should be O(n1.3^n), and space complexity is O(1.3^n). Any ideas?"
                    },
                    {
                        "username": "usc_student_viterbi",
                        "content": "Re: [Please change the misleading description](/topic/1296/please-change-the-misleading-description)"
                    },
                    {
                        "username": "lamster",
                        "content": "I think that given a number x, then the code is to change it a way to read the digits of x:\\ninput: 1,  output: 11\\ninput: 2,  output: 21\\ninput: 11332, output: 212312.\\nmy code gets a wrong answer:\\ninput: 1, my output is 11, and the expected ouput is 1, why?\\nI cannot umderstand"
                    },
                    {
                        "username": "baapcoder_",
                        "content": "I tried using unordered_map for this problem but it gave me 1112. IDK if it\\'s possible or not. Could somebody help me out with this?"
                    },
                    {
                        "username": "dboltenko",
                        "content": "Test result\\n\\nInput:\\n1\\nOutput:\\n\"11\"\\nExpected:\\n\"1\"\\n\\nI guess condition says that 1 read off as one 1 or 11. Is it bad test or what?"
                    },
                    {
                        "username": "jaypatel100125",
                        "content": "I\\'m counting and saying that this is the most disliked problem I have seen on LeetCode."
                    },
                    {
                        "username": "DamianIvanochko",
                        "content": "This problem is easier than you think, just use hashmap to count freq and add it to the string ans"
                    }
                ]
            },
            {
                "id": 2019331,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesn’t matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 2013351,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesn’t matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 2010964,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesn’t matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 2009159,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesn’t matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 2008514,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesn’t matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 2004237,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesn’t matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 2003865,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesn’t matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 2003856,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesn’t matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 2001868,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesn’t matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 2001551,
                "content": [
                    {
                        "username": "real_nitin_negi",
                        "content": "just read the testcase that is given you will figure it out, explanation is kind of confusing"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "TC should have been more explanatory,It sucks to get through such testcases\\uD83E\\uDD72"
                    },
                    {
                        "username": "demoai",
                        "content": "# HELP HELP \n'''\nstring count(string s){ \n        string rs=\"\";\n        unordered_map<char,int>mp;\n        for(auto i:s)\n            mp[i]++;\n        for(auto p:mp)\n            rs+= p.first+to_string(p.second);  \n        return rs;\n    }\n    string countAndSay(int n) {\n\n        string s=\"1\";\n        n--;\n        while(n--){\n            s=count(s);\n            //cout<<s<<endl;\n        }\n        return s;\n    }\n'''\n# PLS Help \nOutput\n\"2111\"\nExpected\n\"1211\"\n"
                    },
                    {
                        "username": "dimitryku",
                        "content": "rs+= to_string(p.second) + p.first;\n\nSince count should be before counted number."
                    },
                    {
                        "username": "sav20011962",
                        "content": "But it would be interesting for me to chat with a problem inverse to this one. Those. given the received string, you need to go back a few steps according to this scheme.\nBy the way, there seem to be some patterns here, which, perhaps, will allow not to carry out iterative calculations (in a loop or recursively - it doesn’t matter), but to immediately get the result according to the formula. This, in my opinion, can apply to both direct and inverse problems. In the inverse problem, it is also interesting that it may not have a solution. The straight line seems to be always resolvable. But the reverse can either grow rapidly (even faster than the direct one), or be a dead end.\nFor example, there is a line 111 = this is 11 by 1, i.e. previous 11111111111 and this is already prohibitive, i.e. 1111111111 by 1.\nAnd if the line is 1123, then the previous one is 1 by 1 and 2 by 3, i.e. 133, and this is a case similar to the previous one, i.e. grows very quickly - the previous 13 to 3, i.e. 3333333333333, further rapid growth..."
                    },
                    {
                        "username": "deepanshubhargav",
                        "content": "kya bakwas explanation hai bhailog\\n"
                    },
                    {
                        "username": "yashwantsing333",
                        "content": "ountAndSay(n) => countAndSay(n-1)==>counAndSay(n-2)....countAndSay(1)\n            countAndSay(1) = >1 which is pretty obvious its base case\n\n            countAndSay(1)=> 1\n            countAndSay(2)=> 11\n            countAndSay(3)=> 21\n            countAndSay(4)=> 1211\n            countAndSay(5)=> 111221\n            countAndSay(6)=> 312211"
                    },
                    {
                        "username": "maxlee577",
                        "content": "To solve this problem, focus on identifying the pattern in the test cases rather than solely relying on the problem description. The base case is represented as \"1\" for input 1. For input 2, it depends on the representation of 1, which is \"1\" in this case. Therefore, to represent 2, use the frequency of \"1\" in \"1\" and the digit \"1,\" resulting in \"11.\"\\n\\nFor input 3, we use the frequency of the digits and the digits themselves. For instance, the frequency of \"1\" in \"2\" is 1, and the digit is \"1,\" so the representation becomes \"21.\"\\n\\nSimilarly, for input 4, observe that 3 is composed of two instances of \"21.\" Therefore, to represent 4, we concatenate the frequencies and digits of \"2\" and \"1,\" resulting in \"1211.\" `your inline code...your inline code...`[leetcode](https://leetcode.com/problems/count-and-say/solutions/3875049/super-fast-with-how-to-solve-methodology/)"
                    },
                    {
                        "username": "maxlee577",
                        "content": "If you want to solve this problem don\\'t think about the problem description but instead look a the pattern in the test case\\n eg-\\n1=\"1\" it is the base case\\n2=\"11\" it depends on 1 in 1 we have string \"1\" so to represent 2 we use the frequency of 1 in 1 and the digit 1\\nfor 3=\"2\" we use\" the freq of the digits and the digit eg- freq(1) in 2 and digit 1=str(freq(1))+\"1\"\\nsimilarly \\n4=\"1211\" if you look closely 3 is make of two \"21\" so to represent 4 we use [freq(2)+digit(2)+freq(1)+digit(1)] `your inline code...your inline code...`"
                    },
                    {
                        "username": "nooneseesmyname",
                        "content": "This would\\'ve been an easy one if the description was clear enough."
                    },
                    {
                        "username": "daniel_9650",
                        "content": "I don\\'t know if its just me, but I plain don\\'t understand the problem description itself. It\\'s very unclear"
                    }
                ]
            },
            {
                "id": 1987973,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1983418,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1973041,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1967780,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1944508,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1913283,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1904104,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1892325,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1862841,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1855192,
                "content": [
                    {
                        "username": "marcjeffs6",
                        "content": "To me, this question came down to understanding loop conditions and when to use what type of loop. I initially tried two pointers with two for loops, but was having trouble incrementing the pointer variables. I think that from now on, if the pointers move conditionally, always will bias to using while loops. It's easier for me to reason about setting the value of each pointer that way since they can be scoped outside of the loops themselves."
                    },
                    {
                        "username": "sanskar01",
                        "content": "Damn! Gave KG vibe."
                    },
                    {
                        "username": "dev_bhalodia",
                        "content": "Can be easily solved using 2 for loops! O(n^2) solution passed! just count the frequency of each character and convert the frequency, which is an integer, to String and add it in the newstring first, and then the respective character. when i say frequency, it is just the count of the same character UNTIL a new character pops up. No need of map too."
                    },
                    {
                        "username": "ingato",
                        "content": "If anybody ever asks anything remotely like this in an interview, tell them to f off and leave. Like, seriously, wtf is this?"
                    },
                    {
                        "username": "JekoAZE",
                        "content": "I understood everything. But to write code for this problem it`s very tough. I dont think some company will ask like this question"
                    },
                    {
                        "username": "patrickallard",
                        "content": "Seems like a lot of people here are struggling with the concept that the input arg is NOT the value being evaluated. It is instead the number of times that countAndSay() is called. That is why the base case n == 1 produces \"1\". "
                    },
                    {
                        "username": "Ditto042",
                        "content": "what?"
                    },
                    {
                        "username": "ayushbisht0103",
                        "content": "Well to be honest  I can\\'t  understand  from this description what  the problem want me to do  so please improve it . "
                    },
                    {
                        "username": "_bolorshagai",
                        "content": "For example, let\\'s say we call countAndSay(4). This means we want to compute the fourth digit string in the count-and-say sequence. Here\\'s how the function executes:\\n\\n+ First, it checks if n (which is 4) is greater than 1. Since it is, the function continues.\\n+ The function calls countAndSay(3) to get the previous digit string in the sequence.\\ncountAndSay(3) in turn calls countAndSay(2) to get the previous digit string, and so on, until we reach the base case of countAndSay(1), which returns \"1\".\\n+ Now we have the previous digit string, which is \"1 1 2 2 2 1\". The function splits this string into substrings that contain exactly one unique digit: \"1 1\", \"2 2 2\", and \"1\".\\n+ The function then loops over these substrings and concatenates the count of each digit with the digit itself. For example, \"1 1\" becomes \"21\" (because there are two ones), \"2 2 2\" becomes \"32\" (because there are three twos), and \"1\" becomes \"11\" (because there is one one).\\n+ Finally, the function concatenates all of these strings together and returns the result: \"211213\"."
                    },
                    {
                        "username": "noob_ace",
                        "content": "Can somebody explain why the output only has 1,2,3 as digits in it? Why is 4 not possible in the output? I looked at [@heera-jaiswal](/heera-jaiswal)\\'s comment and couldn\\'t properly understand the same. "
                    }
                ]
            },
            {
                "id": 1810750,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1793136,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1790290,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1780873,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1766928,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1756510,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1752943,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1752942,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1751592,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1748637,
                "content": [
                    {
                        "username": "izzymoralll",
                        "content": "i always approach any problem with DP/recursion first and then other approach . is this normal ?? "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Stupid problems require stupid solutions\\n"
                    },
                    {
                        "username": "ShankarAjay",
                        "content": "At the beginning, I got confusions about what is the nth sequence. Well, my solution is accepted now, so I\\'m going to give some examples of nth sequence here. The following are sequence from n=1 to n=10:\\n\\n 1.     1\\n 2.     11\\n 3.     21\\n 4.     1211\\n 5.     111221 \\n 6.     312211\\n 7.     13112221\\n 8.     1113213211\\n 9.     31131211131221\\n 10.   13211311123113112211\\nFrom the examples you can see, the (i+1)th sequence is the \"count and say\" of the ith sequence!\\n\\nHope this helps!"
                    },
                    {
                        "username": "romeshtripathi",
                        "content": "This is most easy question until you understand it !\\n\\nn = 1 \\nthen you have to return \"1\"\\n\\nn = 2\\nthen get the answer of n -1 through your function and apply count and say on it.\\nfor example :\\ngiven input is n = 3\\ncall countAndSay for n-1 i.e 2\\n    now for your call n = 2\\n    call count and say for n - 1 i.e n = 1\\n        on this call base case will return \"1\"\\n    we have \"1\" as the result of n = 1 call\\n    now count and say \"1\" ie \"11\" and return it.\\nfor call of n = 2 we have res = \"11\"\\nnow count and say it i.e \"21\" and return it.\\n\\nHope you understood it !"
                    },
                    {
                        "username": "bsheth",
                        "content": "This stupid question screwed me on a hackerrank. "
                    },
                    {
                        "username": "PentaMa",
                        "content": "You don\\'t get to fully understand this question until you check out the discussion board. Bad question, it is."
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "unfaithfullfork",
                        "content": "Tf is this? "
                    },
                    {
                        "username": "paullam328",
                        "content": "It takes more braincells to understand this question than actually solving it"
                    },
                    {
                        "username": "deleted_user",
                        "content": "This question seems easy but I\\'m not able to come up with a proper solution ..)"
                    }
                ]
            },
            {
                "id": 1723369,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            },
            {
                "id": 1722444,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            },
            {
                "id": 1715825,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            },
            {
                "id": 1684119,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            },
            {
                "id": 1671310,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            },
            {
                "id": 1649888,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            },
            {
                "id": 1649769,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            },
            {
                "id": 1649656,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            },
            {
                "id": 1649579,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            },
            {
                "id": 1635755,
                "content": [
                    {
                        "username": "raka_7317",
                        "content": "class Solution {\\n    public String countAndSay(int n) {\\n        if(n==1){\\n            return \"1\";\\n\\n        }\\n        if(n==2){\\n            return \"11\";\\n        }\\n       String s=\"11\";\\n        for(int i=3;i<=n;i++){\\n            String t=\"\";\\n            s=s+\\'$\\';\\n            int c=1;\\n            for(int j=1;j<n;j++){\\n                if(s[j-1]==s[j]){\\n                    c++;\\n                }\\n                else{\\n                    t=t+to_string(c);\\n                    t=t+s[j-1];\\n                    c=1;\\n                }\\n            }\\n            s=t;\\n\\n            \\n        }\\n        return s;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\ncan anyone tell me why the error is here;\\n"
                    },
                    {
                        "username": "fedrox111",
                        "content": "lol, sigmas are dying in war and here we are counting freaking numbers.(wo bhi nahi ho raha bc)\\n"
                    },
                    {
                        "username": "zeroand1only",
                        "content": "This is probably one of the worst problems I have encountered so far. The description is not clear at all - the description doesn\\'t associate the \"n\" to the rest of the explanation, and you can only sort of guess that from the first example which says to be the base case. Then what\\'s the point of this problem? isn\\'t the answer fixed for the given n? kind of like calculating the fib sequence?"
                    },
                    {
                        "username": "edendattox",
                        "content": " `your inline code...your inline code...`"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-count-and-say-problem-solution.html)"
                    },
                    {
                        "username": "Bikkel",
                        "content": "Why this task has so many dislikes?"
                    },
                    {
                        "username": "yousenwang001",
                        "content": "Input: n = 4\\nOutput: \"1211\"\\nExplanation:\\ncountAndSay(1) = \"1\" (base case)\\ncountAndSay(2) = say \"1\" = one 1 = \"11\" \\u4E00\\u500B\\u4E00\\ncountAndSay(3) = say \"11\" = two 1\\'s = \"21\" \\u5169\\u500B\\u4E00\\ncountAndSay(4) = say \"21\" = one 2 + one 1 = \"12\" + \"11\" = \"1211\" \\u4E00\\u500B\\u4E8C \\u4E00\\u500B\\u4E00 "
                    },
                    {
                        "username": "rahul_xt",
                        "content": "Getting the anwer using the instructions given in the question is easy but how do you estimate the time complexity when you don\\'t know how big is your last string going to be. \\nOn a worst to worst case it can be double the size of the last one which would give it the time complexity of O(2^29) which is obviously too much (536,870,912).\\nBut actually the code easily runs under 30ms and obviously the length of the consecutive string cannot be double as definitely there are going to be repeatitions.\\nSo lets say on an average the size of next string is 1.5 times the last one. Using this in the GP formula we get the 127,834.039. Which is quite less but we cannot be sure about it being 1.5.\\nSo let\\'s move on to (2+1.5)/2 = 1.75. We get time complexity of 11,171,292.21. Which is closer to give TLE again.\\nThis makes really ambiguous what the time complexity can be in general when we do not know the size of the next string.  "
                    },
                    {
                        "username": "ishanmsihra74",
                        "content": "## Explanation\\n\\nWe are given a recursive relation where countAndSay(n) = say(CountAndSay(n-1)), for example I/p = 4, then\\ncountAndSay(4) = say(CountAndSay(3))\\n=> CountAndSay(3) = say(CountAndSay(2))\\n=> CountAndSay(2) = say(CountAndSay(1)) [base-case]\\n=> CountAndSay(2) = say(\"1\") [now back track]\\n"
                    },
                    {
                        "username": "barstow123",
                        "content": "I know there are a lot of dislikes on this question, but all the information is available. Top tech companies will want to know that you can read the question critically.\\n\\nI was able to solve this in about 10-15 minutes, and you can too if you practice reading critically. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Copy List with Random Pointer",
        "question_content": "<p>A linked list of length <code>n</code> is given such that each node contains an additional random pointer, which could point to any node in the list, or <code>null</code>.</p>\n\n<p>Construct a <a href=\"https://en.wikipedia.org/wiki/Object_copying#Deep_copy\" target=\"_blank\"><strong>deep copy</strong></a> of the list. The deep copy should consist of exactly <code>n</code> <strong>brand new</strong> nodes, where each new node has its value set to the value of its corresponding original node. Both the <code>next</code> and <code>random</code> pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. <strong>None of the pointers in the new list should point to nodes in the original list</strong>.</p>\n\n<p>For example, if there are two nodes <code>X</code> and <code>Y</code> in the original list, where <code>X.random --&gt; Y</code>, then for the corresponding two nodes <code>x</code> and <code>y</code> in the copied list, <code>x.random --&gt; y</code>.</p>\n\n<p>Return <em>the head of the copied linked list</em>.</p>\n\n<p>The linked list is represented in the input/output as a list of <code>n</code> nodes. Each node is represented as a pair of <code>[val, random_index]</code> where:</p>\n\n<ul>\n\t<li><code>val</code>: an integer representing <code>Node.val</code></li>\n\t<li><code>random_index</code>: the index of the node (range from <code>0</code> to <code>n-1</code>) that the <code>random</code> pointer points to, or <code>null</code> if it does not point to any node.</li>\n</ul>\n\n<p>Your code will <strong>only</strong> be given the <code>head</code> of the original linked list.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e1.png\" style=\"width: 700px; height: 142px;\" />\n<pre>\n<strong>Input:</strong> head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\n<strong>Output:</strong> [[7,null],[13,0],[11,4],[10,2],[1,0]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e2.png\" style=\"width: 700px; height: 114px;\" />\n<pre>\n<strong>Input:</strong> head = [[1,1],[2,1]]\n<strong>Output:</strong> [[1,1],[2,1]]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2019/12/18/e3.png\" style=\"width: 700px; height: 122px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> head = [[3,null],[3,0],[3,null]]\n<strong>Output:</strong> [[3,null],[3,0],[3,null]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= n &lt;= 1000</code></li>\n\t<li><code>-10<sup>4</sup> &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n\t<li><code>Node.random</code> is <code>null</code> or is pointing to some node in the linked list.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 43491,
                "title": "a-solution-with-constant-space-complexity-o-1-and-linear-time-complexity-o-n",
                "content": "An intuitive solution is to keep a hash table for each node in the list, via which we just need to iterate the list in 2 rounds respectively to create nodes and assign the values for their random pointers. As a result, the space complexity of this solution is `O(N)`, although with a linear time complexity. \\n\\n*Note:  if we do not consider the space reversed for the output, then we could say that the algorithm does not consume any additional memory during the processing, i.e. O(1) space complexity*\\n\\nAs an optimised solution, we could reduce the space complexity into constant. ***The idea is to associate the original node with its copy node in a single linked list. In this way, we don\\'t need extra space to keep track of the new nodes.***\\n\\nThe algorithm is composed of the follow three steps which are also 3 iteration rounds. \\n\\n 1. Iterate the original list and duplicate each node. The duplicate\\n    of each node follows its original immediately.\\n 2. Iterate the new list and assign the random pointer for each\\n    duplicated node.\\n 3. Restore the original list and extract the duplicated nodes.\\n\\nThe algorithm is implemented as follows:\\n```java\\npublic RandomListNode copyRandomList(RandomListNode head) {\\n  RandomListNode iter = head, next;\\n\\n  // First round: make copy of each node,\\n  // and link them together side-by-side in a single list.\\n  while (iter != null) {\\n    next = iter.next;\\n\\n    RandomListNode copy = new RandomListNode(iter.label);\\n    iter.next = copy;\\n    copy.next = next;\\n\\n    iter = next;\\n  }\\n\\n  // Second round: assign random pointers for the copy nodes.\\n  iter = head;\\n  while (iter != null) {\\n    if (iter.random != null) {\\n      iter.next.random = iter.random.next;\\n    }\\n    iter = iter.next.next;\\n  }\\n\\n  // Third round: restore the original list, and extract the copy list.\\n  iter = head;\\n  RandomListNode pseudoHead = new RandomListNode(0);\\n  RandomListNode copy, copyIter = pseudoHead;\\n\\n  while (iter != null) {\\n    next = iter.next.next;\\n\\n    // extract the copy\\n    copy = iter.next;\\n    copyIter.next = copy;\\n    copyIter = copy;\\n\\n    // restore the original list\\n    iter.next = next;\\n\\n    iter = next;\\n  }\\n\\n  return pseudoHead.next;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```java\\npublic RandomListNode copyRandomList(RandomListNode head) {\\n  RandomListNode iter = head, next;\\n\\n  // First round: make copy of each node,\\n  // and link them together side-by-side in a single list.\\n  while (iter != null) {\\n    next = iter.next;\\n\\n    RandomListNode copy = new RandomListNode(iter.label);\\n    iter.next = copy;\\n    copy.next = next;\\n\\n    iter = next;\\n  }\\n\\n  // Second round: assign random pointers for the copy nodes.\\n  iter = head;\\n  while (iter != null) {\\n    if (iter.random != null) {\\n      iter.next.random = iter.random.next;\\n    }\\n    iter = iter.next.next;\\n  }\\n\\n  // Third round: restore the original list, and extract the copy list.\\n  iter = head;\\n  RandomListNode pseudoHead = new RandomListNode(0);\\n  RandomListNode copy, copyIter = pseudoHead;\\n\\n  while (iter != null) {\\n    next = iter.next.next;\\n\\n    // extract the copy\\n    copy = iter.next;\\n    copyIter.next = copy;\\n    copyIter = copy;\\n\\n    // restore the original list\\n    iter.next = next;\\n\\n    iter = next;\\n  }\\n\\n  return pseudoHead.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43488,
                "title": "java-o-n-solution",
                "content": "    public RandomListNode copyRandomList(RandomListNode head) {\\n      if (head == null) return null;\\n      \\n      Map<RandomListNode, RandomListNode> map = new HashMap<RandomListNode, RandomListNode>();\\n      \\n      // loop 1. copy all the nodes\\n      RandomListNode node = head;\\n      while (node != null) {\\n        map.put(node, new RandomListNode(node.label));\\n        node = node.next;\\n      }\\n      \\n      // loop 2. assign next and random pointers\\n      node = head;\\n      while (node != null) {\\n        map.get(node).next = map.get(node.next);\\n        map.get(node).random = map.get(node.random);\\n        node = node.next;\\n      }\\n      \\n      return map.get(head);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public RandomListNode copyRandomList(RandomListNode head) {\\n      if (head == null) return null;\\n      \\n      Map<RandomListNode, RandomListNode> map = new HashMap<RandomListNode, RandomListNode>();\\n      \\n      // loop 1. copy all the nodes\\n      RandomListNode node = head;\\n      while (node != null) {\\n        map.put(node, new RandomListNode(node.label));\\n        node = node.next;\\n      }\\n      \\n      // loop 2. assign next and random pointers\\n      node = head;\\n      while (node != null) {\\n        map.get(node).next = map.get(node.next);\\n        map.get(node).random = map.get(node.random);\\n        node = node.next;\\n      }\\n      \\n      return map.get(head);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 811151,
                "title": "extremely-simple-solution-using-c",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        map<Node*, Node*> m;\\n        int i=0;\\n        Node* ptr = head;\\n        while (ptr) {\\n            m[ptr] =new Node(ptr->val);\\n            ptr = ptr->next;\\n        }\\n        ptr = head;\\n        while (ptr) {\\n            m[ptr]->next = m[ptr->next];\\n            m[ptr]->random = m[ptr->random];\\n            ptr = ptr->next;\\n        }\\n        return m[head];\\n    }\\n};\\n```\\n\\nEdit : Since this post has gained a lot of upvotes, I thought to mention the source from where I got this solution - Youtube channel of back to back swe",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        map<Node*, Node*> m;\\n        int i=0;\\n        Node* ptr = head;\\n        while (ptr) {\\n            m[ptr] =new Node(ptr->val);\\n            ptr = ptr->next;\\n        }\\n        ptr = head;\\n        while (ptr) {\\n            m[ptr]->next = m[ptr->next];\\n            m[ptr]->random = m[ptr->random];\\n            ptr = ptr->next;\\n        }\\n        return m[head];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43497,
                "title": "2-clean-c-algorithms-without-using-extra-array-hash-table-algorithms-are-explained-step-by-step",
                "content": "    //\\n    // Here's how the 1st algorithm goes.\\n    // Consider l1 as a node on the 1st list and l2 as the corresponding node on 2nd list.\\n    // Step 1:\\n    // Build the 2nd list by creating a new node for each node in 1st list. \\n    // While doing so, insert each new node after it's corresponding node in the 1st list.\\n    // Step 2:\\n    // The new head is the 2nd node as that was the first inserted node.\\n    // Step 3:\\n    // Fix the random pointers in the 2nd list: (Remember that l1->next is actually l2)\\n    // l2->random will be the node in 2nd list that corresponds l1->random, \\n    // which is next node of l1->random.\\n    // Step 4:\\n    // Separate the combined list into 2: Splice out nodes that are part of second list. \\n    // Return the new head that we saved in step 2.\\n    //\\n    \\n    RandomListNode *copyRandomList(RandomListNode *head) {\\n        RandomListNode *newHead, *l1, *l2;\\n        if (head == NULL) return NULL;\\n        for (l1 = head; l1 != NULL; l1 = l1->next->next) {\\n            l2 = new RandomListNode(l1->label);\\n            l2->next = l1->next;\\n            l1->next = l2;\\n        }\\n            \\n        newHead = head->next;\\n        for (l1 = head; l1 != NULL; l1 = l1->next->next) {\\n            if (l1->random != NULL) l1->next->random = l1->random->next;\\n        }\\n            \\n        for (l1 = head; l1 != NULL; l1 = l1->next) {\\n            l2 = l1->next;\\n            l1->next = l2->next;\\n            if (l2->next != NULL) l2->next = l2->next->next;\\n        }\\n    \\n        return newHead;\\n    }\\n\\n\\n    //\\n    // Here's how the 2nd algorithm goes.\\n    // Consider l1 as a node on the 1st list and l2 as the corresponding node on 2nd list.\\n    // Step 1:\\n    // Build the 2nd list by creating a new node for each node in 1st list. \\n    // While doing so, set the next pointer of the new node to the random pointer \\n    // of the corresponding node in the 1st list.  And set the random pointer of the \\n    // 1st list's node to the newly created node.\\n    // Step 2:\\n    // The new head is the node pointed to by the random pointer of the 1st list.\\n    // Step 3:\\n    // Fix the random pointers in the 2nd list: (Remember that l1->random is l2)\\n    // l2->random will be the node in 2nd list that corresponds to the node in the \\n    // 1st list that is pointed to by l2->next, \\n    // Step 4:\\n    // Restore the random pointers of the 1st list and fix the next pointers of the \\n    // 2nd list. random pointer of the node in 1st list is the next pointer of the \\n    // corresponding node in the 2nd list.  This is what we had done in the \\n    // 1st step and now we are reverting back. next pointer of the node in \\n    // 2nd list is the random pointer of the node in 1st list that is pointed to \\n    // by the next pointer of the corresponding node in the 1st list.\\n    // Return the new head that we saved in step 2.\\n    //\\n\\n    RandomListNode *copyRandomList(RandomListNode *head) {\\n        RandomListNode *newHead, *l1, *l2;\\n        if (head == NULL) return NULL;\\n\\n        for (l1 = head; l1 != NULL; l1 = l1->next) {\\n            l2 = new RandomListNode(l1->label);\\n            l2->next = l1->random;\\n            l1->random = l2;\\n        }\\n        \\n        newHead = head->random;\\n        for (l1 = head; l1 != NULL; l1 = l1->next) {\\n            l2 = l1->random;\\n            l2->random = l2->next ? l2->next->random : NULL;\\n        }\\n        \\n        for (l1 = head; l1 != NULL; l1 = l1->next) {\\n            l2 = l1->random;\\n            l1->random = l2->next;\\n            l2->next = l1->next ? l1->next->random : NULL;\\n        }\\n\\n        return newHead;\\n    }",
                "solutionTags": [],
                "code": "    //\\n    // Here's how the 1st algorithm goes.\\n    // Consider l1 as a node on the 1st list and l2 as the corresponding node on 2nd list.\\n    // Step 1:\\n    // Build the 2nd list by creating a new node for each node in 1st list. \\n    // While doing so, insert each new node after it's corresponding node in the 1st list.\\n    // Step 2:\\n    // The new head is the 2nd node as that was the first inserted node.\\n    // Step 3:\\n    // Fix the random pointers in the 2nd list: (Remember that l1->next is actually l2)\\n    // l2->random will be the node in 2nd list that corresponds l1->random, \\n    // which is next node of l1->random.\\n    // Step 4:\\n    // Separate the combined list into 2: Splice out nodes that are part of second list. \\n    // Return the new head that we saved in step 2.\\n    //\\n    \\n    RandomListNode *copyRandomList(RandomListNode *head) {\\n        RandomListNode *newHead, *l1, *l2;\\n        if (head == NULL) return NULL;\\n        for (l1 = head; l1 != NULL; l1 = l1->next->next) {\\n            l2 = new RandomListNode(l1->label);\\n            l2->next = l1->next;\\n            l1->next = l2;\\n        }\\n            \\n        newHead = head->next;\\n        for (l1 = head; l1 != NULL; l1 = l1->next->next) {\\n            if (l1->random != NULL) l1->next->random = l1->random->next;\\n        }\\n            \\n        for (l1 = head; l1 != NULL; l1 = l1->next) {\\n            l2 = l1->next;\\n            l1->next = l2->next;\\n            if (l2->next != NULL) l2->next = l2->next->next;\\n        }\\n    \\n        return newHead;\\n    }\\n\\n\\n    //\\n    // Here's how the 2nd algorithm goes.\\n    // Consider l1 as a node on the 1st list and l2 as the corresponding node on 2nd list.\\n    // Step 1:\\n    // Build the 2nd list by creating a new node for each node in 1st list. \\n    // While doing so, set the next pointer of the new node to the random pointer \\n    // of the corresponding node in the 1st list.  And set the random pointer of the \\n    // 1st list's node to the newly created node.\\n    // Step 2:\\n    // The new head is the node pointed to by the random pointer of the 1st list.\\n    // Step 3:\\n    // Fix the random pointers in the 2nd list: (Remember that l1->random is l2)\\n    // l2->random will be the node in 2nd list that corresponds to the node in the \\n    // 1st list that is pointed to by l2->next, \\n    // Step 4:\\n    // Restore the random pointers of the 1st list and fix the next pointers of the \\n    // 2nd list. random pointer of the node in 1st list is the next pointer of the \\n    // corresponding node in the 2nd list.  This is what we had done in the \\n    // 1st step and now we are reverting back. next pointer of the node in \\n    // 2nd list is the random pointer of the node in 1st list that is pointed to \\n    // by the next pointer of the corresponding node in the 1st list.\\n    // Return the new head that we saved in step 2.\\n    //\\n\\n    RandomListNode *copyRandomList(RandomListNode *head) {\\n        RandomListNode *newHead, *l1, *l2;\\n        if (head == NULL) return NULL;\\n\\n        for (l1 = head; l1 != NULL; l1 = l1->next) {\\n            l2 = new RandomListNode(l1->label);\\n            l2->next = l1->random;\\n            l1->random = l2;\\n        }\\n        \\n        newHead = head->random;\\n        for (l1 = head; l1 != NULL; l1 = l1->next) {\\n            l2 = l1->random;\\n            l2->random = l2->next ? l2->next->random : NULL;\\n        }\\n        \\n        for (l1 = head; l1 != NULL; l1 = l1->next) {\\n            l2 = l1->random;\\n            l1->random = l2->next;\\n            l2->next = l1->next ? l1->next->random : NULL;\\n        }\\n\\n        return newHead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43485,
                "title": "clear-and-short-python-o-2n-and-o-n-solution",
                "content": "    class Solution:\\n    # @param head, a RandomListNode\\n    # @return a RandomListNode\\n    def copyRandomList(self, head):\\n        dic = dict()\\n        m = n = head\\n        while m:\\n            dic[m] = RandomListNode(m.label)\\n            m = m.next\\n        while n:\\n            dic[n].next = dic.get(n.next)\\n            dic[n].random = dic.get(n.random)\\n            n = n.next\\n        return dic.get(head)\\n\\nO(n)\\n\\n    class Solution:\\n    # @param head, a RandomListNode\\n    # @return a RandomListNode\\n    def copyRandomList(self, head):\\n        dic = collections.defaultdict(lambda: RandomListNode(0))\\n        dic[None] = None\\n        n = head\\n        while n:\\n            dic[n].label = n.label\\n            dic[n].next = dic[n.next]\\n            dic[n].random = dic[n.random]\\n            n = n.next\\n        return dic[head]",
                "solutionTags": [],
                "code": "    class Solution:\\n    # @param head, a RandomListNode\\n    # @return a RandomListNode\\n    def copyRandomList(self, head):\\n        dic = dict()\\n        m = n = head\\n        while m:\\n            dic[m] = RandomListNode(m.label)\\n            m = m.next\\n        while n:\\n            dic[n].next = dic.get(n.next)\\n            dic[n].random = dic.get(n.random)\\n            n = n.next\\n        return dic.get(head)\\n\\nO(n)\\n\\n    class Solution:\\n    # @param head, a RandomListNode\\n    # @return a RandomListNode\\n    def copyRandomList(self, head):\\n        dic = collections.defaultdict(lambda: RandomListNode(0))\\n        dic[None] = None\\n        n = head\\n        while n:\\n            dic[n].label = n.label\\n            dic[n].next = dic[n.next]\\n            dic[n].random = dic[n.random]\\n            n = n.next\\n        return dic[head]",
                "codeTag": "Java"
            },
            {
                "id": 1059181,
                "title": "c-three-pass-o-n-0ms-beats-100-explanation-with-example",
                "content": "**EXPLANATION**\\nThe algorithm is divided into 3 steps (**3 passes**) :\\n**Let us assume :**\\n![image](https://assets.leetcode.com/users/images/3ab58991-e753-4052-9a1a-bfb5030e3819_1612961783.2270477.png)\\n\\n**STEP 1: PASS 1** *(Altering the link list)*\\nIterate the given link list and at *each* iteration create a **copy (except random pointer)** of each node and **insert** it just *next to the node it\\'s copied from* as shown below.\\n- If **initially** the link list is like : **A->B->C->D**\\n- Then **after** this step the link list will be : **A->A\\'->B->B\\'->C->C\\'->D->D\\'**\\nwhere **A\\',B\\',C\\',D\\'** nodes are the copy of **A,B,C,D** nodes respectively **except** the **random** pointers.\\n```\\nNode* node=head;\\nwhile(node){\\n\\tNode* temp=node->next;\\n\\tnode->next=new Node(node->val);\\n\\tnode->next->next=temp;\\n\\tnode=temp;\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/726d9160-1c58-4c2b-bbd6-9a61dd427b1f_1612961921.3060675.png)\\n\\n**STEP 2: PASS 2** *(Copying the random pointers)*\\nAgain iterate the link list and **alternatively copy** the *old node\\'s random pointer* (*if exists*) to the *new node\\'s random pointer* as shown below **```node->next->random=node->random->next```**.\\n```\\nnode=head;\\nwhile(node){\\n\\tif(node->random)\\n\\t\\tnode->next->random=node->random->next;\\n\\tnode=node->next->next; // go to next old node\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/0a5299d4-68ee-4746-8b34-85c944454fa1_1612962505.5484135.png)\\n\\n\\n**STEP 3 : (PASS 3)** *(Restoring the old link list)*\\n- Create a **dummy node (here ```ans```)** that will be used to **copy the alternative new nodes** from the link list using ```helper``` node along with **restoring** the *old link list*.\\n- Finally, return ```ans->next``` as **```ans```** currenly points to a dummy node as shown below.\\n```\\nNode* ans=new Node(0); // first node is a dummy node\\nNode* helper=ans;\\n\\nwhile(head){\\n\\t// Copy the alternate added nodes from the old linklist\\n\\thelper->next=head->next;\\n\\thelper=helper->next;\\n\\n\\t// Restoring the old linklist, by removing the alternative newly added nodes\\n\\thead->next=head->next->next;\\n\\thead=head->next; // go to next alternate node   \\n}\\nreturn ans->next; // Since first node is a dummy node\\n```\\n![image](https://assets.leetcode.com/users/images/19d05849-6da1-4272-a575-48f4a7e5dad2_1612963056.7245958.png)\\n\\n\\n**COMPLETE CODE**\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        \\n        // STEP 1: PASS 1\\n        // Creating a copy (except random pointer) of each old node and insert it next to the old node it\\'s copied from.\\n        // That is, it will create new alternative nodes which are a copy (except random pointer) of its previous node.\\n        Node* node=head;\\n        while(node){\\n            Node* temp=node->next;\\n            node->next=new Node(node->val);\\n            node->next->next=temp;\\n            node=temp;\\n        }\\n        \\n        // STEP 2: PASS 2\\n        // Now copy the random pointer (if exists) of the old nodes to their copy new nodes.\\n        node=head;\\n        while(node){\\n            if(node->random)\\n                node->next->random=node->random->next;\\n            node=node->next->next; // go to next old node\\n        }\\n        \\n        //STEP 3: PASS 3\\n        // Copy the alternative nodes into \"ans\" link list using the \"helper\" pointer along with restoring the old link list.\\n        Node* ans=new Node(0); // first node is a dummy node\\n        Node* helper=ans;\\n    \\n        while(head){\\n            // Copy the alternate added nodes from the old linklist\\n            helper->next=head->next;\\n            helper=helper->next;\\n            \\n            // Restoring the old linklist, by removing the alternative newly added nodes\\n            head->next=head->next->next;\\n            head=head->next; // go to next alternate node   \\n        }\\n        return ans->next; // Since first node is a dummy node\\n    }\\n};\\n```\\n\\n**TIME COMPLEXITY**\\n**O(n+n+n)=O(n)** [ *Each step (pass) takes O(n) time* }\\n\\n**SPACE COMPLEXITY**\\n**O(1)**",
                "solutionTags": [],
                "code": "```\\nNode* node=head;\\nwhile(node){\\n\\tNode* temp=node->next;\\n\\tnode->next=new Node(node->val);\\n\\tnode->next->next=temp;\\n\\tnode=temp;\\n}\\n```\n```node->next->random=node->random->next```\n```\\nnode=head;\\nwhile(node){\\n\\tif(node->random)\\n\\t\\tnode->next->random=node->random->next;\\n\\tnode=node->next->next; // go to next old node\\n}\\n```\n```ans```\n```helper```\n```ans->next```\n```ans```\n```\\nNode* ans=new Node(0); // first node is a dummy node\\nNode* helper=ans;\\n\\nwhile(head){\\n\\t// Copy the alternate added nodes from the old linklist\\n\\thelper->next=head->next;\\n\\thelper=helper->next;\\n\\n\\t// Restoring the old linklist, by removing the alternative newly added nodes\\n\\thead->next=head->next->next;\\n\\thead=head->next; // go to next alternate node   \\n}\\nreturn ans->next; // Since first node is a dummy node\\n```\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        \\n        // STEP 1: PASS 1\\n        // Creating a copy (except random pointer) of each old node and insert it next to the old node it\\'s copied from.\\n        // That is, it will create new alternative nodes which are a copy (except random pointer) of its previous node.\\n        Node* node=head;\\n        while(node){\\n            Node* temp=node->next;\\n            node->next=new Node(node->val);\\n            node->next->next=temp;\\n            node=temp;\\n        }\\n        \\n        // STEP 2: PASS 2\\n        // Now copy the random pointer (if exists) of the old nodes to their copy new nodes.\\n        node=head;\\n        while(node){\\n            if(node->random)\\n                node->next->random=node->random->next;\\n            node=node->next->next; // go to next old node\\n        }\\n        \\n        //STEP 3: PASS 3\\n        // Copy the alternative nodes into \"ans\" link list using the \"helper\" pointer along with restoring the old link list.\\n        Node* ans=new Node(0); // first node is a dummy node\\n        Node* helper=ans;\\n    \\n        while(head){\\n            // Copy the alternate added nodes from the old linklist\\n            helper->next=head->next;\\n            helper=helper->next;\\n            \\n            // Restoring the old linklist, by removing the alternative newly added nodes\\n            head->next=head->next->next;\\n            head=head->next; // go to next alternate node   \\n        }\\n        return ans->next; // Since first node is a dummy node\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258935,
                "title": "detailed-explanation-with-pictures-c-javascript",
                "content": "**Intuition**\\n* First, how do we clone a **Normal** linked list? (i.e, a linked list with no **Random** field). One easy way is to iterate the list and create the nodes on the fly. \\n* This is exactly **Step 1** of the algorithm. We clone the linked list while not caring about the random pointers (setting it to **Null**).\\n* Now, suppose that you have a rope that takes you from any node in the original list to its counterpart in the cloned list. (This is demonstrated by the vertical lines in the picture). How do we actually correct the **random** pointers using this rope? Well, one easy way is to traverse both the lists simultaneously, get the **random** field of the top node, use it reach the location of the **random pointer** (in the top node) and then use the rope to get down vertically, This would be the **random node** for the cloned counterpart.\\n* All that remains is to create the ropes. This can be easily done via **HashMap**. The key is the *address* of the top nodes while the value is the *address* of its copy. The map can be populated while creating the list. \\n* **Remark** ---- *Node* to *Node* hashing is necessary to deal with duplicates. (As can be seen with **2** in the picture).\\n\\n---\\n\\n**Example**\\n\\n![image](https://assets.leetcode.com/users/just__a__visitor/image_1553084036.png)\\n\\n* First, the nodes are cloned with randome pointers set to **Null**. Meanwhile, the virtual ropes are created via hashmap.\\n* Let us say we want to poulate the random field of **1**. We first traverse to **3** (top) and then go down to **3** (bot) and set the random field for the bottom 1.\\n---\\n**Terminology**\\n * `originalHead` represents the head of the original_head. It is never modified.\\n * `clonedHead` represents the head of the cloned linked list. It is never altered once set.\\n * `oldHead` represents a reference to the the head of the original linked list.\\n     It is used for traversing the original list (and hence mutable).\\n * `newHead` represents a reference to the head of the cloned linked list.\\n     It is used for traversing the cloned linked list (and hence mutable).\\n---\\n\\n**Miscellaneous**\\nThe above method handles duplicates but does not handle *Loops* in the linked list. (As it would lead to infinite loop while cloning the lined list). However, this can be easily remedied by using a map and checking whether we have reached the same node twice or not (instead of checking for **null**) which would ensure that the cloning process terminates.\\n\\n**Improving the Space Complexity**\\nThe space compelxity can be further reduced to O(1). You can see my blog post [here](https://leetcode.com/problems/copy-list-with-random-pointer/discuss/259563/Detailed-Explanation-Constant-Space-C%2B%2BJavaScript)\\n\\n```\\nclass Solution\\n{\\npublic:\\n    Node* copyRandomList(Node* orig_head);\\n};\\n\\n/* Deep copies the linked list (along with random pointers) */\\nNode* Solution :: copyRandomList(Node* originalHead)\\n{\\n    // Handle the corner case\\n    if(!originalHead) return originalHead;\\n    \\n    // Create the head of the cloned linked list and store its reference permanently\\n    Node* clonedHead = new Node(originalHead->val, nullptr, nullptr);\\n    \\n    // Create iterators for both the linked lists\\n    Node* newHead = clonedHead;\\n    Node* oldHead = originalHead;\\n    \\n    // Create a map which facilitates going vertically down from the original to cloned node\\n    unordered_map<Node*, Node*> nodeJustBelow;\\n    \\n    /* Node to Node mapping is compulsory to deal with duplicates in the linked list */\\n    \\n    // Link the nodes vertically\\n    nodeJustBelow[oldHead] = newHead;\\n    \\n    // Check whether the next node exists or not\\n    while(oldHead->next)\\n    {\\n        // First, create the next node in the cloned list.\\n        newHead->next = new Node(oldHead->next->val, nullptr, nullptr);\\n        \\n        // After the node has been created, step on it by the new thread\\n        newHead = newHead->next;\\n        oldHead = oldHead->next;\\n        \\n        // After you\\'ve moved to the newly created node, connect it vertically\\n        nodeJustBelow[oldHead] = newHead;\\n    }\\n    \\n    /* The linked list has been cloned correctly (except the random pointers) */\\n\\n    // Traverse both the lists together and fill the random pointers\\n    oldHead = originalHead;\\n    newHead = clonedHead;\\n    \\n    // As long as both the lists exist, correct the random pointers\\n    while(oldHead && newHead)\\n    {\\n        // Traverse the random pointer of the original list and go down vertically and connect it\\n        newHead->random = oldHead->random? nodeJustBelow[oldHead->random] : nullptr;\\n        \\n        // Move forward in both the lists\\n        oldHead = oldHead->next;\\n        newHead = newHead->next;\\n    }\\n    \\n    // Return the stored reference of the cloned list\\n    return clonedHead;\\n}\\n```\\n\\nSorry, I didn\\'t mean to extend it so long, but I hope you understand the concept and its working.",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    Node* copyRandomList(Node* orig_head);\\n};\\n\\n/* Deep copies the linked list (along with random pointers) */\\nNode* Solution :: copyRandomList(Node* originalHead)\\n{\\n    // Handle the corner case\\n    if(!originalHead) return originalHead;\\n    \\n    // Create the head of the cloned linked list and store its reference permanently\\n    Node* clonedHead = new Node(originalHead->val, nullptr, nullptr);\\n    \\n    // Create iterators for both the linked lists\\n    Node* newHead = clonedHead;\\n    Node* oldHead = originalHead;\\n    \\n    // Create a map which facilitates going vertically down from the original to cloned node\\n    unordered_map<Node*, Node*> nodeJustBelow;\\n    \\n    /* Node to Node mapping is compulsory to deal with duplicates in the linked list */\\n    \\n    // Link the nodes vertically\\n    nodeJustBelow[oldHead] = newHead;\\n    \\n    // Check whether the next node exists or not\\n    while(oldHead->next)\\n    {\\n        // First, create the next node in the cloned list.\\n        newHead->next = new Node(oldHead->next->val, nullptr, nullptr);\\n        \\n        // After the node has been created, step on it by the new thread\\n        newHead = newHead->next;\\n        oldHead = oldHead->next;\\n        \\n        // After you\\'ve moved to the newly created node, connect it vertically\\n        nodeJustBelow[oldHead] = newHead;\\n    }\\n    \\n    /* The linked list has been cloned correctly (except the random pointers) */\\n\\n    // Traverse both the lists together and fill the random pointers\\n    oldHead = originalHead;\\n    newHead = clonedHead;\\n    \\n    // As long as both the lists exist, correct the random pointers\\n    while(oldHead && newHead)\\n    {\\n        // Traverse the random pointer of the original list and go down vertically and connect it\\n        newHead->random = oldHead->random? nodeJustBelow[oldHead->random] : nullptr;\\n        \\n        // Move forward in both the lists\\n        oldHead = oldHead->next;\\n        newHead = newHead->next;\\n    }\\n    \\n    // Return the stored reference of the cloned list\\n    return clonedHead;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003262,
                "title": "97-92-hash-table-linked-list",
                "content": "# Interview Guide - Copying a Linked List with Random Pointers: A Dual-Approach Analysis\\n\\n## Introduction & Problem Understanding\\n\\nThe problem at hand involves creating a deep copy of a given singly-linked list where each node has a `next` pointer and an additional `random` pointer. The `random` pointer could point to any node within the list or be `null`. The deep copy should have brand new nodes with the same `next` and `random` pointers as the original list.\\n\\n### Key Concepts and Constraints\\n\\n1. **Node Anatomy**:  \\n   Each node in the list has an integer value, a `next` pointer pointing to the subsequent node, and a `random` pointer that could point to any node in the list or be `null`.\\n\\n2. **Deep Copy**:  \\n   We are required to return a deep copy of the list, meaning that the new list should consist of entirely new nodes that don\\'t refer to nodes in the original list.\\n\\n3. **Memory Efficiency**:  \\n   While one approach uses $$ O(n) $$ additional memory, the other achieves the task without extra memory, using only $$ O(1) $$ extra space.\\n\\n## Strategies to Tackle the Problem\\n\\n1. **Hash Map Method**:  \\n   This approach leverages a hash map to store the mapping between each node in the original list and its corresponding node in the copied list.\\n\\n2. **Interweaving Nodes Method**:  \\n   This approach cleverly interweaves the nodes of the copied list with the original list, using the structure to adjust the `random` pointers correctly, and then separates them.\\n\\n---\\n\\n# Live Coding Hash & More:\\nhttps://youtu.be/eplAWtfkz5o?si=6OwomT_z5ClgyhUc\\n\\n## Solution #1: Hash Map Method\\n\\n### Intuition and Logic Behind the Solution\\n\\nThe basic idea is to traverse the list twice. In the first pass, we create a new node for each node in the original list and store the mapping in a hash map. In the second pass, we set the `next` and `random` pointers for each new node based on the hash map.\\n\\n### Step-by-step Explanation\\n\\n1. **Initialization**: \\n    - Create an empty hash map, `old_to_new`, to store the mapping from old nodes to new nodes.\\n\\n2. **First Pass - Node Creation**:  \\n    - Traverse the original list and for each node, create a corresponding new node.\\n    - Store the mapping in `old_to_new`.\\n\\n3. **Second Pass - Setting Pointers**:  \\n    - Traverse the original list again.\\n    - For each node, set its corresponding new node\\'s `next` and `random` pointers based on the hash map.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: $$ O(n) $$ \\u2014 Each node is visited twice.\\n- **Space Complexity**: $$ O(n) $$ \\u2014 To store the hash map.\\n\\n---\\n\\n## Solution #2: Interweaving Nodes Method\\n\\n### Intuition and Logic Behind the Solution\\n\\nThe crux of this method is to interweave the nodes of the original and copied lists. This interweaving allows us to set the `random` pointers for the new nodes without needing additional memory for mapping.\\n\\n### Step-by-step Explanation\\n\\n1. **Initialization and Interweaving**:  \\n    - Traverse the original list.\\n    - For each node, create a corresponding new node and place it between the current node and the current node\\'s `next`.\\n\\n2. **Setting Random Pointers**:  \\n    - Traverse the interweaved list.\\n    - For each old node, set its corresponding new node\\'s `random` pointer.\\n\\n3. **Separating Lists**:  \\n    - Traverse the interweaved list again to separate the old and new lists.\\n\\n### Complexity Analysis\\n\\n- **Time Complexity**: $$ O(n) $$ \\u2014 Each node is visited multiple times but it\\'s still linear time.\\n- **Space Complexity**: $$ O(1) $$ \\u2014 No additional memory is used for mapping; we only allocate nodes for the new list.\\n\\nBoth methods provide a deep copy of the original list but differ in their use of additional memory. The choice between them would depend on the specific requirements of your application.\\n\\n# Performance\\n\\n| Language  | Time (ms) | Memory (MB) |\\n|-----------|-----------|-------------|\\n| Java      | 0 ms      | 44 MB       |\\n| Go        | 3 ms      | 3.5 MB      |\\n| C++       | 8 ms      | 11.3 MB     | \\n| Python3 (Hash)   | 33 ms     | 17.3 MB     |\\n| JavaScript| 34 ms     | 43.8 MB     | \\n| Python3 (Inter)   | 39 ms     | 17.3 MB     |\\n| C#        | 87 ms     | 39.9 MB     | \\n\\n![v5.png](https://assets.leetcode.com/users/images/29feaf30-0f7c-456b-ad97-77e59b7778a5_1693880496.8172286.png)\\n\\n\\n# Code #1 Hash Map\\n``` Python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n        old_to_new = {}\\n        \\n        curr = head\\n        while curr:\\n            old_to_new[curr] = Node(curr.val)\\n            curr = curr.next\\n        \\n        curr = head\\n        while curr:\\n            old_to_new[curr].next = old_to_new.get(curr.next)\\n            old_to_new[curr].random = old_to_new.get(curr.random)\\n            curr = curr.next\\n            \\n        return old_to_new[head]\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) return nullptr;\\n        \\n        unordered_map<Node*, Node*> old_to_new;\\n        \\n        Node* curr = head;\\n        while (curr) {\\n            old_to_new[curr] = new Node(curr->val);\\n            curr = curr->next;\\n        }\\n        \\n        curr = head;\\n        while (curr) {\\n            old_to_new[curr]->next = old_to_new[curr->next];\\n            old_to_new[curr]->random = old_to_new[curr->random];\\n            curr = curr->next;\\n        }\\n        \\n        return old_to_new[head];\\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null) return null;\\n        \\n        HashMap<Node, Node> oldToNew = new HashMap<>();\\n        \\n        Node curr = head;\\n        while (curr != null) {\\n            oldToNew.put(curr, new Node(curr.val));\\n            curr = curr.next;\\n        }\\n        \\n        curr = head;\\n        while (curr != null) {\\n            oldToNew.get(curr).next = oldToNew.get(curr.next);\\n            oldToNew.get(curr).random = oldToNew.get(curr.random);\\n            curr = curr.next;\\n        }\\n        \\n        return oldToNew.get(head);\\n    }\\n}\\n```\\n``` JavaScript []\\n/**\\n * @param {Node} head\\n * @return {Node}\\n */\\nvar copyRandomList = function(head) {\\n    if (!head) return null;\\n    \\n    const oldToNew = new Map();\\n    \\n    let curr = head;\\n    while (curr) {\\n        oldToNew.set(curr, new Node(curr.val));\\n        curr = curr.next;\\n    }\\n    \\n    curr = head;\\n    while (curr) {\\n        oldToNew.get(curr).next = oldToNew.get(curr.next) || null;\\n        oldToNew.get(curr).random = oldToNew.get(curr.random) || null;\\n        curr = curr.next;\\n    }\\n    \\n    return oldToNew.get(head);\\n};\\n```\\n``` C# []\\npublic class Solution {\\n    public Node CopyRandomList(Node head) {\\n        if (head == null) return null;\\n        \\n        Dictionary<Node, Node> oldToNew = new Dictionary<Node, Node>();\\n        \\n        Node curr = head;\\n        while (curr != null) {\\n            oldToNew[curr] = new Node(curr.val);\\n            curr = curr.next;\\n        }\\n        \\n        curr = head;\\n        while (curr != null) {\\n            oldToNew[curr].next = curr.next != null ? oldToNew[curr.next] : null;\\n            oldToNew[curr].random = curr.random != null ? oldToNew[curr.random] : null;\\n            curr = curr.next;\\n        }\\n        \\n        return oldToNew[head];\\n    }\\n}\\n```\\n``` Go []\\nfunc copyRandomList(head *Node) *Node {\\n    if head == nil {\\n        return nil\\n    }\\n\\n    oldToNew := make(map[*Node]*Node)\\n\\n    curr := head\\n    for curr != nil {\\n        oldToNew[curr] = &Node{Val: curr.Val}\\n        curr = curr.Next\\n    }\\n\\n    curr = head\\n    for curr != nil {\\n        oldToNew[curr].Next = oldToNew[curr.Next]\\n        oldToNew[curr].Random = oldToNew[curr.Random]\\n        curr = curr.Next\\n    }\\n\\n    return oldToNew[head]\\n}\\n```\\n\\n# Code #2 Interweaving Nodes\\n``` Python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n        \\n        curr = head\\n        while curr:\\n            new_node = Node(curr.val, curr.next)\\n            curr.next = new_node\\n            curr = new_node.next\\n            \\n        curr = head\\n        while curr:\\n            if curr.random:\\n                curr.next.random = curr.random.next\\n            curr = curr.next.next\\n        \\n        old_head = head\\n        new_head = head.next\\n        curr_old = old_head\\n        curr_new = new_head\\n        \\n        while curr_old:\\n            curr_old.next = curr_old.next.next\\n            curr_new.next = curr_new.next.next if curr_new.next else None\\n            curr_old = curr_old.next\\n            curr_new = curr_new.next\\n            \\n        return new_head\\n```\\n``` Go []\\nfunc copyRandomList(head *Node) *Node {\\n        if head == nil {\\n        return nil\\n    }\\n    \\n    curr := head\\n    for curr != nil {\\n        new_node := &Node{Val: curr.Val, Next: curr.Next}\\n        curr.Next = new_node\\n        curr = new_node.Next\\n    }\\n    \\n    curr = head\\n    for curr != nil {\\n        if curr.Random != nil {\\n            curr.Next.Random = curr.Random.Next\\n        }\\n        curr = curr.Next.Next\\n    }\\n    \\n    old_head := head\\n    new_head := head.Next\\n    curr_old := old_head\\n    curr_new := new_head\\n    \\n    for curr_old != nil {\\n        curr_old.Next = curr_old.Next.Next\\n        if curr_new.Next != nil {\\n            curr_new.Next = curr_new.Next.Next\\n        } else {\\n            curr_new.Next = nil\\n        }\\n        curr_old = curr_old.Next\\n        curr_new = curr_new.Next\\n    }\\n    \\n    return new_head\\n}\\n```\\n``` C++ []\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n                if (!head) return nullptr;\\n        \\n        Node* curr = head;\\n        while (curr) {\\n            Node* new_node = new Node(curr->val);\\n            new_node->next = curr->next;\\n            curr->next = new_node;\\n            curr = new_node->next;\\n        }\\n        \\n        curr = head;\\n        while (curr) {\\n            if (curr->random) {\\n                curr->next->random = curr->random->next;\\n            }\\n            curr = curr->next->next;\\n        }\\n        \\n        Node* old_head = head;\\n        Node* new_head = head->next;\\n        Node* curr_old = old_head;\\n        Node* curr_new = new_head;\\n        \\n        while (curr_old) {\\n            curr_old->next = curr_old->next->next;\\n            curr_new->next = curr_new->next ? curr_new->next->next : nullptr;\\n            curr_old = curr_old->next;\\n            curr_new = curr_new->next;\\n        }\\n        \\n        return new_head;       \\n    }\\n};\\n```\\n``` Java []\\npublic class Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null) return null;\\n        \\n        Node curr = head;\\n        while (curr != null) {\\n            Node new_node = new Node(curr.val, curr.next);\\n            curr.next = new_node;\\n            curr = new_node.next;\\n        }\\n        \\n        curr = head;\\n        while (curr != null) {\\n            if (curr.random != null) {\\n                curr.next.random = curr.random.next;\\n            }\\n            curr = curr.next != null ? curr.next.next : null;\\n        }\\n        \\n        Node old_head = head;\\n        Node new_head = head.next;\\n        Node curr_old = old_head;\\n        Node curr_new = new_head;\\n        \\n        while (curr_old != null) {\\n            curr_old.next = curr_old.next.next;\\n            curr_new.next = curr_new.next != null ? curr_new.next.next : null;\\n            curr_old = curr_old.next;\\n            curr_new = curr_new.next;\\n        }\\n        \\n        return new_head;\\n    }\\n}\\n```\\n\\n# Live Coding Interweaving & More\\nhttps://youtu.be/DH0HDU4ScYY?si=P-P1Er3P8q5XekTU\\n\\n### Reflections on Copying Lists with Random Pointers\\n\\n#### Hash Map Method:\\nClear and simple, this method uses extra memory to map each node from the original to the copied list. It\\'s straightforward but can be memory-inefficient.\\n\\n#### Interweaving Nodes Method:\\nSleek and space-efficient, this in-place method interweaves new nodes within the existing structure before making them their own list. It\\'s elegant but requires careful attention.\\n\\nThis problem isn\\'t just coding; it\\'s a deep dive into data structures and algorithms. Whether you prefer the clarity of Hash Map or the finesse of Interweaving Nodes, each sharpens your algorithmic skill set. Embrace the challenge! \\uD83C\\uDF1F\\uD83D\\uDE80\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C#",
                    "JavaScript",
                    "Go",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "``` Python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n        old_to_new = {}\\n        \\n        curr = head\\n        while curr:\\n            old_to_new[curr] = Node(curr.val)\\n            curr = curr.next\\n        \\n        curr = head\\n        while curr:\\n            old_to_new[curr].next = old_to_new.get(curr.next)\\n            old_to_new[curr].random = old_to_new.get(curr.random)\\n            curr = curr.next\\n            \\n        return old_to_new[head]\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) return nullptr;\\n        \\n        unordered_map<Node*, Node*> old_to_new;\\n        \\n        Node* curr = head;\\n        while (curr) {\\n            old_to_new[curr] = new Node(curr->val);\\n            curr = curr->next;\\n        }\\n        \\n        curr = head;\\n        while (curr) {\\n            old_to_new[curr]->next = old_to_new[curr->next];\\n            old_to_new[curr]->random = old_to_new[curr->random];\\n            curr = curr->next;\\n        }\\n        \\n        return old_to_new[head];\\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null) return null;\\n        \\n        HashMap<Node, Node> oldToNew = new HashMap<>();\\n        \\n        Node curr = head;\\n        while (curr != null) {\\n            oldToNew.put(curr, new Node(curr.val));\\n            curr = curr.next;\\n        }\\n        \\n        curr = head;\\n        while (curr != null) {\\n            oldToNew.get(curr).next = oldToNew.get(curr.next);\\n            oldToNew.get(curr).random = oldToNew.get(curr.random);\\n            curr = curr.next;\\n        }\\n        \\n        return oldToNew.get(head);\\n    }\\n}\\n```\n``` JavaScript []\\n/**\\n * @param {Node} head\\n * @return {Node}\\n */\\nvar copyRandomList = function(head) {\\n    if (!head) return null;\\n    \\n    const oldToNew = new Map();\\n    \\n    let curr = head;\\n    while (curr) {\\n        oldToNew.set(curr, new Node(curr.val));\\n        curr = curr.next;\\n    }\\n    \\n    curr = head;\\n    while (curr) {\\n        oldToNew.get(curr).next = oldToNew.get(curr.next) || null;\\n        oldToNew.get(curr).random = oldToNew.get(curr.random) || null;\\n        curr = curr.next;\\n    }\\n    \\n    return oldToNew.get(head);\\n};\\n```\n``` C# []\\npublic class Solution {\\n    public Node CopyRandomList(Node head) {\\n        if (head == null) return null;\\n        \\n        Dictionary<Node, Node> oldToNew = new Dictionary<Node, Node>();\\n        \\n        Node curr = head;\\n        while (curr != null) {\\n            oldToNew[curr] = new Node(curr.val);\\n            curr = curr.next;\\n        }\\n        \\n        curr = head;\\n        while (curr != null) {\\n            oldToNew[curr].next = curr.next != null ? oldToNew[curr.next] : null;\\n            oldToNew[curr].random = curr.random != null ? oldToNew[curr.random] : null;\\n            curr = curr.next;\\n        }\\n        \\n        return oldToNew[head];\\n    }\\n}\\n```\n``` Go []\\nfunc copyRandomList(head *Node) *Node {\\n    if head == nil {\\n        return nil\\n    }\\n\\n    oldToNew := make(map[*Node]*Node)\\n\\n    curr := head\\n    for curr != nil {\\n        oldToNew[curr] = &Node{Val: curr.Val}\\n        curr = curr.Next\\n    }\\n\\n    curr = head\\n    for curr != nil {\\n        oldToNew[curr].Next = oldToNew[curr.Next]\\n        oldToNew[curr].Random = oldToNew[curr.Random]\\n        curr = curr.Next\\n    }\\n\\n    return oldToNew[head]\\n}\\n```\n``` Python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n        \\n        curr = head\\n        while curr:\\n            new_node = Node(curr.val, curr.next)\\n            curr.next = new_node\\n            curr = new_node.next\\n            \\n        curr = head\\n        while curr:\\n            if curr.random:\\n                curr.next.random = curr.random.next\\n            curr = curr.next.next\\n        \\n        old_head = head\\n        new_head = head.next\\n        curr_old = old_head\\n        curr_new = new_head\\n        \\n        while curr_old:\\n            curr_old.next = curr_old.next.next\\n            curr_new.next = curr_new.next.next if curr_new.next else None\\n            curr_old = curr_old.next\\n            curr_new = curr_new.next\\n            \\n        return new_head\\n```\n``` Go []\\nfunc copyRandomList(head *Node) *Node {\\n        if head == nil {\\n        return nil\\n    }\\n    \\n    curr := head\\n    for curr != nil {\\n        new_node := &Node{Val: curr.Val, Next: curr.Next}\\n        curr.Next = new_node\\n        curr = new_node.Next\\n    }\\n    \\n    curr = head\\n    for curr != nil {\\n        if curr.Random != nil {\\n            curr.Next.Random = curr.Random.Next\\n        }\\n        curr = curr.Next.Next\\n    }\\n    \\n    old_head := head\\n    new_head := head.Next\\n    curr_old := old_head\\n    curr_new := new_head\\n    \\n    for curr_old != nil {\\n        curr_old.Next = curr_old.Next.Next\\n        if curr_new.Next != nil {\\n            curr_new.Next = curr_new.Next.Next\\n        } else {\\n            curr_new.Next = nil\\n        }\\n        curr_old = curr_old.Next\\n        curr_new = curr_new.Next\\n    }\\n    \\n    return new_head\\n}\\n```\n``` C++ []\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n                if (!head) return nullptr;\\n        \\n        Node* curr = head;\\n        while (curr) {\\n            Node* new_node = new Node(curr->val);\\n            new_node->next = curr->next;\\n            curr->next = new_node;\\n            curr = new_node->next;\\n        }\\n        \\n        curr = head;\\n        while (curr) {\\n            if (curr->random) {\\n                curr->next->random = curr->random->next;\\n            }\\n            curr = curr->next->next;\\n        }\\n        \\n        Node* old_head = head;\\n        Node* new_head = head->next;\\n        Node* curr_old = old_head;\\n        Node* curr_new = new_head;\\n        \\n        while (curr_old) {\\n            curr_old->next = curr_old->next->next;\\n            curr_new->next = curr_new->next ? curr_new->next->next : nullptr;\\n            curr_old = curr_old->next;\\n            curr_new = curr_new->next;\\n        }\\n        \\n        return new_head;       \\n    }\\n};\\n```\n``` Java []\\npublic class Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null) return null;\\n        \\n        Node curr = head;\\n        while (curr != null) {\\n            Node new_node = new Node(curr.val, curr.next);\\n            curr.next = new_node;\\n            curr = new_node.next;\\n        }\\n        \\n        curr = head;\\n        while (curr != null) {\\n            if (curr.random != null) {\\n                curr.next.random = curr.random.next;\\n            }\\n            curr = curr.next != null ? curr.next.next : null;\\n        }\\n        \\n        Node old_head = head;\\n        Node new_head = head.next;\\n        Node curr_old = old_head;\\n        Node curr_new = new_head;\\n        \\n        while (curr_old != null) {\\n            curr_old.next = curr_old.next.next;\\n            curr_new.next = curr_new.next != null ? curr_new.next.next : null;\\n            curr_old = curr_old.next;\\n            curr_new = curr_new.next;\\n        }\\n        \\n        return new_head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43689,
                "title": "python-easy-to-understand-solutions",
                "content": "```\\ndef copyRandomList1(self, head):\\n        if not head:\\n            return \\n        # copy nodes\\n        cur = head\\n        while cur:\\n            nxt = cur.next\\n            cur.next = RandomListNode(cur.label)\\n            cur.next.next = nxt\\n            cur = nxt\\n        # copy random pointers\\n        cur = head\\n        while cur:\\n            if cur.random:\\n                cur.next.random = cur.random.next\\n            cur = cur.next.next\\n        # separate two parts\\n        second = cur = head.next\\n        while cur.next:\\n            head.next = cur.next\\n            head = head.next\\n            cur.next = head.next\\n            cur = cur.next\\n        head.next = None\\n        return second\\n    \\n    # using dictionary    \\n    def copyRandomList(self, head):\\n        if not head:\\n            return \\n        cur, dic = head, {}\\n        # copy nodes\\n        while cur:\\n            dic[cur] = RandomListNode(cur.label)\\n            cur = cur.next\\n        cur = head\\n        # copy random pointers\\n        while cur:\\n            if cur.random:\\n                dic[cur].random = dic[cur.random]\\n            if cur.next:\\n                dic[cur].next = dic[cur.next]\\n            cur = cur.next\\n        return dic[head]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef copyRandomList1(self, head):\\n        if not head:\\n            return \\n        # copy nodes\\n        cur = head\\n        while cur:\\n            nxt = cur.next\\n            cur.next = RandomListNode(cur.label)\\n            cur.next.next = nxt\\n            cur = nxt\\n        # copy random pointers\\n        cur = head\\n        while cur:\\n            if cur.random:\\n                cur.next.random = cur.random.next\\n            cur = cur.next.next\\n        # separate two parts\\n        second = cur = head.next\\n        while cur.next:\\n            head.next = cur.next\\n            head = head.next\\n            cur.next = head.next\\n            cur = cur.next\\n        head.next = None\\n        return second\\n    \\n    # using dictionary    \\n    def copyRandomList(self, head):\\n        if not head:\\n            return \\n        cur, dic = head, {}\\n        # copy nodes\\n        while cur:\\n            dic[cur] = RandomListNode(cur.label)\\n            cur = cur.next\\n        cur = head\\n        # copy random pointers\\n        while cur:\\n            if cur.random:\\n                dic[cur].random = dic[cur.random]\\n            if cur.next:\\n                dic[cur].next = dic[cur.next]\\n            cur = cur.next\\n        return dic[head]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 43496,
                "title": "o-n-time-o-1-space-c",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node * head_cp = nullptr, * cur = head, * cur_cp = nullptr;\\n        if (head == nullptr)\\n            return nullptr;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = new Node(cur->val, cur->next, nullptr);\\n            cur->next = cur_cp;\\n            cur = cur_cp->next;\\n        }\\n        cur = head;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = cur->next;\\n            if (cur->random)\\n                cur_cp->random = cur->random->next;\\n            cur = cur_cp ->next;\\n        }\\n        cur = head;\\n        head_cp = head->next;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = cur->next;\\n            cur->next = cur_cp->next;\\n            cur = cur->next;\\n            if (cur)\\n                cur_cp->next = cur->next;\\n        }\\n        return head_cp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node * head_cp = nullptr, * cur = head, * cur_cp = nullptr;\\n        if (head == nullptr)\\n            return nullptr;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = new Node(cur->val, cur->next, nullptr);\\n            cur->next = cur_cp;\\n            cur = cur_cp->next;\\n        }\\n        cur = head;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = cur->next;\\n            if (cur->random)\\n                cur_cp->random = cur->random->next;\\n            cur = cur_cp ->next;\\n        }\\n        cur = head;\\n        head_cp = head->next;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = cur->next;\\n            cur->next = cur_cp->next;\\n            cur = cur->next;\\n            if (cur)\\n                cur_cp->next = cur->next;\\n        }\\n        return head_cp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43484,
                "title": "c-6-lines-recursive-solution-using-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<RandomListNode*, RandomListNode*>mp;\\n    RandomListNode *copyRandomList(RandomListNode *head) \\n    {\\n        if(!head) return NULL;\\n        if(mp[head]!=NULL) return mp[head];\\n        mp[head] = new RandomListNode(head->label);\\n        mp[head] -> next = copyRandomList(head->next);\\n        mp[head] -> random = copyRandomList(head->random);\\n        return mp[head];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    unordered_map<RandomListNode*, RandomListNode*>mp;\\n    RandomListNode *copyRandomList(RandomListNode *head) \\n    {\\n        if(!head) return NULL;\\n        if(mp[head]!=NULL) return mp[head];\\n        mp[head] = new RandomListNode(head->label);\\n        mp[head] -> next = copyRandomList(head->next);\\n        mp[head] -> random = copyRandomList(head->random);\\n        return mp[head];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 373694,
                "title": "python3-dictionary",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, next, random):\\n        self.val = val\\n        self.next = next\\n        self.random = random\\n\"\"\"\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if head is None: return None\\n        mapping = {}\\n        cur = head\\n        while cur:\\n            mapping[cur] = Node(cur.val,None,None)\\n            cur = cur.next\\n        cur = head\\n        while cur:\\n            if cur.next:\\n                mapping[cur].next = mapping[cur.next]\\n            if cur.random:\\n                mapping[cur].random = mapping[cur.random]\\n            cur = cur.next\\n        return mapping[head]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, val, next, random):\\n        self.val = val\\n        self.next = next\\n        self.random = random\\n\"\"\"\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if head is None: return None\\n        mapping = {}\\n        cur = head\\n        while cur:\\n            mapping[cur] = Node(cur.val,None,None)\\n            cur = cur.next\\n        cur = head\\n        while cur:\\n            if cur.next:\\n                mapping[cur].next = mapping[cur.next]\\n            if cur.random:\\n                mapping[cur].random = mapping[cur.random]\\n            cur = cur.next\\n        return mapping[head]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379056,
                "title": "python-solution-with-comments-o-n-using-a-dictionary",
                "content": "```\\nclass Solution(object):\\n    \"\"\"\\n    \"\"\"\\n    def copyRandomList(self, head):\\n        dic, prev, node = {}, None, head\\n        while node:\\n            if node not in dic:\\n                # Use a dictionary to map the original node to its copy\\n                dic[node] = Node(node.val, node.next, node.random)\\n            if prev:\\n                # Make the previous node point to the copy instead of the original.\\n                prev.next = dic[node]\\n            else:\\n                # If there is no prev, then we are at the head. Store it to return later.\\n                head = dic[node]\\n            if node.random:\\n                if node.random not in dic:\\n                    # If node.random points to a node that we have not yet encountered, store it in the dictionary.\\n                    dic[node.random] = Node(node.random.val, node.random.next, node.random.random)\\n                # Make the copy\\'s random property point to the copy instead of the original.\\n                dic[node].random = dic[node.random]\\n            # Store prev and advance to the next node.\\n            prev, node = dic[node], node.next\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    \"\"\"\\n    \"\"\"\\n    def copyRandomList(self, head):\\n        dic, prev, node = {}, None, head\\n        while node:\\n            if node not in dic:\\n                # Use a dictionary to map the original node to its copy\\n                dic[node] = Node(node.val, node.next, node.random)\\n            if prev:\\n                # Make the previous node point to the copy instead of the original.\\n                prev.next = dic[node]\\n            else:\\n                # If there is no prev, then we are at the head. Store it to return later.\\n                head = dic[node]\\n            if node.random:\\n                if node.random not in dic:\\n                    # If node.random points to a node that we have not yet encountered, store it in the dictionary.\\n                    dic[node.random] = Node(node.random.val, node.random.next, node.random.random)\\n                # Make the copy\\'s random property point to the copy instead of the original.\\n                dic[node].random = dic[node.random]\\n            # Store prev and advance to the next node.\\n            prev, node = dic[node], node.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 341495,
                "title": "javascript-o-n-space-solution",
                "content": "```\\nvar copyRandomList = function(head) {\\n    if(!head) {\\n      return null;\\n    }\\n    const clones = new Map();\\n    let n = head;\\n    while(n) {\\n      clones.set(n, new Node(n.val));\\n      n = n.next\\n    }\\n    n = head;\\n    while(n) {\\n      clones.get(n).next = clones.get(n.next) || null;\\n      clones.get(n).random = clones.get(n.random) || null;\\n      n = n.next\\n    }\\n    return clones.get(head);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar copyRandomList = function(head) {\\n    if(!head) {\\n      return null;\\n    }\\n    const clones = new Map();\\n    let n = head;\\n    while(n) {\\n      clones.set(n, new Node(n.val));\\n      n = n.next\\n    }\\n    n = head;\\n    while(n) {\\n      clones.get(n).next = clones.get(n.next) || null;\\n      clones.get(n).random = clones.get(n.random) || null;\\n      n = n.next\\n    }\\n    return clones.get(head);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1255721,
                "title": "c-both-solutions-explained-clearly-hashmap-method-constant-space-method",
                "content": "**Solution 1: Using Hashmap\\nTime: O(N) \\nSpace: O(N)**\\n\\n```\\nNode* copyRandomList(Node* head) {\\n        \\n        // this map points to the clone of the original node\\n        map<Node*,Node*> mp;\\n        \\n        Node* temp=head;\\n        \\n        // 1st Pass - Creation of Nodes and no wiring\\n        while(temp!=NULL)\\n        {\\n            // Pointing the original node to its clone node\\n            // Now I can access the clone node in O(1)\\n            mp[temp] = new Node(temp->val);\\n            temp=temp->next;\\n            \\n        }\\n        \\n        // 2nd pass - Filling the next and random pointers\\n        temp=head;\\n        \\n        while(temp!=NULL)\\n        {\\n            // mp[ptr] is the clone node and its next is the next original\\n            // node\\'s clone node. \\n            // mp[ptr->next] refers to the clone node of ptr->next;\\n            mp[temp]->next= mp[temp->next]; \\n            \\n            // similar thing for the random pointer\\n            mp[temp]->random=mp[temp->random];\\n            \\n            temp=temp->next;\\n        }\\n        \\n        return mp[head];\\n        \\n    }\\n```\\n\\n**Solution 2: Constant Space without Hashmap\\nTime: O(N)\\nSpace: O(1)**\\n\\n```\\nNode* copyRandomList(Node* head) {\\n        \\n        if(head==NULL)\\n            return NULL;\\n        \\n        // temporary (copied) head node\\n        Node* temp=head;\\n        \\n        // 1st Pass\\n        \\n        while(temp!=NULL)\\n        {\\n             // Cloned node with same val as head\\n            Node* newnode= new Node(temp->val);\\n            \\n            // Insert the cloned node next to the original node\\n            // If A->B->C is the original linked list,\\n            // Linked list after weaving cloned nodes would be\\n            // A->A\\'->B->B\\'->C->C\\'\\n            \\n            newnode->next=temp->next;\\n            temp->next=newnode;\\n            temp=newnode->next;\\n        }\\n        \\n        temp=head;\\n        \\n        // Link random pointers of the newly created nodes\\n        // and iterate through the newly created list and\\n        // use original node\\'s random pointers\\n        \\n        // 2nd Pass\\n        \\n        while(temp!=NULL)\\n        {\\n            temp->next->random=(temp->random)?(temp->random->next):NULL;       \\n            temp=temp->next->next;\\n        }\\n        \\n         // Unweave the current linked list to get back the \\n        // original linked list and the cloned one.\\n        \\n\\t\\t// A->B->C\\n        Node* original=head;\\n        \\n        // A\\'->B\\'->C\\'\\n        Node* clone=head->next;\\n        \\n        // Result is used for returning\\n        Node* result=head->next;\\n        // 3rd Pass\\n        \\n        while(original!=NULL)\\n        {\\n            original->next=original->next->next;\\n            clone->next= (clone->next)?(clone->next->next):NULL;\\n            \\n            original=original->next;\\n            clone=clone->next;\\n        }\\n        \\n        return result;\\n```\\nIf you have any doubts, post in the comments.\\nUpvote if you like the solution",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nNode* copyRandomList(Node* head) {\\n        \\n        // this map points to the clone of the original node\\n        map<Node*,Node*> mp;\\n        \\n        Node* temp=head;\\n        \\n        // 1st Pass - Creation of Nodes and no wiring\\n        while(temp!=NULL)\\n        {\\n            // Pointing the original node to its clone node\\n            // Now I can access the clone node in O(1)\\n            mp[temp] = new Node(temp->val);\\n            temp=temp->next;\\n            \\n        }\\n        \\n        // 2nd pass - Filling the next and random pointers\\n        temp=head;\\n        \\n        while(temp!=NULL)\\n        {\\n            // mp[ptr] is the clone node and its next is the next original\\n            // node\\'s clone node. \\n            // mp[ptr->next] refers to the clone node of ptr->next;\\n            mp[temp]->next= mp[temp->next]; \\n            \\n            // similar thing for the random pointer\\n            mp[temp]->random=mp[temp->random];\\n            \\n            temp=temp->next;\\n        }\\n        \\n        return mp[head];\\n        \\n    }\\n```\n```\\nNode* copyRandomList(Node* head) {\\n        \\n        if(head==NULL)\\n            return NULL;\\n        \\n        // temporary (copied) head node\\n        Node* temp=head;\\n        \\n        // 1st Pass\\n        \\n        while(temp!=NULL)\\n        {\\n             // Cloned node with same val as head\\n            Node* newnode= new Node(temp->val);\\n            \\n            // Insert the cloned node next to the original node\\n            // If A->B->C is the original linked list,\\n            // Linked list after weaving cloned nodes would be\\n            // A->A\\'->B->B\\'->C->C\\'\\n            \\n            newnode->next=temp->next;\\n            temp->next=newnode;\\n            temp=newnode->next;\\n        }\\n        \\n        temp=head;\\n        \\n        // Link random pointers of the newly created nodes\\n        // and iterate through the newly created list and\\n        // use original node\\'s random pointers\\n        \\n        // 2nd Pass\\n        \\n        while(temp!=NULL)\\n        {\\n            temp->next->random=(temp->random)?(temp->random->next):NULL;       \\n            temp=temp->next->next;\\n        }\\n        \\n         // Unweave the current linked list to get back the \\n        // original linked list and the cloned one.\\n        \\n\\t\\t// A->B->C\\n        Node* original=head;\\n        \\n        // A\\'->B\\'->C\\'\\n        Node* clone=head->next;\\n        \\n        // Result is used for returning\\n        Node* result=head->next;\\n        // 3rd Pass\\n        \\n        while(original!=NULL)\\n        {\\n            original->next=original->next->next;\\n            clone->next= (clone->next)?(clone->next->next):NULL;\\n            \\n            original=original->next;\\n            clone=clone->next;\\n        }\\n        \\n        return result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 649910,
                "title": "java-solution-using-hashmap-beat-100",
                "content": "class Solution {\\n    public Node copyRandomList(Node head) {\\n        \\n        // HashMap which holds old nodes as keys and new nodes as its values. \\n        HashMap<Node, Node> map = new HashMap<Node, Node>();\\n        \\n        //copy list nodes into hash table\\n        Node p = head;\\n        while(p != null){\\n            map.put(p, new Node(p.val));\\n            p = p.next;\\n        }\\n        \\n        //deep copy using hash table\\n        Node q = head;\\n        while(q != null){\\n            map.get(q).next = map.get(q.next);\\n            map.get(q).random = map.get(q.random);\\n            q = q.next;\\n        }\\n        \\n        //return new head\\n        return map.get(head);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public Node copyRandomList(Node head) {\\n        \\n        // HashMap which holds old nodes as keys and new nodes as its values. \\n        HashMap<Node, Node> map = new HashMap<Node, Node>();\\n        \\n        //copy list nodes into hash table\\n        Node p = head;\\n        while(p != null){\\n            map.put(p, new Node(p.val));\\n            p = p.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 43515,
                "title": "my-accepted-java-code-o-n-but-need-to-iterate-the-list-3-times",
                "content": "The idea is:\\nStep 1: create a new node for each existing node and join them together\\neg: A->B->C will be A->A'->B->B'->C->C'\\n\\nStep2: copy the random links: for each new node n', n'.random = n.random.next\\n\\nStep3: detach the list: basically n.next = n.next.next; n'.next = n'.next.next\\n\\nHere is the code:\\n\\n    /**\\n     * Definition for singly-linked list with a random pointer.\\n     * class RandomListNode {\\n     *     int label;\\n     *     RandomListNode next, random;\\n     *     RandomListNode(int x) { this.label = x; }\\n     * };\\n     */\\n    public class Solution {\\n        public RandomListNode copyRandomList(RandomListNode head) {\\n            if(head==null){\\n                return null;\\n            }\\n            RandomListNode n = head;\\n            while (n!=null){\\n                RandomListNode n2 = new RandomListNode(n.label);\\n                RandomListNode tmp = n.next;\\n                n.next = n2;\\n                n2.next = tmp;\\n                n = tmp;\\n            }\\n            \\n            n=head;\\n            while(n != null){\\n                RandomListNode n2 = n.next;\\n                if(n.random != null)\\n                    n2.random = n.random.next;\\n                else\\n                    n2.random = null;\\n                n = n.next.next;\\n            }\\n            \\n            //detach list\\n            RandomListNode n2 = head.next;\\n            n = head;\\n            RandomListNode head2 = head.next;\\n            while(n2 != null && n != null){\\n                n.next = n.next.next;\\n                if (n2.next == null){\\n                    break;\\n                }\\n                n2.next = n2.next.next;\\n                \\n                n2 = n2.next;\\n                n = n.next;\\n            }\\n            return head2;\\n            \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public RandomListNode copyRandomList(RandomListNode head) {\\n            if(head==null){\\n                return null;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1841010,
                "title": "python3-just-two-steps-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe main problem is that a random pointer can point to any node in the list. So we can\\'t get by here without a hashmap to remember copied nodes. We need a hashmap that maps the original node to its copy. Having that, we can proceed with two simple steps:\\n\\n1. First pass to create a copy of nodes and fill the hashmap\\n2. Second pass to set random pointers in the copied nodes with according nodes.\\n\\nTime: **O(n)** - for two passes\\nSpace: **O(n)** - for the hashmap\\n\\nRuntime: 36 ms, faster than **91.34%** of Python3 online submissions for Copy List with Random Pointer.\\nMemory Usage: 14.8 MB, less than **85.83%** of Python3 online submissions for Copy List with Random Pointer.\\n\\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        hm, zero = dict(), Node(0)\\n        \\n        cur, copy = head, zero\\n        while cur:\\n            copy.next = Node(cur.val)\\n            hm[cur] = copy.next\\n            cur, copy = cur.next, copy.next\\n            \\n        cur, copy = head, zero.next\\n        while cur:\\n            copy.random = hm[cur.random] if cur.random else None\\n            cur, copy = cur.next, copy.next\\n                \\n        return zero.next\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        hm, zero = dict(), Node(0)\\n        \\n        cur, copy = head, zero\\n        while cur:\\n            copy.next = Node(cur.val)\\n            hm[cur] = copy.next\\n            cur, copy = cur.next, copy.next\\n            \\n        cur, copy = head, zero.next\\n        while cur:\\n            copy.random = hm[cur.random] if cur.random else None\\n            cur, copy = cur.next, copy.next\\n                \\n        return zero.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43567,
                "title": "c-simple-recursive-solution",
                "content": "    class Solution {\\n\\tunordered_map<RandomListNode*, RandomListNode*> hmap;\\n\\n    public:\\n\\tRandomListNode *copyRandomList(RandomListNode *head) {\\n\\t\\tif (!head) return NULL;\\n\\t\\tif (hmap.find(head) != hmap.end())\\n\\t\\t\\treturn hmap.find(head)->second;\\n\\n\\t\\tRandomListNode* node = new RandomListNode(head->label);\\n\\t\\thmap[head] = node;\\n\\t\\tnode->next = copyRandomList(head->next);\\n\\t\\tnode->random = copyRandomList(head->random);\\n\\t\\treturn node;\\n\\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n\\tunordered_map<RandomListNode*, RandomListNode*> hmap;\\n\\n    public:\\n\\tRandomListNode *copyRandomList(RandomListNode *head) {\\n\\t\\tif (!head) return NULL;\\n\\t\\tif (hmap.find(head) != hmap.end())\\n\\t\\t\\treturn hmap.find(head)->second;\\n\\n\\t\\tRandomListNode* node = new RandomListNode(head->label);\\n\\t\\thmap[head] = node;\\n\\t\\tnode->next = copyRandomList(head->next);\\n\\t\\tnode->random = copyRandomList(head->random);\\n\\t\\treturn node;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 43540,
                "title": "very-short-java-solution-with-map",
                "content": "I realized with Map, we don't really need to care about the internal structure of the list. What we need is just deep copy exactly what the original data. So here I just create all nodes and put <old, new> pairs into a map. Then update next and random pointers for each new node.\\n\\n    public class Solution {\\n        public RandomListNode copyRandomList(RandomListNode head) {\\n            if (head == null) {\\n                return null;\\n            }\\n            \\n            final Map<RandomListNode, RandomListNode> map = new HashMap<RandomListNode, RandomListNode>();\\n    \\n            RandomListNode cur = head;\\n            while(cur != null) {\\n                map.put(cur, new RandomListNode(cur.label));\\n                cur = cur.next;\\n            }\\n            \\n            for (Map.Entry<RandomListNode, RandomListNode> entry : map.entrySet()) {\\n                final RandomListNode newNode = entry.getValue();\\n                newNode.next = map.get(entry.getKey().next);\\n                newNode.random = map.get(entry.getKey().random);\\n            }\\n            \\n            return map.get(head);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public RandomListNode copyRandomList(RandomListNode head) {\\n            if (head == null) {\\n                return null;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4003329,
                "title": "c-2-approaches-o-n-space-and-o-1-space",
                "content": "# Approach 1: Hashmap for Relationships\\n**1. Initialize a hashamp of [original, copied] kv pairs**\\n- Initializing a hashmap where the key is the original node, we can create a copy of this node and place it has the value for the key value pair. Therefore we can always access the corresponding copied node by refrencing the hashmap\\n\\n**2. Pass 1: Create Copied Nodes**\\n- We create the copied nodes with the value of the original node.\\n- In the example below, we place the original nodes in the keys, and create a copy of the node with the same value as the corresponding value in the map.\\n```\\nll = 1 -> 2 -> 3 -> 4 -> 5\\n\\nhashmap:\\nkeys = node1    , node2    , node3    , node4    , node5\\nvals = copynode1, copynode2, copynode3, copynode4, copynode5\\n```\\n\\n**3. Pass 2: Assign next and random to the copied nodes**\\n- we can iterate through our original linked list, and access the copied node of the current original node we are at by refrencing the map.\\n- we can then assign the copied node the copied next and copied random nodes as its connections\\n- the code below steps this process out\\n```\\nitr = head; // set iterator of original list to the head node\\nwhile(itr) {\\n    map[itr]->next = map[itr->next]; // assign copied next\\n    map[itr]->random = map[itr->random]; // assign copied random\\n    itr = itr->next; // iterate in original list to next node\\n}\\n```\\n# Complexity\\n**Time complexity: O(n)**\\n- requires two traversals of n nodes = O(2n) = O(n)\\n\\n**Space complexity: O(n)**\\n- we use a hashmap to store n key value pairs = O(n)\\n\\n# Code\\n```,\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        unordered_map<Node*,Node*> map;\\n\\n        Node* itr = head;\\n        while(itr) {\\n            map[itr] = new Node(itr->val);\\n            itr=itr->next;\\n        }\\n\\n        itr = head;\\n        while(itr) {\\n            map[itr]->next = map[itr->next];\\n            map[itr]->random = map[itr->random];\\n            itr = itr->next;\\n        }\\n\\n        return map[head];\\n    }\\n};\\n```\\n\\n# Approach 2: Clever Pointer Manipulation\\n**1. Initalize Pointers**\\n- one for iterating through original list\\n- one for iterating through a cloned list\\n- one for temporary node creation\\n```\\nNode* original = head; // itr for original\\nNode* cloned = nullptr; // itr for cloed\\nNode* temp = nullptr; // temporary for node creation\\n```\\n**2. First Pass Clone Nodes and link them to original**\\n- this allows us to access the cloned nodes as they will be stored in original->next\\n- see example below\\n```\\noriginal: 1 -> 2 -> 3 \\nmanipulated: 1 -> 1copy -> 2 -> 2copy -> 3 -> 3copy\\n```\\n\\n**3. Assign Random pointers to the clones**\\n- again this is done by accessing the original->next\\n- when we move the pointer in iteration, we do original->next->next to skip the copied nodes\\n- the code below is the process\\n```\\nwhile(original) {\\n    if(original->random) {\\n        original->next->random = original->random->next;\\n        } else {\\n            original->next->random = nullptr;\\n        }\\n            original = original->next->next; // skip copy\\n    }\\n}\\n```\\n\\n**4. Seperate the original and cloned lists**\\n- this will allows us to have the copied nodes all next to eachother in the correct order, in regards to their next pointers\\n- see the continued example below\\n```\\nmanipulated = 1 -> 1copy -> 2 -> 2copy -> 3 -> 3copy\\n\\nseperated original = 1 -> 2 -> 3\\nseperated cloned = 1copy -> 2copy -> 3copy\\n```\\n\\nafter this seperation we can return the head of the cloned list\\n\\n# Complexity\\n**Time Complexity: O(n)**\\n- still three traversals = O(3n) = O(n)\\n\\n**Space Complexity: O(1)**\\n- only a constant number of pointers is used for additional memory\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return nullptr;\\n\\n        Node* original = head; // itr for original\\n        Node* cloned = nullptr; // itr for cloed\\n        Node* temp = nullptr; // temporary for node creation\\n\\n        // First pass: clone nodes and link them next to origial\\n        while(original) {\\n            temp = new Node(original->val);\\n            temp->next = original->next;\\n            original->next=temp;\\n            original = temp->next;\\n        }\\n\\n        original = head;\\n        Node* newHead = head->next;\\n\\n        // Second pass: Assign random pointers to cloned nodes\\n        while(original) {\\n            if(original->random) {\\n                original->next->random = original->random->next;\\n            } else {\\n                original->next->random = nullptr;\\n            }\\n            original = original->next->next; // skip copy\\n        }\\n        \\n        original = head;\\n\\n        // Third Pass: Seperate original and cloned \\n        while(original) {\\n            temp = original->next; \\n            original->next = temp->next; \\n            original = original->next;\\n\\n            if(original) {\\n                temp->next = original->next;\\n            } else {\\n                temp->next = nullptr;\\n            }\\n        }\\n\\n    return newHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nll = 1 -> 2 -> 3 -> 4 -> 5\\n\\nhashmap:\\nkeys = node1    , node2    , node3    , node4    , node5\\nvals = copynode1, copynode2, copynode3, copynode4, copynode5\\n```\n```\\nitr = head; // set iterator of original list to the head node\\nwhile(itr) {\\n    map[itr]->next = map[itr->next]; // assign copied next\\n    map[itr]->random = map[itr->random]; // assign copied random\\n    itr = itr->next; // iterate in original list to next node\\n}\\n```\n```,\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        unordered_map<Node*,Node*> map;\\n\\n        Node* itr = head;\\n        while(itr) {\\n            map[itr] = new Node(itr->val);\\n            itr=itr->next;\\n        }\\n\\n        itr = head;\\n        while(itr) {\\n            map[itr]->next = map[itr->next];\\n            map[itr]->random = map[itr->random];\\n            itr = itr->next;\\n        }\\n\\n        return map[head];\\n    }\\n};\\n```\n```\\nNode* original = head; // itr for original\\nNode* cloned = nullptr; // itr for cloed\\nNode* temp = nullptr; // temporary for node creation\\n```\n```\\noriginal: 1 -> 2 -> 3 \\nmanipulated: 1 -> 1copy -> 2 -> 2copy -> 3 -> 3copy\\n```\n```\\nwhile(original) {\\n    if(original->random) {\\n        original->next->random = original->random->next;\\n        } else {\\n            original->next->random = nullptr;\\n        }\\n            original = original->next->next; // skip copy\\n    }\\n}\\n```\n```\\nmanipulated = 1 -> 1copy -> 2 -> 2copy -> 3 -> 3copy\\n\\nseperated original = 1 -> 2 -> 3\\nseperated cloned = 1copy -> 2copy -> 3copy\\n```\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return nullptr;\\n\\n        Node* original = head; // itr for original\\n        Node* cloned = nullptr; // itr for cloed\\n        Node* temp = nullptr; // temporary for node creation\\n\\n        // First pass: clone nodes and link them next to origial\\n        while(original) {\\n            temp = new Node(original->val);\\n            temp->next = original->next;\\n            original->next=temp;\\n            original = temp->next;\\n        }\\n\\n        original = head;\\n        Node* newHead = head->next;\\n\\n        // Second pass: Assign random pointers to cloned nodes\\n        while(original) {\\n            if(original->random) {\\n                original->next->random = original->random->next;\\n            } else {\\n                original->next->random = nullptr;\\n            }\\n            original = original->next->next; // skip copy\\n        }\\n        \\n        original = head;\\n\\n        // Third Pass: Seperate original and cloned \\n        while(original) {\\n            temp = original->next; \\n            original->next = temp->next; \\n            original = original->next;\\n\\n            if(original) {\\n                temp->next = original->next;\\n            } else {\\n                temp->next = nullptr;\\n            }\\n        }\\n\\n    return newHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003730,
                "title": "clear-explanation-code-step-by-step-guide-to-deep-copying",
                "content": "# Problem Description:\\n\\nYou are given a **linked list** where each node has a **\"random\"** pointer that can **point to any other node in the list**, or it can be null. You need to **create a deep copy of this linked list**, such that the **copied list has new nodes with the same values as the original list**, and the \"next\" and \"random\" pointers in the copied list represent the **same relationships as in the original list**.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe **key** to solving this problem **efficiently** is to use a **recursive approach** along with a **hash map** (unordered_map in C++). **Here\\'s how the provided solution works:**\\n\\n**1.** **Base Cases:**\\n- If the input **head is null**, **return null** because there\\'s nothing to copy.\\n- **Check if the hash map (mp) already contains the head node. If it does, return the corresponding copied node from the map**. This is done to avoid copying the same node multiple times.\\n2. **Creating a New Node:**\\n\\n- If the head node is **not in the hash map, create a new node (newNode) with the same value as the head node**.\\n- **Store this mapping** in the hash map, where the original head node is mapped to the newly created newNode.\\n3. **Recursion:**\\n\\n- **Recursively call copyRandomList for the next and random pointers of the head node**. This will ensure that we create deep copies of the nodes pointed to by next and random.\\n- **Assign the results of the recursive calls to newNode->next and newNode->random**. This establishes the correct relationships in the copied list.\\n4. **Return Result:**\\n\\n- **Return newNode** as the result, which is the head of the copied list.\\n# Summary:\\n- **The solution uses a recursive approach** to traverse the original linked list.\\n- **It maintains a hash map** (mp) to keep track of the mapping between nodes in the original list and their corresponding nodes in the copied list.\\n- When you encounter **a node in the original list for the first time,** **you create a new node** in the copied list with the same value.\\n- **Then, you recursively copy the next and random pointers of the original node.**\\n- By using this recursive approach and the hash map to avoid duplicating nodes, you ensure that the copied list preserves the same structure and relationships as the original list.\\n\\n**This solution is efficient because it avoids redundant copying of nodes and ensures that the relationships between nodes (both next and random) are correctly maintained in the copied list.**\\n# Complexity\\n- Time complexity:  The overall time complexity of the code is **O(N)**.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  The overall space complexity of the code is **O(N).**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n\\n# SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A\\n\\n---\\n\\n\\n# Code\\n\\n\\n```C++ []\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    unordered_map<Node*, Node*> mp;\\n    Node* copyRandomList(Node* head) {\\n    if (head == NULL)\\n      return NULL ;\\n    if (mp.count(head))\\n      return mp[head];\\n\\n    Node* newNode = new Node(head->val);\\n    mp[head] = newNode;\\n    newNode->next = copyRandomList(head->next);\\n    newNode->random = copyRandomList(head->random);\\n    return newNode;\\n  }\\n};\\n```\\n```Java []\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\npublic class Solution {\\n    Map<Node, Node> map = new HashMap<>();\\n\\n    public Node copyRandomList(Node head) {\\n        if (head == null) return null;\\n\\n        if (map.containsKey(head)) return map.get(head);\\n\\n        Node newNode = new Node(head.val);\\n        map.put(head, newNode);\\n\\n        newNode.next = copyRandomList(head.next);\\n        newNode.random = copyRandomList(head.random);\\n\\n        return newNode;\\n    }\\n}\\n\\n```\\n```Python3 []\\nclass Solution:\\n    def __init__(self):\\n        self.visited = {}\\n\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n\\n        if head in self.visited:\\n            return self.visited[head]\\n\\n        newNode = Node(head.val)\\n        self.visited[head] = newNode\\n\\n        newNode.next = self.copyRandomList(head.next)\\n        newNode.random = self.copyRandomList(head.random)\\n\\n        return newNode\\n\\n\\n```\\n```Javascript []\\nvar copyRandomList = function(head) {\\n    const visited = new Map();\\n\\n    const copy = (node) => {\\n        if (!node) return null;\\n\\n        if (visited.has(node)) return visited.get(node);\\n\\n        const newNode = new Node(node.val);\\n        visited.set(node, newNode);\\n\\n        newNode.next = copy(node.next);\\n        newNode.random = copy(node.random);\\n\\n        return newNode;\\n    };\\n\\n    return copy(head);\\n};\\n\\n```\\n\\n---\\n\\n\\n# SMALL REQUEST : If you found this post even remotely helpful, be kind enough to smash a upvote. I will be grateful.I will be motivated\\uD83D\\uDE0A\\uD83D\\uDE0A\\n![UPVOTE.png](https://assets.leetcode.com/users/images/5e6c8908-1135-4b04-8ee5-68bd93f2cab9_1693888435.9082885.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```C++ []\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    unordered_map<Node*, Node*> mp;\\n    Node* copyRandomList(Node* head) {\\n    if (head == NULL)\\n      return NULL ;\\n    if (mp.count(head))\\n      return mp[head];\\n\\n    Node* newNode = new Node(head->val);\\n    mp[head] = newNode;\\n    newNode->next = copyRandomList(head->next);\\n    newNode->random = copyRandomList(head->random);\\n    return newNode;\\n  }\\n};\\n```\n```Java []\\nimport java.util.HashMap;\\nimport java.util.Map;\\n\\npublic class Solution {\\n    Map<Node, Node> map = new HashMap<>();\\n\\n    public Node copyRandomList(Node head) {\\n        if (head == null) return null;\\n\\n        if (map.containsKey(head)) return map.get(head);\\n\\n        Node newNode = new Node(head.val);\\n        map.put(head, newNode);\\n\\n        newNode.next = copyRandomList(head.next);\\n        newNode.random = copyRandomList(head.random);\\n\\n        return newNode;\\n    }\\n}\\n\\n```\n```Python3 []\\nclass Solution:\\n    def __init__(self):\\n        self.visited = {}\\n\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n\\n        if head in self.visited:\\n            return self.visited[head]\\n\\n        newNode = Node(head.val)\\n        self.visited[head] = newNode\\n\\n        newNode.next = self.copyRandomList(head.next)\\n        newNode.random = self.copyRandomList(head.random)\\n\\n        return newNode\\n\\n\\n```\n```Javascript []\\nvar copyRandomList = function(head) {\\n    const visited = new Map();\\n\\n    const copy = (node) => {\\n        if (!node) return null;\\n\\n        if (visited.has(node)) return visited.get(node);\\n\\n        const newNode = new Node(node.val);\\n        visited.set(node, newNode);\\n\\n        newNode.next = copy(node.next);\\n        newNode.random = copy(node.random);\\n\\n        return newNode;\\n    };\\n\\n    return copy(head);\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1840970,
                "title": "c-o-1-space",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return NULL;\\n        \\n        Node* temp = head;\\n        \\n        while(temp){\\n            Node* node = new Node(temp->val);\\n            node->next = temp->next;\\n            temp->next = node;\\n            temp = node->next;\\n        }\\n        \\n        temp = head;\\n        while(temp){\\n            temp->next->random = (temp->random)?temp->random->next:NULL;\\n            temp = temp->next->next;\\n        }\\n        \\n        Node* ans = head->next;\\n        temp = head->next;\\n        while(head){\\n            head->next = temp->next;\\n            head = head->next;\\n            if(!head) break;\\n            temp->next = head->next;\\n            temp = temp->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return NULL;\\n        \\n        Node* temp = head;\\n        \\n        while(temp){\\n            Node* node = new Node(temp->val);\\n            node->next = temp->next;\\n            temp->next = node;\\n            temp = node->next;\\n        }\\n        \\n        temp = head;\\n        while(temp){\\n            temp->next->random = (temp->random)?temp->random->next:NULL;\\n            temp = temp->next->next;\\n        }\\n        \\n        Node* ans = head->next;\\n        temp = head->next;\\n        while(head){\\n            head->next = temp->next;\\n            head = head->next;\\n            if(!head) break;\\n            temp->next = head->next;\\n            temp = temp->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 614624,
                "title": "python-o-n-by-mirror-node-85-w-visualization",
                "content": "Python O(n) by mirror node\\n\\n---\\n\\n\\n**Illustration and Visualization**\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588677659.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588677705.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588677740.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588677781.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1588677807.png)\\n\\n---\\n\\n**Implementation** by mirror node:\\n\\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        \\n        # --------------------------------------------------------\\n        \\n        # Create mirror node for each node in linked list\\n        \\n        cur = head\\n        \\n        while cur:\\n            \\n            # backup original next node of input linkied list\\n            original_next_hop = cur.next\\n            \\n            # create mirror node with original order\\n            cur.next = Node( x = cur.val, next = original_next_hop, random = None)\\n            \\n            # move to next position\\n            cur = original_next_hop\\n        \\n        \\n        # --------------------------------------------------------\\n        \\n        # Let mirror node get the random pointer\\n        \\n        cur = head\\n        \\n        while cur:\\n            \\n            if cur.random:\\n                # assign random pointer to mirror node\\n                cur.next.random = cur.random.next\\n                \\n            try:\\n                # move to next position\\n                cur = cur.next.next\\n            except AttributeError:\\n                break\\n                \\n        \\n        # --------------------------------------------------------\\n                \\n        # Separate copy linked list from original linked list\\n        \\n        try:\\n            # locate the head node of copy linked list\\n            head_of_copy_list = head.next\\n            cur = head_of_copy_list\\n            \\n        except AttributeError:\\n            # original input is an empty linked list\\n            return None\\n        \\n        while cur:\\n            \\n            try:\\n                # link mirror node to copy linked list\\n                cur.next = cur.next.next\\n            except AttributeError:\\n                break\\n            \\n            # move to next position\\n            cur = cur.next\\n            \\n        return head_of_copy_list\\n```\\n\\n---\\n\\nSupport function to help trace and debugging:\\n\\n```\\n    def print_linked_list( self, node ):\\n        \\n        cur = node\\n        \\n        while cur:\\n            print( f\\' val = {cur.val} \\')\\n            \\n            if cur.next:\\n                print( f\\' next = {cur.next.val} \\')\\n            else:\\n                print( f\\' next = None \\')\\n                \\n            if cur.random:\\n                print( f\\' random = {cur.random.val} \\')\\n            else:\\n                print( f\\' random = None\\')\\n                \\n            print( \\'\\\\n => \\\\n\\' )\\n            \\n            cur = cur.next\\n```\\n\\n---\\n\\nShare another solution by dictionary of mirror node\\n\\n**Implementation**:\\n\\n```\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n\\n        if not head:\\n            return None\\n\\n        dict_of_copy = {}\\n\\n        cur = head\\n        while cur:\\n            dict_of_copy[ id(cur) ] = Node(x=cur.val, next=None, random=None)\\n            cur = cur.next\\n\\n        cur = head\\n        while cur:\\n\\n            if cur.next:\\n                dict_of_copy[ id(cur) ].next = dict_of_copy[ id(cur.next) ]\\n\\n            if cur.random:\\n                dict_of_copy[ id(cur) ].random = dict_of_copy[ id(cur.random) ]\\n\\n            cur = cur.next\\n\\n        return dict_of_copy[ id(head) ]\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        \\n        # --------------------------------------------------------\\n        \\n        # Create mirror node for each node in linked list\\n        \\n        cur = head\\n        \\n        while cur:\\n            \\n            # backup original next node of input linkied list\\n            original_next_hop = cur.next\\n            \\n            # create mirror node with original order\\n            cur.next = Node( x = cur.val, next = original_next_hop, random = None)\\n            \\n            # move to next position\\n            cur = original_next_hop\\n        \\n        \\n        # --------------------------------------------------------\\n        \\n        # Let mirror node get the random pointer\\n        \\n        cur = head\\n        \\n        while cur:\\n            \\n            if cur.random:\\n                # assign random pointer to mirror node\\n                cur.next.random = cur.random.next\\n                \\n            try:\\n                # move to next position\\n                cur = cur.next.next\\n            except AttributeError:\\n                break\\n                \\n        \\n        # --------------------------------------------------------\\n                \\n        # Separate copy linked list from original linked list\\n        \\n        try:\\n            # locate the head node of copy linked list\\n            head_of_copy_list = head.next\\n            cur = head_of_copy_list\\n            \\n        except AttributeError:\\n            # original input is an empty linked list\\n            return None\\n        \\n        while cur:\\n            \\n            try:\\n                # link mirror node to copy linked list\\n                cur.next = cur.next.next\\n            except AttributeError:\\n                break\\n            \\n            # move to next position\\n            cur = cur.next\\n            \\n        return head_of_copy_list\\n```\n```\\n    def print_linked_list( self, node ):\\n        \\n        cur = node\\n        \\n        while cur:\\n            print( f\\' val = {cur.val} \\')\\n            \\n            if cur.next:\\n                print( f\\' next = {cur.next.val} \\')\\n            else:\\n                print( f\\' next = None \\')\\n                \\n            if cur.random:\\n                print( f\\' random = {cur.random.val} \\')\\n            else:\\n                print( f\\' random = None\\')\\n                \\n            print( \\'\\\\n => \\\\n\\' )\\n            \\n            cur = cur.next\\n```\n```\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n\\n        if not head:\\n            return None\\n\\n        dict_of_copy = {}\\n\\n        cur = head\\n        while cur:\\n            dict_of_copy[ id(cur) ] = Node(x=cur.val, next=None, random=None)\\n            cur = cur.next\\n\\n        cur = head\\n        while cur:\\n\\n            if cur.next:\\n                dict_of_copy[ id(cur) ].next = dict_of_copy[ id(cur.next) ]\\n\\n            if cur.random:\\n                dict_of_copy[ id(cur) ].random = dict_of_copy[ id(cur.random) ]\\n\\n            cur = cur.next\\n\\n        return dict_of_copy[ id(head) ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059152,
                "title": "python-3-stage-o-n-solution-explained",
                "content": "First, we can go through the linked list, put all nodes to hash table and then connect all additional nodes. It takes additional `O(n)` memory. If we more memory efficient solution, we need to think more.\\n\\nUnfortunately, we can not use BFS or DFS here, because, we do not  really know the number of node for random field, only the reference, which can be found in either `O(n)` or we need to keep all references in hash table. \\n\\nThe trick to solve this problem in `O(1)` memory is to use duplication trick. Imagine, that we have list `7 -> 13 -> 11 -> null`, then we need to do `3` stages:\\n\\n1. Create duplicated list, that is `7 -> 7 -> 13 -> 13 -> 11 -> 11 -> null`, where every second value will be elements of new list.\\n2. Second step is to add `random` field pointers, it can be done as `curr.next.random = curr.random.next`, that is where we need to point random pointer of second node with value `7`? We need to look at random field of first `7` and take next element. We need to be careful with null pointers.\\n3. Finally, we need to cut list into two parts, we can do it with simple `2` pointers `curr` and `nxt`, which always will have adjacent elements inside.\\n\\n**Complexity**: time complexity is `O(n)`, this is complexity of every stage. Space complexity is `O(1)`, if we do not count our output list.\\n\\nThe trick to solve is to duplicate our list, after each node add the node with the same value, then add new random fields, and then cut it into 2 lists.\\n\\n```\\nclass Solution:\\n    def copyRandomList(self, head):\\n        dummy = Node(-1)\\n        dummy.next = head\\n        curr = head\\n        while curr:\\n            tmp = Node(curr.val)\\n            tmp.next = curr.next\\n            curr.next = tmp\\n            curr = tmp.next\\n            \\n        curr = head\\n        while curr:\\n            curr.next.random = curr.random.next if curr.random else None\\n            curr = curr.next.next\\n            \\n        curr, nxt = dummy, head\\n        while nxt:\\n            curr.next = nxt.next\\n            curr = nxt\\n            nxt = curr.next\\n            \\n        return dummy.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head):\\n        dummy = Node(-1)\\n        dummy.next = head\\n        curr = head\\n        while curr:\\n            tmp = Node(curr.val)\\n            tmp.next = curr.next\\n            curr.next = tmp\\n            curr = tmp.next\\n            \\n        curr = head\\n        while curr:\\n            curr.next.random = curr.random.next if curr.random else None\\n            curr = curr.next.next\\n            \\n        curr, nxt = dummy, head\\n        while nxt:\\n            curr.next = nxt.next\\n            curr = nxt\\n            nxt = curr.next\\n            \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841347,
                "title": "java-solution-simple-code-7-line-code",
                "content": "\\tPoints:-\\n\\n1. Store the old and corresponding new Node in the map.\\n2. Traverse the Node recursivelly and while returning from recursion set the respective pointer, next and random pointer.\\n\\n**CODE**\\n\\n```\\nclass Solution {\\n\\n    Map<Node,Node> map = new HashMap<>();\\n\\t\\n    public Node copyRandomList(Node head) {\\n        if(head == null) return null;\\n        Node temp = new Node(head.val);\\n        map.put(head,temp);\\n        temp.next = copyRandomList(head.next);\\n        temp.random = map.get(head.random);\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    Map<Node,Node> map = new HashMap<>();\\n\\t\\n    public Node copyRandomList(Node head) {\\n        if(head == null) return null;\\n        Node temp = new Node(head.val);\\n        map.put(head,temp);\\n        temp.next = copyRandomList(head.next);\\n        temp.random = map.get(head.random);\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004716,
                "title": "easy-code-with-comment-multiple-approaches-video-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust do manipulation of pointers.\\n\\n`for detailed explanation you can refer to my youtube channel` \\n\\n[ Video in Hindi click here](https://youtube.com/@LetsCodeTogether72/videos)\\n\\nor link in my profile.Here,you can find any solution in playlists monthwise from june 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation.\\n\\n# Approach 1\\n<!-- Describe your approach to solving the problem. -->\\n1. Create an unordered map `u` to store the mapping between the original nodes and their corresponding copied nodes.\\n\\n2. Iterate through the original linked list `head` and for each node encountered, create a new node with the same value, and store it in the map `u` with the original node as the key.\\n\\n3. Reset `temp` to the beginning of the list `head`.\\n\\n4. Iterate through the list again, this time connecting the `next` and `random` pointers for the copied nodes using the information stored in the map `u`.\\n\\n5. Return the copied head node, which is stored as `u[head]`.\\n\\nThis code first creates a copy of each node and stores it in the map, and then connects the copied nodes\\' `next` and `random` pointers to complete the deep copy. Finally, it returns the head of the copied list.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 1\\n``` C++ []\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node *temp=head;\\n        unordered_map<Node*,Node*>u;\\n        while(temp!=NULL){\\n         u[temp]=new Node(temp->val);\\n         temp=temp->next;\\n        }\\n        temp=head;\\n        while(temp!=NULL){\\n         Node*curr=u[temp];\\n         Node* nex=u[temp->next];\\n         Node*r=u[temp->random];\\n         curr->next=nex;\\n         curr->random=r;\\n         temp=temp->next;\\n        }\\n        return u[head];\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null) return null;\\n        \\n        Map<Node, Node> map = new HashMap<>();\\n        Node current = head;\\n        \\n        // First pass: Create a copy of each node and store it in the map\\n        while (current != null) {\\n            map.put(current, new Node(current.val));\\n            current = current.next;\\n        }\\n        \\n        current = head;\\n        \\n        // Second pass: Connect the copied nodes\\' next and random pointers\\n        while (current != null) {\\n            Node copyNode = map.get(current);\\n            copyNode.next = map.get(current.next);\\n            copyNode.random = map.get(current.random);\\n            current = current.next;\\n        }\\n        \\n        return map.get(head);\\n    }\\n}\\n\\n```\\n```python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n        \\n        node_map = {}\\n        current = head\\n        \\n        # First pass: Create a copy of each node and store it in the map\\n        while current:\\n            node_map[current] = Node(current.val)\\n            current = current.next\\n        \\n        current = head\\n        \\n        # Second pass: Connect the copied nodes\\' next and random pointers\\n        while current:\\n            copy_node = node_map[current]\\n            copy_node.next = node_map.get(current.next)\\n            copy_node.random = node_map.get(current.random)\\n            current = current.next\\n        \\n        return node_map[head]\\n\\n```\\n# Approach 2\\n\\nThis code is an implementation of deep copying a linked list with random pointers using a constant amount of extra space.\\n\\n1. Iterate through the original linked list `head`, and for each node encountered:\\n   - Create a new node with the same value as the original node.\\n   - Insert the new node right after the original node.\\n   - Advance the current pointer by two steps (skip the newly created node).\\n\\n2. Iterate through the list again, this time connecting the `random` pointers for the copied nodes. Update the `random` pointer of each copied node to point to the correct node (if not `NULL`) by using the relationship `copied_node->random = original_node->random->next`.\\n\\n3. Separate the original list and the copied list by adjusting the `next` pointers. Reset the `current` pointer to `head`, and while iterating:\\n   - Set `current->next` to its correct value (either the next original node or `NULL`).\\n   - Adjust the `next` pointer for the corresponding copied node in the copied list similarly.\\n   - Move `current` and the temporary pointer for the copied list forward by one step.\\n\\n4. Return the head of the copied list, which is the node right after the original head node.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code 2\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL)\\n            return NULL;\\n        Node* curr = head;\\n        \\n        // First pass: Create a new node after each original node\\n        while (curr != NULL) {\\n            Node* next = curr->next;\\n            curr->next = new Node(curr->val);\\n            curr->next->next = next;\\n            curr = next;\\n        }\\n        \\n        // Second pass: Connect random pointers for the copied nodes\\n        curr = head;\\n        while (curr != NULL) {\\n            if (curr->random != NULL) {\\n                curr->next->random = curr->random->next;\\n            }\\n            curr = curr->next->next;\\n        }\\n        \\n        // Third pass: Separate the original and copied lists\\n        Node* p = head->next;\\n        Node* temp = p;\\n        curr = head;\\n        while (curr != NULL && temp != NULL) {\\n            curr->next = (curr->next != NULL) ? curr->next->next : curr->next;\\n            temp->next = (temp->next != NULL) ? temp->next->next : temp->next;\\n            curr = curr->next;\\n            temp = temp->next;\\n        }\\n        \\n        return p;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n\\n        Node current = head;\\n\\n        // First pass: Create a new node after each original node\\n        while (current != null) {\\n            Node next = current.next;\\n            current.next = new Node(current.val);\\n            current.next.next = next;\\n            current = next;\\n        }\\n\\n        // Second pass: Connect random pointers for the copied nodes\\n        current = head;\\n        while (current != null) {\\n            if (current.random != null) {\\n                current.next.random = current.random.next;\\n            }\\n            current = current.next.next;\\n        }\\n\\n        // Third pass: Separate the original and copied lists\\n        Node p = head.next;\\n        Node temp = p;\\n        current = head;\\n        while (current != null && temp != null) {\\n            current.next = (current.next != null) ? current.next.next : current.next;\\n            temp.next = (temp.next != null) ? temp.next.next : temp.next;\\n            current = current.next;\\n            temp = temp.next;\\n        }\\n\\n        return p;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n\\n        current = head\\n\\n        # First pass: Create a new node after each original node\\n        while current:\\n            next_node = current.next\\n            current.next = Node(current.val)\\n            current.next.next = next_node\\n            current = next_node\\n\\n        # Second pass: Connect random pointers for the copied nodes\\n        current = head\\n        while current:\\n            if current.random:\\n                current.next.random = current.random.next\\n            current = current.next.next\\n\\n        # Third pass: Separate the original and copied lists\\n        p = head.next\\n        temp = p\\n        current = head\\n        while current and temp:\\n            current.next = current.next.next if current.next else current.next\\n            temp.next = temp.next.next if temp.next else temp.next\\n            current = current.next\\n            temp = temp.next\\n\\n        return p\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node *temp=head;\\n        unordered_map<Node*,Node*>u;\\n        while(temp!=NULL){\\n         u[temp]=new Node(temp->val);\\n         temp=temp->next;\\n        }\\n        temp=head;\\n        while(temp!=NULL){\\n         Node*curr=u[temp];\\n         Node* nex=u[temp->next];\\n         Node*r=u[temp->random];\\n         curr->next=nex;\\n         curr->random=r;\\n         temp=temp->next;\\n        }\\n        return u[head];\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null) return null;\\n        \\n        Map<Node, Node> map = new HashMap<>();\\n        Node current = head;\\n        \\n        // First pass: Create a copy of each node and store it in the map\\n        while (current != null) {\\n            map.put(current, new Node(current.val));\\n            current = current.next;\\n        }\\n        \\n        current = head;\\n        \\n        // Second pass: Connect the copied nodes\\' next and random pointers\\n        while (current != null) {\\n            Node copyNode = map.get(current);\\n            copyNode.next = map.get(current.next);\\n            copyNode.random = map.get(current.random);\\n            current = current.next;\\n        }\\n        \\n        return map.get(head);\\n    }\\n}\\n\\n```\n```python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n        \\n        node_map = {}\\n        current = head\\n        \\n        # First pass: Create a copy of each node and store it in the map\\n        while current:\\n            node_map[current] = Node(current.val)\\n            current = current.next\\n        \\n        current = head\\n        \\n        # Second pass: Connect the copied nodes\\' next and random pointers\\n        while current:\\n            copy_node = node_map[current]\\n            copy_node.next = node_map.get(current.next)\\n            copy_node.random = node_map.get(current.random)\\n            current = current.next\\n        \\n        return node_map[head]\\n\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL)\\n            return NULL;\\n        Node* curr = head;\\n        \\n        // First pass: Create a new node after each original node\\n        while (curr != NULL) {\\n            Node* next = curr->next;\\n            curr->next = new Node(curr->val);\\n            curr->next->next = next;\\n            curr = next;\\n        }\\n        \\n        // Second pass: Connect random pointers for the copied nodes\\n        curr = head;\\n        while (curr != NULL) {\\n            if (curr->random != NULL) {\\n                curr->next->random = curr->random->next;\\n            }\\n            curr = curr->next->next;\\n        }\\n        \\n        // Third pass: Separate the original and copied lists\\n        Node* p = head->next;\\n        Node* temp = p;\\n        curr = head;\\n        while (curr != NULL && temp != NULL) {\\n            curr->next = (curr->next != NULL) ? curr->next->next : curr->next;\\n            temp->next = (temp->next != NULL) ? temp->next->next : temp->next;\\n            curr = curr->next;\\n            temp = temp->next;\\n        }\\n        \\n        return p;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n\\n        Node current = head;\\n\\n        // First pass: Create a new node after each original node\\n        while (current != null) {\\n            Node next = current.next;\\n            current.next = new Node(current.val);\\n            current.next.next = next;\\n            current = next;\\n        }\\n\\n        // Second pass: Connect random pointers for the copied nodes\\n        current = head;\\n        while (current != null) {\\n            if (current.random != null) {\\n                current.next.random = current.random.next;\\n            }\\n            current = current.next.next;\\n        }\\n\\n        // Third pass: Separate the original and copied lists\\n        Node p = head.next;\\n        Node temp = p;\\n        current = head;\\n        while (current != null && temp != null) {\\n            current.next = (current.next != null) ? current.next.next : current.next;\\n            temp.next = (temp.next != null) ? temp.next.next : temp.next;\\n            current = current.next;\\n            temp = temp.next;\\n        }\\n\\n        return p;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n\\n        current = head\\n\\n        # First pass: Create a new node after each original node\\n        while current:\\n            next_node = current.next\\n            current.next = Node(current.val)\\n            current.next.next = next_node\\n            current = next_node\\n\\n        # Second pass: Connect random pointers for the copied nodes\\n        current = head\\n        while current:\\n            if current.random:\\n                current.next.random = current.random.next\\n            current = current.next.next\\n\\n        # Third pass: Separate the original and copied lists\\n        p = head.next\\n        temp = p\\n        current = head\\n        while current and temp:\\n            current.next = current.next.next if current.next else current.next\\n            temp.next = temp.next.next if temp.next else temp.next\\n            current = current.next\\n            temp = temp.next\\n\\n        return p\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003497,
                "title": "video-solution-with-hashmap-python-javascript-java-c",
                "content": "# Intuition\\nThe main idea to solve the question of copying a linked list with random pointers is to create a deep copy of the original linked list while maintaining the relationships between nodes. By following these steps below, you can create an exact deep copy of the original linked list, including its random pointers, and return the head of the copied list. This approach ensures that you maintain the relationships between nodes while copying the linked list with minimal time and space complexity.\\n\\n---\\n\\n# Solution Video\\n\\n### Please subscribe to my channel from here. I have 255 videos as of September 5th, 2023.\\n\\nhttps://youtu.be/eO8TmVWbcxw\\n\\n### In the video, the steps of approach below are visualized using diagrams and drawings. I\\'m sure you understand the solution easily!\\n\\n### \\u2B50\\uFE0F\\u2B50\\uFE0F Don\\'t forget to subscribe to my channel! \\u2B50\\uFE0F\\u2B50\\uFE0F\\n\\n**\\u25A0 Subscribe URL**\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\n---\\n\\n# Approach\\nThis is based on Python. Other might be different a bit.\\n\\n1. Create a dictionary (`hash`) to map original nodes to their corresponding copied nodes.\\n   - Initialize the dictionary with a mapping of `None` to `None`.\\n\\n2. Traverse the original linked list using a pointer `cur`.\\n   - While `cur` is not `None`:\\n     - Create a new node with the same value as the current node and store it in the dictionary `hash` with the current node as the key.\\n     - Move `cur` to the next node in the original list.\\n\\n3. Reset the `cur` pointer to the head of the original linked list.\\n\\n4. Traverse the original linked list again using `cur`.\\n   - While `cur` is not `None`:\\n     - Retrieve the copied node from the `hash` dictionary using `cur` as the key and store it in the `copy` variable.\\n     - Set the `next` pointer of the `copy` node to the copied node obtained from the `hash` dictionary using `cur.next` as the key.\\n     - Set the `random` pointer of the `copy` node to the copied node obtained from the `hash` dictionary using `cur.random` as the key.\\n     - Move `cur` to the next node in the original list.\\n\\n5. Return the copied head node obtained from the `hash` dictionary using the original head node as the key.\\n\\nThis algorithm first creates a mapping of original nodes to their copied nodes and then iterates through the original list twice to connect the `next` and `random` pointers of the copied nodes. Finally, it returns the head of the copied linked list.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n```python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':    \\n        hash = {None:None}\\n        cur = head\\n        \\n        while cur:\\n            hash[cur] = Node(cur.val)\\n            cur = cur.next\\n            \\n        cur = head\\n        \\n        while cur:\\n            copy = hash[cur]\\n            copy.next = hash[cur.next]\\n            copy.random = hash[cur.random]\\n            cur = cur.next\\n            \\n        return hash[head]\\n```\\n```javascript []\\nvar copyRandomList = function(head) {\\n    const hashMap = new Map();\\n    let cur = head;\\n\\n    while (cur) {\\n        hashMap.set(cur, new Node(cur.val));\\n        cur = cur.next;\\n    }\\n\\n    cur = head;\\n\\n    while (cur) {\\n        const copy = hashMap.get(cur);\\n        copy.next = hashMap.get(cur.next) || null;\\n        copy.random = hashMap.get(cur.random) || null;\\n        cur = cur.next;\\n    }\\n\\n    return hashMap.get(head);   \\n};\\n```\\n```java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Map<Node, Node> hashMap = new HashMap<>();\\n        Node cur = head;\\n\\n        while (cur != null) {\\n            hashMap.put(cur, new Node(cur.val));\\n            cur = cur.next;\\n        }\\n\\n        cur = head;\\n\\n        while (cur != null) {\\n            Node copy = hashMap.get(cur);\\n            copy.next = hashMap.get(cur.next);\\n            copy.random = hashMap.get(cur.random);\\n            cur = cur.next;\\n        }\\n\\n        return hashMap.get(head);        \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        std::unordered_map<Node*, Node*> hashMap;\\n        Node* cur = head;\\n\\n        while (cur) {\\n            hashMap[cur] = new Node(cur->val);\\n            cur = cur->next;\\n        }\\n\\n        cur = head;\\n\\n        while (cur) {\\n            Node* copy = hashMap[cur];\\n            copy->next = hashMap[cur->next];\\n            copy->random = hashMap[cur->random];\\n            cur = cur->next;\\n        }\\n\\n        return hashMap[head];        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```python []\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':    \\n        hash = {None:None}\\n        cur = head\\n        \\n        while cur:\\n            hash[cur] = Node(cur.val)\\n            cur = cur.next\\n            \\n        cur = head\\n        \\n        while cur:\\n            copy = hash[cur]\\n            copy.next = hash[cur.next]\\n            copy.random = hash[cur.random]\\n            cur = cur.next\\n            \\n        return hash[head]\\n```\n```javascript []\\nvar copyRandomList = function(head) {\\n    const hashMap = new Map();\\n    let cur = head;\\n\\n    while (cur) {\\n        hashMap.set(cur, new Node(cur.val));\\n        cur = cur.next;\\n    }\\n\\n    cur = head;\\n\\n    while (cur) {\\n        const copy = hashMap.get(cur);\\n        copy.next = hashMap.get(cur.next) || null;\\n        copy.random = hashMap.get(cur.random) || null;\\n        cur = cur.next;\\n    }\\n\\n    return hashMap.get(head);   \\n};\\n```\n```java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Map<Node, Node> hashMap = new HashMap<>();\\n        Node cur = head;\\n\\n        while (cur != null) {\\n            hashMap.put(cur, new Node(cur.val));\\n            cur = cur.next;\\n        }\\n\\n        cur = head;\\n\\n        while (cur != null) {\\n            Node copy = hashMap.get(cur);\\n            copy.next = hashMap.get(cur.next);\\n            copy.random = hashMap.get(cur.random);\\n            cur = cur.next;\\n        }\\n\\n        return hashMap.get(head);        \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        std::unordered_map<Node*, Node*> hashMap;\\n        Node* cur = head;\\n\\n        while (cur) {\\n            hashMap[cur] = new Node(cur->val);\\n            cur = cur->next;\\n        }\\n\\n        cur = head;\\n\\n        while (cur) {\\n            Node* copy = hashMap[cur];\\n            copy->next = hashMap[cur->next];\\n            copy->random = hashMap[cur->random];\\n            cur = cur->next;\\n        }\\n\\n        return hashMap[head];        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 136000,
                "title": "clean-javascript-solution-using-hashmap",
                "content": "```js\\nfunction copyRandomList(head) {\\n  const map = new Map();\\n  \\n  function copy(node)   {\\n    if (node == null) return null;\\n    if (map.get(node) != null) return map.get(node);\\n\\n    const n = new Node(node.val);\\n    map.set(node, n);\\n\\n    n.next = copy(node.next);\\n    n.random = copy(node.random);\\n    return n;\\n  }\\n\\n  return copy(head);\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction copyRandomList(head) {\\n  const map = new Map();\\n  \\n  function copy(node)   {\\n    if (node == null) return null;\\n    if (map.get(node) != null) return map.get(node);\\n\\n    const n = new Node(node.val);\\n    map.set(node, n);\\n\\n    n.next = copy(node.next);\\n    n.random = copy(node.random);\\n    return n;\\n  }\\n\\n  return copy(head);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43714,
                "title": "accepted-c-solution-rt-o-n-sp-o-1",
                "content": "    struct RandomListNode *copyRandomList(struct RandomListNode *head) {\\n    \\tif(NULL==head) return head;\\n    \\n    \\tstruct RandomListNode *p=head;\\n    \\tstruct RandomListNode *pt;\\n\\n    \\t//copy\\n    \\twhile(NULL!=p){\\n    \\t\\tpt=p->next;\\n    \\t\\tp->next=malloc(sizeof(struct RandomListNode));\\n    \\t\\tp->next->label=p->label;\\n    \\t\\tp->next->next=pt;\\n    \\t\\tp->next->random=NULL; \\n    \\t\\tp=pt;\\n    \\t};\\n\\n    \\t//fix random pointer\\n    \\tp=head;\\n    \\twhile(NULL!=p){\\n    \\t\\tif(NULL!=p->random){\\n    \\t\\t\\tp->next->random=p->random->next;\\n    \\t\\t}\\n    \\t\\tp=p->next->next;\\n    \\t};\\n\\n    \\t//separate\\n    \\tstruct RandomListNode *copyed_head=NULL;\\n    \\tp=head;\\n    \\twhile(NULL!=p){\\n    \\t\\tif(NULL!=copyed_head){\\n    \\t\\t\\tpt->next=p->next;\\n    \\t\\t\\tpt=pt->next;\\n    \\t\\t}else{\\n    \\t\\t\\tcopyed_head=p->next;\\n    \\t\\t\\tpt=copyed_head;\\n    \\t\\t}\\n    \\t\\tp->next=p->next->next;\\n    \\t\\tp=p->next;\\n    \\t};\\n    \\n    \\treturn copyed_head;\\n    }\\n\\nWell, someone already share this idea.\\n\\n - step 1:copy each node and append it to the original one;\\n - step 2:iterate the new list and fix the random pointers\\n - step 3:separate the list.",
                "solutionTags": [],
                "code": "    struct RandomListNode *copyRandomList(struct RandomListNode *head) {\\n    \\tif(NULL==head) return head;\\n    \\n    \\tstruct RandomListNode *p=head;\\n    \\tstruct RandomListNode *pt;\\n\\n    \\t//copy\\n    \\twhile(NULL!=p){\\n    \\t\\tpt=p->next;\\n    \\t\\tp->next=malloc(sizeof(struct RandomListNode));\\n    \\t\\tp->next->label=p->label;\\n    \\t\\tp->next->next=pt;\\n    \\t\\tp->next->random=NULL; \\n    \\t\\tp=pt;\\n    \\t};\\n\\n    \\t//fix random pointer\\n    \\tp=head;\\n    \\twhile(NULL!=p){\\n    \\t\\tif(NULL!=p->random){\\n    \\t\\t\\tp->next->random=p->random->next;\\n    \\t\\t}\\n    \\t\\tp=p->next->next;\\n    \\t};\\n\\n    \\t//separate\\n    \\tstruct RandomListNode *copyed_head=NULL;\\n    \\tp=head;\\n    \\twhile(NULL!=p){\\n    \\t\\tif(NULL!=copyed_head){\\n    \\t\\t\\tpt->next=p->next;\\n    \\t\\t\\tpt=pt->next;\\n    \\t\\t}else{\\n    \\t\\t\\tcopyed_head=p->next;\\n    \\t\\t\\tpt=copyed_head;\\n    \\t\\t}\\n    \\t\\tp->next=p->next->next;\\n    \\t\\tp=p->next;\\n    \\t};\\n    \\n    \\treturn copyed_head;\\n    }\\n\\nWell, someone already share this idea.\\n\\n - step 1:copy each node and append it to the original one;\\n - step 2:iterate the new list and fix the random pointers\\n - step 3:separate the list.",
                "codeTag": "Unknown"
            },
            {
                "id": 1841654,
                "title": "visual-python-easy-to-understand-o-n-time-o-n-space",
                "content": "\\uD83D\\uDD3A **Please UPVOTE: Can we hit 10?** \\uD83D\\uDD3A\\n\\n**Approach**\\nWe use a dictionary to store the original list nodes as keys. Then we create the new nodes as the dictionary values. This way we can lookup the new node given the old node and perform any operations on the new node at the same time.\\n\\n![image](https://assets.leetcode.com/users/images/0115d285-2273-47e7-b29d-34a52bb20b68_1647068325.1311626.png)\\n\\n\\n**Code**\\nSee the code below related to the visual above.\\n<iframe src=\"https://leetcode.com/playground/h6HY3aBo/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n\\uD83D\\uDD3A **Please UPVOTE: Can we hit 10?** \\uD83D\\uDD3A\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "\\uD83D\\uDD3A **Please UPVOTE: Can we hit 10?** \\uD83D\\uDD3A\\n\\n**Approach**\\nWe use a dictionary to store the original list nodes as keys. Then we create the new nodes as the dictionary values. This way we can lookup the new node given the old node and perform any operations on the new node at the same time.\\n\\n![image](https://assets.leetcode.com/users/images/0115d285-2273-47e7-b29d-34a52bb20b68_1647068325.1311626.png)\\n\\n\\n**Code**\\nSee the code below related to the visual above.\\n<iframe src=\"https://leetcode.com/playground/h6HY3aBo/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n\\uD83D\\uDD3A **Please UPVOTE: Can we hit 10?** \\uD83D\\uDD3A\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 43632,
                "title": "java-very-simple-and-clean-solution-with-o-n-time-o-1-space-with-algorithm",
                "content": " \\n/* Algorithm  \\n\\n1) Create the copy of node 1 and insert it between node 1 & node 2 in original Linked List, create the copy of 2 and insert    it between 2 & 3.. Continue in this fashion, add the copy of N after the Nth node\\n    \\n 2)  Now copy the random link in this fashion\\n           \\n       original->next->random = original->random->next;\\n        \\nThis works because original->next is nothing but copy of original and Original->random->next is nothing but copy of random.\\n     \\n3) Now restore the original and copy linked lists in this fashion in a single loop.\\n         \\n       original->next = original->next->next;  \\n       copy->next = copy->next->next;\\n     \\n4) Make sure that last element of original->next is NULL.\\n */\\n\\n\\n\\npublic class Solution {\\n\\n\\n    public RandomListNode copyRandomList(RandomListNode head) {\\n        if(head == null) return head;\\n        \\n        RandomListNode original=head;\\n        RandomListNode curOriginal=head;\\n        \\n        // step 1\\n        while(original.next != null ){\\n            RandomListNode copy=new RandomListNode(original.label);\\n            RandomListNode temp=original.next;\\n            original.next=copy;\\n            copy.next=temp;\\n            original=original.next.next;\\n        }\\n        original.next=new RandomListNode(original.label);\\n        \\n        //step 2\\n        while(curOriginal!= null && curOriginal.next != null){\\n            if(curOriginal.random != null){\\n                curOriginal.next.random=curOriginal.random.next;\\n            }\\n            curOriginal=curOriginal.next.next;\\n        }\\n        \\n        //step 3 and 4\\n        RandomListNode orig=head;\\n        RandomListNode copyCur=head.next;\\n        RandomListNode copyHead=head.next;\\n        \\n        while(orig.next != null && copyCur.next != null){\\n            orig.next=orig.next.next;\\n            copyCur.next=copyCur.next.next;\\n            orig=orig.next;\\n            copyCur=copyCur.next;\\n        }\\n        orig.next=null;\\n        \\n        return copyHead;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n\\n    public RandomListNode copyRandomList(RandomListNode head) {\\n        if(head == null) return head;\\n        \\n        RandomListNode original=head;\\n        RandomListNode curOriginal=head;\\n        \\n        // step 1\\n        while(original.next != null ){\\n            RandomListNode copy=new RandomListNode(original.label);\\n            RandomListNode temp=original.next;\\n            original.next=copy;\\n            copy.next=temp;\\n            original=original.next.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 543309,
                "title": "javascript-solution-90",
                "content": "```\\nvar copyRandomList = function(head) {\\n    if (!head) return null;\\n    let curr = head;\\n    while (curr) {\\n        let copy = new Node(curr.val, curr.next, null);\\n        copy.next = curr.next;\\n        curr.next = copy;\\n        curr = curr.next;\\n        curr = curr.next;\\n    }\\n    \\n    curr = head;\\n    while(curr) {\\n        curr.next.random = curr.random ? curr.random.next : null;\\n        curr = curr.next.next;\\n    }\\n    \\n    curr = head;\\n    let result = head.next;\\n    let resPtr = result;\\n    while(curr) {\\n        curr.next = curr.next.next;\\n        curr = curr.next;\\n        resPtr.next = resPtr.next ? resPtr.next.next : null;\\n        resPtr = resPtr.next;\\n    }\\n    \\n    return result;\\n};\\n```\\n\\nRuntime: 52 ms, faster than 90.76% of JavaScript online submissions for Copy List with Random Pointer.\\nMemory Usage: 35.1 MB, less than 100.00% of JavaScript online submissions for Copy List with Random Pointer.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar copyRandomList = function(head) {\\n    if (!head) return null;\\n    let curr = head;\\n    while (curr) {\\n        let copy = new Node(curr.val, curr.next, null);\\n        copy.next = curr.next;\\n        curr.next = copy;\\n        curr = curr.next;\\n        curr = curr.next;\\n    }\\n    \\n    curr = head;\\n    while(curr) {\\n        curr.next.random = curr.random ? curr.random.next : null;\\n        curr = curr.next.next;\\n    }\\n    \\n    curr = head;\\n    let result = head.next;\\n    let resPtr = result;\\n    while(curr) {\\n        curr.next = curr.next.next;\\n        curr = curr.next;\\n        resPtr.next = resPtr.next ? resPtr.next.next : null;\\n        resPtr = resPtr.next;\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059380,
                "title": "c-explanation-o-1-space-o-n-time-three-pass-easy-solution",
                "content": "**Explanation:** This is the most optimal solution and the logic is **simply rewiring the pointers** to create a mapping between the original linked list and cloned linked list. This can get a bit tricky because while we are utilising the next pointer of the original LL to store the mapping of the cloned linked list, we want to make sure that the original linked list is not affected in any manner. The problem can be divided into three sub-problems\\n\\n**1. Cloning of original linked list:** In this step we are **creating a new node and making it the next of original LL\\'s node.** Then we are pointing this **new node\\'s next to the original LL\\'s node\\'s next.** We are utilising the next pointer to store the cloned node\\'s location. \\n\\n   ![image](https://assets.leetcode.com/users/images/635767b4-ee5c-4837-a3d8-0b335368b467_1613021559.7102857.png)\\n\\n\\n**2. Mapping of random pointers:** Now that we have created our cloned singly linked list, we need to assign the random pointers. For this, again we are gonna use next pointer of both original and cloned LL. Using original node\\'s next and random pointer, we will find the cloned node\\'s random pointer and assign it. \\n\\n   ![image](https://assets.leetcode.com/users/images/0e7d740f-37d2-43ca-ad08-68aac22f81d4_1613022137.5576704.png)\\n   \\n \\n**3. Restoring the original linked list:** Now as you can see in the above diagram, the next pointers of original LL is still connected to the cloned LL. We need to detach these pointers and restore the original LL. For this, create a new node currN and it make it next of temp2. Then assign currN as next of temp. Then iterate the linked list untill temp and temp2 reached NULL. Dry run this step for better understanding.\\n\\nThis solution is inspired by [Back to Back SWE\\'s video explanation](https://youtu.be/OvpKeraoxW0)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return head;\\n        \\n        Node* temp=head;\\n        \\n        //creates mapping of cloned list using original list\\n        while(temp)\\n        {\\n            Node* newNode= new Node(temp->val);\\n            newNode->next=temp->next;\\n            temp->next=newNode;\\n            temp=newNode->next;\\n            \\n        }\\n        \\n        //assigning random pointers\\n        temp=head;\\n        while(temp)\\n        {\\n            if(temp->random)\\n            {\\n               temp->next->random= temp->random->next;   \\n            }\\n            temp=temp->next->next;\\n        }\\n        \\n        //restore the original linked list\\n        Node* newHead= head->next;\\n        Node* temp2=head->next;\\n        temp=head;\\n        \\n        while(temp  && temp2)\\n        {\\n            Node* currN=temp2->next;\\n            temp->next=currN;\\n            if(currN)\\n            {\\n                temp2->next=currN->next;\\n            }\\n            temp=temp->next;\\n            temp2=temp2->next;\\n        }\\n        \\n        return newHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return head;\\n        \\n        Node* temp=head;\\n        \\n        //creates mapping of cloned list using original list\\n        while(temp)\\n        {\\n            Node* newNode= new Node(temp->val);\\n            newNode->next=temp->next;\\n            temp->next=newNode;\\n            temp=newNode->next;\\n            \\n        }\\n        \\n        //assigning random pointers\\n        temp=head;\\n        while(temp)\\n        {\\n            if(temp->random)\\n            {\\n               temp->next->random= temp->random->next;   \\n            }\\n            temp=temp->next->next;\\n        }\\n        \\n        //restore the original linked list\\n        Node* newHead= head->next;\\n        Node* temp2=head->next;\\n        temp=head;\\n        \\n        while(temp  && temp2)\\n        {\\n            Node* currN=temp2->next;\\n            temp->next=currN;\\n            if(currN)\\n            {\\n                temp2->next=currN->next;\\n            }\\n            temp=temp->next;\\n            temp2=temp2->next;\\n        }\\n        \\n        return newHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3561863,
                "title": "awesome-hashmap-concept",
                "content": "# Using Hashmap--->TC:O(N)\\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        dic={None:None}\\n        cur=head\\n        while cur:\\n            dic[cur]=Node(cur.val)\\n            cur=cur.next\\n        cur=head\\n        while cur:\\n            copy=dic[cur]\\n            copy.next=dic[cur.next]\\n            copy.random=dic[cur.random]\\n            cur=cur.next\\n        return dic[head]\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        dic={None:None}\\n        cur=head\\n        while cur:\\n            dic[cur]=Node(cur.val)\\n            cur=cur.next\\n        cur=head\\n        while cur:\\n            copy=dic[cur]\\n            copy.next=dic[cur.next]\\n            copy.random=dic[cur.random]\\n            cur=cur.next\\n        return dic[head]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841437,
                "title": "clean-c-soln-w-explanation-o-n-time-o-1-space-iterative-o-n-time-space-recursive",
                "content": "#### Iterative Solution:\\n\\n**Idea In Brief:** We would want to avoid hashing each and every node in the input list with the corresponding new list nodes. In order to do that, we could traverse the input list once and add a new node with the same node value as input list and modify the list as follows:\\n```\\nInput List: [7]->[13]->[11]->[10]->[1] \\nModified List: [7]-[copy7]->[13]->[copy13]->[11]->[copy11]->[10]->[copy10]->[1]->[copy1]\\n``` \\nOnce we have modified the input list, we could traverse the entire list and update the random pointers for the newly create list nodes. Finally we need to traverse the list to disconnect all the input list nodes and link the new nodes and return the `copyHead` of the new list. It will be better understood with the code:\\n\\n**Code:**\\n```\\n Node* copyRandomList(Node* head) {\\n        if(not head) \\n            return head;\\n// Modifying the input list:\\n        Node *temp = head, *ptr = head;\\n        while(ptr){\\n            temp = ptr->next;\\n            ptr->next = new Node(ptr->val);\\n            ptr->next->next = temp;\\n            ptr = temp;\\n        }\\n// List Updated to: [7]-[copy7]->[13]->[copy13]... \\n\\n//  Updating the random pointers\\n\\tptr = head;\\n    while(ptr){\\n            ptr->next->random = (ptr->random)? ptr->random->next : nullptr;\\n            ptr = ptr->next->next;\\n        }\\n//  Disconnecting to generate cloned list.\\n        Node *copyHead = head->next, *copyptr = head->next;\\n        while(head){\\n            head->next = head->next->next;\\n            copyptr->next = copyptr->next? copyptr->next->next : nullptr;\\n            head = head->next;\\n            copyptr = copyptr->next;\\n        }   \\n     return copyHead; \\n    }\\n```\\nThe above solution is a linear time `O(N)` and constant space solution `O(1)`\\n\\n---\\n\\n#### Recursive Solution\\nThe problem can intuitively be solved using recursion, and using hashing of nodes. Recursive approach is a `O(N) Time and O(N) Space` solution. \\n**Idea In Brief:** We need to traverse the list and maintain a mapping between the old list node and the newly created listnode with corresponding node values. We need to make sure that the entire `input` list is traversed first so that we have access to `input` list\\'s all the nodes, and we can update our `new list\\'s` random pointer. \\n\\n**Code:** \\n```\\n unordered_map<Node*,Node*> mp;\\n    Node *Solve(Node *curr){\\n        if(not curr)\\n            return curr;\\n        Node *newNode = new Node(curr->val);\\n        mp[curr] = newNode;\\n        newNode->next = Solve(curr->next);\\n        newNode->random = mp[curr->random];\\n        \\n        return newNode;\\n    }\\n    Node* copyRandomList(Node* head){\\n        if(not head)\\n            return head;\\n        return Solve(head);\\n    }\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nInput List: [7]->[13]->[11]->[10]->[1] \\nModified List: [7]-[copy7]->[13]->[copy13]->[11]->[copy11]->[10]->[copy10]->[1]->[copy1]\\n```\n```\\n Node* copyRandomList(Node* head) {\\n        if(not head) \\n            return head;\\n// Modifying the input list:\\n        Node *temp = head, *ptr = head;\\n        while(ptr){\\n            temp = ptr->next;\\n            ptr->next = new Node(ptr->val);\\n            ptr->next->next = temp;\\n            ptr = temp;\\n        }\\n// List Updated to: [7]-[copy7]->[13]->[copy13]... \\n\\n//  Updating the random pointers\\n\\tptr = head;\\n    while(ptr){\\n            ptr->next->random = (ptr->random)? ptr->random->next : nullptr;\\n            ptr = ptr->next->next;\\n        }\\n//  Disconnecting to generate cloned list.\\n        Node *copyHead = head->next, *copyptr = head->next;\\n        while(head){\\n            head->next = head->next->next;\\n            copyptr->next = copyptr->next? copyptr->next->next : nullptr;\\n            head = head->next;\\n            copyptr = copyptr->next;\\n        }   \\n     return copyHead; \\n    }\\n```\n```\\n unordered_map<Node*,Node*> mp;\\n    Node *Solve(Node *curr){\\n        if(not curr)\\n            return curr;\\n        Node *newNode = new Node(curr->val);\\n        mp[curr] = newNode;\\n        newNode->next = Solve(curr->next);\\n        newNode->random = mp[curr->random];\\n        \\n        return newNode;\\n    }\\n    Node* copyRandomList(Node* head){\\n        if(not head)\\n            return head;\\n        return Solve(head);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1059384,
                "title": "python-optimal-2-pass-o-1-space-w-diagram-explanation",
                "content": "Should be most optimal since we only need two passes and constant space. Other solutions are either [two passes with O(n) space] or [three passes with O(1) space], so we have the best of both worlds! It\\'s also quite short.\\n\\nInstead of creating a new map, we can use the original linked list as a map instead i.e. we use constant space. Since we don\\'t interleave, we can remove one of the passes in the three-pass algorithms.\\n\\nNB: this method is accepted and passes all tests by creating a true deep copy; however, it also irreversibly modifies the original linked list. \\n\\n##### Approach Summary\\nTwo passes. `A` is a node in the original linked list. `a` is the copy of `A`.\\n- On first pass, create a copy `a` of `A`\\n  - Set `a.val` to match `A.val`\\n  - Set `a.random` to point to `A.random`\\n  - Set `A.next` to point to `a`\\n- On second pass, resolve the `random` pointers in the copied linked list\\n\\t- Set `a.random` to point to `a.random.next`\\n\\n# Code\\n\\n#### Code Only [no comments]\\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        copy = preroot = Node(-1, head, None)\\n\\t\\t\\n        while head:\\n            orig_next = head.next\\n            head.next = copy.next = Node(head.val, None, head.random)\\n            head, copy = orig_next, copy.next\\n        \\n        copy = preroot.next\\n        while copy:\\n            copy.random = copy.random.next if copy.random else None\\n            copy = copy.next\\n            \\n        return preroot.next\\n```\\n\\n#### With comments\\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        copy = preroot = Node(-1, head, None)\\n\\t\\t\\n\\t\\t# first pass: create a copy of linked list\\n        while head:\\n            orig_next = head.next\\n\\t\\t\\t\\n\\t\\t\\t# keep RANDOM pointing to original random node\\n\\t\\t\\tnew_node = Node(head.val, None, head.random)\\n\\t\\t\\t\\n\\t\\t\\t# set NEXT to point to copied node\\n            head.next = copy.next = new_node\\n            \\n\\t\\t\\t# head pointer should move forward in the original linked list\\n            head = orig_next\\n            copy = copy.next\\n        \\n\\t\\t# second pass: resolve RANDOM pointers in copies\\n        copy = preroot.next\\n        while copy:\\n\\t\\t\\t# set RANDOM pointers to nodes in the copied linked list\\n            if copy.random:\\n\\t\\t\\t\\tcopy.random = copy.random.next \\n            copy = copy.next\\n            \\n        return preroot.next\\n```\\n\\n# Explanation\\n\\nWhen creating a copy `a` of  a node `A` in the original linked list, we have four pointers we can work with (`a.next`, `a.random`, `A.next`, `A.random = RA`). Of these, we never modify the `A.random` pointer. `A.next` and `a.random` are the tricky pointers: at some point during our construction, `A.next` will point to a node in the copied linked list and `a.random` will point to a node in the original list (but will eventually point to a node in the copied list). The original linked list is modified and not returned to its original state.\\n\\nWe iterate through the original linked list via `next` and create a copy `a` of each original node `A` maintianing the correct `next` order. This means copying `A.val`. We maintain `next` order by construction.\\n\\nWhile we do this for each node, we also set `a.random` (the `random` pointer of the copied node) to point to `RA = A.random` (the node pointed to by the original node\\'s `random` pointer).\\n\\nBy then setting `A.next = a`, we can later use `A.next` to find which copied node `a` corresponds to the original node `A`. \\n\\nSimilarly, let `ra` be the **desired** node that `a.random` should point to in the copied linked list. After the first pass, given that we set `X.next = x` for all original nodes `X`, we know that `RA.next = ra`. \\n\\nIn other words, on the first pass, we make sure we can get from an original node to its copied node using the original node\\'s `next` pointer. \\n\\nIn this way, we can then update `a.random` to actually point to `a.random.next`, as we resolve `(a.random).next = (A.random).next = RA.next = ra`. So after setting `a.random = a.random.next`, we ultimately end up with `a.random` pointing to `ra` as desired (indirectly, `a.random = ra`).\\n\\nEssentially, we use the original linked list as a dictionary / map instead of creating a new one.\\n\\n# Example in Pictures\\n\\nRed represents a `next` pointer\\nBlue represents a `random` pointer\\n\\n##### Original linked list\\n![image](https://assets.leetcode.com/users/images/b9c12203-93f8-4bda-83ba-6d82f75a5015_1612983331.0993712.png)\\n\\n\\n##### First loop\\n- Copy the original row\\'s black boxes and red lines to a row below\\n- Draw red lines from the top row to the bottom row for nodes with the same letters\\n- Draw dotted blue lines from the bottom row to the top row\\n  - Find the top node with the same letter as the bottom node i.e. with a red line to the bottom node\\n  - Follow the solid blue line of the top node\\n  - Draw a dotted blue line from the bottom node to the end of the solid blue line that starts from the top node\\n- All blue lines should point to nodes in the top row\\n  - e.g. all `random` pointers should point to nodes in the original linked list\\n\\n![image](https://assets.leetcode.com/users/images/1f76d1a9-3b19-4fb0-b522-7a9a61a92a01_1612983346.0374637.png)\\n\\n\\n##### Second loop\\n- For each node in the bottom row, follow the dotted blue lines to a node in the top row, then follow the top row node\\'s red line to get to a bottom node. Update the dotted blue line so that it points to the node at the end of this path in the bottom row\\n  - e.g. all `random` pointers in the copied linked list should be resolved to nodes in the copied linked list\\n\\n![image](https://assets.leetcode.com/users/images/b4bc023e-1808-498c-acef-6fcecf4cec55_1612983353.7213051.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        copy = preroot = Node(-1, head, None)\\n\\t\\t\\n        while head:\\n            orig_next = head.next\\n            head.next = copy.next = Node(head.val, None, head.random)\\n            head, copy = orig_next, copy.next\\n        \\n        copy = preroot.next\\n        while copy:\\n            copy.random = copy.random.next if copy.random else None\\n            copy = copy.next\\n            \\n        return preroot.next\\n```\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        copy = preroot = Node(-1, head, None)\\n\\t\\t\\n\\t\\t# first pass: create a copy of linked list\\n        while head:\\n            orig_next = head.next\\n\\t\\t\\t\\n\\t\\t\\t# keep RANDOM pointing to original random node\\n\\t\\t\\tnew_node = Node(head.val, None, head.random)\\n\\t\\t\\t\\n\\t\\t\\t# set NEXT to point to copied node\\n            head.next = copy.next = new_node\\n            \\n\\t\\t\\t# head pointer should move forward in the original linked list\\n            head = orig_next\\n            copy = copy.next\\n        \\n\\t\\t# second pass: resolve RANDOM pointers in copies\\n        copy = preroot.next\\n        while copy:\\n\\t\\t\\t# set RANDOM pointers to nodes in the copied linked list\\n            if copy.random:\\n\\t\\t\\t\\tcopy.random = copy.random.next \\n            copy = copy.next\\n            \\n        return preroot.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43577,
                "title": "my-short-python-solution-with-o-n-complex-using-collections-defaultdict",
                "content": "    def factory():\\n    \\treturn RandomListNode(0)\\n    \\n    class Solution:\\n    \\t# @param head, a RandomListNode\\n    \\t# @return a RandomListNode\\n    \\tdef copyRandomList(self, head):\\n    \\t\\tif not head:\\n    \\t\\t\\treturn None\\n    \\t\\ttemp = head\\n    \\t\\tnode_map =collections.defaultdict(factory)\\n    \\t\\tnode_map[None] = None # avoid None as key to generate a RandomListNode\\n    \\t\\twhile temp:\\n    \\t\\t\\tnode_map[temp].label = temp.label\\n    \\t\\t\\tnode_map[temp].next = node_map[temp.next]\\n    \\t\\t\\tnode_map[temp].random = node_map[temp.random]\\n    \\t\\t\\ttemp = temp.next\\n    \\t\\tdel node_map[None]\\n    \\t\\treturn node_map[head]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def factory():\\n    \\treturn RandomListNode(0)\\n    \\n    class Solution:\\n    \\t# @param head, a RandomListNode\\n    \\t# @return a RandomListNode\\n    \\tdef copyRandomList(self, head):\\n    \\t\\tif not head:\\n    \\t\\t\\treturn None\\n    \\t\\ttemp = head\\n    \\t\\tnode_map =collections.defaultdict(factory)\\n    \\t\\tnode_map[None] = None # avoid None as key to generate a RandomListNode\\n    \\t\\twhile temp:\\n    \\t\\t\\tnode_map[temp].label = temp.label\\n    \\t\\t\\tnode_map[temp].next = node_map[temp.next]\\n    \\t\\t\\tnode_map[temp].random = node_map[temp.random]\\n    \\t\\t\\ttemp = temp.next\\n    \\t\\tdel node_map[None]\\n    \\t\\treturn node_map[head]",
                "codeTag": "Java"
            },
            {
                "id": 1938497,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for a Node.\\n * public class Node {\\n *     public var val: Int\\n *     public var next: Node?\\n *     public var random: Node?\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.next = nil\\n *    \\t   self.random = nil\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func copyRandomList(_ head: Node?) -> Node? {\\n        guard let head = head else { return nil }\\n        \\n        var cur: Node? = head\\n        while let val = cur?.val {\\n            var newNode = Node(val)\\n            newNode.next = cur?.next\\n            cur?.next = newNode\\n            cur = newNode.next\\n        }\\n        \\n        cur = head\\n        while cur != nil {\\n            cur?.next?.random = cur?.random?.next\\n            cur = cur?.next?.next\\n        }\\n        \\n        var oldList: Node? = head\\n        var newList = head.next\\n        let headOld = head.next\\n        \\n        while oldList != nil {\\n            oldList?.next = oldList?.next?.next\\n            newList?.next = newList?.next?.next\\n            oldList = oldList?.next\\n            newList = newList?.next\\n        }\\n        return headOld\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * public class Node {\\n *     public var val: Int\\n *     public var next: Node?\\n *     public var random: Node?\\n *     public init(_ val: Int) {\\n *         self.val = val\\n *         self.next = nil\\n *    \\t   self.random = nil\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func copyRandomList(_ head: Node?) -> Node? {\\n        guard let head = head else { return nil }\\n        \\n        var cur: Node? = head\\n        while let val = cur?.val {\\n            var newNode = Node(val)\\n            newNode.next = cur?.next\\n            cur?.next = newNode\\n            cur = newNode.next\\n        }\\n        \\n        cur = head\\n        while cur != nil {\\n            cur?.next?.random = cur?.random?.next\\n            cur = cur?.next?.next\\n        }\\n        \\n        var oldList: Node? = head\\n        var newList = head.next\\n        let headOld = head.next\\n        \\n        while oldList != nil {\\n            oldList?.next = oldList?.next?.next\\n            newList?.next = newList?.next?.next\\n            oldList = oldList?.next\\n            newList = newList?.next\\n        }\\n        return headOld\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864305,
                "title": "python-3-two-methods-recursive-iterative-explanation",
                "content": "### Approach \\\\#1. Iterative\\n- Use hash table to store information `{original_node: new_node}`\\n- Two pass\\n\\t- First create new node and connect with `next`\\n\\t- Second use hash table to connect `random` node\\n- Time: `O(n)`; Space: `O(n)`\\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        d = {None:None}\\n        dummy = Node(-1)\\n        cur, new_cur = head, dummy\\n        while cur:\\n            new_cur.next = d[cur] = Node(cur.val)\\n            cur, new_cur = cur.next, new_cur.next\\n        cur, new_cur = head, dummy.next\\n        while cur:\\n            new_cur.random = d[cur.random]\\n            cur, new_cur = cur.next, new_cur.next\\n        return dummy.next    \\n```\\n### Approach \\\\#2. Recursive\\n- Recursively create copy of each node and connect their random nodes\\n- Time: `O(n)`; Space: `O(n)`\\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        d = dict()\\n        def deep_copy(node):\\n            if not node: return\\n            if node in d: return d[node]\\n            d[node] = n = Node(node.val)\\n            n.next = deep_copy(node.next)\\n            n.random = deep_copy(node.random)\\n            return n\\n        return deep_copy(head)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        d = {None:None}\\n        dummy = Node(-1)\\n        cur, new_cur = head, dummy\\n        while cur:\\n            new_cur.next = d[cur] = Node(cur.val)\\n            cur, new_cur = cur.next, new_cur.next\\n        cur, new_cur = head, dummy.next\\n        while cur:\\n            new_cur.random = d[cur.random]\\n            cur, new_cur = cur.next, new_cur.next\\n        return dummy.next    \\n```\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        d = dict()\\n        def deep_copy(node):\\n            if not node: return\\n            if node in d: return d[node]\\n            d[node] = n = Node(node.val)\\n            n.next = deep_copy(node.next)\\n            n.random = deep_copy(node.random)\\n            return n\\n        return deep_copy(head)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752807,
                "title": "c-o-n-o-1-in-three-steps-explained",
                "content": "THREE STEPS:\\n**(I)CONSTRUCTING THE NEW LIST WITH THE CURRENT VALUE AND THE NEXT VALUE WITH RANDOM SET AS NULL\\n(II)SETTING THE PREVIOUS NODE VALUE AT THIS STEP\\n(III) INORDER TO RETURN THE VALUES FROM THE NEW LIST WE NEED TO ARRANGE IT SUCH THAT PROPER ORDER WE CAN RETURN **\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head)\\n            return NULL;\\n        Node* head_cp = NULL;\\n        Node* curr = head;\\n        Node* curr_cp = NULL;\\n//(I)CONSTRUCTING THE NEW LIST WITH THE CURRENT VALUE AND THE NEXT VALUE WITH RANDOM SET AS NULL\\n        while(curr!=NULL){\\n            curr_cp = new Node(curr->val,curr->next,NULL);\\n            curr->next = curr_cp;\\n            curr = curr_cp->next;\\n        }\\n//(II)SETTING THE PREVIOUS NODE VALUE AT THIS STEP\\n        curr = head;\\n        while(curr!=NULL){\\n            curr_cp = curr->next;\\n            if(curr->random)\\n                curr_cp->random = curr->random->next;\\n            curr = curr_cp->next;\\n        }\\n//(III) INORDER TO RETURN THE VALUES FROM THE NEW LIST WE NEED TO ARRANGE IT SUCH THAT PROPER ORDER WE CAN RETURN \\n        curr = head;\\n        head_cp = head->next;\\n        while(curr!=NULL){\\n            curr_cp = curr->next;\\n            curr->next = curr_cp->next; // making the question\\'s list back to normal\\n            curr = curr->next;\\n            if(curr)\\n                curr_cp->next = curr->next;\\n        }\\n        return head_cp;\\n    }\\n};\\n```\\nIF THIS SOLUTION HELPS, THEN DON\\'T FORGET TO UPVOTE. :D",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head)\\n            return NULL;\\n        Node* head_cp = NULL;\\n        Node* curr = head;\\n        Node* curr_cp = NULL;\\n//(I)CONSTRUCTING THE NEW LIST WITH THE CURRENT VALUE AND THE NEXT VALUE WITH RANDOM SET AS NULL\\n        while(curr!=NULL){\\n            curr_cp = new Node(curr->val,curr->next,NULL);\\n            curr->next = curr_cp;\\n            curr = curr_cp->next;\\n        }\\n//(II)SETTING THE PREVIOUS NODE VALUE AT THIS STEP\\n        curr = head;\\n        while(curr!=NULL){\\n            curr_cp = curr->next;\\n            if(curr->random)\\n                curr_cp->random = curr->random->next;\\n            curr = curr_cp->next;\\n        }\\n//(III) INORDER TO RETURN THE VALUES FROM THE NEW LIST WE NEED TO ARRANGE IT SUCH THAT PROPER ORDER WE CAN RETURN \\n        curr = head;\\n        head_cp = head->next;\\n        while(curr!=NULL){\\n            curr_cp = curr->next;\\n            curr->next = curr_cp->next; // making the question\\'s list back to normal\\n            curr = curr->next;\\n            if(curr)\\n                curr_cp->next = curr->next;\\n        }\\n        return head_cp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 689730,
                "title": "javascript-solution",
                "content": "```js\\n/**\\n * // Definition for a Node.\\n * function Node(val, next, random) {\\n *    this.val = val;\\n *    this.next = next;\\n *    this.random = random;\\n * };\\n */\\n\\n/**\\n * @param {Node} head\\n * @return {Node}\\n */\\nvar copyRandomList = function(head) {\\n    const map = new Map([[null, null]]);\\n    \\n    let node = head;\\n    \\n    while (node) {\\n        map.set(node, new Node(node.val, null, null));\\n        node = node.next;\\n    }\\n    \\n    node = head;\\n    \\n    while (node) {\\n        const newNode = map.get(node);\\n        newNode.next = map.get(node.next);\\n        newNode.random = map.get(node.random);\\n        node = node.next;\\n    }\\n\\n    return map.get(head);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * // Definition for a Node.\\n * function Node(val, next, random) {\\n *    this.val = val;\\n *    this.next = next;\\n *    this.random = random;\\n * };\\n */\\n\\n/**\\n * @param {Node} head\\n * @return {Node}\\n */\\nvar copyRandomList = function(head) {\\n    const map = new Map([[null, null]]);\\n    \\n    let node = head;\\n    \\n    while (node) {\\n        map.set(node, new Node(node.val, null, null));\\n        node = node.next;\\n    }\\n    \\n    node = head;\\n    \\n    while (node) {\\n        const newNode = map.get(node);\\n        newNode.next = map.get(node.next);\\n        newNode.random = map.get(node.random);\\n        node = node.next;\\n    }\\n\\n    return map.get(head);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1841132,
                "title": "c-clean-and-concise-with-recursion",
                "content": "Using recursion to create all node and put it into `hash map`. After create all node, we can get the random node.\\n```C++\\nclass Solution {\\nprivate:\\n    unordered_map<Node *, Node *> map;\\npublic:\\n    Node *copyRandomList(Node *head, Node *result = nullptr) {\\n        if (!head) return head;\\n        result = new Node(head->val);\\n        map[head] = result;\\n        result->next = copyRandomList(head->next, result->next);\\n        result->random = map[head->random];\\n        return result;\\n    }\\n};\\n```\\nTime complexity: `O(n)` \\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```C++\\nclass Solution {\\nprivate:\\n    unordered_map<Node *, Node *> map;\\npublic:\\n    Node *copyRandomList(Node *head, Node *result = nullptr) {\\n        if (!head) return head;\\n        result = new Node(head->val);\\n        map[head] = result;\\n        result->next = copyRandomList(head->next, result->next);\\n        result->random = map[head->random];\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1227276,
                "title": "my-c-simple-solution-without-hashmap",
                "content": "UPVOTE IF IT HELPS\\n```\\nNode* copyRandomList(Node* head) {\\n        if(!head) return NULL;\\n        Node* newHead, *copyNode, *temp= head;\\n        \\n        //step 1. create copy node in between original node which helps to connect random node of copy node.\\n        while(temp)\\n        {\\n            copyNode = new Node(temp->val);\\n            copyNode->next = temp->next;\\n            temp->next = copyNode;\\n            temp = copyNode->next;\\n        }\\n        //result - 7 -> 7 -> 13 -> 13 -> 11 -> 11 -> 10 -> 10 -> 1 -> 1 -> NULL\\n        \\n        newHead = head->next;\\n        temp = head;\\n        \\n        //step 2. now copyNode->random lie just after original->randomNode.\\n        while(temp)\\n        {\\n            if(temp->random == NULL)\\n                temp->next->random = NULL;\\n            \\n            else \\n                temp->next->random = temp->random->next;\\n            \\n            temp = temp->next->next;\\n        }\\n        //result-  Nodes copied successfully. Now we just need to seprate them.\\n        temp = head;\\n        \\n        //step 3. separating copy Node from original Nodes\\n        while(temp)\\n        {\\n            copyNode = temp->next;\\n            temp->next = copyNode->next;\\n            \\n            if(copyNode->next)\\n                copyNode->next = copyNode->next->next;\\n            \\n            temp = temp->next;\\n        }\\n        \\n        return newHead;\\n    }",
                "solutionTags": [],
                "code": "UPVOTE IF IT HELPS\\n```\\nNode* copyRandomList(Node* head) {\\n        if(!head) return NULL;\\n        Node* newHead, *copyNode, *temp= head;\\n        \\n        //step 1. create copy node in between original node which helps to connect random node of copy node.\\n        while(temp)\\n        {\\n            copyNode = new Node(temp->val);\\n            copyNode->next = temp->next;\\n            temp->next = copyNode;\\n            temp = copyNode->next;\\n        }\\n        //result - 7 -> 7 -> 13 -> 13 -> 11 -> 11 -> 10 -> 10 -> 1 -> 1 -> NULL\\n        \\n        newHead = head->next;\\n        temp = head;\\n        \\n        //step 2. now copyNode->random lie just after original->randomNode.\\n        while(temp)\\n        {\\n            if(temp->random == NULL)\\n                temp->next->random = NULL;\\n            \\n            else \\n                temp->next->random = temp->random->next;\\n            \\n            temp = temp->next->next;\\n        }\\n        //result-  Nodes copied successfully. Now we just need to seprate them.\\n        temp = head;\\n        \\n        //step 3. separating copy Node from original Nodes\\n        while(temp)\\n        {\\n            copyNode = temp->next;\\n            temp->next = copyNode->next;\\n            \\n            if(copyNode->next)\\n                copyNode->next = copyNode->next->next;\\n            \\n            temp = temp->next;\\n        }\\n        \\n        return newHead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1058990,
                "title": "c-simple-recursive-and-iterative-solutions-faster-than-90",
                "content": "**Recursive:**\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) return NULL;\\n        if (m[head]) return m[head];\\n        m[head] = new Node(head->val);\\n        m[head]->next = copyRandomList(head->next);\\n        m[head]->random = copyRandomList(head->random);\\n        return m[head];\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> m;\\n};\\n```\\n**Iterative:**\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) return NULL;\\n        Node *ptr = head, *new_head = new Node(0), *new_ptr = new_head;\\n        while (ptr) {\\n            new_ptr->next = new Node(ptr->val);\\n            m[ptr] = new_ptr->next;\\n            ptr = ptr->next;\\n            new_ptr = new_ptr->next;\\n        }\\n        ptr = head;\\n        while (ptr) {\\n            if (ptr->random)\\n                m[ptr]->random = m[ptr->random];\\n            ptr = ptr->next;\\n\\n        }\\n        return new_head->next;\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> m;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) return NULL;\\n        if (m[head]) return m[head];\\n        m[head] = new Node(head->val);\\n        m[head]->next = copyRandomList(head->next);\\n        m[head]->random = copyRandomList(head->random);\\n        return m[head];\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> m;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) return NULL;\\n        Node *ptr = head, *new_head = new Node(0), *new_ptr = new_head;\\n        while (ptr) {\\n            new_ptr->next = new Node(ptr->val);\\n            m[ptr] = new_ptr->next;\\n            ptr = ptr->next;\\n            new_ptr = new_ptr->next;\\n        }\\n        ptr = head;\\n        while (ptr) {\\n            if (ptr->random)\\n                m[ptr]->random = m[ptr->random];\\n            ptr = ptr->next;\\n\\n        }\\n        return new_head->next;\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> m;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 757913,
                "title": "python-100-recursive-deepcopy",
                "content": "**Python 100% | Recursive Deepcopy**\\n\\nTraditional implementation of a Python \"deepcopy\" function using recursion. The key to this problem is that we can return a Node (with a basic initialization), and fix its properties later :)\\n\\nI hope the code is helpful.\\nCheers,\\n\\n```\\nclass Solution:\\n    def copyRandomList(self, head): # -> \\'Node\\':\\n        memo = {}\\n        def deepcopy(n):\\n            # Trivial Returns\\n            if not n:\\n                return\\n            if n in memo:\\n                return memo[n]\\n            #\\n            # Create node and register it immediately (to break cycles)\\n            memo[n] = new = Node( n.val )\\n            #\\n            # Fix Node Properties\\n            new.next   = deepcopy(n.next  )\\n            new.random = deepcopy(n.random)\\n            return new\\n        return deepcopy(head)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head): # -> \\'Node\\':\\n        memo = {}\\n        def deepcopy(n):\\n            # Trivial Returns\\n            if not n:\\n                return\\n            if n in memo:\\n                return memo[n]\\n            #\\n            # Create node and register it immediately (to break cycles)\\n            memo[n] = new = Node( n.val )\\n            #\\n            # Fix Node Properties\\n            new.next   = deepcopy(n.next  )\\n            new.random = deepcopy(n.random)\\n            return new\\n        return deepcopy(head)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 632977,
                "title": "c-solution",
                "content": "**Approach 1**\\n- Time: O(n)\\n- Space: O(n)\\n\\n```\\npublic class Solution {\\n    public Node CopyRandomList(Node head) {\\n        \\n        if(head == null)\\n            return null;\\n        \\n        Dictionary<Node, Node> dic = new Dictionary<Node, Node>();\\n        \\n        // Deep copy nodes for values\\n        Node curr = head;\\n        while(curr != null)\\n        {\\n            dic.Add(curr, new Node(curr.val, null, null));\\n            curr = curr.next;\\n        }\\n        \\n        // Deep copy nodes for pointers\\n        curr = head;\\n        while(curr != null)\\n        {\\n            // key of dictionary can\\'t be null\\n            dic[curr].next = curr.next == null? null : dic[curr.next];\\n            dic[curr].random = curr.random == null? null : dic[curr.random];\\n            curr = curr.next;\\n        }\\n        \\n        return dic[head];\\n    }\\n}\\n```\\n\\n**Approach 2**\\n- Time: O(n): 3 passes\\n- Space: O(1)\\n```\\npublic class Solution {\\n    public Node CopyRandomList(Node head) {\\n        \\n        if(head == null)\\n            return null;\\n        \\n        // linked each node to its copy. 1 -> 1\\' -> 2 -> 2\\' -> 3 -> 3\\'\\n        Node curr = head;\\n        while(curr != null)\\n        {\\n            Node next = curr.next;          \\n            curr.next = new Node(curr.val);\\n            curr.next.next = next;\\n            \\n            curr = next;\\n        }\\n        \\n        // set random pointers for the copy nodes\\n        curr = head;\\n        while(curr != null)\\n        {\\n            if(curr.random != null)\\n                curr.next.random = curr.random.next;\\n            curr = curr.next.next;\\n        }\\n        \\n        // seperate copy linkedList from the original linkedList\\n        Node dummyHead = head.next;\\n        curr = head;\\n        Node curr2 = dummyHead;\\n        while(curr2.next != null)\\n        {    \\n            curr.next = curr.next.next;\\n            curr = curr.next;\\n            \\n            curr2.next = curr2.next.next;\\n            curr2 = curr2.next;\\n        }\\n        \\n        // handle the last original node\\n        curr.next = null;\\n        \\n        return dummyHead;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public Node CopyRandomList(Node head) {\\n        \\n        if(head == null)\\n            return null;\\n        \\n        Dictionary<Node, Node> dic = new Dictionary<Node, Node>();\\n        \\n        // Deep copy nodes for values\\n        Node curr = head;\\n        while(curr != null)\\n        {\\n            dic.Add(curr, new Node(curr.val, null, null));\\n            curr = curr.next;\\n        }\\n        \\n        // Deep copy nodes for pointers\\n        curr = head;\\n        while(curr != null)\\n        {\\n            // key of dictionary can\\'t be null\\n            dic[curr].next = curr.next == null? null : dic[curr.next];\\n            dic[curr].random = curr.random == null? null : dic[curr.random];\\n            curr = curr.next;\\n        }\\n        \\n        return dic[head];\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public Node CopyRandomList(Node head) {\\n        \\n        if(head == null)\\n            return null;\\n        \\n        // linked each node to its copy. 1 -> 1\\' -> 2 -> 2\\' -> 3 -> 3\\'\\n        Node curr = head;\\n        while(curr != null)\\n        {\\n            Node next = curr.next;          \\n            curr.next = new Node(curr.val);\\n            curr.next.next = next;\\n            \\n            curr = next;\\n        }\\n        \\n        // set random pointers for the copy nodes\\n        curr = head;\\n        while(curr != null)\\n        {\\n            if(curr.random != null)\\n                curr.next.random = curr.random.next;\\n            curr = curr.next.next;\\n        }\\n        \\n        // seperate copy linkedList from the original linkedList\\n        Node dummyHead = head.next;\\n        curr = head;\\n        Node curr2 = dummyHead;\\n        while(curr2.next != null)\\n        {    \\n            curr.next = curr.next.next;\\n            curr = curr.next;\\n            \\n            curr2.next = curr2.next.next;\\n            curr2 = curr2.next;\\n        }\\n        \\n        // handle the last original node\\n        curr.next = null;\\n        \\n        return dummyHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 259563,
                "title": "detailed-explanation-constant-space-c-javascript",
                "content": "The HashMap based solution can be found [here](https://leetcode.com/problems/copy-list-with-random-pointer/discuss/258935/Detailed-Explanation-with-Pictures-C%2B%2BJavaScript)\\n\\n**Intuition**\\n* As discussed in the above link, the only thing forcing us to use extra space is the fact that we need a mapping from the old node to the new node counterpart (The vertical threading). Now, can we overcome this? (Of course, we would still need a mapping).\\n* The idea is to clone the nodes such the cloned node is just to the right of the old node. This way, we can have a mapping in O(1).\\n* We traverse the original list and for each node we create a copy and insert it to the right. So, *1 2 3 4 2 5* would become *1 1 2 2 3 3 4 4 2 2 5 5*. \\n* Now, we traverse the list again and correct the random field of the cloned nodes. (How?). We stand at the original node, go to its **random** field, and then move right (the mapping) and set the newly found node as the random field of the cloned node (the node to the current right). We continue this process, while ensuring that we only stand at the original nodes.\\n* Now, we need to free the lists. This is easy, for each node, we set it\\'s next field to the **node.next.next**. (This has to be done to each node since we need to free both the lists).\\n\\n**Credits** ----- Inspired by a couple of **Discuss** posts and a question on **StackOverFlow**.\\n\\n```\\nclass Solution\\n{\\npublic:\\n    Node* copyRandomList(Node* originalHead);\\n};\\n\\n/* Returns a deep copy of the list using constant space */\\nNode* Solution :: copyRandomList(Node* originalHead)\\n{\\n    // Handle the base case\\n    if(!originalHead) return originalHead;\\n    \\n    // The iterator for the list and the backup.\\n    Node* weavedHead;\\n    Node* backup;\\n    weavedHead = originalHead;\\n    \\n    /* Never declare variables inside for loop if you need O(1) space solution */\\n    \\n    /* Interleave the nodes (Make copies to the right) */\\n    \\n    // Create the copies and put them to the right\\n    while(weavedHead)\\n    {\\n        // Make a backup of the next (original) node\\n        backup = weavedHead->next;\\n        \\n        // Attach a copy. The next field of the new node is the original right node\\n        weavedHead->next = new Node(weavedHead->val, backup, nullptr);\\n        \\n        // Move to the original right node.(Don\\'t create copies of copies)\\n        weavedHead = backup;\\n    }\\n    \\n    // Store a permanent reference to the cloned head\\n    Node* clonedHead = originalHead->next;\\n    \\n    // Iterator for the list\\n    weavedHead = originalHead;\\n    \\n    // Start filling the random pointers\\n    while(weavedHead)\\n    {\\n        /* We are standing at a node from the original list\\n         * The next node is its clone. \\n         * Get the random pointer of the original list and traverse there.\\n         * The corresponding counterpart of the random node would be to its right\\n         * Fill the random pointers of the cloned part (right) using this\\n         */\\n        (weavedHead->next)->random = weavedHead->random ? (weavedHead->random)->next : nullptr;\\n        \\n        /* Make sure to go 2 steps to the right.\\n         * We always stand at the original node and correct the clone node\\n         * It is guaranteed that weavedHead->next is not null. How? Check the first assumption\\n         */\\n        weavedHead = weavedHead->next->next;\\n    }\\n    \\n    // Remove the interlacing and correct the original list\\n    weavedHead = originalHead;\\n    while(weavedHead)\\n    {\\n        // We can stand on both types of nodes. Get a backup of the next element\\n        backup = weavedHead->next;\\n        \\n        // The correct neighbour is shifted to the right by 1 place\\n        weavedHead->next = weavedHead->next ? weavedHead->next->next : nullptr;\\n        \\n        // Remember to go one step at a time to correct both the lists\\n        weavedHead = backup;\\n    }\\n    \\n    // Return the stored permananent reference\\n    return clonedHead;\\n}\\n```\\n[JavaScript Implementation](https://github.com/Just-A-Visitor/Coding/tree/master/LeetCode%20Non-Contest%20Solutions/%23138%20Cloning%20a%20Linked%20List%20with%20Random%20Pointers)",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    Node* copyRandomList(Node* originalHead);\\n};\\n\\n/* Returns a deep copy of the list using constant space */\\nNode* Solution :: copyRandomList(Node* originalHead)\\n{\\n    // Handle the base case\\n    if(!originalHead) return originalHead;\\n    \\n    // The iterator for the list and the backup.\\n    Node* weavedHead;\\n    Node* backup;\\n    weavedHead = originalHead;\\n    \\n    /* Never declare variables inside for loop if you need O(1) space solution */\\n    \\n    /* Interleave the nodes (Make copies to the right) */\\n    \\n    // Create the copies and put them to the right\\n    while(weavedHead)\\n    {\\n        // Make a backup of the next (original) node\\n        backup = weavedHead->next;\\n        \\n        // Attach a copy. The next field of the new node is the original right node\\n        weavedHead->next = new Node(weavedHead->val, backup, nullptr);\\n        \\n        // Move to the original right node.(Don\\'t create copies of copies)\\n        weavedHead = backup;\\n    }\\n    \\n    // Store a permanent reference to the cloned head\\n    Node* clonedHead = originalHead->next;\\n    \\n    // Iterator for the list\\n    weavedHead = originalHead;\\n    \\n    // Start filling the random pointers\\n    while(weavedHead)\\n    {\\n        /* We are standing at a node from the original list\\n         * The next node is its clone. \\n         * Get the random pointer of the original list and traverse there.\\n         * The corresponding counterpart of the random node would be to its right\\n         * Fill the random pointers of the cloned part (right) using this\\n         */\\n        (weavedHead->next)->random = weavedHead->random ? (weavedHead->random)->next : nullptr;\\n        \\n        /* Make sure to go 2 steps to the right.\\n         * We always stand at the original node and correct the clone node\\n         * It is guaranteed that weavedHead->next is not null. How? Check the first assumption\\n         */\\n        weavedHead = weavedHead->next->next;\\n    }\\n    \\n    // Remove the interlacing and correct the original list\\n    weavedHead = originalHead;\\n    while(weavedHead)\\n    {\\n        // We can stand on both types of nodes. Get a backup of the next element\\n        backup = weavedHead->next;\\n        \\n        // The correct neighbour is shifted to the right by 1 place\\n        weavedHead->next = weavedHead->next ? weavedHead->next->next : nullptr;\\n        \\n        // Remember to go one step at a time to correct both the lists\\n        weavedHead = backup;\\n    }\\n    \\n    // Return the stored permananent reference\\n    return clonedHead;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719735,
                "title": "2-clean-java-solutions-with-explanations-o-1-and-o-n-space",
                "content": "O(n) - time | O(n) - space\\n```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n        \\n        Map<Node, Node> map =  new HashMap<Node, Node>();\\n    \\n        Node curNode = head;\\n        while(curNode != null)\\n        {\\n            map.put(curNode, new Node(curNode.val));\\n            curNode = curNode.next;\\n        }\\n        \\n        for(Map.Entry<Node, Node> entry : map.entrySet())  // key -> value;  node -> copy\\n        {\\n            Node node = entry.getValue();\\n            node.next = map.get(entry.getKey().next);\\n            node.random = map.get(entry.getKey().random);\\n        }\\n        \\n        return map.get(head);\\n    }\\n}\\n```\\n\\n------------------------------------------------------------------------------------------------------------\\n\\nO(n) - time | O(1) - space\\n\\n```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n        \\n        Node curr = head;\\n        //add a copy extra node after each node\\n        while (curr != null)\\n        {\\n            Node temp = curr.next;\\n            Node copy = new Node(curr.val);\\n            curr.next = copy;\\n            copy.next = temp;\\n            curr = temp;            \\n        }\\n        \\n        // put the random reference for copies\\n        curr = head;\\n        while (curr != null)\\n        {\\n            if(curr.next != null)  \\n              curr.next.random = (curr.random != null) ? curr.random.next : curr.random;  \\n  \\n        // move to the next newly added node by  \\n        // skipping an original node  \\n        curr = (curr.next != null) ? curr.next.next : curr.next;  \\n        }\\n        \\n        // separa in two lists : original and copy\\n        // restore initial next configuration\\n        Node original = head, copy = head.next;  \\n  \\n        // save the start of copied linked list  \\n        Node result = copy;  \\n\\n        // now separate the original list and copied list  \\n        while (original != null && copy != null)  \\n        {  \\n            original.next = (original.next != null) ? original.next.next : original.next;  \\n            copy.next = (copy.next != null) ? copy.next.next : copy.next;  \\n            \\n            original = original.next;  \\n            copy = copy.next;  \\n        }  \\n        return result;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n        \\n        Map<Node, Node> map =  new HashMap<Node, Node>();\\n    \\n        Node curNode = head;\\n        while(curNode != null)\\n        {\\n            map.put(curNode, new Node(curNode.val));\\n            curNode = curNode.next;\\n        }\\n        \\n        for(Map.Entry<Node, Node> entry : map.entrySet())  // key -> value;  node -> copy\\n        {\\n            Node node = entry.getValue();\\n            node.next = map.get(entry.getKey().next);\\n            node.random = map.get(entry.getKey().random);\\n        }\\n        \\n        return map.get(head);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n        \\n        Node curr = head;\\n        //add a copy extra node after each node\\n        while (curr != null)\\n        {\\n            Node temp = curr.next;\\n            Node copy = new Node(curr.val);\\n            curr.next = copy;\\n            copy.next = temp;\\n            curr = temp;            \\n        }\\n        \\n        // put the random reference for copies\\n        curr = head;\\n        while (curr != null)\\n        {\\n            if(curr.next != null)  \\n              curr.next.random = (curr.random != null) ? curr.random.next : curr.random;  \\n  \\n        // move to the next newly added node by  \\n        // skipping an original node  \\n        curr = (curr.next != null) ? curr.next.next : curr.next;  \\n        }\\n        \\n        // separa in two lists : original and copy\\n        // restore initial next configuration\\n        Node original = head, copy = head.next;  \\n  \\n        // save the start of copied linked list  \\n        Node result = copy;  \\n\\n        // now separate the original list and copied list  \\n        while (original != null && copy != null)  \\n        {  \\n            original.next = (original.next != null) ? original.next.next : original.next;  \\n            copy.next = (copy.next != null) ? copy.next.next : copy.next;  \\n            \\n            original = original.next;  \\n            copy = copy.next;  \\n        }  \\n        return result;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 786604,
                "title": "python-sentinel-node-o-n-time-o-1-space",
                "content": "Hello there,\\n\\nHere is my solution. The analysis is below. \\n\\n1. Clarifications:\\n    Is the linked-list ready-only? Let\\'s assume that it\\'s not.\\n\\n2. Implementation:\\n\\n```\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        \\n        clone_prehead = Node(0) # To keep track of the new list head and to avoid having 2 cases (cloning the head node and internal nodes)\\n        \\n\\t\\t# 1. Clone Values and Next pointers\\n        clone = clone_prehead\\n        while head:\\n            clone.next = Node(head.val, None, head.random)\\n            clone = clone.next\\n            \\n            head.next, head = clone, head.next\\n        \\n\\t\\t# 2. Clone Random pointers\\n        clone = clone_prehead.next\\n        while clone:\\n            if clone.random:\\n                clone.random = clone.random.next\\n            \\n            clone = clone.next\\n                \\n        return clone_prehead.next\\n\\n```\\n        \\n3. Intuition:\\n\\t* Create a new list by cloning `Values` and `Next` pointers\\n\\t\\t* Create each new node as follow: (**Val**: original val, **Next**: points to its new next node, **Random**: points to the original random node)\\n\\t\\t* Update the original node next node to point to its clone node: `Original.next = Clone`\\n\\t* Update new list by cloning  `Random` pointers:\\n\\t\\t* Scan new list nodes, \\n\\t\\t* For each node which random node isn\\'t `None`, assign it with the next node of the original random node: `Clone = Clone.random.next`\\n\\t\\t\\n\\t\\t```\\n       Initially:   \\n              Original list: 1 -> 2 -> 3\\n                             |________ ^\\n                    original.node(1).random = original.node(3)\\n\\n      After the 1st loop :\\n                              ____________\\n                             |            |\\n                      clone: 1 -> 2 -> 3  |\\n                             ^    ^    ^  |\\n                   Original: 1    2    3 <-\\n                             |________ ^\\n                    original.node(3).next = clone.node(3)\\n                    clone.node(1).random = original.node(3)\\n\\n      After the 2st loop :\\n                              ____________\\n                             |            |\\n                      clone: 1 -> 2 -> 3 <|\\n                             ^    ^    ^  \\n                   Original: 1    2    3\\n                             |________ ^\\n                    clone.node(1).random = original.node(3).next = clone.node(1).random.next\\n\\n\\t\\t```\\n\\n4. Complexity Analysis:\\n\\t* Time Complexity: O(n)\\n\\t* Space Complexity: O(1)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        \\n        clone_prehead = Node(0) # To keep track of the new list head and to avoid having 2 cases (cloning the head node and internal nodes)\\n        \\n\\t\\t# 1. Clone Values and Next pointers\\n        clone = clone_prehead\\n        while head:\\n            clone.next = Node(head.val, None, head.random)\\n            clone = clone.next\\n            \\n            head.next, head = clone, head.next\\n        \\n\\t\\t# 2. Clone Random pointers\\n        clone = clone_prehead.next\\n        while clone:\\n            if clone.random:\\n                clone.random = clone.random.next\\n            \\n            clone = clone.next\\n                \\n        return clone_prehead.next\\n\\n```\n```\\n       Initially:   \\n              Original list: 1 -> 2 -> 3\\n                             |________ ^\\n                    original.node(1).random = original.node(3)\\n\\n      After the 1st loop :\\n                              ____________\\n                             |            |\\n                      clone: 1 -> 2 -> 3  |\\n                             ^    ^    ^  |\\n                   Original: 1    2    3 <-\\n                             |________ ^\\n                    original.node(3).next = clone.node(3)\\n                    clone.node(1).random = original.node(3)\\n\\n      After the 2st loop :\\n                              ____________\\n                             |            |\\n                      clone: 1 -> 2 -> 3 <|\\n                             ^    ^    ^  \\n                   Original: 1    2    3\\n                             |________ ^\\n                    clone.node(1).random = original.node(3).next = clone.node(1).random.next\\n\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 494261,
                "title": "single-pass-java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head == null) {\\n            return head;\\n        }\\n        \\n        //first form the list with current nodes and new nodes\\n        // if list is 1->2->3\\n        // we make it 1->1->2->2->3->3\\n        Node curr = head;\\n        while(curr != null) {\\n            Node n = new Node(curr.val);\\n            n.next = curr.next;\\n            curr.next = n;\\n            curr = curr.next.next;\\n        }\\n        \\n        //Now we have actual nodes and new Nodes\\n        // understand this clearly first\\n        // curr.next.random = curr.random.next;\\n\\t\\t\\n        curr = head;\\n        while(curr!=null) {\\n            if(curr.random == null) {\\n                curr.next.random = null;\\n            } else {\\n                curr.next.random = curr.random.next;\\n            }\\n            curr = curr.next.next;\\n        }\\n        \\n        //separate out both the lists and return the new list\\n        curr = head;\\n        Node curr1 = head.next;\\n        Node h = curr1;\\n        while(curr != null) {\\n            curr.next = curr.next.next;\\n            if(curr1.next != null) {\\n                curr1.next = curr1.next.next;\\n            } \\n            curr = curr.next;\\n            curr1 = curr1.next;\\n        }\\n        return h;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head == null) {\\n            return head;\\n        }\\n        \\n        //first form the list with current nodes and new nodes\\n        // if list is 1->2->3\\n        // we make it 1->1->2->2->3->3\\n        Node curr = head;\\n        while(curr != null) {\\n            Node n = new Node(curr.val);\\n            n.next = curr.next;\\n            curr.next = n;\\n            curr = curr.next.next;\\n        }\\n        \\n        //Now we have actual nodes and new Nodes\\n        // understand this clearly first\\n        // curr.next.random = curr.random.next;\\n\\t\\t\\n        curr = head;\\n        while(curr!=null) {\\n            if(curr.random == null) {\\n                curr.next.random = null;\\n            } else {\\n                curr.next.random = curr.random.next;\\n            }\\n            curr = curr.next.next;\\n        }\\n        \\n        //separate out both the lists and return the new list\\n        curr = head;\\n        Node curr1 = head.next;\\n        Node h = curr1;\\n        while(curr != null) {\\n            curr.next = curr.next.next;\\n            if(curr1.next != null) {\\n                curr1.next = curr1.next.next;\\n            } \\n            curr = curr.next;\\n            curr1 = curr1.next;\\n        }\\n        return h;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443593,
                "title": "c-solution-using-dictionary-beats-99",
                "content": "```\\n public Node CopyRandomList(Node head)\\n        {\\n            if (head == null) return null;\\n\\n            var originalToCopyNodeMap = new Dictionary<Node , Node>();\\n            var p = head;\\n            while (p != null)\\n            {\\n                originalToCopyNodeMap.Add(p, new Node(p.val, null, null));\\n                p = p.next;\\n            }\\n\\n            p = head;\\n            while (p != null)\\n            {\\n                if (p.next != null) originalToCopyNodeMap[p].next = originalToCopyNodeMap[p.next];\\n                if( p.random != null) originalToCopyNodeMap[p].random = originalToCopyNodeMap[p.random];\\n                p = p.next;\\n            }\\n            return originalToCopyNodeMap[head];\\n\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n public Node CopyRandomList(Node head)\\n        {\\n            if (head == null) return null;\\n\\n            var originalToCopyNodeMap = new Dictionary<Node , Node>();\\n            var p = head;\\n            while (p != null)\\n            {\\n                originalToCopyNodeMap.Add(p, new Node(p.val, null, null));\\n                p = p.next;\\n            }\\n\\n            p = head;\\n            while (p != null)\\n            {\\n                if (p.next != null) originalToCopyNodeMap[p].next = originalToCopyNodeMap[p.next];\\n                if( p.random != null) originalToCopyNodeMap[p].random = originalToCopyNodeMap[p.random];\\n                p = p.next;\\n            }\\n            return originalToCopyNodeMap[head];\\n\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43617,
                "title": "one-loop-can-be-a-bad-choice-in-three-solutions-c",
                "content": "140ms using loop to hack this problem but due to frequent invoking of **node_map.count**, there is a dramatic performance decrease.\\n\\n    \\n    class Solution {\\n    public:\\n        RandomListNode *copyRandomList(RandomListNode *head) {\\n            if(!head) return NULL;\\n            unordered_map<RandomListNode*, RandomListNode*> node_map;\\n            RandomListNode *p = head, *pre = NULL;\\n            while(p)\\n            {\\n                if(!node_map.count(p)) node_map[p] = new RandomListNode(p->label);\\n                if(p->random)\\n                {\\n                    if(!node_map.count(p->random)) node_map[p->random] = new RandomListNode(p->random->label); \\n                    node_map[p]->random = node_map[p->random];\\n                }\\n                if(pre) pre->next = node_map[p];\\n                pre = node_map[p];\\n                p = p->next;\\n            }\\n            return node_map[head];\\n        }\\n    };\\n\\n\\n----------\\n\\nUsing 110ms to solve this, though traverse twice but it's more clean and easy-understanding.\\n\\n    class Solution {\\n    public:\\n        RandomListNode *copyRandomList(RandomListNode *head) {\\n            if(!head) return NULL;\\n            unordered_map<RandomListNode*, RandomListNode*> node_map;\\n            RandomListNode *p = head, *pre = NULL, t(0);\\n            pre = &t;\\n            while(p)\\n            {\\n                pre->next = node_map[p] = new RandomListNode(p->label);\\n                p = p->next;\\n                pre = pre->next;\\n            }\\n            p = head;\\n            pre = t.next;\\n            while(p)\\n            {\\n                pre->random = node_map[p->random];\\n                pre = pre->next;\\n                p = p->next;\\n            }\\n            return t.next;\\n        }\\n    };\\n\\n\\n----------\\n\\nUsing 110ms without map, copy all the nodes just after its original position then the random pointer of the cloned node can be easily retrieved by the original nodes (since the original is just before its corresponding cloned nodes so the random) Check the code directly, quite simple.\\n\\n    class Solution {\\n    public:\\n        RandomListNode *copyRandomList(RandomListNode *head) {\\n            if(!head) return NULL;\\n            RandomListNode *p = head, *next, *cloned, *pre;\\n            while(p)\\n            {\\n                cloned = new RandomListNode(p->label);\\n                next = p->next;\\n                p->next = cloned;\\n                cloned->next = next;\\n                p = next;\\n            }\\n            p = head;\\n            cloned = head->next;\\n            while(p)\\n            {\\n                if(p->random) cloned->random = p->random->next;\\n                if(cloned->next) cloned = cloned->next->next;\\n                else break;\\n                p = p->next->next;\\n            }\\n            RandomListNode t(0);\\n            p = head;\\n            pre = &t;\\n            while(p)\\n            {\\n                pre->next = p->next;\\n                p->next = p->next->next;\\n                p = p->next;\\n                pre = pre->next;\\n            }\\n            return t.next;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        RandomListNode *copyRandomList(RandomListNode *head) {\\n            if(!head) return NULL;\\n            unordered_map<RandomListNode*, RandomListNode*> node_map;\\n            RandomListNode *p = head, *pre = NULL;\\n            while(p)\\n            {\\n                if(!node_map.count(p)) node_map[p] = new RandomListNode(p->label);\\n                if(p->random)\\n                {\\n                    if(!node_map.count(p->random)) node_map[p->random] = new RandomListNode(p->random->label); \\n                    node_map[p]->random = node_map[p->random];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3698001,
                "title": "easy-c-soln-time-complexity-o-n-and-o-1-space-complexity",
                "content": "# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n- Approach : \\n       - Add node with same data after original node \\n       - Then update the random of copy node by random of original node\\n       - After that saperate the original and copied nodes as a linked list\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![WhatsApp Image 2023-06-30 at 12.43.51 AM.jpeg](https://assets.leetcode.com/users/images/6f304a47-fd2b-4820-b8ae-39c9f12da8ea_1688066101.2978802.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(head==NULL)return NULL;\\n        for(Node* curr=head;curr!=NULL;)\\n        {\\n            Node* tmp = curr->next;\\n            curr->next = new Node(curr->val);\\n            curr->next->next = tmp;\\n            curr = tmp;\\n        }\\n        for(Node* curr=head;curr!=NULL;curr=curr->next->next)\\n        {\\n            curr->next->random = curr->random?curr->random->next:NULL;\\n        }\\n        Node* temp = head->next,*original=head,*copy=head->next;\\n        while(copy && original)\\n        {\\n            original->next = original->next?original->next->next:original->next;\\n            copy->next = copy->next?copy->next->next:copy->next;\\n            original = original->next;\\n            copy = copy->next;\\n\\n        }\\n        return temp;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(head==NULL)return NULL;\\n        for(Node* curr=head;curr!=NULL;)\\n        {\\n            Node* tmp = curr->next;\\n            curr->next = new Node(curr->val);\\n            curr->next->next = tmp;\\n            curr = tmp;\\n        }\\n        for(Node* curr=head;curr!=NULL;curr=curr->next->next)\\n        {\\n            curr->next->random = curr->random?curr->random->next:NULL;\\n        }\\n        Node* temp = head->next,*original=head,*copy=head->next;\\n        while(copy && original)\\n        {\\n            original->next = original->next?original->next->next:original->next;\\n            copy->next = copy->next?copy->next->next:copy->next;\\n            original = original->next;\\n            copy = copy->next;\\n\\n        }\\n        return temp;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205736,
                "title": "138-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThis solution uses a dictionary to keep track of nodes that have already been processed. It recursively copies the next and random pointers of the original list, creating new nodes as needed, and saves them in the visited dictionary. If a node has already been processed, it returns the cloned version of it from the dictionary.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\\nclass Solution:\\n    def __init__(self):\\n        self.visited = {}\\n\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n\\n        # If we have already processed the current node, return the cloned version of it\\n        if head in self.visited:\\n            return self.visited[head]\\n\\n        # Create a new node with the same value as the original node\\n        node = Node(head.val, None, None)\\n\\n        # Save the new node in the visited dictionary\\n        self.visited[head] = node\\n\\n        # Recursively copy the next and random pointers\\n        node.next = self.copyRandomList(head.next)\\n        node.random = self.copyRandomList(head.random)\\n\\n        return node\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\\nclass Solution:\\n    def __init__(self):\\n        self.visited = {}\\n\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n\\n        # If we have already processed the current node, return the cloned version of it\\n        if head in self.visited:\\n            return self.visited[head]\\n\\n        # Create a new node with the same value as the original node\\n        node = Node(head.val, None, None)\\n\\n        # Save the new node in the visited dictionary\\n        self.visited[head] = node\\n\\n        # Recursively copy the next and random pointers\\n        node.next = self.copyRandomList(head.next)\\n        node.random = self.copyRandomList(head.random)\\n\\n        return node\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230997,
                "title": "simple-c-solution-2-approach-with-extra-space-without-extra-space",
                "content": "**Approach -1** **[** **With extra Space** **--** **Using Haspmap** **]**\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        unordered_map<Node* ,Node*> map;\\n        Node* dummy=new Node(-1);\\n        Node* temp=head;\\n        Node* temp2=dummy;\\n        while(temp!=NULL){\\n            Node* copy=new Node(temp->val);\\n            map[temp]=copy;\\n            \\n            temp2->next=copy;\\n            temp2=copy;\\n            temp=temp->next; \\n        }\\n        dummy=dummy->next;\\n        \\n        temp=dummy;\\n        temp2=head;\\n        while(temp!=NULL){\\n           temp->random=map[temp2->random];\\n            temp=temp->next;\\n            temp2=temp2->next;\\n        }\\n        return dummy;\\n    }\\n};\\n```\\n\\n**Approach -2** **[** **Without using extra Space** **--** **Merging Lists** **]**\\n```\\nclass Solution {\\npublic:\\n    void copy_merge(Node* head){\\n        Node* curr=head;\\n        Node* next=head->next;\\n        while(curr!=NULL){\\n            Node* copy=new Node(curr->val);\\n            curr->next=copy;\\n            copy->next=next;\\n            curr=next;\\n            if(next!=NULL){\\n                next=next->next;\\n            }\\n        }\\n    }\\n    \\n    void handle_random(Node* head){\\n        Node* curr=head;\\n        while(curr!=NULL){\\n            if(curr->random!=NULL){\\n            curr->next->random=curr->random->next;\\n            }\\n            curr=curr->next->next;\\n        }\\n    }\\n    \\n    Node* detach(Node* head){\\n        Node* curr=head;\\n        Node* dummy=new Node(-1);\\n        Node* tail=dummy;\\n        while(curr!=NULL){\\n            tail->next=curr->next;\\n            tail=tail->next;\\n            curr->next=tail->next;\\n            curr=curr->next;\\n        }\\n        return dummy->next;\\n    }\\n    Node* copyRandomList(Node* head) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        copy_merge(head);\\n        \\n        handle_random(head);\\n        \\n        return detach(head);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        unordered_map<Node* ,Node*> map;\\n        Node* dummy=new Node(-1);\\n        Node* temp=head;\\n        Node* temp2=dummy;\\n        while(temp!=NULL){\\n            Node* copy=new Node(temp->val);\\n            map[temp]=copy;\\n            \\n            temp2->next=copy;\\n            temp2=copy;\\n            temp=temp->next; \\n        }\\n        dummy=dummy->next;\\n        \\n        temp=dummy;\\n        temp2=head;\\n        while(temp!=NULL){\\n           temp->random=map[temp2->random];\\n            temp=temp->next;\\n            temp2=temp2->next;\\n        }\\n        return dummy;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void copy_merge(Node* head){\\n        Node* curr=head;\\n        Node* next=head->next;\\n        while(curr!=NULL){\\n            Node* copy=new Node(curr->val);\\n            curr->next=copy;\\n            copy->next=next;\\n            curr=next;\\n            if(next!=NULL){\\n                next=next->next;\\n            }\\n        }\\n    }\\n    \\n    void handle_random(Node* head){\\n        Node* curr=head;\\n        while(curr!=NULL){\\n            if(curr->random!=NULL){\\n            curr->next->random=curr->random->next;\\n            }\\n            curr=curr->next->next;\\n        }\\n    }\\n    \\n    Node* detach(Node* head){\\n        Node* curr=head;\\n        Node* dummy=new Node(-1);\\n        Node* tail=dummy;\\n        while(curr!=NULL){\\n            tail->next=curr->next;\\n            tail=tail->next;\\n            curr->next=tail->next;\\n            curr=curr->next;\\n        }\\n        return dummy->next;\\n    }\\n    Node* copyRandomList(Node* head) {\\n        if(head==NULL){\\n            return head;\\n        }\\n        copy_merge(head);\\n        \\n        handle_random(head);\\n        \\n        return detach(head);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465844,
                "title": "c-detailed-o-n-time-o-1-space-without-hash-map",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\nclass Solution {\\n// Iterative sol\\'n with O(N) time, O(1) space without a hash map\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) return nullptr;\\n                \\n        // temporary (copied) head node\\n        Node* tmp_node = head;\\n\\t\\t\\n        while(tmp_node)\\n        {\\n            // Cloned node with same val as head\\n            Node* tmp_copy_node = new Node(tmp_node->val);\\n            \\n            // Insert the cloned node next to the original node\\n            // If A->B->C is the original linked list,\\n            // Linked list after weaving cloned nodes would be\\n            // A->A\\'->B->B\\'->C->C\\'\\n            tmp_copy_node->next = tmp_node->next;\\n            tmp_node->next = tmp_copy_node;\\n            tmp_node = tmp_copy_node->next;\\n        }\\n            \\n        tmp_node = head;\\n        \\n        // Link random pointers of the newly created nodes\\n        // and iterate through the newly created list and\\n        // use original node\\'s random pointers\\n            \\n        while (tmp_node)\\n        {\\n            tmp_node->next->random = (tmp_node->random) ? tmp_node->random->next : nullptr;\\n            tmp_node = tmp_node->next->next;\\n        }\\n        \\n        // Unweave the current linked list to get back the \\n        // original linked list and the cloned one.\\n        \\n\\t\\t// A->B->C\\n        Node* tmp_node_old_list = head;\\n\\t\\t\\n\\t\\t// A\\'->B\\'->C\\'\\n        Node* tmp_node_new_list = head->next;\\n        \\n\\t\\tNode* old_head = head->next;\\n        \\n        while(tmp_node_old_list)\\n        {\\n            tmp_node_old_list->next = tmp_node_old_list->next->next;\\n            tmp_node_new_list->next = (tmp_node_new_list->next) ? tmp_node_new_list->next->next : nullptr;\\n            \\n            tmp_node_old_list = tmp_node_old_list->next;\\n            tmp_node_new_list = tmp_node_new_list->next;\\n        }\\n        return old_head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\nclass Solution {\\n// Iterative sol\\'n with O(N) time, O(1) space without a hash map\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) return nullptr;\\n                \\n        // temporary (copied) head node\\n        Node* tmp_node = head;\\n\\t\\t\\n        while(tmp_node)\\n        {\\n            // Cloned node with same val as head\\n            Node* tmp_copy_node = new Node(tmp_node->val);\\n            \\n            // Insert the cloned node next to the original node\\n            // If A->B->C is the original linked list,\\n            // Linked list after weaving cloned nodes would be\\n            // A->A\\'->B->B\\'->C->C\\'\\n            tmp_copy_node->next = tmp_node->next;\\n            tmp_node->next = tmp_copy_node;\\n            tmp_node = tmp_copy_node->next;\\n        }\\n            \\n        tmp_node = head;\\n        \\n        // Link random pointers of the newly created nodes\\n        // and iterate through the newly created list and\\n        // use original node\\'s random pointers\\n            \\n        while (tmp_node)\\n        {\\n            tmp_node->next->random = (tmp_node->random) ? tmp_node->random->next : nullptr;\\n            tmp_node = tmp_node->next->next;\\n        }\\n        \\n        // Unweave the current linked list to get back the \\n        // original linked list and the cloned one.\\n        \\n\\t\\t// A->B->C\\n        Node* tmp_node_old_list = head;\\n\\t\\t\\n\\t\\t// A\\'->B\\'->C\\'\\n        Node* tmp_node_new_list = head->next;\\n        \\n\\t\\tNode* old_head = head->next;\\n        \\n        while(tmp_node_old_list)\\n        {\\n            tmp_node_old_list->next = tmp_node_old_list->next->next;\\n            tmp_node_new_list->next = (tmp_node_new_list->next) ? tmp_node_new_list->next->next : nullptr;\\n            \\n            tmp_node_old_list = tmp_node_old_list->next;\\n            tmp_node_new_list = tmp_node_new_list->next;\\n        }\\n        return old_head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 453258,
                "title": "easy-to-understand-c-solution-o-n-time-o-1-space",
                "content": "Runtime: 24 ms, faster than 99.04% of C++ online submissions for Copy List with Random Pointer.\\nMemory Usage: 21.8 MB, less than 100.00% of C++ online submissions for Copy List with Random Pointer.\\n\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n\\n    Node() {}\\n\\n    Node(int _val, Node* _next, Node* _random) {\\n        val = _val;\\n        next = _next;\\n        random = _random;\\n    }\\n};\\n*/\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        \\n        if(head == nullptr) return head;\\n        Node* curr = head;\\n        Node* temp;\\n        \\n        while(curr)\\n        {\\n            temp = curr->next;\\n            curr->next = new Node(curr->val,nullptr, nullptr);\\n            curr->next->next = temp;\\n            curr = temp;\\n        }\\n        \\n        curr = head;\\n        while(curr)\\n        {\\n            if(curr->next && curr->random)\\n                curr->next->random = curr->random->next;\\n            curr = curr->next ? curr->next->next : curr->next;\\n        }\\n        \\n        Node* original = head;\\n        Node* copy = head->next;\\n        temp = copy;\\n        \\n        while(original && copy)\\n        {\\n            original->next = original->next ? original->next->next : original->next;\\n            copy->next = copy->next ? copy->next->next : copy->next;\\n            \\n            original = original->next;\\n            copy = copy->next;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n\\n    Node() {}\\n\\n    Node(int _val, Node* _next, Node* _random) {\\n        val = _val;\\n        next = _next;\\n        random = _random;\\n    }\\n};\\n*/\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        \\n        if(head == nullptr) return head;\\n        Node* curr = head;\\n        Node* temp;\\n        \\n        while(curr)\\n        {\\n            temp = curr->next;\\n            curr->next = new Node(curr->val,nullptr, nullptr);\\n            curr->next->next = temp;\\n            curr = temp;\\n        }\\n        \\n        curr = head;\\n        while(curr)\\n        {\\n            if(curr->next && curr->random)\\n                curr->next->random = curr->random->next;\\n            curr = curr->next ? curr->next->next : curr->next;\\n        }\\n        \\n        Node* original = head;\\n        Node* copy = head->next;\\n        temp = copy;\\n        \\n        while(original && copy)\\n        {\\n            original->next = original->next ? original->next->next : original->next;\\n            copy->next = copy->next ? copy->next->next : copy->next;\\n            \\n            original = original->next;\\n            copy = copy->next;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417399,
                "title": "python-simple-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n        \\n        d = {}\\n        p = head\\n        \\n        while p:\\n            d[p] = Node(p.val, None, None)\\n            p = p.next\\n        \\n        p = head\\n        while p:\\n            if p.random:\\n                d[p].random = d[p.random]\\n            if p.next:\\n                d[p].next = d[p.next]\\n            p = p.next\\n        \\n        return d[head]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n        \\n        d = {}\\n        p = head\\n        \\n        while p:\\n            d[p] = Node(p.val, None, None)\\n            p = p.next\\n        \\n        p = head\\n        while p:\\n            if p.random:\\n                d[p].random = d[p.random]\\n            if p.next:\\n                d[p].next = d[p.next]\\n            p = p.next\\n        \\n        return d[head]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004195,
                "title": "java-solution-linear-time-constant-space-o-n-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Node temp = head;\\n        while(temp != null) {\\n            Node next = temp.next;\\n            Node clone = new Node(temp.val);\\n            temp.next = clone;\\n            clone.next = next;\\n            temp = next;\\n        }\\n        temp = head;\\n        while(temp != null) {\\n            if(temp.random != null) {\\n                temp.next.random = temp.random.next;\\n            }\\n            temp = temp.next.next;\\n        }\\n        Node cloneHead = new Node(0);\\n        Node tempHead = cloneHead;\\n        temp = head;\\n        while(temp != null) {\\n            Node next = temp.next.next;\\n            Node clone = temp.next;\\n            tempHead.next = clone;\\n            tempHead = clone;\\n            temp.next = next;\\n            temp = next;\\n        }\\n        return cloneHead.next;\\n    }\\n}\\n\\n// Refrences : \\n// https://www.youtube.com/watch?v=83mPr0i56Gg\\n// https://leetcode.com/problems/copy-list-with-random-pointer/solutions/43491/a-solution-with-constant-space-complexity-o-1-and-linear-time-complexity-o-n/\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Node temp = head;\\n        while(temp != null) {\\n            Node next = temp.next;\\n            Node clone = new Node(temp.val);\\n            temp.next = clone;\\n            clone.next = next;\\n            temp = next;\\n        }\\n        temp = head;\\n        while(temp != null) {\\n            if(temp.random != null) {\\n                temp.next.random = temp.random.next;\\n            }\\n            temp = temp.next.next;\\n        }\\n        Node cloneHead = new Node(0);\\n        Node tempHead = cloneHead;\\n        temp = head;\\n        while(temp != null) {\\n            Node next = temp.next.next;\\n            Node clone = temp.next;\\n            tempHead.next = clone;\\n            tempHead = clone;\\n            temp.next = next;\\n            temp = next;\\n        }\\n        return cloneHead.next;\\n    }\\n}\\n\\n// Refrences : \\n// https://www.youtube.com/watch?v=83mPr0i56Gg\\n// https://leetcode.com/problems/copy-list-with-random-pointer/solutions/43491/a-solution-with-constant-space-complexity-o-1-and-linear-time-complexity-o-n/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177657,
                "title": "python-list-interweaving-with-explanation-o-n-time-and-o-1-space-complexity",
                "content": "Solution manipulating the original list.\\n**1. We need to make a copy of each node and add it after the original node.**\\nThe resulting list looks like this: (7->7C->13->13C->11->11C->10->10C->1->1C)\\n**2. The random pointer of every new node has to point to the original random.next - the node that is after the original random node.**\\nIf current.random 11 points to 1, the new node copy.random has to point to the 1C.\\n**3. Return the original list to its initial state and extract the copied list.** \\nThis is the most tricky part. We have to remember that the first node in the list we have is original, second is a copy, third is original, fourth is a copy and so on...\\nUsing two pointers current and current_old, we can start current at head.next (the first copied node) and current_old at head.\\nthe next pointers always have to skip one node, so current_old.next = current_old.next.next and current.next = current.next.next.\\n\\nThis code is not the shortest, but with plenty of comments, to make it more understandable.\\n\\n```\\nclass Solution(object):\\n    def copyRandomList(self, head):\\n        \"\"\"\\n        :type head: Node\\n        :rtype: Node\\n        \"\"\"\\n        if head is None:\\n            return None\\n\\n        current = head\\n\\n        # copy nodes inside the original list --------------------------------------------------------------------------\\n\\n        while current is not None:\\n            # create new copied node\\n            new_node = Node(x=current.val, next=current.next)\\n            # change current.next pointer to the new_node\\n            current.next = new_node\\n\\n            # move current to the next after the copied node\\n            current = current.next.next\\n\\n        # add random pointers --------------------------------------------------------------------------------------\\n\\n        # we have to replicate the random pointers for the copied nodes\\n        # also we have to break pointers of the copied nodes to the original nodes\\n\\n        current = head\\n        while current is not None:\\n            # go to the next copied node - copy is always the node after the current\\n            copy = current.next\\n            # random pointer will point to the random node after the original random\\n            if current.random is not None:\\n                copy.random = current.random.next\\n            else:\\n                copy.random = None\\n\\n            # go to he next original node\\n            current = current.next.next\\n\\n        # break connections of the copied nodes to the original nodes --------------------------------------------------\\n        # this could probably be done inside previous loop, but it complicates the code\\n\\n        # second node is the head node of the new copied list inside the original list\\n        copied_head = head.next\\n        current = head.next\\n        # another pointer to return the list to its original state\\n        current_old = head\\n\\n        while current is not None:\\n            # Return original list to its original state\\n            # pointers for the original list\\n            if current_old.next is not None:\\n                current_old.next = current_old.next.next\\n                current_old = current_old.next\\n            else:\\n                current_old.next = None\\n                current_old = None\\n\\n            # Separate new list from the original list\\n            # pointers for the new list\\n            if current.next is not None:\\n                current.next = current.next.next\\n                current = current.next\\n            else:\\n                current.next = None\\n                current = None\\n\\n        return copied_head\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution(object):\\n    def copyRandomList(self, head):\\n        \"\"\"\\n        :type head: Node\\n        :rtype: Node\\n        \"\"\"\\n        if head is None:\\n            return None\\n\\n        current = head\\n\\n        # copy nodes inside the original list --------------------------------------------------------------------------\\n\\n        while current is not None:\\n            # create new copied node\\n            new_node = Node(x=current.val, next=current.next)\\n            # change current.next pointer to the new_node\\n            current.next = new_node\\n\\n            # move current to the next after the copied node\\n            current = current.next.next\\n\\n        # add random pointers --------------------------------------------------------------------------------------\\n\\n        # we have to replicate the random pointers for the copied nodes\\n        # also we have to break pointers of the copied nodes to the original nodes\\n\\n        current = head\\n        while current is not None:\\n            # go to the next copied node - copy is always the node after the current\\n            copy = current.next\\n            # random pointer will point to the random node after the original random\\n            if current.random is not None:\\n                copy.random = current.random.next\\n            else:\\n                copy.random = None\\n\\n            # go to he next original node\\n            current = current.next.next\\n\\n        # break connections of the copied nodes to the original nodes --------------------------------------------------\\n        # this could probably be done inside previous loop, but it complicates the code\\n\\n        # second node is the head node of the new copied list inside the original list\\n        copied_head = head.next\\n        current = head.next\\n        # another pointer to return the list to its original state\\n        current_old = head\\n\\n        while current is not None:\\n            # Return original list to its original state\\n            # pointers for the original list\\n            if current_old.next is not None:\\n                current_old.next = current_old.next.next\\n                current_old = current_old.next\\n            else:\\n                current_old.next = None\\n                current_old = None\\n\\n            # Separate new list from the original list\\n            # pointers for the new list\\n            if current.next is not None:\\n                current.next = current.next.next\\n                current = current.next\\n            else:\\n                current.next = None\\n                current = None\\n\\n        return copied_head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 961881,
                "title": "java-solution-with-hashmap-easy-to-understand",
                "content": "```\\npublic Node copyRandomList(Node head) {\\n        \\n        if (head ==null)\\n            return head;\\n        \\n        HashMap<Node,Node> map = new HashMap<Node,Node>();\\n        Node temp = head;\\n        while(temp!=null)\\n        {\\n            map.put(temp,new Node(temp.val));\\n            temp=temp.next;\\n        }\\n         temp = head;\\n        while(temp!=null){\\n            map.get(temp).next = map.get(temp.next);\\n            map.get(temp).random = map.get(temp.random);\\n            temp = temp.next;\\n        }\\n        return map.get(head);\\n    }\\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic Node copyRandomList(Node head) {\\n        \\n        if (head ==null)\\n            return head;\\n        \\n        HashMap<Node,Node> map = new HashMap<Node,Node>();\\n        Node temp = head;\\n        while(temp!=null)\\n        {\\n            map.put(temp,new Node(temp.val));\\n            temp=temp.next;\\n        }\\n         temp = head;\\n        while(temp!=null){\\n            map.get(temp).next = map.get(temp.next);\\n            map.get(temp).random = map.get(temp.random);\\n            temp = temp.next;\\n        }\\n        return map.get(head);\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 618019,
                "title": "golang",
                "content": "```\\nfunc copyRandomList(head *Node) *Node {\\n\\tif head == nil {\\n\\t\\treturn nil\\n\\t}\\n\\tcloneMap := map[*Node]*Node{}\\n\\tfor cur := head; cur != nil; cur = cur.Next {\\n\\t\\tcloneMap[cur] = &Node{}\\n\\t}\\n\\tfor k, v := range cloneMap {\\n\\t\\tv.Val = k.Val\\n\\t\\tif k.Next != nil {\\n\\t\\t\\tv.Next = cloneMap[k.Next]\\n\\t\\t}\\n\\t\\tif k.Random != nil {\\n\\t\\t\\tv.Random = cloneMap[k.Random]\\n\\t\\t}\\n\\t}\\n\\treturn cloneMap[head]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc copyRandomList(head *Node) *Node {\\n\\tif head == nil {\\n\\t\\treturn nil\\n\\t}\\n\\tcloneMap := map[*Node]*Node{}\\n\\tfor cur := head; cur != nil; cur = cur.Next {\\n\\t\\tcloneMap[cur] = &Node{}\\n\\t}\\n\\tfor k, v := range cloneMap {\\n\\t\\tv.Val = k.Val\\n\\t\\tif k.Next != nil {\\n\\t\\t\\tv.Next = cloneMap[k.Next]\\n\\t\\t}\\n\\t\\tif k.Random != nil {\\n\\t\\t\\tv.Random = cloneMap[k.Random]\\n\\t\\t}\\n\\t}\\n\\treturn cloneMap[head]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 252962,
                "title": "java-solution-1ms-using-hashmap-easy-to-understand",
                "content": "```\\npublic Node copyRandomList(Node head) {\\n        if(head == null)\\n            return null;\\n        \\n        Map<Node, Node> map = new HashMap<>();\\n        Node node = head;\\n        while(node != null) {\\n            map.put(node, new Node(node.val, node.next, node.random));\\n            node = node.next;\\n        }\\n        \\n        node = head;\\n        while(node != null) {\\n            map.get(node).next = map.get(node.next);\\n            map.get(node).random = map.get(node.random);\\n            node = node.next;\\n        }\\n        \\n        return map.get(head);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic Node copyRandomList(Node head) {\\n        if(head == null)\\n            return null;\\n        \\n        Map<Node, Node> map = new HashMap<>();\\n        Node node = head;\\n        while(node != null) {\\n            map.put(node, new Node(node.val, node.next, node.random));\\n            node = node.next;\\n        }\\n        \\n        node = head;\\n        while(node != null) {\\n            map.get(node).next = map.get(node.next);\\n            map.get(node).random = map.get(node.random);\\n            node = node.next;\\n        }\\n        \\n        return map.get(head);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 249256,
                "title": "c-iterative-recursive-and-o-1-space",
                "content": "Use an `unordered_map` to record the copies of nodes and use it if it has already been copied.\\n\\n**Iterative**\\n\\nFollow from `head` onwards.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) {\\n            return NULL;\\n        }\\n        copies[head] = new Node(head -> val, NULL, NULL);\\n        Node* node = head;\\n        while (node) {\\n            Node *next = node -> next, *random = node -> random;\\n            if (next && copies.find(next) == copies.end()) {\\n                copies[next] = new Node(next -> val, NULL, NULL);\\n            }\\n            if (random && copies.find(random) == copies.end()) {\\n                copies[random] = new Node(random -> val, NULL, NULL);\\n            }\\n            copies[node] -> next = next ? copies[next] : NULL;\\n            copies[node] -> random = random ? copies[random] : NULL;\\n            node = next;\\n        }\\n        return copies[head];\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> copies;\\n};\\n```\\n\\n**Recursive**\\n\\nRecursively copy the `next` and `random` pointers.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) {\\n            return NULL;\\n        }\\n        if (copies.find(head) == copies.end()) {\\n            copies[head] = new Node(head -> val, NULL, NULL);\\n            copies[head] -> next = copyRandomList(head -> next);\\n            copies[head] -> random = copyRandomList(head -> random);\\n        }\\n        return copies[head];\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> copies;\\n};\\n```\\n\\n**O(1)-space**\\n\\nOf course, as suggested by the hints, you may use the `next` pointer of each node to store its copy. This method is fancier.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) {\\n            return NULL;\\n        }\\n        Node *cur = head, *next, *temp, *ans;\\n        while (cur) {\\n            next = cur -> next;\\n            cur -> next = new Node(cur -> val, next, NULL);;\\n            cur = next;\\n        }\\n        cur = head;\\n        while (cur) {\\n            if (cur -> random) {\\n                cur -> next -> random = cur -> random -> next;\\n            }\\n            cur = cur -> next -> next;\\n        }\\n        cur = head, ans = temp = head -> next;\\n        while (cur) {\\n            cur -> next = cur -> next -> next;\\n            temp -> next = temp -> next ? temp -> next -> next : NULL;\\n            cur = cur -> next;\\n            temp = temp -> next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) {\\n            return NULL;\\n        }\\n        copies[head] = new Node(head -> val, NULL, NULL);\\n        Node* node = head;\\n        while (node) {\\n            Node *next = node -> next, *random = node -> random;\\n            if (next && copies.find(next) == copies.end()) {\\n                copies[next] = new Node(next -> val, NULL, NULL);\\n            }\\n            if (random && copies.find(random) == copies.end()) {\\n                copies[random] = new Node(random -> val, NULL, NULL);\\n            }\\n            copies[node] -> next = next ? copies[next] : NULL;\\n            copies[node] -> random = random ? copies[random] : NULL;\\n            node = next;\\n        }\\n        return copies[head];\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> copies;\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) {\\n            return NULL;\\n        }\\n        if (copies.find(head) == copies.end()) {\\n            copies[head] = new Node(head -> val, NULL, NULL);\\n            copies[head] -> next = copyRandomList(head -> next);\\n            copies[head] -> random = copyRandomList(head -> random);\\n        }\\n        return copies[head];\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> copies;\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (!head) {\\n            return NULL;\\n        }\\n        Node *cur = head, *next, *temp, *ans;\\n        while (cur) {\\n            next = cur -> next;\\n            cur -> next = new Node(cur -> val, next, NULL);;\\n            cur = next;\\n        }\\n        cur = head;\\n        while (cur) {\\n            if (cur -> random) {\\n                cur -> next -> random = cur -> random -> next;\\n            }\\n            cur = cur -> next -> next;\\n        }\\n        cur = head, ans = temp = head -> next;\\n        while (cur) {\\n            cur -> next = cur -> next -> next;\\n            temp -> next = temp -> next ? temp -> next -> next : NULL;\\n            cur = cur -> next;\\n            temp = temp -> next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004014,
                "title": "simple-java-solution-using-hashmap-o-n-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Map<Node, Node> map = new HashMap();\\n        Node temp = head;\\n        while(temp != null) {\\n            map.put(temp, new Node(temp.val));\\n            temp = temp.next;\\n        }\\n        temp = head;\\n        while(temp != null) {\\n            map.get(temp).next = map.get(temp.next);\\n            map.get(temp).random = map.get(temp.random);\\n            temp = temp.next;\\n        }\\n        return map.get(head);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Map<Node, Node> map = new HashMap();\\n        Node temp = head;\\n        while(temp != null) {\\n            map.put(temp, new Node(temp.val));\\n            temp = temp.next;\\n        }\\n        temp = head;\\n        while(temp != null) {\\n            map.get(temp).next = map.get(temp.next);\\n            map.get(temp).random = map.get(temp.random);\\n            temp = temp.next;\\n        }\\n        return map.get(head);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841320,
                "title": "c-efficient-without-using-map-tc-o-n-sc-o-1-3-steps-with-solution-video",
                "content": "#### *please Upvote, If you find its helpful :)*\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node *iter = head; \\n          Node *front = head;\\n\\n          // First round: make copy of each node,\\n          // and link them together side-by-side in a single list.\\n          while (iter != NULL) {\\n            front = iter->next;\\n\\n            Node *copy = new Node(iter->val);\\n            iter->next = copy;\\n            copy->next = front;\\n\\n            iter = front;\\n          }\\n\\n          // Second round: assign random pointers for the copy nodes.\\n          iter = head;\\n          while (iter != NULL) {\\n            if (iter->random != NULL) {\\n              iter->next->random = iter->random->next;\\n            }\\n            iter = iter->next->next;\\n          }\\n\\n          // Third round: restore the original list, and extract the copy list.\\n          iter = head;\\n          Node *pseudoHead = new Node(0);\\n          Node *copy = pseudoHead;\\n\\n          while (iter != NULL) {\\n            front = iter->next->next;\\n\\n            // extract the copy\\n            copy->next = iter->next;\\n\\n            // restore the original list\\n            iter->next = front;\\n              \\n            copy = copy -> next; \\n            iter = front;\\n          }\\n          return pseudoHead->next;\\n    }\\n};\\n```\\n*Check comment for video solution by striver* :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node *iter = head; \\n          Node *front = head;\\n\\n          // First round: make copy of each node,\\n          // and link them together side-by-side in a single list.\\n          while (iter != NULL) {\\n            front = iter->next;\\n\\n            Node *copy = new Node(iter->val);\\n            iter->next = copy;\\n            copy->next = front;\\n\\n            iter = front;\\n          }\\n\\n          // Second round: assign random pointers for the copy nodes.\\n          iter = head;\\n          while (iter != NULL) {\\n            if (iter->random != NULL) {\\n              iter->next->random = iter->random->next;\\n            }\\n            iter = iter->next->next;\\n          }\\n\\n          // Third round: restore the original list, and extract the copy list.\\n          iter = head;\\n          Node *pseudoHead = new Node(0);\\n          Node *copy = pseudoHead;\\n\\n          while (iter != NULL) {\\n            front = iter->next->next;\\n\\n            // extract the copy\\n            copy->next = iter->next;\\n\\n            // restore the original list\\n            iter->next = front;\\n              \\n            copy = copy -> next; \\n            iter = front;\\n          }\\n          return pseudoHead->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748462,
                "title": "simple-and-short-swift-solution",
                "content": "```\\nclass Solution {\\n    var memo = [Node? : Node?]()\\n    func copyRandomList(_ head: Node?) -> Node? {\\n        return constructList(head)\\n    }\\n    \\n    func constructList(_ node: Node?) -> Node? {\\n        if let node = memo[node] {\\n            return node\\n        }\\n        guard let node = node else { return nil }\\n        let newNode = Node(node.val)\\n        memo[node] = newNode\\n        newNode.next = constructList(node.next)\\n        newNode.random = constructList(node.random)\\n        return newNode\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var memo = [Node? : Node?]()\\n    func copyRandomList(_ head: Node?) -> Node? {\\n        return constructList(head)\\n    }\\n    \\n    func constructList(_ node: Node?) -> Node? {\\n        if let node = memo[node] {\\n            return node\\n        }\\n        guard let node = node else { return nil }\\n        let newNode = Node(node.val)\\n        memo[node] = newNode\\n        newNode.next = constructList(node.next)\\n        newNode.random = constructList(node.random)\\n        return newNode\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 443516,
                "title": "super-simple-python-solution-99-time-100-space",
                "content": "\\n        \\n        if head is None:\\n            return None\\n        \\n        d = {}\\n        curr = head\\n        \\n        while curr:\\n            d[curr] = Node(curr.val, None, None)\\n            curr = curr.next\\n            \\n        \\n        curr = head\\n        \\n        while curr:\\n            if curr.next != None:\\n                d[curr].next = d[curr.next]\\n            if curr.random != None:\\n                d[curr].random = d[curr.random]\\n            curr = curr.next\\n        \\n            \\n        \\n        return d[head]\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n        \\n        if head is None:\\n            return None\\n        \\n        d = {}\\n        curr = head\\n        \\n        while curr:\\n            d[curr] = Node(curr.val, None, None)\\n            curr = curr.next\\n            \\n        \\n        curr = head\\n        \\n        while curr:\\n            if curr.next != None:\\n                d[curr].next = d[curr.next]\\n            if curr.random != None:\\n                d[curr].random = d[curr.random]\\n            curr = curr.next\\n        \\n            \\n        \\n        return d[head]\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 360360,
                "title": "javascript-recursive",
                "content": "```\\nvar copyRandomList = function(head) {\\n    let visited = new Map();\\n    \\n    let helper = (node) => {\\n        if (!node) return null;\\n        if (visited.has(node)) return visited.get(node);\\n        \\n        let newNode = new Node(node.val);\\n        visited.set(node, newNode);\\n        newNode.next = helper(node.next);\\n        newNode.random = helper(node.random);\\n        return newNode;\\n    }\\n    return helper(head);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar copyRandomList = function(head) {\\n    let visited = new Map();\\n    \\n    let helper = (node) => {\\n        if (!node) return null;\\n        if (visited.has(node)) return visited.get(node);\\n        \\n        let newNode = new Node(node.val);\\n        visited.set(node, newNode);\\n        newNode.next = helper(node.next);\\n        newNode.random = helper(node.random);\\n        return newNode;\\n    }\\n    return helper(head);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 136171,
                "title": "simple-python-solution-beats-100",
                "content": "```\\nclass Solution(object):\\n    def copyRandomList(self, head):\\n        \"\"\"\\n        :type head: RandomListNode\\n        :rtype: RandomListNode\\n        \"\"\"\\n        map = {}\\n        iterNode = head\\n        while iterNode:\\n            map[iterNode] = RandomListNode(iterNode.label)\\n            iterNode = iterNode.next\\n        \\n        iterNode = head\\n        while iterNode:\\n            map[iterNode].next = map[iterNode.next] if iterNode.next else None\\n            map[iterNode].random = map[iterNode.random] if iterNode.random else None\\n            iterNode = iterNode.next\\n        return map[head] if head else None\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def copyRandomList(self, head):\\n        \"\"\"\\n        :type head: RandomListNode\\n        :rtype: RandomListNode\\n        \"\"\"\\n        map = {}\\n        iterNode = head\\n        while iterNode:\\n            map[iterNode] = RandomListNode(iterNode.label)\\n            iterNode = iterNode.next\\n        \\n        iterNode = head\\n        while iterNode:\\n            map[iterNode].next = map[iterNode.next] if iterNode.next else None\\n            map[iterNode].random = map[iterNode.random] if iterNode.random else None\\n            iterNode = iterNode.next\\n        return map[head] if head else None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43607,
                "title": "simple-yet-best-solution-in-c-using-constant-space",
                "content": "\\n* clone each node of the list and connect the cloned just after its original\\n* the random pointer of the cloned node can be easily fetched by its previous node `p->random->next`\\n* split the original node and its cloned collecting the `odd and even` nodes in a list\\n\\n```\\nclass Solution {\\npublic:\\n    RandomListNode *copyRandomList(RandomListNode *head) \\n    {\\n        RandomListNode newHead(0), *p = head, *t = NULL;\\n        while(p)\\n        {\\n            RandomListNode *cloned = new RandomListNode(p->label);\\n            cloned->next = p->next;\\n            p->next = cloned;\\n            p = cloned->next;\\n        }\\n        \\n        p = head;\\n        while(p && p->next)\\n        {\\n            if(p->random) p->next->random = p->random->next;\\n            p = p->next->next;\\n        }\\n        \\n        p = head;\\n        t = &newHead;\\n        while(p && p->next)\\n        {\\n            t->next = p->next;\\n            p->next = p->next->next;\\n            t = t->next;\\n            p = p->next;\\n        }\\n        t->next = NULL;\\n        return newHead.next;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    RandomListNode *copyRandomList(RandomListNode *head) \\n    {\\n        RandomListNode newHead(0), *p = head, *t = NULL;\\n        while(p)\\n        {\\n            RandomListNode *cloned = new RandomListNode(p->label);\\n            cloned->next = p->next;\\n            p->next = cloned;\\n            p = cloned->next;\\n        }\\n        \\n        p = head;\\n        while(p && p->next)\\n        {\\n            if(p->random) p->next->random = p->random->next;\\n            p = p->next->next;\\n        }\\n        \\n        p = head;\\n        t = &newHead;\\n        while(p && p->next)\\n        {\\n            t->next = p->next;\\n            p->next = p->next->next;\\n            t = t->next;\\n            p = p->next;\\n        }\\n        t->next = NULL;\\n        return newHead.next;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43765,
                "title": "o-n-time-3-passes-o-1-memory-usage-solution",
                "content": "    /**\\n     * Definition for singly-linked list with a random pointer.\\n     * class RandomListNode {\\n     *     int label;\\n     *     RandomListNode next, random;\\n     *     RandomListNode(int x) { this.label = x; }\\n     * };\\n     */\\n    public class Solution {\\n        public RandomListNode copyRandomList(RandomListNode head) {\\n            if (head == null)\\n                return null;\\n            RandomListNode c = head;\\n            while (c != null) {\\n                RandomListNode n = new RandomListNode(c.label);\\n                n.random = c.random;\\n                n.next = c.next;\\n                c.next = n;\\n                c = n.next;\\n            }\\n            c = head;\\n            while (c != null) {\\n                c = c.next;\\n                if (c.random != null)\\n                    c.random = c.random.next;\\n                c = c.next;\\n            }\\n            RandomListNode newHead = new RandomListNode(0);\\n            newHead.next = head;\\n            c = head;\\n            RandomListNode cNew = newHead;\\n            while (c != null) {\\n               cNew.next = c.next;\\n               c.next = c.next.next;\\n               cNew = cNew.next;\\n               c = c.next;\\n            }\\n            return newHead.next;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public RandomListNode copyRandomList(RandomListNode head) {\\n            if (head == null)\\n                return null;\\n            RandomListNode c = head;\\n            while (c != null) {\\n                RandomListNode n = new RandomListNode(c.label);\\n                n.random = c.random;\\n                n.next = c.next;\\n                c.next = n;\\n                c = n.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3797257,
                "title": "69-iq-solution",
                "content": "# Code\\n```\\nfunction copyRandomList(head: Node | null): Node | null {\\n    if (head == null) return null;\\n\\n    let map = new Map();\\n\\n    let current = head;\\n\\n    while (current) {\\n        map.set(current, new Node(current.val, current.next, current.random));\\n        current = current.next;\\n    }\\n\\n    map.forEach(node => {\\n        if (node.next) node.next = map.get(node.next);\\n        if (node.random) node.random = map.get(node.random);\\n    });\\n\\n    return map.get(head);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction copyRandomList(head: Node | null): Node | null {\\n    if (head == null) return null;\\n\\n    let map = new Map();\\n\\n    let current = head;\\n\\n    while (current) {\\n        map.set(current, new Node(current.val, current.next, current.random));\\n        current = current.next;\\n    }\\n\\n    map.forEach(node => {\\n        if (node.next) node.next = map.get(node.next);\\n        if (node.random) node.random = map.get(node.random);\\n    });\\n\\n    return map.get(head);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3718767,
                "title": "sharing-my-o-1-extra-space-solution-that-uses-pointer-tagging",
                "content": "# Intuition\\nTo get a O(1) solution, we essentially need to modify the original list (in-place) somehow to keep track of the copies of each node. [Most](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/43491/a-solution-with-constant-space-complexity-o-1-and-linear-time-complexity-o-n/) [other](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/1255721/c-both-solutions-explained-clearly-hashmap-method-constant-space-method/) [solutions](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/1059181/c-three-pass-o-n-0ms-beats-100-explanation-with-example/) go with inserting the copy right after the original, but I was in the mood for something fancier.\\n\\nInsight: We can store the address (memory pointer) of the copied node inside the original node itself- there is enough space! Or rather, we can _make_ enough space for it...\\n\\n# Background\\n## Pointer tagging\\n\\nSee [Wikipedia](https://en.wikipedia.org/wiki/Tagged_pointer).\\nOn a 64-bit system, pointers usually take up 64-bits = 8 bytes of space. But this is a convenient lie- pointers don\\'t _really_ need so much space. Having 64-bits would be enough to reference `2**64` bytes of memory, which is around 1.6 MILLION TERABYTES. Much more RAM than a single machine typically has. So, most operating systems cheat, and only use the first 48-bits of the pointer- the rest are usually set to 0.\\n\\nNow, we only need to find a place inside `Node` where we can stash an entire additional pointer (48-bits). (Remember, we need to modify each node in-place to get an `O(1)` solution.)\\n\\nWe can\\'t use `next` and `random` since those are pointers and use up at least 48 bits in their respective fields, leaving only 32 bits total - not enough.\\n\\nFlipping around the problem, if we somehow had 64 bits inside `Node`, we could store the pointer in the 48 bits, and use 16 bits to store some other value.\\n\\nOh- what divine coincidence... 16 bits is more than enough to represent all the values from our problem description; the range `[-10000, 10000]` has 20001 values, which is much less than `2**16` = 65536. (Even 15 bits, with 32768 values, would work... but that is a minor detail.) Maybe we can store `val` in the top 16-bits of our extra pointer.\\n\\nBuuut `val` is itself just an `int`, giving us a measely 32 bits. We need 64 bits to store the combination of `val` (16 bits) and the extra pointer (48 bits). Where do we get the extra 32 bits from?\\n\\nSeems like we are stuck... Or are we??\\n\\nTime to dig deeper...\\n\\n## Memory padding in C++ structs\\nHere\\'s the `Node` struct as given in the problem statement:\\n```cpp\\nclass Node {\\n    int val;\\n    Node* next;\\n    Node* random;\\n    //...\\n};\\n```\\n\\nNaively, one would think that our `Node` struct is just 20 bytes in size- `4`(`int val`) + `8`(`Node* next`) + `8`(`Node* random`). (`int` is 32-bits, and on a 64-bit system, a pointer typically takes up 8 bytes.)\\n\\nHowever, our compiler says `Node` is really 24 bytes wide:\\n```cpp\\ncout << sizeof(Node);  // prints 24\\n```\\n\\nWhat gives?\\n\\nThe answer lies in how the fields inside the struct are really laid out in memory. Instead of putting them right next to each other, the compiler is free to leave some blank bytes between them. This space is called padding.\\n\\nIn typical systems, pointers are aligned to 8 bytes. For `Node`, the compiler inserts extra 4 bytes of padding after `val` to make sure that `next` is properly aligned. See [Typical alignment of C structs on x86 (Wikipedia)](https://en.wikipedia.org/wiki/Data_structure_alignment#Typical_alignment_of_C_structs_on_x86) for more details.\\n\\nWe can take advantage of this padding to \"procure\" the extra space we needed.\\n\\n# Approach\\nWe define a separate struct `Node2` that is the same as `Node`, but with `uint64_t` for the `val` field instead of `int`. **Crucially, on most systems/compilers, this struct has the same size as `Node`.**\\n\\nNow, by casting our `Node*` pointers to `Node2*` pointers, we are able to access the padding bytes from the original struct. We can use pointer tagging to store both the original node value _and_ the additional address in this field.\\n\\n# Code\\n```cpp\\n// assuming 64-bit system\\nstatic_assert(sizeof(uintptr_t) == 8);\\n// number of extra bits that are unused in the pointers.\\n// we could technically make do with just 15 bits\\n// since the range of vals is between [-10000, 10000], i.e. 20001 numbers\\n// and pow(2, 15) == 32768 is enough to store all these nums.\\nconstexpr uint64_t NUM_EXTRA_BITS = 16;\\nconstexpr uint64_t VAL_SHIFT = 64 - NUM_EXTRA_BITS;\\nconstexpr uint64_t make_mask(uint64_t num_bits) {\\n    return (1ULL << num_bits) - 1;\\n}\\nconstexpr uint64_t PTR_BITS = make_mask(VAL_SHIFT);\\nconstexpr uint64_t VAL_BITS = make_mask(NUM_EXTRA_BITS) << VAL_SHIFT;\\n// make sure there is no overlap\\nstatic_assert((PTR_BITS & VAL_BITS) == 0);\\n\\nstruct Node2 {\\n    uint64_t tagged;\\n    struct Node2* next;\\n    struct Node2* random;\\n    int get_v() const {\\n        return tagged >> VAL_SHIFT;\\n    }\\n    void put_v(int v) {\\n        tagged |= uint64_t(v) << VAL_SHIFT;\\n    }\\n    void* get_ptr() const {\\n        return (void*)(tagged & PTR_BITS); \\n    }\\n    void put(void* ptr, int v) {\\n        // zero-ing out the field is really crucial to avoid undefined behaviour\\n        // without this line, we can\\'t be sure about the contents of padding bytes\\n        tagged = 0;\\n        put_ptr(ptr);\\n        put_v(v);\\n    }\\n    void put_ptr(void* ptr) {\\n        assert((int64_t(ptr) & VAL_BITS) == 0);\\n        tagged |= (int64_t)ptr;\\n    }\\n};\\n// this solution will break if the following assert is false\\nstatic_assert(sizeof(Node2) == sizeof(Node));\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head) {\\n        Node *copyhead = nullptr, *copytail = nullptr;\\n\\n        // create copy list and add tagged pointers\\n        for (Node* p = head; p; p = p->next) {\\n            auto copy = new Node(p->val);\\n            if (!copyhead) {\\n                copyhead = copy;\\n            }\\n            if (copytail) {\\n                copytail->next = copy;\\n            }\\n            copytail = copy;\\n            copy->random = p->random;\\n            auto* origptr = reinterpret_cast<Node2*>(p);\\n            // store address of copied node into the original node using pointer tagging\\n            origptr->put(copy, copy->val);\\n        }\\n        // get the addresses from tagged pointer\\n        for (Node* copy = copyhead; copy; copy = copy->next) {\\n            if (copy->random) {\\n                // copy->random is currently the original random node\\n                auto* taggedptr = reinterpret_cast<Node2*>(copy->random);\\n                // get the copied node from the original node\\n                copy->random = (Node*)taggedptr->get_ptr();\\n            }\\n        }\\n        // restore the original values\\n        for (Node* p = head; p; p = p->next) {\\n            auto* taggedptr = reinterpret_cast<Node2*>(p);\\n            p->val = taggedptr->get_v();\\n        }\\n        return copyhead;\\n    }\\n};\\n```\\n\\n# Another solution\\nIf you were following closely, you might have noticed an alternate solution which avoids using the padding bytes entirely.\\n\\nOur requirements are that we need to store the 48-bit pointer somewhere inside the `Node` fields. Now note that our `next` and `random` fields are themselves pointers, so they only take up 48-bits each, leaving 16+16 = 32 bits unused. We can get another 16 bits from the upper half of `val` (again, we only need 15 bits to store all the nums between `[-10000, 10000]`). \\n\\nSo, by taking 16 bits from each of the three fields, we actually have enough space for our additional pointer. We just need to split it across the three fields. See if you can implement this :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Node {\\n    int val;\\n    Node* next;\\n    Node* random;\\n    //...\\n};\\n```\n```cpp\\ncout << sizeof(Node);  // prints 24\\n```\n```cpp\\n// assuming 64-bit system\\nstatic_assert(sizeof(uintptr_t) == 8);\\n// number of extra bits that are unused in the pointers.\\n// we could technically make do with just 15 bits\\n// since the range of vals is between [-10000, 10000], i.e. 20001 numbers\\n// and pow(2, 15) == 32768 is enough to store all these nums.\\nconstexpr uint64_t NUM_EXTRA_BITS = 16;\\nconstexpr uint64_t VAL_SHIFT = 64 - NUM_EXTRA_BITS;\\nconstexpr uint64_t make_mask(uint64_t num_bits) {\\n    return (1ULL << num_bits) - 1;\\n}\\nconstexpr uint64_t PTR_BITS = make_mask(VAL_SHIFT);\\nconstexpr uint64_t VAL_BITS = make_mask(NUM_EXTRA_BITS) << VAL_SHIFT;\\n// make sure there is no overlap\\nstatic_assert((PTR_BITS & VAL_BITS) == 0);\\n\\nstruct Node2 {\\n    uint64_t tagged;\\n    struct Node2* next;\\n    struct Node2* random;\\n    int get_v() const {\\n        return tagged >> VAL_SHIFT;\\n    }\\n    void put_v(int v) {\\n        tagged |= uint64_t(v) << VAL_SHIFT;\\n    }\\n    void* get_ptr() const {\\n        return (void*)(tagged & PTR_BITS); \\n    }\\n    void put(void* ptr, int v) {\\n        // zero-ing out the field is really crucial to avoid undefined behaviour\\n        // without this line, we can\\'t be sure about the contents of padding bytes\\n        tagged = 0;\\n        put_ptr(ptr);\\n        put_v(v);\\n    }\\n    void put_ptr(void* ptr) {\\n        assert((int64_t(ptr) & VAL_BITS) == 0);\\n        tagged |= (int64_t)ptr;\\n    }\\n};\\n// this solution will break if the following assert is false\\nstatic_assert(sizeof(Node2) == sizeof(Node));\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head) {\\n        Node *copyhead = nullptr, *copytail = nullptr;\\n\\n        // create copy list and add tagged pointers\\n        for (Node* p = head; p; p = p->next) {\\n            auto copy = new Node(p->val);\\n            if (!copyhead) {\\n                copyhead = copy;\\n            }\\n            if (copytail) {\\n                copytail->next = copy;\\n            }\\n            copytail = copy;\\n            copy->random = p->random;\\n            auto* origptr = reinterpret_cast<Node2*>(p);\\n            // store address of copied node into the original node using pointer tagging\\n            origptr->put(copy, copy->val);\\n        }\\n        // get the addresses from tagged pointer\\n        for (Node* copy = copyhead; copy; copy = copy->next) {\\n            if (copy->random) {\\n                // copy->random is currently the original random node\\n                auto* taggedptr = reinterpret_cast<Node2*>(copy->random);\\n                // get the copied node from the original node\\n                copy->random = (Node*)taggedptr->get_ptr();\\n            }\\n        }\\n        // restore the original values\\n        for (Node* p = head; p; p = p->next) {\\n            auto* taggedptr = reinterpret_cast<Node2*>(p);\\n            p->val = taggedptr->get_v();\\n        }\\n        return copyhead;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3341661,
                "title": "c-easy-commented-code-map-solution-100-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere, an unordered map is used to store [key : pairs] as [old nodes : new nodes]\\n\\nSteps :\\n1. If the given Linked List is empty return it\\n2. Loop through the Linked List and check for the presence of each node in the map. If absent, make a new copy for the current node and store it in the map as [Old Node : New Node]\\n3. Now we have all the new copies in our map. Loop through the Linked List again and set the corresponding next and random pointers for new nodes.\\n4. Return the corresponding copy for head;\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head)   return head;\\n        unordered_map<Node*, Node*> copy;\\n        Node* it = head;\\n        while(it) if(!copy[it]) copy[it] = new Node(it->val), it = it->next;\\n        it = head;\\n        while(it) copy[it]->next = it->next ? copy[it->next] : nullptr, copy[it]->random = it->random ? copy[it->random] : nullptr, it = it->next;\\n        return copy[head];\\n    }\\n};\\n```\\n\\nUpvote if you find this helpful :)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head)   return head;\\n        unordered_map<Node*, Node*> copy;\\n        Node* it = head;\\n        while(it) if(!copy[it]) copy[it] = new Node(it->val), it = it->next;\\n        it = head;\\n        while(it) copy[it]->next = it->next ? copy[it->next] : nullptr, copy[it]->random = it->random ? copy[it->random] : nullptr, it = it->next;\\n        return copy[head];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203441,
                "title": "python-straightforward-iterative-solution-with-a-dict",
                "content": "```\\ndef copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        \\n        d = {}\\n        dummy = Node(-1000)\\n        \\n        prev = dummy\\n        cur = head\\n        \\n\\t\\t# iterate over original list\\n        while cur:\\n\\t\\t\\t# create a copy of current node\\n            prev.next = Node(cur.val)\\n\\t\\t\\t\\n\\t\\t\\t# map original node to its\\' copy\\n            d[cur] = prev.next\\n\\t\\t\\t\\n            prev = prev.next\\n            cur = cur.next\\n        \\n        cur = head\\n        \\n        while cur:\\n\\t\\t\\t# set each random pointer in the new list to correct node using mapping\\n            d[cur].random = d[cur.random] if cur.random else None\\n            cur = cur.next\\n        \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\ndef copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        \\n        d = {}\\n        dummy = Node(-1000)\\n        \\n        prev = dummy\\n        cur = head\\n        \\n\\t\\t# iterate over original list\\n        while cur:\\n\\t\\t\\t# create a copy of current node\\n            prev.next = Node(cur.val)\\n\\t\\t\\t\\n\\t\\t\\t# map original node to its\\' copy\\n            d[cur] = prev.next\\n\\t\\t\\t\\n            prev = prev.next\\n            cur = cur.next\\n        \\n        cur = head\\n        \\n        while cur:\\n\\t\\t\\t# set each random pointer in the new list to correct node using mapping\\n            d[cur].random = d[cur.random] if cur.random else None\\n            cur = cur.next\\n        \\n        return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1841602,
                "title": "most-optimal-approach-with-constant-space-with-intuition",
                "content": "![image](https://assets.leetcode.com/users/images/836ed23c-8302-4414-b472-20f4f9957155_1647064947.629208.png)\\nNow after these operations the linked list will look like\\n\\n![image](https://assets.leetcode.com/users/images/a968a4e4-47a0-42ad-8da7-c48697dee9c7_1647065226.635323.png)\\n![image](https://assets.leetcode.com/users/images/dc58fbed-18d4-4fb2-a786-221aa324b84d_1647065467.7630546.png)\\n![image](https://assets.leetcode.com/users/images/898e94c4-4f0b-4417-93a2-dd00bbe52698_1647065508.4319434.png)\\n\\nNow comes the third step which is seperating these two linked lists.\\n![image](https://assets.leetcode.com/users/images/9d77a9ac-8f0f-4fb9-bd96-02515319ed83_1647066370.315812.png)\\n\\nReturn the final in the end.\\n\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) { \\n\\t //STEP 1\\n        if(!head) return NULL; \\n        Node* temp = head;\\n        while(temp){ // while temp is not null\\n            Node* node = new Node(temp->val);\\n            node->next = temp->next; \\n            temp->next = node;\\n            temp = node->next;\\n        }\\n\\t\\t\\n\\t\\t//Step 2\\n        temp = head; \\n        while(temp){\\n            temp->next->random = (temp->random)?temp->random->next:NULL; \\n            temp = temp->next->next; \\n        }\\n\\t\\t\\n\\t\\t//Step 3\\n        Node* final = head->next;\\n        temp = head->next;\\n        while(head){ \\n            head->next = temp->next;\\n            head = head->next; \\n            if(!head) break; \\n            temp->next = head->next; \\n            temp = temp->next;\\n        }\\n        return final;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) { \\n\\t //STEP 1\\n        if(!head) return NULL; \\n        Node* temp = head;\\n        while(temp){ // while temp is not null\\n            Node* node = new Node(temp->val);\\n            node->next = temp->next; \\n            temp->next = node;\\n            temp = node->next;\\n        }\\n\\t\\t\\n\\t\\t//Step 2\\n        temp = head; \\n        while(temp){\\n            temp->next->random = (temp->random)?temp->random->next:NULL; \\n            temp = temp->next->next; \\n        }\\n\\t\\t\\n\\t\\t//Step 3\\n        Node* final = head->next;\\n        temp = head->next;\\n        while(head){ \\n            head->next = temp->next;\\n            head = head->next; \\n            if(!head) break; \\n            temp->next = head->next; \\n            temp = temp->next;\\n        }\\n        return final;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059423,
                "title": "c-recursive-dfs-solution-explained-100-time-20-space",
                "content": "Not the most memory-efficient approach, but still fun to develop.\\n\\nWith the more naive solution, we will store the created nodes as we go in `m`, an `unordered_map` with original `Node`s as key and matching copies of them as values.\\n\\nIn our main function we will just create a `res` `Node` pointer and assign the value of `copyNode(head)` to it.\\n\\nThe `copyNode` helper function will:\\n* return `head`, when this is `NULL`;\\n* create a new pointer `res` with the same `->val` of `head` and and assign it to `m`;\\n* we will then go down the list with recursive calls to generate all the `next` values up to the end;\\n* by now, the whole list has been generated, so we can easily assign `res->random` as well, picking it from the matching element we stored in `m[head->random]`;\\n* return the fully created and connected new `Node` pointer `res`.\\n\\nOnce done with the helper function, we will also return `res` in the main one :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    unordered_map<Node*, Node*> m;\\n    Node* copyNode(Node* head) {\\n        // edge case: NULL head\\n        if (!head) return head;\\n        // creating and storing the new node\\n        Node *res = m[head] = new Node(head->val);\\n        // creating all the next nodes\\n        res->next = copyNode(head->next);\\n        // assigning random\\n        res->random = m[head->random];\\n        return res;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node *res = copyNode(head);\\n        return res;\\n    }\\n};\\n```\\n\\nSame logic, but with iteration instead of leveraging a big recursive stack; similar time performance, but with memory usage from 5% to ~50%:\\n\\n```cpp\\nclass Solution {\\nprivate:\\n    unordered_map<Node*, Node*> m;\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // edge case: empty list\\n        if (!head) return NULL;\\n        // support variables\\n        Node *tmp = head, *newHead = m[head] = new Node(tmp->val), *newTmp = newHead;\\n        tmp = tmp->next;\\n        // creating all the next nodes\\n        while (tmp) {\\n            // storing and connecting next nodes\\n            newTmp->next = m[tmp] = new Node(tmp->val);\\n            // advancing newTmp and tmp\\n            newTmp = newTmp->next;\\n            tmp = tmp->next;\\n        }\\n        // assigning all the random nodes\\n        tmp = head;\\n        while (tmp) {\\n            // connecting random nodes\\n            m[tmp]->random = m[tmp->random];\\n            // advancing tmp\\n            tmp = tmp->next;\\n        }\\n        return newHead;\\n    }\\n};\\n```\\n\\nFinally, the extra challenge from the problem - no extra memory.\\n\\nTo do so, we first of all check if we have an empty list - no point in moving forward, in case.\\n\\nIf not, then we create a couple of support variables:\\n* `tmp`, our main iterator, initially set to point to the original `head`;\\n* `newHead`, that we will use only at the end to return the copied list;\\n* `newTmp`, as the name implies the homologous of `tmp` in our cloned list.\\n\\nThen we will move on with a first loop, running as long as `tmp` is not `NULL`, to create all the new nodes, splicing them right after the matching node from the original list:\\n* `newTmp` will be assigned the value of a new node with value `tmp->val`;\\n* `newTmp->next` will become `tmp->next`;\\n* and in turn `tmp->next` will be `newTmp`;\\n* finally, we advance `tmp` by one step and loop again.\\n\\nTime for the second loop, right after resetting `tmp = head` and with the same condition; here we will take care of the `random` property:\\n* `tmp->next->random` (ie: the `random` property of a newly created node right after `tmp`, with it always being an original node) will take the value of `tmp->random->next`, since we know that `tmp->random` is again an original node and the one immediately following it is its matching copy;\\n* since we want to keep working only with original nodes, this time we advance by 2 positions (and we can be sure that as long as `tmp` is not `NULL`, so it will be the case for `tmp->next`, since an original node is now always followed by a copied one).\\n\\nTime for one last loop, after again resetting `tmp = head`, but this time also storing `newHead = head->next`. We will then:\\n* store the node following `tmp` (guaranted to be a new one) in `newTmp`;\\n* splice said node out of the old list, with `tmp->next = tmp->next->next`;\\n* if `newTmp` is not the last node, then we will similarly set it to connect with the next cloned node;\\n* finally, we advance `tmp` by one step and loop again.\\n\\nOnce done, we can safely return `newHead` :)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // edge case: empty list\\n        if (!head) return NULL;\\n        // support variables\\n        Node *tmp = head, *newHead, *newTmp;\\n        // creating all the next nodes\\n        while (tmp) {\\n            // creating a new node\\n            newTmp = new Node(tmp->val);\\n            // splicing newTmp\\n            newTmp->next = tmp->next;\\n            tmp->next = newTmp;\\n            // advancing tmp\\n            tmp = newTmp->next;\\n        }\\n        // assigning all the random nodes\\n        tmp = head;\\n        while (tmp) {\\n            // connecting random nodes\\n            tmp->next->random = tmp->random ? tmp->random->next : NULL;\\n            // advancing tmp\\n            tmp = tmp->next->next;\\n        }\\n        // splitting the lists\\n        tmp = head;\\n        newHead = head->next;\\n        while (tmp) {\\n            // storing the new node\\n\\t\\t\\tnewTmp = tmp->next;\\n            // restoring original list to be only made of original nodes\\n            tmp->next = tmp->next->next;\\n            if (newTmp->next) newTmp->next = newTmp->next->next;\\n            // advancing tmp\\n            tmp = tmp->next;\\n        }\\n        return newHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```cpp\\nclass Solution {\\nprivate:\\n    unordered_map<Node*, Node*> m;\\n    Node* copyNode(Node* head) {\\n        // edge case: NULL head\\n        if (!head) return head;\\n        // creating and storing the new node\\n        Node *res = m[head] = new Node(head->val);\\n        // creating all the next nodes\\n        res->next = copyNode(head->next);\\n        // assigning random\\n        res->random = m[head->random];\\n        return res;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node *res = copyNode(head);\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\nprivate:\\n    unordered_map<Node*, Node*> m;\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // edge case: empty list\\n        if (!head) return NULL;\\n        // support variables\\n        Node *tmp = head, *newHead = m[head] = new Node(tmp->val), *newTmp = newHead;\\n        tmp = tmp->next;\\n        // creating all the next nodes\\n        while (tmp) {\\n            // storing and connecting next nodes\\n            newTmp->next = m[tmp] = new Node(tmp->val);\\n            // advancing newTmp and tmp\\n            newTmp = newTmp->next;\\n            tmp = tmp->next;\\n        }\\n        // assigning all the random nodes\\n        tmp = head;\\n        while (tmp) {\\n            // connecting random nodes\\n            m[tmp]->random = m[tmp->random];\\n            // advancing tmp\\n            tmp = tmp->next;\\n        }\\n        return newHead;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // edge case: empty list\\n        if (!head) return NULL;\\n        // support variables\\n        Node *tmp = head, *newHead, *newTmp;\\n        // creating all the next nodes\\n        while (tmp) {\\n            // creating a new node\\n            newTmp = new Node(tmp->val);\\n            // splicing newTmp\\n            newTmp->next = tmp->next;\\n            tmp->next = newTmp;\\n            // advancing tmp\\n            tmp = newTmp->next;\\n        }\\n        // assigning all the random nodes\\n        tmp = head;\\n        while (tmp) {\\n            // connecting random nodes\\n            tmp->next->random = tmp->random ? tmp->random->next : NULL;\\n            // advancing tmp\\n            tmp = tmp->next->next;\\n        }\\n        // splitting the lists\\n        tmp = head;\\n        newHead = head->next;\\n        while (tmp) {\\n            // storing the new node\\n\\t\\t\\tnewTmp = tmp->next;\\n            // restoring original list to be only made of original nodes\\n            tmp->next = tmp->next->next;\\n            if (newTmp->next) newTmp->next = newTmp->next->next;\\n            // advancing tmp\\n            tmp = tmp->next;\\n        }\\n        return newHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 935355,
                "title": "two-js-solutions",
                "content": "```\\n/*\\n[Recursion, Memoization]\\n1. Consider every node as a list.\\n2. Record each original node to hash table with its value being a clone node.\\n3. Copy next node and random node.\\n4. Return node.\\n*/\\nvar copyRandomList = function(head, cloneMap=new Map()) {\\n    if (!head) {\\n        return null;\\n    }\\n    if (cloneMap.has(head)) {\\n        return cloneMap.get(head);\\n    }\\n    let clone = new Node(head.val, null, null);\\n    cloneMap.set(head, clone);\\n    clone.next = copyRandomList(head.next, cloneMap);\\n    clone.random = copyRandomList(head.random, cloneMap);\\n    return clone;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\\n\\n```\\n/*\\n1. Iterate through given list. For each node, create a clone and record it to a hash table with an entry being\\n(node, clone node). Then, push the original node to an array.\\n2. Iterate through the array. For each node, get the clone node and\\n(1) Set next pointer to next node\\'s clone\\n(2) Set random pointer to current node\\'s random node\\'s clone\\n3. Return the cloned head from hash table.\\n*/\\nvar copyRandomList = function(head) {\\n    if (!head) {\\n        return null;\\n    }\\n    let cloneMap = new Map(), arr = [];\\n    let cur = head;\\n    while (cur !== null) {\\n        arr.push(cur);\\n        let cloneNode = new Node(cur.val, null, null);\\n        cloneMap.set(cur, cloneNode);\\n        cur = cur.next;\\n    }\\n    \\n    for (let i = 0; i < arr.length; i++) {\\n        let clone = cloneMap.get(arr[i]);\\n        // set next pointer\\n        if (i < arr.length-1) {\\n            clone.next = cloneMap.get(arr[i+1]);\\n        }\\n        // set random pointer\\n        if (arr[i].random !== null) {\\n            clone.random = cloneMap.get(arr[i].random);\\n        }\\n    }\\n    return cloneMap.get(head);\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\n[Recursion, Memoization]\\n1. Consider every node as a list.\\n2. Record each original node to hash table with its value being a clone node.\\n3. Copy next node and random node.\\n4. Return node.\\n*/\\nvar copyRandomList = function(head, cloneMap=new Map()) {\\n    if (!head) {\\n        return null;\\n    }\\n    if (cloneMap.has(head)) {\\n        return cloneMap.get(head);\\n    }\\n    let clone = new Node(head.val, null, null);\\n    cloneMap.set(head, clone);\\n    clone.next = copyRandomList(head.next, cloneMap);\\n    clone.random = copyRandomList(head.random, cloneMap);\\n    return clone;\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```\n```\\n/*\\n1. Iterate through given list. For each node, create a clone and record it to a hash table with an entry being\\n(node, clone node). Then, push the original node to an array.\\n2. Iterate through the array. For each node, get the clone node and\\n(1) Set next pointer to next node\\'s clone\\n(2) Set random pointer to current node\\'s random node\\'s clone\\n3. Return the cloned head from hash table.\\n*/\\nvar copyRandomList = function(head) {\\n    if (!head) {\\n        return null;\\n    }\\n    let cloneMap = new Map(), arr = [];\\n    let cur = head;\\n    while (cur !== null) {\\n        arr.push(cur);\\n        let cloneNode = new Node(cur.val, null, null);\\n        cloneMap.set(cur, cloneNode);\\n        cur = cur.next;\\n    }\\n    \\n    for (let i = 0; i < arr.length; i++) {\\n        let clone = cloneMap.get(arr[i]);\\n        // set next pointer\\n        if (i < arr.length-1) {\\n            clone.next = cloneMap.get(arr[i+1]);\\n        }\\n        // set random pointer\\n        if (arr[i].random !== null) {\\n            clone.random = cloneMap.get(arr[i].random);\\n        }\\n    }\\n    return cloneMap.get(head);\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 744455,
                "title": "modular-and-easy-o-n-o-1-cpp",
                "content": "After writing my code, I saw the top answers. I felt that this question needs a good modular structure for others to really understand without scratching their head.\\n\\nIdea: \\n1. Simply insert copy of nodes between the nodes of original List\\n2. Copy Random pointers for the Clone/Copy List.\\n3. Then assign the next pointers correctly to segragate both the list.\\n\\nNote: We need to keep the original list Untouched. (I was stuck for 5 mins because after writing everything correctly, I was not restoring the original List, And I was getting some weird error.) :(\\n\\nOne of my friends adviced me to practice writng quality code. Its something every Interviewer looks forward to.\\n\\nMy code: \\n\\n```\\nclass Solution {\\n    private:\\n        void insertNewNodes(Node* head) {\\n            Node* itr=head;\\n            while(itr) {\\n                Node* temp=new Node(itr->val);\\n                temp->next=itr->next;\\n                itr->next=temp;\\n                itr=itr->next->next;\\n            }\\n        }\\n        void copyRandomPointers(Node* head) {\\n            Node* itr=head;\\n            while(itr) {\\n                if(itr->random == NULL) itr->next->random=NULL;\\n                else itr->next->random=itr->random->next;\\n                itr=itr->next->next;\\n            }\\n        }\\n        void copyNextPointers(Node* head) {\\n            Node* itr=head;\\n            while(itr) {\\n                Node* temp=itr->next->next;\\n                if(temp) itr->next->next=itr->next->next->next;\\n                itr->next=temp;\\n                itr=itr->next;\\n            }\\n        }\\n    public:\\n        Node* copyRandomList(Node* head) {\\n            if(head == NULL) return NULL;\\n            insertNewNodes(head);\\n            Node* headCopy=head->next;\\n            copyRandomPointers(head);\\n            copyNextPointers(head);\\n            return headCopy;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private:\\n        void insertNewNodes(Node* head) {\\n            Node* itr=head;\\n            while(itr) {\\n                Node* temp=new Node(itr->val);\\n                temp->next=itr->next;\\n                itr->next=temp;\\n                itr=itr->next->next;\\n            }\\n        }\\n        void copyRandomPointers(Node* head) {\\n            Node* itr=head;\\n            while(itr) {\\n                if(itr->random == NULL) itr->next->random=NULL;\\n                else itr->next->random=itr->random->next;\\n                itr=itr->next->next;\\n            }\\n        }\\n        void copyNextPointers(Node* head) {\\n            Node* itr=head;\\n            while(itr) {\\n                Node* temp=itr->next->next;\\n                if(temp) itr->next->next=itr->next->next->next;\\n                itr->next=temp;\\n                itr=itr->next;\\n            }\\n        }\\n    public:\\n        Node* copyRandomList(Node* head) {\\n            if(head == NULL) return NULL;\\n            insertNewNodes(head);\\n            Node* headCopy=head->next;\\n            copyRandomPointers(head);\\n            copyNextPointers(head);\\n            return headCopy;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 710506,
                "title": "standard-java-solution",
                "content": "### Theory\\nOnce you know the pattern for this problem, its actually very trivial. We simply need to keep a clone space mapping from the original to the newly created ones. We first traverse through to create the clone space, then we do a second pass to attach the pointers. Notice how once we do our initial traversal, all the nodes are defined in our map, and therefore assigning random pointers will not be a problem now. \\n\\n### Solution\\n```\\n    public Node copyRandomList(Node head) {\\n        Map<Node, Node> map = new HashMap<>();\\n        Node curr = head;\\n        while (curr != null) {\\n            map.put(curr, new Node(curr.val));\\n            curr = curr.next;\\n        }\\n        \\n        curr = head;\\n        while (curr != null) {\\n            map.get(curr).random = map.get(curr.random);\\n            map.get(curr).next = map.get(curr.next);\\n            curr = curr.next;\\n        }\\n        \\n        return map.get(head);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public Node copyRandomList(Node head) {\\n        Map<Node, Node> map = new HashMap<>();\\n        Node curr = head;\\n        while (curr != null) {\\n            map.put(curr, new Node(curr.val));\\n            curr = curr.next;\\n        }\\n        \\n        curr = head;\\n        while (curr != null) {\\n            map.get(curr).random = map.get(curr.random);\\n            map.get(curr).next = map.get(curr.next);\\n            curr = curr.next;\\n        }\\n        \\n        return map.get(head);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 650032,
                "title": "java-solution-without-using-hashmap",
                "content": "class Solution {\\n    public Node copyRandomList(Node head) {\\n        \\n        if(head == null){\\n            return null;\\n        }\\n        \\n        //copy linked list to following structure A -> A\\' -> B -> B\\' .... -> C -> C\\'\\n        Node p = head;\\n        while(p != null){\\n            Node tmp = p.next;\\n            p.next = new Node(p.val);\\n            p.next.next = tmp;\\n            p = tmp;\\n        }\\n        \\n        //copy random list\\n        p = head;\\n        while(p != null){\\n            if(p.random == null){\\n                p.next.random = null;\\n            }else{\\n                p.next.random = p.random.next;\\n            }\\n            p = p.next.next;\\n        }\\n        \\n        //split structure A -> A\\' -> B -> B\\' => A -> B | A\\' -> B\\'\\n        Node newHead = head.next;\\n        Node q = newHead;\\n        p = head;\\n        \\n        while(p!= null){\\n            p.next = p.next.next;\\n            if(p.next == null){\\n                q.next = null;\\n            }else{\\n                q.next = p.next.next;\\n            }\\n            p = p.next;\\n            q = q.next;\\n        }\\n        \\n        return newHead;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public Node copyRandomList(Node head) {\\n        \\n        if(head == null){\\n            return null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 594662,
                "title": "go-two-solutions",
                "content": "O(N) space hash map solution:\\n```\\nfunc copyRandomList(head *Node) *Node {\\n    m := make(map[*Node]*Node)\\n    \\n    dummy := &Node{}\\n    \\n    curr1 := head\\n    curr2 := dummy\\n    for curr1 != nil {\\n        newNode := &Node{Val: curr1.Val}\\n        m[curr1] = newNode\\n        curr2.Next = newNode\\n        curr1 = curr1.Next\\n        curr2 = curr2.Next\\n    }\\n    \\n    curr1 = head\\n    curr2 = dummy.Next\\n    for curr1 != nil {\\n        curr2.Random = m[curr1.Random]\\n        curr1 = curr1.Next\\n        curr2 = curr2.Next\\n    }\\n    \\n    return dummy.Next\\n}\\n```\\n\\n<hr>\\n\\nO(1) Space duplicate list and then extract:\\n```\\nfunc copyRandomList(head *Node) *Node {\\n    // Duplicate each node.\\n    curr := head\\n    for curr != nil {\\n        newNode := &Node{\\n            Val: curr.Val,\\n            Next: curr.Next,\\n            Random: curr.Random,\\n        }\\n        \\n        curr.Next = newNode\\n        curr = newNode.Next\\n    }\\n    \\n    // Make the duplicated nodes point to the correct random.\\n    curr = head\\n    for curr != nil {\\n        curr = curr.Next\\n        if curr.Random != nil {\\n            curr.Random = curr.Random.Next\\n        }\\n        curr = curr.Next\\n    }\\n    \\n    // Extract the duplicated nodes and recover the original list.\\n    dummy := &Node{}\\n    curr2 := dummy\\n    curr = head\\n    for curr != nil {\\n        n := curr.Next\\n        curr.Next = curr.Next.Next\\n        curr = curr.Next\\n        curr2.Next = n\\n        curr2 = curr2.Next\\n    }\\n    \\n    return dummy.Next\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc copyRandomList(head *Node) *Node {\\n    m := make(map[*Node]*Node)\\n    \\n    dummy := &Node{}\\n    \\n    curr1 := head\\n    curr2 := dummy\\n    for curr1 != nil {\\n        newNode := &Node{Val: curr1.Val}\\n        m[curr1] = newNode\\n        curr2.Next = newNode\\n        curr1 = curr1.Next\\n        curr2 = curr2.Next\\n    }\\n    \\n    curr1 = head\\n    curr2 = dummy.Next\\n    for curr1 != nil {\\n        curr2.Random = m[curr1.Random]\\n        curr1 = curr1.Next\\n        curr2 = curr2.Next\\n    }\\n    \\n    return dummy.Next\\n}\\n```\n```\\nfunc copyRandomList(head *Node) *Node {\\n    // Duplicate each node.\\n    curr := head\\n    for curr != nil {\\n        newNode := &Node{\\n            Val: curr.Val,\\n            Next: curr.Next,\\n            Random: curr.Random,\\n        }\\n        \\n        curr.Next = newNode\\n        curr = newNode.Next\\n    }\\n    \\n    // Make the duplicated nodes point to the correct random.\\n    curr = head\\n    for curr != nil {\\n        curr = curr.Next\\n        if curr.Random != nil {\\n            curr.Random = curr.Random.Next\\n        }\\n        curr = curr.Next\\n    }\\n    \\n    // Extract the duplicated nodes and recover the original list.\\n    dummy := &Node{}\\n    curr2 := dummy\\n    curr = head\\n    for curr != nil {\\n        n := curr.Next\\n        curr.Next = curr.Next.Next\\n        curr = curr.Next\\n        curr2.Next = n\\n        curr2 = curr2.Next\\n    }\\n    \\n    return dummy.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 522507,
                "title": "easy-java-solution",
                "content": "```\\npublic Node copyRandomList(Node head) {\\n        Map<Node, Node> map = new HashMap<>();\\n        for (Node curr = head; curr != null; curr= curr.next) {\\n            map.put(curr, new Node(curr.val));\\n        }\\n        for (Node curr = head; curr != null; curr= curr.next) {\\n            Node clonedCurr = map.get(curr);\\n            clonedCurr.next = map.get(curr.next);\\n            clonedCurr.random = map.get(curr.random);\\n        }\\n        return map.get(head);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic Node copyRandomList(Node head) {\\n        Map<Node, Node> map = new HashMap<>();\\n        for (Node curr = head; curr != null; curr= curr.next) {\\n            map.put(curr, new Node(curr.val));\\n        }\\n        for (Node curr = head; curr != null; curr= curr.next) {\\n            Node clonedCurr = map.get(curr);\\n            clonedCurr.next = map.get(curr.next);\\n            clonedCurr.random = map.get(curr.random);\\n        }\\n        return map.get(head);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 306481,
                "title": "js-map-solution-o-n",
                "content": "We use map to solve this problem. In the first while loop, we create a new map, the key is the object itself, the value is the copy of the object node. In the second loop, we set:\\n* map.get(tmp).next = map.get(tmp.next) OR null\\n* map.get(tmp).random = map.get(tmp.random) OR null\\n```\\n/**\\n * // Definition for a Node.\\n * function Node(val,next,random) {\\n *    this.val = val;\\n *    this.next = next;\\n *    this.random = random;\\n * };\\n */\\n/**\\n * @param {Node} head\\n * @return {Node}\\n */\\nvar copyRandomList = function(head) {\\n    if (head == null)\\n        return head\\n    let map = new Map(), tmp = head\\n    while (tmp != null) {\\n        map.set(tmp, new Node(tmp.val, null, null))\\n        tmp = tmp.next\\n    }\\n    tmp = head\\n    while (tmp != null) {\\n        map.get(tmp).next = tmp.next == null? null: map.get(tmp.next)\\n        map.get(tmp).random = tmp.random == null? null: map.get(tmp.random)\\n        tmp = tmp.next\\n    }\\n    return map.get(head)\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * // Definition for a Node.\\n * function Node(val,next,random) {\\n *    this.val = val;\\n *    this.next = next;\\n *    this.random = random;\\n * };\\n */\\n/**\\n * @param {Node} head\\n * @return {Node}\\n */\\nvar copyRandomList = function(head) {\\n    if (head == null)\\n        return head\\n    let map = new Map(), tmp = head\\n    while (tmp != null) {\\n        map.set(tmp, new Node(tmp.val, null, null))\\n        tmp = tmp.next\\n    }\\n    tmp = head\\n    while (tmp != null) {\\n        map.get(tmp).next = tmp.next == null? null: map.get(tmp.next)\\n        map.get(tmp).random = tmp.random == null? null: map.get(tmp.random)\\n        tmp = tmp.next\\n    }\\n    return map.get(head)\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43520,
                "title": "javascript-o-n-solution-using-es6-map",
                "content": "```\\nvar copyRandomList = function(head) {\\n    if (!head) return null;\\n    const dummy = new RandomListNode();\\n    const map = new Map();\\n    \\n    let src = head;\\n    let dest = dummy;\\n    while (src && !map.has(src)) {\\n        dest.next = new RandomListNode(src.label);\\n        map.set(src, dest.next);\\n        src = src.next;\\n        dest = dest.next;\\n    }\\n    \\n    for (let [src, dest] of map) {\\n        dest.random = map.get(src.random) || null;\\n    }\\n    \\n    return dummy.next;\\n};\\n```\\n`Map` allows us to key by node reference. This should also work for lists that cycle.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar copyRandomList = function(head) {\\n    if (!head) return null;\\n    const dummy = new RandomListNode();\\n    const map = new Map();\\n    \\n    let src = head;\\n    let dest = dummy;\\n    while (src && !map.has(src)) {\\n        dest.next = new RandomListNode(src.label);\\n        map.set(src, dest.next);\\n        src = src.next;\\n        dest = dest.next;\\n    }\\n    \\n    for (let [src, dest] of map) {\\n        dest.random = map.get(src.random) || null;\\n    }\\n    \\n    return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 43682,
                "title": "easy-to-understand-and-fast-o-n-solution-memory-complexity-o-n",
                "content": "The idea is to copy the main list first, keep map of oldPrt-newPrt and then go through again and duplicate random pointers. please see the code and feel free to ask any questions\\n\\n    /**\\n     * Definition for singly-linked list with a random pointer.\\n     * struct RandomListNode {\\n     *     int label;\\n     *     RandomListNode *next, *random;\\n     *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        RandomListNode *copyRandomList(RandomListNode *head)\\n        {\\n            // copy the main list first and remember to keep map of original item addresses to the new addresses\\n            map<RandomListNode*, RandomListNode*> oldNewPtrs;\\n            \\n            // pointers for new list\\n            RandomListNode *newHead = NULL;\\n            RandomListNode *newTail = NULL;\\n            \\n            // just an iterator through the original list\\n            RandomListNode *curr = head;\\n            while (curr != NULL)\\n            {\\n                RandomListNode *newItem = new RandomListNode(curr->label);\\n                oldNewPtrs[curr] = newItem;\\n                \\n                // add new item into new list\\n                if (newHead == NULL)\\n                {\\n                    newHead = newItem;\\n                    newTail = newItem;\\n                }\\n                else\\n                {\\n                    newTail->next = newItem;\\n                    newTail = newItem;\\n                }\\n                \\n                curr = curr->next;\\n            }\\n            \\n            // at this point we copied only next pointers.\\n            // here we go through the original list and copy random pointers\\n            curr = head;\\n            while (curr != NULL)\\n            {\\n                // old item points to random old point. we need to have newItem points to new item\\n                // curr - old item\\n                // oldNewPtrs[curr] - new item - copy of old item\\n                if (curr->random != NULL)\\n                    oldNewPtrs[curr]->random = oldNewPtrs[curr->random];\\n                \\n                curr = curr->next;\\n            }\\n            \\n            return newHead;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        RandomListNode *copyRandomList(RandomListNode *head)\\n        {\\n            // copy the main list first and remember to keep map of original item addresses to the new addresses\\n            map<RandomListNode*, RandomListNode*> oldNewPtrs;\\n            \\n            // pointers for new list\\n            RandomListNode *newHead = NULL;\\n            RandomListNode *newTail = NULL;\\n            \\n            // just an iterator through the original list\\n            RandomListNode *curr = head;\\n            while (curr != NULL)\\n            {\\n                RandomListNode *newItem = new RandomListNode(curr->label);\\n                oldNewPtrs[curr] = newItem;\\n                \\n                // add new item into new list\\n                if (newHead == NULL)\\n                {\\n                    newHead = newItem;\\n                    newTail = newItem;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 43495,
                "title": "clean-c-o-1-space-solution-the-idea-is-the-same-as-others-but-it-s-clean-and-pure",
                "content": "    RandomListNode *copyRandomList(RandomListNode *head) {\\n        RandomListNode *node = head, *nextNode;\\n        while (node) {\\n            nextNode = node->next;\\n            node->next = new RandomListNode(node->label);\\n            node->next->next = nextNode;\\n            node = nextNode;\\n        }\\n        node = head;\\n        while (node) {\\n            node->next->random = node->random ? node->random->next : nullptr;\\n            node = node->next->next;\\n        }\\n        RandomListNode *psuedoHead = new RandomListNode(0), *copyNode = psuedoHead;\\n        node = head;\\n        while (node) {\\n            copyNode->next = node->next;\\n            copyNode = node->next;\\n            node->next = node->next->next;\\n            node = node->next;\\n        }\\n        return psuedoHead->next;\\n    }",
                "solutionTags": [],
                "code": "    RandomListNode *copyRandomList(RandomListNode *head) {\\n        RandomListNode *node = head, *nextNode;\\n        while (node) {\\n            nextNode = node->next;\\n            node->next = new RandomListNode(node->label);\\n            node->next->next = nextNode;\\n            node = nextNode;\\n        }\\n        node = head;\\n        while (node) {\\n            node->next->random = node->random ? node->random->next : nullptr;\\n            node = node->next->next;\\n        }\\n        RandomListNode *psuedoHead = new RandomListNode(0), *copyNode = psuedoHead;\\n        node = head;\\n        while (node) {\\n            copyNode->next = node->next;\\n            copyNode = node->next;\\n            node->next = node->next->next;\\n            node = node->next;\\n        }\\n        return psuedoHead->next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 4004383,
                "title": "java-100-time-0ms-using-hash-table",
                "content": "# Problem Description\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven a linked list of length `n` where each node contains an additional **random** pointer that can point to any node in the list (or be null), the **task** is to create a deep copy of this linked list. The copy should consist of `n` new nodes, each with the same value as its original counterpart. Both the **next** and **random** pointers of the new nodes should point to new nodes in the copied list, mirroring the relationships in the original list. **None of the pointers** in the new list should reference nodes in the original list.\\n\\nReturn the `head of the copied` linked list, and you will be given the head of the original linked list as input.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Check if the original list is empty; if so, return null.\\n- Initialize a copied list head `originalCopy` with the value from the original head node.\\n- Initialize another variable refrencing to `originalCopy` name it `copiedHead` and use it for traversal.\\n- Create a mapping between original and copied nodes using a HashMap.\\n- Traverse the original list and copy each node to the copied list while updating the HashMap.\\n- Reset pointers to the heads of both lists.\\n- Iterate through the original list to set the random pointers in the copied list using the HashMap.\\n- Return the head of the copied list `originalCopy`.\\n\\n# Complexity\\n- **Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe can say, it is `2*N` since we are iterating over the whole linked list twice. So, it is `O(N)`\\n- **Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIt is `O(N)` since we are using Hashmap (Hash table) \\n\\n# Code\\n```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        // Check if the original list is empty\\n        if (head == null)\\n            return null;\\n        \\n        // Initialize the copied list with the value from the original head\\n        Node originalCopy = new Node(head.val);\\n        Node copiedHead = originalCopy;\\n        Node current = head;\\n        \\n        // Create a mapping between nodes in the original list and their copies\\n        HashMap<Node, Node> referenceMap = new HashMap<>();\\n        referenceMap.put(current, copiedHead);\\n        current = current.next;\\n\\n        // Copy the rest of the nodes in the list\\n        while (current != null) {\\n            copiedHead.next = new Node(current.val);\\n            referenceMap.put(current, copiedHead.next);\\n            current = current.next;\\n            copiedHead = copiedHead.next;\\n        }\\n\\n        // Reset pointers for traversing both original and copied lists\\n        current = head;\\n        copiedHead = originalCopy;\\n\\n        // Populate the \\'random\\' pointers in the copied list using the mapping\\n        while (current != null) {\\n            copiedHead.random = referenceMap.get(current.random);\\n            current = current.next;\\n            copiedHead = copiedHead.next;\\n        }\\n\\n        // Return the head of the copied list\\n        return originalCopy;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        // Check if the original list is empty\\n        if (head == null)\\n            return null;\\n        \\n        // Initialize the copied list with the value from the original head\\n        Node originalCopy = new Node(head.val);\\n        Node copiedHead = originalCopy;\\n        Node current = head;\\n        \\n        // Create a mapping between nodes in the original list and their copies\\n        HashMap<Node, Node> referenceMap = new HashMap<>();\\n        referenceMap.put(current, copiedHead);\\n        current = current.next;\\n\\n        // Copy the rest of the nodes in the list\\n        while (current != null) {\\n            copiedHead.next = new Node(current.val);\\n            referenceMap.put(current, copiedHead.next);\\n            current = current.next;\\n            copiedHead = copiedHead.next;\\n        }\\n\\n        // Reset pointers for traversing both original and copied lists\\n        current = head;\\n        copiedHead = originalCopy;\\n\\n        // Populate the \\'random\\' pointers in the copied list using the mapping\\n        while (current != null) {\\n            copiedHead.random = referenceMap.get(current.random);\\n            current = current.next;\\n            copiedHead = copiedHead.next;\\n        }\\n\\n        // Return the head of the copied list\\n        return originalCopy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004022,
                "title": "c-recursion-iteration-with-hash-table-for-linked-list-beats-96-91",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolving such problems, I prefer to use recursion. The reason for that is just much shorter code!\\n\\nThis code efficiently clones a linked list with random pointers by using memoization to avoid duplicate work. The recursive version is short and not slow, while the iterative solution requires 2 or 3 times traversals depending on the ways of implementation.\\n\\n1st approach uses unordered_map as hash table which has linear time complexity $O(n)$; but in the reality, it is slow(Runtime 11 ms Beats 29%). 2nd approach using map instead of unordered_map has TC $O(n\\\\log n)$(Runtime 3 ms Beats 96.91%). Maybe the implementation of unordered_map in GCC is not expected efficient as one wants.\\n\\nYou can clone the Linked list. Using the same technique, you can also solve [Leetcode 133. Clone Graph\\n](https://leetcode.com/problems/clone-graph/solutions/3392007/easy-dfs-c-solution-beats-95-3)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere\\'s how the copyRandomList method works:\\n\\n1.If head is NULL, it returns NULL, which is the base case for the recursion.\\n\\n2.If the head node has already been cloned and exists in the mp map, it returns the cloned node to avoid duplicating nodes.\\n\\n3.Otherwise, it creates a new node (newNode) with the same value as the original node and stores this mapping in the mp map.\\n\\n4.It recursively calls copyRandomList on the next and random pointers of the head node to clone the linked list.\\n\\n5.Finally, it returns the cloned newNode.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)\\\\to O(n \\\\log n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n$O(n)$\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    unordered_map<Node*, Node*> mp;\\n    Node* copyRandomList(Node* head) {\\n        if (head==NULL) return NULL;\\n        if (mp.count(head)!=0) return mp[head];\\n        Node* newNode=new Node(head->val);\\n        mp[head]=newNode;\\n        newNode->next=copyRandomList(head->next);\\n        newNode->random=copyRandomList(head->random);\\n        return newNode;\\n    }\\n};\\n```\\n# Code with Explanation in comments\\n```\\nclass Solution {\\npublic:\\n    unordered_map<Node*, Node*> mp; // An unordered map to store the mapping between original and cloned nodes.\\n\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL) return NULL; // Base case: if the input list is empty, return NULL.\\n\\n        if (mp.count(head) != 0) return mp[head]; // If the node has already been cloned, return the cloned node.\\n\\n        Node* newNode = new Node(head->val); // Create a new node with the same value as the original node.\\n        mp[head] = newNode; // Store the mapping between the original and cloned nodes.\\n        \\n        // Recursively clone the next and random pointers.\\n        newNode->next = copyRandomList(head->next);\\n        newNode->random = copyRandomList(head->random);\\n        \\n        return newNode; // Return the cloned node.\\n    }\\n};\\n```\\n\\n# 2nd approach using map instead of unordered_map||Runtime 3 ms Beats 96.91%\\n\\n```\\nclass Solution {\\npublic:\\n    map<Node*, Node*> mp;\\n    Node* copyRandomList(Node* head) {\\n        if (head==NULL) return NULL;\\n        if (mp.count(head)!=0) return mp[head];\\n        Node* newNode=new Node(head->val);\\n        mp[head]=newNode;\\n        newNode->next=copyRandomList(head->next);\\n        newNode->random=copyRandomList(head->random);\\n        return newNode;\\n    }\\n};\\n```\\n# Code for iterative Version using map\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL) return NULL;\\n\\n        map<Node*, Node*> mp; \\n// First traversal: create cloned nodes \\n        Node* ptr = head;\\n        while (ptr) {\\n            mp[ptr] = new Node(ptr->val);\\n            ptr = ptr->next;\\n        }\\n\\n//2nd traversal: assign random pointers for cloned nodes\\n        ptr = head;\\n        while (ptr) {\\n            mp[ptr]->next = mp[ptr->next];\\n            mp[ptr]->random = mp[ptr->random];\\n            ptr = ptr->next;\\n        }\\n\\n        return mp[head];\\n    }\\n};\\n```\\n# 2nd iterative Version\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL) return NULL;\\n\\n        unordered_map<Node*, int> nIdx; \\n        vector<Node*> node;\\n        \\n        // First traversal: create cloned nodes \\n        Node* ptr = head;\\n        int i = 0;\\n\\n        // Initialize node vector and nIdx map\\n        while (ptr) {\\n            node.push_back(new Node(ptr->val));\\n            nIdx[ptr] = i;\\n            ptr = ptr->next;\\n            i++;\\n        }\\n\\n        // Reset ptr to head and start the second traversal using a for loop\\n        ptr = head;\\n        for (i = 0; ptr; i++,  ptr = ptr->next) {\\n            if (ptr->next) {\\n                node[i]->next = node[i + 1];\\n            }\\n            if (ptr->random) {\\n                node[i]->random = node[nIdx[ptr->random]];\\n            }\\n        }\\n\\n        return node[0];\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List",
                    "Memoization",
                    "Ordered Map"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    unordered_map<Node*, Node*> mp;\\n    Node* copyRandomList(Node* head) {\\n        if (head==NULL) return NULL;\\n        if (mp.count(head)!=0) return mp[head];\\n        Node* newNode=new Node(head->val);\\n        mp[head]=newNode;\\n        newNode->next=copyRandomList(head->next);\\n        newNode->random=copyRandomList(head->random);\\n        return newNode;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    unordered_map<Node*, Node*> mp; // An unordered map to store the mapping between original and cloned nodes.\\n\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL) return NULL; // Base case: if the input list is empty, return NULL.\\n\\n        if (mp.count(head) != 0) return mp[head]; // If the node has already been cloned, return the cloned node.\\n\\n        Node* newNode = new Node(head->val); // Create a new node with the same value as the original node.\\n        mp[head] = newNode; // Store the mapping between the original and cloned nodes.\\n        \\n        // Recursively clone the next and random pointers.\\n        newNode->next = copyRandomList(head->next);\\n        newNode->random = copyRandomList(head->random);\\n        \\n        return newNode; // Return the cloned node.\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    map<Node*, Node*> mp;\\n    Node* copyRandomList(Node* head) {\\n        if (head==NULL) return NULL;\\n        if (mp.count(head)!=0) return mp[head];\\n        Node* newNode=new Node(head->val);\\n        mp[head]=newNode;\\n        newNode->next=copyRandomList(head->next);\\n        newNode->random=copyRandomList(head->random);\\n        return newNode;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL) return NULL;\\n\\n        map<Node*, Node*> mp; \\n// First traversal: create cloned nodes \\n        Node* ptr = head;\\n        while (ptr) {\\n            mp[ptr] = new Node(ptr->val);\\n            ptr = ptr->next;\\n        }\\n\\n//2nd traversal: assign random pointers for cloned nodes\\n        ptr = head;\\n        while (ptr) {\\n            mp[ptr]->next = mp[ptr->next];\\n            mp[ptr]->random = mp[ptr->random];\\n            ptr = ptr->next;\\n        }\\n\\n        return mp[head];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL) return NULL;\\n\\n        unordered_map<Node*, int> nIdx; \\n        vector<Node*> node;\\n        \\n        // First traversal: create cloned nodes \\n        Node* ptr = head;\\n        int i = 0;\\n\\n        // Initialize node vector and nIdx map\\n        while (ptr) {\\n            node.push_back(new Node(ptr->val));\\n            nIdx[ptr] = i;\\n            ptr = ptr->next;\\n            i++;\\n        }\\n\\n        // Reset ptr to head and start the second traversal using a for loop\\n        ptr = head;\\n        for (i = 0; ptr; i++,  ptr = ptr->next) {\\n            if (ptr->next) {\\n                node[i]->next = node[i + 1];\\n            }\\n            if (ptr->random) {\\n                node[i]->random = node[nIdx[ptr->random]];\\n            }\\n        }\\n\\n        return node[0];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003803,
                "title": "python3-solution",
                "content": "\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        old_to_copy={None:None}\\n        cur=head\\n        while cur:\\n            copy=Node(cur.val)\\n            old_to_copy[cur]=copy\\n            cur=cur.next\\n\\n        cur=head\\n        while cur:\\n            copy=old_to_copy[cur]\\n            copy.next=old_to_copy[cur.next]\\n            copy.random=old_to_copy[cur.random]\\n            cur=cur.next\\n\\n        return old_to_copy[head]                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        old_to_copy={None:None}\\n        cur=head\\n        while cur:\\n            copy=Node(cur.val)\\n            old_to_copy[cur]=copy\\n            cur=cur.next\\n\\n        cur=head\\n        while cur:\\n            copy=old_to_copy[cur]\\n            copy.next=old_to_copy[cur.next]\\n            copy.random=old_to_copy[cur.random]\\n            cur=cur.next\\n\\n        return old_to_copy[head]                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003277,
                "title": "99-00-beats-c-easy-to-understand-c-java-python-javascript-beginner",
                "content": "# Intuition\\n- The goal of this problem is to create a deep copy of a linked list with random pointers. \\n- To do this, we can iterate through the original linked list and create a new node for each node in the original list. \\n- We\\'ll also maintain a mapping between the nodes in the original list and their corresponding nodes in the new list. \\n- This mapping will be useful when setting the random pointers of the new nodes.\\n\\n# Approach\\n1. Handle edge case: If the input linked list `head` is `NULL`, return `NULL` since there\\'s nothing to copy.\\n\\n1. Initialize a new dummy node `newhead` to simplify the construction of the new linked list. This dummy node won\\'t be part of the final result.\\n\\n1. Initialize pointers `new_curr` and `curr` to traverse the new and original linked lists, respectively.\\n\\n1. Create an unordered map (`umap`) to store the mapping between nodes in the original list and their corresponding nodes in the new list.\\n\\n1. First Pass:\\n\\n   -   Iterate through the original linked list (`head`).\\n   - For each node in the original list, create a new node with the same value and insert it into `umap` to establish a mapping.\\n   - Connect the new node to the `new_curr` pointer.\\n   - Move both `new_curr` and `curr` to the next nodes in their respective lists.\\n1. Reset `curr` to the beginning of the original list and `new_curr` to the beginning of the new list.\\n\\n1. Second Pass:\\n\\n   - Iterate through the original linked list again.\\n   - For each node in the original list, get the corresponding random pointer\\'s node from `umap` and assign it as the random pointer for the new node.\\n   - Move both `new_curr` and `curr` to the next nodes in their respective lists.\\n   - Finally, return the `next` pointer of `newhead`, which will be the head of the newly created linked list.\\n\\n# Complexity\\n- Time complexity:\\n- This solution iterates through the original linked list twice, so the time complexity is `O(N)`, where N is the number of nodes in the linked list.\\n- Space complexity:\\n- The space complexity is `O(N)` because we use additional space to store the mapping of nodes from the original list to the new list in the unordered map (`umap`).\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if( head == NULL) return head;\\n        Node* newhead = new Node(0);\\n        Node* new_curr = newhead;\\n        Node* curr = head;\\n        unordered_map<Node*, Node*> umap;\\n        \\n        while(curr){\\n            Node* temp = new Node(curr->val);\\n            umap.insert({curr, temp});\\n            \\n            new_curr->next = temp;\\n            new_curr = new_curr->next;\\n            curr = curr->next;\\n        }\\n        curr = head;\\n        new_curr = newhead->next;\\n        \\n        while(curr){\\n            Node* random = curr->random;\\n            Node* newNode = umap[random];\\n            new_curr->random = newNode;\\n            \\n            new_curr = new_curr->next;\\n            curr = curr->next;\\n        }\\n        \\n        return newhead->next;\\n    }\\n};\\n```\\n**#JAVA**\\n```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n\\n        Node newHead = new Node(0);\\n        Node newCurr = newHead;\\n        Node curr = head;\\n        Map<Node, Node> umap = new HashMap<>();\\n\\n        while (curr != null) {\\n            Node temp = new Node(curr.val);\\n            umap.put(curr, temp);\\n\\n            newCurr.next = temp;\\n            newCurr = newCurr.next;\\n            curr = curr.next;\\n        }\\n\\n        curr = head;\\n        newCurr = newHead.next;\\n\\n        while (curr != null) {\\n            Node random = curr.random;\\n            Node newNode = umap.get(random);\\n            newCurr.random = newNode;\\n\\n            newCurr = newCurr.next;\\n            curr = curr.next;\\n        }\\n\\n        return newHead.next;\\n    }\\n}\\n\\n```\\n**#PYTHON**\\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n\\n        new_head = Node(0)\\n        new_curr = new_head\\n        curr = head\\n        umap = {}\\n\\n        while curr:\\n            temp = Node(curr.val)\\n            umap[curr] = temp\\n\\n            new_curr.next = temp\\n            new_curr = new_curr.next\\n            curr = curr.next\\n\\n        curr = head\\n        new_curr = new_head.next\\n\\n        while curr:\\n            random = curr.random\\n            new_node = umap.get(random)\\n            new_curr.random = new_node\\n\\n            new_curr = new_curr.next\\n            curr = curr.next\\n\\n        return new_head.next\\n\\n```\\n**#JAVSCRIPT**\\n```\\nclass Node {\\n    constructor(val, next, random) {\\n        this.val = val;\\n        this.next = next || null;\\n        this.random = random || null;\\n    }\\n}\\n\\nclass Solution {\\n    copyRandomList(head) {\\n        if (!head) {\\n            return null;\\n        }\\n\\n        const newHead = new Node(0);\\n        let newCurr = newHead;\\n        let curr = head;\\n        const umap = new Map();\\n\\n        while (curr) {\\n            const temp = new Node(curr.val);\\n            umap.set(curr, temp);\\n\\n            newCurr.next = temp;\\n            newCurr = newCurr.next;\\n            curr = curr.next;\\n        }\\n\\n        curr = head;\\n        newCurr = newHead.next;\\n\\n        while (curr) {\\n            const random = curr.random;\\n            const newNode = umap.get(random);\\n            newCurr.random = newNode;\\n\\n            newCurr = newCurr.next;\\n            curr = curr.next;\\n        }\\n\\n        return newHead.next;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if( head == NULL) return head;\\n        Node* newhead = new Node(0);\\n        Node* new_curr = newhead;\\n        Node* curr = head;\\n        unordered_map<Node*, Node*> umap;\\n        \\n        while(curr){\\n            Node* temp = new Node(curr->val);\\n            umap.insert({curr, temp});\\n            \\n            new_curr->next = temp;\\n            new_curr = new_curr->next;\\n            curr = curr->next;\\n        }\\n        curr = head;\\n        new_curr = newhead->next;\\n        \\n        while(curr){\\n            Node* random = curr->random;\\n            Node* newNode = umap[random];\\n            new_curr->random = newNode;\\n            \\n            new_curr = new_curr->next;\\n            curr = curr->next;\\n        }\\n        \\n        return newhead->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n\\n        Node newHead = new Node(0);\\n        Node newCurr = newHead;\\n        Node curr = head;\\n        Map<Node, Node> umap = new HashMap<>();\\n\\n        while (curr != null) {\\n            Node temp = new Node(curr.val);\\n            umap.put(curr, temp);\\n\\n            newCurr.next = temp;\\n            newCurr = newCurr.next;\\n            curr = curr.next;\\n        }\\n\\n        curr = head;\\n        newCurr = newHead.next;\\n\\n        while (curr != null) {\\n            Node random = curr.random;\\n            Node newNode = umap.get(random);\\n            newCurr.random = newNode;\\n\\n            newCurr = newCurr.next;\\n            curr = curr.next;\\n        }\\n\\n        return newHead.next;\\n    }\\n}\\n\\n```\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if not head:\\n            return None\\n\\n        new_head = Node(0)\\n        new_curr = new_head\\n        curr = head\\n        umap = {}\\n\\n        while curr:\\n            temp = Node(curr.val)\\n            umap[curr] = temp\\n\\n            new_curr.next = temp\\n            new_curr = new_curr.next\\n            curr = curr.next\\n\\n        curr = head\\n        new_curr = new_head.next\\n\\n        while curr:\\n            random = curr.random\\n            new_node = umap.get(random)\\n            new_curr.random = new_node\\n\\n            new_curr = new_curr.next\\n            curr = curr.next\\n\\n        return new_head.next\\n\\n```\n```\\nclass Node {\\n    constructor(val, next, random) {\\n        this.val = val;\\n        this.next = next || null;\\n        this.random = random || null;\\n    }\\n}\\n\\nclass Solution {\\n    copyRandomList(head) {\\n        if (!head) {\\n            return null;\\n        }\\n\\n        const newHead = new Node(0);\\n        let newCurr = newHead;\\n        let curr = head;\\n        const umap = new Map();\\n\\n        while (curr) {\\n            const temp = new Node(curr.val);\\n            umap.set(curr, temp);\\n\\n            newCurr.next = temp;\\n            newCurr = newCurr.next;\\n            curr = curr.next;\\n        }\\n\\n        curr = head;\\n        newCurr = newHead.next;\\n\\n        while (curr) {\\n            const random = curr.random;\\n            const newNode = umap.get(random);\\n            newCurr.random = newNode;\\n\\n            newCurr = newCurr.next;\\n            curr = curr.next;\\n        }\\n\\n        return newHead.next;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3726546,
                "title": "3-passes-o-n-python",
                "content": "# Approach\\n- In the first pass, create copy nodes for each node in the linked list\\n- In the 2nd pass, update the random pointers of each copy node\\n- In the 3rd pass, update the next pointers of the copy nodes, and eliminate the original nodes\\n\\n# Code\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n\\n        temp = head\\n        while(temp):\\n            node = Node(temp.val)\\n            node.next = temp.next\\n            temp.next = node\\n            temp = node.next\\n\\n        temp = head\\n        while(temp):\\n            if not temp.random:\\n                temp.next.random = None\\n            else:\\n                temp.next.random = temp.random.next\\n            temp = temp.next.next\\n\\n        temp = head.next\\n        while(temp.next):\\n            print(temp.val)\\n            temp.next = temp.next.next\\n            temp = temp.next\\n\\n        return head.next\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n\\n        temp = head\\n        while(temp):\\n            node = Node(temp.val)\\n            node.next = temp.next\\n            temp.next = node\\n            temp = node.next\\n\\n        temp = head\\n        while(temp):\\n            if not temp.random:\\n                temp.next.random = None\\n            else:\\n                temp.next.random = temp.random.next\\n            temp = temp.next.next\\n\\n        temp = head.next\\n        while(temp.next):\\n            print(temp.val)\\n            temp.next = temp.next.next\\n            temp = temp.next\\n\\n        return head.next\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582492,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        while (temp != NULL) {\\n            Node* newNode = new Node(temp->val);\\n            newNode->next = temp->next;\\n            temp->next = newNode;\\n            temp = temp->next->next;\\n        }\\n        temp = head;\\n        while (temp != NULL) {\\n            if (temp->random != NULL) {\\n                temp->next->random = temp->random->next;\\n            }\\n            temp = temp->next->next;\\n        }\\n        Node* dummy = new Node(0);\\n        Node* itr = dummy;\\n        Node* fast;\\n        temp = head;\\n        while (temp != NULL) {\\n            fast = temp->next->next;\\n            itr->next = temp->next;\\n            itr = itr->next;\\n            temp->next = fast;\\n            temp = fast;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        while (temp != NULL) {\\n            Node* newNode = new Node(temp->val);\\n            newNode->next = temp->next;\\n            temp->next = newNode;\\n            temp = temp->next->next;\\n        }\\n        temp = head;\\n        while (temp != NULL) {\\n            if (temp->random != NULL) {\\n                temp->next->random = temp->random->next;\\n            }\\n            temp = temp->next->next;\\n        }\\n        Node* dummy = new Node(0);\\n        Node* itr = dummy;\\n        Node* fast;\\n        temp = head;\\n        while (temp != NULL) {\\n            fast = temp->next->next;\\n            itr->next = temp->next;\\n            itr = itr->next;\\n            temp->next = fast;\\n            temp = fast;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891888,
                "title": "java-2-solutions-with-without-extra-space",
                "content": "# Please Upvote :D\\n\\n---\\n\\n##### 1. Using extra space (hashmap):\\n\\n![image.png](https://assets.leetcode.com/users/images/d6aec53c-05a3-458d-b045-3513a3e5b51b_1670521786.738047.png)\\n\\n\\n``` java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Map<Node, Node> map = new HashMap<>();\\n        Node node = head;\\n\\n        while (node != null) {\\n            map.put(node, new Node(node.val));\\n            node = node.next;\\n        }\\n\\n        node = head;\\n\\n        while (node != null) {\\n            map.get(node).next = map.get(node.next);\\n            map.get(node).random = map.get(node.random);\\n            node = node.next;\\n        }\\n\\n        return map.get(head);\\n    }\\n}\\n\\n// TC: O(n) + O(n) => O(n)\\n// SC: O(n)\\n```\\n---\\n\\n##### 2. No extra space:\\n\\n![image.png](https://assets.leetcode.com/users/images/003ffc95-aff9-42ae-a2b0-390fdd5c06ee_1670521842.8753994.png)\\n\\n\\n``` java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Node curr = head, currNext = head;\\n\\n        // step 1: create copy nodes   \\n        while (curr != null) {\\n            currNext = curr.next;\\n            Node copy = new Node(curr.val);\\n            curr.next = copy;\\n            copy.next = currNext;\\n            curr = currNext;\\n        }\\n\\n        curr = head;\\n\\n        // link the copy nodes\\'s random pointers properly \\n        while (curr != null) {\\n            if (curr.random != null) {\\n                curr.next.random = curr.random.next;\\n            }\\n            curr = curr.next.next;\\n        }\\n\\n        Node ans = new Node(-1);\\n        Node copyItr = ans;\\n        curr = head; currNext = head;\\n\\n        // separate the copy nodes and original nodes and restore as lists\\n        while (curr != null) {\\n            currNext = currNext.next.next;\\n            copyItr.next = curr.next;\\n            curr.next = currNext;\\n            curr = curr.next;\\n            copyItr = copyItr.next;\\n        }\\n\\n        return ans.next;\\n    }\\n}\\n\\n// TC: O(n) + O(n) + O(n) => O(n)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "``` java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Map<Node, Node> map = new HashMap<>();\\n        Node node = head;\\n\\n        while (node != null) {\\n            map.put(node, new Node(node.val));\\n            node = node.next;\\n        }\\n\\n        node = head;\\n\\n        while (node != null) {\\n            map.get(node).next = map.get(node.next);\\n            map.get(node).random = map.get(node.random);\\n            node = node.next;\\n        }\\n\\n        return map.get(head);\\n    }\\n}\\n\\n// TC: O(n) + O(n) => O(n)\\n// SC: O(n)\\n```\n``` java []\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        Node curr = head, currNext = head;\\n\\n        // step 1: create copy nodes   \\n        while (curr != null) {\\n            currNext = curr.next;\\n            Node copy = new Node(curr.val);\\n            curr.next = copy;\\n            copy.next = currNext;\\n            curr = currNext;\\n        }\\n\\n        curr = head;\\n\\n        // link the copy nodes\\'s random pointers properly \\n        while (curr != null) {\\n            if (curr.random != null) {\\n                curr.next.random = curr.random.next;\\n            }\\n            curr = curr.next.next;\\n        }\\n\\n        Node ans = new Node(-1);\\n        Node copyItr = ans;\\n        curr = head; currNext = head;\\n\\n        // separate the copy nodes and original nodes and restore as lists\\n        while (curr != null) {\\n            currNext = currNext.next.next;\\n            copyItr.next = curr.next;\\n            curr.next = currNext;\\n            curr = curr.next;\\n            copyItr = copyItr.next;\\n        }\\n\\n        return ans.next;\\n    }\\n}\\n\\n// TC: O(n) + O(n) + O(n) => O(n)\\n// SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258663,
                "title": "easy-c-sol-naive-efficient-approaches-time-o-n",
                "content": "```\\n\\n// Naive Solution :: Time : O(N) + O(N) :: Aux_Space : O(N)\\n\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n\\n        unordered_map<Node*,Node*> mp;\\n\\n        Node *temp = head;\\n\\n        while(temp != NULL){\\n\\n            mp[temp] = new Node(temp->val);\\n            temp = temp->next;\\n\\n        }\\n\\n         temp = head;\\n\\n        while(temp != NULL){\\n\\n            Node* listCopy = mp[temp];\\n            listCopy->next = mp[temp->next];\\n            listCopy->random = mp[temp->random];\\n\\n            temp = temp->next;\\n\\n        }\\n        return mp[head];\\n    }\\n};\\n\\n// Efficient Solution :: Time : O(N) + O(N) + O(N) :: Aux_Space : O(1)\\n\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n\\n        Node *temp = head;\\n\\n        // First round: make copy of each node,\\n        // and link them together side-by-side in a single list.\\n\\n        while(temp){\\n\\n            Node *curr = new Node(temp->val);\\n            curr->next = temp->next;\\n            temp->next = curr;\\n\\n            temp = temp->next->next;\\n\\n        }\\n\\n         // Second round: assign random pointers for the copy nodes.\\n\\n        temp = head;\\n\\n        while(temp){\\n\\n            if(temp->random != NULL)\\n                temp->next->random = temp->random->next;\\n\\n            temp = temp->next->next;\\n\\n        }\\n\\n         // Third round: restore the original list, and extract the copy list.\\n\\n        Node *dummy = new Node(0);\\n        Node *copy = dummy;\\n\\n        temp = head;\\n        Node *front;\\n\\n        while(temp){\\n\\n            front = temp->next->next;\\n\\n            copy->next = temp->next;\\n            temp->next = front;\\n\\n            temp = temp->next;\\n            copy = copy->next;\\n        }\\n        return dummy->next;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n\\n        unordered_map<Node*,Node*> mp;\\n\\n        Node *temp = head;\\n\\n        while(temp != NULL){\\n\\n            mp[temp] = new Node(temp->val);\\n            temp = temp->next;\\n\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2126191,
                "title": "c-without-any-hashing-or-saving-the-nodes-optimal",
                "content": "\\t Node* copyRandomList(Node* head) {\\n        \\n        if(!head) return NULL;\\n        \\n\\t//         Node* temp1 = head;\\n\\t//         Node* newhead = new Node(temp1->val);\\n\\t//         Node* temp = newhead;\\n\\t//         temp1 = temp1->next;\\n\\t//         unordered_map<Node*,Node*> map;\\n\\t//         map[head] = newhead;\\n\\n\\t//         while(temp1)\\n\\t//         {\\n\\t//             temp->next = new Node(temp1->val);\\n\\t//             map[temp1] = temp->next;\\n\\t//             temp = temp->next;\\n\\t//             temp1 = temp1->next;\\n\\t//         }\\n\\n\\t//         temp1 = head;\\n\\t//         temp = newhead;\\n\\n\\t//         while(temp1)\\n\\t//         {\\n\\t//             temp->random = map[temp1->random];\\n\\t//             temp1 = temp1->next;\\n\\t//             temp = temp->next;\\n\\t//         }\\n\\n\\t//         return newhead;\\n        \\n        Node* curr = head;\\n        Node* nxt = head->next;\\n        Node* dummy = new Node(-1);\\n        Node* temp = dummy;\\n        while(curr)\\n        {\\n            Node* newnode = new Node(curr->val);\\n            temp->next = curr;\\n            curr->next = newnode;\\n            temp = newnode;\\n            curr = nxt;\\n            if(nxt) nxt = nxt->next;\\n        }\\n    \\n        curr = head;\\n        dummy->next = dummy->next->next;\\n        temp = dummy->next;\\n        while(curr)\\n        {\\n            temp->random = NULL;\\n            if(curr->random) temp->random = curr->random->next;\\n            curr = temp->next;\\n            if(curr) temp = curr->next;\\n        }\\n        \\n        curr = head;\\n        temp = dummy->next;\\n        while(curr)\\n        {\\n            curr->next = temp->next;\\n            if(temp->next)  temp->next = temp->next->next;\\n            curr = curr->next;\\n            temp = temp->next;\\n        }\\n        return dummy->next;  \\n    }\\n\\t\\nCommented code is using hashmap to solve this problem and the uncommented is the optimal approach without using space to save original nodes.\\nFirst loop is used to modify the linked list.\\nSecond loop is used to setup the random pointers.\\nThird loop is used to remodify the linked list to its original form.",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "\\t Node* copyRandomList(Node* head) {\\n        \\n        if(!head) return NULL;\\n        \\n\\t//         Node* temp1 = head;\\n\\t//         Node* newhead = new Node(temp1->val);\\n\\t//         Node* temp = newhead;\\n\\t//         temp1 = temp1->next;\\n\\t//         unordered_map<Node*,Node*> map;\\n\\t//         map[head] = newhead;\\n\\n\\t//         while(temp1)\\n\\t//         {\\n\\t//             temp->next = new Node(temp1->val);\\n\\t//             map[temp1] = temp->next;\\n\\t//             temp = temp->next;\\n\\t//             temp1 = temp1->next;\\n\\t//         }\\n\\n\\t//         temp1 = head;\\n\\t//         temp = newhead;\\n\\n\\t//         while(temp1)\\n\\t//         {\\n\\t//             temp->random = map[temp1->random];\\n\\t//             temp1 = temp1->next;\\n\\t//             temp = temp->next;\\n\\t//         }\\n\\n\\t//         return newhead;\\n        \\n        Node* curr = head;\\n        Node* nxt = head->next;\\n        Node* dummy = new Node(-1);\\n        Node* temp = dummy;\\n        while(curr)\\n        {\\n            Node* newnode = new Node(curr->val);\\n            temp->next = curr;\\n            curr->next = newnode;\\n            temp = newnode;\\n            curr = nxt;\\n            if(nxt) nxt = nxt->next;\\n        }\\n    \\n        curr = head;\\n        dummy->next = dummy->next->next;\\n        temp = dummy->next;\\n        while(curr)\\n        {\\n            temp->random = NULL;\\n            if(curr->random) temp->random = curr->random->next;\\n            curr = temp->next;\\n            if(curr) temp = curr->next;\\n        }\\n        \\n        curr = head;\\n        temp = dummy->next;\\n        while(curr)\\n        {\\n            curr->next = temp->next;\\n            if(temp->next)  temp->next = temp->next->next;\\n            curr = curr->next;\\n            temp = temp->next;\\n        }\\n        return dummy->next;  \\n    }\\n\\t\\nCommented code is using hashmap to solve this problem and the uncommented is the optimal approach without using space to save original nodes.\\nFirst loop is used to modify the linked list.\\nSecond loop is used to setup the random pointers.\\nThird loop is used to remodify the linked list to its original form.",
                "codeTag": "Unknown"
            },
            {
                "id": 1842903,
                "title": "go-solution",
                "content": "https://github.com/ganeshskudva/Leetcode-Golang\\n\\n```\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Next *Node\\n *     Random *Node\\n * }\\n */\\n\\nfunc copyRandomList(head *Node) *Node {\\n\\tif head == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tmp, node := make(map[*Node]*Node), head\\n\\t// loop 1. copy all the nodes\\n\\tfor node != nil {\\n\\t\\tmp[node] = &Node{Val: node.Val}\\n\\t\\tnode = node.Next\\n\\t}\\n\\n\\tnode = head\\n\\t// loop 2. assign next and random pointers\\n\\tfor node != nil {\\n\\t\\tmp[node].Next = mp[node.Next]\\n\\t\\tmp[node].Random = mp[node.Random]\\n\\t\\tnode = node.Next\\n\\t}\\n\\n\\treturn mp[head]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a Node.\\n * type Node struct {\\n *     Val int\\n *     Next *Node\\n *     Random *Node\\n * }\\n */\\n\\nfunc copyRandomList(head *Node) *Node {\\n\\tif head == nil {\\n\\t\\treturn nil\\n\\t}\\n\\n\\tmp, node := make(map[*Node]*Node), head\\n\\t// loop 1. copy all the nodes\\n\\tfor node != nil {\\n\\t\\tmp[node] = &Node{Val: node.Val}\\n\\t\\tnode = node.Next\\n\\t}\\n\\n\\tnode = head\\n\\t// loop 2. assign next and random pointers\\n\\tfor node != nil {\\n\\t\\tmp[node].Next = mp[node.Next]\\n\\t\\tmp[node].Random = mp[node.Random]\\n\\t\\tnode = node.Next\\n\\t}\\n\\n\\treturn mp[head]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1841446,
                "title": "c-iterative-2-pass-o-n",
                "content": "**APPROACH**\\n```\\n1. Make deep copy of each node and only assign next as of now\\n2. store each node and its shallow copy\\n3. Traverse new list and assign random node\\n```\\n\\nTC - O(n)\\n\\n**CODE**\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node * temp = head;\\n        Node * nhead = NULL;\\n        Node * ntail = NULL;\\n        unordered_map<Node * , Node *> m;\\n        m[NULL] = NULL;\\n        while(temp != NULL){\\n            if(nhead == NULL){\\n                nhead = new Node(temp->val);\\n                ntail = nhead;\\n            }\\n            else{\\n                ntail->next = new Node(temp->val);\\n                ntail = ntail->next;\\n            }\\n            m[temp] = ntail;\\n            temp = temp->next;\\n        }\\n        \\n        \\n        temp = nhead;\\n        while(temp != NULL){\\n            temp->random = m[head->random];\\n            head = head->next;\\n            temp = temp->next;\\n        }\\n        return nhead;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n1. Make deep copy of each node and only assign next as of now\\n2. store each node and its shallow copy\\n3. Traverse new list and assign random node\\n```\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node * temp = head;\\n        Node * nhead = NULL;\\n        Node * ntail = NULL;\\n        unordered_map<Node * , Node *> m;\\n        m[NULL] = NULL;\\n        while(temp != NULL){\\n            if(nhead == NULL){\\n                nhead = new Node(temp->val);\\n                ntail = nhead;\\n            }\\n            else{\\n                ntail->next = new Node(temp->val);\\n                ntail = ntail->next;\\n            }\\n            m[temp] = ntail;\\n            temp = temp->next;\\n        }\\n        \\n        \\n        temp = nhead;\\n        while(temp != NULL){\\n            temp->random = m[head->random];\\n            head = head->next;\\n            temp = temp->next;\\n        }\\n        return nhead;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739675,
                "title": "solution-swift-copy-list-with-random-pointer",
                "content": "```swift\\nclass Solution {\\n    func copyRandomList(_ head: Node?) -> Node? {\\n        if head == nil { return nil }\\n        \\n        var node = head, idx = 0\\n        \\n        while let nod = node {\\n            nod.val = (nod.val + 10000) | (idx << 32)\\n            node = nod.next\\n            idx += 1\\n        }\\n        \\n        var nodes: [Node?] = []\\n        node = head\\n        \\n        while let nod = node {\\n            let new = Node((nod.val & Int(UInt32.max)) - 10000)\\n            if !nodes.isEmpty { nodes[nodes.count - 1]?.next = new }\\n            nodes.append(new)\\n            node = nod.next\\n        }\\n        \\n        node = head\\n        idx = 0\\n        \\n        while let nod = node {\\n            if let rand = nod.random {\\n                nodes[idx]?.random = nodes[rand.val >> 32]\\n            }\\n            node = node?.next\\n            idx += 1\\n        }\\n        return nodes[0]\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><b>Node</b></summary>\\n\\n```swift\\npublic class Node {\\n    public var val: Int\\n    public var next: Node?\\n    public var random: Node?\\n    public init(_ val: Int) {\\n        self.val = val\\n        self.next = nil\\n        self.random = nil\\n    }\\n}\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func copyRandomList(_ head: Node?) -> Node? {\\n        if head == nil { return nil }\\n        \\n        var node = head, idx = 0\\n        \\n        while let nod = node {\\n            nod.val = (nod.val + 10000) | (idx << 32)\\n            node = nod.next\\n            idx += 1\\n        }\\n        \\n        var nodes: [Node?] = []\\n        node = head\\n        \\n        while let nod = node {\\n            let new = Node((nod.val & Int(UInt32.max)) - 10000)\\n            if !nodes.isEmpty { nodes[nodes.count - 1]?.next = new }\\n            nodes.append(new)\\n            node = nod.next\\n        }\\n        \\n        node = head\\n        idx = 0\\n        \\n        while let nod = node {\\n            if let rand = nod.random {\\n                nodes[idx]?.random = nodes[rand.val >> 32]\\n            }\\n            node = node?.next\\n            idx += 1\\n        }\\n        return nodes[0]\\n    }\\n}\\n```\n```swift\\npublic class Node {\\n    public var val: Int\\n    public var next: Node?\\n    public var random: Node?\\n    public init(_ val: Int) {\\n        self.val = val\\n        self.next = nil\\n        self.random = nil\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1680280,
                "title": "simple-c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        unordered_map<Node*,Node*> ump;\\n        Node* curr = head;\\n        while(curr!=NULL){\\n            Node* copy = new Node(curr->val);\\n            ump[curr] = copy;\\n            curr=curr->next;\\n        }\\n        curr = head;\\n        while(curr!=NULL){\\n            ump[curr]->next= ump[curr->next];\\n            ump[curr]->random = ump[curr->random];\\n            curr=curr->next;\\n        }\\n        return ump[head];\\n    }\\n};\\n```\\n*If you like it pls upvote my answer*",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        unordered_map<Node*,Node*> ump;\\n        Node* curr = head;\\n        while(curr!=NULL){\\n            Node* copy = new Node(curr->val);\\n            ump[curr] = copy;\\n            curr=curr->next;\\n        }\\n        curr = head;\\n        while(curr!=NULL){\\n            ump[curr]->next= ump[curr->next];\\n            ump[curr]->random = ump[curr->random];\\n            curr=curr->next;\\n        }\\n        return ump[head];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523760,
                "title": "easy-to-understand-7-8-line-code-in-c",
                "content": "class Solution {\\npublic:\\n\\n\\n    Node* copyRandomList(Node* head) {\\n        map<Node*,Node*> mp;\\n        \\n        Node* var=head;\\n        \\n        while(var!=NULL)\\n        {\\n            mp[var] = new Node(var->val);\\n            var=var->next;\\n            \\n        }\\n        \\n        var=head;\\n        \\n        while(var!=NULL)\\n        {\\n            mp[var]->next= mp[var->next]; \\n            \\n       \\n            mp[var]->random=mp[var->random];\\n            \\n            var=var->next;\\n        }\\n        \\n        return mp[head];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    Node* copyRandomList(Node* head) {\\n        map<Node*,Node*> mp;\\n        \\n        Node* var=head;\\n        \\n        while(var!=NULL)\\n        {\\n            mp[var] = new Node(var->val);\\n            var=var->next;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1124767,
                "title": "this-is-the-way-python",
                "content": "Logic:\\nWe need links between old and new list for assigning the `random` nodes.\\n\\n1. For each node `p1` of old linked list: create a new node `q1` such that:\\n\\t`p1.cloned_to = q1`\\n2. For each node `p1` in old list, assign `next` and `random` to `q1`:\\n\\t`q1.next = p1.next.cloned_to`\\n    `q1.random = p1.random.cloned_to`\\n\\t\\n```\\nclass Solution:\\n    def copyRandomList(self, head):\\n        \\n        if not head: return \\n        \\n        p1 = head\\n\\t\\t\\n        while p1:\\n            q1 = Node(p1.val)\\n            p1.cloned_to = q1\\n            p1 = p1.next\\n        \\n        p1 = head\\n\\n        while p1:\\n            q1 = p1.cloned_to\\n            q1.next = p1.next.cloned_to if p1.next else None\\n            q1.random = p1.random.cloned_to if p1.random else None\\n            p1 = p1.next\\n            \\n        return head.cloned_to\\n   ```         \\n   \\n  Time: `O(N)`, Space: `O(1)`\\n            \\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head):\\n        \\n        if not head: return \\n        \\n        p1 = head\\n\\t\\t\\n        while p1:\\n            q1 = Node(p1.val)\\n            p1.cloned_to = q1\\n            p1 = p1.next\\n        \\n        p1 = head\\n\\n        while p1:\\n            q1 = p1.cloned_to\\n            q1.next = p1.next.cloned_to if p1.next else None\\n            q1.random = p1.random.cloned_to if p1.random else None\\n            p1 = p1.next\\n            \\n        return head.cloned_to\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 1059515,
                "title": "python-faster-than-96-65-cool-easy-understanding-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n\\t\\t\\thelper = {}\\n\\t\\t\\tdef buildList(head: Node) -> Node:\\n\\t\\t\\t\\tnonlocal helper\\n\\t\\t\\t\\tif not head: return None\\n\\t\\t\\t\\tif helper.get(head): return helper[head]\\n\\t\\t\\t\\thelper[head] = Node( head.val )\\n\\t\\t\\t\\thelper[head].random = buildList(head.random)\\n\\t\\t\\t\\thelper[head].next = buildList(head.next)\\n\\t\\t\\t\\treturn helper[head]\\n\\t\\t\\t\\n\\t\\t\\treturn buildList(head)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "class Solution:\\n\\t\\tdef copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n\\t\\t\\thelper = {}",
                "codeTag": "Java"
            },
            {
                "id": 940030,
                "title": "o-1-space-complexity-and-o-n-time-complexity-solution",
                "content": "*Lets say we have a LinkdeList as*\\n1[13] -> 2[1] -> 13[13] -> 13[2]\\n\\nThe idea here is to do a little trick. We first traverse the list and add the next pointer of the current node to another node having the same value and marking the next of the new pointer to the next of the current pointer and making the next of current pointer to the temp node.\\n\\n*So after the first traversal we get:*\\n1[13] -> 1 ->2[1] -> 2 -> 13[13] -> 13 -> 13[2] -> 13\\n\\n**The next pointer of each node points to a pointer same in value but the random pointer is intact.**\\n\\nNow, as we can see the random pointer is intact, so we can next of current pointer point to the next of the random of current. It is a bit of a tounge twister but what we are basically doing is *1 points to 1 and its random is 13, so the next of 1 will point to the random of 1(i.e. 13) and it\\'s next.*\\n\\nSo we get:\\n1[13] -> 1[13] -> 2[1] -> 2 -> 13[13] -> 13 ->13[2] -> 13\\nSimiliarly we do the above step for 2 pointer. **The next of 2 points to 13 but the random of the next node points to the next of random of the current node.**\\n& that is basically the idea to do it in Constant space and Linear time.\\n\\nI tried to convey the idea to the best of my abilities, if you\\'re still unsure how is it done, don\\'t worry, I didn\\'t get it in the first time either. Take a look at the video and go through the code once.\\nhttps://www.youtube.com/watch?v=xbpUHSKoALg&t=1s\\n\\nHere\\'s the code however\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\nclass Solution:\\n\\tdef copyRandomList(self, head):\\n\\n\\t\\t# Insert each node\\'s copy right after it, already copy.val\\n\\t\\tnode = head\\n\\t\\twhile node:\\n\\t\\t\\tcopy = Node(node.val)\\n\\t\\t\\tcopy.next = node.next\\n\\t\\t\\tnode.next = copy\\n\\t\\t\\tnode = copy.next\\n\\n\\t\\t# Set each copy\\'s.random\\n\\t\\tnode = head\\n\\t\\twhile node:\\n\\t\\t\\tnode.next.random = node.random and node.random.next\\n\\t\\t\\tnode = node.next.next\\n\\n\\t\\t# Separate the copied list from the original, (re)setting every .next\\n\\t\\tnode = head\\n\\t\\tcopy = head_copy = head and head.next\\n\\t\\twhile node:\\n\\t\\t\\tnode.next = node = copy.next\\n\\t\\t\\tcopy.next = copy = node and node.next\\n\\n\\t\\treturn head_copy\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\nclass Solution:\\n\\tdef copyRandomList(self, head):\\n\\n\\t\\t# Insert each node\\'s copy right after it, already copy.val\\n\\t\\tnode = head\\n\\t\\twhile node:\\n\\t\\t\\tcopy = Node(node.val)\\n\\t\\t\\tcopy.next = node.next\\n\\t\\t\\tnode.next = copy\\n\\t\\t\\tnode = copy.next\\n\\n\\t\\t# Set each copy\\'s.random\\n\\t\\tnode = head\\n\\t\\twhile node:\\n\\t\\t\\tnode.next.random = node.random and node.random.next\\n\\t\\t\\tnode = node.next.next\\n\\n\\t\\t# Separate the copied list from the original, (re)setting every .next\\n\\t\\tnode = head\\n\\t\\tcopy = head_copy = head and head.next\\n\\t\\twhile node:\\n\\t\\t\\tnode.next = node = copy.next\\n\\t\\t\\tcopy.next = copy = node and node.next\\n\\n\\t\\treturn head_copy\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679840,
                "title": "easy-detailed-explanation-for-o-1-space-o-n-time",
                "content": "First look at this awesome video https://www.youtube.com/watch?v=OvpKeraoxW0 and understand what exactly are the 3 steps from logic point of view. Don\\'t worry about the code.\\n\\nOnce you have seen the video explanation just go through the below code once and it will be crystal clear.\\n\\n```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        //edge case\\n        if(head == null)\\n            return head;\\n        \\n        Node originalHead = head;\\n        \\n        //Step 1: Make copyNode and insert the copyNode between originalNode and its next originalNode.\\n        //In this step Head will be always placed on original nodes.\\n        while(head != null){\\n            Node nextOriginalNode = head.next;\\n            Node copyNode = new Node(head.val);\\n            head.next = copyNode;\\n            copyNode.next = nextOriginalNode;\\n            head = nextOriginalNode;\\n        }\\n        \\n        //Step 2: Make wiring of random references of copyNodes. In this step Head will be always placed on\\n        //original nodes.\\n        head = originalHead;\\n        while(head != null){\\n            //if the head\\'s random is pointing to null, we don\\'t need to do anything. It is there by deafult\\n            if(head.random != null){\\n                //Whatever node is pointed by the original node\\'s random, we assign the next of that node\\n                //to our copyNode\\'s random. This is because the node pointed by the original node\\'s random\\n                //further points to its copyNode. And we need to wire copyNode\\'s random.\\n                \\n                //So head.next gives us the copyNode whose random needs to be wired. Head is at our original\\n                //node. Now if you look at the node pointed by the head.random, you will observe that it is\\n                //also an original node.\\n                \\n                //But we want to wire copyNode with copyNode. So if you look carefully the original node we\\n                //obtained after head.random, is pointing to is copied version via next. And this is what we\\n                //want.\\n                //So head.random.next ==> gives us the target copyNode to be wired.\\n                //And we need to wire it with head.next.random.\\n                //Hence the code will be head.next.random = head.random.next;\\n                head.next.random = head.random.next;\\n                \\n                //Simplified version \\n                //Node copyNode = head.next;\\n                //copyNode.random = head.random.next;\\n            }\\n            head = head.next.next; //Since we want to move on original Nodes only.\\n        }\\n        \\n        //Step 3: Separate original list with the copied list and return copied head\\n        head = originalHead;\\n        Node copyNodeHead = head.next;\\n        Node copyNodePtr = copyNodeHead;\\n        \\n        while(copyNodePtr.next != null){\\n            head.next = head.next.next;\\n            head = head.next;\\n            \\n            copyNodePtr.next = copyNodePtr.next.next;\\n            copyNodePtr = copyNodePtr.next;\\n        }\\n        head.next = copyNodePtr.next; //Important step. Because copyNode\\'s list last node is connected to\\n        //null. Whereas the last node of the original list is connected to the last node of copyNode list.\\n        //To fully separate these two lists we need to connect the original list\\'s last node to null.\\n        //Hence we do head.next = head.next.next which is similar to head.next = copyNodePtr.next\\n        \\n        return copyNodeHead;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        //edge case\\n        if(head == null)\\n            return head;\\n        \\n        Node originalHead = head;\\n        \\n        //Step 1: Make copyNode and insert the copyNode between originalNode and its next originalNode.\\n        //In this step Head will be always placed on original nodes.\\n        while(head != null){\\n            Node nextOriginalNode = head.next;\\n            Node copyNode = new Node(head.val);\\n            head.next = copyNode;\\n            copyNode.next = nextOriginalNode;\\n            head = nextOriginalNode;\\n        }\\n        \\n        //Step 2: Make wiring of random references of copyNodes. In this step Head will be always placed on\\n        //original nodes.\\n        head = originalHead;\\n        while(head != null){\\n            //if the head\\'s random is pointing to null, we don\\'t need to do anything. It is there by deafult\\n            if(head.random != null){\\n                //Whatever node is pointed by the original node\\'s random, we assign the next of that node\\n                //to our copyNode\\'s random. This is because the node pointed by the original node\\'s random\\n                //further points to its copyNode. And we need to wire copyNode\\'s random.\\n                \\n                //So head.next gives us the copyNode whose random needs to be wired. Head is at our original\\n                //node. Now if you look at the node pointed by the head.random, you will observe that it is\\n                //also an original node.\\n                \\n                //But we want to wire copyNode with copyNode. So if you look carefully the original node we\\n                //obtained after head.random, is pointing to is copied version via next. And this is what we\\n                //want.\\n                //So head.random.next ==> gives us the target copyNode to be wired.\\n                //And we need to wire it with head.next.random.\\n                //Hence the code will be head.next.random = head.random.next;\\n                head.next.random = head.random.next;\\n                \\n                //Simplified version \\n                //Node copyNode = head.next;\\n                //copyNode.random = head.random.next;\\n            }\\n            head = head.next.next; //Since we want to move on original Nodes only.\\n        }\\n        \\n        //Step 3: Separate original list with the copied list and return copied head\\n        head = originalHead;\\n        Node copyNodeHead = head.next;\\n        Node copyNodePtr = copyNodeHead;\\n        \\n        while(copyNodePtr.next != null){\\n            head.next = head.next.next;\\n            head = head.next;\\n            \\n            copyNodePtr.next = copyNodePtr.next.next;\\n            copyNodePtr = copyNodePtr.next;\\n        }\\n        head.next = copyNodePtr.next; //Important step. Because copyNode\\'s list last node is connected to\\n        //null. Whereas the last node of the original list is connected to the last node of copyNode list.\\n        //To fully separate these two lists we need to connect the original list\\'s last node to null.\\n        //Hence we do head.next = head.next.next which is similar to head.next = copyNodePtr.next\\n        \\n        return copyNodeHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 669560,
                "title": "javascript-o-1-space-no-hashmap",
                "content": "```javascript\\nvar copyRandomList = function(head) {\\n    \\n    function createNewNodes(node) {\\n        if(!node) return;\\n        const newNode = new Node(node.val);\\n        newNode.next = node.next;\\n        node.next = newNode;\\n        createNewNodes(newNode.next);\\n    }\\n    \\n    function linkRandomNode(node) {\\n        if(!node) return;\\n        node.next.random = node.random ? node.random.next : null;\\n        linkRandomNode(node.next.next);\\n    }\\n    \\n    function restoreOriginal(node) {\\n        if(!node) return null;\\n        const temp = node.next;\\n        node.next = node.next.next;\\n        temp.next = restoreOriginal(node.next)\\n        return temp;\\n    }\\n    \\n    createNewNodes(head);\\n    linkRandomNode(head);\\n    return restoreOriginal(head);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar copyRandomList = function(head) {\\n    \\n    function createNewNodes(node) {\\n        if(!node) return;\\n        const newNode = new Node(node.val);\\n        newNode.next = node.next;\\n        node.next = newNode;\\n        createNewNodes(newNode.next);\\n    }\\n    \\n    function linkRandomNode(node) {\\n        if(!node) return;\\n        node.next.random = node.random ? node.random.next : null;\\n        linkRandomNode(node.next.next);\\n    }\\n    \\n    function restoreOriginal(node) {\\n        if(!node) return null;\\n        const temp = node.next;\\n        node.next = node.next.next;\\n        temp.next = restoreOriginal(node.next)\\n        return temp;\\n    }\\n    \\n    createNewNodes(head);\\n    linkRandomNode(head);\\n    return restoreOriginal(head);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 569173,
                "title": "simple-recursive-o-n-o-n-100-faster",
                "content": "```\\n    public Node copyRandomList(Node head) {\\n      HashMap<Node, Node> map = new HashMap<>();\\n      \\n      return cloneMyAssDeeply(head, map);\\n      \\n    }\\n  \\n  private Node cloneMyAssDeeply(Node head, HashMap map){\\n    \\n    if(head == null)\\n      return null;\\n    \\n    Node node = new Node(head.val);\\n    \\n    map.put(head, node);\\n    \\n    node.next = cloneMyAssDeeply(head.next, map);\\n    \\n    node.random = (Node)map.get(head.random);\\n    \\n    return node;\\n  }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public Node copyRandomList(Node head) {\\n      HashMap<Node, Node> map = new HashMap<>();\\n      \\n      return cloneMyAssDeeply(head, map);\\n      \\n    }\\n  \\n  private Node cloneMyAssDeeply(Node head, HashMap map){\\n    \\n    if(head == null)\\n      return null;\\n    \\n    Node node = new Node(head.val);\\n    \\n    map.put(head, node);\\n    \\n    node.next = cloneMyAssDeeply(head.next, map);\\n    \\n    node.random = (Node)map.get(head.random);\\n    \\n    return node;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 492116,
                "title": "python3-with-comments",
                "content": "```py\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if head is None:\\n            return\\n        \\n\\t\\t# First pass over linked list to create the cloned nodes without connections\\n        node = head\\n\\t\\t# Nodes are objects and in Python all user defined classes are hashable by default\\n\\t\\t# this allows us to map the original Nodes to their clones\\n        clone_map = {}\\n        while node:\\n            clone_map[node] = Node(node.val) # we allow the next and random attributes to default to None\\n            node = node.next\\n        \\n\\t\\t# Second pass over the original linked list, this time creating the connections\\n        node = head\\n        while node:\\n            clone_map[node].next = clone_map.get(node.next)\\n\\t\\t\\t# The \"random\" nodes can be accessed in constant time\\n            clone_map[node].random = clone_map.get(node.random)\\n            node = node.next\\n\\t\\t\\n\\t\\t# now we can return the first cloned node\\n        return clone_map[head]\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        if head is None:\\n            return\\n        \\n\\t\\t# First pass over linked list to create the cloned nodes without connections\\n        node = head\\n\\t\\t# Nodes are objects and in Python all user defined classes are hashable by default\\n\\t\\t# this allows us to map the original Nodes to their clones\\n        clone_map = {}\\n        while node:\\n            clone_map[node] = Node(node.val) # we allow the next and random attributes to default to None\\n            node = node.next\\n        \\n\\t\\t# Second pass over the original linked list, this time creating the connections\\n        node = head\\n        while node:\\n            clone_map[node].next = clone_map.get(node.next)\\n\\t\\t\\t# The \"random\" nodes can be accessed in constant time\\n            clone_map[node].random = clone_map.get(node.random)\\n            node = node.next\\n\\t\\t\\n\\t\\t# now we can return the first cloned node\\n        return clone_map[head]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 422333,
                "title": "c-easy-to-understand",
                "content": "``` cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return head;\\n        auto curr = head;\\n        // insert new nodes in between\\n        while(curr){\\n            auto tmp = curr->next;\\n            auto new_node = new Node(curr->val, tmp, nullptr);\\n            curr->next = new_node;\\n            curr = new_node->next;\\n        }\\n        // assign rand access pointers\\n        curr = head;\\n        while(curr){\\n            curr->next->random = curr->random ? curr->random->next : nullptr;\\n            curr = curr->next->next;\\n        }\\n        // separate the list and reconstruct the original;\\n        auto new_head = head->next;\\n        curr = head;\\n        while(curr){\\n            auto next_node = curr->next;\\n            curr->next = next->next;\\n            curr = curr->next;\\n            next_node->next = curr ? curr->next : nullptr;\\n        }\\n        return new_head;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "``` cpp\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return head;\\n        auto curr = head;\\n        // insert new nodes in between\\n        while(curr){\\n            auto tmp = curr->next;\\n            auto new_node = new Node(curr->val, tmp, nullptr);\\n            curr->next = new_node;\\n            curr = new_node->next;\\n        }\\n        // assign rand access pointers\\n        curr = head;\\n        while(curr){\\n            curr->next->random = curr->random ? curr->random->next : nullptr;\\n            curr = curr->next->next;\\n        }\\n        // separate the list and reconstruct the original;\\n        auto new_head = head->next;\\n        curr = head;\\n        while(curr){\\n            auto next_node = curr->next;\\n            curr->next = next->next;\\n            curr = curr->next;\\n            next_node->next = curr ? curr->next : nullptr;\\n        }\\n        return new_head;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 326252,
                "title": "python3-simple-print-statement-throws-runtime-error",
                "content": "```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        print(\"test\")\\n```\\n\\nI hit \"Run Code\" and get a runtime error \"\\'NoneType\\' object is not subscriptable.\" Obviously since this doesn\\'t work with just a print statement, I can\\'t even attempt to run code that actually addresses the problem. Am I missing something? The Python 2.x equivalent runs with no issues:\\n\\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        print \"test\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        print(\"test\")\\n```\n```\\nclass Solution:\\n    def copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n        print \"test\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43578,
                "title": "simple-java-solution-o-1-space-o-n-time-complexity",
                "content": "```\\n public RandomListNode copyRandomList(RandomListNode head) {\\n        if (head == null) {\\n            return head;\\n        }\\n\\n        RandomListNode cur = head;\\n        RandomListNode next = null;\\n        while(cur != null) { //insert a new node between originals\\n            next = cur.next;\\n            cur.next = new RandomListNode(cur.label);\\n            cur.next.next = next;\\n            cur = next;\\n        }\\n        \\n        RandomListNode copyHead = head.next;\\n        cur = head;\\n        while(cur != null) { //set the random of each newNode\\n            if(cur.random == null) {\\n                cur.next.random = null;\\n            }\\n            else {\\n                cur.next.random = cur.random.next;\\n            }\\n            cur = cur.next.next;\\n        }\\n\\n\\n        cur = head;\\n        RandomListNode curCopy = null;\\n        while(cur != null && cur.next != null) { // set the next of each original and new node\\n            curCopy = cur.next;\\n            cur.next = cur.next.next;\\n            cur = curCopy;\\n        }\\n\\n        return copyHead;\\n    }",
                "solutionTags": [],
                "code": "```\\n public RandomListNode copyRandomList(RandomListNode head) {\\n        if (head == null) {\\n            return head;\\n        }\\n\\n        RandomListNode cur = head;\\n        RandomListNode next = null;\\n        while(cur != null) { //insert a new node between originals\\n            next = cur.next;\\n            cur.next = new RandomListNode(cur.label);\\n            cur.next.next = next;\\n            cur = next;\\n        }\\n        \\n        RandomListNode copyHead = head.next;\\n        cur = head;\\n        while(cur != null) { //set the random of each newNode\\n            if(cur.random == null) {\\n                cur.next.random = null;\\n            }\\n            else {\\n                cur.next.random = cur.random.next;\\n            }\\n            cur = cur.next.next;\\n        }\\n\\n\\n        cur = head;\\n        RandomListNode curCopy = null;\\n        while(cur != null && cur.next != null) { // set the next of each original and new node\\n            curCopy = cur.next;\\n            cur.next = cur.next.next;\\n            cur = curCopy;\\n        }\\n\\n        return copyHead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43609,
                "title": "similar-to-graph-clone-recursive-java-solution",
                "content": "This is another **deep clone** problem for list, use a map to store its original and its new copy, recursive java solution:\\n```\\nMap<RandomListNode, RandomListNode> map = new HashMap<>();\\n\\n    public RandomListNode copyRandomList(RandomListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (map.containsKey(head)) {\\n            return map.get(head);\\n        }\\n        RandomListNode result = new RandomListNode(head.label);\\n        map.put(head, result);\\n        result.next = copyRandomList(head.next);\\n        result.random = copyRandomList(head.random);\\n        return result;\\n    }",
                "solutionTags": [],
                "code": "This is another **deep clone** problem for list, use a map to store its original and its new copy, recursive java solution:\\n```\\nMap<RandomListNode, RandomListNode> map = new HashMap<>();\\n\\n    public RandomListNode copyRandomList(RandomListNode head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        if (map.containsKey(head)) {\\n            return map.get(head);\\n        }\\n        RandomListNode result = new RandomListNode(head.label);\\n        map.put(head, result);\\n        result.next = copyRandomList(head.next);\\n        result.random = copyRandomList(head.random);\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 43553,
                "title": "accepted-java-solution-with-explanation-no-additional-data-structures",
                "content": "The idea is to use only next and random link of a node to create a copy of list. Please, check sketch and Java code below.\\n\\n\\n![enter image description here][1]\\n\\n\\n    public RandomListNode copyRandomList(RandomListNode head) {\\n\\t\\tif (head == null) return null;\\n\\t\\t\\n\\t\\t// Step 1\\n\\t\\tRandomListNode origin = head;\\n\\t\\twhile (origin != null) {\\n\\t\\t\\tRandomListNode originNext = origin.next;\\n\\t\\t\\tRandomListNode copy = new RandomListNode(origin.label);\\n\\t\\t\\torigin.next = copy;\\n\\t\\t\\tcopy.next = originNext;\\n\\t\\t\\torigin = originNext;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Step 2\\n\\t\\torigin = head;\\n\\t\\twhile (origin != null) {\\n\\t\\t\\tRandomListNode originNext = origin.next.next;\\n\\t\\t\\tRandomListNode copy = origin.next;\\n\\t\\t\\tif (origin.random != null) {\\n\\t\\t\\t\\tcopy.random = origin.random.next;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcopy.random = null;\\n\\t\\t\\t}\\n\\t\\t\\torigin = originNext;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Step 3\\n\\t\\torigin = head;\\n\\t\\tRandomListNode copyHead = head.next;\\n\\t\\twhile (origin != null) {\\n\\t\\t\\tRandomListNode copy = origin.next;\\n\\t\\t\\tRandomListNode originNext = origin.next.next;\\n\\t\\t\\tRandomListNode copyNext;\\n\\t\\t\\tif (copy.next != null) {\\n\\t\\t\\t\\tcopyNext = copy.next.next;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcopyNext = null;\\n\\t\\t\\t}\\n\\t\\t\\torigin.next = originNext;\\n\\t\\t\\tcopy.next = copyNext;\\n\\t\\t\\torigin = originNext;\\n\\t\\t\\tcopy = copyNext;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn copyHead;\\n    }\\n\\n\\n  [1]: http://s27.postimg.org/ywzricioz/IMG_20150101_173454.jpg\\n  [2]: http://postimg.org/image/rh0hwjuzj/",
                "solutionTags": [],
                "code": "The idea is to use only next and random link of a node to create a copy of list. Please, check sketch and Java code below.\\n\\n\\n![enter image description here][1]\\n\\n\\n    public RandomListNode copyRandomList(RandomListNode head) {\\n\\t\\tif (head == null) return null;\\n\\t\\t\\n\\t\\t// Step 1\\n\\t\\tRandomListNode origin = head;\\n\\t\\twhile (origin != null) {\\n\\t\\t\\tRandomListNode originNext = origin.next;\\n\\t\\t\\tRandomListNode copy = new RandomListNode(origin.label);\\n\\t\\t\\torigin.next = copy;\\n\\t\\t\\tcopy.next = originNext;\\n\\t\\t\\torigin = originNext;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Step 2\\n\\t\\torigin = head;\\n\\t\\twhile (origin != null) {\\n\\t\\t\\tRandomListNode originNext = origin.next.next;\\n\\t\\t\\tRandomListNode copy = origin.next;\\n\\t\\t\\tif (origin.random != null) {\\n\\t\\t\\t\\tcopy.random = origin.random.next;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcopy.random = null;\\n\\t\\t\\t}\\n\\t\\t\\torigin = originNext;\\n\\t\\t}\\n\\t\\t\\n\\t\\t// Step 3\\n\\t\\torigin = head;\\n\\t\\tRandomListNode copyHead = head.next;\\n\\t\\twhile (origin != null) {\\n\\t\\t\\tRandomListNode copy = origin.next;\\n\\t\\t\\tRandomListNode originNext = origin.next.next;\\n\\t\\t\\tRandomListNode copyNext;\\n\\t\\t\\tif (copy.next != null) {\\n\\t\\t\\t\\tcopyNext = copy.next.next;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tcopyNext = null;\\n\\t\\t\\t}\\n\\t\\t\\torigin.next = originNext;\\n\\t\\t\\tcopy.next = copyNext;\\n\\t\\t\\torigin = originNext;\\n\\t\\t\\tcopy = copyNext;\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn copyHead;\\n    }\\n\\n\\n  [1]: http://s27.postimg.org/ywzricioz/IMG_20150101_173454.jpg\\n  [2]: http://postimg.org/image/rh0hwjuzj/",
                "codeTag": "Unknown"
            },
            {
                "id": 43768,
                "title": "with-error-random-pointer-of-node-with-label-1-points-to-a-node-from-the-original-list-can-anyone-help-me",
                "content": "    /**\\n     * Definition for singly-linked list with a random pointer.\\n     * struct RandomListNode {\\n     *     int label;\\n     *     RandomListNode *next, *random;\\n     *     RandomListNode(int x) : label(x), next(NULL), random(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n    \\tRandomListNode *copyRandomList(RandomListNode *head) {\\n    \\t\\tvector<RandomListNode *> vecOld;\\n    \\t\\tunordered_map<RandomListNode *, size_t> addressIndexMap;\\n    \\t\\tvector<RandomListNode *> vecAddress;\\n    \\t\\tif (!head)\\n    \\t\\t{\\n    \\t\\t\\treturn NULL;\\n    \\t\\t}\\n    \\t\\telse if (!head->next)\\n    \\t\\t{\\n    \\t\\t\\treturn new RandomListNode(*head);\\n    \\t\\t}\\n    \\t\\tRandomListNode * curr = head;\\n    \\t\\tRandomListNode * guard = new RandomListNode(0);\\n    \\t\\tRandomListNode * newCurr = guard;\\n    \\t\\twhile (curr)\\n    \\t\\t{\\n    \\t\\t    //store the old random pointer \\n    \\t\\t\\tvecOld.push_back(curr->random);\\n    \\t\\t\\t//store the old address -> index pair for later reconstruction of random pointer\\n    \\t\\t\\taddressIndexMap[curr] = vecOld.size() - 1;\\n    \\t\\t\\tnewCurr->next = new RandomListNode(*curr);\\n    \\t\\t\\tnewCurr = newCurr->next;\\n    \\t\\t\\tnewCurr->random = NULL;\\n    \\t\\t\\t//store the address of new nodes for later reconstruction of random pointer\\n    \\t\\t\\tvecAddress.push_back(newCurr);\\n    \\t\\t\\tcurr = curr->next;\\n    \\t\\t}\\n    \\t\\tnewCurr = guard->next;\\n    \\t\\tint index = 0;\\n    \\t\\twhile (newCurr)\\n    \\t\\t{\\n    \\t\\t    //If the old random pointer is not NULL\\n    \\t\\t\\tif (NULL != vecOld[index])\\n    \\t\\t\\t{\\n    \\t\\t\\t    //Get the corresponding index\\n    \\t\\t\\t\\tsize_t randomIndex = addressIndexMap[vecOld[index]];\\n    \\t\\t\\t\\t//get the new address of the node with the index and reconstruct the random pointer\\n    \\t\\t\\t\\tnewCurr->random = vecAddress[randomIndex];\\n    \\t\\t\\t}\\n    \\t\\t\\t++index;\\n    \\t\\t\\tnewCurr = newCurr->next;\\n    \\t\\t}\\n    \\t\\tnewCurr = guard->next;\\n    \\t\\tdelete guard;\\n    \\t\\treturn newCurr;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tRandomListNode *copyRandomList(RandomListNode *head) {\\n    \\t\\tvector<RandomListNode *> vecOld;\\n    \\t\\tunordered_map<RandomListNode *, size_t> addressIndexMap;\\n    \\t\\tvector<RandomListNode *> vecAddress;\\n    \\t\\tif (!head)\\n    \\t\\t{\\n    \\t\\t\\treturn NULL;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4004158,
                "title": "not-a-regular-solution-it-is-easy-then-random-pointer-beats-100-of-java-users",
                "content": "# Intuition\\nUsing HashMap which stores old->new pairs\\n\\n# Approach\\n- First you consider a hashmap and now one the go of creating a new node itself you try to point the old pointer to the newly created node.\\n- Don\\'t forget to point the newly formed linked list to next,next,next...\\n- The intial goal of first loop is to make key,value pairs and creating a linear linked list without pointing random pointers\\n- In the second loop u directly try to point the random pointers\\n- Finally you return new head.\\n\\n![image.png](https://assets.leetcode.com/users/images/4b132dba-7acc-49a1-a8c3-c252bd6f5eb9_1693895373.3642166.png)\\n![image.png](https://assets.leetcode.com/users/images/dc73eb27-15c5-410d-976d-0fba7eb2693b_1693895520.1152763.png)\\n\\n\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        HashMap<Node,Node>oldToNew = new HashMap<>();\\n        if(head==null)\\n            return null;\\n        Node oldCurr = head;\\n        Node prevNew = null;\\n        while(oldCurr!=null){\\n            Node newCurr = new Node(oldCurr.val);\\n            if(prevNew!=null){\\n                prevNew.next = newCurr;\\n            }\\n            prevNew = newCurr;\\n            oldToNew.put(oldCurr,newCurr);\\n            oldCurr = oldCurr.next;\\n        }\\n        oldCurr = head;\\n        while(oldCurr!=null){\\n            oldToNew.get(oldCurr).random = oldToNew.getOrDefault(oldCurr.random,null);\\n            oldCurr = oldCurr.next;\\n        }\\n\\n        return oldToNew.get(head);\\n\\n        \\n\\n        \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        HashMap<Node,Node>oldToNew = new HashMap<>();\\n        if(head==null)\\n            return null;\\n        Node oldCurr = head;\\n        Node prevNew = null;\\n        while(oldCurr!=null){\\n            Node newCurr = new Node(oldCurr.val);\\n            if(prevNew!=null){\\n                prevNew.next = newCurr;\\n            }\\n            prevNew = newCurr;\\n            oldToNew.put(oldCurr,newCurr);\\n            oldCurr = oldCurr.next;\\n        }\\n        oldCurr = head;\\n        while(oldCurr!=null){\\n            oldToNew.get(oldCurr).random = oldToNew.getOrDefault(oldCurr.random,null);\\n            oldCurr = oldCurr.next;\\n        }\\n\\n        return oldToNew.get(head);\\n\\n        \\n\\n        \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944614,
                "title": "the-most-optimal-solution-using-deep-copy-beats-100-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n  if (!head) return nullptr;\\n\\n        // Step 1: Duplicate nodes and interleave them in the original list\\n        Node* current = head;\\n        while (current) {\\n            Node* copy = new Node(current->val);\\n            copy->next = current->next;\\n            current->next = copy;\\n            current = copy->next;\\n        }\\n\\n        // Step 2: Update random pointers for the copied nodes\\n        current = head;\\n        while (current) {\\n            if (current->random) {\\n                current->next->random = current->random->next;\\n            }\\n            current = current->next->next;\\n        }\\n\\n        // Step 3: Separate the original list and the copied list\\n        current = head;\\n        Node* newHead = head->next;\\n        while (current) {\\n            Node* copy = current->next;\\n            current->next = copy->next;\\n            if (copy->next) {\\n                copy->next = copy->next->next;\\n            }\\n            current = current->next;\\n        }\\n\\n        return newHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n  if (!head) return nullptr;\\n\\n        // Step 1: Duplicate nodes and interleave them in the original list\\n        Node* current = head;\\n        while (current) {\\n            Node* copy = new Node(current->val);\\n            copy->next = current->next;\\n            current->next = copy;\\n            current = copy->next;\\n        }\\n\\n        // Step 2: Update random pointers for the copied nodes\\n        current = head;\\n        while (current) {\\n            if (current->random) {\\n                current->next->random = current->random->next;\\n            }\\n            current = current->next->next;\\n        }\\n\\n        // Step 3: Separate the original list and the copied list\\n        current = head;\\n        Node* newHead = head->next;\\n        while (current) {\\n            Node* copy = current->next;\\n            current->next = copy->next;\\n            if (copy->next) {\\n                copy->next = copy->next->next;\\n            }\\n            current = current->next;\\n        }\\n\\n        return newHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3861915,
                "title": "2-best-c-solution-with-video-explanation-space-o-1-and-o-n-solutions",
                "content": "# [Video Link](https://youtu.be/83mPr0i56Gg) \\n\\n### Please upvote the solution if you liked it !!\\n\\n# Code\\n```\\n// Solution 1 - Using maps - SC O(N) \\nclass Solution\\n{\\n    public:\\n    void insertAtTail(Node* &head, Node* &tail, int d){\\n        Node* newNode = new Node(d);\\n        if(head == NULL){\\n            head = newNode;\\n            tail = newNode;\\n            return;\\n        }\\n        else{\\n            tail->next = newNode;\\n            tail = newNode;\\n        }\\n    }\\n    \\n    Node *copyRandomList(Node *head)\\n    {\\n        Node* cloneHead = NULL;\\n        Node* cloneTail = NULL;\\n        Node* temp = head;\\n        \\n        // Step 1 - Create a clone LL\\n        while(temp != NULL){\\n            insertAtTail(cloneHead, cloneTail, temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        // Step 2 - Create a map\\n        unordered_map<Node*, Node*> mp;\\n        Node* originalNode = head;\\n        Node* cloneNode = cloneHead;\\n        \\n        while(originalNode != NULL){\\n            mp[originalNode] = cloneNode;\\n            originalNode = originalNode->next;\\n            cloneNode = cloneNode->next;\\n        }\\n        \\n        // Step 3 - Map random pointers\\n        originalNode = head;\\n        cloneNode = cloneHead;\\n        while(originalNode != temp){\\n            cloneNode->random = mp[originalNode->random];\\n            originalNode = originalNode->next;\\n            cloneNode = cloneNode->next;\\n        }\\n        \\n        return cloneHead;\\n    }\\n};\\n\\n// Solution 2 - SC O(1) \\nclass Solution {\\npublic:\\n    void insertAtTail(Node* &head, Node* &tail, int d){\\n        Node *newNode = new Node(d);\\n        if(head == NULL){\\n            head = newNode;\\n            tail = newNode;\\n        }\\n        else{\\n            tail->next = newNode;\\n            tail = newNode;\\n        }\\n    }\\n\\n    Node* copyRandomList(Node* head) {\\n\\n        Node *cloneHead = NULL, *cloneTail = NULL;\\n        Node *temp = head;\\n        \\n        // Step 1 = Create a cloned LL\\n        while(temp != NULL ){\\n            insertAtTail(cloneHead, cloneTail, temp->val);\\n            temp = temp->next;\\n        }\\n\\n        // Step 2 - Merge original and cloned LL\\n        temp = head;\\n        Node *clone = cloneHead;\\n        while(temp != NULL && clone != NULL){\\n            Node *newNode = temp->next;\\n            temp->next = clone;\\n            temp = newNode;\\n\\n            newNode = clone->next;\\n            clone->next = temp;\\n            clone = newNode;\\n        }\\n\\n        // Step 3 - Copy the random pointers from original node to clone nodes\\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL && temp->random != NULL){\\n                temp->next->random = temp->random->next;\\n            }\\n            temp = temp->next->next;\\n        }\\n\\n        // Step 4 - Revert/Reverse the step 2 by separating the orignal and clone LL\\n        temp = head;\\n        clone = cloneHead;\\n        while(temp != NULL){\\n            temp->next = clone->next;\\n            temp = temp->next;\\n\\n            if(temp != NULL)\\n                clone->next = temp->next;\\n            clone = clone->next;\\n        }\\n\\n        return cloneHead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n// Solution 1 - Using maps - SC O(N) \\nclass Solution\\n{\\n    public:\\n    void insertAtTail(Node* &head, Node* &tail, int d){\\n        Node* newNode = new Node(d);\\n        if(head == NULL){\\n            head = newNode;\\n            tail = newNode;\\n            return;\\n        }\\n        else{\\n            tail->next = newNode;\\n            tail = newNode;\\n        }\\n    }\\n    \\n    Node *copyRandomList(Node *head)\\n    {\\n        Node* cloneHead = NULL;\\n        Node* cloneTail = NULL;\\n        Node* temp = head;\\n        \\n        // Step 1 - Create a clone LL\\n        while(temp != NULL){\\n            insertAtTail(cloneHead, cloneTail, temp->val);\\n            temp = temp->next;\\n        }\\n        \\n        // Step 2 - Create a map\\n        unordered_map<Node*, Node*> mp;\\n        Node* originalNode = head;\\n        Node* cloneNode = cloneHead;\\n        \\n        while(originalNode != NULL){\\n            mp[originalNode] = cloneNode;\\n            originalNode = originalNode->next;\\n            cloneNode = cloneNode->next;\\n        }\\n        \\n        // Step 3 - Map random pointers\\n        originalNode = head;\\n        cloneNode = cloneHead;\\n        while(originalNode != temp){\\n            cloneNode->random = mp[originalNode->random];\\n            originalNode = originalNode->next;\\n            cloneNode = cloneNode->next;\\n        }\\n        \\n        return cloneHead;\\n    }\\n};\\n\\n// Solution 2 - SC O(1) \\nclass Solution {\\npublic:\\n    void insertAtTail(Node* &head, Node* &tail, int d){\\n        Node *newNode = new Node(d);\\n        if(head == NULL){\\n            head = newNode;\\n            tail = newNode;\\n        }\\n        else{\\n            tail->next = newNode;\\n            tail = newNode;\\n        }\\n    }\\n\\n    Node* copyRandomList(Node* head) {\\n\\n        Node *cloneHead = NULL, *cloneTail = NULL;\\n        Node *temp = head;\\n        \\n        // Step 1 = Create a cloned LL\\n        while(temp != NULL ){\\n            insertAtTail(cloneHead, cloneTail, temp->val);\\n            temp = temp->next;\\n        }\\n\\n        // Step 2 - Merge original and cloned LL\\n        temp = head;\\n        Node *clone = cloneHead;\\n        while(temp != NULL && clone != NULL){\\n            Node *newNode = temp->next;\\n            temp->next = clone;\\n            temp = newNode;\\n\\n            newNode = clone->next;\\n            clone->next = temp;\\n            clone = newNode;\\n        }\\n\\n        // Step 3 - Copy the random pointers from original node to clone nodes\\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL && temp->random != NULL){\\n                temp->next->random = temp->random->next;\\n            }\\n            temp = temp->next->next;\\n        }\\n\\n        // Step 4 - Revert/Reverse the step 2 by separating the orignal and clone LL\\n        temp = head;\\n        clone = cloneHead;\\n        while(temp != NULL){\\n            temp->next = clone->next;\\n            temp = temp->next;\\n\\n            if(temp != NULL)\\n                clone->next = temp->next;\\n            clone = clone->next;\\n        }\\n\\n        return cloneHead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739596,
                "title": "few-lines-super-easy-c-code",
                "content": "# Intuition\\nstep-1 : Take an unordered map and store the Node of old LL as a key and Copy node as a value.\\n\\nstep-2: Remove the new node from map and join the next and random by using key of the map \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n      unordered_map<Node*,Node*> m;\\n      for(Node *curr=head; curr != NULL ; curr=curr->next)\\n        m[curr]=new Node(curr->val);\\n     Node *clone;\\n     for(Node *curr=head; curr != NULL ; curr=curr->next){\\n         clone=m[curr];\\n         clone->next=m[curr->next];\\n         clone->random=m[curr->random];\\n     } \\n     Node *newhead=m[head];\\n     return newhead;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n      unordered_map<Node*,Node*> m;\\n      for(Node *curr=head; curr != NULL ; curr=curr->next)\\n        m[curr]=new Node(curr->val);\\n     Node *clone;\\n     for(Node *curr=head; curr != NULL ; curr=curr->next){\\n         clone=m[curr];\\n         clone->next=m[curr->next];\\n         clone->random=m[curr->random];\\n     } \\n     Node *newhead=m[head];\\n     return newhead;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3247684,
                "title": "java-beats-100-well-explained-using-hashmap-o-n-space",
                "content": "# Intuition\\nUse HashMap to store Nodes reference while traversing and creating a new copied list and thus it will contain all random connections in the map as well\\n\\n# Approach\\nFetch those random connections from the map and append those to new list as well\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null)\\n            return null;\\n        Node ansHead = new Node(head.val); //creating answer head and taking two pointers for each list\\n        Node temp2 = ansHead;\\n        Node temp = head;\\n\\n        HashMap<Node, Node> mapped = new HashMap<>();  // storing Node.next references in the map\\n        // key - temp.next , value - temp2.next\\n        mapped.put(head, ansHead); //putting itnitial values\\n\\n//traverse the linked list, copying the new nodes and putting next refernces of nodes on map\\n        while(temp!=null || temp2!=null){ \\n            \\n            if(temp.next!=null){\\n                temp2.next = new Node(temp.next.val); //copy\\n            }\\n\\n            mapped.put(temp.next, temp2.next);\\n            temp = temp.next;\\n            temp2 = temp2.next;\\n        }\\n\\n        temp = head;\\n        temp2 = ansHead;\\n\\n//once again traverse the linked list and make the random connections remaining\\n        while(temp2!=null || temp!=null){\\n            temp2.random = mapped.get(temp.random); // we will get temp.next.random from the map, we have \\n            // temp.next Node in the map, just retrieve .random from it\\n            temp=temp.next;\\n            temp2=temp2.next;\\n        }\\n        return ansHead;\\n    }\\n}\\n```\\n##### For another solution using Constant space visit - \\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/3249057/java-beats-100-detailed-solution-with-explanation-o-1-space-complexity/",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null)\\n            return null;\\n        Node ansHead = new Node(head.val); //creating answer head and taking two pointers for each list\\n        Node temp2 = ansHead;\\n        Node temp = head;\\n\\n        HashMap<Node, Node> mapped = new HashMap<>();  // storing Node.next references in the map\\n        // key - temp.next , value - temp2.next\\n        mapped.put(head, ansHead); //putting itnitial values\\n\\n//traverse the linked list, copying the new nodes and putting next refernces of nodes on map\\n        while(temp!=null || temp2!=null){ \\n            \\n            if(temp.next!=null){\\n                temp2.next = new Node(temp.next.val); //copy\\n            }\\n\\n            mapped.put(temp.next, temp2.next);\\n            temp = temp.next;\\n            temp2 = temp2.next;\\n        }\\n\\n        temp = head;\\n        temp2 = ansHead;\\n\\n//once again traverse the linked list and make the random connections remaining\\n        while(temp2!=null || temp!=null){\\n            temp2.random = mapped.get(temp.random); // we will get temp.next.random from the map, we have \\n            // temp.next Node in the map, just retrieve .random from it\\n            temp=temp.next;\\n            temp2=temp2.next;\\n        }\\n        return ansHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891413,
                "title": "kotlin-iterative",
                "content": "```\\nclass Solution {\\n    fun copyRandomList(node: Node?): Node? {\\n        val oldToNew = HashMap<Node, Node>()    \\n\\n        var copy: Node? = null\\n        var curr: Node? = node\\n\\n        while (curr != null) {\\n            copy = Node(curr.`val`)\\n            oldToNew[curr] = copy\\n            curr = curr?.next\\n        }\\n\\n        curr = node\\n        while (curr != null) {\\n            copy = oldToNew[curr]!!\\n            copy.next = oldToNew[curr.next]\\n            copy.random = oldToNew[curr.random]\\n            curr = curr?.next\\n        }\\n\\n        return oldToNew[node]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Hash Table",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    fun copyRandomList(node: Node?): Node? {\\n        val oldToNew = HashMap<Node, Node>()    \\n\\n        var copy: Node? = null\\n        var curr: Node? = node\\n\\n        while (curr != null) {\\n            copy = Node(curr.`val`)\\n            oldToNew[curr] = copy\\n            curr = curr?.next\\n        }\\n\\n        curr = node\\n        while (curr != null) {\\n            copy = oldToNew[curr]!!\\n            copy.next = oldToNew[curr.next]\\n            copy.random = oldToNew[curr.random]\\n            curr = curr?.next\\n        }\\n\\n        return oldToNew[node]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795536,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node * head_cp = nullptr, * cur = head, * cur_cp = nullptr;\\n        if (head == nullptr)\\n            return nullptr;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = new Node(cur->val, cur->next, nullptr);\\n            cur->next = cur_cp;\\n            cur = cur_cp->next;\\n        }\\n        cur = head;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = cur->next;\\n            if (cur->random)\\n                cur_cp->random = cur->random->next;\\n            cur = cur_cp ->next;\\n        }\\n        cur = head;\\n        head_cp = head->next;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = cur->next;\\n            cur->next = cur_cp->next;\\n            cur = cur->next;\\n            if (cur)\\n                cur_cp->next = cur->next;\\n        }\\n        return head_cp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node * head_cp = nullptr, * cur = head, * cur_cp = nullptr;\\n        if (head == nullptr)\\n            return nullptr;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = new Node(cur->val, cur->next, nullptr);\\n            cur->next = cur_cp;\\n            cur = cur_cp->next;\\n        }\\n        cur = head;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = cur->next;\\n            if (cur->random)\\n                cur_cp->random = cur->random->next;\\n            cur = cur_cp ->next;\\n        }\\n        cur = head;\\n        head_cp = head->next;\\n        while (cur != nullptr)\\n        {\\n            cur_cp = cur->next;\\n            cur->next = cur_cp->next;\\n            cur = cur->next;\\n            if (cur)\\n                cur_cp->next = cur->next;\\n        }\\n        return head_cp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642765,
                "title": "simple-solution-using-dictionary",
                "content": "\\n\\n# Code\\n```\\npublic class Solution {\\n    public Node CopyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n         var tracking = new Dictionary<Node, Node>();\\n        Node cur = head;\\n        // Copy node without next and random\\n        while (cur != null)\\n        {\\n            tracking.Add(cur, new Node(cur.val));\\n            cur = cur.next;\\n        }\\n\\n        cur = head;\\n        // Connect all node\\n        while (cur != null)\\n        {\\n            tracking[cur].next = cur.next != null ? tracking[cur.next] : null;\\n            tracking[cur].random = cur.random != null ? tracking[cur.random] : null;\\n            cur = cur.next;\\n        }\\n\\n        return tracking[head];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public Node CopyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n         var tracking = new Dictionary<Node, Node>();\\n        Node cur = head;\\n        // Copy node without next and random\\n        while (cur != null)\\n        {\\n            tracking.Add(cur, new Node(cur.val));\\n            cur = cur.next;\\n        }\\n\\n        cur = head;\\n        // Connect all node\\n        while (cur != null)\\n        {\\n            tracking[cur].next = cur.next != null ? tracking[cur.next] : null;\\n            tracking[cur].random = cur.random != null ? tracking[cur.random] : null;\\n            cur = cur.next;\\n        }\\n\\n        return tracking[head];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358516,
                "title": "c-solution-well-explained-diagram-time-complexity-o-n-space-complexity-o-1",
                "content": "##Explanation\\n\\n**Original Linked List:**\\n\\n![image.png](https://assets.leetcode.com/users/images/182cc627-0688-47fe-ba79-bd184ddbb7d3_1693872448.433081.png)\\n\\n### Phase 1 - Duplicating and Inserting Nodes\\n\\nIn this phase, we\\'ll create a new node for each original node and insert it between the original node and its next node.\\n\\nStart with the original list (head points to the first node).\\nCreate a duplicate node for each original node and insert it between them:\\n\\n![image.png](https://assets.leetcode.com/users/images/780d72af-7ec1-403b-8afa-ee5507159e40_1693872526.817351.png)\\n\\n\\n### Phase 2 - Updating Random Pointers\\n\\nIn this phase, we\\'ll update the random pointers of the duplicate nodes to point to the corresponding duplicate nodes.\\nStart with head->next (pointing to the first duplicate node) and head (pointing to the first original node).\\nUpdate the random pointers of the duplicate nodes:\\n<br>\\n**1\\' should point to the duplicate node corresponding to the random node of 1, which is 3\\'.\\n2\\' should point to the duplicate node corresponding to the random node of 2, which is 1\\'.\\n3\\' should point to the duplicate node corresponding to the random node of 3, which is 5\\'.\\n4\\' should point to the duplicate node corresponding to the random node of 4, which is 1\\'.\\n5\\' should point to the duplicate node corresponding to the random node of 5, which is 5\\' (it could also be nullptr).**\\n\\n![image.png](https://assets.leetcode.com/users/images/15e4f41f-37e9-4251-b0ab-6d00396a5188_1693872672.5756319.png)\\n\\n### Phase 3 - Separating the Lists\\n\\nIn this phase, we\\'ll separate the original list from the copied list.\\n\\nStart with head2 (pointing to the head of the copied list), temp (pointing to the first duplicate node), and t (pointing to the first original node).\\nIterate through the list and update the next pointers to skip every other node for both the original and copied lists.\\nAfter this phase, we\\'ll have two separate lists: the original list (head) and the copied list (head2). The two lists are structurally identical with the same random pointers but are independent.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/d061c72d-39b1-4890-80d8-71511e7a06a4_1693872712.9219985.png)\\n\\n\\n\\n\\n\\n```\\nNode* copyRandomList(Node* head) {\\n    // Check if the input list is empty\\n    if (!head)\\n        return head;\\n\\n    // Phase 1: Duplicate each node and insert it between the original nodes\\n    Node* temp = head;\\n    while (temp) {\\n        Node* newnode = new Node(temp->val);  // Create a new node with the same value as the original node\\n        newnode->next = temp->next;           // Set the new node\\'s \"next\" pointer to the original node\\'s \"next\"\\n        temp->next = newnode;                 // Update the original node\\'s \"next\" to point to the new node\\n        temp = temp->next->next;              // Move to the next original node\\n    }\\n\\n    // Phase 2: Update the random pointers of the new nodes\\n    temp = head->next;\\n    Node* t = head;\\n    while (temp) {\\n        if (t->random) // If the original node\\'s random pointer exists\\n            temp->random = t->random->next; // Update the new node\\'s random pointer to point to the corresponding new node\\n        else\\n            temp->random = t->random; // If the original node\\'s random pointer is nullptr, set the new node\\'s random pointer to nullptr\\n\\n        if (!temp->next) {\\n            break;\\n        }\\n        t = t->next->next;\\n        temp = temp->next->next;\\n    }\\n\\n    // Phase 3: Separate the original list and the copied list\\n    Node* head2 = head->next; // The head of the copied list\\n    temp = head->next;\\n    t = head;\\n    while (temp->next) {\\n        t->next = t->next->next; // Update the \"next\" pointer of the original list to skip the copied nodes\\n        temp->next = temp->next->next; // Update the \"next\" pointer of the copied list to skip the original nodes\\n        temp = temp->next;\\n        t = t->next;\\n    }\\n\\n    t->next = NULL; // Set the last node\\'s \"next\" pointer to nullptr to terminate the copied list\\n\\n    return head2; // Return the head of the copied list\\n}\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "##Explanation\\n\\n**Original Linked List:**\\n\\n![image.png](https://assets.leetcode.com/users/images/182cc627-0688-47fe-ba79-bd184ddbb7d3_1693872448.433081.png)\\n\\n### Phase 1 - Duplicating and Inserting Nodes\\n\\nIn this phase, we\\'ll create a new node for each original node and insert it between the original node and its next node.\\n\\nStart with the original list (head points to the first node).\\nCreate a duplicate node for each original node and insert it between them:\\n\\n![image.png](https://assets.leetcode.com/users/images/780d72af-7ec1-403b-8afa-ee5507159e40_1693872526.817351.png)\\n\\n\\n### Phase 2 - Updating Random Pointers\\n\\nIn this phase, we\\'ll update the random pointers of the duplicate nodes to point to the corresponding duplicate nodes.\\nStart with head->next (pointing to the first duplicate node) and head (pointing to the first original node).\\nUpdate the random pointers of the duplicate nodes:\\n<br>\\n**1\\' should point to the duplicate node corresponding to the random node of 1, which is 3\\'.\\n2\\' should point to the duplicate node corresponding to the random node of 2, which is 1\\'.\\n3\\' should point to the duplicate node corresponding to the random node of 3, which is 5\\'.\\n4\\' should point to the duplicate node corresponding to the random node of 4, which is 1\\'.\\n5\\' should point to the duplicate node corresponding to the random node of 5, which is 5\\' (it could also be nullptr).**\\n\\n![image.png](https://assets.leetcode.com/users/images/15e4f41f-37e9-4251-b0ab-6d00396a5188_1693872672.5756319.png)\\n\\n### Phase 3 - Separating the Lists\\n\\nIn this phase, we\\'ll separate the original list from the copied list.\\n\\nStart with head2 (pointing to the head of the copied list), temp (pointing to the first duplicate node), and t (pointing to the first original node).\\nIterate through the list and update the next pointers to skip every other node for both the original and copied lists.\\nAfter this phase, we\\'ll have two separate lists: the original list (head) and the copied list (head2). The two lists are structurally identical with the same random pointers but are independent.\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/d061c72d-39b1-4890-80d8-71511e7a06a4_1693872712.9219985.png)\\n\\n\\n\\n\\n\\n```\\nNode* copyRandomList(Node* head) {\\n    // Check if the input list is empty\\n    if (!head)\\n        return head;\\n\\n    // Phase 1: Duplicate each node and insert it between the original nodes\\n    Node* temp = head;\\n    while (temp) {\\n        Node* newnode = new Node(temp->val);  // Create a new node with the same value as the original node\\n        newnode->next = temp->next;           // Set the new node\\'s \"next\" pointer to the original node\\'s \"next\"\\n        temp->next = newnode;                 // Update the original node\\'s \"next\" to point to the new node\\n        temp = temp->next->next;              // Move to the next original node\\n    }\\n\\n    // Phase 2: Update the random pointers of the new nodes\\n    temp = head->next;\\n    Node* t = head;\\n    while (temp) {\\n        if (t->random) // If the original node\\'s random pointer exists\\n            temp->random = t->random->next; // Update the new node\\'s random pointer to point to the corresponding new node\\n        else\\n            temp->random = t->random; // If the original node\\'s random pointer is nullptr, set the new node\\'s random pointer to nullptr\\n\\n        if (!temp->next) {\\n            break;\\n        }\\n        t = t->next->next;\\n        temp = temp->next->next;\\n    }\\n\\n    // Phase 3: Separate the original list and the copied list\\n    Node* head2 = head->next; // The head of the copied list\\n    temp = head->next;\\n    t = head;\\n    while (temp->next) {\\n        t->next = t->next->next; // Update the \"next\" pointer of the original list to skip the copied nodes\\n        temp->next = temp->next->next; // Update the \"next\" pointer of the copied list to skip the original nodes\\n        temp = temp->next;\\n        t = t->next;\\n    }\\n\\n    t->next = NULL; // Set the last node\\'s \"next\" pointer to nullptr to terminate the copied list\\n\\n    return head2; // Return the head of the copied list\\n}\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2331483,
                "title": "c-solution-o-1-space-compexitiy-visualised-beats-100",
                "content": "At beggining our linked list should look like this!\\n![image](https://assets.leetcode.com/users/images/78ef59a6-ebe8-47c8-b5b0-f99d52d4e833_1658746955.8413064.png)\\n\\nIn first pass we will create and insert copy of every element between that element and his next element, so copy of first element we will insert between 1st and 2nd, copy of 2nd element we will insert between 2nd and 3rd...\\nAfter first pass our linked List should look like this (red nodes are copies)\\n![image](https://assets.leetcode.com/users/images/27c82699-4072-487a-9fe8-3d1f71a650a9_1658746936.6524725.png)\\n\\nIn second pass we will link our copies to their random nodes, when we insert all copies we can easily access them because we see that \\ncopy->random = real->random->next, and copy we can get because copy = real->next, after that our list should look like this\\n![image](https://assets.leetcode.com/users/images/7cf85f9d-86df-4e85-9fe4-3618ae69bf05_1658747506.1802163.png)\\n\\nIn final third pass we should extract copy nodes from list and made the first list to look like it was before.\\n\\nNow lets see code\\n```\\nstruct Node* copyRandomList(struct Node* head) {\\n\\tstruct Node *newHead = NULL;\\n    struct Node *tail = NULL;\\n    struct Node *curr;\\n    \\n    for (curr = head; curr; curr = curr->next->next){\\n        struct Node *new = malloc(sizeof(struct Node));\\n        new->next = curr->next;\\n        new->val = curr->val;\\n        curr->next = new;\\n    }\\n    \\n    for (curr = head; curr; curr = curr->next->next){\\n        if (curr->random == NULL){\\n            curr->next->random = NULL;\\n        } else {\\n            curr->next->random = curr->random->next;\\n        }\\n    }\\n    \\n    curr = head;\\n    \\n    while (curr){\\n        struct Node *newList = curr->next;\\n        curr->next = newList->next;\\n        newList->next = NULL;\\n        if (!newHead){\\n            newHead = newList;\\n        } else {\\n            tail->next = newList;\\n        }\\n        tail = newList;\\n        curr = curr->next;\\n    }\\n    \\n    \\n    return newHead;\\n    \\n}\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nstruct Node* copyRandomList(struct Node* head) {\\n\\tstruct Node *newHead = NULL;\\n    struct Node *tail = NULL;\\n    struct Node *curr;\\n    \\n    for (curr = head; curr; curr = curr->next->next){\\n        struct Node *new = malloc(sizeof(struct Node));\\n        new->next = curr->next;\\n        new->val = curr->val;\\n        curr->next = new;\\n    }\\n    \\n    for (curr = head; curr; curr = curr->next->next){\\n        if (curr->random == NULL){\\n            curr->next->random = NULL;\\n        } else {\\n            curr->next->random = curr->random->next;\\n        }\\n    }\\n    \\n    curr = head;\\n    \\n    while (curr){\\n        struct Node *newList = curr->next;\\n        curr->next = newList->next;\\n        newList->next = NULL;\\n        if (!newHead){\\n            newHead = newList;\\n        } else {\\n            tail->next = newList;\\n        }\\n        tail = newList;\\n        curr = curr->next;\\n    }\\n    \\n    \\n    return newHead;\\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2128946,
                "title": "simple-js-solution-w-comments-iterative",
                "content": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 78 ms, faster than 61.33% of JavaScript online submissions for Copy List with Random Pointer.\\n// Memory Usage: 43.6 MB, less than 93.23% of JavaScript online submissions for Copy List with Random Pointer.\\nconst copyRandomList = head => {\\n\\tif (!head) return head;\\n\\n\\tconst map = new Map(); // node: copy of code\\n\\tlet current = head;\\n\\n\\t// iterate LL and create map of each node and its copy\\n\\twhile (current) {\\n\\t\\tconst copy = new Node(current.val);\\n\\n\\t\\tmap.set(current, copy);\\n\\t\\tcurrent = current.next;\\n\\t}\\n\\n\\tcurrent = head; // start iterating from start of LL\\n\\n\\t// go through LL and make a LL of new copied nodes\\n\\twhile (current) {\\n\\t\\tconst copy = map.get(current);\\n\\n\\t\\t// if node exist add to pointer otherwise end of LL\\n\\t\\tcopy.next = map.get(current.next) || null; \\n\\t\\tcopy.random = map.get(current.random) || null; \\n\\n\\t\\tcurrent = current.next;\\n\\t}\\n\\n\\t// return head of copied node\\n\\treturn map.get(head);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * *Time: O(N)\\n * *Space: O(N)\\n */\\n// Runtime: 78 ms, faster than 61.33% of JavaScript online submissions for Copy List with Random Pointer.\\n// Memory Usage: 43.6 MB, less than 93.23% of JavaScript online submissions for Copy List with Random Pointer.\\nconst copyRandomList = head => {\\n\\tif (!head) return head;\\n\\n\\tconst map = new Map(); // node: copy of code\\n\\tlet current = head;\\n\\n\\t// iterate LL and create map of each node and its copy\\n\\twhile (current) {\\n\\t\\tconst copy = new Node(current.val);\\n\\n\\t\\tmap.set(current, copy);\\n\\t\\tcurrent = current.next;\\n\\t}\\n\\n\\tcurrent = head; // start iterating from start of LL\\n\\n\\t// go through LL and make a LL of new copied nodes\\n\\twhile (current) {\\n\\t\\tconst copy = map.get(current);\\n\\n\\t\\t// if node exist add to pointer otherwise end of LL\\n\\t\\tcopy.next = map.get(current.next) || null; \\n\\t\\tcopy.random = map.get(current.random) || null; \\n\\n\\t\\tcurrent = current.next;\\n\\t}\\n\\n\\t// return head of copied node\\n\\treturn map.get(head);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1843243,
                "title": "c-solution-o-n-space-explanation-with-diagram-easy-to-understand",
                "content": "**Problem**\\n\\nWe have given a linked list having signature :\\n\\n\\tclass Node {\\n\\tpublic:\\n\\t\\tint val;\\n\\t\\tNode* next;\\n\\t\\tNode* random;\\n\\n\\t\\tNode(int _val) {\\n\\t\\t\\tval = _val;\\n\\t\\t\\tnext = NULL;\\n\\t\\t\\trandom = NULL;\\n\\t\\t}\\n\\t};\\nAnd we have to **return a copy** of this list such that the random pointer of each copied node **points to copy** of random node in given list.\\n\\n\\n**Approach**\\n\\nFor easier understanding lets divide solution into 3 steps -\\n* **Coupling** - existing list and newly created nodes\\n* **Assigning Random Nodes** - assigning random nodes to new nodes\\n* **Decoupling** - breaking list into original and newly created list\\n\\n**Step 1-**\\n\\n![image](https://assets.leetcode.com/users/images/3c95d09f-f89a-4d20-b488-b6efc48e7318_1647107092.677427.gif)\\n\\nCoupled list - 7 -> **7** -> 13 -> **13** ->11 -> **11** -> 10 ->**10** -> 1 ->**1**  -> NULL\\n(Highlighted nodes are copied node we just created)\\n\\n**Why create coupled list ?**\\n* For assigning random node to copies we need to know copy of random orginal node.\\n* For this conventionally we use extra space but with coupled representation copied node has become next node so we can access it by using next pointer. \\n\\n\\n**Step 2-**\\n![image](https://assets.leetcode.com/users/images/931830c1-2aa3-451a-b31e-26420061aff6_1647160443.1398268.gif)\\n\\nNow random pointer of every node is assigned, now we just have to break 2 list and return the copied one.  \\n\\n**Step 3- Decoupling**\\n\\nSince we have already seen coupling , decoupling becomes very easy.\\nSee the code once and you will get it.\\n\\nTip - be sure to restore given list to its original state otherwise, leetcode compiler gives a weird  error.\\n![image](https://assets.leetcode.com/users/images/dfe6cae8-ba72-4eda-b7ea-c70ed0e1648e_1647108230.505617.png)\\n\\n**Code -**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    Node* copyRandomList(Node* head)\\n    {\\n        if(!head)return NULL;\\n        Node * temp = head;\\n        \\n\\t\\t// Coupling\\n        while(temp)\\n        {\\n            Node *node = new Node(temp->val);\\n            node->next = temp->next;\\n            temp->next = node;\\n            temp = node->next;\\n        }\\n        \\n\\t\\t// Assigning random nodes\\n        temp = head;\\n        while(temp)\\n        {\\n            temp->next->random = temp->random?temp->random->next:NULL;\\n            temp = temp->next->next;\\n        }\\n\\t\\t\\n\\t\\t//decoupling        \\n        Node *ans = head->next;\\n        temp = head->next;\\n       \\n        while(head)\\n        {\\n            head->next=temp->next;\\n            head=head->next;\\n            if(!head)break;\\n            temp->next=head->next;\\n            temp=temp->next;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Upvote this post if it helps u, feel free to ask any doubt\\nSee u in another post, Untill then TATAKAE :)**\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    Node* copyRandomList(Node* head)\\n    {\\n        if(!head)return NULL;\\n        Node * temp = head;\\n        \\n\\t\\t// Coupling\\n        while(temp)\\n        {\\n            Node *node = new Node(temp->val);\\n            node->next = temp->next;\\n            temp->next = node;\\n            temp = node->next;\\n        }\\n        \\n\\t\\t// Assigning random nodes\\n        temp = head;\\n        while(temp)\\n        {\\n            temp->next->random = temp->random?temp->random->next:NULL;\\n            temp = temp->next->next;\\n        }\\n\\t\\t\\n\\t\\t//decoupling        \\n        Node *ans = head->next;\\n        temp = head->next;\\n       \\n        while(head)\\n        {\\n            head->next=temp->next;\\n            head=head->next;\\n            if(!head)break;\\n            temp->next=head->next;\\n            temp=temp->next;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842579,
                "title": "python-with-without-hashmap-simple-elegant-solutions-with-explanation",
                "content": "## Solution1 (Simple Solution)\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n        \\n        # Copy linked list without random pointer and save the original node with its corresponding copied node in hashmap to update its random pointer further.\\n        hashmap = {}\\n        copiedList = Node(head.val)\\n        hashmap[head] = copiedList\\n        node = copiedList\\n        while head.next:\\n            head = head.next\\n            node.next = Node(head.val)\\n            node = node.next\\n            hashmap[head] = node\\n        \\n        # Update random pointer of each node\\n        for node, copiedNode in hashmap.items():\\n            if node.random:\\n                copiedNode.random = hashmap[node.random]\\n        \\n        return copiedList\\n```\\n\\n## Solution2 (Elegant Solution)\\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n        \\n        # Add the copied node without random pointer just after its corresponding original node.\\n        node = head\\n        while node:\\n            copiedNode = Node(node.val, node.next)\\n            node.next = copiedNode\\n            node = copiedNode.next\\n        \\n        \"\"\"\\n            Update the random pointer of each copied node by using the below logic-\\n                Let\\'s say the copied node is c_node and it\\'s original node is o_node then the random pointer of c_node would be the next node of random pointer of o_node because we have placed each copied node just after it\\'s original node. \\n        \"\"\"\\n        node = head\\n        while node:\\n            copiedNode = node.next\\n            if node.random:\\n                copiedNode.random = node.random.next\\n            node = copiedNode.next\\n        \\n        # Now just remove the original nodes from the list and return the remaining list as the remaining nodes of the list would make the deep copied list of original list.\\n        copiedHead = head.next\\n        node = head\\n        while node:\\n            copiedNode = node.next\\n            node.next = copiedNode.next\\n            node = node.next\\n            if copiedNode.next:\\n                copiedNode.next = copiedNode.next.next\\n                copiedNode = copiedNode.next\\n        return copiedHead\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n        \\n        # Copy linked list without random pointer and save the original node with its corresponding copied node in hashmap to update its random pointer further.\\n        hashmap = {}\\n        copiedList = Node(head.val)\\n        hashmap[head] = copiedList\\n        node = copiedList\\n        while head.next:\\n            head = head.next\\n            node.next = Node(head.val)\\n            node = node.next\\n            hashmap[head] = node\\n        \\n        # Update random pointer of each node\\n        for node, copiedNode in hashmap.items():\\n            if node.random:\\n                copiedNode.random = hashmap[node.random]\\n        \\n        return copiedList\\n```\n```\\n\"\"\"\\n# Definition for a Node.\\nclass Node:\\n    def __init__(self, x: int, next: \\'Node\\' = None, random: \\'Node\\' = None):\\n        self.val = int(x)\\n        self.next = next\\n        self.random = random\\n\"\"\"\\n\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        if not head:\\n            return None\\n        \\n        # Add the copied node without random pointer just after its corresponding original node.\\n        node = head\\n        while node:\\n            copiedNode = Node(node.val, node.next)\\n            node.next = copiedNode\\n            node = copiedNode.next\\n        \\n        \"\"\"\\n            Update the random pointer of each copied node by using the below logic-\\n                Let\\'s say the copied node is c_node and it\\'s original node is o_node then the random pointer of c_node would be the next node of random pointer of o_node because we have placed each copied node just after it\\'s original node. \\n        \"\"\"\\n        node = head\\n        while node:\\n            copiedNode = node.next\\n            if node.random:\\n                copiedNode.random = node.random.next\\n            node = copiedNode.next\\n        \\n        # Now just remove the original nodes from the list and return the remaining list as the remaining nodes of the list would make the deep copied list of original list.\\n        copiedHead = head.next\\n        node = head\\n        while node:\\n            copiedNode = node.next\\n            node.next = copiedNode.next\\n            node = node.next\\n            if copiedNode.next:\\n                copiedNode.next = copiedNode.next.next\\n                copiedNode = copiedNode.next\\n        return copiedHead\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842118,
                "title": "clone-node-linked-list-with-random-pointer-hashmap",
                "content": "Hi,\\n\\nCloning linked list with random pointer looked like a complex question, as this kindly of random pointer first time for me.\\n\\nSo first thing that came to my mind is use some mapping techinque to store the node with new node.\\nI went blind with that step, but after completing this step I approached by making some change to those nodes in the hashmap and returned the head value from the hashmap.\\n\\n```\\npublic Node copyRandomList(Node head) {\\n    \\tif(head==null)\\n    \\t\\treturn head;\\n    \\tHashMap<Node, Node> map = new HashMap<Node, Node>();\\n    \\tNode curr = head;\\n    \\twhile(curr!=null){\\n    \\t\\tmap.put(curr, new Node(curr.val));\\n    \\t\\tcurr = curr.next;\\n    \\t}\\n        curr = head;\\n    \\twhile(curr!=null){\\n            Node one = map.get(curr);\\n    \\t\\tone.next = map.get(curr.next);\\n    \\t\\tone.random = map.get(curr.random);\\n            map.put(curr, one);\\n    \\t\\tcurr = curr.next;\\n    \\t}\\n    \\treturn map.get(head);\\n    }\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hi,\\n\\nCloning linked list with random pointer looked like a complex question, as this kindly of random pointer first time for me.\\n\\nSo first thing that came to my mind is use some mapping techinque to store the node with new node.\\nI went blind with that step, but after completing this step I approached by making some change to those nodes in the hashmap and returned the head value from the hashmap.\\n\\n```\\npublic Node copyRandomList(Node head) {\\n    \\tif(head==null)\\n    \\t\\treturn head;\\n    \\tHashMap<Node, Node> map = new HashMap<Node, Node>();\\n    \\tNode curr = head;\\n    \\twhile(curr!=null){\\n    \\t\\tmap.put(curr, new Node(curr.val));\\n    \\t\\tcurr = curr.next;\\n    \\t}\\n        curr = head;\\n    \\twhile(curr!=null){\\n            Node one = map.get(curr);\\n    \\t\\tone.next = map.get(curr.next);\\n    \\t\\tone.random = map.get(curr.random);\\n            map.put(curr, one);\\n    \\t\\tcurr = curr.next;\\n    \\t}\\n    \\treturn map.get(head);\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1841755,
                "title": "python-go-3-different-solutions-and-explanations",
                "content": "**\\uD83D\\uDC46Please UPVOTE it if you find my soulutions are useful \\uD83D\\uDC46 Feel free to ask any question**\\n# [Python/Go] \\uD83C\\uDF1F 3 Different Solutions and Explanations \\uD83D\\uDC95\\n\\n## 1\\uFE0F\\u20E3 DFS  Approach O(N)|O(N):\\n1. Create a hashmap, that will render our original node to copy node.\\n2. DFS CALL\\n\\t* **Base Case**: If node is None return None, If node in hashMap, return its copy node\\n\\t* **Create a copy** of current node, and store it in hashMap.\\n\\t* DFS clone its next and random\\n\\t* return current node\\n3. return DFS(head)\\n## Complexity Analysis\\n* Time: O(N): Traverse random and next takes O(2N) => O(N)\\n* Space: O(N): The dfs call and graphHash both take O(N)\\n## DFS Code\\n**Python**\\n```python\\n# DFS O(N) | O(N)\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        # Create a hashmap to tell us whether we clone this node\\n        oldToCopy = {} #Original -> Copy\\n        \\n        # Using dfs to traverse node, and make copy of it\\n        def dfs(node):\\n            # Base cases\\n            if node is None:\\n                return node\\n            if node in oldToCopy:\\n                return oldToCopy[node]\\n            # Create a copy of current node\\n            copyNode = Node(node.val)\\n            oldToCopy[node] = copyNode\\n            # DFS clone node\\'s next and random\\n            copyNode.next = dfs(node.next)\\n            copyNode.random = dfs(node.random)\\n            \\n            return copyNode\\n        \\n        return dfs(head)\\n```\\n**Go**\\n```go\\n// DFS O(N) | O(N)\\nfunc copyRandomList(head *Node) *Node {\\n    oldToCopy := make(map[*Node]*Node)\\n    var dfs func (old *Node) *Node\\n    dfs = func (old *Node) *Node{\\n        // Base Cases\\n        if old == nil{\\n            return nil \\n        }\\n        if _, found := oldToCopy[old]; found{\\n            return oldToCopy[old]\\n        }\\n        // Create a copy of current node\\n        copyNode := Node{old.Val, nil, nil}\\n        oldToCopy[old] = &copyNode\\n        // DFS clone node\\'s next and random\\n        copyNode.Next = dfs(old.Next)\\n        copyNode.Random = dfs(old.Random)\\n        \\n        return &copyNode\\n    }\\n    \\n    return dfs(head)\\n}\\n```\\n## 2\\uFE0F\\u20E3 Iterative Approach O(N)|O(N):\\n1. Create a hashmap, that will render our original node to copy node.\\n2. Create all clone node but not connected\\n3. Make all connection through hashMap\\n## Complexity Analysis\\n* Time: O(N): Traverse through all nodes and create clone take O(N). Make all connection take O(N) => O(N)\\n* Space: O(N): The oldToCopy hashMap store O(N)\\n## Iterative Code\\n**Python**\\n```python\\n# Iterative O(N) | O(N)\\nclass Solution:\\n    def copyRandomList(self, head):\\n        oldToCopy = {None:None}\\n        curr = head\\n        # Creat all nodes but not connect\\n        while curr:\\n            copy = Node(curr.val)\\n            oldToCopy[curr] = copy\\n            curr = curr.next\\n        curr = head\\n        # Make all connection through hashMap\\n        while curr:\\n            copy = oldToCopy[curr]\\n            copy.next = oldToCopy[curr.next]\\n            copy.random = oldToCopy[curr.random]\\n            curr = curr.next\\n            \\n        return oldToCopy[head]\\n```\\n**Go**\\n```go\\n// Iterative O(N) | O(N)\\nfunc copyRandomList(head *Node) *Node {\\n    oldToCopy := make(map[*Node]*Node)\\n    oldToCopy[nil] = nil\\n    curr := head\\n    // Creat all nodes but not connected\\n    for curr != nil{\\n        copyNode := Node{curr.Val, nil, nil}\\n        oldToCopy[curr] = &copyNode\\n        curr = curr.Next\\n    }\\n    curr = head\\n    // Make all connection through hashMap\\n    for curr != nil{\\n        copyNode := oldToCopy[curr]\\n        copyNode.Next = oldToCopy[curr.Next]\\n        copyNode.Random = oldToCopy[curr.Random]\\n        curr = curr.Next\\n    }\\n    \\n    return oldToCopy[head]\\n}\\n```\\n\\n## 3\\uFE0F\\u20E3 Iterative Weaved List Approach O(N)|O(1):\\nInstead of a separate hashmap to keep the old node to its clone node, we can tweak the original linked list and keep every cloned node be next to its original node.\\nFor example : ```original : A->B->C->D``` we can simpliy clone and expand the original list to ```A -> A\\' -> B -> B\\' -> C-> C\\' -> D -> D\\'``` where n\\' indicate its clone node.\\nNow we create all clone nodes, let\\'s make all clone nodes connected to its connection\\n**Random**: copy.random = old.random.next\\n**Next**:  copy.next = copy.nex.next\\n\\n**Algo**\\n1. Create weaved list.   ```A -> B-> C-> D``` to  ```A -> A\\' -> B -> B\\' -> C-> C\\' -> D -> D\\'```\\n2. Connect random.  ```copy.random = old.random.next if old.random else None```\\n3. Connect next and Unweaved list.\\n\\t* ```copy.next = nextOld.next if nextOld else None``` to connect clone node to its next clone node\\n\\t* ```old.next = nextOld``` to restore original connections\\n\\n## Complexity Analysis\\n* Time: O(N):\\n* Space: O(N) -> O(1):\\n## Iterative Weaved List Code\\n**Python**\\n```python\\n# Iterative Weaved List O(N) | O(1)\\nclass Solution:\\n    def copyRandomList(self, head):\\n        curr = head\\n        \\n        # Create weaved list, no connection\\n        while curr:\\n            copy = Node(curr.val, curr.next)\\n            curr.next = copy\\n            curr = copy.next\\n        old = head\\n        \\n        # Connect random\\n        while old:\\n            copy = old.next\\n            copy.random = old.random.next if old.random else None\\n            old = copy.next\\n        cloneHead = head.next if head else None\\n        \\n        # Connect next and Unweaved list\\n        old = head\\n        while old:\\n            copy = old.next\\n            nextOld = copy.next\\n            copy.next = nextOld.next if nextOld else None\\n            old.next = nextOld\\n            old = old.next\\n\\n        return cloneHead\\n```\\n**Go**\\n```go\\n// Iterative Weaved List O(N) | O(1)\\nfunc copyRandomList(head *Node) *Node {\\n    curr := head\\n    // Create weaved list, no connection\\n    for curr != nil{\\n        curr, curr.Next =curr.Next, &Node{Val:curr.Val, Next:curr.Next, }\\n    }\\n    \\n    old := head\\n    // Connect random\\n    for old != nil{\\n        copyNode := old.Next\\n        copyNode.Random = nil\\n        if old.Random != nil{\\n            copyNode.Random = old.Random.Next\\n        }\\n        old = copyNode.Next \\n    }\\n    \\n    // Connect next and Unweaved list\\n    var newHead *Node\\n    if head != nil{\\n        newHead = head.Next\\n    }\\n    old = head\\n    for old != nil{\\n        copyNode := old.Next\\n        oldNext := copyNode.Next\\n        copyNode.Next = nil\\n        if oldNext != nil{\\n            copyNode.Next = oldNext.Next\\n        }\\n        old.Next = oldNext\\n        old = old.Next\\n    }\\n    return newHead\\n}\\n```\\n* See more 2022 Daily Challenge Solution : [GitHub](https://github.com/gcobs0834/2022-Daily-LeetCoding-Challenge-python3-)",
                "solutionTags": [
                    "Python",
                    "Go"
                ],
                "code": "```python\\n# DFS O(N) | O(N)\\nclass Solution:\\n    def copyRandomList(self, head: \\'Optional[Node]\\') -> \\'Optional[Node]\\':\\n        # Create a hashmap to tell us whether we clone this node\\n        oldToCopy = {} #Original -> Copy\\n        \\n        # Using dfs to traverse node, and make copy of it\\n        def dfs(node):\\n            # Base cases\\n            if node is None:\\n                return node\\n            if node in oldToCopy:\\n                return oldToCopy[node]\\n            # Create a copy of current node\\n            copyNode = Node(node.val)\\n            oldToCopy[node] = copyNode\\n            # DFS clone node\\'s next and random\\n            copyNode.next = dfs(node.next)\\n            copyNode.random = dfs(node.random)\\n            \\n            return copyNode\\n        \\n        return dfs(head)\\n```\n```go\\n// DFS O(N) | O(N)\\nfunc copyRandomList(head *Node) *Node {\\n    oldToCopy := make(map[*Node]*Node)\\n    var dfs func (old *Node) *Node\\n    dfs = func (old *Node) *Node{\\n        // Base Cases\\n        if old == nil{\\n            return nil \\n        }\\n        if _, found := oldToCopy[old]; found{\\n            return oldToCopy[old]\\n        }\\n        // Create a copy of current node\\n        copyNode := Node{old.Val, nil, nil}\\n        oldToCopy[old] = &copyNode\\n        // DFS clone node\\'s next and random\\n        copyNode.Next = dfs(old.Next)\\n        copyNode.Random = dfs(old.Random)\\n        \\n        return &copyNode\\n    }\\n    \\n    return dfs(head)\\n}\\n```\n```python\\n# Iterative O(N) | O(N)\\nclass Solution:\\n    def copyRandomList(self, head):\\n        oldToCopy = {None:None}\\n        curr = head\\n        # Creat all nodes but not connect\\n        while curr:\\n            copy = Node(curr.val)\\n            oldToCopy[curr] = copy\\n            curr = curr.next\\n        curr = head\\n        # Make all connection through hashMap\\n        while curr:\\n            copy = oldToCopy[curr]\\n            copy.next = oldToCopy[curr.next]\\n            copy.random = oldToCopy[curr.random]\\n            curr = curr.next\\n            \\n        return oldToCopy[head]\\n```\n```go\\n// Iterative O(N) | O(N)\\nfunc copyRandomList(head *Node) *Node {\\n    oldToCopy := make(map[*Node]*Node)\\n    oldToCopy[nil] = nil\\n    curr := head\\n    // Creat all nodes but not connected\\n    for curr != nil{\\n        copyNode := Node{curr.Val, nil, nil}\\n        oldToCopy[curr] = &copyNode\\n        curr = curr.Next\\n    }\\n    curr = head\\n    // Make all connection through hashMap\\n    for curr != nil{\\n        copyNode := oldToCopy[curr]\\n        copyNode.Next = oldToCopy[curr.Next]\\n        copyNode.Random = oldToCopy[curr.Random]\\n        curr = curr.Next\\n    }\\n    \\n    return oldToCopy[head]\\n}\\n```\n```original : A->B->C->D```\n```A -> A\\' -> B -> B\\' -> C-> C\\' -> D -> D\\'```\n```A -> B-> C-> D```\n```A -> A\\' -> B -> B\\' -> C-> C\\' -> D -> D\\'```\n```copy.random = old.random.next if old.random else None```\n```copy.next = nextOld.next if nextOld else None```\n```old.next = nextOld```\n```python\\n# Iterative Weaved List O(N) | O(1)\\nclass Solution:\\n    def copyRandomList(self, head):\\n        curr = head\\n        \\n        # Create weaved list, no connection\\n        while curr:\\n            copy = Node(curr.val, curr.next)\\n            curr.next = copy\\n            curr = copy.next\\n        old = head\\n        \\n        # Connect random\\n        while old:\\n            copy = old.next\\n            copy.random = old.random.next if old.random else None\\n            old = copy.next\\n        cloneHead = head.next if head else None\\n        \\n        # Connect next and Unweaved list\\n        old = head\\n        while old:\\n            copy = old.next\\n            nextOld = copy.next\\n            copy.next = nextOld.next if nextOld else None\\n            old.next = nextOld\\n            old = old.next\\n\\n        return cloneHead\\n```\n```go\\n// Iterative Weaved List O(N) | O(1)\\nfunc copyRandomList(head *Node) *Node {\\n    curr := head\\n    // Create weaved list, no connection\\n    for curr != nil{\\n        curr, curr.Next =curr.Next, &Node{Val:curr.Val, Next:curr.Next, }\\n    }\\n    \\n    old := head\\n    // Connect random\\n    for old != nil{\\n        copyNode := old.Next\\n        copyNode.Random = nil\\n        if old.Random != nil{\\n            copyNode.Random = old.Random.Next\\n        }\\n        old = copyNode.Next \\n    }\\n    \\n    // Connect next and Unweaved list\\n    var newHead *Node\\n    if head != nil{\\n        newHead = head.Next\\n    }\\n    old = head\\n    for old != nil{\\n        copyNode := old.Next\\n        oldNext := copyNode.Next\\n        copyNode.Next = nil\\n        if oldNext != nil{\\n            copyNode.Next = oldNext.Next\\n        }\\n        old.Next = oldNext\\n        old = old.Next\\n    }\\n    return newHead\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841321,
                "title": "138-copy-list-with-random-pointer",
                "content": "![image](https://assets.leetcode.com/users/images/e7b4451b-b044-45dc-8c9c-3425cd4ef366_1647058612.6356645.jpeg)\\n![image](https://assets.leetcode.com/users/images/276801c2-ff9c-43b7-bb04-51c1e93dedf0_1647058637.7747352.jpeg)\\n![image](https://assets.leetcode.com/users/images/51b59d6e-2b90-4c68-a2e7-4a3a3b44e350_1647058650.3850918.jpeg)``\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n            if(head==NULL)\\n                    return head;\\n     unordered_map<Node*,Node*>mp;\\n            Node* curr=head;\\n            Node* newhead=NULL;\\n            Node* newtail=NULL;\\n            while(curr)\\n            {\\n                    Node* temp=new Node(curr->val);\\n                    if(newhead==NULL)\\n                    {\\n                            newhead=temp;\\n                            newtail=temp;\\n                    }\\n                    else\\n                    {\\n                            newtail->next=temp;\\n                            newtail=newtail->next;\\n                    }\\n                    mp[curr]=temp;\\n                    curr=curr->next;\\n            }\\n            curr=newhead;\\n            Node*temp=head;\\n            while(curr)\\n            {\\n                    Node* nxt=mp[temp->random];\\n                    curr->random=nxt;\\n                    curr=curr->next;\\n                    temp=temp->next;\\n            }\\n            return newhead;\\n    }\\n};\\n``\\n***if you like plzzzz upvote***`",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n            if(head==NULL)\\n                    return head;\\n     unordered_map<Node*,Node*>mp;\\n            Node* curr=head;\\n            Node* newhead=NULL;\\n            Node* newtail=NULL;\\n            while(curr)\\n            {\\n                    Node* temp=new Node(curr->val);\\n                    if(newhead==NULL)\\n                    {\\n                            newhead=temp;\\n                            newtail=temp;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1730244,
                "title": "o-n-time-and-o-1-space-complexity",
                "content": "This diagram may help in better understanding of the solution. The arrows represented in red are the random pointers and the arrows in black are the next pointers of respective nodes.\\n![image](https://assets.leetcode.com/users/images/d32c3e29-6b98-4a6c-b789-485afdcf1510_1643515655.2651782.png)\\n\\nAfter this formation we seperate the nodes and make a new linked list and return the head of the newly created linkedl list.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return NULL;\\n        Node* temp = head;\\n        while(temp){\\n            Node* node = new Node(temp->val);      // create a new node with val as temp->val;\\n            node->next = temp->next;               // insert that node\\n            temp->next = node;                     // in between temp and temp->next;\\n            temp = temp->next->next;\\n        }\\n        \\n        temp = head;\\n        while(temp){\\n            if(temp->random and temp->random->next) temp->next->random = temp->random->next;   // now the value temp->next->random will be mapped to temp->random->next;\\n            temp = temp->next->next;                                                           // this is the mapping of our random pointer;\\n        }\\n        \\n        // create a new list by seperating the older list;\\n        Node* curr = head;\\n        Node* newhead = NULL;\\n        Node* newList = NULL;\\n        while(curr){\\n            Node *next = curr->next;\\n            if(!newhead){\\n                newhead = next;\\n                newList = newhead;\\n            }\\n            else{\\n                newList->next = next;       \\n                newList = newList->next;\\n            }\\n            curr->next = next->next;\\n            curr = next->next;\\n        }\\n        return newhead;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if(!head) return NULL;\\n        Node* temp = head;\\n        while(temp){\\n            Node* node = new Node(temp->val);      // create a new node with val as temp->val;\\n            node->next = temp->next;               // insert that node\\n            temp->next = node;                     // in between temp and temp->next;\\n            temp = temp->next->next;\\n        }\\n        \\n        temp = head;\\n        while(temp){\\n            if(temp->random and temp->random->next) temp->next->random = temp->random->next;   // now the value temp->next->random will be mapped to temp->random->next;\\n            temp = temp->next->next;                                                           // this is the mapping of our random pointer;\\n        }\\n        \\n        // create a new list by seperating the older list;\\n        Node* curr = head;\\n        Node* newhead = NULL;\\n        Node* newList = NULL;\\n        while(curr){\\n            Node *next = curr->next;\\n            if(!newhead){\\n                newhead = next;\\n                newList = newhead;\\n            }\\n            else{\\n                newList->next = next;       \\n                newList = newList->next;\\n            }\\n            curr->next = next->next;\\n            curr = next->next;\\n        }\\n        return newhead;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1702032,
                "title": "java-sc-o-n-tc-o-n",
                "content": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        HashMap<Node, Node> hm = new HashMap<>();\\n        return copyRandomList(head, hm);\\n    }\\n    \\n    public Node copyRandomList(Node head, HashMap<Node, Node> hm){\\n        if(head == null) return null; \\n        Node newHead = new Node(head.val);\\n        \\n        hm.put(head, newHead);\\n        \\n        newHead.next = copyRandomList(head.next, hm);\\n        newHead.random = hm.get(head.random);           \\n        return newHead;\\n    }\\n}\\n```\\n\\nPlease upvote if you like my solution.",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        HashMap<Node, Node> hm = new HashMap<>();\\n        return copyRandomList(head, hm);\\n    }\\n    \\n    public Node copyRandomList(Node head, HashMap<Node, Node> hm){\\n        if(head == null) return null; \\n        Node newHead = new Node(head.val);\\n        \\n        hm.put(head, newHead);\\n        \\n        newHead.next = copyRandomList(head.next, hm);\\n        newHead.random = hm.get(head.random);           \\n        return newHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662032,
                "title": "simple-one-in-java-and-c",
                "content": "**Java**\\n```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        \\n        // First Step: \\n        // Adding extra nodes in middle of linkedlist\\n        if (head == null) return null;\\n        Node curr = head;\\n        while (curr != null) {\\n            Node forw = new Node(curr.val);\\n            Node temp = curr.next;\\n            curr.next = forw;\\n            forw.next = temp;\\n            curr = temp;\\n        }\\n        \\n        // Second step:\\n        // setting up random pointers of our clone linkedlist\\n        curr = head;\\n        while (curr != null) {\\n            curr.next.random = curr.random != null ? curr.random.next : null;\\n            curr = curr.next != null ? curr.next.next : null;\\n        }\\n        \\n        // Third Step:\\n        // saperating original and clone linkedlist\\n        Node original = head;\\n        Node clone = head.next;\\n        Node ans = clone;\\n        while (original != null && clone != null) {\\n            original.next = original.next != null ? original.next.next : null;\\n            clone.next = clone.next != null ? clone.next.next : null;\\n            \\n            original = original.next;\\n            clone = clone.next;\\n        }\\n        \\n        // return deep copy (clone list)\\n        return ans;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL)\\n            return NULL;\\n        Node* curr = head;\\n        Node* temp = nullptr;\\n        while (curr != NULL) {\\n            Node* forw = new Node(curr->val);\\n            temp = curr->next;\\n            curr->next = forw;\\n            forw->next = temp;\\n            curr = temp;\\n        }\\n        curr = head;\\n        while (curr != nullptr) {\\n            curr->next->random = curr->random != nullptr ? curr->random->next : nullptr;\\n            curr = curr->next != nullptr ? curr->next->next : nullptr;\\n        }\\n        Node* original = head;\\n        Node* clone = head->next;\\n        temp = clone;\\n        while (original != nullptr && clone != nullptr) {\\n            original->next = original->next != nullptr ? original->next->next : nullptr;\\n            clone->next = clone->next != nullptr ? clone->next->next : nullptr;\\n            \\n            clone = clone->next;\\n            original = original->next;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        \\n        // First Step: \\n        // Adding extra nodes in middle of linkedlist\\n        if (head == null) return null;\\n        Node curr = head;\\n        while (curr != null) {\\n            Node forw = new Node(curr.val);\\n            Node temp = curr.next;\\n            curr.next = forw;\\n            forw.next = temp;\\n            curr = temp;\\n        }\\n        \\n        // Second step:\\n        // setting up random pointers of our clone linkedlist\\n        curr = head;\\n        while (curr != null) {\\n            curr.next.random = curr.random != null ? curr.random.next : null;\\n            curr = curr.next != null ? curr.next.next : null;\\n        }\\n        \\n        // Third Step:\\n        // saperating original and clone linkedlist\\n        Node original = head;\\n        Node clone = head.next;\\n        Node ans = clone;\\n        while (original != null && clone != null) {\\n            original.next = original.next != null ? original.next.next : null;\\n            clone.next = clone.next != null ? clone.next.next : null;\\n            \\n            original = original.next;\\n            clone = clone.next;\\n        }\\n        \\n        // return deep copy (clone list)\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == NULL)\\n            return NULL;\\n        Node* curr = head;\\n        Node* temp = nullptr;\\n        while (curr != NULL) {\\n            Node* forw = new Node(curr->val);\\n            temp = curr->next;\\n            curr->next = forw;\\n            forw->next = temp;\\n            curr = temp;\\n        }\\n        curr = head;\\n        while (curr != nullptr) {\\n            curr->next->random = curr->random != nullptr ? curr->random->next : nullptr;\\n            curr = curr->next != nullptr ? curr->next->next : nullptr;\\n        }\\n        Node* original = head;\\n        Node* clone = head->next;\\n        temp = clone;\\n        while (original != nullptr && clone != nullptr) {\\n            original->next = original->next != nullptr ? original->next->next : nullptr;\\n            clone->next = clone->next != nullptr ? clone->next->next : nullptr;\\n            \\n            clone = clone->next;\\n            original = original->next;\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428603,
                "title": "2-clean-c-solutions-hashmap-only-pointers",
                "content": "#### BRUTEFORCE : USING HASHMAP TC=O(N) SC=O(N)\\n```\\n\\nNode* copyRandomList(Node* head) {\\n\\t\\n\\t//STEP 1 : STORE ALL THE NODES IN <NODE,NODE> MAP\\n    unordered_map<Node*,Node*> m;\\n    Node* iter = head;\\n    while(iter){\\n        Node* temp = new Node(iter->val);\\n        m[iter] = temp;\\n        iter = iter->next;\\n    }\\n    \\n    //STEP 2 : UPDATE THE NEXT AND RANDOM POINTERS ACCORDINGLY \\n    iter = head;\\n    while(iter){\\n        m[iter]->next = m[iter->next];\\n        m[iter]->random = m[iter->random];\\n        iter = iter->next;\\n    }\\n    \\n    return m[head];\\n}\\n\\n```\\n#### OPTIMIZED : TC=O(N) SC=O(1)\\nINTUITION : STEP 1 : CREATE A DEEP COPY OF THE LINKED LIST ON THE NEXT NODE OF THE CURRENT NODE TC=O(N)\\nSTEP 2 : MAKE SURE THAT THE RANDOM NODES ARE CONNECTED TC=O(N)\\nSTEP 3 : SEPARATE THE DEEP COPY NODES AND THE ORIGINAL NODES TC=O(N)\\n\\n```\\nNode* copyRandomList(Node* head) {\\n    Node* iter = head;\\n    Node* front = head;\\n    \\n    //Step 1 Code\\n    while(iter){\\n        front = iter->next;\\n        Node* copy = new Node(iter->val);\\n        copy->next = iter->next;\\n        iter->next = copy;\\n        iter = front;\\n    }\\n    \\n    //Step 2 Code\\n    iter = head;\\n    while(iter){\\n        if(iter->random){\\n            iter->next->random = iter->random->next;    \\n        }\\n        iter = iter->next->next;\\n    }\\n    \\n    //Step 3 Code\\n    iter = head;\\n    Node* dummy = new Node(0);\\n    Node* deepcopy = dummy;\\n    while(iter){\\n        front = iter->next->next;\\n        deepcopy->next = iter->next;\\n        iter->next = front;\\n        deepcopy = deepcopy->next;\\n        iter = front;\\n    }\\n    return dummy->next;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\nNode* copyRandomList(Node* head) {\\n\\t\\n\\t//STEP 1 : STORE ALL THE NODES IN <NODE,NODE> MAP\\n    unordered_map<Node*,Node*> m;\\n    Node* iter = head;\\n    while(iter){\\n        Node* temp = new Node(iter->val);\\n        m[iter] = temp;\\n        iter = iter->next;\\n    }\\n    \\n    //STEP 2 : UPDATE THE NEXT AND RANDOM POINTERS ACCORDINGLY \\n    iter = head;\\n    while(iter){\\n        m[iter]->next = m[iter->next];\\n        m[iter]->random = m[iter->random];\\n        iter = iter->next;\\n    }\\n    \\n    return m[head];\\n}\\n\\n```\n```\\nNode* copyRandomList(Node* head) {\\n    Node* iter = head;\\n    Node* front = head;\\n    \\n    //Step 1 Code\\n    while(iter){\\n        front = iter->next;\\n        Node* copy = new Node(iter->val);\\n        copy->next = iter->next;\\n        iter->next = copy;\\n        iter = front;\\n    }\\n    \\n    //Step 2 Code\\n    iter = head;\\n    while(iter){\\n        if(iter->random){\\n            iter->next->random = iter->random->next;    \\n        }\\n        iter = iter->next->next;\\n    }\\n    \\n    //Step 3 Code\\n    iter = head;\\n    Node* dummy = new Node(0);\\n    Node* deepcopy = dummy;\\n    while(iter){\\n        front = iter->next->next;\\n        deepcopy->next = iter->next;\\n        iter->next = front;\\n        deepcopy = deepcopy->next;\\n        iter = front;\\n    }\\n    return dummy->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1060194,
                "title": "easy-c-solution-using-hashmap-99-fast",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        map<Node *,Node *> check;\\n        Node *temp = head;\\n        while(head!=NULL){\\n            check[head]=new Node(head->val);\\n            head=head->next;\\n        }\\n        for(auto i:check){\\n            i.second->next=check[i.first->next];\\n            i.second->random = check[i.first->random];\\n        }\\n        return check[temp];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        map<Node *,Node *> check;\\n        Node *temp = head;\\n        while(head!=NULL){\\n            check[head]=new Node(head->val);\\n            head=head->next;\\n        }\\n        for(auto i:check){\\n            i.second->next=check[i.first->next];\\n            i.second->random = check[i.first->random];\\n        }\\n        return check[temp];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015320,
                "title": "java-10-lines-logic-0ms-runtime",
                "content": "1. We maintain a hashtable to map the corresponding nodes created for every node in the given list. \\n2. We update the next and random pointers using the hashtable we created in step 1. \\n```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        HashMap<Node, Node> ht = new HashMap<>();\\n        for(Node i = head; i != null; i = i.next) {\\n            ht.put(i, new Node(i.val));\\n        }\\n        for(Node i: ht.keySet()) {\\n            Node j = ht.get(i);\\n            j.next = ht.get(i.next);\\n            j.random = ht.get(i.random);\\n        }\\n        return ht.get(head);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        HashMap<Node, Node> ht = new HashMap<>();\\n        for(Node i = head; i != null; i = i.next) {\\n            ht.put(i, new Node(i.val));\\n        }\\n        for(Node i: ht.keySet()) {\\n            Node j = ht.get(i);\\n            j.next = ht.get(i.next);\\n            j.random = ht.get(i.random);\\n        }\\n        return ht.get(head);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930517,
                "title": "my-java-solution-using-map-extra-space",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n        Map<Node, Node> map = new HashMap<>();\\n        Node node = head;\\n        // copy every node\\n        while (node != null) {\\n            map.put(node, new Node(node.val));\\n            node = node.next;\\n        }\\n        // assign next and random pointers\\n        node = head;\\n        while (node != null) {\\n            map.get(node).next = map.get(node.next);\\n            map.get(node).random = map.get(node.random);\\n            node = node.next;\\n        }\\n        return map.get(head);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null)\\n            return null;\\n        Map<Node, Node> map = new HashMap<>();\\n        Node node = head;\\n        // copy every node\\n        while (node != null) {\\n            map.put(node, new Node(node.val));\\n            node = node.next;\\n        }\\n        // assign next and random pointers\\n        node = head;\\n        while (node != null) {\\n            map.get(node).next = map.get(node.next);\\n            map.get(node).random = map.get(node.random);\\n            node = node.next;\\n        }\\n        return map.get(head);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917438,
                "title": "super-easy-and-concise-c-implementation",
                "content": "~~~c++\\n/*\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == nullptr) {\\n            return head;\\n        }\\n        if (h.find(head) != h.end()) {\\n            return h[head];\\n        }\\n        Node* new_node = new Node(head->val);\\n        h[head] = new_node;\\n        h[head]->next = copyRandomList(head->next);   \\n        h[head]->random = copyRandomList(head->random);   \\n        return h[head];\\n    }\\nprivate:\\n    unordered_map<Node*, Node*> h;\\n};\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        if (head == nullptr) {\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 816572,
                "title": "java-100-0ms-with-explanation-different-from-given-solutions",
                "content": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        // O(n) solution using map\\n        // key: random pointer\\n        // value: original pointer\\n        Map<Node, Node> pseudoRandomMap = new HashMap<Node, Node>(); // used to deep copy the random nodes\\n        \\n        // first, deep copy the next pointers\\n        Node dummy = new Node(0);\\n        Node curr = head;\\n        Node currPrev = new Node(0);\\n        Node prev = dummy;\\n        while (curr != null) {\\n            prev.next = new Node(curr.val);\\n            prev.next.random = curr;\\n            \\n            // we temporarily set the random pointers of the cloned nodes\\n            // to the original node that is in the same relative position\\n            pseudoRandomMap.put(curr, prev.next);\\n            \\n            prev = prev.next;\\n            curr = curr.next;\\n        }\\n        \\n        // second, deep copy the randomPointers\\n        // curr and prev are the in the same relative position, so\\n        // curr.random and prev.random should be in the same relative position\\n        curr = head;\\n        prev = dummy.next;\\n        while (curr != null) {\\n            Node rand = curr.random;\\n            if (rand == null) {\\n                prev.random = null;\\n            } else {\\n                prev.random = pseudoRandomMap.get(rand);\\n            }\\n            curr = curr.next;\\n            prev = prev.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\\n\\nOpen to any suggesstions!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if (head == null) {\\n            return null;\\n        }\\n        // O(n) solution using map\\n        // key: random pointer\\n        // value: original pointer\\n        Map<Node, Node> pseudoRandomMap = new HashMap<Node, Node>(); // used to deep copy the random nodes\\n        \\n        // first, deep copy the next pointers\\n        Node dummy = new Node(0);\\n        Node curr = head;\\n        Node currPrev = new Node(0);\\n        Node prev = dummy;\\n        while (curr != null) {\\n            prev.next = new Node(curr.val);\\n            prev.next.random = curr;\\n            \\n            // we temporarily set the random pointers of the cloned nodes\\n            // to the original node that is in the same relative position\\n            pseudoRandomMap.put(curr, prev.next);\\n            \\n            prev = prev.next;\\n            curr = curr.next;\\n        }\\n        \\n        // second, deep copy the randomPointers\\n        // curr and prev are the in the same relative position, so\\n        // curr.random and prev.random should be in the same relative position\\n        curr = head;\\n        prev = dummy.next;\\n        while (curr != null) {\\n            Node rand = curr.random;\\n            if (rand == null) {\\n                prev.random = null;\\n            } else {\\n                prev.random = pseudoRandomMap.get(rand);\\n            }\\n            curr = curr.next;\\n            prev = prev.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763481,
                "title": "java-hash-map-simple-solution-100-faster",
                "content": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        HashMap<Node,Node> map=new HashMap<>();\\n        Node node=head;\\n        while(node!=null)\\n        {\\n            Node n=new Node(node.val);\\n            map.put(node,n);\\n            node=node.next;\\n        } \\n        for(Map.Entry <Node ,Node> entry:map.entrySet())\\n        {\\n             Node main=entry.getKey();\\n             Node copy=entry.getValue();\\n             copy.next=main.next!=null?map.get(main.next):null;\\n             copy.random=main.random!=null?map.get(main.random):null;\\n        }\\n        return map.get(head);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        HashMap<Node,Node> map=new HashMap<>();\\n        Node node=head;\\n        while(node!=null)\\n        {\\n            Node n=new Node(node.val);\\n            map.put(node,n);\\n            node=node.next;\\n        } \\n        for(Map.Entry <Node ,Node> entry:map.entrySet())\\n        {\\n             Node main=entry.getKey();\\n             Node copy=entry.getValue();\\n             copy.next=main.next!=null?map.get(main.next):null;\\n             copy.random=main.random!=null?map.get(main.random):null;\\n        }\\n        return map.get(head);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750800,
                "title": "far-simpler-o-n-solution-no-interleaving-or-recursion",
                "content": "```\\nvar copyRandomList = function(head) {\\n  \\n    if (!head) return null;\\n    \\n    let pointer = head;\\n    \\n    // for each node - link it to a copy of itself\\n    // the copy has the same random and next properties as the original node\\n    while(pointer !== null) {\\n        // create new copyNode\\n        pointer.copy = new Node(pointer.val, pointer.next, pointer.random);\\n        // iterate forwards\\n        pointer = pointer.next;\\n    }\\n    \\n\\t// create a new pointer to the head of our copy LL\\n\\t// (this is what we will return)\\n    let copyHead = head.copy;\\n    \\n\\t// reset our pointer to the head of the list\\n\\tpointer = head;\\n    \\n    // set each copy node\\'s next and random properties to the respective node\\'s copy\\n    while(pointer !== null) {\\n        \\n        if (pointer.copy.next) {\\n            pointer.copy.next = pointer.copy.next.copy;            \\n        }\\n        if (pointer.copy.random) {\\n            pointer.copy.random = pointer.copy.random.copy;            \\n        }\\n        pointer = pointer.next;\\n    }\\n    \\n    // remove the references to the copy node on the original nodes\\n    pointer = head;\\n    while(pointer !== null) {\\n        pointer.copy = undefined;\\n        pointer = pointer.next;\\n    }\\n    \\n    // return our new copy list\\n    return copyHead;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Iterator"
                ],
                "code": "```\\nvar copyRandomList = function(head) {\\n  \\n    if (!head) return null;\\n    \\n    let pointer = head;\\n    \\n    // for each node - link it to a copy of itself\\n    // the copy has the same random and next properties as the original node\\n    while(pointer !== null) {\\n        // create new copyNode\\n        pointer.copy = new Node(pointer.val, pointer.next, pointer.random);\\n        // iterate forwards\\n        pointer = pointer.next;\\n    }\\n    \\n\\t// create a new pointer to the head of our copy LL\\n\\t// (this is what we will return)\\n    let copyHead = head.copy;\\n    \\n\\t// reset our pointer to the head of the list\\n\\tpointer = head;\\n    \\n    // set each copy node\\'s next and random properties to the respective node\\'s copy\\n    while(pointer !== null) {\\n        \\n        if (pointer.copy.next) {\\n            pointer.copy.next = pointer.copy.next.copy;            \\n        }\\n        if (pointer.copy.random) {\\n            pointer.copy.random = pointer.copy.random.copy;            \\n        }\\n        pointer = pointer.next;\\n    }\\n    \\n    // remove the references to the copy node on the original nodes\\n    pointer = head;\\n    while(pointer !== null) {\\n        pointer.copy = undefined;\\n        pointer = pointer.next;\\n    }\\n    \\n    // return our new copy list\\n    return copyHead;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 339636,
                "title": "c-extremely-simple-11-line-recursive-solution-beats-96-time",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    Node* copyRandomList(Node* head) {\\n        \\n        //mapping original node to its copy\\n        unordered_map<Node*, Node*> created;\\n        \\n        return helper(head, created);\\n    }\\n    \\n    Node* helper(Node* head, unordered_map<Node*, Node*> & created) {\\n        if (!head) return nullptr;\\n\\t\\t\\n        if (created.find(head) != created.end()) return created[head];\\n\\t\\t\\n        Node * curr = new Node(head->val, nullptr, nullptr);\\n        created[head] = curr;\\n        curr->next = helper(head->next, created);\\n        curr->random = helper(head->random, created);\\n        return curr;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    Node* copyRandomList(Node* head) {\\n        \\n        //mapping original node to its copy\\n        unordered_map<Node*, Node*> created;\\n        \\n        return helper(head, created);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 326572,
                "title": "c-o-n-speed-o-n-space-list-map-solution-koderz-kamp",
                "content": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        \\n        if (head == NULL) { return NULL; }\\n        \\n        Node *aNode = head;\\n        unordered_map<Node*, int> aMap;\\n        int aIndex = 1;\\n        while (aNode != NULL) {\\n            aMap[aNode] = aIndex;\\n            aNode = aNode->next;\\n            aIndex += 1;\\n        }\\n        \\n        vector<Node*> aCloneList;\\n        Node *aResult = new Node(head->val, NULL, NULL);\\n        aCloneList.push_back(aResult);\\n        Node *aClone = aResult;\\n        Node *aPrevClone = aResult;\\n        aNode = head->next;\\n        while (aNode != NULL) {\\n            aClone = new Node(aNode->val, NULL, NULL);\\n            aCloneList.push_back(aClone);\\n            aPrevClone->next = aClone;\\n            aPrevClone = aClone;\\n            aNode = aNode->next;\\n        }\\n        \\n        aNode = head;\\n        aClone = aResult;\\n        while (aNode != NULL) {\\n            if (aMap[aNode->random] != 0) {\\n                aClone->random = aCloneList[aMap[aNode->random] - 1];\\n            }\\n            aClone = aClone->next;\\n            aNode = aNode->next;\\n        }\\n        \\n        return aResult;\\n        \\n    }\\n};\\n```\\n\\nThere isn\\'t much special here, just finding the indices of the random pointers and linking up clones based on the indices from the original. We just put all the clones into a list.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        \\n        if (head == NULL) { return NULL; }\\n        \\n        Node *aNode = head;\\n        unordered_map<Node*, int> aMap;\\n        int aIndex = 1;\\n        while (aNode != NULL) {\\n            aMap[aNode] = aIndex;\\n            aNode = aNode->next;\\n            aIndex += 1;\\n        }\\n        \\n        vector<Node*> aCloneList;\\n        Node *aResult = new Node(head->val, NULL, NULL);\\n        aCloneList.push_back(aResult);\\n        Node *aClone = aResult;\\n        Node *aPrevClone = aResult;\\n        aNode = head->next;\\n        while (aNode != NULL) {\\n            aClone = new Node(aNode->val, NULL, NULL);\\n            aCloneList.push_back(aClone);\\n            aPrevClone->next = aClone;\\n            aPrevClone = aClone;\\n            aNode = aNode->next;\\n        }\\n        \\n        aNode = head;\\n        aClone = aResult;\\n        while (aNode != NULL) {\\n            if (aMap[aNode->random] != 0) {\\n                aClone->random = aCloneList[aMap[aNode->random] - 1];\\n            }\\n            aClone = aClone->next;\\n            aNode = aNode->next;\\n        }\\n        \\n        return aResult;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 316681,
                "title": "python-simple-solution",
                "content": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val, next, random):\\n        self.val = val\\n        self.next = next\\n        self.random = random\\n\"\"\"\\nclass Solution(object):\\n    def copyRandomList(self, head):\\n        \"\"\"\\n        :type head: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not head:\\n            return None\\n        \\n        \\n        old_to_new = {}\\n        cur = head\\n        while cur:\\n            old_to_new[cur] = Node(cur.val,None,None)\\n            cur = cur.next\\n        \\n        cur = head\\n        while cur:\\n            if cur.next:\\n                old_to_new[cur].next = old_to_new[cur.next]\\n            if cur.random:\\n                old_to_new[cur].random = old_to_new[cur.random]\\n            cur = cur.next\\n        \\n        return old_to_new[head]\\n```",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n# Definition for a Node.\\nclass Node(object):\\n    def __init__(self, val, next, random):\\n        self.val = val\\n        self.next = next\\n        self.random = random\\n\"\"\"\\nclass Solution(object):\\n    def copyRandomList(self, head):\\n        \"\"\"\\n        :type head: Node\\n        :rtype: Node\\n        \"\"\"\\n        if not head:\\n            return None\\n        \\n        \\n        old_to_new = {}\\n        cur = head\\n        while cur:\\n            old_to_new[cur] = Node(cur.val,None,None)\\n            cur = cur.next\\n        \\n        cur = head\\n        while cur:\\n            if cur.next:\\n                old_to_new[cur].next = old_to_new[cur.next]\\n            if cur.random:\\n                old_to_new[cur].random = old_to_new[cur.random]\\n            cur = cur.next\\n        \\n        return old_to_new[head]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 243750,
                "title": "python3-dictionary-solution-faster-than-100-60ms-concise-easy-to-understand-o-n",
                "content": "```\\ndef copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n\\tif not head:\\n\\t\\treturn None\\n\\n\\ttracker = dict()\\n\\tp1 = head\\n\\twhile(p1):\\n\\t\\ttracker[p1] = Node(p1.val, None, None)\\n\\t\\tp1 = p1.next\\n\\n\\tp1 = head\\n\\twhile(p1):\\n\\t\\tp2 = tracker[p1]\\n\\t\\tp2.random = tracker[p1.random] if p1.random else None\\n\\t\\tp2.next = tracker[p1.next] if p1.next else None\\n\\t\\tp1 = p1.next\\n\\n\\treturn tracker[head]\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\ndef copyRandomList(self, head: \\'Node\\') -> \\'Node\\':\\n\\tif not head:\\n\\t\\treturn None\\n\\n\\ttracker = dict()\\n\\tp1 = head\\n\\twhile(p1):\\n\\t\\ttracker[p1] = Node(p1.val, None, None)\\n\\t\\tp1 = p1.next\\n\\n\\tp1 = head\\n\\twhile(p1):\\n\\t\\tp2 = tracker[p1]\\n\\t\\tp2.random = tracker[p1.random] if p1.random else None\\n\\t\\tp2.next = tracker[p1.next] if p1.next else None\\n\\t\\tp1 = p1.next\\n\\n\\treturn tracker[head]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 158770,
                "title": "map",
                "content": "> ? deep copy\\ncopy val, next and random\\n\\n> ? why can\\'t we iterate through the list and copy each node\\nrandom pointers may point to unknown nodes so far\\n\\n>assuming we have a map mapping original nodes to copied nodes, things will be easier\\n\\n>so, we loop through the list for twice\\nfirstly, we copy next pointers and map original nodes to copied nodes\\nthen we copy random pointers\\n****\\n```\\n    public Node copyRandomList(Node head) {\\n        // Corner case\\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        // Create a new list\\n        Node dummyHead = new Node(0, null, null);\\n        \\n        Map<Node, Node> originalToCopy = new HashMap<>();\\n        \\n        // Build the new list with the next pointers only, and map original nodes to copied nodes\\n        Node ptr = head, ptrCopy = dummyHead;\\n        while (ptr != null) {\\n            Node copyNode = new Node(ptr.val, null, null);\\n            ptrCopy.next = copyNode;\\n            originalToCopy.put(ptr, copyNode);\\n            \\n            ptrCopy = ptrCopy.next;\\n            ptr = ptr.next;\\n        }\\n        \\n        // Iterate through the list to process the random pointers \\n        ptr = head;\\n        while (ptr != null) {\\n            Node random = ptr.random;\\n            Node randomCopy = originalToCopy.get(random);\\n            ptrCopy = originalToCopy.get(ptr);\\n            ptrCopy.random = randomCopy;\\n            \\n            ptr = ptr.next;\\n        }\\n        \\n        return dummyHead.next;        \\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public Node copyRandomList(Node head) {\\n        // Corner case\\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        // Create a new list\\n        Node dummyHead = new Node(0, null, null);\\n        \\n        Map<Node, Node> originalToCopy = new HashMap<>();\\n        \\n        // Build the new list with the next pointers only, and map original nodes to copied nodes\\n        Node ptr = head, ptrCopy = dummyHead;\\n        while (ptr != null) {\\n            Node copyNode = new Node(ptr.val, null, null);\\n            ptrCopy.next = copyNode;\\n            originalToCopy.put(ptr, copyNode);\\n            \\n            ptrCopy = ptrCopy.next;\\n            ptr = ptr.next;\\n        }\\n        \\n        // Iterate through the list to process the random pointers \\n        ptr = head;\\n        while (ptr != null) {\\n            Node random = ptr.random;\\n            Node randomCopy = originalToCopy.get(random);\\n            ptrCopy = originalToCopy.get(ptr);\\n            ptrCopy.random = randomCopy;\\n            \\n            ptr = ptr.next;\\n        }\\n        \\n        return dummyHead.next;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 131629,
                "title": "simple-c-hashmap-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    RandomListNode *copyRandomList(RandomListNode *head) {\\n        unordered_map<RandomListNode*, RandomListNode*>m;\\n        auto p = head;\\n        while(p){\\n            m[p] = new RandomListNode(p->label);\\n            p = p->next;\\n        }\\n        p = head;\\n        while(p){\\n            m[p]->next = m[p->next];\\n            m[p]->random = m[p->random];\\n            p = p->next;\\n        }\\n        return m[head];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    RandomListNode *copyRandomList(RandomListNode *head) {\\n        unordered_map<RandomListNode*, RandomListNode*>m;\\n        auto p = head;\\n        while(p){\\n            m[p] = new RandomListNode(p->label);\\n            p = p->next;\\n        }\\n        p = head;\\n        while(p){\\n            m[p]->next = m[p->next];\\n            m[p]->random = m[p->random];\\n            p = p->next;\\n        }\\n        return m[head];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 43587,
                "title": "clear-o-n-complexity-with-o-1-space-in-python",
                "content": "    class Solution:\\n        # @param head, a RandomListNode\\n        # @return a RandomListNode\\n        def copyRandomList(self, head):\\n            if not head:return None\\n            self.copyNext(head)\\n            self.copyRandom(head)\\n            return splitList(head)\\n    \\n            \\n        def copyNext(self,head):\\n            while head:\\n                newNode = RandomListNode(head.label)\\n                newNode.random = head.random\\n                newNode.next = head.next\\n                head.next = newNode\\n                head = head.next.next\\n    \\n        def copyRandom(self,head):\\n            while head:\\n                if head.next.random:\\n                    head.next.random = head.random.next\\n                head = head.next.next \\n    \\n        def splitList(self,head):\\n            newHead = head.next\\n            while head:\\n                tmp = head.next\\n                head.next = tmp.next\\n                head = head.next\\n                if tmp.next:\\n                    tmp.next = tmp.next.next\\n            return newHead",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param head, a RandomListNode\\n        # @return a RandomListNode\\n        def copyRandomList(self, head):\\n            if not head:return None\\n            self.copyNext(head)\\n            self.copyRandom(head)\\n            return splitList(head)\\n    \\n            \\n        def copyNext(self,head):\\n            while head:\\n                newNode = RandomListNode(head.label)\\n                newNode.random = head.random\\n                newNode.next = head.next\\n                head.next = newNode\\n                head = head.next.next\\n    \\n        def copyRandom(self,head):\\n            while head:\\n                if head.next.random:\\n                    head.next.random = head.random.next\\n                head = head.next.next \\n    \\n        def splitList(self,head):\\n            newHead = head.next\\n            while head:\\n                tmp = head.next\\n                head.next = tmp.next\\n                head = head.next\\n                if tmp.next:\\n                    tmp.next = tmp.next.next\\n            return newHead",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567517,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1566932,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1566828,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1565490,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1565595,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1565740,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1565344,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1567422,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1567318,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1575555,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1567517,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1566932,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1566828,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1565490,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1565595,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1565740,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1565344,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1567422,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1567318,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1575555,
                "content": [
                    {
                        "username": "v2021",
                        "content": "This same question appeard in my amazon round 1.\\nLet me write some more about what was attending its round 1 felt.\\nAmazon round 1 contained 4 section.\\n\\t1. 7 Array based Question of debugging came. (Which were so easy that everyone solved them with all test cases as passed). (20 min)\\n\\t2. This section contained 2 Coding based Questin were given, 1 was 138. Copy List with Random Pointer and other question was to return a recommendataion gener list of book based on some information given, also very simple. But the time was of constraint here. (60 min)\\n\\t3. This section had some Behavioural question.(answers vary person to person).\\n\\t4. last section was combination of Technical and Apti Questions (25 Question in 34 min).\\n\\nThat\\'s it I hope it come of some use to you."
                    },
                    {
                        "username": "Anshul29",
                        "content": "Did you clear it?\\uD83D\\uDE2C\\uD83E\\uDD1E"
                    },
                    {
                        "username": "17BIT0216",
                        "content": "What does the question asks?\\nI was confused with  the question for a bit. But understood it, Basically the question is to deep copy the linked list,  that is make an exact copy.(replicate the random nodes too)\\nIf it was simple single linked list, it was simple. Just make a copy on the go and connect the nodes.\\nBut if the random element is present we have to replicate it to, just imagine you made a new node and the random of this node points to a node which is not yet created ?What will you do? How will you Point to that node, thats what we have to solve here,"
                    },
                    {
                        "username": "dimitryku",
                        "content": "You need to preserve the sequence. If the first node of the original list was pointing to fifth node by \"random\" pointer, you need to do the same thing in your copy. The most difficult part here is to find out, what were the position of pointed node in the original list."
                    },
                    {
                        "username": "razvx",
                        "content": "I dont understand the qn. can someone plz explain.\\nthanks"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exact copy of the original one."
                    },
                    {
                        "username": "Coollaitar",
                        "content": "Create a CLONE of given Linked List"
                    },
                    {
                        "username": "hammeramr",
                        "content": "make the same exact linked list as the one given - all the nodes in the one you are making should be brand new - if your new linked list points to any of the list you are given it will fail the test"
                    },
                    {
                        "username": "ufo2mstar",
                        "content": "It seems like the problem is merely asking for a deepcopy of the labels (node values) of the random node that nodes point to, not the absolute reference of the n-th node within the Linked List!\\n\\nI was mapping the internal relative index of the random destination node and was preserving the order,\\nbut the silly validation program is passing even if I create brand new references!\\n\\nI feel that either the problem should be restated to make this clear, \\nor the test cases should look into the node addresses properly!"
                    },
                    {
                        "username": "jason3",
                        "content": "Does anyone know what \\n\\n\\nInput:\\t{1,2,2,2}\\nOutput:\\t{1,2,#,#}\\nExpected:\\t{1,2,2,2}\\n\\nmeans?"
                    },
                    {
                        "username": "Rushi_11",
                        "content": "[@treat](/treat) Lol"
                    },
                    {
                        "username": "payadikishan",
                        "content": "It is a simple linked list where next of each pointer is NULL"
                    },
                    {
                        "username": "treat",
                        "content": "Almost a decade and still unanswered"
                    },
                    {
                        "username": "napoleon",
                        "content": "I solve this problem by costing 392ms.\\nI use map to save the relation between the original list and the copy one."
                    },
                    {
                        "username": "wjmolina",
                        "content": "You are expecting a list like this:\\n\\n![enter image description here][1]\\n\\nHowever, something like this will get accepted, too:\\n\\n![enter image description here][2]\\n\\n  [1]: http://i59.tinypic.com/1zcpmq9.png\\n  [2]: http://i59.tinypic.com/33bpmjn.png"
                    },
                    {
                        "username": "pengtsen",
                        "content": "I have coded the O(n) space solution before and never thought I can do better. I recently saw this question in an interview and gave the o(n) space solution, but it is deemed unaccetable. You are supposed to give a O(n) time and O(1) space solution."
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@grovre](/grovre) By O(1) space they mean apart from the obvious space required by the problem, you cannot use more space than that. So, if a problem requires you to create a copy of an array for example, a array of size n will not be counted in the space complexity, the auxillary space that you are using for creating that copy of the array will be counted in the complexity."
                    },
                    {
                        "username": "grovre",
                        "content": "How do you copy a linked list, or any collection at that matter, in O(1) space?"
                    },
                    {
                        "username": "sirsa",
                        "content": "The problem description is not clear.\\n\\n(1) What is meant by deep copy of a linked list?\\n(2) Why is there no sample input/output?\\n(3) Why is there no \"Run Code\" option with sample test case?\\n\\nPlease fix."
                    },
                    {
                        "username": "rahuljindal",
                        "content": "Credit to @DyXrLxSTAOadoD \\n\\n![image](https://assets.leetcode.com/users/images/f501a1c5-69fc-4baa-a98c-46850dac1866_1626697190.039599.jpeg)\\n"
                    },
                    {
                        "username": "devmaleeq",
                        "content": "why answers here?"
                    },
                    {
                        "username": "sam23414",
                        "content": "Avoid giving answers here!"
                    }
                ]
            },
            {
                "id": 1569975,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 2044769,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 1567738,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 2044722,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 1567211,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 2031875,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 1573924,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 1569691,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 1568038,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 2044549,
                "content": [
                    {
                        "username": "tonyraubenheimer",
                        "content": "The question description indicates that node.random is an index. But, the inputs are structured such that node.random is actually a pointer."
                    },
                    {
                        "username": "PrakharG14",
                        "content": "Check constraint"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Linked List & hash table !\nA very short recursion with memo is possible. I like trees and graphs much more than linked lists."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "Dude, at least mark your message as hint.."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/copy-list-with-random-pointer/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive\n\n  \n**Approach 2:** Iterative with $$O(N)$$ Space\n\n  \n**Approach 3:** Iterative with $$O(1)$$ Space\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "souvikmkhrj",
                        "content": "<a href=\"https://imgur.com/V9O4jyS\"><img src=\"https://i.imgur.com/V9O4jyS.jpg\" title=\"source: imgur.com\" width=\"400px\" /></a>"
                    },
                    {
                        "username": "A1m",
                        "content": "I don't see a 'Run Code' button on this problem, my code does also not compile if I submit. Is this a bug?\\n\\nEverything is just fine for any other problem on leetcode. Am I overseeing something here?"
                    },
                    {
                        "username": "user4796V",
                        "content": "\"Random pointer of node with label 7 from the original list was modified.\"\\nit never said that i can\\'t modifiy the random pointers from the original nodes ! "
                    },
                    {
                        "username": "xeviltimx",
                        "content": "The description clearly says, **`random_index`: the index of the node (range from 0 to n-1) where random pointer points to, or null if it does not point to any node**. \\nBut what `random_index` really is it\\'s a one of the nodes from original list, not index.\\nIn Javascript there is no types description and it seems like `random_index` is a `Number`, not `Node`.\\nPlease fix that."
                    },
                    {
                        "username": "dante2302",
                        "content": "that\\'s only for the input section of the problem, nowhere else is stated that the re are indexes of the nodes(obviously that wouldnt be random)\\n"
                    },
                    {
                        "username": "theSlayer",
                        "content": "Wouldn\\'t this create problem ? Why does python even allow it ? My understanding was private classes in python are mutable and key for dictionary should be mutable and hashable.\\n\\nGood people of Leetcode, What am I missing ?"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Key must be **immutable** or **hashable**\nYou can't make a list as key"
                    },
                    {
                        "username": "kavishjadwani",
                        "content": "Can anyone provide sample test cases. I am not able to submit code and hence cannot test my code. "
                    },
                    {
                        "username": "mavaziri",
                        "content": "I have same problem"
                    },
                    {
                        "username": "mrb15",
                        "content": "Good week for those who did Striver\\'s sheet!"
                    }
                ]
            },
            {
                "id": 1942973,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 1569340,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 1571300,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 1568960,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 2045096,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 2045064,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 2044944,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 2044797,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 2044763,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 2044681,
                "content": [
                    {
                        "username": "mg5050",
                        "content": "Downvoted because the description is wrong and borderline deceptive.\n\nRandom is not an index, but a pointer to the \"random\" node in the original list.\n\nFortunately, it's not too hard to create a mapping of \"random\" node to its actual offset."
                    },
                    {
                        "username": "ercanK",
                        "content": "When describing the list, `random pointer` is used several times: e.g \"each node contains an additional `random pointer`, ...\" and \"Both the `next` and `random` pointer of the new nodes should point to new nodes in the copied list such that the pointers ...\".\n\nWhereas, while <i>representing</i> a list, for example in test cases, `random_index` is used and each node is represented as [val, random_index]."
                    },
                    {
                        "username": "Ranchi",
                        "content": "What\\'s up with this question? \\n1. Theres no run button. I am not managing to run the code before submitting, even though I\\'m pressing the correct shortcut\\n2. The description of the problem lacks detail and examples\\n3. The error messages I\\'m getting are super general, unlike other problems\\n4. There are only 6 optional coding languages, unlike other questions which have double the options\\nIs this a bug on my end or are other people experiencing the same?"
                    },
                    {
                        "username": "sandeep37",
                        "content": "I'm not able to understand what a deep copy is ? Would someone explain me what a deep copy would look like ? for example A->B->C and A has random pointer to C and C has a random pointer to A. So how would the ouput look like ?\\n\\nlike this ? A->C->B->C->A ?"
                    },
                    {
                        "username": "whitehat",
                        "content": "Hi,\\n\\nI am not aware of the term. I think a couple of examples must be mentioned in the question to explain the same.\\n\\nCan someone explain what does a \"deep copy\" mean? Would appreciate an example too.\\n\\nThank you."
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "Mark Zuckerberg won\\'t take much time in copying a list \\uD83D\\uDDD2\\uFE0F as he have experience with threads \\uD83E\\uDDF5 already "
                    },
                    {
                        "username": "charonme",
                        "content": "no matter what I submit I always get a runtime error:\\n`Runtime Error\\nLine 196: PHP Fatal error:  Uncaught TypeError: spl_object_hash(): Argument #1 ($object) must be of type object, null given in solution.php\\nStack trace:\\n#0 solution.php: spl_object_hash()\\n#1 {main}`\\n\\n(I\\'m not using spl_object_hash() in my code)"
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one ."
                    },
                    {
                        "username": "munu8998rai",
                        "content": "I am really disappointed with myself as after coding for straight 2 months still i can\\'t solve questions! Is it normal?"
                    },
                    {
                        "username": "psionl0",
                        "content": "This is perfectly normal. Programming takes weeks to learn and a life time to master."
                    },
                    {
                        "username": "user5400vw",
                        "content": "i feel the same way after hundreds of practice questions - some questions feel as fresh and daunting as when i started.  sometimes your brain is on sometimes not, but just exposing yourself to the practice makes you better.  especially if you read the editorials on new concepts and build up your algorithm toolkit "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "linked-list week"
                    },
                    {
                        "username": "psionl0",
                        "content": "Suits me. Having learned LISP programming, I find linked lists to be quite a natural data structure."
                    },
                    {
                        "username": "indrazit",
                        "content": "There is no constraint that the nodes of the original node should not be changed, but if I return the new list with the original list broken (in Scala), Leetcode does not accept my solution, so I needed to repair the original list, too.  This constraint should be specified, too."
                    }
                ]
            },
            {
                "id": 2044661,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 2044646,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 2016978,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 1572806,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 1572322,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 1572180,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 1571301,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 1571302,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 1570131,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 2045015,
                "content": [
                    {
                        "username": "Bingo_o",
                        "content": "Again.. Where is Rust? :C"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[@Bingo_o](/Bingo_o) yes, using `std::rc::Rc` and `std::cell::RefCell` is a way to allow circular references in linked lists. If we can convince LeetCode to do so..."
                    },
                    {
                        "username": "Bingo_o",
                        "content": "[@Minamikaze392](/Minamikaze392) But what is wrong with this solution, for example?\\nhttps://leetcode.com/problems/linked-list-cycle/solutions/2071179/rust-solution/"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "[Here\\'s some explanation by someone.](https://www.reddit.com/r/rust/comments/t7wquc/comment/hzki2dy/)"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "[explained with proper explanation here](https://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003617/beats-100-with-proper-explanation/)"
                    },
                    {
                        "username": "sunilleetcode6",
                        "content": "please mention we are not allowed to disrot original link list"
                    },
                    {
                        "username": "datduyng",
                        "content": "I am not sure if I am missing something here. \\nImplementing a Java HashMap with custome key(in this case `Node` is our custome key), require us to override the `hashCode` and `equals` method. None of the hashmap solution I have reviewed actually overrided the class `Node` definition. How does the `HashMap` class know what to compare on? \\n\\nI have the same question on the https://leetcode.com/problems/clone-graph/ leetcode question as well. But couldn\\'t explain to myself what is so magical about the custome key object being created in both question."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, you don\\'t need to override equals() and hashCode(), but if you override one you should override the other so that they are consistent. The default (Object) implementation for equals() is:\\n public boolean equals(Object obj){\\n     return this == obj;\\n }\\nwhich is something every Java dev should learn and know."
                    },
                    {
                        "username": "saurabhsuniljain",
                        "content": "What is meant by deep copy of list ?"
                    },
                    {
                        "username": "donny-h",
                        "content": "I see many O(n) solutions, but they often make use of a dictionary that keys nodes based on their labels. Nowhere in the problem statement do I see that the nodes\\' labels are unique, and if they are not unique, then the dictionary approach wouldn\\'t work. Am I missing something here or can I just assume every time I see the word label in a Leetcode problem that it implies unique label?"
                    },
                    {
                        "username": "shenhualonga",
                        "content": "{-1,8,7,-3,4,4,-3,#,#,-1}\\n\\nFor example what does it mean?"
                    },
                    {
                        "username": "echoht",
                        "content": "are all the labels different from each other?"
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "**There is no use of random_index(Just foir confusion). Leetcode does it automatically for u.Just figure out a way to point next and random pointers of copied nodes to each other using dictinary.**"
                    },
                    {
                        "username": "neizod",
                        "content": "the WTF moment when implementing an unclear problem statement. what did the problem need actually? what is the input? is it give me an index or pointer? it\\'s totally unclear!!!\\n\\ngood bye leetcode, i can\\'t tolerate your WTF junk problems furthermore >:("
                    },
                    {
                        "username": "ercanK",
                        "content": "`Node` structure is given in the beginning of the code and copyRandomList's parameter `head` is of type Node.\n\nWhen it comes to input representation in test cases, it clearly says: \"The linked list is represented in the input/output as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]`\"."
                    },
                    {
                        "username": "prashudeshmukh3006",
                        "content": "It simply asks you to make a completely new linked list which is exactly similar to the original one "
                    }
                ]
            },
            {
                "id": 2063267,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2062004,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2059345,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2059007,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2045537,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2045536,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2045388,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2045371,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2045126,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2045085,
                "content": [
                    {
                        "username": "Roba00",
                        "content": " `return copy.deepcopy(head)`\\n![No need to thank me](https://media.tenor.com/ASwlibYFe2gAAAAC/no-need-to-thank-me-zapp-brannigan.gif)"
                    },
                    {
                        "username": "Harshal2022",
                        "content": "/*\\n// Definition for a Node.\\nclass Node {\\n    int val;\\n    Node next;\\n    Node random;\\n\\n    public Node(int val) {\\n        this.val = val;\\n        this.next = null;\\n        this.random = null;\\n    }\\n}\\n*/\\n\\nclass Solution {\\n    public Node copyRandomList(Node head) {\\n        if(head==null){\\n            return null;\\n        }\\n          Node ans = new Node(head.val);\\n        Node temp1=head;\\n        Node temp2=ans;\\n        temp1=temp1.next;\\n        while(temp1!=null){\\n            Node nextemp=new Node(temp1.val);\\n            temp2.next=nextemp;\\n            temp2=temp2.next;\\n            temp1=temp1.next;\\n        }\\n        \\n        temp1=head;\\n        temp2=ans;\\n         while(temp1!=null){\\n            if(temp1.random==null){\\n                temp2.random=null;\\n            }else{\\n               Node countemp1=head;\\n               Node countemp2=ans;\\n               while(temp1.random!=countemp1){\\n                   countemp2=countemp2.next;\\n                   countemp1=countemp1.next;\\n               }\\n               temp2.random=countemp2;\\n            }\\n            temp1=temp1.next;\\n            temp2=temp2.next;\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "hothanhnha25062004",
                        "content": "I use map to linking address of both, but it\\'s O(n) space, how to solve with O(1). I need some advices :("
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "those daigrams are quite overwhelming"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Question was great !  really liked it ! But it took me almost one hour to get it done ,came up with a solution on my own that takes O(n) time and O(n) space . I just wanna ask , is this normal ? Did I took way too long? I took ~30 mins in brainstorming the question. If this not normal , how can I improve ? I really want to improve my timings on problem solving. I really appreciate your advice and any kind of help."
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "[@satyamS_71](/satyamS_71) Actually at first go I also thinked the same but taken near about 15 mins to complete it you\\'re on the right path just keep practicing you\\'ll be on the right track. \\uD83D\\uDC4D"
                    },
                    {
                        "username": "satyamS_71",
                        "content": "[@Anekantjainsagar1](/Anekantjainsagar1)  I was focusing on just setting up pointers(both `next` and `random`) for each node . Setting up `next` pointer was easy (less than 1 minute to figure it out) . The real problem for was `random` pointer .  Because to set `random` pointer in copied list required to find the node in the newly formed list. I thought , it will be waste to loop through that node. And that is when , my thinking started hinting that I require some kind of map , so that I can get `random` node in an instant. But still I had no idea ,  how to use the map . This created kind of a hint for me.( I didn\\'t look at actual hint either). As I was sure that the solution requires some use of map , it took me ~15 mins to come up with a solution to map each node of original list to new copied list . First , I set up the copied list , with all the properties of the list , except `random` pointer. While performing this , I also set up the map accordingly . Second , I used the map to set the `random` pointer of the copied list.  "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Can you tell me how you\\'ve started thinking about it means what was the first thought that came to your mind"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "there is a deep copy problem in graphs too . can someone help me understand what exactly do these question tes"
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Linked List week :))"
                    },
                    {
                        "username": "santanusen",
                        "content": "1. O(n) extra space solution: use a hash-table to map nodes of source list to nodes of destination list.\\n\\n2. O(1) extra space solution:\\nLet the original list be\\n```\\nX->Y->Z\\n```\\nNow create and insert the nodes of the destination list next to its source in the original list.\\n```\\nX->x->Y->y->Z->z\\n```\\nNow, for each source and destination pair of nodes ```X``` and ```x``` set\\n```\\nx.random = X.random.next\\n```"
                    },
                    {
                        "username": "Anshul29",
                        "content": "Can Node.random point to a future node i.e. node yet to come or does it always point to past node?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "It may point to the node of original list, that was not yet copied (will be copied, when you will iterate through list to it). "
                    },
                    {
                        "username": "Anshul29",
                        "content": "[@Harsh-br0](/Harsh-br0) Nevermind. I got the answer. I was talking about like the node with val 11 points to a later node in example 1. ( I didn\\'t saw it earlier)"
                    },
                    {
                        "username": "Harsh-br0",
                        "content": "U mean a new node regardless of being part of cloned list...\\n\\nIt may work but that solution won\\'t be space efficient "
                    },
                    {
                        "username": "Anekantjainsagar1",
                        "content": "Value will be repeating or not?"
                    },
                    {
                        "username": "dimitryku",
                        "content": "Example 3. All nodes have the same value"
                    },
                    {
                        "username": "psionl0",
                        "content": "In example 3 it is but it doesn\\'t matter. Just copy the current value into the current new node."
                    }
                ]
            },
            {
                "id": 2045056,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2045048,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2044905,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2044814,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2044781,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2044777,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2044765,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2044764,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2044750,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2044680,
                "content": [
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 I managed to find a solution, but it took quite long to do so"
                    },
                    {
                        "username": "SakSwift",
                        "content": "is Node hashable by default? how are we keeping Node as the key of the Map? ( a map requires the key to be hashable right...)"
                    },
                    {
                        "username": "pyush98",
                        "content": "I might be wrong but I believe: although nodes are hashable in Python, it is not a recommended practice to use mutable objects as keys.\\n\\nplease, someone correct me if I\\'m wrong"
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "yes address can be hash able"
                    },
                    {
                        "username": "psionl0",
                        "content": "If you can do pointer arithmetic in the language of your choice then a node address should be hashable."
                    },
                    {
                        "username": "gracelan",
                        "content": "the given input example and the given Node class definition doesn\\'t really match, which is really confusing...."
                    },
                    {
                        "username": "psionl0",
                        "content": "``random`` is a node pointer but ``random_index`` is the index number of the node that ``random`` points to. We do not use ``random_index``."
                    },
                    {
                        "username": "oops_moment",
                        "content": "\\uD83D\\uDE0A At first glance, dealing with this extra random pointer in a linked list might seem like a head-scratcher. Random pointers in a linked list? Cloning? What\\'s going on? Don\\'t worry; we\\'ve got this!\\n\\nSo, picture a regular linked list where each node has a `next` pointer, right? It\\'s like a chain of nodes where you know what comes next. But now, let\\'s make things interesting. In this special linked list, we have not only the  `next` pointer but also a  `random` pointer.\\n\\nNext vs. Random:\\n\\nThe `next` pointer, just like in a regular linked list, points to the next node in line.\\nBut here\\'s the twist: the `random` pointer doesn\\'t follow the order. It points to some random node anywhere in the linked list. It\\'s like a surprise link that can take you anywhere!\\nWhat\\'s Cloning?\\n\\nNow, let\\'s talk about cloning. Instead of using the original nodes\\' addresses, we\\'re going to create brand new nodes that correspond to each of the original nodes. We\\'ll store these new nodes in a special map, like a dictionary, so we can find them later.\\n\\nMapping for Cloning:\\n\\nImagine we\\'re reconstructing our linked list, step by step. If the original list had a connection like this: `original->next = node1` , we can use our map to say, \"Hey, when you see `original->next`, replace it with `map[original->next]`, which is the new node we\\'ve created, like `mp[node1]`.\""
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Come after learning Linked list best tip"
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Just iterate the linked list and create copies of the nodes on the go. Since a node can be referenced from multiple nodes due to the random pointers, ensure you are not making multiple copies of the same node.\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "just make new LinkedList of same type but not referencing the previous List"
                    },
                    {
                        "username": "psionl0",
                        "content": "Had I read the hint first, I would have used the interleaving nodes trick but I prefer to see what I can achieve by myself before researching the answer so hashmap it is."
                    },
                    {
                        "username": "Sayan_Sen",
                        "content": "Whenever life throws you a challenge , use a hashMap."
                    },
                    {
                        "username": "Saphal",
                        "content": "Happy Teacher\\'s Day LEETCODE \\uD83C\\uDF89!"
                    }
                ]
            },
            {
                "id": 2044673,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2044583,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2044573,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2044560,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2044559,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2044558,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2044533,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2042310,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2033267,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2028542,
                "content": [
                    {
                        "username": "sakibmondal7",
                        "content": "Just when  you think Linkedlist is easy! \\uD83D\\uDE12"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "I  prepare  a  hashmap to mapping  original nodes to deepcopy nodes, is that cheating?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@hero080](/hero080) Thanks for the solution! I mean...As for leetcode problems, it looks a bit strange to put a pointer into hashmap or hashset."
                    },
                    {
                        "username": "hero080",
                        "content": "No. It\\'s actually a very good way and pretty efficient.\\n\\nJust for fun though, we can do acrobats to achieve $O(1)$ extra space\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "CheeTaHOO7",
                        "content": "return copy.deepcopy(head)\\nsshhh! no one\\'s watching"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Bro how did you figure out. it actually works"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "`Tips:-`\\n\\nThe only tricky part here is to store a connection map between the real nodes to clone nodes and clone nodes to real nodes.\\n\\nThis will help you in copying the random pointer!"
                    },
                    {
                        "username": "aitachii",
                        "content": "I still don't understand how the O(n) time, O(1) space solution works, can someone explain?\nEDIT: nvm, i figured it out after some reading"
                    },
                    {
                        "username": "hero080",
                        "content": "An much more readable way to code that solution\\nhttps://leetcode.com/problems/copy-list-with-random-pointer/solutions/4003531/0ms-o-n-o-1-most-efficient-solution-interleaved-shallow-copy/"
                    },
                    {
                        "username": "user5400vw",
                        "content": "hmm is python really that slow?\\n\\nAccepted\\na few seconds ago\\nC++\\n3 ms\\n11.4 MB\\n\\nAccepted\\nAug 02, 2022\\nPython3\\n82 ms\\n14.7 MB\\n"
                    },
                    {
                        "username": "hero080",
                        "content": "[@tifv](/tifv) Although, in leetcode C++ and other compiled languages are not using the production optimization. They are often several times slower than they could run."
                    },
                    {
                        "username": "tifv",
                        "content": "Python itself is written in C; you can see some of what it has to do to set a single attribute of an object:\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1028-L1075\nhttps://github.com/python/cpython/blob/3.10/Objects/object.c#L1338-L1411\nhttps://github.com/python/cpython/blob/3.10/Objects/dictobject.c#L1063-L1154 (on attribute dict)\nEven if we ignore `NULL` checks, you can see a lot of `Py_DECREF` and `Py_INCREF`, which are modifying operations.\nCompare that to a single line of C or C++ code. It is an actual engineering feat that Python in some cases runs only like 50 times slower :)"
                    },
                    {
                        "username": "hero080",
                        "content": "This looks really fast for python. Python can often be 100 to 1000 times slower than C++"
                    },
                    {
                        "username": "tifv",
                        "content": "Yes :)"
                    },
                    {
                        "username": "utkarsh_verma",
                        "content": "aren\\'t we just supposed to return a copy of the linked list?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "A copy, yes. \\u201CJust\\u201D a copy, though? The list has many additional internal links that all need to be carefully reconstructed."
                    },
                    {
                        "username": "Lunagaron",
                        "content": "I am so confused what this question is asking. I know that return copy.deepcopy in python gets everything right, but I know its not correct."
                    },
                    {
                        "username": "tifv",
                        "content": "The idea of this problem to to (re)implement this operation."
                    },
                    {
                        "username": "sugandhajha3423",
                        "content": "whenever i try to access the head.random_index, it shows an error \\n\\n\\nAttributeError: \\'Node\\' object has no attribute \\'random_index\\'\\n\\n\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "It should be `head.random`, not `head.random_index`.\\n\\n`random_index` is only present in the specification of testcases. Your program will not receive this index directly. Instead, a node will contain `random` attribute pointing to the corresponding random node."
                    },
                    {
                        "username": "a_d14",
                        "content": "I do not understand why this solution is not working?\n\n`class Solution {\n\n    public Node copyRandomList(Node head) {\n\n        if(head == null) return null;\n        Node curr = head, newHead = null, newCurr = null;\n        Map<Integer, Node> nodeMap = new HashMap<>();\n\n        while(curr != null) {\n            if(newHead == null) {\n                newHead = new Node(curr.val);\n                nodeMap.put(curr.val, newHead);\n                newCurr = newHead;\n                curr = curr.next;\n                continue;\n            }\n\n            newCurr.next = new Node(curr.val);\n            newCurr = newCurr.next;\n            if(newCurr == null) System.out.println(\"NULL\");\n            nodeMap.put(curr.val, newCurr);\n            curr = curr.next;\n\n        }\n\n        curr = head; newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        System.out.println();\n        newCurr = newHead;\n\n        while(curr != null) {\n            if(curr.random == null) {\n                curr = curr.next;\n                newCurr = newCurr.next;\n                continue;\n            }\n\n            System.out.print(curr.random.val + \" \");\n            // newCurr.random = nodeMap.get(curr.random.val);\n            Node rand = nodeMap.get(curr.random.val);\n            newCurr.random = rand;\n            System.out.print(newCurr.random.val + \" \");\n            newCurr = newCurr.next;\n            curr = curr.next;\n        }\n\n        newCurr = newHead;\n\n        while(newCurr != null) {\n            System.out.print(newCurr.val + \" \");\n            newCurr = newCurr.next;\n        }\n\n        return newHead;\n    }\n}`\n\nEDIT: It works if I store the Node curr as a key in the map instead of curr.val. Don't know what the problem is."
                    },
                    {
                        "username": "psionl0",
                        "content": "The next and random fields in the nodes are node pointers (rather than vals as implied by the description). Other than copying curr.val to the new node, curr.val is irrelevant."
                    }
                ]
            },
            {
                "id": 2016562,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 2013742,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 1988675,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 1980463,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 1977306,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 1977099,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 1960957,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 1939215,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 1934699,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 1930343,
                "content": [
                    {
                        "username": "ParianshMahajan",
                        "content": "Not able to understand what they want??\\nInput=[[-1,0]];\\noutput=Random pointer of node with val -1 points to a node not in the copied list;\\n\\nLogic ::\\nif(head->next==NULL){\\n            Node *ins= new Node(head->val);\\n            if(head->random==NULL){\\n                ins->random=NULL;\\n            }\\n            else{\\n                Node *rand= new Node(head->random->val);  //next and random = NULL\\n                ins->random=rand;\\n                // ins->next=rand;\\n            }\\n            return ins;\\n        }\\n"
                    },
                    {
                        "username": "its_adit",
                        "content": "Node with label -1 was not copied but a reference to the original one. why i am getting this \\nNode* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* cur=head;\\n        Node *dummy=new Node(cur->val);\\n        Node* ans=dummy;\\n        mp[cur]=dummy;\\n        while(cur->next!=NULL)\\n        {\\n            cur=cur->next;\\n            dummy->next=new Node(cur->val);\\n            dummy=dummy->next;\\n            mp[cur]=dummy;\\n        }\\n        cur=head;\\n        Node*clone=ans;\\n        while(cur!=NULL && clone!=NULL)\\n        {\\n            clone->random = mp[cur->random];\\n            clone=clone->next;\\n            cur=cur->next;\\n        }        \\n        return ans;\\n    }\\n"
                    },
                    {
                        "username": "_Abhinav_",
                        "content": "what does this question achieves?"
                    },
                    {
                        "username": "mavaziri",
                        "content": "How can i submit my own code?\\nThe input and output is array in example, but my input is linked list.\\nCan someone plz explain.\\nThanks"
                    },
                    {
                        "username": "mavaziri",
                        "content": "[@prathameshpadhye743](/prathameshpadhye743) thanks for your reply.\\ni already wrote the code, but here in example input is an array, but my input is a linked list.\\n for example: head: {value: 1, next: Node}.\\nmy question is, how can i submit this code in leetcode with linked list input, while the input is for example: head = [[3,null],[3,0],[3,null]]. \\nthanks a lot."
                    },
                    {
                        "username": "prathameshpadhye743",
                        "content": "that\\'s representation of the input , what you get as input is just one node that is head of linked list. you traverse and work on it to make an exact copy of it."
                    },
                    {
                        "username": "charan_24137",
                        "content": "will this Linked List contain\\'s only unique elements or will there be any duplicates?"
                    },
                    {
                        "username": "psionl0",
                        "content": "There is nothing that says that the vals in the list are unique (see Testcase 3 for example). However, a deep copy will clone each node and the pointers in the copy will only point to the copied nodes."
                    },
                    {
                        "username": "yashwantyadav71",
                        "content": "https://takeuforward.org/data-structure/clone-linked-list-with-random-and-next-pointer/"
                    },
                    {
                        "username": "oops_moment",
                        "content": "For those confused regarding the question, it\\'s just asking you to make an exact copy . You need to make new Nodes yes you can\\'t use reference to nodes of original linkedlist . Just make an exact copy .\\n\\nHINT: Take a map where  new Node maps to old one . Then make the connections in the new node as they were in the original linked list ."
                    },
                    {
                        "username": "ed3642dev",
                        "content": "Today I learned that objects can be keys for dictionaries"
                    },
                    {
                        "username": "malstuti3",
                        "content": "  Node*on=head;\\n       Node*cn=clonehead;\\n       while(on!=NULL&&cn!=NULL){\\n           Node*next=on->next;\\n           on->next=cn;\\n           on=next;\\n\\n           next=cn->next;\\n           cn->next=on;\\n           cn=next;\\n       }\\n\\n       //step 3 -random pointer copy\\n        on=head;\\n        cn=clonehead;\\n        while(on!=NULL&&cn!=NULL){\\n            if(on->random!=NULL){\\n                cn->random=on->random->next;\\n            }\\n            else{\\n                cn->random=NULL;\\n            }\\n            cn=cn->next;\\n            on=on->next;\\n        }\\n         //step4 :revert changes done in step2\\n         on=head;\\n         cn=clonehead;\\n         while(on!=NULL&&cn!=NULL){\\n          on->next=cn->next;\\n          on=on->next;\\n\\n           if(on!=NULL){\\n           cn->next=on->next;\\n           }\\n           cn=cn->next;\\n\\n       \\n       }\\n     \\n       \\n       //step 5:return ans-clonehead\\n\\n       return clonehead;\\n    }\\n};\\n\\n\\ncan NYBODY PLEASE CHECK  WHAT IS THW ERROR a i m GETTING THE ERROR\\n\\nRandom pointer of node with label 13 from the original list was modified.\\n\\nBUT I HVENT MODIFIFED IT ANYWHERE\\n"
                    },
                    {
                        "username": "iw33209jfdcifidfj93",
                        "content": "can i use extra space here ?"
                    }
                ]
            },
            {
                "id": 1921719,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1917065,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1891175,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1842169,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1807997,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1805978,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1803521,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1799882,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1799184,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1788964,
                "content": [
                    {
                        "username": "dayemsaeed",
                        "content": "This problem description is too confusing. Simply, the problem is to create a deep copy (exact copy including the random nodes) without referencing any of the nodes in the original list. The problem description needs to be clearer."
                    },
                    {
                        "username": "its_adit",
                        "content": "Node* copyRandomList(Node* head) {\\n        if(head==NULL || head->next==NULL) return head;\\n        unordered_map<Node*, Node*> mp;\\n        Node* t=head;\\n        Node *dummy=new Node(t->val);\\n        mp[t]=dummy;\\n        while(t->next!=NULL)\\n        {\\n            t=t->next;\\n            dummy->next=new Node(t->val);\\n            dummy=dummy->next;\\n            mp[t]=dummy;\\n        }\\n        t=head;\\n        while(t!=NULL)\\n        {\\n        if (t->random != NULL) {\\n        mp[t]->random = mp[t->random];\\n        }\\n            t=t->next;\\n        }        \\n        return mp[head];\\n    } why i cant i am able to pass last 2 test case "
                    },
                    {
                        "username": "ChaitanyaGarg",
                        "content": "I think questions like these should also have a constraint that the given list should finally remain the same. I think the basic utility of this function is to have another copy of the list, while also having the current one, so giving the copy at the cost of distorting the original is not usefull. I have encountered my such cases where the arguments is passed via reference (to save memory), or is a pointer, and the best solutions just alter them completely. I feel like that should not be allowed."
                    },
                    {
                        "username": "kochtaik",
                        "content": "Does your JS solution work? Every time I click the \\'Run\\' button (despite the code I wrote) I get next error:\\n\\n`Line 142 in solution.js\\n          nextHash.set(now, now.next);\\n                                ^\\n\\nTypeError: Cannot read properties of undefined (reading \\'next\\')`\\n\\n"
                    },
                    {
                        "username": "kiam_uditya",
                        "content": "while making the true replica we can connect the  newly created node with the previous one;\\nhow on earth should i connect the random  pointer to a node which i haven\\'t created yet?"
                    },
                    {
                        "username": "hafid-hub",
                        "content": "We can just create all this nodes and after that only connect the random pointers."
                    },
                    {
                        "username": "bharukahimanshu",
                        "content": "class Solution {\\nprivate:\\n//insert function for inserting nodes in clone list\\n\\n    void insert(Node* &head , Node* &tail , int data){\\n        Node*temp = new Node(data);\\n        if(head == NULL){\\n            head = temp;\\n            tail = temp;\\n            return ;\\n        }\\n        \\n        else{\\n            tail->next = temp;\\n            tail = temp;\\n        }\\n        return;\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        Node* temp = head;\\n        Node* clonehead = NULL , *clonetail = NULL;\\n        while(temp!=NULL){\\n            int data = temp->val;\\n            insert(clonehead , clonetail , data);\\n            temp = temp->next;\\n        }\\n        \\n        map<Node* , Node*> mp;\\n        temp = head;\\n        Node* p =clonehead;\\n        \\n        while(temp!=NULL && p!=NULL){\\n            mp[temp] = p;\\n            temp = temp->next;\\n            p = p->next;\\n        }\\n        \\n        p = clonehead;\\n        temp = head;\\n        \\n        while(p!=NULL && temp!=NULL){\\n            p->random = mp[temp->random];\\n            temp=temp->next;\\n            p = p->next;\\n        }\\n        \\n        return clonehead;\\n    }\\n\\n};\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Rmsa77",
                        "content": "This question ruined my day....!!!!!!!!!!"
                    },
                    {
                        "username": "tejasX",
                        "content": "Can we do it in one pass? Sprinklr has asked this in One Pass."
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "// best code for easy to understand\\n\\n\\n\\n/*\\n\\n\\n\\n\\n// Definition for a Node.\\nclass Node {\\npublic:\\n    int val;\\n    Node* next;\\n    Node* random;\\n    \\n    Node(int _val) {\\n        val = _val;\\n        next = NULL;\\n        random = NULL;\\n    }\\n};\\n*/\\n\\nclass Solution {\\npublic:\\n\\n    Node* copyRandomList(Node* head)\\n{\\n    Node* temp = head;\\n\\n    while(temp!=NULL){\\n        \\n        Node* n = new Node(temp->val); //head value copy to n\\n        n->next = temp->next;\\n        temp->next = n;\\n\\n        temp=temp->next->next;//move 2 time bcoz skip duplicate value\\n    }\\n   temp = head;\\n\\n   while(temp!=NULL) \\n   {\\n       if(temp->random!=NULL){\\n           temp->next->random = temp->random->next;\\n       }\\n       temp = temp->next->next;\\n   }\\n\\n   temp  = head;\\n   Node* new_head = NULL;\\n   Node* new_tail = NULL;\\n\\n   while(temp!=NULL){\\n       Node* copy = temp->next;\\n\\n       if(new_head==NULL){\\n           new_head =copy;\\n           new_tail= copy;\\n\\n           temp->next= copy->next;\\n           copy->next = NULL;\\n\\n       }\\n       else\\n       {\\n           temp->next = copy->next;\\n           copy->next = NULL;\\n           new_tail->next = copy;\\n           new_tail = copy;\\n       }\\n       temp = temp->next;\\n   }\\n   return new_head;\\n\\n}\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Best rules for easy to understand.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "VIVEKKUMARMAURYA",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/description/ \\n\\nI\\'m Solving this problem by using unordered map, Solution passed 16 test cases out of 19 but it shows wrong answer for test case 17 which is [[-1, NULL]], guys please help me to solve this problem."
                    }
                ]
            },
            {
                "id": 1781804,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            },
            {
                "id": 1781304,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            },
            {
                "id": 1768467,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            },
            {
                "id": 1763583,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            },
            {
                "id": 1761012,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            },
            {
                "id": 1760377,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            },
            {
                "id": 1701671,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            },
            {
                "id": 1568961,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            },
            {
                "id": 1574804,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            },
            {
                "id": 1574762,
                "content": [
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/copy-list-with-random-pointer/solutions/3121744/js-quad-time-beats-84-linear-space-beat-79-explanation/\\n\\nSpace Efficient\\nQuad Time \\nExplanation"
                    },
                    {
                        "username": "VioletLeon",
                        "content": "Why am I running into a \"process exited with signal SIGSEGV\" error when trying to code this in typescript/javascript?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    },
                    {
                        "username": "asifaftab87",
                        "content": "This is a copy linkedlist question. Here deep copy meaning, we have to copied given(existing) linkedlist with its random pointer value. \\nI am trying to describe question may be clear and helpful for others.\\n1. Create new linkedlist which is copy of given linkedlist and random pointer if not pointing to null then it is pointing to any other node of the list. \\n2. Here when we copy random pointer then new list pointer should point to new list node.\\n3. In our code we have to be careful that our new random pointer point to exact same new block, means suppose if given list random pointer of block a pointing to block c then our new list random pointer of block(or node) a should point to new block c.\\n\\nSolution:\\nHere I first created a Map<Node, Node> then created new linked from existing linked (only val is same with new node) and same time I saved given node address as key and new node as value in map.   Then I iterated given linkedlist and every time I have assigned value of map that I got by using given linkedlist node as key to random pointer to new linkedlist node. if given(existing) value of random pointer is null then we are getting null value from map else we get corresponding node address of new linkedlist.\\n "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "Darshan119",
                        "content": "private:\\n    void insertatTail(Node* &head , Node* & tail , int d){\\n        Node* NewNode = new Node(d);\\n        if(head == NULL){\\n            head = NewNode;\\n            tail = NewNode;\\n        }\\n        else{\\n            tail->next = NewNode;\\n            tail = NewNode;\\n        }\\n    }\\npublic:\\n    Node* copyRandomList(Node* head) {\\n        // step 1 create a clone list\\n        Node* CloneHead = NULL;\\n        Node* CloneTail = NULL;\\n        Node* temp = head;\\n        while(temp != NULL){\\n        insertatTail(CloneHead , CloneTail , temp->val);\\n        temp = temp->next;\\n        }\\n        // step 2 clonenode add in between\\n        Node* OriginalNode = head;\\n        Node* CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n\\n        Node* nextPointing = OriginalNode->next ;\\n        OriginalNode ->next = CloneNode;\\n        OriginalNode = nextPointing;\\n\\n        nextPointing = CloneNode -> next;\\n        CloneNode->next = OriginalNode;\\n        CloneNode = nextPointing ;\\n        }\\n\\n        // step 3 copy random pointer \\n        temp = head;\\n        while(temp != NULL){\\n            if(temp->next != NULL){\\n                temp->next->random = temp->random ? temp->random->next : temp->random;\\n            }\\n            temp = temp->next;\\n        }\\n\\n        // step 4 revert changes done in step 2\\n        OriginalNode = head;\\n        CloneNode = CloneHead;\\n\\n        while(OriginalNode != NULL && CloneNode != NULL){\\n            OriginalNode -> next  = CloneNode -> next ;\\n            OriginalNode = OriginalNode -> next;\\n\\n            if(OriginalNode  != NULL){\\n                CloneNode -> next = OriginalNode -> next ;\\n            }\\n            CloneNode = CloneNode -> next ;\\n        }\\n    //  step 5 return answer \\n    return CloneHead;\\n    } \\n\\n\\n\\n\\nwhat wrong in this code ,, giving test case failed \\n"
                    },
                    {
                        "username": "qqwww520kk",
                        "content": " `   public Node copyRandomList(Node head) {\\n        if(head == null){\\n            return null;\\n        }\\n        Node p = head;\\n        while(p != null){\\n            Node t = new Node(p.val);\\n            t.next = p.next;\\n            p.next = t;\\n            p = p.next.next;\\n        }\\n\\n\\n        Node new_head = head.next;\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.random != null){\\n                p.next.random = p.random.next;\\n            }\\n            \\n\\n     \\n            // if(p.next.next != null){\\n            //     p.next.next = p.next.next.next;\\n            // }\\n            // p.next = t;\\n            p = t;\\n        }\\n\\n        p = head;\\n        while(p != null){\\n            Node t = p.next.next;\\n            if(p.next.next != null){\\n                p.next.next = p.next.next.next;\\n            }\\n            p.next = t;//I don\\'t understand why this code is necessary.\\n            p = t;\\n        }\\n        return new_head;\\n            \\n    }`\\n\\n\\nPlease see two parts I comment.\\n\\nI don\\'t know why it is necessary to reset the old node\\'s \"next\" in order not to link to new one.."
                    },
                    {
                        "username": "kelukelu",
                        "content": "I cannot imagine someone figuring this out without knowing the trick."
                    },
                    {
                        "username": "PKYO123",
                        "content": "return head; //gg"
                    },
                    {
                        "username": "divya_dhaipulle",
                        "content": "![image](https://assets.leetcode.com/users/images/f86e3e39-e632-4514-92cd-195c92dfce7c_1609589968.7361178.png)\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Product of Array Except Self",
        "question_content": "<p>Given an integer array <code>nums</code>, return <em>an array</em> <code>answer</code> <em>such that</em> <code>answer[i]</code> <em>is equal to the product of all the elements of</em> <code>nums</code> <em>except</em> <code>nums[i]</code>.</p>\n\n<p>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</p>\n\n<p>You must write an algorithm that runs in&nbsp;<code>O(n)</code>&nbsp;time and without using the division operation.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> nums = [1,2,3,4]\n<strong>Output:</strong> [24,12,8,6]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> nums = [-1,1,0,-3,3]\n<strong>Output:</strong> [0,0,9,0,0]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>-30 &lt;= nums[i] &lt;= 30</code></li>\n\t<li>The product of any prefix or suffix of <code>nums</code> is <strong>guaranteed</strong> to fit in a <strong>32-bit</strong> integer.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong>&nbsp;Can you solve the problem in <code>O(1)</code>&nbsp;extra&nbsp;space complexity? (The output array <strong>does not</strong> count as extra space for space complexity analysis.)</p>\n",
        "solutions": [
            {
                "id": 65622,
                "title": "simple-java-solution-in-o-n-without-extra-space",
                "content": "    public class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] res = new int[n];\\n        res[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            res[i] = res[i - 1] * nums[i - 1];\\n        }\\n        int right = 1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            res[i] *= right;\\n            right *= nums[i];\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] res = new int[n];\\n        res[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            res[i] = res[i - 1] * nums[i - 1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1342916,
                "title": "3-minute-read-mimicking-an-interview",
                "content": "In this post, I would be discussing this question with different approaches which you would come up in an interview in the manner of increasing difficulty. I will be writting this post in such a way as if I were the person being interviewed. So, enjoy \\uD83D\\uDE0A\\n\\n#### **1. Brute Force**\\nSo, the first and formost, the simplest method that comes to mind is, I can loop through the complete array using a pointer, say `j`, for every index `i`, and multiply all the elements  at index `j` except when  `i == j`. This would ensure that I skip the element at index `i` from being multiplied. \\n\\nThe Time Complexity for this solution would be O(n<sup>2</sup>). \\n\\nBelow is the Java Code for this approach.\\n```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int ans[] = new int[n];\\n        \\n        for(int i = 0; i < n; i++) {\\n            int pro = 1;\\n            for(int j = 0; j < n; j++) {\\n                if(i == j) continue;\\n                pro *= nums[j];\\n            }\\n            ans[i] = pro;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\nTo this, the interviewer would surely say to optimize the time complexity of the solution. \\nThen a bit of acting to think \\uD83E\\uDD14.\\n\\n\\n### **2. Dividing the product of array with the number**\\nWhat we would do is, we would find the product of all the numbers of our Array and then divide the product with each element of the array to get the new element for that position in our final answer array.\\n\\nNow after presenting the interviewer with this solution, here is our one more chance to shine out in the interview. We would specifically tell the interviewer that one major *con* in going with this method is when we have an element as `0` in our array. The problem is that, we can\\'t perform a division by `0`, as a result, we won\\'t be able to get corresponding values in our final answer array for the indices having `0` in our initial array at that position. \\n\\nThe Time Complexity of this approach would be O(n).\\n\\nBelow is the Java Code for the above approach. \\n```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int ans[] = new int[n];\\n        int pro = 1;\\n        for(int i : nums) {\\n            pro *= i;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            ans[i] = pro / nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nTo which the interviewer would now say to overcome this problem which we face when having `0`.\\nAgain a bit of acting acting to think \\uD83E\\uDD14 (because that\\'s very important \\uD83D\\uDE1C). Then we would say that, `0` is our problem only when we are performing division, with multiplication, we have no such problem with `0`, so we would need to think of a way using multiplication.\\n\\n### **3. Finding Prefix Product and Suffix Product**\\nSimilar to finding Prefix Sum Array, here we would intend to find the Prefix Product Array and Suffix Product Array for our original array, i.e. `pre[i] = pre[i - 1] * a[i - 1]` (yes, we multiply with `a[i - 1]` and not with `a[i]` on purpose) and similarly `suff[i] = suff[i + 1] * a[i + 1]`. \\nNow, at any index `i` our final answer `ans[i]` would be given by `ans[i] = pre[i] * suff[i]`. Why? Because the `pre[i] * suff[i]` contains product of every element before `i` and every element after `i` but not the element at index `i` (and that is the reson why we excluded `a[i]` in our prefix and suffix product). \\n\\nThe Time Complexity would be O(n), but we are now using Auxilary Space of O(n) (excluding the final answer array).\\n\\nBelow is the Java Code for this approach\\n```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int pre[] = new int[n];\\n        int suff[] = new int[n];\\n        pre[0] = 1;\\n        suff[n - 1] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            pre[i] = pre[i - 1] * nums[i - 1];\\n        }\\n        for(int i = n - 2; i >= 0; i--) {\\n            suff[i] = suff[i + 1] * nums[i + 1];\\n        }\\n        \\n        int ans[] = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            ans[i] = pre[i] * suff[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nNow the interviewer might ask you to oprimize the space complexity of the program. Again a bit of thinking \\uD83E\\uDD14.\\n\\n### **4. Directly store the product of prefix and suffix into the final answer array**\\nThe logic is, we don\\'t actually need seperate array to store prefix product and suffix products, we can do all the approach discussed in method 3 directly onto our final answer array. \\n\\nThe Time Complexity would be O(n) but now, the Auxilary Space is O(1) (excluding the final answer array).\\n\\nBelow is the Java Code for the above algorithm.\\n```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int ans[] = new int[n];\\n        Arrays.fill(ans, 1);\\n        int curr = 1;\\n        for(int i = 0; i < n; i++) {\\n            ans[i] *= curr;\\n            curr *= nums[i];\\n        }\\n        curr = 1;\\n        for(int i = n - 1; i >= 0; i--) {\\n            ans[i] *= curr;\\n            curr *= nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nAfter this, hope the interviewer get\\'s impressed and you are  selected into your dream company. \\uD83D\\uDE0A\\n\\n**Thank you for giving your time in reading this post.**\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int ans[] = new int[n];\\n        \\n        for(int i = 0; i < n; i++) {\\n            int pro = 1;\\n            for(int j = 0; j < n; j++) {\\n                if(i == j) continue;\\n                pro *= nums[j];\\n            }\\n            ans[i] = pro;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int ans[] = new int[n];\\n        int pro = 1;\\n        for(int i : nums) {\\n            pro *= i;\\n        }\\n        \\n        for(int i = 0; i < n; i++) {\\n            ans[i] = pro / nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int pre[] = new int[n];\\n        int suff[] = new int[n];\\n        pre[0] = 1;\\n        suff[n - 1] = 1;\\n        \\n        for(int i = 1; i < n; i++) {\\n            pre[i] = pre[i - 1] * nums[i - 1];\\n        }\\n        for(int i = n - 2; i >= 0; i--) {\\n            suff[i] = suff[i + 1] * nums[i + 1];\\n        }\\n        \\n        int ans[] = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            ans[i] = pre[i] * suff[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int ans[] = new int[n];\\n        Arrays.fill(ans, 1);\\n        int curr = 1;\\n        for(int i = 0; i < n; i++) {\\n            ans[i] *= curr;\\n            curr *= nums[i];\\n        }\\n        curr = 1;\\n        for(int i = n - 1; i >= 0; i--) {\\n            ans[i] *= curr;\\n            curr *= nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597994,
                "title": "c-python-4-simple-solutions-w-explanation-prefix-suffix-product-o-1-space-approach",
                "content": "We are given an array `nums` and need to return an array `ans` where `ans[i]` contains product of all elements in `nums` except `nums[i]`.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Calculate product & divide by self)***\\n\\nWe can simply calculate product of the whole array and for each element in `nums`, divide the product by `nums[i]`. This effectively leaves us with product of whole array except self at each index. We need to take care of zeros that may occur in the array -\\n\\n<ol>\\n\\n**1.** If there are more than one `0`s in `nums`, the result is an array consisting of all `0`.\\n**2.** If there is a single `0` in `nums`, then the result is an array consisting of all `0` except at the index where there was `0` in `nums`, which will contain product of rest of array.\\n**3.** If there\\'s no `0` in `nums`, then the result is an array `ans` where `ans[i] = prod / nums[i]` (`prod = product of all elements in nums`).\\n\\n</ol>\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int prod = 1, zeroCnt = count(begin(nums), end(nums), 0);\\n        if(zeroCnt > 1) return vector<int>(size(nums));               // Case-1\\n        for(auto c : nums) \\n            if(c) prod *= c;                                          // calculate product of all elements except 0\\n        for(auto& c : nums)\\n            if(zeroCnt) c = c ? 0 : prod;                             // Case-2\\n            else c = prod / c;                                        // Case-3\\n        return nums;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums):\\n        prod, zero_cnt = reduce(lambda a, b: a*(b if b else 1), nums, 1), nums.count(0)\\n        if zero_cnt > 1: return [0]*len(nums)\\n        for i, c in enumerate(nums):\\n            if zero_cnt: nums[i] = 0 if c else prod\\n            else: nums[i] = prod // c\\n        return nums\\n```\\n\\n***Time Complexity :*** `O(N)`\\n***Space Complexity :*** `O(1)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Prefix & Suffix Products)***\\n\\nWe are required to solve this problem without using the division operator. We can do this by calculating two arrays `pre` and `suf` where `pre[i]` contains product of all `nums[j]` such that `j <= i`, and `suf[i]` contains product of all `nums[j]` such that `j >= i`. \\n\\nFinally, the resulting array `ans` can be calculated as `ans[i] = pre[i-1] * suf[i+1]` which is product of all elements with index less than `i` multiplied by product of all elements with index greater than `i`. This is essentially equal to product of array except self at each index.\\n\\n<p align=middle>\\n<img src=\"https://assets.leetcode.com/users/images/99b64bb7-85d3-454e-a800-0a76cd905ef5_1637980713.7155366.png\" width=600 />\\n</p>\\n\\n\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> pre(nums), suf(nums), ans(size(nums));\\n        partial_sum(begin(pre), end(pre), begin(pre), multiplies<int>());       // calculates & stores prefix product at each index\\n        partial_sum(rbegin(suf), rend(suf), rbegin(suf), multiplies<int>());    // calculates & stores suffix product at each index\\n        for(int i = 0; i < size(nums); i++)\\n            ans[i] = (i ? pre[i-1] : 1) * (i+1 < size(nums) ? suf[i+1] : 1);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums):\\n        pre, suf, n = list(accumulate(nums, mul)), list(accumulate(nums[::-1], mul))[::-1], len(nums)\\n        return [(pre[i-1] if i else 1) * (suf[i+1] if i+1 < n else 1) for i in range(n)]\\n```\\n\\n***Time Complexity :*** `O(N)`, calculating `pre` and `suf` arrays takes `O(N)` time and then another `O(N)` to compute `ans`. Total complexity comes out to be `O(3*N) = O(N)`.\\n***Space Complexity :*** `O(N)`, required to store `pre` and `suf` arrays\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - III (Space-Optimized Prefix & Suffix Products)***\\n\\nWe can calculate `ans` without maintaining two extra `pre` and `suf` arrays. \\n\\n* We can initialize the result array `ans` of length equal to `nums` filled with `1`.\\n* Then, for each `i`, we can calculate prefix product (without self), i.e, `ans[i] = ans[i-1]*nums[i-1]`. This is same as calculating `pre` in previous approach but this time we are storing it within our result array.\\n* Then we iterate from the last index with a variable `suffixProd=1` denoting suffix product. For each `i`, we multiply `ans[i]` with `suffixProd`. Each time we will also update `suffixProd = suffixProd * nums[i]`.\\n\\nThe above again gives us product of array except self at each index. This is because, firstly we are storing prefix product (without self) in `ans` and then multiplying each `ans[i]` with suffix product which is the same that we did in the previous approach.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans(size(nums),1);\\n        for(int i = 1; i < size(nums); i++)                            // store prefix product\\n\\t\\t\\tans[i] = ans[i-1] * nums[i-1];\\n        for(int i = size(nums)-1, suffixProd = 1; i >= 0; i--) {\\n            ans[i] *= suffixProd;                                      // multiply stored prefix product with suffix product\\n            suffixProd *= nums[i];                                     // update suffix product\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums):\\n        n, ans, suffix_prod = len(nums), [1]*len(nums), 1\\n        for i in range(1,n):\\n            ans[i] = ans[i-1] * nums[i-1]\\n        for i in range(n-1,-1,-1):\\n            ans[i] *= suffix_prod\\n            suffix_prod *= nums[i]\\n        return ans\\n```\\n\\n***Time Complexity :*** `O(N)`, one iteration is required to calculate prefix product for each index and another iteration to calculate suffix product. Total time complexity comes out to be `O(2*N) = O(N)`\\n***Space Complexity :*** `O(1)`, ignoring the output, we are only using constant extra space.\\n\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Space-Optimized Prefix & Suffix Products in One-Pass)***\\n\\nThe above process can be done in single pass as well. We were first calculating prefix product in one loop and then multiplying it with suffix product in another loop. These two process are independent of each other and can be done in the same loop. We just need to keep another prefix product variable similar to `suffix_prod` in previous approach.\\n\\nWe iterate from start and keep calculating prefix product & update corresponding `ans[i]` & at the same time we can calculate keep calculating suffix product from the end & update `ans[n-1-i]`.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans(size(nums),1);\\n        for(int i = 0, suf = 1, pre = 1, n = size(nums); i < n; i++) {\\n            ans[i] *= pre;             // similar to prefix product being calculated in 1st loop of previous solution\\n            pre *= nums[i];\\t\\t\\t\\n            ans[n-1-i] *= suf;         // similar to suffix product being calculated in 2nd loop of previous solution\\n            suf *= nums[n-1-i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums):\\n        ans, suf, pre = [1]*len(nums), 1, 1\\n        for i in range(len(nums)):\\n            ans[i] *= pre               # prefix product from one end\\n            pre *= nums[i]\\n\\t\\t\\tans[-1-i] *= suf            # suffix product from other end\\n\\t\\t\\tsuf *= nums[-1-i]\\n        return ans\\n```\\n\\nNote that the final result would be product of array except self because we only update & multiply `pre` with `nums[i]` after updating `ans[i]` and similarly for `suf`.\\n\\n***Time Complexity :*** `O(N)`\\n***Space Complexity :*** `O(1)`\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int prod = 1, zeroCnt = count(begin(nums), end(nums), 0);\\n        if(zeroCnt > 1) return vector<int>(size(nums));               // Case-1\\n        for(auto c : nums) \\n            if(c) prod *= c;                                          // calculate product of all elements except 0\\n        for(auto& c : nums)\\n            if(zeroCnt) c = c ? 0 : prod;                             // Case-2\\n            else c = prod / c;                                        // Case-3\\n        return nums;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums):\\n        prod, zero_cnt = reduce(lambda a, b: a*(b if b else 1), nums, 1), nums.count(0)\\n        if zero_cnt > 1: return [0]*len(nums)\\n        for i, c in enumerate(nums):\\n            if zero_cnt: nums[i] = 0 if c else prod\\n            else: nums[i] = prod // c\\n        return nums\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> pre(nums), suf(nums), ans(size(nums));\\n        partial_sum(begin(pre), end(pre), begin(pre), multiplies<int>());       // calculates & stores prefix product at each index\\n        partial_sum(rbegin(suf), rend(suf), rbegin(suf), multiplies<int>());    // calculates & stores suffix product at each index\\n        for(int i = 0; i < size(nums); i++)\\n            ans[i] = (i ? pre[i-1] : 1) * (i+1 < size(nums) ? suf[i+1] : 1);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums):\\n        pre, suf, n = list(accumulate(nums, mul)), list(accumulate(nums[::-1], mul))[::-1], len(nums)\\n        return [(pre[i-1] if i else 1) * (suf[i+1] if i+1 < n else 1) for i in range(n)]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans(size(nums),1);\\n        for(int i = 1; i < size(nums); i++)                            // store prefix product\\n\\t\\t\\tans[i] = ans[i-1] * nums[i-1];\\n        for(int i = size(nums)-1, suffixProd = 1; i >= 0; i--) {\\n            ans[i] *= suffixProd;                                      // multiply stored prefix product with suffix product\\n            suffixProd *= nums[i];                                     // update suffix product\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums):\\n        n, ans, suffix_prod = len(nums), [1]*len(nums), 1\\n        for i in range(1,n):\\n            ans[i] = ans[i-1] * nums[i-1]\\n        for i in range(n-1,-1,-1):\\n            ans[i] *= suffix_prod\\n            suffix_prod *= nums[i]\\n        return ans\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans(size(nums),1);\\n        for(int i = 0, suf = 1, pre = 1, n = size(nums); i < n; i++) {\\n            ans[i] *= pre;             // similar to prefix product being calculated in 1st loop of previous solution\\n            pre *= nums[i];\\t\\t\\t\\n            ans[n-1-i] *= suf;         // similar to suffix product being calculated in 2nd loop of previous solution\\n            suf *= nums[n-1-i];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums):\\n        ans, suf, pre = [1]*len(nums), 1, 1\\n        for i in range(len(nums)):\\n            ans[i] *= pre               # prefix product from one end\\n            pre *= nums[i]\\n\\t\\t\\tans[-1-i] *= suf            # suffix product from other end\\n\\t\\t\\tsuf *= nums[-1-i]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3186745,
                "title": "best-c-3-solution-dp-space-optimization-brute-force-optimize-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Array(Two Nested Loops). Brute Force Approach.\\n2. Solved using Dynamic Programming Approach(tabulation).\\n3. Solved using Dynamic Programming Approach(Space Optimization). Optimized Approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the size of the Array(nums). Here Two nested loop creates the time \\n    complexity.\\n\\n    Space complexity : O(1), Constant space. Extra space is only allocated for the Array(output), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : This will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> output;\\n        for(int i=0; i<n; i++){\\n            int product = 1;\\n            for(int j=0; j<n; j++){\\n                if(i == j) continue;\\n                product *= nums[j];\\n            }\\n            output.push_back(product);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), As we iterate the Array(nums) thrice. Where N = size of the array.\\n\\n    Space complexity : O(N), Array(left_Product and right_Product) space. \\n\\n    Solved using Dynamic Programming Approach(tabulation).\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        vector<int> left_Product(n);\\n        vector<int> right_Product(n);\\n        left_Product[0] = 1;\\n        for(int i=1; i<n; i++){\\n            left_Product[i] = left_Product[i-1] * nums[i-1];\\n        }\\n        right_Product[n-1] = 1;\\n        for(int i=n-2; i>=0; i--){\\n            right_Product[i] = right_Product[i+1] * nums[i+1];\\n        }\\n        for(int i=0; i<n; i++){\\n            ans[i] = left_Product[i] * right_Product[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), As we iterate the Array(nums) twice. Where N = size of the array.\\n\\n    Space complexity : O(1), Constant space. Extra space is only allocated for the Array(output), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using Dynamic Programming Approach(Space Optimization). Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> output(n);\\n        output[0] = 1;\\n        for(int i=1; i<n; i++){\\n            output[i] = output[i-1] * nums[i-1];\\n        }\\n        int right = 1;\\n        for(int i=n-1; i>=0; i--){\\n            output[i] *= right;\\n            right *= nums[i];\\n        }\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N^2), Where N is the size of the Array(nums). Here Two nested loop creates the time \\n    complexity.\\n\\n    Space complexity : O(1), Constant space. Extra space is only allocated for the Array(output), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using Array(Two Nested Loop). Brute Force Approach.\\n\\n    Note : This will give TLE.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> output;\\n        for(int i=0; i<n; i++){\\n            int product = 1;\\n            for(int j=0; j<n; j++){\\n                if(i == j) continue;\\n                product *= nums[j];\\n            }\\n            output.push_back(product);\\n        }\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), As we iterate the Array(nums) thrice. Where N = size of the array.\\n\\n    Space complexity : O(N), Array(left_Product and right_Product) space. \\n\\n    Solved using Dynamic Programming Approach(tabulation).\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        vector<int> left_Product(n);\\n        vector<int> right_Product(n);\\n        left_Product[0] = 1;\\n        for(int i=1; i<n; i++){\\n            left_Product[i] = left_Product[i-1] * nums[i-1];\\n        }\\n        right_Product[n-1] = 1;\\n        for(int i=n-2; i>=0; i--){\\n            right_Product[i] = right_Product[i+1] * nums[i+1];\\n        }\\n        for(int i=0; i<n; i++){\\n            ans[i] = left_Product[i] * right_Product[i];\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N), As we iterate the Array(nums) twice. Where N = size of the array.\\n\\n    Space complexity : O(1), Constant space. Extra space is only allocated for the Array(output), however the\\n    output does not count towards the space complexity.\\n\\n    Solved using Dynamic Programming Approach(Space Optimization). Optimized Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> output(n);\\n        output[0] = 1;\\n        for(int i=1; i<n; i++){\\n            output[i] = output[i-1] * nums[i-1];\\n        }\\n        int right = 1;\\n        for(int i=n-1; i>=0; i--){\\n            output[i] *= right;\\n            right *= nums[i];\\n        }\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65638,
                "title": "my-simple-java-solution",
                "content": "Use `tmp` to store temporary multiply result by two directions. Then fill it into `result`. Bingo!\\n\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] result = new int[nums.length];\\n        for (int i = 0, tmp = 1; i < nums.length; i++) {\\n            result[i] = tmp;\\n            tmp *= nums[i];\\n        }\\n        for (int i = nums.length - 1, tmp = 1; i >= 0; i--) {\\n            result[i] *= tmp;\\n            tmp *= nums[i];\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Use `tmp` to store temporary multiply result by two directions. Then fill it into `result`. Bingo!\\n\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] result = new int[nums.length];\\n        for (int i = 0, tmp = 1; i < nums.length; i++) {\\n            result[i] = tmp;\\n            tmp *= nums[i];\\n        }\\n        for (int i = nums.length - 1, tmp = 1; i >= 0; i--) {\\n            result[i] *= tmp;\\n            tmp *= nums[i];\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 65627,
                "title": "o-n-time-and-o-1-space-c-solution-with-explanation",
                "content": "First, consider O(n) time and O(n) space solution.\\n\\n    class Solution {\\n    public:\\n        vector<int> productExceptSelf(vector<int>& nums) {\\n            int n=nums.size();\\n            vector<int> fromBegin(n);\\n            fromBegin[0]=1;\\n            vector<int> fromLast(n);\\n            fromLast[0]=1;\\n            \\n            for(int i=1;i<n;i++){\\n                fromBegin[i]=fromBegin[i-1]*nums[i-1];\\n                fromLast[i]=fromLast[i-1]*nums[n-i];\\n            }\\n            \\n            vector<int> res(n);\\n            for(int i=0;i<n;i++){\\n                res[i]=fromBegin[i]*fromLast[n-1-i];\\n            }\\n            return res;\\n        }\\n    };\\n\\nWe just need to change the two vectors to two integers and note that we should do multiplying operations for two related elements of the results vector in each loop.\\n\\n    class Solution {\\n    public:\\n        vector<int> productExceptSelf(vector<int>& nums) {\\n            int n=nums.size();\\n            int fromBegin=1;\\n            int fromLast=1;\\n            vector<int> res(n,1);\\n            \\n            for(int i=0;i<n;i++){\\n                res[i]*=fromBegin;\\n                fromBegin*=nums[i];\\n                res[n-1-i]*=fromLast;\\n                fromLast*=nums[n-1-i];\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> productExceptSelf(vector<int>& nums) {\\n            int n=nums.size();\\n            vector<int> fromBegin(n);\\n            fromBegin[0]=1;\\n            vector<int> fromLast(n);\\n            fromLast[0]=1;\\n            \\n            for(int i=1;i<n;i++){\\n                fromBegin[i]=fromBegin[i-1]*nums[i-1];\\n                fromLast[i]=fromLast[i-1]*nums[n-i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1597959,
                "title": "c-discussing-all-solutions-explaining-in-detail-with-image",
                "content": "There can be multiple solutions to this problem but we have to reach the required condition mentioned in the question that **TC :: O(n)** and **SC :: O(1)**\\n\\n1.  **Naive solution using nested loop** \\n\\n For every element int the array , running the loop and calculating the product except itself -->>>\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> ans(n, 1);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == j) continue;\\n                ans[i] = ans[i] * nums[j]; \\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n**TC ::  O(n\\xB2)** and **SC :: O(1)** \\nobviously did not meet the required condition as TC is very bad !!\\n//\\n\\n    \\n\\t  \\n  \\t  \\n2. **Maintaining a left_product and a right_product array**\\n\\nThis is the way towards reaching the desired solution ... To calculate the product of all the elements except itself for an element at the index i, what do we need ?  Product of all the elements on the left side of it and the product of all the elements on the right side of it and if we multiply them both we get the answer !!\\nkeeping this in mind, let\\'s look at an example --->>\\n![image](https://assets.leetcode.com/users/images/8f7c6d1b-2d36-4a95-b114-39dd50c422a1_1637977417.633562.jpeg)\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        vector<int> left_Product(n);\\n        vector<int> right_Product(n);\\n        \\n        left_Product[0] = 1;\\n        for(int i = 1; i < nums.size(); i++){\\n            left_Product[i] = left_Product[i - 1] * nums[i - 1];\\n        }\\n        \\n        right_Product[n - 1] = 1;\\n        for (int j = n - 2; j >= 0; j--) {\\n            right_Product[j] = right_Product[j + 1] * nums[j + 1];\\n        }\\n        \\n        for (int k = 0; k < n; k++) {\\n            ans[k]= left_Product[k] * right_Product[k];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**TC :: O(n)** and **SC :: O(n)**\\n\\n\\n3. **Left_product taken as variable and using Right_product array as ans**\\n\\nWe have optimized the TC, we just don\\'t need to use any extra space ... In the previous solution do we really need any extra space ? After maintaining the Right_prod array , can\\'t we just take left_prod as a variable and then we keep updating it with left_product into nums[i] while iterating from left to right ... look at the example again\\n![image](https://assets.leetcode.com/users/images/44275a05-52fb-4c1f-aa91-fca30eb89cfc_1637978695.8859732.jpeg)\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> ans(n);\\n        \\n        ans[n - 1] = 1; // ans array used as right product array\\n        \\n        for(int i = n - 2; i >= 0; i--){\\n            ans[i] = nums[i + 1] * ans[i + 1];\\n        }\\n        \\n        int leftProd = 1;\\n        for(int i = 0; i < n; i++){\\n            ans[i] = leftProd * ans[i];\\n            leftProd = leftProd * nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**TC :: O(n) and SC :: O(1)**\\n\\nwe have achieved the desired solution .. if you have come this far then thanks for coping up with my handwriting ::))",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        vector<int> ans(n, 1);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == j) continue;\\n                ans[i] = ans[i] * nums[j]; \\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        vector<int> left_Product(n);\\n        vector<int> right_Product(n);\\n        \\n        left_Product[0] = 1;\\n        for(int i = 1; i < nums.size(); i++){\\n            left_Product[i] = left_Product[i - 1] * nums[i - 1];\\n        }\\n        \\n        right_Product[n - 1] = 1;\\n        for (int j = n - 2; j >= 0; j--) {\\n            right_Product[j] = right_Product[j + 1] * nums[j + 1];\\n        }\\n        \\n        for (int k = 0; k < n; k++) {\\n            ans[k]= left_Product[k] * right_Product[k];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> ans(n);\\n        \\n        ans[n - 1] = 1; // ans array used as right product array\\n        \\n        for(int i = n - 2; i >= 0; i--){\\n            ans[i] = nums[i + 1] * ans[i + 1];\\n        }\\n        \\n        int leftProd = 1;\\n        for(int i = 0; i < n; i++){\\n            ans[i] = leftProd * ans[i];\\n            leftProd = leftProd * nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 135882,
                "title": "a-java-solution-with-an-explanation",
                "content": "### Problem\\nGiven an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].\\n\\n### Solution\\n\\nI\\'ll put the solution here, just so you don\\'t have to scroll; but I\\'m told my explanation helps understanding how to think about the problem in a way that doesn\\'t seem like magic. \\n\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        // Left is an array containing the left products\\n        // i.e: left[i] = nums[0] * .... * nums[i-1]  * nums[i]\\n        int[] left = new int[nums.length];\\n        \\n        // Right is an array containing the array products\\n        //i.e: right[i] = nums[i] * nums[i+1]  * .... * nums[len(nums)]\\n        int[] right = new int[nums.length];\\n        \\n        left[0] = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            left[i] = left[i-1] * nums[i-1];\\n        }\\n        \\n        right[nums.length - 1] = 1;\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            right[i] = right[i+1] * nums[i+1];\\n        }\\n        \\n        int[] product = new int[nums.length];\\n        for (int i = 0; i < product.length; i++) {\\n            product[i] = left[i] * right[i];\\n        }\\n        \\n        return product;\\n    }\\n}\\n```\\n\\n### Background\\nBefore we look at the contraints, let\\'s just think of solving the problem as is.\\n\\nAt first glance, it becomes evident that we could easily solve this problem in one of two ways:\\n1. Calculate the product of every item in the array `nums`. Then create a `result` array of the same length as `nums`, such that for each item in result `result[i] = product / nums[i]`. This is super simple, and runs in `O(n)`. \\n2. Create a `result` array of the same size as `nums`. We can calculate the results array by:\\n\\n\\t```\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tresults[i] = 1;\\n\\t\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\tif (i != j) {\\n\\t\\t\\t\\t\\tresult[i] *= nums[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n\\t```\\n\\tNow, in this second attempt, what are we actually doing? For each item in the `nums` array, we manage to get the product of everything in `nums` but that item itself. How would we explain this a bit more mathematically? Let\\'s try to define how we calculate `results[i]`:\\n\\t```\\n\\tFor all i in the middle of nums (i.e., not at either end):\\n\\t    results[i] = nums[0] * ...... * nums[i-1] * nums[i + 1] * ...... * nums[nums.length - 1]\\n\\t\\n\\tFor i = 0:\\n\\t    results[i] = nums[i + 1] * ...... * nums[nums.length - 1]\\n\\t\\t\\t\\n\\tFor i = nums.length - 1:\\n\\t    results[i] = nums[0] * ...... * nums[i-1]\\n\\t```\\n\\t\\n\\tHopefully this spells it out a bit better. **Essentially, to get results[i], for any i, we calculate the product everything to the left and to the right of nums[i]**. Keep this in mind for later!\\n\\t\\n### Insight\\nWe know the constraints, and we need to come up with a solution!\\n\\n#### Left and Right Products\\nLet\\'s say we have an array of integers: [1, 2, 3, 4, 5, 6, 7, 8]. Let\\'s calculate the product of all items except for the 4 (index = 3)\\n```\\n1 * 2 * 3 * 5 * 6 * 7 * 8\\n```\\n\\nis how we would do that. This product is the product of everything to the left and to the right of 4. This is equivalent to doing:\\n```\\n(1 * 2 * 3) * (5 * 6 * 7 * 8)\\n```\\nThis is the product of the left product (the product of everything on the left) and the right product (the product of everything on the right)\\n**Now, for any i-th item in nums we should be able to calculate the product of everything but itself, by multiplying its left and right product!**\\n\\n#### Finding the Left Products (and Right Products) can be done in O(n)!\\nLet\\'s try to calculate a left product array, such that for `left[i]` = the product of everything to the left of nums[i], using this example (`[1,2,3,4]`).\\n\\n`left[0] = 1` (There is nothing to the left of nums[0], so we set it to 1)\\n`left[1] = 1` (1 is to the left of nums[0], so we set it to 1)\\n`left[2] = 1 * 2`\\n`left[3] = 1 * 2 * 3`\\n\\nLook for the pattern in those products (There\\'s a pattern here!)\\n`left[1] = 1  = left[0] * 1 = left[0] * nums[0]`\\n`left[2] = 1 * 2 = left[1] * 2 = left[1] * nums[1] `\\n`left[3] = 1 * 2 * 3 = left[2] * 3 = left[2] * nums[2]`\\n\\n**The pattern: `left[i] = left[i-1] * nums[i-1]` !!!**\\n\\nWe can show a similar situation for the right product array-> `right[i] = right[i+1] * nums[i+1]`\\n\\n`right[3] = 1` (There is nothing to the left of nums[3], so we set it to 1)\\n`right[2] = 4` (4 is to the right of nums[2])\\n`right[1] = 4 * 3`\\n`right[0] = 4 * 3 * 2`\\n\\nLook for the pattern in those products (There\\'s a pattern here!)\\n`right[2] = 4  = right[3] * 4 = right[3] * nums[3]`\\n`right[1] = 4 * 3 = right[2] * 3 = right[2] * nums[2] `\\n`right[0] = 4 * 3 * 2 = right[1] * 2 = right[1] * nums[1]`\\n\\n\\n#### Solution\\nNow that we know how to calculate the left product array and right product array, we can simply say that `results[i] = left[i] * right[i]`!!\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        // Left is an array containing the left products\\n        // i.e: left[i] = nums[0] * .... * nums[i-1]  * nums[i]\\n        int[] left = new int[nums.length];\\n        \\n        // Right is an array containing the array products\\n        //i.e: right[i] = nums[i] * nums[i+1]  * .... * nums[len(nums)]\\n        int[] right = new int[nums.length];\\n        \\n        left[0] = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            left[i] = left[i-1] * nums[i-1];\\n        }\\n        \\n        right[nums.length - 1] = 1;\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            right[i] = right[i+1] * nums[i+1];\\n        }\\n        \\n        int[] product = new int[nums.length];\\n        for (int i = 0; i < product.length; i++) {\\n            product[i] = left[i] * right[i];\\n        }\\n        \\n        return product;\\n    }\\n}\\n```\n```\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tresults[i] = 1;\\n\\t\\t\\tfor (int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\tif (i != j) {\\n\\t\\t\\t\\t\\tresult[i] *= nums[j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t}\\n\\t```\n```\\n\\tFor all i in the middle of nums (i.e., not at either end):\\n\\t    results[i] = nums[0] * ...... * nums[i-1] * nums[i + 1] * ...... * nums[nums.length - 1]\\n\\t\\n\\tFor i = 0:\\n\\t    results[i] = nums[i + 1] * ...... * nums[nums.length - 1]\\n\\t\\t\\t\\n\\tFor i = nums.length - 1:\\n\\t    results[i] = nums[0] * ...... * nums[i-1]\\n\\t```\n```\\n1 * 2 * 3 * 5 * 6 * 7 * 8\\n```\n```\\n(1 * 2 * 3) * (5 * 6 * 7 * 8)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996710,
                "title": "o-n-single-pass-solution-in-python-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLike any other problem, my first intuition was let\\'s brute force the solution by having two pointers going from i-1 to 1 and i+1 to len(nums) and multiplying each element and then appending this result to the output array. However, on secondary thought (and mainly due to solving questions such as Prefix Sum and Postfix Sum before), I could observe that we can use similar concept like Prefix and Postfix.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use the fact that prefix_product of arr[i] is arr[0] * arr[1] * .. * arr[i-1] and postfix_product of arr[i] is arr[i+1] * arr[i+2] * .. * arr[n-1]. \\n\\nSo basically, we have to calculate   prefix_product * postfix_product[i] for each element.\\n\\nMost solutions implementing the concept of Prefix and Postfix would suggest 2 traversals, however I felt that we could one-up that and come up with a single traversal solution.\\n\\n*1. Initialize a Solution Array of same size as input array with value.*\\n*2. Store Prefix and Postfix Product so far in variables.*\\n*3. Traverse the input array.*\\n*4. Before updating the values for each i, multiply current solution array value at i with the value of prefix i.e. multiply with prefix product of the previous i-1 elements.*\\n*5. Similarly, calculate the postfix product value for n-i-1 where n is length of input array at each iteration.*\\n*6. As in Step 4, before calculating the postfix for i\\'th value , multiply the solution_array[n-i-1] with the postfix product value i.e. products of input[i+1] to input[n-1].*\\n\\nPlease do like the solution if you understood it. Helps boosting visibility :-P\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ Single Pass [Should technically be 100% faster than other solutions but Leetcode showing only 85%. Don\\'t know why]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Technically $$O(1)$$ as we are not supposed to count the output array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        length=len(nums)\\n        sol=[1]*length\\n        pre = 1\\n        post = 1\\n        for i in range(length):\\n            sol[i] *= pre\\n            pre = pre*nums[i]\\n            sol[length-i-1] *= post\\n            post = post*nums[length-i-1]\\n        return(sol)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        length=len(nums)\\n        sol=[1]*length\\n        pre = 1\\n        post = 1\\n        for i in range(length):\\n            sol[i] *= pre\\n            pre = pre*nums[i]\\n            sol[length-i-1] *= post\\n            post = post*nums[length-i-1]\\n        return(sol)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580519,
                "title": "python-one-pass-o-1-space-no-division",
                "content": "\\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        ans = [1 for _ in nums]\\n        \\n        left = 1\\n        right = 1\\n        \\n        for i in range(len(nums)):\\n            ans[i] *= left\\n            ans[-1-i] *= right\\n            left *= nums[i]\\n            right *= nums[-1-i]\\n        \\n        return ans",
                "solutionTags": [],
                "code": "\\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        ans = [1 for _ in nums]\\n        \\n        left = 1\\n        right = 1\\n        \\n        for i in range(len(nums)):\\n            ans[i] *= left\\n            ans[-1-i] *= right\\n            left *= nums[i]\\n            right *= nums[-1-i]\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 65632,
                "title": "my-solution-beats-100-java-solutions",
                "content": "The idea is simply. The product basically is calculated using the numbers before the current number and the numbers after the current number. Thus, we can scan the array twice. First, we calcuate the running product of the part before the current number. Second, we calculate the running product of the part after the current number through scanning from the end of the array.\\n\\n    public class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int leng = nums.length;\\n        int[] ret = new int[leng];\\n        if(leng == 0)\\n            return ret;\\n        int runningprefix = 1;\\n        for(int i = 0; i < leng; i++){\\n            ret[i] = runningprefix;\\n            runningprefix*= nums[i];\\n        }\\n        int runningsufix = 1;\\n        for(int i = leng -1; i >= 0; i--){\\n            ret[i] *= runningsufix;\\n            runningsufix *= nums[i];\\n        }\\n        return ret;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int leng = nums.length;\\n        int[] ret = new int[leng];\\n        if(leng == 0)\\n            return ret;\\n        int runningprefix = 1;\\n        for(int i = 0; i < leng; i++){\\n            ret[i] = runningprefix;\\n            runningprefix*= nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 210147,
                "title": "java-python-thinking-process-with-followup",
                "content": "The invariant is\\n```\\nproduct of array except nums[i] = product of numbers to the left of nums[i] * product of numbers to the right of nums[i]\\n```\\nPlease note that nums[0] doesn\\'t have elements to its left, and nums[n-1] doesn\\'t have elements to its right. Thus\\n```\\nleftProduct[0] = 1;\\nrightProduct[n - 1] = 1;\\n```\\n**O(n) time without division**\\n```\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        // leftProduct[i] is product of numbers to the left of i.\\n        int[] leftProduct = new int[n];\\n        // rightProduct[i] is product of numbers to the right of i.\\n        int[] rightProduct = new int[n];\\n        // productExceptSelf[i] is product of array except self.\\n        int[] productExceptSelf = new int[n];\\n        \\n        leftProduct[0] = 1; // Without numbers to its left.\\n        rightProduct[n - 1] = 1; // Without numbers to its right.\\n        \\n        for (int i = 1; i < n; i++) {\\n            leftProduct[i] = leftProduct[i - 1] * nums[i - 1];\\n        }\\n        for (int i = n - 2; i >= 0; i--) {\\n            rightProduct[i] = rightProduct[i + 1] * nums[i + 1];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            productExceptSelf[i] = leftProduct[i] * rightProduct[i]; \\n        }\\n        \\n        return productExceptSelf;\\n    }\\n```\\n**Followup: with constant space complexity**\\nWe make productExceptSelf act as leftProduct then rightProduct.\\n```\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        // productExceptSelf[i] is product of array except self.\\n        int[] productExceptSelf = new int[n];\\n        \\n        productExceptSelf[0] = 1; // Without numbers to its left.\\n        for (int i = 1; i < n; i++) {\\n            productExceptSelf[i] = productExceptSelf[i - 1] * nums[i - 1];\\n        }\\n        \\n        // Product of numbers to the right of current element.\\n        int productOfRightNums = 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            productOfRightNums = productOfRightNums * nums[i + 1];\\n            productExceptSelf[i] *= productOfRightNums;\\n        }\\n        \\n        return productExceptSelf;\\n    }\\n```\\n**Python**\\n```\\n    def productExceptSelf(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        numsLen = len(nums)\\n        productWithoutSelf = [1] * numsLen\\n        \\n        # productWithoutSelf[i] as product of elements to the left of nums[i].\\n        for i in range(1, numsLen):\\n            productWithoutSelf[i] = productWithoutSelf[i - 1] * nums[i - 1]\\n        \\n        # productWithoutSelf[i] multiply product of elements to the right of nums[i].\\n        rightProduct = 1\\n        for i in range(numsLen - 1, -1, -1):\\n            productWithoutSelf[i] *= rightProduct\\n            rightProduct = rightProduct * nums[i]\\n            \\n        return productWithoutSelf\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\nproduct of array except nums[i] = product of numbers to the left of nums[i] * product of numbers to the right of nums[i]\\n```\n```\\nleftProduct[0] = 1;\\nrightProduct[n - 1] = 1;\\n```\n```\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        // leftProduct[i] is product of numbers to the left of i.\\n        int[] leftProduct = new int[n];\\n        // rightProduct[i] is product of numbers to the right of i.\\n        int[] rightProduct = new int[n];\\n        // productExceptSelf[i] is product of array except self.\\n        int[] productExceptSelf = new int[n];\\n        \\n        leftProduct[0] = 1; // Without numbers to its left.\\n        rightProduct[n - 1] = 1; // Without numbers to its right.\\n        \\n        for (int i = 1; i < n; i++) {\\n            leftProduct[i] = leftProduct[i - 1] * nums[i - 1];\\n        }\\n        for (int i = n - 2; i >= 0; i--) {\\n            rightProduct[i] = rightProduct[i + 1] * nums[i + 1];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            productExceptSelf[i] = leftProduct[i] * rightProduct[i]; \\n        }\\n        \\n        return productExceptSelf;\\n    }\\n```\n```\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        // productExceptSelf[i] is product of array except self.\\n        int[] productExceptSelf = new int[n];\\n        \\n        productExceptSelf[0] = 1; // Without numbers to its left.\\n        for (int i = 1; i < n; i++) {\\n            productExceptSelf[i] = productExceptSelf[i - 1] * nums[i - 1];\\n        }\\n        \\n        // Product of numbers to the right of current element.\\n        int productOfRightNums = 1;\\n        for (int i = n - 2; i >= 0; i--) {\\n            productOfRightNums = productOfRightNums * nums[i + 1];\\n            productExceptSelf[i] *= productOfRightNums;\\n        }\\n        \\n        return productExceptSelf;\\n    }\\n```\n```\\n    def productExceptSelf(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        numsLen = len(nums)\\n        productWithoutSelf = [1] * numsLen\\n        \\n        # productWithoutSelf[i] as product of elements to the left of nums[i].\\n        for i in range(1, numsLen):\\n            productWithoutSelf[i] = productWithoutSelf[i - 1] * nums[i - 1]\\n        \\n        # productWithoutSelf[i] multiply product of elements to the right of nums[i].\\n        rightProduct = 1\\n        for i in range(numsLen - 1, -1, -1):\\n            productWithoutSelf[i] *= rightProduct\\n            rightProduct = rightProduct * nums[i]\\n            \\n        return productWithoutSelf\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 65663,
                "title": "javascript-solution-if-anyone-is-interested",
                "content": "    var productExceptSelf = function(nums) {\\n        var output = [];\\n        var leftMult = 1;\\n        var rightMult = 1;\\n        for (var i=nums.length - 1; i >= 0; i--) {\\n            output[i] = rightMult;\\n            rightMult *= nums[i];\\n        }\\n        for (var j=0; j < nums.length; j++) {\\n            output[j] *= leftMult;\\n            leftMult *= nums[j];\\n        }\\n        return output;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var productExceptSelf = function(nums) {\\n        var output = [];\\n        var leftMult = 1;\\n        var rightMult = 1;\\n        for (var i=nums.length - 1; i >= 0; i--) {\\n            output[i] = rightMult;\\n            rightMult *= nums[i];\\n        }\\n        for (var j=0; j < nums.length; j++) {\\n            output[j] *= leftMult;\\n            leftMult *= nums[j];\\n        }\\n        return output;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 694266,
                "title": "javascript-solution-no-division-with-explanation",
                "content": "I\\'ve tried to explain the logic to the best of my capability. :)\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\n/*\\n[1,2,3,4]\\nThe array should be multiplication of all values except the index that we are currenty on:\\n[2x3x4 (not 1), \\n1x3x4 (not 2), \\n1x2x4 (not 3), \\n1x2x3  (not 4)] = [24, 12, 8 , 6]\\n\\nIn this problem, if division was allowed:\\n1. We run a loop on array and get 1x2x3x4 = 24.\\n2. we run another array, and for each index:\\n  24/1 = 24\\n  24/2 = 12\\n  24/3 = 8\\n  24/4 = 6\\n------------------------------------------------\\nWithout division:\\n\\nwe create 2 arrays:\\n\\n1 array with incremental multiplication from left, 1 array with incremental multiplication from right.\\n\\nat the start index of these arrays, we\\'ll have 1 (as no multiplication prior to it).\\n\\nleft arr = [1, (1)x1, (1x1)x2, (1x1x2)x3] = [1, 1, 2, 6]\\n\\nright arr = [(1x4x3)x2, (1x4)x3, (1)x4 ,1] = [24, 12, 4, 1]\\n\\nnow, at each index, in left array, we\\'ll have mutiple of left elements prior that index.\\n\\nIn right array, we\\'ll have mutiple of right elements ahead of that index.\\n\\nSo, we\\'ll multiply [1, 1, 2, 6] X  [24, 12, 4, 1] at each index.\\n\\nResult = [24, 12, 8, 6]\\n\\n1 array \\n\\n*/\\nvar productExceptSelf = function(nums) {\\n\\n  let leftArr = [];\\n  let leftMultiplication = 1;\\n\\n  for (let i=0; i < nums.length; i++) {\\n    leftArr[i] = leftMultiplication;\\n    leftMultiplication *=  nums[i];\\n  }\\n    \\n  let rightArr = [];\\n  let rightMultiplication = 1;\\n\\n  for (let i=nums.length-1; i >= 0; i--) {\\n    rightArr[i] = rightMultiplication;\\n    rightMultiplication *= nums[i];\\n    rightArr[i] *= leftArr[i]; //this additional step saves us from having another iteration. We can do the multiplication at the spot.\\n  }\\n  \\n  return rightArr;\\n  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\n/*\\n[1,2,3,4]\\nThe array should be multiplication of all values except the index that we are currenty on:\\n[2x3x4 (not 1), \\n1x3x4 (not 2), \\n1x2x4 (not 3), \\n1x2x3  (not 4)] = [24, 12, 8 , 6]\\n\\nIn this problem, if division was allowed:\\n1. We run a loop on array and get 1x2x3x4 = 24.\\n2. we run another array, and for each index:\\n  24/1 = 24\\n  24/2 = 12\\n  24/3 = 8\\n  24/4 = 6\\n------------------------------------------------\\nWithout division:\\n\\nwe create 2 arrays:\\n\\n1 array with incremental multiplication from left, 1 array with incremental multiplication from right.\\n\\nat the start index of these arrays, we\\'ll have 1 (as no multiplication prior to it).\\n\\nleft arr = [1, (1)x1, (1x1)x2, (1x1x2)x3] = [1, 1, 2, 6]\\n\\nright arr = [(1x4x3)x2, (1x4)x3, (1)x4 ,1] = [24, 12, 4, 1]\\n\\nnow, at each index, in left array, we\\'ll have mutiple of left elements prior that index.\\n\\nIn right array, we\\'ll have mutiple of right elements ahead of that index.\\n\\nSo, we\\'ll multiply [1, 1, 2, 6] X  [24, 12, 4, 1] at each index.\\n\\nResult = [24, 12, 8, 6]\\n\\n1 array \\n\\n*/\\nvar productExceptSelf = function(nums) {\\n\\n  let leftArr = [];\\n  let leftMultiplication = 1;\\n\\n  for (let i=0; i < nums.length; i++) {\\n    leftArr[i] = leftMultiplication;\\n    leftMultiplication *=  nums[i];\\n  }\\n    \\n  let rightArr = [];\\n  let rightMultiplication = 1;\\n\\n  for (let i=nums.length-1; i >= 0; i--) {\\n    rightArr[i] = rightMultiplication;\\n    rightMultiplication *= nums[i];\\n    rightArr[i] *= leftArr[i]; //this additional step saves us from having another iteration. We can do the multiplication at the spot.\\n  }\\n  \\n  return rightArr;\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65848,
                "title": "concise-python-solution-constant-space-left-to-right-then-right-to-left",
                "content": "        \\n    # two-round solution     \\n    def productExceptSelf(self, nums):\\n        res = [1] * len(nums)\\n        for i in xrange(1, len(nums)): # from left to right \\n            res[i] = res[i-1] * nums[i-1]\\n        tmp = 1\\n        for i in xrange(len(nums)-2, -1, -1): # from right to left\\n            tmp *= nums[i+1]\\n            res[i] *= tmp\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    # two-round solution     \\n    def productExceptSelf(self, nums):\\n        res = [1] * len(nums)\\n        for i in xrange(1, len(nums)): # from left to right \\n            res[i] = res[i-1] * nums[i-1]\\n        tmp = 1\\n        for i in xrange(len(nums)-2, -1, -1): # from right to left\\n            tmp *= nums[i+1]\\n            res[i] *= tmp\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 65667,
                "title": "my-one-pass-java-solution-without-extra-spaces",
                "content": "One pass, if don't count the initialization of the 'result'...\\n\\n        int[] result = new int[nums.length];\\n        for (int i = 0; i < result.length; i++) result[i] = 1;\\n        int left = 1, right = 1;\\n        for (int i = 0, j = nums.length - 1; i < nums.length - 1; i++, j--) {\\n            left *= nums[i];\\n            right *= nums[j];\\n            result[i + 1] *= left;\\n            result[j - 1] *= right;\\n        }\\n        return result;\\n\\n-\\n\\nedit 2016/04/05:\\n\\n**EXPLAINATION:**\\n\\nThinking of the 'nums' array [1, 2, 3, 4, 5, 6], and the 'result' array [1, 1, 1, 1, 1, 1]. Every number in 'nums' will be multiplied in 'result' array except itself, then we will get the map below:\\n\\n\\n      1 2 3 4 5 6\\n      -----------\\n    1|  1 1 1 1 1\\n    2|2   2 2 2 2\\n    3|3 3   3 3 3\\n    4|4 4 4   4 4\\n    5|5 5 5 5   5\\n    6|6 6 6 6 6\\n    \\n    (horizontal axis is nums array, vertical axis is multiplied times)\\n\\n\\nNoticed the regular pattern of the upper triangular and lower triangular. Using integers to store the products of the lower and upper triangulars, then we can do it in one pass:\\n\\n- i : left index of the nums array\\n- j : right index of the nums array\\n- left : left products multiplied from nums[0] to nums[i].\\n- right : right products multiplied from nums[j] to nums[nums.length - 1].\\n\\nWe multiply left to result[i + 1] ((i, i + 1) in the uppper triangular),\\n\\nand multiply right to result[j - 1] ((j, j - 1) in the lower triangular),\\n\\nfinally we have calculated the products of the nums except current.\\n\\n-\\n\\nSorry for my poor English...= =!\\nChecking more of my solutions at: https://github.com/dss886/LeetCode/tree/master/src/leetcode",
                "solutionTags": [
                    "Java"
                ],
                "code": "One pass, if don't count the initialization of the 'result'...\\n\\n        int[] result = new int[nums.length];\\n        for (int i = 0; i < result.length; i++) result[i] = 1;\\n        int left = 1, right = 1;\\n        for (int i = 0, j = nums.length - 1; i < nums.length - 1; i++, j--) {\\n            left *= nums[i];\\n            right *= nums[j];\\n            result[i + 1] *= left;\\n            result[j - 1] *= right;\\n        }\\n        return result;\\n\\n-\\n\\nedit 2016/04/05:\\n\\n**EXPLAINATION:**\\n\\nThinking of the 'nums' array [1, 2, 3, 4, 5, 6], and the 'result' array [1, 1, 1, 1, 1, 1]. Every number in 'nums' will be multiplied in 'result' array except itself, then we will get the map below:\\n\\n\\n      1 2 3 4 5 6\\n      -----------\\n    1|  1 1 1 1 1\\n    2|2   2 2 2 2\\n    3|3 3   3 3 3\\n    4|4 4 4   4 4\\n    5|5 5 5 5   5\\n    6|6 6 6 6 6\\n    \\n    (horizontal axis is nums array, vertical axis is multiplied times)\\n\\n\\nNoticed the regular pattern of the upper triangular and lower triangular. Using integers to store the products of the lower and upper triangulars, then we can do it in one pass:\\n\\n- i : left index of the nums array\\n- j : right index of the nums array\\n- left : left products multiplied from nums[0] to nums[i].\\n- right : right products multiplied from nums[j] to nums[nums.length - 1].\\n\\nWe multiply left to result[i + 1] ((i, i + 1) in the uppper triangular),\\n\\nand multiply right to result[j - 1] ((j, j - 1) in the lower triangular),\\n\\nfinally we have calculated the products of the nums except current.\\n\\n-\\n\\nSorry for my poor English...= =!\\nChecking more of my solutions at: https://github.com/dss886/LeetCode/tree/master/src/leetcode",
                "codeTag": "Unknown"
            },
            {
                "id": 2005799,
                "title": "javascript-solution-with-explanation-and-code-comments",
                "content": "The trick with this one, as is the case with many array-based problems, is to find a key insight about how the math works out at each position.\\n\\nConsider the example input: `[1,2,3,4]`\\n\\nAnd its output: `[24,12,8,6]`\\n\\nLet\\'s ignore the first index, since it\\'ll end up being a special case. Look at `input[1]`, which has a value of `2`. The output we want is `12`, which we can get with `1 * 3 * 4`, all the elements except `2`. \\n\\nThe key insight is that it\\'s not just `1 * 3 * 4` that we want, but rather, we want `product of all left elements * product of all right elements`, which in this case is `(1) * (3 * 4)`. If, for every index in the input array, we knew the product of all elements to its left, and the product of all elements to its right, we could determine the product of the array except itself - without having to use a division operation, as the problem asked us to. \\n\\nLet\\'s talk about the straightforward way to approach this, and then we can dig into the optimized space solution afterwards\\n\\n### Building Prefix and Suffix Arrays\\n\\nWe can solve this problem in linear time and space with three passes: \\n\\n1. On the first pass, iterate through the array and create an array of prefixes, which give us the `product of all left elements` for each position\\n2. On the second pass, iterate through the array and create an array of suffixes, which give us the `product of all right elements` for each position\\n3. On the third pass, build a result array that contains the product of `prefixes[i] * suffixes[i]` for each position, and return this as our answer.\\n\\nThere are two special cases to consider: \\n\\n1. The prefix value of the first element in the array should just be `1`, since there are no values to the left of it. \\n1. The suffix value of the last element in the array should just be `1`, since there are no values to the right of it. \\n\\n\\nHere\\'s how we can express that in JavaScript: \\n\\n```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function(nums) {\\n    // First, create a prefix array that moves from the left,\\n    // gathering the running product of the prefix at each index\\n    const prefix = []\\n    \\n    // Move left in the input array\\n    for (let i=0; i<nums.length; i++) {\\n        // If i === 0, start with `1`, since there is no prefix\\n        if (i===0) {\\n            prefix[i] = 1\\n        } else {\\n            // Otherwise, multiply nums[i-1] times the prefix at position i-1,\\n            // and add that to the prefix array at position i\\n            prefix[i] = nums[i-1] * prefix[i-1]\\n        }\\n    }\\n    \\n    // Then, let\\'s create a suffix array\\n    const suffix = []\\n    \\n    // Move right in the input array\\n    for (let i=nums.length - 1; i>=0; i--) {\\n        // For the last index, we have no suffix, so just add a 1 to that position\\n        if (i===nums.length - 1) {\\n            suffix[i] = 1\\n        } else {\\n            // Otherwise, we multiply nums[i+1] by the suffix at position i+1\\n            // and add that to the suffix array at position i\\n            suffix[i] = nums[i + 1] * suffix[i + 1]\\n        }\\n    }\\n    \\n    // Finally, our result array should be the products of prefix * suffix for each position\\n    const result = []\\n    \\n    for (let i=0; i<nums.length; i++) {\\n        result[i] = prefix[i] * suffix[i]\\n    }\\n    \\n    return result\\n};\\n```\\n\\n### Solving in Constant Space\\n\\nThe follow-up asks us if we can identify a solution that just uses constant space. Fortunately, the solution is the same - we just need to change the way we keep track of everything. Instead of three arrays, we\\'ll create one new array, and we\\'ll do our forward pass and bckwards pass, keeping track of the prefix and suffix values as we go. \\n\\nHere\\'s what that looks like in JavaScript (with comments, to explain how we keep track of the prefix/suffix/final results):\\n\\n```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function(nums) {\\n    // Set up an empty array as our result\\n    const result = []\\n    \\n    // Initialize a prefix tracker at 1\\n    let prefix = 1\\n    \\n    // Loop through the input array - for each position,\\n    // the result array should equal the prefix tracker.\\n    \\n    // Then, update the prefix tracker to be the product of itself,\\n    // multiplied by the input value at the position.\\n    for (let i=0; i<nums.length; i++) {\\n        result[i] = prefix\\n        prefix *= nums[i]\\n    }\\n    \\n    // Initialize a suffix tracker at 1\\n    let suffix = 1\\n    \\n    // Loop backwards through the array.\\n    // For each iteration, set the result array to be \\n    // the product of itself multiplied by the suffix tracker.\\n    \\n    // Then, update the suffix tracker to be the product of itself,\\n    // multiplied by the input value at that position.\\n    for (let i=nums.length - 1; i>=0; i--) {\\n        result[i] *= suffix\\n        suffix *= nums[i]\\n    }\\n\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function(nums) {\\n    // First, create a prefix array that moves from the left,\\n    // gathering the running product of the prefix at each index\\n    const prefix = []\\n    \\n    // Move left in the input array\\n    for (let i=0; i<nums.length; i++) {\\n        // If i === 0, start with `1`, since there is no prefix\\n        if (i===0) {\\n            prefix[i] = 1\\n        } else {\\n            // Otherwise, multiply nums[i-1] times the prefix at position i-1,\\n            // and add that to the prefix array at position i\\n            prefix[i] = nums[i-1] * prefix[i-1]\\n        }\\n    }\\n    \\n    // Then, let\\'s create a suffix array\\n    const suffix = []\\n    \\n    // Move right in the input array\\n    for (let i=nums.length - 1; i>=0; i--) {\\n        // For the last index, we have no suffix, so just add a 1 to that position\\n        if (i===nums.length - 1) {\\n            suffix[i] = 1\\n        } else {\\n            // Otherwise, we multiply nums[i+1] by the suffix at position i+1\\n            // and add that to the suffix array at position i\\n            suffix[i] = nums[i + 1] * suffix[i + 1]\\n        }\\n    }\\n    \\n    // Finally, our result array should be the products of prefix * suffix for each position\\n    const result = []\\n    \\n    for (let i=0; i<nums.length; i++) {\\n        result[i] = prefix[i] * suffix[i]\\n    }\\n    \\n    return result\\n};\\n```\n```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function(nums) {\\n    // Set up an empty array as our result\\n    const result = []\\n    \\n    // Initialize a prefix tracker at 1\\n    let prefix = 1\\n    \\n    // Loop through the input array - for each position,\\n    // the result array should equal the prefix tracker.\\n    \\n    // Then, update the prefix tracker to be the product of itself,\\n    // multiplied by the input value at the position.\\n    for (let i=0; i<nums.length; i++) {\\n        result[i] = prefix\\n        prefix *= nums[i]\\n    }\\n    \\n    // Initialize a suffix tracker at 1\\n    let suffix = 1\\n    \\n    // Loop backwards through the array.\\n    // For each iteration, set the result array to be \\n    // the product of itself multiplied by the suffix tracker.\\n    \\n    // Then, update the suffix tracker to be the product of itself,\\n    // multiplied by the input value at that position.\\n    for (let i=nums.length - 1; i>=0; i--) {\\n        result[i] *= suffix\\n        suffix *= nums[i]\\n    }\\n\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1598117,
                "title": "python3-o-1-space-and-o-n-time-explained",
                "content": "The product of elements except the `i`<sub>th</sub> one is equal to a product of elements on the left side and on the right side of that element. So the idea is to do two passes over the input `nums` and use an auxiliary list `res` to store intermediate results. First pass we do from the start to the end and on each iteration we store the accumulated product in the `res`  at the according index such that the value of the `res` at the `i`<sub>th</sub> index equal to product of all elements in `nums` starting from 0 to `i-1`, i.e: `res[i] = product(nums[0:i-1])`. The second pass we do from the end to the start of the `nums`. We again accumulate a product of met elements and modify the `res` such that the value at the index `i` is equal to the product of the value at this index and accumulated value from the pass. In the end, the `res` is the required answer.\\n\\nTime: **O(n)** for two passes over nums\\nSpace: **O(1)** since the result doesn\\'t count against the space complexity\\n\\nRuntime: 228 ms, faster than **92.58%** of Python3 online submissions for Product of Array Except Self.\\nMemory Usage: 21.1 MB, less than **58.80%** of Python3 online submissions for Product of Array Except Self.\\n\\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        res = []\\n        \\n        acc = 1\\n        for n in nums:\\n            res.append(acc)\\n            acc *= n\\n\\n        acc = 1\\n        for i in reversed(range(len(nums))):\\n            res[i] *= acc\\n            acc *= nums[i]\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        res = []\\n        \\n        acc = 1\\n        for n in nums:\\n            res.append(acc)\\n            acc *= n\\n\\n        acc = 1\\n        for i in reversed(range(len(nums))):\\n            res[i] *= acc\\n            acc *= nums[i]\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65789,
                "title": "super-easy-java-solution-in-o-n-time-and-o-1-space",
                "content": "You traverse twice, applying the appropriate multiplier.\\n      \\n    public int[] productExceptSelf(int[] nums) {\\n    \\n        int len = nums.length;\\n        int [] output = new int[len];\\n        \\n        int leftMult = 1, rightMult = 1;\\n        \\n        for(int i = len-1; i >= 0; i--){\\n            output[i] = rightMult;\\n            rightMult *= nums[i];\\n        }\\n        for(int j = 0; j < len; j++){\\n            output[j] *= leftMult;\\n            leftMult *= nums[j];\\n           \\n        }\\n        \\n        return output; \\n\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "You traverse twice, applying the appropriate multiplier.\\n      \\n    public int[] productExceptSelf(int[] nums) {\\n    \\n        int len = nums.length;\\n        int [] output = new int[len];\\n        \\n        int leftMult = 1, rightMult = 1;\\n        \\n        for(int i = len-1; i >= 0; i--){\\n            output[i] = rightMult;\\n            rightMult *= nums[i];\\n        }\\n        for(int j = 0; j < len; j++){\\n            output[j] *= leftMult;\\n            leftMult *= nums[j];\\n           \\n        }\\n        \\n        return output; \\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3938575,
                "title": "video-visualization-and-explanation-of-o-n-solution",
                "content": "https://youtu.be/5bS636lE_R0?si=CXD7IT3sxRkONnAe\\n\\nThe brute force method would be to manually calculate each product.  Since there are n products to calculate, and each product is made up of n-1 numbers, this runs in O(n<sup>2</sup>) time.\\n\\nThis method causes us to do the same calculations over and over again.  So instead, we\\'ll calculate all the products to the left and right of any given element just once and reuse those calculations.  This allows us to reduce the runtime to O(n).\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        length = len(nums)\\n        products = [1] * length\\n        for i in range(1, length):\\n            products[i] = products[i-1] * nums[i-1]\\n\\n        right = nums[-1]\\n        for i in range(length-2, -1, -1):\\n            products[i] *= right\\n            right *= nums[i]\\n        \\n        return products\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        length = len(nums)\\n        products = [1] * length\\n        for i in range(1, length):\\n            products[i] = products[i-1] * nums[i-1]\\n\\n        right = nums[-1]\\n        for i in range(length-2, -1, -1):\\n            products[i] *= right\\n            right *= nums[i]\\n        \\n        return products\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018111,
                "title": "c-simple-1-pass-2-pass-solutions-o-n-time-o-1-space-faster-than-99",
                "content": "**2 passes - first multiply by all elements in the right, then go from the end and multiply by all elements in the left:**\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size(), temp = 1;\\n        vector<int> res(n);\\n        \\n        // Put in each index in res the product of all elements before it:\\n        for (int i=0; i<n; i++) {\\n            res[i] = temp;\\n            temp *= nums[i];\\n        }\\n        \\n        // Now multiply each one with all the elements after it:\\n        temp = 1;\\n        for (int i=n-1; i>=0; i--) {\\n            res[i] *= temp;\\n            temp *= nums[i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n****\\n**This solution leads to a better one -**\\n**1-pass: do it simultaneously**\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size()-1, left = 1, right = 1;\\n        vector<int> res(n+1, 1);\\n\\n        for (int i=0; i<=n; i++) {\\n            res[i] *= left;\\n            res[n-i] *= right;\\n            left *= nums[i];\\n            right *= nums[n-i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote...\\nHave any comments? I\\'d love to hear!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size(), temp = 1;\\n        vector<int> res(n);\\n        \\n        // Put in each index in res the product of all elements before it:\\n        for (int i=0; i<n; i++) {\\n            res[i] = temp;\\n            temp *= nums[i];\\n        }\\n        \\n        // Now multiply each one with all the elements after it:\\n        temp = 1;\\n        for (int i=n-1; i>=0; i--) {\\n            res[i] *= temp;\\n            temp *= nums[i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size()-1, left = 1, right = 1;\\n        vector<int> res(n+1, 1);\\n\\n        for (int i=0; i<=n; i++) {\\n            res[i] *= left;\\n            res[n-i] *= right;\\n            left *= nums[i];\\n            right *= nums[n-i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 239771,
                "title": "python-solution",
                "content": "Time complexity: `O(n)`, space complexity: `O(n)`.\\n\\n```\\nclass Solution:\\n    def productExceptSelf(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [1]*len(nums)\\n        lprod = 1\\n        rprod = 1\\n        for i in range(len(nums)):\\n            res[i] *= lprod\\n            lprod *= nums[i]\\n            res[~i] *= rprod\\n            rprod *= nums[~i]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        res = [1]*len(nums)\\n        lprod = 1\\n        rprod = 1\\n        for i in range(len(nums)):\\n            res[i] *= lprod\\n            lprod *= nums[i]\\n            res[~i] *= rprod\\n            rprod *= nums[~i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793722,
                "title": "c-easy-solution-meeting-all-requirements-explained-98-time-95-space",
                "content": "Okay, this is not an easy one and the trick is that you have to go through 2 passes, in different order.\\n\\nLet\\'s assume your initial array is `[1,2,3,4,5,6]`: if you prepare a result vector `res` of the required size (same as `nums`) and set the first value to `1` (the neuter element in multiplications), you can go on up to the end setting each cell to be the product of the previous one, plus the matching previous slot in `nums`.\\n\\nIn our case, after the first pass, we will have `[1,1,2,6,24,120]` - and please note that the last element is already of the expected value.\\n\\nNow, for the second pass, we have to start from the opposite direction (I started from left first, so I will go right now - you can try the other way around, if you want some extra challenge) and multiply each value (other than the rightmost: we are already fine with that) by `prod`, initially set to be of the value of the last element (so, in our case, the \"previous\" element, since we start from the penultimate one, in the same guise we started from the second element in the first loop) and then gradually incremented by `nums[i]` AFTER we have multiplying the `i`th cell.\\n\\nThe second loop will give us `[720,360,240,180,144,120]`, which is precisely what we wanted, so it means we are done and can now return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        // setting up the necessary variables\\n        int len = nums.size(), prod = nums[len - 1];\\n        vector<int> res(len);\\n        // ruling out an edge case\\n        if (!len) return res;\\n        // initialising res and using it for the first pass\\n        res[0] = 1;\\n        // each cell will be the product of the previous and the matching previous value in nums\\n        for (int i = 1; i < len; i++) res[i] = res[i - 1] * nums[i - 1];\\n        // second pass, from the right\\n        for (int i = --len - 1; i >= 0; --i) {\\n            res[i] *= prod;\\n            prod *= nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        // setting up the necessary variables\\n        int len = nums.size(), prod = nums[len - 1];\\n        vector<int> res(len);\\n        // ruling out an edge case\\n        if (!len) return res;\\n        // initialising res and using it for the first pass\\n        res[0] = 1;\\n        // each cell will be the product of the previous and the matching previous value in nums\\n        for (int i = 1; i < len; i++) res[i] = res[i - 1] * nums[i - 1];\\n        // second pass, from the right\\n        for (int i = --len - 1; i >= 0; --i) {\\n            res[i] *= prod;\\n            prod *= nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231758,
                "title": "238-time-96-95-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n96.95%\\n\\n- Space complexity:\\n68.31%\\n\\n# Code\\n```\\nclass Solution:\\n  def productExceptSelf(self, nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    left_product = [1] * n # initialize left_product array with 1\\n    right_product = [1] * n # initialize right_product array with 1\\n    # calculate the product of elements to the left of each element\\n    for i in range(1, n):\\n        left_product[i] = left_product[i - 1] * nums[i - 1]\\n\\n    # calculate the product of elements to the right of each element\\n    for i in range(n - 2, -1, -1):\\n        right_product[i] = right_product[i + 1] * nums[i + 1]\\n\\n    # calculate the product of all elements except nums[i]\\n    result = [left_product[i] * right_product[i] for i in range(n)]\\n\\n    return result\\n```\\nThe algorithm works by first initializing two arrays, left_product and right_product, both filled with 1\\'s. We then populate the left_product array by calculating the product of all elements to the left of each element in nums. Similarly, we populate the right_product array by calculating the product of all elements to the right of each element in nums.\\n\\nOnce we have left_product and right_product, we can calculate the product of all elements except nums[i] by multiplying the corresponding elements from left_product and right_product. We do this for each element in nums to obtain the final result.\\n\\nThe time complexity of this algorithm is O(n), which satisfies the problem\\'s requirements. The space complexity is O(n) as well, since we need to store two arrays of size n. However, we can optimize the space complexity to O(1) by using the result array to store the left_product array and computing the right_product array on-the-fly during the final calculation. Here\\'s the optimized solution:\\n\\n```\\nclass Solution:\\n  def productExceptSelf(self, nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    result = [1] * n\\n    # calculate the product of elements to the left of each element and store in result\\n    for i in range(1, n):\\n        result[i] = result[i - 1] * nums[i - 1]\\n\\n    # calculate the product of elements to the right of each element and update result\\n    right_product = 1\\n    for i in range(n - 1, -1, -1):\\n        result[i] *= right_product\\n        right_product *= nums[i]\\n\\n    return result\\n\\n```\\nIn this optimized solution, we reuse the result array to store the left_product array. We then compute the product of elements to the right of each element on-the-fly by keeping track of a running product, right_product. We update the corresponding element in result with the product of the left and right products for that element. This way, we only need to use one extra variable (right_product) instead of a whole extra array (right_product).\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n  def productExceptSelf(self, nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    left_product = [1] * n # initialize left_product array with 1\\n    right_product = [1] * n # initialize right_product array with 1\\n    # calculate the product of elements to the left of each element\\n    for i in range(1, n):\\n        left_product[i] = left_product[i - 1] * nums[i - 1]\\n\\n    # calculate the product of elements to the right of each element\\n    for i in range(n - 2, -1, -1):\\n        right_product[i] = right_product[i + 1] * nums[i + 1]\\n\\n    # calculate the product of all elements except nums[i]\\n    result = [left_product[i] * right_product[i] for i in range(n)]\\n\\n    return result\\n```\n```\\nclass Solution:\\n  def productExceptSelf(self, nums: List[int]) -> List[int]:\\n    n = len(nums)\\n    result = [1] * n\\n    # calculate the product of elements to the left of each element and store in result\\n    for i in range(1, n):\\n        result[i] = result[i - 1] * nums[i - 1]\\n\\n    # calculate the product of elements to the right of each element and update result\\n    right_product = 1\\n    for i in range(n - 1, -1, -1):\\n        result[i] *= right_product\\n        right_product *= nums[i]\\n\\n    return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 200478,
                "title": "linear-javascript-solution",
                "content": "Linear JavaScript solution that beats 100% of solutions\\n\\n```\\nvar productExceptSelf = function(nums) {\\n    const result = [];\\n    let productSoFar = 1;\\n    for (let i = 0; i < nums.length; i++) {\\n        result[i] = productSoFar\\n        productSoFar *= nums[i]\\n    }\\n    productSoFar = 1\\n    for (let j = nums.length-1; j >= 0; j--) {\\n        result[j] *= productSoFar\\n        productSoFar *= nums[j]\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar productExceptSelf = function(nums) {\\n    const result = [];\\n    let productSoFar = 1;\\n    for (let i = 0; i < nums.length; i++) {\\n        result[i] = productSoFar\\n        productSoFar *= nums[i]\\n    }\\n    productSoFar = 1\\n    for (let j = nums.length-1; j >= 0; j--) {\\n        result[j] *= productSoFar\\n        productSoFar *= nums[j]\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65747,
                "title": "how-from-o-n-to-o-1",
                "content": "Here is the O(N) based C++ implementation\\n\\n    class Solution {\\n    public:\\n        vector<int> productExceptSelf(vector<int>& nums) {\\n            int len=nums.size();\\n            vector<int> left(len, 1);\\n            vector<int> right(len, 1);\\n            vector<int> result(len, 0);\\n            for(int i=1; i<len; i++)  left[i]=left[i-1]*nums[i-1];\\n            for(int i=len-2; i>=0; i--)  right[i]=right[i+1]*nums[i+1];\\n            for(int i=0; i<len; i++) result[i]=left[i]*right[i];\\n            return result;\\n        }\\n    };\\n\\nHow to use O(1) ?\\n\\nBy observing the above code, we can just for every position multiply it to its right position.\\n\\nJust the idea to think reversly !\\n\\n    class Solution {\\n    public:\\n        vector<int> productExceptSelf(vector<int>& nums) {\\n            int n=nums.size();\\n            int left=1, right=1;\\n            vector<int> result(n, 1);\\n            for(int i=0; i<n; i++){\\n                result[i]*=left;\\n                result[n-1-i]*=right;\\n                left*=nums[i];\\n                right*=nums[n-1-i];\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> productExceptSelf(vector<int>& nums) {\\n            int len=nums.size();\\n            vector<int> left(len, 1);\\n            vector<int> right(len, 1);\\n            vector<int> result(len, 0);\\n            for(int i=1; i<len; i++)  left[i]=left[i-1]*nums[i-1];\\n            for(int i=len-2; i>=0; i--)  right[i]=right[i+1]*nums[i+1];\\n            for(int i=0; i<len; i++) result[i]=left[i]*right[i];\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 65801,
                "title": "very-easy-two-passes-solution",
                "content": "    // two passes, O(2n)\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 1);\\n        \\n        for (int i = 1; i < n; ++i) {\\n            ans[i] = ans[i-1] * nums[i-1];\\n        }\\n        \\n        int m = 1;\\n        for (int i = n-1; i >= 0; --i) {\\n            ans[i] *= m;\\n            m *= nums[i];\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "    // two passes, O(2n)\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 1);\\n        \\n        for (int i = 1; i < n; ++i) {\\n            ans[i] = ans[i-1] * nums[i-1];\\n        }\\n        \\n        int m = 1;\\n        for (int i = n-1; i >= 0; --i) {\\n            ans[i] *= m;\\n            m *= nums[i];\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 65764,
                "title": "java-o-n-without-additional-space-no-temp-accumulator-vars-either",
                "content": "Uses only return array as accumulator:\\n\\n    public class Solution {\\n        public int[] productExceptSelf(int[] nums) {\\n            int[] res = new int[nums.length];\\n    \\n            res[0] = 1;\\n            for(int i=1; i < nums.length; i++) {\\n                res[i] = res[i-1] * nums[i-1];\\n            }\\n            for(int j = nums.length - 1; j > 0; j--) {\\n                res[j] *= res[0];\\n                res[0] *= nums[j];\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int[] productExceptSelf(int[] nums) {\\n            int[] res = new int[nums.length];\\n    \\n            res[0] = 1;\\n            for(int i=1; i < nums.length; i++) {\\n                res[i] = res[i-1] * nums[i-1];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3426752,
                "title": "2-best-swift-solutions-easy-to-understand",
                "content": "# First solution\\n\\n## Approach\\nThis approach to solving the problem involves using three arrays: `prefix`, `suffix`, and `result`. The `prefix` array is used to store the product of all elements before the current element, starting from the first element. The `suffix` array is used to store the product of all elements after the current element, starting from the last element. The `result` array is used to store the product of all elements excluding the current element, which is obtained by multiplying the corresponding elements in the `prefix` and `suffix` arrays.\\n\\nTo be specific, the `prefix` array is initialized with all 1\\'s, and each element is updated by multiplying the previous element in the array with the corresponding element in the `nums` array. This is done by iterating through the `nums` array from the second element to the last element.\\n\\nThe `suffix` array is initialized with all 1\\'s as well, and each element is updated by multiplying the next element in the array with the corresponding element in the `nums` array. This is done by iterating through the `nums` array in reverse order, from the second-to-last element to the first element.\\n\\nFinally, the `result` array is initialized with all 0\\'s, and each element is updated by multiplying the corresponding elements in the `prefix` and `suffix` arrays. This is done by iterating through the result array and accessing the corresponding elements in the `prefix` and `suffix` arrays.\\n\\n## Complexity\\nThis approach has a *time complexity* of $$O(n)$$ and a *space complexity* of $$O(n)$$, where $$n$$ is the length of the input array `nums`.\\n\\n## Code\\n```swift\\nclass Solution {\\n    func productExceptSelf(_ nums: [Int]) -> [Int] {\\n        var prefix = Array(repeating: 1, count: nums.count)\\n        var suffix = Array(repeating: 1, count: nums.count)\\n        var result = Array(repeating: 0, count: nums.count)\\n\\n        for i in 1 ..< nums.count {\\n            prefix[i] = prefix[i - 1] * nums[i - 1]\\n        }\\n\\n        for i in (0 ..< nums.count - 1).reversed() {\\n            suffix[i] = suffix[i + 1] * nums[i + 1]\\n        }\\n\\n        for i in 0 ..< result.count {\\n            result[i] = prefix[i] * suffix[i]\\n        }\\n\\n        return result\\n    }\\n}\\n```\\n\\n\\n---\\n\\n# Second solution\\n\\n## Approach\\nThis approach to solving the problem also involves using two arrays: `result` and `suffix`, but it **optimizes space** usage by only using a single `suffix` variable instead of a `suffix` array. The `result` array is used to store the product of all elements before the current element, starting from the first element, just like in the previous approach. The `suffix` variable is used to store the product of all elements after the current element, starting from the last element, but it is updated in reverse order.\\n\\nTo be specific, the `result` array is initialized with all 1\\'s, and each element is updated by multiplying the previous element in the array with the corresponding element in the `nums` array. This is done by iterating through the nums array from the second element to the last element.\\n\\nThen, the `suffix` variable is initialized with the value `1` and updated in reverse order by multiplying it with the corresponding element in the `nums` array and then updating the corresponding element in the `result` array with the product of the `prefix` and `suffix`. This is done by iterating through the `nums` array in reverse order, from the last element to the first element.\\n\\n## Complexity\\nThis approach also has a *time complexity* of $$O(n)$$ and a *space complexity* of $$O(1)$$, where $$n$$ is the length of the input array `nums`. (The output array does not count as extra space for space complexiy analysis)\\n\\n## Code\\n```swift\\nclass Solution {\\n    func productExceptSelf(_ nums: [Int]) -> [Int] {\\n        var result = Array(repeating: 1, count: nums.count)\\n\\n        for i in 1 ..< nums.count {\\n            result[i] = result[i - 1] * nums[i - 1]\\n        }\\n\\n        var suffix = 1\\n        for i in (0 ..< nums.count).reversed() {\\n            result[i] *= suffix\\n            suffix *= nums[i]\\n        }\\n\\n        return result\\n    }\\n}\\n```\\n\\n# Upvote ^^\\n\\n![upvote.png](https://assets.leetcode.com/users/images/79ace5a2-54b7-48a2-be86-23cd40dcee3a_1681733172.21386.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "Swift",
                    "Array",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```swift\\nclass Solution {\\n    func productExceptSelf(_ nums: [Int]) -> [Int] {\\n        var prefix = Array(repeating: 1, count: nums.count)\\n        var suffix = Array(repeating: 1, count: nums.count)\\n        var result = Array(repeating: 0, count: nums.count)\\n\\n        for i in 1 ..< nums.count {\\n            prefix[i] = prefix[i - 1] * nums[i - 1]\\n        }\\n\\n        for i in (0 ..< nums.count - 1).reversed() {\\n            suffix[i] = suffix[i + 1] * nums[i + 1]\\n        }\\n\\n        for i in 0 ..< result.count {\\n            result[i] = prefix[i] * suffix[i]\\n        }\\n\\n        return result\\n    }\\n}\\n```\n```swift\\nclass Solution {\\n    func productExceptSelf(_ nums: [Int]) -> [Int] {\\n        var result = Array(repeating: 1, count: nums.count)\\n\\n        for i in 1 ..< nums.count {\\n            result[i] = result[i - 1] * nums[i - 1]\\n        }\\n\\n        var suffix = 1\\n        for i in (0 ..< nums.count).reversed() {\\n            result[i] *= suffix\\n            suffix *= nums[i]\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1599115,
                "title": "238-product-of-array-except-self-java-solution",
                "content": "Input:\\n![image](https://assets.leetcode.com/users/images/aff2f7cc-bc8d-4cb3-a3fb-44e3152a650b_1638034053.2986994.png)\\n\\n\\nExplaination:\\n![image](https://assets.leetcode.com/users/images/e688b675-854b-4601-8895-13cbb4c4c96c_1638034099.1931355.png)\\n\\n\\nOutput:\\n![image](https://assets.leetcode.com/users/images/be557e33-b491-4786-85b8-68ad1c88928e_1638034077.1648877.png)\\n\\nCode:\\n```\\nclass Solution {\\n\\tpublic int[] productExceptSelf(int[] nums) {\\n\\t\\tint length = nums.length;\\n\\t\\t\\n\\t\\tint[] left_products = new int[length];\\n\\t\\tleft_products[0] = 1;\\n\\t\\t\\n\\t\\tint[] right_products = new int[length];\\n\\t\\tright_products[length-1] = 1;\\n\\t\\t\\n\\t\\tint[] output = new int[length];\\n\\n\\t\\tfor (int i = 1; i < length; i++) {\\n\\t\\t\\tleft_products[i] = nums[i-1] * left_products[i-1];\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = length-2; i >= 0; i--) {\\n\\t\\t\\tright_products[i] = nums[i+1] * right_products[i+1];\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = 0; i < length; i++) {\\n\\t\\t\\toutput[i] = right_products[i] * left_products[i];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn output;\\n\\t}\\n}\\n```\\n\\nWithout 2 Extra Array:\\n```\\nclass Solution {\\n\\tpublic int[] productExceptSelf(int[] nums) {\\n\\t\\tint[] output = new int[nums.length];\\n\\t\\tfor (int i = 0, left = 1; i < nums.length; i++) {\\n\\t\\t\\toutput[i] = left;\\n\\t\\t\\tleft *= nums[i];\\n\\t\\t}\\n\\t\\tfor (int i = nums.length - 1, right = 1; i >= 0; i--) {\\n\\t\\t\\toutput[i] *= right;\\n\\t\\t\\tright *= nums[i];\\n\\t\\t}\\n\\t\\treturn output;\\n\\t}\\n}\\n```\\n\\nIf it helped, please UPVOTE. Happy Coding and keep up the good work.\\nFeel free to give your suggestions or correct me in the comments.\\nThanks for reading.\\uD83D\\uDE43",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int[] productExceptSelf(int[] nums) {\\n\\t\\tint length = nums.length;\\n\\t\\t\\n\\t\\tint[] left_products = new int[length];\\n\\t\\tleft_products[0] = 1;\\n\\t\\t\\n\\t\\tint[] right_products = new int[length];\\n\\t\\tright_products[length-1] = 1;\\n\\t\\t\\n\\t\\tint[] output = new int[length];\\n\\n\\t\\tfor (int i = 1; i < length; i++) {\\n\\t\\t\\tleft_products[i] = nums[i-1] * left_products[i-1];\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = length-2; i >= 0; i--) {\\n\\t\\t\\tright_products[i] = nums[i+1] * right_products[i+1];\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = 0; i < length; i++) {\\n\\t\\t\\toutput[i] = right_products[i] * left_products[i];\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn output;\\n\\t}\\n}\\n```\n```\\nclass Solution {\\n\\tpublic int[] productExceptSelf(int[] nums) {\\n\\t\\tint[] output = new int[nums.length];\\n\\t\\tfor (int i = 0, left = 1; i < nums.length; i++) {\\n\\t\\t\\toutput[i] = left;\\n\\t\\t\\tleft *= nums[i];\\n\\t\\t}\\n\\t\\tfor (int i = nums.length - 1, right = 1; i >= 0; i--) {\\n\\t\\t\\toutput[i] *= right;\\n\\t\\t\\tright *= nums[i];\\n\\t\\t}\\n\\t\\treturn output;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776664,
                "title": "c-3-approaches-easy-to-understand",
                "content": "# 2 Extra Arrays\\n***Runtime: 16 ms, faster than 97.28% of C++ online submissions for Product of Array Except Self.\\nMemory Usage: 16.2 MB, less than 24.82% of C++ online submissions for Product of Array Except Self.***\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> lhs(nums.size(), 1);\\n        vector<int> rhs(nums.size(), 1);\\n        for(int i = 1; i < nums.size();i++){\\n            lhs[i] = lhs[i-1] * nums[i-1];\\n        }\\n        for(int i = nums.size()-1 ; i >= 1 ; i--){\\n            rhs[i-1] = rhs[i] * nums[i];\\n        }\\n        for(int i = 0;i<nums.size() ;i++){\\n            nums[i] = lhs[i] * rhs[i];\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n# Using Division (/) Operator\\n***Runtime: 24 ms, faster than 61.36% of C++ online submissions for Product of Array Except Self.\\nMemory Usage: 15.8 MB, less than 68.37% of C++ online submissions for Product of Array Except Self.***\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int totalProduct = 1;\\n        int zeroCount = 0;\\n        int firstZeroIndex = -1;\\n        for(int i = 0; i<nums.size() ; i++){\\n            if( nums[i] == 0 ){\\n                zeroCount++;\\n                firstZeroIndex = i;\\n                if(zeroCount > 1){\\n                    return vector(nums.size(), 0);\\n                }\\n            }else{\\n                totalProduct *= nums[i];\\n            }\\n        }\\n        for(int i = 0; i< nums.size() ; i++){\\n            if(zeroCount == 1){\\n                if(i == firstZeroIndex){\\n                    nums[i] = totalProduct;\\n                }else{\\n                    nums[i] = 0;\\n                }\\n            }else{\\n                nums[i] = totalProduct/nums[i];\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n# Using 1 Output Array ONLY!!!!\\n***Runtime: 12 ms, faster than 99.86% of C++ online submissions for Product of Array Except Self.\\nMemory Usage: 15.6 MB, less than 99.03% of C++ online submissions for Product of Array Except Self.***\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> lhs(nums.size(), 1);\\n        int rhs = 1;\\n        for(int i = 1; i<nums.size() ; i++){\\n            lhs[i] = lhs[i-1] * nums[i-1];\\n        }\\n        for(int i = lhs.size()-1; i >= 1 ; i--){\\n            rhs *= nums[i];\\n            lhs[i-1] *= rhs;\\n        }\\n        return lhs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> lhs(nums.size(), 1);\\n        vector<int> rhs(nums.size(), 1);\\n        for(int i = 1; i < nums.size();i++){\\n            lhs[i] = lhs[i-1] * nums[i-1];\\n        }\\n        for(int i = nums.size()-1 ; i >= 1 ; i--){\\n            rhs[i-1] = rhs[i] * nums[i];\\n        }\\n        for(int i = 0;i<nums.size() ;i++){\\n            nums[i] = lhs[i] * rhs[i];\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int totalProduct = 1;\\n        int zeroCount = 0;\\n        int firstZeroIndex = -1;\\n        for(int i = 0; i<nums.size() ; i++){\\n            if( nums[i] == 0 ){\\n                zeroCount++;\\n                firstZeroIndex = i;\\n                if(zeroCount > 1){\\n                    return vector(nums.size(), 0);\\n                }\\n            }else{\\n                totalProduct *= nums[i];\\n            }\\n        }\\n        for(int i = 0; i< nums.size() ; i++){\\n            if(zeroCount == 1){\\n                if(i == firstZeroIndex){\\n                    nums[i] = totalProduct;\\n                }else{\\n                    nums[i] = 0;\\n                }\\n            }else{\\n                nums[i] = totalProduct/nums[i];\\n            }\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> lhs(nums.size(), 1);\\n        int rhs = 1;\\n        for(int i = 1; i<nums.size() ; i++){\\n            lhs[i] = lhs[i-1] * nums[i-1];\\n        }\\n        for(int i = lhs.size()-1; i >= 1 ; i--){\\n            rhs *= nums[i];\\n            lhs[i-1] *= rhs;\\n        }\\n        return lhs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65691,
                "title": "my-c-solution-o-n-time-with-no-extra-space",
                "content": "    vector<int> productExceptSelf(vector<int>& nums) {\\n        int N = nums.size();\\n        vector<int> res(N,1);\\n        \\n        for(int i=0; i<N; i++){\\n            if (i==0)   res[i] = 1;\\n            else res[i] = res[i-1]*nums[i-1];\\n        }\\n        \\n        int r_prod = 1;\\n        for(int i=N-1; i>=0; i--){\\n            res[i] *= r_prod;\\n            r_prod *= nums[i];\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    vector<int> productExceptSelf(vector<int>& nums) {\\n        int N = nums.size();\\n        vector<int> res(N,1);\\n        \\n        for(int i=0; i<N; i++){\\n            if (i==0)   res[i] = 1;\\n            else res[i] = res[i-1]*nums[i-1];\\n        }\\n        \\n        int r_prod = 1;\\n        for(int i=N-1; i>=0; i--){\\n            res[i] *= r_prod;\\n            r_prod *= nums[i];\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 693902,
                "title": "python-simple-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        ## RC ##\\n        ## APPROACH ##\\n        ## Using division is sipmle ##\\n        # we can make use of the product of all the numbers to the left and all the numbers to the right of the index. Multiplying these two individual products would give us the desired result as well. ##\\n        # ==> left product [1,2,3,4] ==> [1,1,2,6] (left to right)\\n        # ==> right product [1,2,3,4] ==> [24,12,4,1] (right to left)\\n        # ==> multiplying these two will get answer.\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        size = len(nums)\\n        leftProduct = [0]*size\\n        rightProduct = [0]*size\\n        leftProduct[0] = 1\\n        rightProduct[size-1] = 1\\n        \\n        for i in range(1,size):\\n            leftProduct[i] = leftProduct[i-1] * nums[i-1]\\n            rightProduct[size-i-1] = rightProduct[size-i] * nums[size-i]\\n        \\n        ans = []\\n        for i in range(size):\\n            ans.append(leftProduct[i] * rightProduct[i])\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        ## RC ##\\n        ## APPROACH ##\\n        ## Using division is sipmle ##\\n        # we can make use of the product of all the numbers to the left and all the numbers to the right of the index. Multiplying these two individual products would give us the desired result as well. ##\\n        # ==> left product [1,2,3,4] ==> [1,1,2,6] (left to right)\\n        # ==> right product [1,2,3,4] ==> [24,12,4,1] (right to left)\\n        # ==> multiplying these two will get answer.\\n        \\n\\t\\t## TIME COMPLEXITY : O(N) ##\\n\\t\\t## SPACE COMPLEXITY : O(N) ##\\n\\n        size = len(nums)\\n        leftProduct = [0]*size\\n        rightProduct = [0]*size\\n        leftProduct[0] = 1\\n        rightProduct[size-1] = 1\\n        \\n        for i in range(1,size):\\n            leftProduct[i] = leftProduct[i-1] * nums[i-1]\\n            rightProduct[size-i-1] = rightProduct[size-i] * nums[size-i]\\n        \\n        ans = []\\n        for i in range(size):\\n            ans.append(leftProduct[i] * rightProduct[i])\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 927440,
                "title": "python-no-division-time-o-n-space-o-1-not-including-the-output-array",
                "content": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        result = [1] * len(nums)        \\n        for i in range(1, len(nums)):\\n            result[i] = nums[i-1] * result[i-1]\\n            \\n        right_prod = 1\\n        for i in range(len(nums)-1, -1, -1):\\n            result[i] *= right_prod\\n            right_prod *= nums[i]             \\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        result = [1] * len(nums)        \\n        for i in range(1, len(nums)):\\n            result[i] = nums[i-1] * result[i-1]\\n            \\n        right_prod = 1\\n        for i in range(len(nums)-1, -1, -1):\\n            result[i] *= right_prod\\n            right_prod *= nums[i]             \\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580549,
                "title": "c-solution-in-o-n-time-and-o-1-space-without-using-division",
                "content": "Let p[i] represent the answer for the ith index.\\nLet n= Size of nums array\\nThen p[i]=nums[0] * nums[1] * nums[2] * .............* nums[i-1] * nums[i+1] * nums[i+2] * ......... * nums[n-1]\\n1. Using one loop we can calculate the prefix product and update it.\\n\\t\\t\\t p[i]=nums[0] * nums[1] * nums[2] * .............* nums[i-1] after this step.\\n2. Using another loop from rear we can calculate suffix product and update it.\\n\\t\\t\\tp[i]=p[i] * nums[i+1] * nums[i+2] * ......... * nums[n-1] after this step.\\n\\t\\t\\t\\nC++ code:\\n``` \\nvector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> v(nums.size(),1);\\n        int pre=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            v[i]=pre;\\n            pre=pre*nums[i];\\n        }\\n        int post=nums[nums.size()-1];\\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            v[i]=v[i]*post;\\n            post=post*nums[i];\\n        }\\n        return v;\\n    }\\n```\\nP.S. - The Output Array doesn\\'t count as extra array for the purpose of Space Complexity Analysis (Mentioned in the Question itself).\\n",
                "solutionTags": [],
                "code": "``` \\nvector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> v(nums.size(),1);\\n        int pre=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            v[i]=pre;\\n            pre=pre*nums[i];\\n        }\\n        int post=nums[nums.size()-1];\\n        for(int i=nums.size()-2;i>=0;i--)\\n        {\\n            v[i]=v[i]*post;\\n            post=post*nums[i];\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65855,
                "title": "8-lines-in-ruby",
                "content": "Same algorithm as everybody, just in Ruby. I like the usage of indexes `i`, `-i` and `~i`.\\n\\n    def product_except_self(nums)\\n        n = nums.size\\n        out = [1] * n\\n        left = right = 1\\n        1.upto(n-1) { |i|\\n            out[i] *= left *= nums[i-1]\\n            out[~i] *= right *= nums[-i]\\n        }\\n        out\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "Same algorithm as everybody, just in Ruby. I like the usage of indexes `i`, `-i` and `~i`.\\n\\n    def product_except_self(nums)\\n        n = nums.size\\n        out = [1] * n\\n        left = right = 1\\n        1.upto(n-1) { |i|\\n            out[i] *= left *= nums[i-1]\\n            out[~i] *= right *= nums[-i]\\n        }\\n        out\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 988475,
                "title": "hints",
                "content": "Click hint names / descriptions (next to the <strong><strong>&blacktriangleright;</strong></strong>) to view each hint.\\n\\n**Wrong paths**\\n<details><summary>Most interviewers would warn candidates away from spending time on these fruitless paths (click to reveal hint):</summary>\\n\\n\\n- bit manipulation\\n- precalculating very large data structures (the worst case solution is O(n) in space)\\n</details>\\n\\n**Brute force algorithm in O(n<sup>2</sup>)**\\n\\nIn this case, the brute force algorithm is not incredibly instructive, but it\\'s included here as a decent first step in thinking about any interview question.\\n\\n<details><summary>algorithm</summary>\\n\\nLoop through the input array.\\nAt each index, loop through the array again, multiplying all other elements to find the output for that index.\\n</details>\\n\\n<details><summary>click to reveal pseudocode</summary>\\n\\n```\\nfunction productExceptSelf(nums) {\\n\\tn = nums.length\\n\\toutput = Array.new(n)  // array of length n\\n\\tfor i=0; i &lt n-1; i=i+1 {\\n\\t\\toutput_at_i = 1\\n\\t\\tfor j=0; j &lt; n-1; j=j+1 {\\n\\t\\t\\tif j != i {\\n\\t\\t\\t\\toutput_at_i = output_at_i * nums[j]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\toutput[i] = output_at_i\\n\\t}\\n\\treturn output\\n}\\n```\\n</details>\\n\\n<details><summary>example</summary>\\n\\nHere\\'s an example of how this solution would work:\\nInput: `[a,b,c,d,e]`\\nCorrect output: `[b*c*d*e,  a*c*d*e , a*b*d*e , a*b*c*e, a*b*c*d]`\\nWhen `i` is `0`, we loop through `j` from `0` to `4` to calculate `b*c*d*e`.\\nWhen `i` is `1`, we loop through `j` from `0` to `4` to calculate `a*c*d*e`.\\nWhen `i` is `2`, we loop through `j` from `0` to `4` to calculate `a*b*d*e`.\\nWhen `i` is `3`, we loop through `j` from `0` to `4` to calculate `a*b*c*e`.\\nWhen `i` is `0`, we loop through `j` from `0` to `4` to calculate `a*b*c*d`.\\n\\n</details>\\n\\n<details><summary>Why is the brute force solution too slow?</summary>\\n\\nTo find an O(n) solution, we\\'ll have to remove the inner loop (with `j` in the pseudocode above). \\n\\nThat means we must be recalculating some information in each inner loop that we could instead build up with one or a few passes over the input array.  \\n\\nFiguring out how to break down the required multiplications to remove repeated calculations is the core of this problem.  You may want to try writing done some more examples to try to spot a pattern.\\n</details>\\n\\n**Getting to O(n)**\\n\\nThese hints progressively give away more and more information. View in order for best experience.\\n\\n<details><summary>hint 0</summary>\\n\\nThe mention of \"prefixes\" and \"suffixes\" in the problem is relevant to the correct approach.\\n</details>\\n\\n<details><summary>hint 1</summary>\\n\\nHow can you express the output value at each index in terms of a prefix and suffix?  \\n\\n*You may want to spend some time thinking about this since the next hint gives away the key insight needed to solve this problem. Try writing out examples with different numbers of elements in the input.*\\n\\n</details>\\n\\n<details><summary>hint 2 (key insight / central idea of the solution)</summary>\\n\\nThe output value at each index `i` is the product of:\\n\\n<ul><li>the product of the elements before <code>i</code> (prefix), multiplied by</li>\\n<li>the product of elements after <code>i</code> (suffix).</li></ul>\\n\\n</details>\\n\\n<details><summary>hint 3</summary>\\n\\nHere\\'s an example.\\n\\nInput: `[a,b,c,d,e]`\\nCorrect output: `[b*c*d*e,  a*c*d*e , a*b*d*e , a*b*c*e, a*b*c*d]`\\nCorrect output, rewritten as products of \"prefixes\" and \"suffixes\": `[(b*c*d*e), (a)*(c*d*e), (a*b)*(c*d), (a*b*c)*(e), (a*b*c*d)]`\\n\\nThe brute force solution is inefficient because it recalculates most of the product of elements before `i` and most of the product of elements after `i` in each pass through the inner loop.\\n\\nHow can you generate the prefix products for all `i`s in O(n) time?\\n\\nHow can you generate the suffix products for all `i` in O(n) time?\\n\\n</details>\\n\\n<details><summary>hint 4</summary>\\n\\nHow can you generate the prefix products for all `i`s in O(n) time?\\n\\nPrefix products are `1` (for the first element having no prefix), `a`, `a*b`, `a*b*c`, `a*b*c*d`.\\n\\nThese can be generated with a non-nested loop in O(n) time.\\n\\n</details>\\n\\n<details><summary>hint 5</summary>\\n\\nHow can you generate the suffix products for all `i` in O(n) time?\\n\\nSuffix products are `b*c*d*e`, `c*d*e`, `d*e`, `e`, and `1` (for the last element having no suffix).\\n\\nThese can be generated with a non-nested loop, looping \"backwards\" from the end of `nums`, in O(n) time.\\n\\n</details>\\n\\n\\n**Getting to O(n) time with O(1) space**\\n<details><summary>hint 6</summary>\\n\\nSince the problem statement says we can use the output array without counting against O(1) space complexity, some data storage can move there.\\n\\n</details>\\n\\n<details><summary>hint 7</summary>\\n\\nKeeping a single numerical variable is O(1) in space.  How does this help reduce storage needs?\\n\\n<details><summary>hint 8</summary>\\nKeep the prefix product, or suffix product, in a single variable instead of storing values in a separate data structure. \\n</details>\\n\\n</details>\\n\\n\\n**Getting to one loop (optional)**\\n<details><summary>hint 9</summary>\\n\\nTo combine calculations into a single pass in a loop, use two pointers / counters / iteration variables, one starting from the beginning of the input array that drives the prefix-based work, and one starting at the end that drives suffix-based work. \\n\\n</details>\\n\\n",
                "solutionTags": [],
                "code": "```\\nfunction productExceptSelf(nums) {\\n\\tn = nums.length\\n\\toutput = Array.new(n)  // array of length n\\n\\tfor i=0; i &lt n-1; i=i+1 {\\n\\t\\toutput_at_i = 1\\n\\t\\tfor j=0; j &lt; n-1; j=j+1 {\\n\\t\\t\\tif j != i {\\n\\t\\t\\t\\toutput_at_i = output_at_i * nums[j]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\toutput[i] = output_at_i\\n\\t}\\n\\treturn output\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 796378,
                "title": "two-js-solutions",
                "content": "```\\n/*\\nWe have to return an array so we will create a result array.\\nres[i]  = the product of elements on the left of i and elements on the right of i\\n        = left[i-1] * right[i+1], \\n        where left[i] is the product of elements from 0 to i and right[i] is the product of elements from end of array to i\\nWe will fill these two arrays, left[] and right[], and then iterate through result array and fill it with correct products. \\n*/\\nvar productExceptSelf = function(nums) {\\n    if (nums === null || nums.length <= 1) {\\n        return [];\\n    }\\n    let n = nums.length;\\n    let left = new Array(n), right = new Array(n), res = new Array(n);\\n    for (let i = 0; i < n; i++) {\\n        left[i] = i > 0 ? nums[i] * left[i-1] : nums[i];\\n    }\\n    for (let i = n-1; i >= 0; i--) {\\n        right[i] = i < n-1 ? nums[i] * right[i+1] : nums[i];\\n    }\\n    for (let i = 1; i < n-1; i++) {\\n        res[i] = left[i-1] * right[i+1];\\n    }\\n    res[0] = right[1];\\n    res[n-1] = left[n-2];\\n    return res;\\n    // T.C: O(N)\\n    // S.C: O(N), even though we assume that the output array is not counted as extra space,\\n    // we use two extra arrays of length n\\n};\\n```\\n\\n```\\n/*\\nAdd optimisation to the solution above.\\n\\nInstead of using two arrays left[] and right[], we will keep track of product from left and product from right.\\nHence, at each i, res[i] = productFromLeft * productFromRight. Since we can\\'t have access to productFromLeft and\\nproductFromRight at the same time without storing them somewhere, we will set res[i] to productFromLeft when\\niterating from the start and we will multiply productFromRight to each res[i] as we iterate through from the end.\\n*/\\n\\nvar productExceptSelf = function(nums) {\\n    if (nums === null || nums.length <= 1) {\\n        return [];\\n    }\\n    let productFromLeft = 1, productFromRight = 1;\\n    let res = new Array(nums.length);\\n    for (let i = 0; i < nums.length; i++) {\\n        res[i] = productFromLeft;\\n        productFromLeft *= nums[i];\\n    }\\n    for (let i = nums.length-1; i >= 0; i--) {\\n        res[i] *= productFromRight;\\n        productFromRight *= nums[i];\\n    }\\n    return res;\\n    // T.C: O(N)\\n    // S.C: O(1), assuming that we do not count the output array as extra space\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nWe have to return an array so we will create a result array.\\nres[i]  = the product of elements on the left of i and elements on the right of i\\n        = left[i-1] * right[i+1], \\n        where left[i] is the product of elements from 0 to i and right[i] is the product of elements from end of array to i\\nWe will fill these two arrays, left[] and right[], and then iterate through result array and fill it with correct products. \\n*/\\nvar productExceptSelf = function(nums) {\\n    if (nums === null || nums.length <= 1) {\\n        return [];\\n    }\\n    let n = nums.length;\\n    let left = new Array(n), right = new Array(n), res = new Array(n);\\n    for (let i = 0; i < n; i++) {\\n        left[i] = i > 0 ? nums[i] * left[i-1] : nums[i];\\n    }\\n    for (let i = n-1; i >= 0; i--) {\\n        right[i] = i < n-1 ? nums[i] * right[i+1] : nums[i];\\n    }\\n    for (let i = 1; i < n-1; i++) {\\n        res[i] = left[i-1] * right[i+1];\\n    }\\n    res[0] = right[1];\\n    res[n-1] = left[n-2];\\n    return res;\\n    // T.C: O(N)\\n    // S.C: O(N), even though we assume that the output array is not counted as extra space,\\n    // we use two extra arrays of length n\\n};\\n```\n```\\n/*\\nAdd optimisation to the solution above.\\n\\nInstead of using two arrays left[] and right[], we will keep track of product from left and product from right.\\nHence, at each i, res[i] = productFromLeft * productFromRight. Since we can\\'t have access to productFromLeft and\\nproductFromRight at the same time without storing them somewhere, we will set res[i] to productFromLeft when\\niterating from the start and we will multiply productFromRight to each res[i] as we iterate through from the end.\\n*/\\n\\nvar productExceptSelf = function(nums) {\\n    if (nums === null || nums.length <= 1) {\\n        return [];\\n    }\\n    let productFromLeft = 1, productFromRight = 1;\\n    let res = new Array(nums.length);\\n    for (let i = 0; i < nums.length; i++) {\\n        res[i] = productFromLeft;\\n        productFromLeft *= nums[i];\\n    }\\n    for (let i = nums.length-1; i >= 0; i--) {\\n        res[i] *= productFromRight;\\n        productFromRight *= nums[i];\\n    }\\n    return res;\\n    // T.C: O(N)\\n    // S.C: O(1), assuming that we do not count the output array as extra space\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 580972,
                "title": "java-clean-code-easy-to-understand-o-n-time-o-1-space",
                "content": "**Solution 1: Easy to understand**\\n```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] leftProductArr = new int[n]; // leftProductArr[i] = 1*arr[0]*arr[1]*...*arr[i-1] \\n        leftProductArr[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            leftProductArr[i] = leftProductArr[i - 1] * nums[i - 1];\\n        }\\n        int rightProduct = 1;\\n        int[] ans = new int[n];\\n        for (int i = n - 1; i >= 0; i--) {\\n            ans[i] = rightProduct * leftProductArr[i];\\n            rightProduct *= nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\\nComplexity\\n- Time: `O(N)`\\n- Extra Space: `O(N)`\\n\\n**Solution 2: Optimized**\\nUse `ans` for `leftProductArr`\\n```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        ans[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            ans[i] = ans[i - 1] * nums[i - 1];\\n        }\\n        int rightProduct = 1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            ans[i] = rightProduct * ans[i];\\n            rightProduct *= nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(N)`\\n- Extra Space: `O(1)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] leftProductArr = new int[n]; // leftProductArr[i] = 1*arr[0]*arr[1]*...*arr[i-1] \\n        leftProductArr[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            leftProductArr[i] = leftProductArr[i - 1] * nums[i - 1];\\n        }\\n        int rightProduct = 1;\\n        int[] ans = new int[n];\\n        for (int i = n - 1; i >= 0; i--) {\\n            ans[i] = rightProduct * leftProductArr[i];\\n            rightProduct *= nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        ans[0] = 1;\\n        for (int i = 1; i < n; i++) {\\n            ans[i] = ans[i - 1] * nums[i - 1];\\n        }\\n        int rightProduct = 1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            ans[i] = rightProduct * ans[i];\\n            rightProduct *= nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65745,
                "title": "most-basic-approach-in-python-o-n",
                "content": "class Solution(object):\\n    def productExceptSelf(self, nums):\\n   \\n        output=[1]*len(nums)\\n        n=len(nums)\\n        \\n        prod=1\\n        for i in range(1,n):\\n            prod=prod*nums[i-1]\\n            output[i]*=prod\\n            \\n        prod=1\\n        for i in range(n-2,-1,-1):\\n            prod=prod*nums[i+1]\\n            output[i]*=prod\\n        \\n        return output",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    def productExceptSelf(self, nums):\\n   \\n        output=[1]*len(nums)\\n        n=len(nums)\\n        \\n        prod=1\\n        for i in range(1,n):\\n            prod=prod*nums[i-1]\\n            output[i]*=prod\\n            \\n        prod=1\\n        for i in range(n-2,-1,-1):\\n            prod=prod*nums[i+1]\\n            output[i]*=prod\\n        \\n        return output",
                "codeTag": "Java"
            },
            {
                "id": 1670352,
                "title": "multiple-c-solution-with-full-explanations-extra-space-or-not",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- ***This solution use O(n) extra space.***\\n- We\\u2019ve taken 2 arrays ***l & r*** to store products from ***left to right*** and ***right to left.***\\n- We simply multiply ***l[i-1] & r[i+1]***  and stored the value to nums array.\\n- Edge cases: first and last elements will be ***nums[0]=r[1] & nums[n-1]=l[n-2].***\\n- **Time complexity:** O(n).\\n\\n### Solution 02\\n\\n- ***This solution doesn\\u2019t use any extra space.***\\n- Here we calculated the left to right product and store it in ans array.\\n- Then we took a product variable initialized with 1.\\n- In ans array iterate from last and change current value with previous ans value multiply product value & update product value by multiplying current element of nums array. ***ans[i]= ans[i-1]*product;\\nproduct *= nums[i];***\\n- Edge case: replace first element with final product value from the loop.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n= nums.size(), p=1;\\n        vector<int> l(n), r(n);\\n        \\n        for(int i=0; i<n; i++){\\n            p *= nums[i];\\n            l[i]=p;\\n        }\\n        \\n        p=1;\\n        \\n        for(int i=n-1; i>=0; i--){\\n            p *= nums[i];\\n            r[i]=p;\\n        }\\n        \\n        nums[0]=r[1]; nums[n-1]=l[n-2];\\n        \\n        for(int i=1; i<n-1; i++){\\n            nums[i]= l[i-1]*r[i+1];\\n        }\\n        \\n        return nums;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n= nums.size(), p=1;\\n        vector<int> ans(n);\\n        \\n        for(int i=0; i<n; i++){\\n            p *= nums[i];\\n            ans[i]=p;\\n        }\\n        \\n        int product=1;\\n        for(int i=n-1; i>0; i--){\\n            ans[i]= ans[i-1]*product;\\n            product *= nums[i];\\n        }\\n        ans[0]=product;\\n        \\n        return ans;\\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n= nums.size(), p=1;\\n        vector<int> l(n), r(n);\\n        \\n        for(int i=0; i<n; i++){\\n            p *= nums[i];\\n            l[i]=p;\\n        }\\n        \\n        p=1;\\n        \\n        for(int i=n-1; i>=0; i--){\\n            p *= nums[i];\\n            r[i]=p;\\n        }\\n        \\n        nums[0]=r[1]; nums[n-1]=l[n-2];\\n        \\n        for(int i=1; i<n-1; i++){\\n            nums[i]= l[i-1]*r[i+1];\\n        }\\n        \\n        return nums;\\n    }\\n};**\\n\\n//Solution 02:\\n**class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n= nums.size(), p=1;\\n        vector<int> ans(n);\\n        \\n        for(int i=0; i<n; i++){\\n            p *= nums[i];\\n            ans[i]=p;\\n        }\\n        \\n        int product=1;\\n        for(int i=n-1; i>0; i--){\\n            ans[i]= ans[i-1]*product;\\n            product *= nums[i];\\n        }\\n        ans[0]=product;\\n        \\n        return ans;\\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598479,
                "title": "java-2-simple-solutions-100-faster-o-n-time-o-n-o-1-space",
                "content": "**Approach 1:** *O(N) time + O(N) space*\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        left[0] = 1; right[n - 1] = 1;\\n        for (int i = 1; i < n; i++)\\n            left[i] = left[i - 1] * nums[i - 1];\\n        for (int i = n - 2; i >= 0; i--)\\n            right[i] = right[i + 1] * nums[i + 1];\\n        \\n        int[] result = new int[n];\\n        for (int i = 0; i < n; i++)\\n            result[i] = left[i] * right[i];\\n        return result;\\n    }\\n}\\n```\\n**Approach 2:** *O(N) time + O(1) space*\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] result = new int[n];\\n        result[0] = 1;\\n        for (int i = 1; i < n; i++)\\n            result[i] = result[i - 1] * nums[i - 1];\\n        \\n        int right = nums[n - 1];\\n        for (int i = n - 2; i >= 0; i--) {\\n            result[i] = result[i] * right;\\n            right *= nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```\\n**Approach 3:** *O(N) time + O(1) space, single loop*\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] result = new int[n];\\n        Arrays.fill(result, 1);\\n        int left = 1, right = 1;\\n        for (int i = 0; i < n; i++) {\\n            result[i] *= left;\\n            left *= nums[i];\\n            result[n - i - 1] *= right;\\n            right *= nums[n - i - 1];\\n        }\\n        return result;\\n    }\\n}\\n```\\nPlease **upvote** :-)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        left[0] = 1; right[n - 1] = 1;\\n        for (int i = 1; i < n; i++)\\n            left[i] = left[i - 1] * nums[i - 1];\\n        for (int i = n - 2; i >= 0; i--)\\n            right[i] = right[i + 1] * nums[i + 1];\\n        \\n        int[] result = new int[n];\\n        for (int i = 0; i < n; i++)\\n            result[i] = left[i] * right[i];\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] result = new int[n];\\n        result[0] = 1;\\n        for (int i = 1; i < n; i++)\\n            result[i] = result[i - 1] * nums[i - 1];\\n        \\n        int right = nums[n - 1];\\n        for (int i = n - 2; i >= 0; i--) {\\n            result[i] = result[i] * right;\\n            right *= nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] result = new int[n];\\n        Arrays.fill(result, 1);\\n        int left = 1, right = 1;\\n        for (int i = 0; i < n; i++) {\\n            result[i] *= left;\\n            left *= nums[i];\\n            result[n - i - 1] *= right;\\n            right *= nums[n - i - 1];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65843,
                "title": "my-c-one-pass-o-n-time-o-1-space-solution",
                "content": "\\n\\n    class Solution {\\n    public:\\n        vector<int> productExceptSelf(vector<int>& nums) {\\n            int n = nums.size();\\n            vector<int> result(n, 1);\\n            int left_fac = 1, right_fac = 1, i = 0;\\n            while(i < n)\\n            {\\n                result[i] *= left_fac;\\n                left_fac *= nums[i];\\n                result[n - ++i] *= right_fac;\\n                right_fac *= nums[n - i];\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> productExceptSelf(vector<int>& nums) {\\n            int n = nums.size();\\n            vector<int> result(n, 1);\\n            int left_fac = 1, right_fac = 1, i = 0;\\n            while(i < n)\\n            {\\n                result[i] *= left_fac;\\n                left_fac *= nums[i];\\n                result[n - ++i] *= right_fac;\\n                right_fac *= nums[n - i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4069888,
                "title": "simple-and-easy-1-min-explanation-in-python-and-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimilar to finding Prefix Sum array, here the preblem intends us to find the Prefix Product Array and Suffix Product Array for our original array.\\n```\\npre[i+1] = pre[i] * a[i]\\nsuff[i-1] = suff[i] * a[i]\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\nOnly 2 loops iterating $$n$$ times each without any nesting.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\nWe have taken prefix and suffixProduct as variables instead of arrays to further optimize space, even though the overall complexity remains the same.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int numsLength = nums.length;\\n        int prefixProduct = 1;\\n        int suffixProduct = 1;\\n        int[] result = new int[numsLength];\\n        for(int i = 0; i < numsLength; i++) {\\n            result[i] = prefixProduct;\\n            prefixProduct *= nums[i];\\n        }\\n        for(int i = numsLength-1; i >= 0; i--) {\\n            result[i] *= suffixProduct;\\n            suffixProduct *= nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```\\n```python3 []\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        prefix_product = 1\\n        postfix_product = 1\\n        result = [0]*n\\n        for i in range(n):\\n            result[i] = prefix_product\\n            prefix_product *= nums[i]\\n        for i in range(n-1,-1,-1):\\n            result[i] *= postfix_product\\n            postfix_product *= nums[i]\\n        return result\\n```\\n*Please upvote, if this helped you understand the solution in optimal time :)*\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\npre[i+1] = pre[i] * a[i]\\nsuff[i-1] = suff[i] * a[i]\\n```\n```java []\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int numsLength = nums.length;\\n        int prefixProduct = 1;\\n        int suffixProduct = 1;\\n        int[] result = new int[numsLength];\\n        for(int i = 0; i < numsLength; i++) {\\n            result[i] = prefixProduct;\\n            prefixProduct *= nums[i];\\n        }\\n        for(int i = numsLength-1; i >= 0; i--) {\\n            result[i] *= suffixProduct;\\n            suffixProduct *= nums[i];\\n        }\\n        return result;\\n    }\\n}\\n```\n```python3 []\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        prefix_product = 1\\n        postfix_product = 1\\n        result = [0]*n\\n        for i in range(n):\\n            result[i] = prefix_product\\n            prefix_product *= nums[i]\\n        for i in range(n-1,-1,-1):\\n            result[i] *= postfix_product\\n            postfix_product *= nums[i]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489326,
                "title": "python-solution-thought-process-o-1-space-o-n-time",
                "content": "**Thought Process:**\\n1. Look at the example array -> [1, 2, 3, 4]\\n2. Somehow realize that:\\n\\t* output[i] = product([i+1:]) * product([:i])\\n\\t* which means output[i] = \"product of all elements left of i\" * \"product of all elements right of i\"\\n3. Realize that we can find find \"left products\" and \"right products\" by iterating back and forth across the array. \\n\\t* Realize that we can store the left products in `output` (counts as constant space as per problem constraints) and compute the running right product and store it in a variable `right` (allows for constant space) as we iterate from the back of the input array to the front.\\n5. Come up with Pseudocode:\\n\\t* Iterate through nums while computing \"left products\" and save them in the output array\\n\\t* Then, while going from right to left across the arrays:\\n\\t\\t* store the running \"right product\" in a variable `right`\\n\\t\\t* compute output[i] as we iterate\\n\\n**Solution:**\\n```python\\nclass Solution:  \\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        output = []\\n        # Store \"left products\" in output\\n        for n in nums:\\n            output.append(output[-1]*n if output else n)\\n        right = None\\n        # As we iterate backwards, compute running \"right product\" and use it to compute each output element.\\n        i = len(nums) - 1\\n        while i >= 0:\\n            right = right*nums[i+1] if right != None else 1\\n            output[i] = output[i-1]*right if i-1 >= 0 else right\\n            i -= 1\\n        return output\\n```\\n\\n\\n**Notes:**\\n* If the ternarys cause too much confusion for understanding, please comment and I will update this accordingly.\\n* I refrained from using `range` since `range` technically creates a list of O(N) size.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:  \\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        output = []\\n        # Store \"left products\" in output\\n        for n in nums:\\n            output.append(output[-1]*n if output else n)\\n        right = None\\n        # As we iterate backwards, compute running \"right product\" and use it to compute each output element.\\n        i = len(nums) - 1\\n        while i >= 0:\\n            right = right*nums[i+1] if right != None else 1\\n            output[i] = output[i-1]*right if i-1 >= 0 else right\\n            i -= 1\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384653,
                "title": "javascript-no-division-with-easy-explanation-o-1-space-94-beats-two-solution",
                "content": "# Aproach (Aproach of commented code)\\nThe first solution computes the product of all the elements to the left and right of each element in the input array using two separate arrays - leftArr and rightArr. It then multiplies the left and right products for each element to get the final result.\\n\\nLet\\'s take an example to understand this approach. Consider an input array:\\n```\\nnums = [1,2,3,4]\\n```\\nThe approach works as follows:\\n1. Initialize two arrays, leftArr and rightArr, both of size nums.length.\\n2. Traverse the nums array from left to right and compute the product of all elements to the left of the current element. Store this value in the corresponding index of leftArr.\\n```\\nleftArr[0] = 1\\nleftArr[1] = 1 * nums[0] = 1 * 1 = 1\\nleftArr[2] = 1 * nums[0] * nums[1] = 1 * 1 * 2 = 2\\nleftArr[3] = 1 * nums[0] * nums[1] * nums[2] = 1 * 1 * 2 * 3 = 6\\n```\\n3. Traverse the nums array from right to left and compute the product of all elements to the right of the current element. Store this value in the corresponding index of rightArr.\\n```\\nrightArr[3] = 1\\nrightArr[2] = 1 * nums[3] = 1 * 4 = 4\\nrightArr[1] = 1 * nums[3] * nums[2] = 1 * 4 * 3 = 12\\nrightArr[0] = 1 * nums[3] * nums[2] * nums[1] = 1 * 4 * 3 * 2 = 24\\n\\n```\\n4. Traverse the nums array one more time and compute the final product by multiplying the corresponding values in leftArr and rightArr.\\n```\\nresult[0] = leftArr[2] * rightArr[1] = 2 * 12 = 24\\nresult[1] = leftArr[1] * rightArr[2] = 1 * 24 = 24\\nresult[2] = leftArr[0] * rightArr[3] = 1 * 1 = 1\\nresult[3] = leftArr[3] * rightArr[0] = 6 * 1 = 6\\n```\\n5. Return the result array.\\n\\nThe time complexity of this approach is O(n), and the space complexity is also O(n) due to the use of two extra arrays leftArr and rightArr.\\n\\nBut we will later modify this code\\n\\n# Explanation of actual code step by step:\\n1. Initialize an empty array result to store the final products, and two variables left and right to store the left and right products for each element, respectively.\\n\\n2. Loop through the nums array from left to right. For each element nums[i], compute its left product by setting result[i] to the current value of left, and then updating left to the product of left and nums[i].\\n\\n3. Loop through the nums array again, but this time from right to left. For each element nums[i], compute its right product by multiplying right with nums[i], and then updating result[i] to the product of the current value of result[i] and right.\\n\\n4. After the loops have completed, the result array should contain the final products of all elements in the nums array.\\n\\nThe key idea behind this approach is that each element\\'s product can be computed as the product of its left and right products. By computing these left and right products separately for each element, we can avoid having to compute the product of all elements except for the current one, which would have a time complexity of O(n^2). Instead, we can achieve a time complexity of O(n) by computing the left and right products in separate passes through the array. Additionally, we can optimize the space complexity by storing only the left and right products for each element in two variables left and right, instead of creating two separate arrays like in the first solution.\\n\\nIf it was helpful, do not forget to like\\uD83D\\uDE03\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function (nums) {\\n  /**\\n   * @param {number[]} nums\\n   * @return {number[]}\\n   */\\n  /*\\n  //1st solution -> Not constant memory\\n  //TIME: O(n)\\n  //MEMORY: O(n)\\n  let leftArr = [];\\n  let rightArr = [];\\n  let result = [];\\n  let left = 1;\\n  let right = 1;\\n  const length = nums.length - 1;\\n  let rIndex = length - 1;\\n  let lIndex = -1;\\n  for (let i = 0; i < nums.length; i++) {\\n    left = left * nums[i];\\n    leftArr.push(left);\\n  }\\n  for (let i = nums.length - 1; i > -1; i--) {\\n    right = right * nums[i];\\n    rightArr.push(right);\\n  }\\n  console.log(leftArr, rightArr);\\n  for (let i = 0; i < nums.length; i++) {\\n    const res =\\n      (lIndex == -1 ? 1 : leftArr[lIndex]) *\\n      (rIndex == -1 ? 1 : rightArr[rIndex]);\\n    result.push(res);\\n    rIndex--;\\n    lIndex++;\\n  }\\n  return result;\\n  */\\n  //TIME: O(n)\\n  //MEMORY: O(1)\\n  let result = [];\\n  let left = 1;\\n  let right = 1;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    // compute left product for nums[i]\\n    result[i] = left;\\n    left *= nums[i];\\n  }\\n\\n  for (let i = nums.length - 1; i >= 0; i--) {\\n    // compute right product for nums[i] and multiply it with the left product\\n    result[i] *= right;\\n    right *= nums[i];\\n  }\\n\\n  return result;\\n};\\nmodule.exports = productExceptSelf;\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nnums = [1,2,3,4]\\n```\n```\\nleftArr[0] = 1\\nleftArr[1] = 1 * nums[0] = 1 * 1 = 1\\nleftArr[2] = 1 * nums[0] * nums[1] = 1 * 1 * 2 = 2\\nleftArr[3] = 1 * nums[0] * nums[1] * nums[2] = 1 * 1 * 2 * 3 = 6\\n```\n```\\nrightArr[3] = 1\\nrightArr[2] = 1 * nums[3] = 1 * 4 = 4\\nrightArr[1] = 1 * nums[3] * nums[2] = 1 * 4 * 3 = 12\\nrightArr[0] = 1 * nums[3] * nums[2] * nums[1] = 1 * 4 * 3 * 2 = 24\\n\\n```\n```\\nresult[0] = leftArr[2] * rightArr[1] = 2 * 12 = 24\\nresult[1] = leftArr[1] * rightArr[2] = 1 * 24 = 24\\nresult[2] = leftArr[0] * rightArr[3] = 1 * 1 = 1\\nresult[3] = leftArr[3] * rightArr[0] = 6 * 1 = 6\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function (nums) {\\n  /**\\n   * @param {number[]} nums\\n   * @return {number[]}\\n   */\\n  /*\\n  //1st solution -> Not constant memory\\n  //TIME: O(n)\\n  //MEMORY: O(n)\\n  let leftArr = [];\\n  let rightArr = [];\\n  let result = [];\\n  let left = 1;\\n  let right = 1;\\n  const length = nums.length - 1;\\n  let rIndex = length - 1;\\n  let lIndex = -1;\\n  for (let i = 0; i < nums.length; i++) {\\n    left = left * nums[i];\\n    leftArr.push(left);\\n  }\\n  for (let i = nums.length - 1; i > -1; i--) {\\n    right = right * nums[i];\\n    rightArr.push(right);\\n  }\\n  console.log(leftArr, rightArr);\\n  for (let i = 0; i < nums.length; i++) {\\n    const res =\\n      (lIndex == -1 ? 1 : leftArr[lIndex]) *\\n      (rIndex == -1 ? 1 : rightArr[rIndex]);\\n    result.push(res);\\n    rIndex--;\\n    lIndex++;\\n  }\\n  return result;\\n  */\\n  //TIME: O(n)\\n  //MEMORY: O(1)\\n  let result = [];\\n  let left = 1;\\n  let right = 1;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    // compute left product for nums[i]\\n    result[i] = left;\\n    left *= nums[i];\\n  }\\n\\n  for (let i = nums.length - 1; i >= 0; i--) {\\n    // compute right product for nums[i] and multiply it with the left product\\n    result[i] *= right;\\n    right *= nums[i];\\n  }\\n\\n  return result;\\n};\\nmodule.exports = productExceptSelf;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 744951,
                "title": "product-of-array-except-self-python3-solution-with-a-detailed-explanation",
                "content": "It\\'s easy to see what you have to do is to calculate the product of array numbers up to index `i`, multiplied by numbers from `i+1` to the end. In an array like this: `nums = [a,b,c,d,e]`, you need to come up with `res = [|bcde, a|cde, ab|de, abc|e, abcd|]`. I added a `|` to show where the index we\\'re excluding would go. Makes sense? \\n\\nNow, how would you start? Note that if we could come up with two arrays, one keeping track of `leftProducts` and one `rightProducts`, we could multiply each entry of them to get the desired results, right? In the above example, if we could get `leftProducts = [1,a,ab,abc,abcd]` and `rightProducts = [bcde, cde,de,e, 1]`, and we multiply the two, we would end up with `res = [bcde, acde, abde, abce, abcd]`, right? That\\'s what we want, and following solution is doing exactly that. While you\\'re reading through the code, check the above example. I\\'m pretty sure it\\'d be easier to follow based on that example. \\n\\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        leftProducts = [0]*len(nums) # initialize left array \\n        rightProducts = [0]*len(nums) # initialize right array\\n        \\n        leftProducts[0] = 1 # the left most is 1\\n        rightProducts[-1] = 1 # the right most is 1\\n        res = [] # output\\n        \\n        for i in range(1, len(nums)):\\n            leftProducts[i] = leftProducts[i-1]*nums[i-1]\\n            rightProducts[len(nums) - i - 1] = rightProducts[len(nums) - i]*nums[len(nums) - i]\\n            \\n        for i in range(len(nums)):\\n            res.append(leftProducts[i]*rightProducts[i])\\n        \\n        return res\\n```\\n\\nThis solution has time and space complexity of `O(n)`. However, we can make the space complexity `O(1)`. Here is a better version of above solution in which we don\\'t initialize two arrays, instead we save the products in the output array. Here, you `output` array after the first `for` loop would be similar to the `leftProducts` in the above solution. And, after the second `for` loop, the result is complete. Note that in the first `for` loop, the last element (although we\\'re iterating until the last element) is not being added to `res`. On the second `for` loop, we\\'re iterating backward from last element, however, `p=1` gets re-initialized. Therefore, the last element of `res` doesn\\'t change which is the product of all the numbers up to the last entry. After each passing of line `#1`, variable `p` gets updated to take into account the `nums[i]` for the next product. \\n\\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        res = []\\n        \\n        p = 1\\n        for i in range(len(nums)):\\n            res.append(p)\\n            p = p * nums[i]\\n        \\n        p = 1\\n        for i in range(len(nums) - 1, -1, -1):\\n            res[i] = res[i] * p #1\\n            p = p*nums[i]\\n        \\n        return res\\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        leftProducts = [0]*len(nums) # initialize left array \\n        rightProducts = [0]*len(nums) # initialize right array\\n        \\n        leftProducts[0] = 1 # the left most is 1\\n        rightProducts[-1] = 1 # the right most is 1\\n        res = [] # output\\n        \\n        for i in range(1, len(nums)):\\n            leftProducts[i] = leftProducts[i-1]*nums[i-1]\\n            rightProducts[len(nums) - i - 1] = rightProducts[len(nums) - i]*nums[len(nums) - i]\\n            \\n        for i in range(len(nums)):\\n            res.append(leftProducts[i]*rightProducts[i])\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        res = []\\n        \\n        p = 1\\n        for i in range(len(nums)):\\n            res.append(p)\\n            p = p * nums[i]\\n        \\n        p = 1\\n        for i in range(len(nums) - 1, -1, -1):\\n            res[i] = res[i] * p #1\\n            p = p*nums[i]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1382895,
                "title": "c-product-of-array-except-self-5-different-solutions",
                "content": "# **LeetCode + Todoist = Consistent Grind -- TRY [Code Task](https://codetask.vercel.app/)**\\n\\n**1. iterate the whole array twice and calculating the result by multiplying**\\n* **Time Complexcity : `O(n\\xB2)`**\\n* **Space Complexcity : `O(1)`**\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 1);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == j){\\n                    continue;\\n                }\\n                ans[i] = ans[i] * nums[j]; \\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n**2. multiply the whole array at once and calculating the result by dividing**\\n* **Time Complexcity : `O(n)`**\\n* **Space Complexcity : `O(1)`**\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans;\\n        \\n        int zero = 0;\\n        int product = 1;\\n        for(auto x : nums){\\n            if(x == 0){\\n                zero = zero + 1;\\n            }else{\\n                product = product * x;\\n            }\\n        }\\n        \\n        for(auto x : nums){\\n            if(x == 0){\\n                if(zero != 1){\\n                    ans.push_back(0);\\n                }else{\\n                    ans.push_back(product);\\n                }\\n            }else{\\n                if(zero == 0){\\n                    ans.push_back(product/x);\\n                }else{\\n                     ans.push_back(0);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**3. maintain both right product array and left product array**\\n* **Time Complexcity : `O(n)`**\\n* **Space Complexcity : `O(n)`**\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        vector<int> leftProd(n);\\n        vector<int> rightProd(n);\\n        \\n        leftProd[0] = 1;\\n        for(int i = 1; i < nums.size(); i++){\\n            leftProd[i] = leftProd[i - 1] * nums[i - 1];\\n        }\\n        \\n        rightProd[n - 1] = 1;\\n        for (int j = n - 2; j >= 0; j--) {\\n            rightProd[j] = rightProd[j + 1] * nums[j + 1];\\n        }\\n        \\n        for (int k = 0; k < n; k++) {\\n            ans[k]= leftProd[k] * rightProd[k];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**4. maintain right product array and calculate *leftProd* variable used to simulate left product array**\\n* **Time Complexcity : `O(n)`**\\n* **Space Complexcity : `O(n)`**\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        vector<int> rightProd(n);\\n        \\n        rightProd[n - 1] = 1;\\n        for (int j = n - 2; j >= 0; j--) {\\n            rightProd[j] = rightProd[j + 1] * nums[j + 1];\\n        }\\n        \\n        int leftProd = 1;\\n        for(int i = 0; i < nums.size(); i++){\\n            ans[i] = rightProd[i] * leftProd;\\n            leftProd = leftProd * nums[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n**5. *ans* array used as right product array and *leftProd* variable used to simulate left product array**\\n* **Time Complexcity : `O(n)`**\\n* **Space Complexcity : `O(1)`**\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> ans(n);\\n        \\n        ans[n - 1] = 1; // ans array used as right product array\\n        for(int i = n - 2; i >= 0; i--){\\n            ans[i] = nums[i + 1] * ans[i + 1];\\n        }\\n        \\n        int leftProd = 1;\\n        for(int i = 0; i < n; i++){\\n            ans[i] = leftProd * ans[i];\\n            leftProd = leftProd * nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 1);\\n        \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(i == j){\\n                    continue;\\n                }\\n                ans[i] = ans[i] * nums[j]; \\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans;\\n        \\n        int zero = 0;\\n        int product = 1;\\n        for(auto x : nums){\\n            if(x == 0){\\n                zero = zero + 1;\\n            }else{\\n                product = product * x;\\n            }\\n        }\\n        \\n        for(auto x : nums){\\n            if(x == 0){\\n                if(zero != 1){\\n                    ans.push_back(0);\\n                }else{\\n                    ans.push_back(product);\\n                }\\n            }else{\\n                if(zero == 0){\\n                    ans.push_back(product/x);\\n                }else{\\n                     ans.push_back(0);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        vector<int> leftProd(n);\\n        vector<int> rightProd(n);\\n        \\n        leftProd[0] = 1;\\n        for(int i = 1; i < nums.size(); i++){\\n            leftProd[i] = leftProd[i - 1] * nums[i - 1];\\n        }\\n        \\n        rightProd[n - 1] = 1;\\n        for (int j = n - 2; j >= 0; j--) {\\n            rightProd[j] = rightProd[j + 1] * nums[j + 1];\\n        }\\n        \\n        for (int k = 0; k < n; k++) {\\n            ans[k]= leftProd[k] * rightProd[k];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        vector<int> rightProd(n);\\n        \\n        rightProd[n - 1] = 1;\\n        for (int j = n - 2; j >= 0; j--) {\\n            rightProd[j] = rightProd[j + 1] * nums[j + 1];\\n        }\\n        \\n        int leftProd = 1;\\n        for(int i = 0; i < nums.size(); i++){\\n            ans[i] = rightProd[i] * leftProd;\\n            leftProd = leftProd * nums[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        vector<int> ans(n);\\n        \\n        ans[n - 1] = 1; // ans array used as right product array\\n        for(int i = n - 2; i >= 0; i--){\\n            ans[i] = nums[i + 1] * ans[i + 1];\\n        }\\n        \\n        int leftProd = 1;\\n        for(int i = 0; i < n; i++){\\n            ans[i] = leftProd * ans[i];\\n            leftProd = leftProd * nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65799,
                "title": "java-solution-with-o-n-time-and-constant-space-only-the-output-array",
                "content": "    public class Solution {\\n        public int[] productExceptSelf(int[] nums) {\\n            int[] output = new int[nums.length];\\n    \\n            // from left to right process\\n            // output[i] = product of all numbers left of i\\n            for (int i = 0; i < nums.length; i++) {\\n                if (i == 0) {\\n                    output[i] = 1;\\n                } else {\\n                    output[i] = output[i - 1] * nums[i - 1];\\n                }\\n            }\\n    \\n            // from right to left\\n            // t is the product of all numbers right of j\\n            for (int j = nums.length - 1, t = 1; j >= 0; j--) {\\n                // the final result\\n                output[j] = output[j] * t;\\n                t = t * nums[j];\\n            }\\n    \\n            return output;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int[] productExceptSelf(int[] nums) {\\n            int[] output = new int[nums.length];\\n    \\n            // from left to right process\\n            // output[i] = product of all numbers left of i\\n            for (int i = 0; i < nums.length; i++) {\\n                if (i == 0) {\\n                    output[i] = 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3465090,
                "title": "c-solution-with-explanation",
                "content": "First of all, since the index element isn\\'t taken into account while multiplying, we create a vector with a size that matches the supplied vector size and an initialization value of 1.\\n\\n![IMG_9190.PNG](https://assets.leetcode.com/users/images/199a0925-76bc-4835-9503-af60275b4131_1682742401.500352.png)\\n\\nFirst, we finish the part\\'s left-side multiplication for each individual element. \\n\\n![IMG_9191.PNG](https://assets.leetcode.com/users/images/98be38ee-4870-4c9a-bbef-90d667b02bd4_1682742996.564627.png)\\n\\nOnce the right side of the part has been multiplied for each individual element.\\n\\n![IMG_9192.PNG](https://assets.leetcode.com/users/images/278ffaa7-6b28-4b05-ba18-050de7509aeb_1682743035.8224885.png)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> output(n, 1);\\n\\n        int left_prod = 1;\\n        for(int i = 1; i < n; i++) {\\n            left_prod *= nums[i-1];\\n            output[i] *= left_prod;\\n        }\\n\\n        int right_prod = 1;\\n        for(int i = n-2; i >= 0; i--) {\\n            right_prod *= nums[i+1];\\n            output[i] *= right_prod;\\n        }\\n\\n        return output;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> output(n, 1);\\n\\n        int left_prod = 1;\\n        for(int i = 1; i < n; i++) {\\n            left_prod *= nums[i-1];\\n            output[i] *= left_prod;\\n        }\\n\\n        int right_prod = 1;\\n        for(int i = n-2; i >= 0; i--) {\\n            right_prod *= nums[i+1];\\n            output[i] *= right_prod;\\n        }\\n\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598337,
                "title": "python-3-lines-solution-explained",
                "content": "We can use cumulative products for boths sides and then multipy them elementwise.\\n\\n#### Complexity\\nIt is `O(n)` both for time and space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums):\\n        t1 = [1] + list(accumulate(nums, mul))[:-1]\\n        t2 = list(accumulate(nums[::-1], mul))[::-1][1:] + [1]\\n        return [x*y for x, y in zip(t1, t2)]\\n```\\n\\n#### Remark\\nFor `O(1)` space complexity we can first create empty output array and then traverse it twice from different ends.\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def productExceptSelf(self, nums):\\n        t1 = [1] + list(accumulate(nums, mul))[:-1]\\n        t2 = list(accumulate(nums[::-1], mul))[::-1][1:] + [1]\\n        return [x*y for x, y in zip(t1, t2)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511986,
                "title": "easy-solution-in-java-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        //Approach: Using prefix and postfix\\n        //Idea: Just find prefix and postfix product and keep them in the ans array\\n\\n        int ans[] = new int[nums.length];\\n        int pre = 1, post = 1;\\n        \\n        //find pre product\\n        for(int i=0;i<nums.length;i++){\\n            ans[i] = pre;\\n            pre*=nums[i];\\n        }\\n\\n        //find post product\\n        for(int i=nums.length-1;i>=0;i--){\\n            ans[i]*=post;\\n            post*=nums[i];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        //Approach: Using prefix and postfix\\n        //Idea: Just find prefix and postfix product and keep them in the ans array\\n\\n        int ans[] = new int[nums.length];\\n        int pre = 1, post = 1;\\n        \\n        //find pre product\\n        for(int i=0;i<nums.length;i++){\\n            ans[i] = pre;\\n            pre*=nums[i];\\n        }\\n\\n        //find post product\\n        for(int i=nums.length-1;i>=0;i--){\\n            ans[i]*=post;\\n            post*=nums[i];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1474385,
                "title": "c-o-1-space-o-n-time-easiest-explanation-image",
                "content": "## **LOGIC (STOP ON THE INDEX AND LOOK)**\\n\\n- You might never heard of this approach, but this is the best way to solve the problems. Bear with me.\\n- First of all the problem statement mention that you can\\'t use the division operation in the problem!! If asked\\n    - Consider an array like [1,2,3,0] then if you come up with the division operation, then you can\\'t find the result for the last index position (TRY ON YOUR OWN) as you can\\'t divide any number with the 0.\\n- Now we will iterate through the whole array two times.\\n    - First from the left to the right to add the product of all numbers present on the left side of that element\\n    - Second, from the right to the left to add the product of all numbers in the existence product present on the right side of that element.\\n    - Voila!! It\\'s done.\\n\\n# **IMAGE AS PROMISED:**\\n\\nPS: My handwriting is pretty bad :) If you don\\'t get what I write in this image, let me know in the comments.\\n\\n![https://assets.leetcode.com/users/images/7a1293fe-418d-400b-82f5-7cda631b906f_1632123381.6407583.jpeg](https://assets.leetcode.com/users/images/7a1293fe-418d-400b-82f5-7cda631b906f_1632123381.6407583.jpeg)\\n\\n```\\nvector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> r(nums.size(),1);\\n        for (auto i=1;i<nums.size();++i){\\n            r[i]=r[i-1]*nums[i-1];\\n        }\\n        int multiplier=nums.back();\\n        for (int i=nums.size()-2;i>=0;--i){\\n            r[i]=r[i]*multiplier;\\n            multiplier*=nums[i];\\n        }\\n        return r;\\n}\\n```\\n\\n**Like it? please upvote...Have any comments? I\\'d love to hear!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> r(nums.size(),1);\\n        for (auto i=1;i<nums.size();++i){\\n            r[i]=r[i-1]*nums[i-1];\\n        }\\n        int multiplier=nums.back();\\n        for (int i=nums.size()-2;i>=0;--i){\\n            r[i]=r[i]*multiplier;\\n            multiplier*=nums[i];\\n        }\\n        return r;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1285112,
                "title": "c-brute-force-optimised-approach",
                "content": "**1. Brute force approach**\\n**Time:O(n)\\nspace:O(n)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int>n(nums.size());\\n        vector<int>m(nums.size());\\n        vector<int>ans(nums.size());\\n        n[0]=1;\\n        m[nums.size()-1]=1;\\n        for(int i=1;i<nums.size();i++){\\n            n[i]=n[i-1]*nums[i-1];\\n        } \\n        for(int i=nums.size()-2;i>=0;i--){\\n            m[i]=m[i+1]*nums[i+1];\\n        }\\n        for(int i=0;i<ans.size();i++){\\n         ans[i]=n[i]*m[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**2.Optimized approach**\\n**time:O(n)\\nspace:O(1)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>output;\\n        if(n<1){\\n            return output;\\n        }\\n        int product=1;\\n        for(int i=0;i<n;i++){\\n            product*=nums[i];\\n            output.push_back(product);\\n        }\\n        //traverse from right array and update output array\\n        product=1;\\n        for(int i=n-1;i>0;i--){\\n            output[i]=output[i-1]*product;\\n            product*=nums[i];\\n        }\\n        output[0]=product;\\n        return output;\\n    }\\n};\\n```\\nIf you like the solution ,upvote it and encourage me.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int>n(nums.size());\\n        vector<int>m(nums.size());\\n        vector<int>ans(nums.size());\\n        n[0]=1;\\n        m[nums.size()-1]=1;\\n        for(int i=1;i<nums.size();i++){\\n            n[i]=n[i-1]*nums[i-1];\\n        } \\n        for(int i=nums.size()-2;i>=0;i--){\\n            m[i]=m[i+1]*nums[i+1];\\n        }\\n        for(int i=0;i<ans.size();i++){\\n         ans[i]=n[i]*m[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>output;\\n        if(n<1){\\n            return output;\\n        }\\n        int product=1;\\n        for(int i=0;i<n;i++){\\n            product*=nums[i];\\n            output.push_back(product);\\n        }\\n        //traverse from right array and update output array\\n        product=1;\\n        for(int i=n-1;i>0;i--){\\n            output[i]=output[i-1]*product;\\n            product*=nums[i];\\n        }\\n        output[0]=product;\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385915,
                "title": "99-beats-for-time-complexity-best-solution-best-approach-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a result array with the same length as the input array, initializing all elements to 1. \\nIterate through the input array from the beginning, calculating the product of all elements before the current index. Multiply the corresponding element in the result array by this product.\\n    Iterate through the input array from the end, calculating the product of all elements after the current index. Multiply the corresponding element in the result array by this product.\\n    Return the result array.\\nThe given solution works for arrays containing zeros. There is no need to change the approach for such cases.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function(nums) {\\n  const length = nums.length;\\n  const result = new Array(length).fill(1);\\n\\n  // Calculate the product of elements before the current index\\n  let productBefore = 1;\\n  for (let i = 0; i < length; i++) {\\n    result[i] *= productBefore;\\n    productBefore *= nums[i];\\n  }\\n\\n  // Calculate the product of elements after the current index\\n  let productAfter = 1;\\n  for (let i = length - 1; i >= 0; i--) {\\n    result[i] *= productAfter;\\n    productAfter *= nums[i];\\n  }\\n\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function(nums) {\\n  const length = nums.length;\\n  const result = new Array(length).fill(1);\\n\\n  // Calculate the product of elements before the current index\\n  let productBefore = 1;\\n  for (let i = 0; i < length; i++) {\\n    result[i] *= productBefore;\\n    productBefore *= nums[i];\\n  }\\n\\n  // Calculate the product of elements after the current index\\n  let productAfter = 1;\\n  for (let i = length - 1; i >= 0; i--) {\\n    result[i] *= productAfter;\\n    productAfter *= nums[i];\\n  }\\n\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2846283,
                "title": "python-96-15-faster-t-c-o-n-s-c-o-1-prefix-and-postfix-array",
                "content": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        prefix,n=1,len(nums)\\n        answer=[1]\\n        for i in range(1,n):\\n            prefix*=nums[i-1]\\n            answer.append(prefix)\\n        postfix=1\\n        for i in range(n-2,-1,-1):\\n            postfix*=nums[i+1]\\n            answer[i]*=postfix\\n        return answer\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        prefix,n=1,len(nums)\\n        answer=[1]\\n        for i in range(1,n):\\n            prefix*=nums[i-1]\\n            answer.append(prefix)\\n        postfix=1\\n        for i in range(n-2,-1,-1):\\n            postfix*=nums[i+1]\\n            answer[i]*=postfix\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1746766,
                "title": "c-two-solutions-with-examples-detailed-explanation",
                "content": "\\n\\nAs much as we are tempted to use the division operator, we need to solve it according to the condition to get the most out of it. So let\\'s get started! \\u263A\\uFE0F\\n\\nFirst, I am giving a solution with O(n) space and O(n) time and then we will optimize the space. \\n\\n### **1. Space and Time Complexity: O(n)**\\n\\nWe will maintain two arrays: left and right to store the multiplication from the left and right sides. The multiplication will **exclude the current element**, that\\'s why the first element of left and last element of right is 1.\\nOur answer array will be the multiplication of the respective elements of left and right.\\n\\nExample: \\nif nums = [2, 3, 4, 5]\\nthen,\\nleft = [1, 2, 2 * 3, 2 * 3* 4] = [1, 2, 6, 24]\\n       right = [3 * 4 * 5, 4 * 5, 5, 1] = [60, 20, 5, 1] \\n\\t   \\n  =>  ans = [120, 40, 30, 24]\\n  \\n  **Code:**\\n  ```\\n  class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans (n);\\n        vector<int> left (n,1);\\n        vector<int> right (n,1);\\n    \\n        int lf=nums[0],rf=nums[n-1];\\n        \\n        for(int i=1;i<n;++i){\\n            left[i]=lf;\\n            lf*=nums[i];\\n        }\\n        \\n        for(int i=n-2;i>=0;--i){\\n            right[i]*=rf;\\n            rf*=nums[i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            ans[i]=left[i]*right[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n### **2. Space Complexity: O(1) and Time Complexity: O(n)**\\nInstead of calculating the array, we will calculate and store the result directly in our answer array. \\nWe will keep two variables: lf and rf. lf will keep track of the left multiplication and update the answer array. Similarly, rf will keep track of the right multiplication and update the answer array. \\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans (n,1);\\n        int lf=nums[0],rf=nums[n-1];\\n        for(int i=1;i<n;++i){\\n            ans[i]=lf;\\n            lf*=nums[i];\\n        }\\n        for(int i=n-2;i>=0;--i){\\n            ans[i]*=rf;\\n            rf*=nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n  class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans (n);\\n        vector<int> left (n,1);\\n        vector<int> right (n,1);\\n    \\n        int lf=nums[0],rf=nums[n-1];\\n        \\n        for(int i=1;i<n;++i){\\n            left[i]=lf;\\n            lf*=nums[i];\\n        }\\n        \\n        for(int i=n-2;i>=0;--i){\\n            right[i]*=rf;\\n            rf*=nums[i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            ans[i]=left[i]*right[i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans (n,1);\\n        int lf=nums[0],rf=nums[n-1];\\n        for(int i=1;i<n;++i){\\n            ans[i]=lf;\\n            lf*=nums[i];\\n        }\\n        for(int i=n-2;i>=0;--i){\\n            ans[i]*=rf;\\n            rf*=nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 580696,
                "title": "c-o-1-space-o-n-time-thought-process-explained-4-solutions",
                "content": "Hi, this question is a pretty famous one, so I thought I\\'d write a guide for all of you who encounter it, so you can know how to explain it to the interviewer. Keep in mind that I\\'ll be walking you through the complete though process and how to improve a solution one step at a time, so let\\'s begin!\\n\\n# 1. Brute Force\\nWhen starting the solution, the initial idea that should come to your mind is obviously brute force. In this case what we are doing is we are traversing the whole array and whenever we stumble upon different indeces we multiply our final result. Here\\'s a quick solution of how it works:\\n```cpp\\nvector<int> res; \\nfor (int i = 0; i < nums.size(); i++)\\n{\\n\\tres.push_back(1);\\n\\tfor (int j = 0; j < nums.size(); j++)\\n\\t\\tif (i != j)\\n\\t\\t\\tres[i] *= nums[j];\\n}\\nreturn res;\\n```\\nThis solution is obviously not the most efficient. Yes, we do use O(1) space and we don\\'t use division just like stated in our optimal solution info, but our running time is O(N^2) and quadratic time is almost never good in problems as simple as this one. That is why we move on to the second idea.\\n# 2. Division\\nIn our case problem states there is no use of division allowed, but depending on the interviewer, this may not be clarified in the beginning. Idea is simple, but keep in mind that your interviewer will probably require a more complex solution (of course in terms of design, not runtime). We do a simple preprocessing step to find the sum of all the arrays and later on, in order to exclude an item, we simply divide it by a given item. Here\\'s a code snippet that illustrates the solution properly:\\n```cpp\\nint zeroCount = 0;\\nvector<int> res;\\nint prod = 1;\\nfor (int i : nums)\\n{\\n\\tif (i != 0)\\n\\t\\tprod *= i;\\n\\telse\\n\\t\\tzeroCount++;\\n}\\nfor (int i : nums)\\n{\\n\\tif (zeroCount == 1 && i == 0)\\n\\t\\tres.push_back(prod);\\n\\telse if (zeroCount == 1 && i != 0)\\n\\t\\tres.push_back(0);\\n\\telse if (zeroCount > 1)\\n\\t\\tres.push_back(0);\\n\\telse\\n\\t\\tres.push_back(prod / i);\\n}\\nreturn res;\\n```\\nThis solution checks all the boxes stated by the question, except for the no division statement. After all, it would be too use was this allowed, wouldn\\'t it?\\n# 3. Memoization (kind of...)\\nI know it may sound weird, but this problem is kind of a DP problem, although not directly stated. Take a look at the following example:\\n`1 2 3 4` should result in `24 12 8 6`\\nWe can see that for both products excluding 1 and 2, we need the product of 3 and 4. In a similar fashion, we can see we need same subproblems for multiple problems. This gives us overlapping problems, there\\'s \\'optimal substructure\\' as well, but not completely. Still, this gives us room to experiment by keeping our solutions in cache.\\nHere\\'s the concept that should describe the working process. For each solution we need products of elements on its right and on its left, thus we could use two arrays to store these values for each of the excluded elements. Since sum of elements on the left of 3 is 1 * 2 and one on the right of 4 is 1 * 2 * 3, we can see the following formula:\\n`left[i] = left[i - 1] * nums[i - 1]`\\nSimilarly:\\n`right[i] = right[i + 1] * nums[i + 1]`\\nHow about our base cases, what if i +1 or i - 1 get out of the given bound? Since we are working with the products, it results in 1, a neutral number in both division and multiplication. Were we to work with sums, we could just swap 1 for the adequate addition element 0. Simple, isn\\'t it?\\nNow let\\'s see how we can implement this solution:\\n```cpp\\nvector<int> res(nums.size());\\nvector<int> leftProd(nums.size());\\nvector<int> rightProd(nums.size());\\nleftProd[0] = 1;\\nrightProd[rightProd.size() - 1] = 1;\\nfor (int i = 1; i < nums.size(); i++)\\n{\\n\\tleftProd[i] = leftProd[i - 1] * nums[i - 1];\\n\\trightProd[nums.size() - 1 - i] = rightProd[nums.size() - i] * nums[nums.size() - i];\\n}\\nfor (int i = 0; i < res.size(); i++)\\n\\tres[i] = leftProd[i] * rightProd[i];\\nreturn res;\\n```\\nI, myself, used to try solving this problem using push_back when working with vectors, but it is only possible to do so with the left array, unless you are willing to reverse the whole right product array, which is by no means a good practice, so I don\\'t recommend doing so.\\nBack to the solution. Once we\\'ve computed all the left and right products, only thing left to do is get the final products which we get simply by multiplying the two.\\nThis solution is what you will be expected to come up with in an interview, which runs in O(N) time, but also uses O(2 * N) = O(N) space. Last solution does improve space, but it simply builds up on it, so you are not required to know it, but it is some extra points if you \\'come up\\' with it during an interview.\\n# 4. Memoization - Improved\\nSince this solution simply builds up on the last one, there is no need to really explain too much about it. We do need two passes for this one tho, so it makes it slightly less efficient in terms of time, but nothing that will save us in a real-life scenario or even contest.\\nInstead of creating two arrays, we store all the values in our resulting array (this doesn\\'t count as extra space in most interviews), but for keeping right values we will use a single variable. In practice, we retrieve all the products on the left from our result array and multiply them with the current right product. It\\'s important to note that we do so in reverse order (either left->right and right->left or right->left and left->right will do the trick). Here\\'s a code for those interested in it:\\n```cpp\\nvector<int> res(nums.size());\\nres[0] = 1;\\nint rProd = 1;\\nfor (int i = 1; i < nums.size(); i++)\\n\\tres[i] = res[i - 1] * nums[i - 1];\\nfor (int i = nums.size() - 1; i >= 0; i--)\\n{\\n\\tres[i] = res[i] * rProd;\\n\\trProd = rProd * nums[i];\\n}\\nreturn res;\\n```\\nThat\\'s it, simple to get a grasp of, right? I really hope you enjoyed my explanation and let me know if there is anything to improve about it. It would mean much if you could provide any feedback.",
                "solutionTags": [],
                "code": "```cpp\\nvector<int> res; \\nfor (int i = 0; i < nums.size(); i++)\\n{\\n\\tres.push_back(1);\\n\\tfor (int j = 0; j < nums.size(); j++)\\n\\t\\tif (i != j)\\n\\t\\t\\tres[i] *= nums[j];\\n}\\nreturn res;\\n```\n```cpp\\nint zeroCount = 0;\\nvector<int> res;\\nint prod = 1;\\nfor (int i : nums)\\n{\\n\\tif (i != 0)\\n\\t\\tprod *= i;\\n\\telse\\n\\t\\tzeroCount++;\\n}\\nfor (int i : nums)\\n{\\n\\tif (zeroCount == 1 && i == 0)\\n\\t\\tres.push_back(prod);\\n\\telse if (zeroCount == 1 && i != 0)\\n\\t\\tres.push_back(0);\\n\\telse if (zeroCount > 1)\\n\\t\\tres.push_back(0);\\n\\telse\\n\\t\\tres.push_back(prod / i);\\n}\\nreturn res;\\n```\n```cpp\\nvector<int> res(nums.size());\\nvector<int> leftProd(nums.size());\\nvector<int> rightProd(nums.size());\\nleftProd[0] = 1;\\nrightProd[rightProd.size() - 1] = 1;\\nfor (int i = 1; i < nums.size(); i++)\\n{\\n\\tleftProd[i] = leftProd[i - 1] * nums[i - 1];\\n\\trightProd[nums.size() - 1 - i] = rightProd[nums.size() - i] * nums[nums.size() - i];\\n}\\nfor (int i = 0; i < res.size(); i++)\\n\\tres[i] = leftProd[i] * rightProd[i];\\nreturn res;\\n```\n```cpp\\nvector<int> res(nums.size());\\nres[0] = 1;\\nint rProd = 1;\\nfor (int i = 1; i < nums.size(); i++)\\n\\tres[i] = res[i - 1] * nums[i - 1];\\nfor (int i = nums.size() - 1; i >= 0; i--)\\n{\\n\\tres[i] = res[i] * rProd;\\n\\trProd = rProd * nums[i];\\n}\\nreturn res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 571688,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:     \\n        left, right = [1]*len(nums), [1]*len(nums)\\n        \\n        # build left\\n        for i in range(1, len(nums)):\\n            left[i] = left[i-1]*nums[i-1]\\n\\n        # build right\\n        for i in reversed(range(0, len(nums)-1)):\\n            right[i] = right[i+1]*nums[i+1]\\n            \\n        # build final list\\n        for i in range(len(nums)):\\n            nums[i] = left[i]*right[i]\\n            \\n        return nums            \\n\\n  ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:     \\n        left, right = [1]*len(nums), [1]*len(nums)\\n        \\n        # build left\\n        for i in range(1, len(nums)):\\n            left[i] = left[i-1]*nums[i-1]\\n\\n        # build right\\n        for i in reversed(range(0, len(nums)-1)):\\n            right[i] = right[i+1]*nums[i+1]\\n            \\n        # build final list\\n        for i in range(len(nums)):\\n            nums[i] = left[i]*right[i]\\n            \\n        return nums            \\n\\n  ```",
                "codeTag": "Java"
            },
            {
                "id": 409640,
                "title": "python-o-n-constant-space-with-two-pointers-and-simple",
                "content": "```py\\ndef productExceptSelf(self, nums: List[int]) -> List[int]:\\n\\t\\t#output array (just fill empty with 1s)\\n        res = [1] * len(nums)\\n        #left and right pointers\\n        lo = 0\\n        hi = len(nums) - 1\\n        #product for left and right\\n        leftProduct = 1\\n        rightProduct = 1\\n        #keep going until pointers meet\\n        while lo < len(nums):\\n            #add running from the l/r products to these spots\\n            res[lo] *= leftProduct\\n            res[hi] *= rightProduct\\n            #multiply products by current in nums\\n            rightProduct *= nums[hi]\\n            leftProduct *= nums[lo]\\n            #inc/dec pointers\\n            lo += 1\\n            hi -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\ndef productExceptSelf(self, nums: List[int]) -> List[int]:\\n\\t\\t#output array (just fill empty with 1s)\\n        res = [1] * len(nums)\\n        #left and right pointers\\n        lo = 0\\n        hi = len(nums) - 1\\n        #product for left and right\\n        leftProduct = 1\\n        rightProduct = 1\\n        #keep going until pointers meet\\n        while lo < len(nums):\\n            #add running from the l/r products to these spots\\n            res[lo] *= leftProduct\\n            res[hi] *= rightProduct\\n            #multiply products by current in nums\\n            rightProduct *= nums[hi]\\n            leftProduct *= nums[lo]\\n            #inc/dec pointers\\n            lo += 1\\n            hi -= 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 65751,
                "title": "java-two-time-scan-solution",
                "content": " 1. First round: \\n     scan from left to right to compute the product of all elements to the left  of i  \\n     starting value is 1\\n 2. Second round: \\n     scan from right to left to compute the product of all elements to the right of i  \\n     use the left product to time the right product\\n\\n\\n----------\\n\\n     public int[] productExceptSelf(int[] nums) {\\n            int[] p = new int[nums.length];\\n            \\n            int product = 1;\\n            for(int i=0;i<p.length;++i){\\n                p[i] = product;\\n                product *= nums[i];\\n            }\\n            \\n            product = 1;\\n            for(int i=p.length-1;i>=0;--i){\\n                p[i]*=product;\\n                product*=nums[i];\\n            }\\n            return p;\\n        }",
                "solutionTags": [],
                "code": " 1. First round: \\n     scan from left to right to compute the product of all elements to the left  of i  \\n     starting value is 1\\n 2. Second round: \\n     scan from right to left to compute the product of all elements to the right of i  \\n     use the left product to time the right product\\n\\n\\n----------\\n\\n     public int[] productExceptSelf(int[] nums) {\\n            int[] p = new int[nums.length];\\n            \\n            int product = 1;\\n            for(int i=0;i<p.length;++i){\\n                p[i] = product;\\n                product *= nums[i];\\n            }\\n            \\n            product = 1;\\n            for(int i=p.length-1;i>=0;--i){\\n                p[i]*=product;\\n                product*=nums[i];\\n            }\\n            return p;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2545324,
                "title": "python-solution-with-a-little-math-and-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        \"\"\"\\n        for example:\\n            nums = [a, b, c, d]\\n        we want\\n            res = [bcd, acd, abd, bcd]\\n        \"\"\"\\n        res = [1] * nums\\n        product = 1\\n\\n        \"\"\"\\n        after that, we get\\n            res = [1, a, ab, abc]\\n        \"\"\"\\n        for i, num in enumerate(nums):\\n            res[i] *= product\\n            product *= num\\n\\n        \"\"\"\\n        from\\n            res  = [1, a, ab, abc]\\n            nums = [a, b, c, d]\\n        to\\n            res = [1 * dcb, a * dc, ab * d, abc * 1]\\n                = [bcd, acd, abd, bcd]\\n        \"\"\"\\n        product = 1\\n        for i in range(len(nums) - 1, -1, -1):\\n            res[i] *= product\\n            product *= nums[i]\\n\\n        return res\\n\\n```\\n\\nPlease vote if you like the solution or the explanation :)",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        \"\"\"\\n        for example:\\n            nums = [a, b, c, d]\\n        we want\\n            res = [bcd, acd, abd, bcd]\\n        \"\"\"\\n        res = [1] * nums\\n        product = 1\\n\\n        \"\"\"\\n        after that, we get\\n            res = [1, a, ab, abc]\\n        \"\"\"\\n        for i, num in enumerate(nums):\\n            res[i] *= product\\n            product *= num\\n\\n        \"\"\"\\n        from\\n            res  = [1, a, ab, abc]\\n            nums = [a, b, c, d]\\n        to\\n            res = [1 * dcb, a * dc, ab * d, abc * 1]\\n                = [bcd, acd, abd, bcd]\\n        \"\"\"\\n        product = 1\\n        for i in range(len(nums) - 1, -1, -1):\\n            res[i] *= product\\n            product *= nums[i]\\n\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652407,
                "title": "java-easy-solution-without-division-100-faster-o-n",
                "content": "**Code**\\n```java\\npublic int[] productExceptSelf(int[] nums) {\\n\\tint[] ans = new int[nums.length];\\n\\tint leftProd = 1;\\n\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\tans[i] = leftProd;\\n\\t\\tleftProd *= nums[i];\\n\\t}\\n\\n\\tint rightProd = 1;\\n\\tfor(int i = nums.length-1; i >= 0; i--) {\\n\\t\\tans[i] *= rightProd;\\n\\t\\trightProd *= nums[i];\\n\\t}\\n\\n\\treturn ans;\\n}\\n```\\n\\n**Explanation**\\nSo we need to find the new array without using division operator, so we make use of multiply operator with a smart observation.\\nWe see that for an index `i` in `ans` array the value is given by product of all left elements and product of all right element.\\nwe find prefix product first and then suffix product in the array.\\n\\nIt works like this:-\\n![image](https://assets.leetcode.com/users/images/71295c5f-7682-4276-a13b-d14e712f3918_1640685699.745131.png)\\n\\nHope it helps\\nThanks\\nDo upvote",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int[] productExceptSelf(int[] nums) {\\n\\tint[] ans = new int[nums.length];\\n\\tint leftProd = 1;\\n\\tfor(int i = 0; i < nums.length; i++) {\\n\\t\\tans[i] = leftProd;\\n\\t\\tleftProd *= nums[i];\\n\\t}\\n\\n\\tint rightProd = 1;\\n\\tfor(int i = nums.length-1; i >= 0; i--) {\\n\\t\\tans[i] *= rightProd;\\n\\t\\trightProd *= nums[i];\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 279536,
                "title": "i-was-asked-to-solve-with-division-during-the-interview",
                "content": "There are many edge cases to handle when solving this question with the division. I would rather not using division... but in case the interviewer asked (I was required to use division during a FB interview in 2017 and another time with Amazon in 2019), here is the solution.\\n\\nThe tricky scenario is to consider  \\n* one zero is in the array, e.g., [1,2,0,5,6] - the result will be [0, 0, 60, 0, 0]\\n* two or more zeros are in the array, e.g., [1,2,0,5,0] - the result will be [0, 0, 0, 0, 0]\\n\\nSo we need to track \\n* number of zeros \\n* the prod that to be used to do prod/nums[i] when nums[i] is not zero\\n* nonZeroProd that to be used for the single zero scenario\\n\\n```\\npublic int[] productExceptSelf(int[] nums) {\\n        int prod = 1;\\n        int nonZeroProd = 1;\\n        int zeroCount = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            prod *= nums[i];\\n            if(nums[i] != 0)\\n                nonZeroProd *= nums[i];\\n            else\\n                zeroCount++;\\n        }    \\n        \\n        int[] result = new int[nums.length];\\n        if(zeroCount>1) return result;\\n        for(int i = 0; i<nums.length; i++){\\n            if(nums[i] != 0)\\n                result[i] = prod/nums[i];\\n            else\\n                result[i] = nonZeroProd;\\n        }\\n        \\n        return result;\\n    }",
                "solutionTags": [],
                "code": "There are many edge cases to handle when solving this question with the division. I would rather not using division... but in case the interviewer asked (I was required to use division during a FB interview in 2017 and another time with Amazon in 2019), here is the solution.\\n\\nThe tricky scenario is to consider  \\n* one zero is in the array, e.g., [1,2,0,5,6] - the result will be [0, 0, 60, 0, 0]\\n* two or more zeros are in the array, e.g., [1,2,0,5,0] - the result will be [0, 0, 0, 0, 0]\\n\\nSo we need to track \\n* number of zeros \\n* the prod that to be used to do prod/nums[i] when nums[i] is not zero\\n* nonZeroProd that to be used for the single zero scenario\\n\\n```\\npublic int[] productExceptSelf(int[] nums) {\\n        int prod = 1;\\n        int nonZeroProd = 1;\\n        int zeroCount = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            prod *= nums[i];\\n            if(nums[i] != 0)\\n                nonZeroProd *= nums[i];\\n            else\\n                zeroCount++;\\n        }    \\n        \\n        int[] result = new int[nums.length];\\n        if(zeroCount>1) return result;\\n        for(int i = 0; i<nums.length; i++){\\n            if(nums[i] != 0)\\n                result[i] = prod/nums[i];\\n            else\\n                result[i] = nonZeroProd;\\n        }\\n        \\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 118532,
                "title": "c-solution",
                "content": "The idea is to:\\n1. first round to calculate the product of all left digits.\\n2. second round to calculate the product of all right digits.\\n\\n```\\n    public int[] ProductExceptSelf(int[] nums) {\\n            if (nums == null || nums.Length == 0)\\n                return null;\\n\\n            int[] result = new int[nums.Length];\\n            int temp = 1;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                result[i] = temp;\\n                temp *= nums[i];\\n            }\\n\\n            temp = 1;\\n            for (int i = result.Length - 1; i >= 0; i--)\\n            {\\n                result[i] *= temp;\\n                temp *= nums[i];\\n            }\\n\\n            return result;\\n    }",
                "solutionTags": [],
                "code": "The idea is to:\\n1. first round to calculate the product of all left digits.\\n2. second round to calculate the product of all right digits.\\n\\n```\\n    public int[] ProductExceptSelf(int[] nums) {\\n            if (nums == null || nums.Length == 0)\\n                return null;\\n\\n            int[] result = new int[nums.Length];\\n            int temp = 1;\\n\\n            for (int i = 0; i < nums.Length; i++)\\n            {\\n                result[i] = temp;\\n                temp *= nums[i];\\n            }\\n\\n            temp = 1;\\n            for (int i = result.Length - 1; i >= 0; i--)\\n            {\\n                result[i] *= temp;\\n                temp *= nums[i];\\n            }\\n\\n            return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3182074,
                "title": "super-easy-step-by-step-explained-java-solution-100-0ms-faster",
                "content": "# 2nd Approach\\nMade two helping array left and right.\\n```\\nright[n - 1] = 1; //right most element have to be 1.\\nleft[0] = 1; //leftmost element have to be 1.\\nfor(int i = n - 2; i >= 0; i--){\\n    right[i] = right[i + 1] * nums[i + 1];\\n}\\nfor(int i = 1; i < n; i++){\\n    left[i] = left[i - 1] * nums[i - 1];\\n}\\n```\\n![WhatsApp Image 2023-02-28 at 12.07.48 AM.jpeg](https://assets.leetcode.com/users/images/3554cd78-b689-4f04-8379-a414d2abefda_1677523092.5442686.jpeg)\\nUse two array like this and multiply ```l[i]``` with ```r[i]```;\\n\\nI will update this code again with more optimal space complexity.\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n\\n- Space complexity:\\n- $$O(n)$$\\n\\n# 1st Approach\\nFirst check for any 0 there in array. If you found a zero then increment a flag.\\n```\\nfor(int i = 0; i < n; i++){\\n    if(nums[i] != 0)\\n        total = total * nums[i];\\n    else\\n        flag += 1;\\n}\\n```\\nThen check for if the flag is 1 or greater than one. If flag is one then it means only total value will assign in ```nums[i] == 0```.\\n```\\nelse if(flag == 1){\\n    if(nums[i] != 0)\\n        nums[i] = 0;\\n    else\\n        nums[i] = total;\\n}\\n```\\nIf flag is greater than one then all the values will be zero.\\n```\\nif(flag > 1){\\n    nums[i] = 0;\\n}\\n```\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUpvote if you find this idea helpful(used division operator).\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        //2nd approach\\n        int n = nums.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        right[n - 1] = 1;\\n        left[0] = 1;\\n        for(int i = n - 2; i >= 0; i--){\\n            right[i] = right[i + 1] * nums[i + 1];\\n        }\\n        for(int i = 1; i < n; i++){\\n            left[i] = left[i - 1] * nums[i - 1];\\n        }\\n        for(int i = 0; i < n; i++){\\n            nums[i] = left[i] * right[i];\\n        }\\n        return nums;\\n        //1st approact O(n) but with division operator.\\n        // int n = nums.length, total = 1, flag = 0;\\n        // for(int i = 0; i < n; i++){\\n        //     if(nums[i] != 0)\\n        //         total = total * nums[i];\\n        //     else\\n        //         flag += 1;\\n        // }\\n        // for(int i = 0; i < n; i++){\\n        //     if(flag > 1){\\n        //         nums[i] = 0;\\n        //     }\\n        //     else if(flag == 1){\\n        //         if(nums[i] != 0)\\n        //             nums[i] = 0;\\n        //         else\\n        //             nums[i] = total;\\n        //     }\\n        //     else{\\n        //         nums[i] = total / nums[i];\\n        //     }\\n        // }\\n        // return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nright[n - 1] = 1; //right most element have to be 1.\\nleft[0] = 1; //leftmost element have to be 1.\\nfor(int i = n - 2; i >= 0; i--){\\n    right[i] = right[i + 1] * nums[i + 1];\\n}\\nfor(int i = 1; i < n; i++){\\n    left[i] = left[i - 1] * nums[i - 1];\\n}\\n```\n```l[i]```\n```r[i]```\n```\\nfor(int i = 0; i < n; i++){\\n    if(nums[i] != 0)\\n        total = total * nums[i];\\n    else\\n        flag += 1;\\n}\\n```\n```nums[i] == 0```\n```\\nelse if(flag == 1){\\n    if(nums[i] != 0)\\n        nums[i] = 0;\\n    else\\n        nums[i] = total;\\n}\\n```\n```\\nif(flag > 1){\\n    nums[i] = 0;\\n}\\n```\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        //2nd approach\\n        int n = nums.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        right[n - 1] = 1;\\n        left[0] = 1;\\n        for(int i = n - 2; i >= 0; i--){\\n            right[i] = right[i + 1] * nums[i + 1];\\n        }\\n        for(int i = 1; i < n; i++){\\n            left[i] = left[i - 1] * nums[i - 1];\\n        }\\n        for(int i = 0; i < n; i++){\\n            nums[i] = left[i] * right[i];\\n        }\\n        return nums;\\n        //1st approact O(n) but with division operator.\\n        // int n = nums.length, total = 1, flag = 0;\\n        // for(int i = 0; i < n; i++){\\n        //     if(nums[i] != 0)\\n        //         total = total * nums[i];\\n        //     else\\n        //         flag += 1;\\n        // }\\n        // for(int i = 0; i < n; i++){\\n        //     if(flag > 1){\\n        //         nums[i] = 0;\\n        //     }\\n        //     else if(flag == 1){\\n        //         if(nums[i] != 0)\\n        //             nums[i] = 0;\\n        //         else\\n        //             nums[i] = total;\\n        //     }\\n        //     else{\\n        //         nums[i] = total / nums[i];\\n        //     }\\n        // }\\n        // return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148153,
                "title": "c-solution-o-n-without-extra-space-with-explanation",
                "content": "I had to draw this out to really understand how to solve this properly. Let\\'s go through an example with an array with length 4. Let\\'s say it\\'s the one in this example [1, 2, 3, 4 ].  The below is all using the index and not the actual value.\\n\\nIndex 0 Product: 1 * 2 * 3\\nIndex 1 Product: 0 * 2 * 3\\nIndex 2 Product: 0 * 1 * 3\\nIndex 3 Product: 0 * 1 * 2\\n\\nThis can be written with pre-product and post-product notation. NOTE: (1..3) means index 1 * 2 * 3.\\n\\nIndex 0 => Pre(\"\") * Post(1..3)\\nIndex 1 =>Pre (0) * Post(2..3)\\nIndex 2 => Pre(0..1) * Post(3)\\nIndex 3 => Pre(0..2) * Post(\"\")\\n\\nYou will notice that the resulting array is then just the pre-product * post-product. So, index 0 is basically just the post product being multiplied from the end of the array to beginning + 1 and Index 3 is just the pre-product being multiplied from the front till the end - 1.   \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        //multiply each item except for yourself and put in an output vector\\n        vector<int> output( nums.size(), 1 ); //Initialize the result to all 1\\'s, since we are multiplying, don\\'t want to multiply by 0\\n        \\n        int pre = 1;   //Initialize to 1, since we will be multiplying\\n        int post = 1; //Initialize to 1, since we will be multiplying \\n        int end = nums.size() - 1;\\n       //Loop through the numbers forward and backwards to construt pre-product and post-product\\n        for ( int start = 0; start < nums.size(); start++, end-- ){\\n            output[start] *= pre;    //multiply the pre-product to start index\\n            output[end] *= post;   //multiply the post-product to end index\\n            pre *= nums[start];    //construct the pre-product as we iterate to end\\n            post *= nums[end];   //construct the post-product as we iterate to start\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        //multiply each item except for yourself and put in an output vector\\n        vector<int> output( nums.size(), 1 ); //Initialize the result to all 1\\'s, since we are multiplying, don\\'t want to multiply by 0\\n        \\n        int pre = 1;   //Initialize to 1, since we will be multiplying\\n        int post = 1; //Initialize to 1, since we will be multiplying \\n        int end = nums.size() - 1;\\n       //Loop through the numbers forward and backwards to construt pre-product and post-product\\n        for ( int start = 0; start < nums.size(); start++, end-- ){\\n            output[start] *= pre;    //multiply the pre-product to start index\\n            output[end] *= post;   //multiply the post-product to end index\\n            pre *= nums[start];    //construct the pre-product as we iterate to end\\n            post *= nums[end];   //construct the post-product as we iterate to start\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082015,
                "title": "simple-java-solutions-runtime-1ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int [] res = new int[nums.length];\\n        int multiply = 1 , countzero = 0;\\n\\n        for (int n : nums)\\n        {\\n            if (n == 0){\\n                countzero++;\\n            }else {\\n                multiply *= n;\\n            }\\n        }\\n        \\n        if (countzero == 0){\\n            for (int i = 0; i < nums.length; i++)\\n                res[i] = multiply / nums[i];\\n        }else if (countzero == 1) {\\n            for (int i = 0; i < nums.length ; i++)\\n                if (nums[i] == 0)\\n                    res[i] = multiply;\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/d1f4d248-c5b2-4d63-bee5-2696e626e860_1695497801.5838907.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int [] res = new int[nums.length];\\n        int multiply = 1 , countzero = 0;\\n\\n        for (int n : nums)\\n        {\\n            if (n == 0){\\n                countzero++;\\n            }else {\\n                multiply *= n;\\n            }\\n        }\\n        \\n        if (countzero == 0){\\n            for (int i = 0; i < nums.length; i++)\\n                res[i] = multiply / nums[i];\\n        }else if (countzero == 1) {\\n            for (int i = 0; i < nums.length ; i++)\\n                if (nums[i] == 0)\\n                    res[i] = multiply;\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005897,
                "title": "o-n-single-pass-solution-in-java-easy-to-understand-beats-100-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLike any other problem, my first intuition was let\\'s brute force the solution by having two pointers going from i-1 to 1 and i+1 to len(nums) and multiplying each element and then appending this result to the output array. However, on secondary thought (and mainly due to solving questions such as Prefix Sum and Postfix Sum before), I could observe that we can use similar concept like Prefix and Postfix.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use the fact that prefix_product of arr[i] is arr[0] * arr[1] * .. * arr[i-1] and postfix_product of arr[i] is arr[i+1] * arr[i+2] * .. * arr[n-1].\\n\\nSo basically, we have to calculate prefix_product * postfix_product[i] for each element.\\n\\nMost solutions implementing the concept of Prefix and Postfix would suggest 2 traversals, however I felt that we could one-up that and come up with a single traversal solution.\\n\\n1. Initialize a Solution Array of same size as input array with value.\\n2. Store Prefix and Postfix Product so far in variables.\\n3. Traverse the input array.\\n4. Before updating the values for each i, multiply current solution array value at i with the value of prefix i.e. multiply with prefix product of the previous i-1 elements.\\n5. Similarly, calculate the postfix product value for n-i-1 where n is length of input array at each iteration.\\n6. As in Step 4, before calculating the postfix for i\\'th value , multiply the solution_array[n-i-1] with the postfix product value i.e. products of input[i+1] to input[n-1].\\n\\nPlease do like the solution if you understood it. Helps boosting visibility :-P\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)O(n)O(n) Single Pass\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: Technically O(1)O(1)O(1) as we are not supposed to count the output array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] sol = new int[nums.length];\\n        \\n        for(int i = 0; i<nums.length; i++) {\\n            sol[i] = 1;\\n        }\\n        int pre = 1;\\n        int post = 1;\\n\\n        for(int i = 0; i<nums.length; i++) {\\n            sol[i] = sol[i] * pre;\\n            pre = pre * nums[i];\\n            sol[nums.length - i - 1] = sol[nums.length - i - 1] * post;\\n            post = post * nums[nums.length - i - 1];\\n        }\\n        return sol;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] sol = new int[nums.length];\\n        \\n        for(int i = 0; i<nums.length; i++) {\\n            sol[i] = 1;\\n        }\\n        int pre = 1;\\n        int post = 1;\\n\\n        for(int i = 0; i<nums.length; i++) {\\n            sol[i] = sol[i] * pre;\\n            pre = pre * nums[i];\\n            sol[nums.length - i - 1] = sol[nums.length - i - 1] * post;\\n            post = post * nums[nums.length - i - 1];\\n        }\\n        return sol;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713226,
                "title": "python3-time-94",
                "content": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        res = [1] * len(nums)   # res => [1 , 1, 1, 1]\\n        prefix = 1 \\n        postfix = 1\\n        \\n        \\n#     input => [1,2,3,4]\\n#     prefix =>  [1,2,6,24]\\n#     postfix =>  [24,24,12,4]\\n    \\n#     ans = [1] [1,1,1,1] [1]\\n    \\n#     ans[i] => prefix[i - 1] * postfix[i + 1]\\n#     ans[0] => prefix[-1] * postfix[1]\\n#             => 1 * 24 \\n#             => [24 , 1 , 1 , 1]\\n#     ans[1]  => [24 , 12 , 8 , 6]\\n\\n\\n        for i in range(len(nums)) :  # [1,2,6,24]\\n            res[i] = prefix\\n            prefix *= nums[i]\\n        for i in range(len(nums) - 1 , - 1 , - 1) :  # [24,24,12,4]\\n            res[i] *= postfix\\n            postfix *= nums[i]\\n        return res\\n   \\n```\\n![image](https://assets.leetcode.com/users/images/5dcf9332-3833-42be-9344-d5bcfc57f610_1665993081.1688116.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        res = [1] * len(nums)   # res => [1 , 1, 1, 1]\\n        prefix = 1 \\n        postfix = 1\\n        \\n        \\n#     input => [1,2,3,4]\\n#     prefix =>  [1,2,6,24]\\n#     postfix =>  [24,24,12,4]\\n    \\n#     ans = [1] [1,1,1,1] [1]\\n    \\n#     ans[i] => prefix[i - 1] * postfix[i + 1]\\n#     ans[0] => prefix[-1] * postfix[1]\\n#             => 1 * 24 \\n#             => [24 , 1 , 1 , 1]\\n#     ans[1]  => [24 , 12 , 8 , 6]\\n\\n\\n        for i in range(len(nums)) :  # [1,2,6,24]\\n            res[i] = prefix\\n            prefix *= nums[i]\\n        for i in range(len(nums) - 1 , - 1 , - 1) :  # [24,24,12,4]\\n            res[i] *= postfix\\n            postfix *= nums[i]\\n        return res\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2682561,
                "title": "simple-typescript-solution",
                "content": "```\\nfunction productExceptSelf(nums: number[]): number[] {\\n    const result:number[] = Array(nums.length).fill(1)\\n\\tconst numsLen:number = nums.length\\n\\tconst curr: number[] = Array(2).fill(1)\\n    for (let i:number=1; i<numsLen; i++) {\\n        curr[0] *= nums[i-1] \\n        curr[1] *= nums[numsLen-i]\\n        result[i] *= curr[0]\\n        result[numsLen-i-1] *= curr[1]\\n    }\\n    return result\\n};\\n```\\n\\nAn easy understanding of what\\'s going on can be visualized by neetcode\\'s videos https://www.youtube.com/watch?v=bNvIQI2wAjk",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction productExceptSelf(nums: number[]): number[] {\\n    const result:number[] = Array(nums.length).fill(1)\\n\\tconst numsLen:number = nums.length\\n\\tconst curr: number[] = Array(2).fill(1)\\n    for (let i:number=1; i<numsLen; i++) {\\n        curr[0] *= nums[i-1] \\n        curr[1] *= nums[numsLen-i]\\n        result[i] *= curr[0]\\n        result[numsLen-i-1] *= curr[1]\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1598023,
                "title": "100-o-n-complexity-without-using-extra-space-with-explanation",
                "content": "1.Make a answer vector that store suffix Product of elements.\\n2.Now on that answer vector start iterating from last and check two edge cases.\\n3.Their are two edge cases (i)-> for i==n-1 and (ii)->for i==0.\\n4.for first edge case answer[n] =answer[n-1].\\n5. now work until you reach 2nd edge case and store all product form last .\\n6. and for every i execpt edge case... answer will be answer[i]=answer[i-1]*product form last.\\n\\tYou will understand better after reading code..\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans(n,1);\\n        int num=1;\\n        for(int i=0;i<n;i++){\\n            num*=nums[i];\\n            ans[i]=num;\\n        }\\n        num=1;\\n        for(int i=n-1;i>=0;i--){\\n            if(i==n-1)  \\n                ans[i]=ans[i-1];                            \\n            else if(i==0)\\n                ans[i]=num;         \\n            else\\n                ans[i]=ans[i-1]*num;\\n            num*=nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>ans(n,1);\\n        int num=1;\\n        for(int i=0;i<n;i++){\\n            num*=nums[i];\\n            ans[i]=num;\\n        }\\n        num=1;\\n        for(int i=n-1;i>=0;i--){\\n            if(i==n-1)  \\n                ans[i]=ans[i-1];                            \\n            else if(i==0)\\n                ans[i]=num;         \\n            else\\n                ans[i]=ans[i-1]*num;\\n            num*=nums[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677297,
                "title": "java-helpful-for-interview-4-approaches",
                "content": "Approach 1 : Brute force\\nTime : O(n^2)\\nspace : O(1)\\n\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int ans[] = new int[n];\\n        int a=1;\\n        for(int i=0;i<n;i++){\\n            a=1;\\n            for(int j=0;j<n;j++)\\n               if(i!=j) a*=nums[j];\\n            ans[i]=a;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nApproach 2 : Input Array modification\\nTime : O(n)\\nspace : O(1)\\n\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int a=1;\\n        int countO = 0;\\n        for(int i=0;i<n;i++)\\n            if(nums[i] == 0) countO++;\\n        if(countO ==0){\\n            for(int i=0;i<n;i++){\\n                a *= nums[i];\\n            }\\n            for(int i=0;i<n;i++)\\n                nums[i] = a / nums[i];\\n            return nums;\\n        }\\n        else if(countO == 1){\\n             for(int i=0;i<n;i++){\\n               if(nums[i]!=0) a *= nums[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                if(nums[i] ==0) nums[i] = a;\\n                else nums[i] = 0;\\n            }\\n            return nums;\\n        }\\n        else return new int[n];\\n    }\\n}\\n```\\n\\nApproach 3 :  Using Left[] and Right[] to Store multiplications \\nTime : O(n)\\nspace : O(n)\\n\\n```\\nclass Solution {\\n    \\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int left[],right[],ans[];\\n        left = new int[n];\\n        right = new int[n];\\n        ans = new int[n];\\n        \\n        left[0] = 1;\\n        for(int i=1;i<n;i++)\\n            left[i] = left[i-1] * nums[i-1];\\n        \\n        right[n-1] = 1;\\n        for(int i=n-2;i>=0;i--)\\n            right[i] = right[i+1] * nums[i+1];\\n        \\n        for(int i=0;i<n;i++)\\n            ans[i] = left[i] * right[i];\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nApproach 4: Using only Output array \\nTime : O(n)\\nspace : O(1){\\n\\tAs per the question says output array doesnt count to the extra space,\\n\\thowever we are using output array to hold intermediate result which is actually not allowed if we look at this problem as O(1) perspective. So basically question says that apart from the output array , you are not allowed to use any other storage.\\n\\n}\\n\\n```\\nclass Solution {\\n    \\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        \\n        ans[0] = 1;\\n        for(int i=1;i<n;i++)\\n            ans[i] = ans[i-1] * nums[i-1];\\n        \\n        int R = 1;\\n        for(int i=n-1;i>=0;i--){\\n          ans[i] = R * ans[i];\\n          R *= nums[i];  \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int ans[] = new int[n];\\n        int a=1;\\n        for(int i=0;i<n;i++){\\n            a=1;\\n            for(int j=0;j<n;j++)\\n               if(i!=j) a*=nums[j];\\n            ans[i]=a;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int a=1;\\n        int countO = 0;\\n        for(int i=0;i<n;i++)\\n            if(nums[i] == 0) countO++;\\n        if(countO ==0){\\n            for(int i=0;i<n;i++){\\n                a *= nums[i];\\n            }\\n            for(int i=0;i<n;i++)\\n                nums[i] = a / nums[i];\\n            return nums;\\n        }\\n        else if(countO == 1){\\n             for(int i=0;i<n;i++){\\n               if(nums[i]!=0) a *= nums[i];\\n            }\\n            for(int i=0;i<n;i++){\\n                if(nums[i] ==0) nums[i] = a;\\n                else nums[i] = 0;\\n            }\\n            return nums;\\n        }\\n        else return new int[n];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int left[],right[],ans[];\\n        left = new int[n];\\n        right = new int[n];\\n        ans = new int[n];\\n        \\n        left[0] = 1;\\n        for(int i=1;i<n;i++)\\n            left[i] = left[i-1] * nums[i-1];\\n        \\n        right[n-1] = 1;\\n        for(int i=n-2;i>=0;i--)\\n            right[i] = right[i+1] * nums[i+1];\\n        \\n        for(int i=0;i<n;i++)\\n            ans[i] = left[i] * right[i];\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        \\n        ans[0] = 1;\\n        for(int i=1;i<n;i++)\\n            ans[i] = ans[i-1] * nums[i-1];\\n        \\n        int R = 1;\\n        for(int i=n-1;i>=0;i--){\\n          ans[i] = R * ans[i];\\n          R *= nums[i];  \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332008,
                "title": "simple-c-solution",
                "content": "```\\n\\tprivate int[] ProductOfArrayWithoutSelf_WithoutDivision(int[] arr)\\n        {\\n            if (arr == null || arr.Length < 2)\\n                return arr;\\n\\n            int[] result = new int[arr.Length];\\n\\n            int left = 1; // For the array travel from left to right\\n            for (int i = 0; i< arr.Length; i++)\\n            {\\n                result[i] = left; // add left value to result array\\n                left *= arr[i]; // calculate left value\\n            }\\n\\n            int right = 1; // For the array travel from right to left\\n            for (int i = arr.Length - 1; i>= 0; i--)\\n            {\\n                result[i] *= right; // add right value to result array\\n                right *= arr[i]; // calculate right value\\n            }\\n\\n            return result;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tprivate int[] ProductOfArrayWithoutSelf_WithoutDivision(int[] arr)\\n        {\\n            if (arr == null || arr.Length < 2)\\n                return arr;\\n\\n            int[] result = new int[arr.Length];\\n\\n            int left = 1; // For the array travel from left to right\\n            for (int i = 0; i< arr.Length; i++)\\n            {\\n                result[i] = left; // add left value to result array\\n                left *= arr[i]; // calculate left value\\n            }\\n\\n            int right = 1; // For the array travel from right to left\\n            for (int i = arr.Length - 1; i>= 0; i--)\\n            {\\n                result[i] *= right; // add right value to result array\\n                right *= arr[i]; // calculate right value\\n            }\\n\\n            return result;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952648,
                "title": "java-beats-100-simple-explanation",
                "content": "# Intuition\\nThe problem requires us to calculate the product of all elements in the array except for the current element. We can do this by first calculating the product of all elements to the left of each element and then multiplying it with the product of all elements to the right of each element.\\n\\n# Approach\\n1. Initialize an array `result` of the same length as the input `nums` array.\\n2. Iterate through the `nums` array from **left to right** and calculate the product of elements to the left of the current element. Store this product in the corresponding index of the `result` array.\\n3. Iterate through the `nums` array from **right to left** and calculate the product of elements to the right of the current element. Multiply this product with the value in the `result` array at the same index.\\n4. Return the `result` array.\\n\\n# Complexity\\n- **Time complexity**: The solution uses two passes through the input array, each taking $$O(n)$$ time, where n is the length of the input array. As a result, the overall time complexity is $$O(n)$$.\\n\\n- **Space complexity**: The solution uses a single additional array `result` of the same length as the input array to store the products. Hence, the space complexity is $$O(n)$$ due to the space used for the `result` array.\\n\\n\\n- **Auxiliary Space Complexity**: The solution doesn\\'t use any extra space apart from the result array. The memory usage is constant, making the auxiliary space complexity $$O(1)$$.\\n# Code\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int len = nums.length;\\n        int[] result = new int[len];\\n\\n        int leftProduct = 1;\\n        for (int i = 0; i < len; i++) {\\n            result[i] = leftProduct; // Store product of elements to the left\\n            leftProduct *= nums[i]; // Calculate product of elements to the left\\n        }\\n\\n        int rightProduct = 1;\\n        for (int i = len - 1; i >= 0; i--) {\\n            result[i] *= rightProduct; // Multiply by product of elements to the right\\n            rightProduct *= nums[i]; // Calculate product of elements to the right\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int len = nums.length;\\n        int[] result = new int[len];\\n\\n        int leftProduct = 1;\\n        for (int i = 0; i < len; i++) {\\n            result[i] = leftProduct; // Store product of elements to the left\\n            leftProduct *= nums[i]; // Calculate product of elements to the left\\n        }\\n\\n        int rightProduct = 1;\\n        for (int i = len - 1; i >= 0; i--) {\\n            result[i] *= rightProduct; // Multiply by product of elements to the right\\n            rightProduct *= nums[i]; // Calculate product of elements to the right\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888516,
                "title": "simple-and-precise-solution-in-cpp-plz-upvote",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n    std::vector<int> answer(n, 1);\\n\\n    // Calculate the product of all elements to the left of i\\n    int leftProduct = 1;\\n    for (int i = 0; i < n; ++i) {\\n        answer[i] *= leftProduct;\\n        leftProduct *= nums[i];\\n    }\\n\\n    // Calculate the product of all elements to the right of i\\n    int rightProduct = 1;\\n    for (int i = n - 1; i >= 0; --i) {\\n        answer[i] *= rightProduct;\\n        rightProduct *= nums[i];\\n    }\\n\\n    return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n    std::vector<int> answer(n, 1);\\n\\n    // Calculate the product of all elements to the left of i\\n    int leftProduct = 1;\\n    for (int i = 0; i < n; ++i) {\\n        answer[i] *= leftProduct;\\n        leftProduct *= nums[i];\\n    }\\n\\n    // Calculate the product of all elements to the right of i\\n    int rightProduct = 1;\\n    for (int i = n - 1; i >= 0; --i) {\\n        answer[i] *= rightProduct;\\n        rightProduct *= nums[i];\\n    }\\n\\n    return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799364,
                "title": "c-easy-solution-fully-explained-easy-to-understand-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor `nums[i]`, calculate its left product and right product, store them in tables, and multiply both to generate the result.\\n\\n\\n# Approach\\n![A89000F2-4FEB-45E5-B728-9476C44CE7B7.jpg](https://assets.leetcode.com/users/images/7fb9ceb8-3f02-46bf-b0b6-2ca62e8299f2_1690004771.30163.jpeg)\\n\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) \\n    {\\n        int n = nums.size(), i, j;\\n        vector<int> L_product(n), R_product(n), res(n);\\n        L_product[0] = 1;\\n        R_product[n-1] = 1;\\n        for(i=1; i<n; i++)\\n        {\\n            j = (n - 1) - i;\\n            L_product[i] = L_product[i-1] * nums[i-1];\\n            R_product[j] = R_product[j+1] * nums[j+1];\\n        }\\n        for(i=0; i<n; i++)\\n            res[i] = L_product[i] * R_product[i];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) \\n    {\\n        int n = nums.size(), i, j;\\n        vector<int> L_product(n), R_product(n), res(n);\\n        L_product[0] = 1;\\n        R_product[n-1] = 1;\\n        for(i=1; i<n; i++)\\n        {\\n            j = (n - 1) - i;\\n            L_product[i] = L_product[i-1] * nums[i-1];\\n            R_product[j] = R_product[j+1] * nums[j+1];\\n        }\\n        for(i=0; i<n; i++)\\n            res[i] = L_product[i] * R_product[i];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771862,
                "title": "inplace-algo-o-n-time-o-1-space-beats-100",
                "content": "# Please upvote if the below solution helps you\\uD83D\\uDE0A\\n# Code\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] output = new int[n];\\n        \\n        if(n<1) return output;\\n        \\n        int product = 1;\\n        for(int i=0;i<n;i++) {\\n            product*=nums[i];\\n            output[i] = product;\\n        }\\n        product = 1;\\n        for(int i=n-1;i>0;i--) {\\n            output[i] = output[i-1] * product;\\n            product*=nums[i];\\n        }\\n        output[0] = product;\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] output = new int[n];\\n        \\n        if(n<1) return output;\\n        \\n        int product = 1;\\n        for(int i=0;i<n;i++) {\\n            product*=nums[i];\\n            output[i] = product;\\n        }\\n        product = 1;\\n        for(int i=n-1;i>0;i--) {\\n            output[i] = output[i-1] * product;\\n            product*=nums[i];\\n        }\\n        output[0] = product;\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373567,
                "title": "two-approaches-you-will-understand-easily-and-prefix-and-suffix-approach",
                "content": "# 1. Easy Approach:\\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        list1=[]\\n        n=len(nums)\\n        import numpy as np\\n        if nums.count(0)>1:\\n            return [0]*n\\n        elif nums.count(0)==1:\\n            index_zero=nums.index(0)\\n            nums.remove(0)\\n            product=np.prod(np.array(nums))\\n            for i in range(n):\\n                if i==index_zero:\\n                    list1.append(product)\\n                else:\\n                    list1.append(0)\\n        else:\\n            product=np.prod(np.array(nums))\\n            for i in range(n):\\n                list1.append(product//nums[i])\\n        return list1\\n```\\n\\n# Prefix and Suffix Concept--->O(N)\\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        list1=[1]*(len(nums))\\n        prefix,postfix=1,1\\n        for i in range(len(nums)):\\n            list1[i]=prefix\\n            prefix*=nums[i]\\n        for j in range(len(nums)-1,-1,-1):\\n            list1[j]*=postfix\\n            postfix*=nums[j]\\n        return list1\\n          \\n```\\n# please upvote me it would encourage me alot\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        list1=[]\\n        n=len(nums)\\n        import numpy as np\\n        if nums.count(0)>1:\\n            return [0]*n\\n        elif nums.count(0)==1:\\n            index_zero=nums.index(0)\\n            nums.remove(0)\\n            product=np.prod(np.array(nums))\\n            for i in range(n):\\n                if i==index_zero:\\n                    list1.append(product)\\n                else:\\n                    list1.append(0)\\n        else:\\n            product=np.prod(np.array(nums))\\n            for i in range(n):\\n                list1.append(product//nums[i])\\n        return list1\\n```\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        list1=[1]*(len(nums))\\n        prefix,postfix=1,1\\n        for i in range(len(nums)):\\n            list1[i]=prefix\\n            prefix*=nums[i]\\n        for j in range(len(nums)-1,-1,-1):\\n            list1[j]*=postfix\\n            postfix*=nums[j]\\n        return list1\\n          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3091539,
                "title": "tc-o-n-2-o-n-sc-o-n-o-1-c-explained-updated",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea we itself got from the question. we have to do it without division using prefix suffix approach.\\n\\nFollow me on linkdin - https://linkedin.com/in/bhaskar-agrawal-a01069219\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nPrefix suffix approach states that multiplication/division/ sum etc at an particular index is multiplication/division/ sum from all left and all right.\\n1. here rather than declaring left and right product array, we have stored left product array in output array itself and then modified it with right product.\\n2. iterate through the array and store the left side product of all elements till i, in output array. \\n3. after this, set product to 1, so that we can modify output array.\\n4. in order to modify, run a loop from end to beginning, we have to keep tract of the right product also simultaneously... product= product* nums[i+1].\\n5. v[i+1]= v[i]* product; will help to modify the output array as product variable will keep tract of right side element\\'s product.\\n6. for the 0 index,  set it to product as it contains product of right side all elements except 0 index.\\n7. return v.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N), we have ran twice for loop, O(n) + O(n)= O(2n)= O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1), doing in O(N) is possible, but we reduce O(n) to O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int product = 1;\\n        vector <int> v;\\n        for(auto i : nums){\\n            product = product * i;\\n            v.push_back(product);\\n        }\\n        product = 1;\\n        for(int i = v.size() -1; i > 0; i--){ \\n            v[i] = product * v[i - 1];\\n            product *= nums[i];\\n        }\\n        v[0] = product;\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int product = 1;\\n        vector <int> v;\\n        for(auto i : nums){\\n            product = product * i;\\n            v.push_back(product);\\n        }\\n        product = 1;\\n        for(int i = v.size() -1; i > 0; i--){ \\n            v[i] = product * v[i - 1];\\n            product *= nums[i];\\n        }\\n        v[0] = product;\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3029983,
                "title": "c-solution-with-two-loops",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int[] ProductExceptSelf(int[] nums) {\\n    \\n        var arrLength = nums.Length;\\n        var output = new int[arrLength];\\n    \\n        for (int i = 0, prev = 1; i < arrLength; i++)\\n        {\\n            output[i] = prev;\\n            prev = nums[i] * prev;\\n        }\\n    \\n        for (int i = arrLength - 1, prev = 1; i >= 0; i--)\\n        {\\n            output[i] = output[i] * prev;\\n            prev = nums[i] * prev;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] ProductExceptSelf(int[] nums) {\\n    \\n        var arrLength = nums.Length;\\n        var output = new int[arrLength];\\n    \\n        for (int i = 0, prev = 1; i < arrLength; i++)\\n        {\\n            output[i] = prev;\\n            prev = nums[i] * prev;\\n        }\\n    \\n        for (int i = arrLength - 1, prev = 1; i >= 0; i--)\\n        {\\n            output[i] = output[i] * prev;\\n            prev = nums[i] * prev;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557123,
                "title": "javascript-solution-beats-99-07-no-division-simple-solution-with-explanation",
                "content": "# Explanation\\n\\nThe challenge of this question comes from the requirement \"`without using the division operation`\"  With division, this would be an easy problem. In order to solve it, we perform 2 steps:\\n1. Iterate over the array from left to right, recording the *product of the numbers we\\'ve seen so far*.\\n2. Iterate backwards from right to left, multiplying each element in `res` by the product of the numbers we\\'ve seen so far from right-to-left.\\n\\n\\n## Example\\n\\n1. If `nums` is `[1, 2, 3, 4]` then the left-to-right iteration will produce `[1, 1, 2, 6]`.\\nWhy is this first number 1? Because we haven\\'t visited any elements yet.\\n\\n2. Next, we iterate `nums` from right-to-left, doing the same thing backwards. Again, product initialises as `1` before we visit the first element on the right. This second iterations yields the final result `[24, 12, 8, 6]`\\n\\n## Code\\n```\\nvar productExceptSelf = function (nums) {\\n  const res = [];\\n  let product = 1;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    res.push(product);\\n    product *= nums[i];\\n  }\\n\\n  product = 1;\\n\\n  for (let j = nums.length - 1; j >= 0; j--) {\\n    res[j] *= product;\\n    product *= nums[j];\\n  }\\n\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar productExceptSelf = function (nums) {\\n  const res = [];\\n  let product = 1;\\n\\n  for (let i = 0; i < nums.length; i++) {\\n    res.push(product);\\n    product *= nums[i];\\n  }\\n\\n  product = 1;\\n\\n  for (let j = nums.length - 1; j >= 0; j--) {\\n    res[j] *= product;\\n    product *= nums[j];\\n  }\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1749763,
                "title": "c-intution-two-approach",
                "content": "**Upvote if u like**\\n# **INTUTION-Non working**\\n//intution first i thought that we will multiply all the elements and divide and store in each but the //interviewer has said that we cannot use divide\\n//[1,2,3,4]\\n//product = 24\\n//ans[0] = 24/1  ans[1] = 24/2  ans[2] = 24/3 ans[3] = 24/4\\n\\n//**but this will also not work when array contains 0**\\n\\n# **Approach 1  space complexity 0(2n) & time - 0(n)**\\n\\ncode 1:\\n\\n```\\n  vector<int> productExceptSelf(vector<int>& nums) {\\n      int n=nums.size();\\n      vector<int> ans (n);\\n      vector<int> left (n,1);//All elements should be initialized to 1\\n      vector<int> right (n,1);\\n  \\n      int lp=nums[0],rp=nums[n-1];\\n      \\n      for(int i=1;i<n;++i){\\n          left[i]=lp;\\n          lp*=nums[i];\\n      }\\n      \\n      for(int i=n-2;i>=0;--i){\\n          right[i]*=rp;\\n          rp*=nums[i];\\n      }\\n      \\n      for(int i=0;i<n;i++){\\n          ans[i]=left[i]*right[i];\\n      }\\n      \\n      return ans;\\n  }\\n```\\n\\n//Here we are storing the prefix multiplication sum in 1st array\\n// suffix multiplication sum in 2nd array\\n//Then we multiply both to get the result\\n\\n\\n# **2 approach :-Here the idea is same as 1st but we are only using the given array**\\n```\\n  vector<int> productExceptSelf(vector<int>& nums) {\\n     \\n        int n = nums.size();\\n       vector<int>ans(n,1); //All elements should be initialized to 1\\n        \\n        int lp = nums[0] , rp = nums[n-1];\\n        \\n        for(int i = 1 ; i < n ; i++)\\n        {\\n            ans[i] = lp;\\n            lp *= nums[i];\\n        }\\n         for(int i = n-2 ; i >= 0 ; i--)\\n        {\\n            ans[i] *=rp;\\n             rp*=nums[i];\\n        }\\n        return ans;\\n    }\\n```\\n**First we will store the prefix multiplication in the ans array**\\n           ```\\n            ans[i] *=rp;\\n             rp *=nums[i];\\n```\\nThe main catch is in this part dry run this carefully\\n\\n",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n  vector<int> productExceptSelf(vector<int>& nums) {\\n      int n=nums.size();\\n      vector<int> ans (n);\\n      vector<int> left (n,1);//All elements should be initialized to 1\\n      vector<int> right (n,1);\\n  \\n      int lp=nums[0],rp=nums[n-1];\\n      \\n      for(int i=1;i<n;++i){\\n          left[i]=lp;\\n          lp*=nums[i];\\n      }\\n      \\n      for(int i=n-2;i>=0;--i){\\n          right[i]*=rp;\\n          rp*=nums[i];\\n      }\\n      \\n      for(int i=0;i<n;i++){\\n          ans[i]=left[i]*right[i];\\n      }\\n      \\n      return ans;\\n  }\\n```\n```\\n  vector<int> productExceptSelf(vector<int>& nums) {\\n     \\n        int n = nums.size();\\n       vector<int>ans(n,1); //All elements should be initialized to 1\\n        \\n        int lp = nums[0] , rp = nums[n-1];\\n        \\n        for(int i = 1 ; i < n ; i++)\\n        {\\n            ans[i] = lp;\\n            lp *= nums[i];\\n        }\\n         for(int i = n-2 ; i >= 0 ; i--)\\n        {\\n            ans[i] *=rp;\\n             rp*=nums[i];\\n        }\\n        return ans;\\n    }\\n```\n```\\n            ans[i] *=rp;\\n             rp *=nums[i];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 581309,
                "title": "swift",
                "content": "```\\nclass Solution {\\n    func productExceptSelf(_ nums: [Int]) -> [Int] {\\n        var result = Array(repeating: 1, count: nums.count)\\n        \\n        var left = 1\\n        for i in 0..<nums.count{\\n            result[i] = left\\n            left = nums[i] * left\\n        }\\n        \\n        var right = 1\\n        for i in (0..<nums.count).reversed(){\\n            result[i] *= right\\n            right = nums[i] * right\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func productExceptSelf(_ nums: [Int]) -> [Int] {\\n        var result = Array(repeating: 1, count: nums.count)\\n        \\n        var left = 1\\n        for i in 0..<nums.count{\\n            result[i] = left\\n            left = nums[i] * left\\n        }\\n        \\n        var right = 1\\n        for i in (0..<nums.count).reversed(){\\n            result[i] *= right\\n            right = nums[i] * right\\n        }\\n        \\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 385833,
                "title": "javascript-no-devision-easy-to-understand-solution",
                "content": "```\\nvar productExceptSelf = function(nums) {\\n    let res =[];\\n    nums.reduce((leftP, curr, i) => {\\n        res[i] = leftP;\\n        return leftP*curr;\\n    }, 1)\\n    nums.reduceRight((rightP, curr, i) => {\\n        res[i] *= rightP;\\n        return rightP*curr;\\n    }, 1)\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar productExceptSelf = function(nums) {\\n    let res =[];\\n    nums.reduce((leftP, curr, i) => {\\n        res[i] = leftP;\\n        return leftP*curr;\\n    }, 1)\\n    nums.reduceRight((rightP, curr, i) => {\\n        res[i] *= rightP;\\n        return rightP*curr;\\n    }, 1)\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 349984,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function(nums) {\\n    const solArr = new Array(nums.length).fill(1);\\n    \\n    let mult = 1;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        solArr[i] *= mult;\\n        mult *= nums[i];\\n    }\\n    \\n    mult = 1;\\n    \\n    for (let j = nums.length - 1; j >= 0; j--) {\\n        solArr[j] *= mult;\\n        mult *= nums[j];\\n    }\\n    \\n    return solArr;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function(nums) {\\n    const solArr = new Array(nums.length).fill(1);\\n    \\n    let mult = 1;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        solArr[i] *= mult;\\n        mult *= nums[i];\\n    }\\n    \\n    mult = 1;\\n    \\n    for (let j = nums.length - 1; j >= 0; j--) {\\n        solArr[j] *= mult;\\n        mult *= nums[j];\\n    }\\n    \\n    return solArr;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65824,
                "title": "easy-understand-two-scans-python",
                "content": "class Solution(object):\\n\\n    def productExceptSelf(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        res = [1]\\n        prev = 1\\n        #scan forward\\n        for i in xrange(1,len(nums)):\\n            prev=prev*nums[i-1]\\n            res.append(prev)\\n        #scan backward\\n        prev = 1\\n        for i in xrange(len(nums)-2,-1,-1):\\n            prev = prev*nums[i+1]\\n            res[i]=res[i]*prev\\n            \\n            \\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n\\n    def productExceptSelf(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        res = [1]\\n        prev = 1\\n        #scan forward\\n        for i in xrange(1,len(nums)):\\n            prev=prev*nums[i-1]\\n            res.append(prev)\\n        #scan backward\\n        prev = 1\\n        for i in xrange(len(nums)-2,-1,-1):\\n            prev = prev*nums[i+1]\\n            res[i]=res[i]*prev\\n            \\n            \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 4040473,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector <int> ans(n);\\n        int prod = 1;\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = prod;\\n            prod *= nums[i];\\n        }\\n        int revProd = 1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            ans[i] *= revProd;\\n            revProd *= nums[i];\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector <int> ans(n);\\n        int prod = 1;\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = prod;\\n            prod *= nums[i];\\n        }\\n        int revProd = 1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            ans[i] *= revProd;\\n            revProd *= nums[i];\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502473,
                "title": "java-simplest-soln-o-n-time-o-1-space-with-intuition",
                "content": "**[The soln with prefix and suffix multiplication is good to practice the concept and this one is based on common sense, only for the sake of info...]**\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. What if there is no zero in the array\\n    you need to simply calculate the product and divide the product with the number at every index in order to form your solution.\\n2. If there is a zero??\\nThe problem arises when there is a zero involved. Right?\\nLet\\'s say there is one zero in the array, then at every other index the answer will be zero and at zero the ans is product of every other element. \\n \\nSo why not exclude zero while calculating the product\\nBut what if there is an another zero, then the ans at this particular index will also be zero because of that another zero. and same for that another zero. Right??\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. I calculated number of zeros and product excluding all zeros\\n2. If there is just one zero, I put this product at corresponding index in answer array.\\n3. If no zero -- u know what to do\\n4. if more than 1 zero then ans at every index will be zero only.\\n\\n\\nPlease feel free to upvote\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int nz=0;//number of zeros\\n        int prod=1;//product\\n        int n=nums.length;\\n        int[] ans=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n                nz++;\\n            else\\n                prod=prod*nums[i];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nz==1)\\n            {\\n                if(nums[i]==0)\\n                    ans[i]=prod;\\n                else\\n                    ans[i]=0;\\n            }\\n            if(nz==0)\\n                ans[i]=prod/nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int nz=0;//number of zeros\\n        int prod=1;//product\\n        int n=nums.length;\\n        int[] ans=new int[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]==0)\\n                nz++;\\n            else\\n                prod=prod*nums[i];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nz==1)\\n            {\\n                if(nums[i]==0)\\n                    ans[i]=prod;\\n                else\\n                    ans[i]=0;\\n            }\\n            if(nz==0)\\n                ans[i]=prod/nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499274,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] ProductExceptSelf(int[] nums) {\\n        int[] product = new int[nums.Length];\\n        int num = 1, i;\\n\\n        for(i=0; i< nums.Length; i++)\\n        {\\n            product[i] = num;\\n            num *= nums[i];\\n        }\\n        num=1;\\n\\n        for(i=nums.Length-1; i>=0; i--)\\n        {\\n            product[i] *= num;\\n            num *= nums[i];\\n        }\\n        return product;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] ProductExceptSelf(int[] nums) {\\n        int[] product = new int[nums.Length];\\n        int num = 1, i;\\n\\n        for(i=0; i< nums.Length; i++)\\n        {\\n            product[i] = num;\\n            num *= nums[i];\\n        }\\n        num=1;\\n\\n        for(i=nums.Length-1; i>=0; i--)\\n        {\\n            product[i] *= num;\\n            num *= nums[i];\\n        }\\n        return product;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275907,
                "title": "fastest-java-c-code-beats-100",
                "content": "# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C []\\nint* productExceptSelf(int* nums, int N, int* resultSize){\\n    *resultSize = N;\\n    int *result = malloc(sizeof(int) * N);\\n    for(int i = 0, p = 1; i < N; i++){\\n        result[i] = p;\\n        p *= nums[i];\\n    }\\n    for(int i = N-1, p = 1; i >- 1; i--){\\n        result[i] *= p;\\n        p *= nums[i];\\n    }\\n    return result;\\n}\\n```\\n```JAVA []\\nclass Solution {\\npublic int[] productExceptSelf(int[] nums) {\\n    int[] result = new int[nums.length];\\n    Arrays.fill(result, 1);\\n    for(int i=0, p = 1; i<nums.length; i++){\\n        result[i] *= p;\\n        p *= nums[i];\\n    }\\n    for(int i=nums.length-1, p = 1; i>-1; i--){\\n        result[i] *= p;\\n        p *= nums[i];\\n    }\\n    return result;\\n}\\n}\\n``` \\n>>> ## Upvote\\uD83D\\uDC4D if you find helpful\\n```\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```C []\\nint* productExceptSelf(int* nums, int N, int* resultSize){\\n    *resultSize = N;\\n    int *result = malloc(sizeof(int) * N);\\n    for(int i = 0, p = 1; i < N; i++){\\n        result[i] = p;\\n        p *= nums[i];\\n    }\\n    for(int i = N-1, p = 1; i >- 1; i--){\\n        result[i] *= p;\\n        p *= nums[i];\\n    }\\n    return result;\\n}\\n```\n```JAVA []\\nclass Solution {\\npublic int[] productExceptSelf(int[] nums) {\\n    int[] result = new int[nums.length];\\n    Arrays.fill(result, 1);\\n    for(int i=0, p = 1; i<nums.length; i++){\\n        result[i] *= p;\\n        p *= nums[i];\\n    }\\n    for(int i=nums.length-1, p = 1; i>-1; i--){\\n        result[i] *= p;\\n        p *= nums[i];\\n    }\\n    return result;\\n}\\n}\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2690249,
                "title": "python-solution-simple-easy-to-understand-faster-than-93",
                "content": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        \\n        ans = [1]*len(nums)\\n        \\n        prefix = 1\\n        \\n        postfix = 1\\n        \\n        \\n        for i in range(0,len(nums)):\\n            \\n            ans[i] = prefix\\n            prefix*=nums[i]\\n        \\n        for i in range(len(nums)-1,-1,-1):\\n            \\n            ans[i] = ans[i]*postfix\\n            postfix*=nums[i]\\n           \\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        \\n        ans = [1]*len(nums)\\n        \\n        prefix = 1\\n        \\n        postfix = 1\\n        \\n        \\n        for i in range(0,len(nums)):\\n            \\n            ans[i] = prefix\\n            prefix*=nums[i]\\n        \\n        for i in range(len(nums)-1,-1,-1):\\n            \\n            ans[i] = ans[i]*postfix\\n            postfix*=nums[i]\\n           \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429258,
                "title": "rust-o-n-with-o-1-extra-space-solution",
                "content": "```\\npub fn product_except_self(nums: Vec<i32>) -> Vec<i32> {\\n        let mut ret = vec![1; nums.len()];\\n        let mut l = 0;\\n        let mut r = nums.len()-1;\\n\\n        let mut lv = 1;\\n        let mut rv = 1;\\n        loop {\\n            ret[l] = ret[l] * lv;\\n            ret[r] = ret[r] * rv;\\n\\n            rv = rv * nums[r];\\n            lv = lv * nums[l];\\n\\n            if r == 0 {\\n                break;\\n            }\\n            l += 1;\\n            r -= 1;\\n        }\\n\\n        return ret;\\n    }\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\npub fn product_except_self(nums: Vec<i32>) -> Vec<i32> {\\n        let mut ret = vec![1; nums.len()];\\n        let mut l = 0;\\n        let mut r = nums.len()-1;\\n\\n        let mut lv = 1;\\n        let mut rv = 1;\\n        loop {\\n            ret[l] = ret[l] * lv;\\n            ret[r] = ret[r] * rv;\\n\\n            rv = rv * nums[r];\\n            lv = lv * nums[l];\\n\\n            if r == 0 {\\n                break;\\n            }\\n            l += 1;\\n            r -= 1;\\n        }\\n\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1864228,
                "title": "one-pass-c-solution-o-n-time-o-1-space",
                "content": "\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tUPVOTE IF YOU LIKE IT\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> product(nums.size() ,1) ;\\n        int left=1 ,right =1  ,i=0 ,j= nums.size()-1;\\n        while(i<nums.size()-1 and j>0)\\n        {\\n            left*= nums[i++] ;right*=nums[j--] ;\\n            product[i]*=left;\\n            product[j]*=right;\\n        }\\n        return product ;\\n    }\\n};",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> product(nums.size() ,1) ;\\n        int left=1 ,right =1  ,i=0 ,j= nums.size()-1;\\n        while(i<nums.size()-1 and j>0)\\n        {\\n            left*= nums[i++] ;right*=nums[j--] ;\\n            product[i]*=left;\\n            product[j]*=right;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1598069,
                "title": "c-java-python-4-simple-approaches-with-explanation",
                "content": "### Introduction\\n\\nGiven `nums`, we want an array `result` such that `result[i] = nums[0] * ... * nums[i-1] * nums[i+1] * ...`. The conditions given include:\\n\\n- Not using the division operation. This includes bit shifting right as well (i.e. not explicitly using the `/` operator but performing division manually).\\n- `O(n)` runtime complexity.\\n- `O(1)` auxiliary space.\\n\\n---\\n\\n### Approach 1: Brute Force (TLE)\\n\\nWe can loop over each element in the given array and perform multiplication with each element in the resultant array, except for the element at the given index.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> result(nums.size(), 1);\\n        for (int i=0; i<nums.size(); i++) {\\n            for (int j=0; j<nums.size(); j++) {\\n                if (i == j)\\n                    continue;\\n                result[j] *= nums[i];\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] result = new int[nums.length];\\n        Arrays.fill(result, 1);\\n        for (int i=0; i<nums.length; i++) {\\n            for (int j=0; j<nums.length; j++) {\\n                if (i == j)\\n                    continue;\\n                result[j] *= nums[i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        result = [1] * (l := len(nums))\\n        for i, j in product(range(l), repeat=2):\\n            if (i == j):\\n                continue\\n            result[j] *= nums[i]\\n        return result\\n```\\n\\n**TC: O(n<sup>2</sup>)**; nested looping over resultant array.\\n**SC: O(n)** for the resultant array, **O(1)** auxiliary space.\\n\\n---\\n\\n### Approach 2: Left and Right Product Arrays\\n\\nRewriting the equation, we can see that `result[i] = (nums[0] * ... * nums[i-1]) * (nums[i+1] * ... * nums[length-1])`, which is essentially the product of all elements to the left of the index multiplied by the product of all elements to the right of the index. Then, we can split the computation into the left and right products, and multiply them together afterward.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> left(nums.size(), 1), right(nums.size(), 1);\\n        for (int i=1; i<nums.size(); i++) {\\n            left[i] *= left[i-1]*nums[i-1];\\n            right[nums.size()-1-i] *= right[nums.size()-i]*nums[nums.size()-i];\\n        }\\n        for (int i=0; i<nums.size(); i++)\\n            left[i] *= right[i];\\n        return left;\\n    }\\n};\\n```\\n\\n```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] left = new int[nums.length], right = new int[nums.length];\\n        Arrays.fill(left, 1);\\n        Arrays.fill(right, 1);\\n        for (int i=1; i<nums.length; i++) {\\n            left[i] *= left[i-1]*nums[i-1];\\n            right[nums.length-1-i] *= right[nums.length-i]*nums[nums.length-i];\\n        }\\n        for (int i=0; i<nums.length; i++)\\n            left[i] *= right[i];\\n        return left;\\n    }\\n}\\n```\\n\\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        left, right = [1] * (l := len(nums)), [1]*l\\n        for i in range(1, l):\\n            left[i] *= left[i-1]*nums[i-1]\\n            right[-i-1] *= right[-i]*nums[-i]\\n        return [lv*rv for lv, rv in zip(left, right)]\\n```\\n\\n**TC: O(n)**, no nested loops used.\\n**SC: O(n)**, as previously discussed; **O(n)** auxiliary space used.\\n\\n---\\n\\n### Approach 3: Optimised Left and Right Product Arrays\\n\\nInstead of having two separate arrays for left and right products, we can perform the computation within the same array.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int left = 1, right = 1, sz = nums.size();\\n        vector<int> result(sz, 1);\\n        for (int i=1; i<sz; i++) {\\n            result[i] *= (left *= nums[i-1]);\\n            result[sz-1-i] *= (right *= nums[sz-i]);\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int left = 1, right = 1;\\n        int[] result = new int[nums.length];\\n        Arrays.fill(result, 1);\\n        for (int i=1; i<nums.length; i++) {\\n            result[i] *= (left *= nums[i-1]);\\n            result[nums.length-1-i] *= (right *= nums[nums.length-i]);\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        result, left, right = [1] * len(nums), 1, 1\\n        for i in range(1, len(nums)):\\n            result[i] *= (left := left*nums[i-1])\\n            result[-i-1] *= (right := right*nums[-i])\\n        return result\\n```\\n\\n**TC: O(n)**, no nested loops used.\\n**SC: O(n)**, as previously discussed; **O(n)** auxiliary space used.\\n\\n---\\n\\n### Approach 4: Division\\n\\nWe just have to keep track of the product of all the non-zero elements in the array and the number of zeros. Of course, this approach is only if you disregard the division condition.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        long prod = 1;\\n        int count = 0;\\n        for (int num : nums)\\n            num ? prod *= num : count++;\\n        for (int i=0; i<nums.size(); i++)\\n            nums[i] = nums[i] ? (count > 0 ? 0 : (int) prod/nums[i]) : (count > 1 ? 0 : (int) prod);\\n        return nums;\\n    }\\n};\\n```\\n\\n```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        long prod = 1;\\n        int count = 0;\\n        for (int num : nums) {\\n            count += num == 0 ? 1 : 0;\\n            prod *= num == 0 ? 1 : num;\\n        }\\n        for (int i=0; i<nums.length; i++)\\n            nums[i] = nums[i] == 0 ? (count > 1 ? 0 : (int) prod) : (count > 0 ? 0 : (int) prod/nums[i]);\\n        return nums;\\n    }\\n}\\n```\\n\\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        prod, count = 1, 0\\n        for num in nums:\\n            count += num == 0\\n            prod *= 1 if num == 0 else num\\n        for i in range(len(nums)):\\n            nums[i] = (0 if count > 0 else prod//nums[i]) if nums[i] else (0 if count > 1 else prod)\\n        return nums\\n```\\n\\n**TC: O(n)**, no nested loops used.\\n**SC: O(1)**, no additional data structures used.\\n\\n---\\n\\n### Conclusion\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> result(nums.size(), 1);\\n        for (int i=0; i<nums.size(); i++) {\\n            for (int j=0; j<nums.size(); j++) {\\n                if (i == j)\\n                    continue;\\n                result[j] *= nums[i];\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] result = new int[nums.length];\\n        Arrays.fill(result, 1);\\n        for (int i=0; i<nums.length; i++) {\\n            for (int j=0; j<nums.length; j++) {\\n                if (i == j)\\n                    continue;\\n                result[j] *= nums[i];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        result = [1] * (l := len(nums))\\n        for i, j in product(range(l), repeat=2):\\n            if (i == j):\\n                continue\\n            result[j] *= nums[i]\\n        return result\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> left(nums.size(), 1), right(nums.size(), 1);\\n        for (int i=1; i<nums.size(); i++) {\\n            left[i] *= left[i-1]*nums[i-1];\\n            right[nums.size()-1-i] *= right[nums.size()-i]*nums[nums.size()-i];\\n        }\\n        for (int i=0; i<nums.size(); i++)\\n            left[i] *= right[i];\\n        return left;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] left = new int[nums.length], right = new int[nums.length];\\n        Arrays.fill(left, 1);\\n        Arrays.fill(right, 1);\\n        for (int i=1; i<nums.length; i++) {\\n            left[i] *= left[i-1]*nums[i-1];\\n            right[nums.length-1-i] *= right[nums.length-i]*nums[nums.length-i];\\n        }\\n        for (int i=0; i<nums.length; i++)\\n            left[i] *= right[i];\\n        return left;\\n    }\\n}\\n```\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        left, right = [1] * (l := len(nums)), [1]*l\\n        for i in range(1, l):\\n            left[i] *= left[i-1]*nums[i-1]\\n            right[-i-1] *= right[-i]*nums[-i]\\n        return [lv*rv for lv, rv in zip(left, right)]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int left = 1, right = 1, sz = nums.size();\\n        vector<int> result(sz, 1);\\n        for (int i=1; i<sz; i++) {\\n            result[i] *= (left *= nums[i-1]);\\n            result[sz-1-i] *= (right *= nums[sz-i]);\\n        }\\n        return result;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int left = 1, right = 1;\\n        int[] result = new int[nums.length];\\n        Arrays.fill(result, 1);\\n        for (int i=1; i<nums.length; i++) {\\n            result[i] *= (left *= nums[i-1]);\\n            result[nums.length-1-i] *= (right *= nums[nums.length-i]);\\n        }\\n        return result;\\n    }\\n}\\n```\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        result, left, right = [1] * len(nums), 1, 1\\n        for i in range(1, len(nums)):\\n            result[i] *= (left := left*nums[i-1])\\n            result[-i-1] *= (right := right*nums[-i])\\n        return result\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        long prod = 1;\\n        int count = 0;\\n        for (int num : nums)\\n            num ? prod *= num : count++;\\n        for (int i=0; i<nums.size(); i++)\\n            nums[i] = nums[i] ? (count > 0 ? 0 : (int) prod/nums[i]) : (count > 1 ? 0 : (int) prod);\\n        return nums;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        long prod = 1;\\n        int count = 0;\\n        for (int num : nums) {\\n            count += num == 0 ? 1 : 0;\\n            prod *= num == 0 ? 1 : num;\\n        }\\n        for (int i=0; i<nums.length; i++)\\n            nums[i] = nums[i] == 0 ? (count > 1 ? 0 : (int) prod) : (count > 0 ? 0 : (int) prod/nums[i]);\\n        return nums;\\n    }\\n}\\n```\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        prod, count = 1, 0\\n        for num in nums:\\n            count += num == 0\\n            prod *= 1 if num == 0 else num\\n        for i in range(len(nums)):\\n            nums[i] = (0 if count > 0 else prod//nums[i]) if nums[i] else (0 if count > 1 else prod)\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476274,
                "title": "o-n-2-to-o-n-thought-process-explained",
                "content": "Hi Everyone, \\n\\nIn this solution, we will move from ***Brute Force Approach to Optimal Approach*** using some pre-computation techniques. For better clarity, understanding both the approaches can be very helpful.\\n\\n***Brute Force Approach*** - **Clears 18/20 test cases**\\n\\nHere, we will fix (i)th index and traverse from 0th index till (n-1)th index for all i using another index j and we will take the product as long as i != j. \\n\\n***Time Complexity - O(N^2)***\\n        \\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        \\n        n = len(nums)\\n        answer = [1] * n #this will hold our output\\n       \\n\\t\\tfor i in range(0, n):\\n            for j in range(0, n):\\n                if i != j:\\n                    answer[i] = answer[i] * nums[j]\\n                    \\n        return answer\\n  ```\\n  \\n***Optimal Solution Approach*** - **All test cases passed** - Taken from discussion section\\n\\n\\n- ***First For loop***\\nHere, we are declaring an array named left that will hold the product from left side till the end. Eg, if input array is [1,2,3,4] ; left will be [1,1,2,6] after the first for loop.\\n\\n- ***Second For loop***\\nWe are trying to get the product of all elements except the one being considered in nums. \\n\\n**I am trying to explain this (second for loop) in a theoretical manner, will edit this soon. If you have any idea on how to explain this, feel free to comment**. \\n\\n\\n***Time Complexity - O(N)***\\n```\\n        n=len(nums)\\n        left=[1]*n\\n        \\n        for i in range(0, n-1): \\n            left[i+1] = left[i]*nums[i]\\n        \\n        \\n        for i in range(0, n-1):\\n            left[-1 - i] *= left[0]\\n            left[0] *= nums[-1 - i]\\n            \\n        return left\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        \\n        n = len(nums)\\n        answer = [1] * n #this will hold our output\\n       \\n\\t\\tfor i in range(0, n):\\n            for j in range(0, n):\\n                if i != j:\\n                    answer[i] = answer[i] * nums[j]\\n                    \\n        return answer\\n  ```\n```\\n        n=len(nums)\\n        left=[1]*n\\n        \\n        for i in range(0, n-1): \\n            left[i+1] = left[i]*nums[i]\\n        \\n        \\n        for i in range(0, n-1):\\n            left[-1 - i] *= left[0]\\n            left[0] *= nums[-1 - i]\\n            \\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497566,
                "title": "clean-and-fast-o-n-python3-with-explanation",
                "content": "Complexity: time *O(N)*, space *O(1)* -- not counting the return array.\\n\\nThe insight for this problem, is that in order to compute `out[i]` we need to multiply the product of `num[0...i-1]` with that of `num[i+1...N)`.  So one approach is:\\n1. Traverse `nums` --> build `left`\\n2. Traverse `nums` (in reverse order) --> build `right`\\n3. For all `i`, multiply `left[i]` and `right[i]` --> build `out`\\n\\nYou can easily code it in *O(N)* time, and *O(N)* space complexity.\\n\\nTo cut on the space complexity, you can temporarily use the `out` array to store `right` and then build `left` as we go (scalar, instead of array). The result is *O(N)* in time (and faster), and *O(1)* in space.\\n\\n```\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n\\n        N = len(nums)\\n        out = [1]*N\\n        # Use the \\'out\\' array to temporarily store the multiplication of the right elements\\n        # We don\\'t really need the scalar \\'right\\', but I think it will save us on array dereferences\\n        right = 1\\n        for p in reversed(range(N)):\\n            out[p] = right\\n            right *= nums[p]\\n\\n        # The scalar \\'left\\' will hold the multiplication of the left elements\\n        left = 1\\n        for p in range(N):\\n            out[p] *= left\\n            left *= nums[p]\\n\\n        return out\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n\\n        N = len(nums)\\n        out = [1]*N\\n        # Use the \\'out\\' array to temporarily store the multiplication of the right elements\\n        # We don\\'t really need the scalar \\'right\\', but I think it will save us on array dereferences\\n        right = 1\\n        for p in reversed(range(N)):\\n            out[p] = right\\n            right *= nums[p]\\n\\n        # The scalar \\'left\\' will hold the multiplication of the left elements\\n        left = 1\\n        for p in range(N):\\n            out[p] *= left\\n            left *= nums[p]\\n\\n        return out\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 471589,
                "title": "java-using-division",
                "content": "```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int nZeroes = 0;\\n        int prod = 1;\\n        int[] res = new int[n];\\n        for (int num: nums)\\n            if (num == 0) {\\n                ++nZeroes;\\n                if (nZeroes >= 2) return res;\\n            } else {\\n                prod *= num;\\n            }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            int num = nums[i];\\n            if (nZeroes == 1) {\\n                if (num == 0)\\n                    res[i] = prod;\\n            } else {\\n                res[i] = prod / num;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int nZeroes = 0;\\n        int prod = 1;\\n        int[] res = new int[n];\\n        for (int num: nums)\\n            if (num == 0) {\\n                ++nZeroes;\\n                if (nZeroes >= 2) return res;\\n            } else {\\n                prod *= num;\\n            }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            int num = nums[i];\\n            if (nZeroes == 1) {\\n                if (num == 0)\\n                    res[i] = prod;\\n            } else {\\n                res[i] = prod / num;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 114292,
                "title": "a-simple-c-solution-accepted",
                "content": "```\\n/**\\n * Return an array of size *returnSize.\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* productExceptSelf(int* nums, int numsSize, int* returnSize) {\\n    int *ret=(int*)malloc(numsSize*sizeof(int));\\n    *returnSize=numsSize;\\n    ret[0]=1;\\n    for(int i=1;i<numsSize;i++){\\n        ret[i]=nums[i-1]*ret[i-1];\\n    }\\n    int temp=1;\\n    for(int i=numsSize-1;i>=0;i--){\\n        ret[i]*=temp;\\n        temp*=nums[i];\\n    }\\n    return ret;\\n}\\n````",
                "solutionTags": [],
                "code": "```\\n/**\\n * Return an array of size *returnSize.\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* productExceptSelf(int* nums, int numsSize, int* returnSize) {\\n    int *ret=(int*)malloc(numsSize*sizeof(int));\\n    *returnSize=numsSize;\\n    ret[0]=1;\\n    for(int i=1;i<numsSize;i++){\\n        ret[i]=nums[i-1]*ret[i-1];\\n    }\\n    int temp=1;\\n    for(int i=numsSize-1;i>=0;i--){\\n        ret[i]*=temp;\\n        temp*=nums[i];\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65654,
                "title": "swift-solution-without-extra-space-in-linear-time",
                "content": "```\\n    func productExceptSelf(_ nums: [Int]) -> [Int] {\\n        var last = 1\\n        var result: [Int] = []\\n        for i in 0..<nums.count {\\n            result.append(last)\\n            last *= nums[i]\\n        }\\n\\n        last = 1\\n        for i in stride(from: nums.count-1, through: 0, by: -1) {\\n            result[i] *= last\\n            last *= nums[i]\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n    func productExceptSelf(_ nums: [Int]) -> [Int] {\\n        var last = 1\\n        var result: [Int] = []\\n        for i in 0..<nums.count {\\n            result.append(last)\\n            last *= nums[i]\\n        }\\n\\n        last = 1\\n        for i in stride(from: nums.count-1, through: 0, by: -1) {\\n            result[i] *= last\\n            last *= nums[i]\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 65750,
                "title": "c-o-1-space-and-o-n-time",
                "content": "    class Solution {\\n    public:\\n        vector<int> productExceptSelf(vector<int>& nums) {\\n            if(nums.empty()){\\n                return vector<int>{};\\n            }\\n            int n = nums.size();\\n            vector<int> ans(n, 1);\\n            int begin = 1, end = 1;\\n            for(int i = 0;i < n; ++i){\\n                ans[i] *= begin;\\n                begin *= nums[i];\\n                ans[n - 1 - i] *= end;\\n                end *= nums[n - 1 - i];\\n            }\\n            return ans;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> productExceptSelf(vector<int>& nums) {\\n            if(nums.empty()){\\n                return vector<int>{}",
                "codeTag": "Java"
            },
            {
                "id": 65769,
                "title": "easy-java-solution-in-o-n-time-and-no-extra-space-2ms",
                "content": "    public class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        final int[] result = new int[nums.length];\\n        for(int i=0, leftProduct=1; i<nums.length; i++) { // left product\\n            result[i] = leftProduct;\\n            leftProduct *= nums[i];\\n        }\\n        for(int i=nums.length-1, rightProduct=1; i>=0; i--) { // right product\\n            result[i] *= rightProduct;\\n            rightProduct *= nums[i];\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        final int[] result = new int[nums.length];\\n        for(int i=0, leftProduct=1; i<nums.length; i++) { // left product\\n            result[i] = leftProduct;\\n            leftProduct *= nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 65810,
                "title": "see-my-concise-solution-with-constant-space-and-o-n-complexity",
                "content": "        class Solution {\\n    public:\\n        vector<int> productExceptSelf(vector<int>& nums) {\\n            vector<int> result;\\n            int current = 1;\\n            for (int i = 0;i < nums.size();++ i) {\\n                result.push_back(current);\\n                current *= nums[i];\\n            }\\n            int n = nums.size();\\n            current = 1;\\n            for (int i = n-1;i >= 0;-- i) {\\n                result[i] = current * result[i];\\n                current *= nums[i];\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> productExceptSelf(vector<int>& nums) {\\n            vector<int> result;\\n            int current = 1;\\n            for (int i = 0;i < nums.size();++ i) {\\n                result.push_back(current);\\n                current *= nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 65823,
                "title": "java-solution-with-constant-space",
                "content": "    public class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] output = new int[n];\\n        int temp = 1;\\n        output[0] = 1;\\n        for (int i = 1; i < n; i++)\\n        {\\n            output[i] = output[i-1] * nums[i-1];\\n        }\\n        for (int i = n - 1; i >= 0 ; i--)\\n        {\\n            output[i] = temp * output[i];\\n            temp = temp * nums[i];\\n        }\\n        return output;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] output = new int[n];\\n        int temp = 1;\\n        output[0] = 1;\\n        for (int i = 1; i < n; i++)\\n        {\\n            output[i] = output[i-1] * nums[i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 65844,
                "title": "my-java-solution-with-o-n-time-and-o-n-space",
                "content": "    public class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n=nums.length;\\n        int A[]=new int[n];\\n        int B[]=new int[n];\\n        A[0]=1;B[n-1]=1;\\n        for(int i=1;i<n;i++) {\\n            A[i]=A[i-1]*nums[i-1];\\n            B[n-1-i]=B[n-i]*nums[n-i];\\n        } \\n        for(int i=0;i<n;i++){\\n            nums[i]=A[i]*B[i];\\n        }\\n        return nums;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n=nums.length;\\n        int A[]=new int[n];\\n        int B[]=new int[n];\\n        A[0]=1;B[n-1]=1;\\n        for(int i=1;i<n;i++) {\\n            A[i]=A[i-1]*nums[i-1];\\n            B[n-1-i]=B[n-i]*nums[n-i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 65800,
                "title": "only-one-pass-no-extra-spaces-solution",
                "content": "    class Solution {\\n    public:\\n        vector<int> productExceptSelf(vector<int>& nums) {\\n            const int N = nums.size();\\n            vector<int> ret(N, 1);\\n            int left = 1, right = 1;\\n            for (int i = 0; i < N; ++i) {\\n                ret[i] *= left;\\n                ret[N-1-i] *= right;\\n                left *= nums[i];\\n                right *= nums[N-1-i];\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> productExceptSelf(vector<int>& nums) {\\n            const int N = nums.size();\\n            vector<int> ret(N, 1);\\n            int left = 1, right = 1;\\n            for (int i = 0; i < N; ++i) {\\n                ret[i] *= left;\\n                ret[N-1-i] *= right;\\n                left *= nums[i];\\n                right *= nums[N-1-i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3524777,
                "title": "python-code-explained-with-approach-and-time-complexity",
                "content": "# Intuition\\n\\n- The product of all elements in an array except the current element can be calculated by multiplying the prefix product of all elements to the left of the current element with the suffix product of all elements to the right of the current element.\\n\\n# Approach\\n\\n- Create three arrays to store the result, prefix products, and suffix products.\\n- Calculate the prefix products by iterating through the input array from left to right and updating the prefix product at each index.\\n- Calculate the suffix products by iterating through the input array from right to left and updating the suffix product at each index.\\n- Set the result array values by multiplying the corresponding prefix and suffix products.\\n- Return the result array.\\n\\n# Complexity\\n**Time complexity:**\\n\\n- The given solution has a time complexity of O(n), where n is the length of the input array.\\n- This is because the solution iterates through the input array twice and performs constant time operations at each index.\\n\\n**Space complexity:**\\n\\n- The given solution has a space complexity of O(n), where n is the length of the input array.\\n- This is because the solution creates three additional arrays of length n to store the prefix, suffix, and result values.\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        \\n        result = len(nums)*[1]   # create an array to store the result and initialize it with 1\\n        pre = len(nums)*[1]      # create an array to store prefix products and initialize it with 1\\n        post= len(nums)*[1]      # create an array to store suffix products and initialize it with 1\\n        pref, postf = 1 , 1      # initialize prefix and suffix products to 1\\n        \\n        # calculate prefix products\\n        for i in range(len(nums)):\\n            pre[i]= pref       # store the prefix product of nums[0:i] in pre[i]\\n            pref *= nums[i]    # update the prefix product by multiplying with the current number\\n            \\n        # calculate suffix products\\n        for i in range(len(nums)-1,-1,-1):\\n            post[i]= postf      # store the suffix product of nums[i+1:n] in post[i]\\n            postf *=nums[i]     # update the suffix product by multiplying with the current number\\n        \\n        result[0]= post[0]       # set result[0] to the suffix product of the last element\\n        result[len(nums)-1] = pre[len(nums)-1]   # set result[n-1] to the prefix product of the first element\\n        \\n        # calculate product of prefix and suffix values\\n        for i in range (1,len(nums)-1):\\n            result[i]=pre[i]*post[i]   # compute the product of prefix and suffix values\\n        \\n        return result     # return the final result array\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        \\n        result = len(nums)*[1]   # create an array to store the result and initialize it with 1\\n        pre = len(nums)*[1]      # create an array to store prefix products and initialize it with 1\\n        post= len(nums)*[1]      # create an array to store suffix products and initialize it with 1\\n        pref, postf = 1 , 1      # initialize prefix and suffix products to 1\\n        \\n        # calculate prefix products\\n        for i in range(len(nums)):\\n            pre[i]= pref       # store the prefix product of nums[0:i] in pre[i]\\n            pref *= nums[i]    # update the prefix product by multiplying with the current number\\n            \\n        # calculate suffix products\\n        for i in range(len(nums)-1,-1,-1):\\n            post[i]= postf      # store the suffix product of nums[i+1:n] in post[i]\\n            postf *=nums[i]     # update the suffix product by multiplying with the current number\\n        \\n        result[0]= post[0]       # set result[0] to the suffix product of the last element\\n        result[len(nums)-1] = pre[len(nums)-1]   # set result[n-1] to the prefix product of the first element\\n        \\n        # calculate product of prefix and suffix values\\n        for i in range (1,len(nums)-1):\\n            result[i]=pre[i]*post[i]   # compute the product of prefix and suffix values\\n        \\n        return result     # return the final result array\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073199,
                "title": "java-easiest-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        for (int i = 0, left = 1; i < n; ++i) {\\n            ans[i] = left;\\n            left *= nums[i];\\n        }\\n        for (int i = n - 1, right = 1; i >= 0; --i) {\\n            ans[i] *= right;\\n            right *= nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        for (int i = 0, left = 1; i < n; ++i) {\\n            ans[i] = left;\\n            left *= nums[i];\\n        }\\n        for (int i = n - 1, right = 1; i >= 0; --i) {\\n            ans[i] *= right;\\n            right *= nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892353,
                "title": "c-o-n-o-1-solution",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int[] ProductExceptSelf(int[] nums) \\n    {\\n        int n = nums.Length;\\n        int[] ans = new int[n];\\n        for (int i = 0; i < n; ++i) ans[i] = 1;\\n\\n        int leftProduct = 1, rightProduct = 1;\\n        for (int i = 1, j = n - 2; i < n; ++i, --j)\\n        {\\n            leftProduct *= nums[i - 1];\\n            rightProduct *= nums[j + 1];\\n            ans[i] *= leftProduct;\\n            ans[j] *= rightProduct;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int[] ProductExceptSelf(int[] nums) \\n    {\\n        int n = nums.Length;\\n        int[] ans = new int[n];\\n        for (int i = 0; i < n; ++i) ans[i] = 1;\\n\\n        int leftProduct = 1, rightProduct = 1;\\n        for (int i = 1, j = n - 2; i < n; ++i, --j)\\n        {\\n            leftProduct *= nums[i - 1];\\n            rightProduct *= nums[j + 1];\\n            ans[i] *= leftProduct;\\n            ans[j] *= rightProduct;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399460,
                "title": "video-explanation-for-both-o-n-and-o-1-space-complexity",
                "content": "I posted a video explanation of the problem: https://www.youtube.com/watch?v=fFNIP5E5AJE\\nIt first explains the O(N) space complexity solution then the O(1) space complexity solution.\\nHope it helps for building intuition on how to solve problems like these.",
                "solutionTags": [
                    "Python"
                ],
                "code": "I posted a video explanation of the problem: https://www.youtube.com/watch?v=fFNIP5E5AJE\\nIt first explains the O(N) space complexity solution then the O(1) space complexity solution.\\nHope it helps for building intuition on how to solve problems like these.",
                "codeTag": "Unknown"
            },
            {
                "id": 2334577,
                "title": "fastest-java-solution-runtime-1-ms-faster-than-100-00-memory-usage-50-2-mb-less-than-97-44",
                "content": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n    \\tint[] res = new int[nums.length];\\n    \\tint dummy=1;\\n    \\tfor (int i=0;i<nums.length;i++) {\\n    \\t\\tres[i]=dummy;\\n    \\t\\tdummy*=nums[i];\\n    \\t}\\n        dummy=1;\\n    \\tfor(int i=nums.length-1;i>=0;i--) {\\n    \\t\\tres[i]*=dummy;\\n    \\t\\tdummy*=nums[i];\\n    \\t}\\n    \\treturn res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n    \\tint[] res = new int[nums.length];\\n    \\tint dummy=1;\\n    \\tfor (int i=0;i<nums.length;i++) {\\n    \\t\\tres[i]=dummy;\\n    \\t\\tdummy*=nums[i];\\n    \\t}\\n        dummy=1;\\n    \\tfor(int i=nums.length-1;i>=0;i--) {\\n    \\t\\tres[i]*=dummy;\\n    \\t\\tdummy*=nums[i];\\n    \\t}\\n    \\treturn res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130470,
                "title": "c-solution-o-n-time-and-o-1-space-with-dry-run-example",
                "content": "1) We can solve it by multiplying each element of the array  and storing the total value and then dividing it by the each element of array. But it is clearly mentioned not to use division operator.\\n2) So we have other method of maintaining two arrays one with suffix product and prefix product of a particualr element and then multipling those two to get desired output. But the space complexity won\\'t be O(1).\\n\\nSolution : Time Complexity: O(n) , Space Complexity : O(1)\\n```\\nvector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int>ans;\\n        int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n            ans.push_back(product);\\n        }\\n        product=1;\\n        for(int i=nums.size()-1;i>0;i--){\\n            ans[i]=ans[i-1]*product;\\n            product=product*nums[i];\\n        }\\n        ans[0]=product;\\n        return ans;\\n}\\n```\\nDry Run:\\n![image](https://assets.leetcode.com/users/images/b6ff846b-1931-41f9-badb-266d85f98a13_1654768691.819684.jpeg)\\n![image](https://assets.leetcode.com/users/images/eeb52723-5171-48c9-8c94-4a7793166d0b_1654768704.2956436.jpeg)\\n\\nThis is my first discussion post. Feel free to suggest. Thanks\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int>ans;\\n        int product=1;\\n        for(int i=0;i<nums.size();i++){\\n            product=product*nums[i];\\n            ans.push_back(product);\\n        }\\n        product=1;\\n        for(int i=nums.size()-1;i>0;i--){\\n            ans[i]=ans[i-1]*product;\\n            product=product*nums[i];\\n        }\\n        ans[0]=product;\\n        return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2005648,
                "title": "highly-efficient-python-code-beats-99-with-explanantion",
                "content": "****\\n#### **Proof:**\\n![image](https://assets.leetcode.com/users/images/1623421d-d81b-4256-8134-95a2285d0c61_1651612230.3819964.png)\\n****\\n#### **Explanation:**\\nIf the input is: \\n\\n**Input : [1,2,3,4]**\\n\\nWe will create a new list dp which will have the product of all values to the left of the indexed value.\\nSince there is no element to the left of first element, we add 1 to dp and then after moving one by one we will get:\\n\\n**dp : [1, 1, 2, 6]**\\n\\nAfter that we will initialise product as 1 which will contain product of all values to the right of the indexed value.\\nNow, we start at the last index and just multiply the left product from dp and right product from product variable.\\nwhich will result in :\\n\\n**Output : [24,12,8,6]**\\n\\n****\\n\\n\\n#### **Code:**\\n\\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        dp=[]\\n        product=1\\n        for i in nums:\\n            dp.append(product)\\n            product*=i\\n        product=1\\n        for i in range(len(nums)-1,-1,-1):\\n            dp[i]=dp[i]*product\\n            product*=nums[i]\\n        return dp\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        dp=[]\\n        product=1\\n        for i in nums:\\n            dp.append(product)\\n            product*=i\\n        product=1\\n        for i in range(len(nums)-1,-1,-1):\\n            dp[i]=dp[i]*product\\n            product*=nums[i]\\n        return dp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967548,
                "title": "c-o-n-and-o-1-solution",
                "content": "Time Complexity :O(n) \\nSpace Complexity : O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> prefixProduct(nums.size()+1,1),suffixProduct(nums.size()+1,1);\\n        for(int i=0;i<nums.size();i++){\\n            prefixProduct[i+1]=prefixProduct[i]*nums[i];\\n        }\\n        for(int i=nums.size()-1;i>=0;i--){\\n            suffixProduct[i]=suffixProduct[i+1]*nums[i];\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(prefixProduct[i]*suffixProduct[i+1]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\nTime Complexity : O(n)\\nSpace Complexity: O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans(nums.size(),1);\\n        int fromStart=1;\\n        int fromLast=1;\\n        for(int i=0;i<nums.size();i++){\\n            ans[i]*=fromStart;\\n            fromStart*=nums[i];\\n            ans[nums.size()-1-i]*=fromLast;\\n            fromLast*=nums[nums.size()-1-i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> prefixProduct(nums.size()+1,1),suffixProduct(nums.size()+1,1);\\n        for(int i=0;i<nums.size();i++){\\n            prefixProduct[i+1]=prefixProduct[i]*nums[i];\\n        }\\n        for(int i=nums.size()-1;i>=0;i--){\\n            suffixProduct[i]=suffixProduct[i+1]*nums[i];\\n        }\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(prefixProduct[i]*suffixProduct[i+1]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans(nums.size(),1);\\n        int fromStart=1;\\n        int fromLast=1;\\n        for(int i=0;i<nums.size();i++){\\n            ans[i]*=fromStart;\\n            fromStart*=nums[i];\\n            ans[nums.size()-1-i]*=fromLast;\\n            fromLast*=nums[nums.size()-1-i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694007,
                "title": "golang-easy-implementation-of-solution",
                "content": "```\\nfunc productExceptSelf(nums []int) []int {\\n    res := make([]int, len(nums))\\n    \\n    for i := range nums {\\n        res[i] = 1\\n    }\\n    \\n    prefix := 1\\n    for i := 0; i < len(nums); i++ {\\n        res[i] = prefix\\n        prefix = prefix * nums[i]\\n    }\\n    \\n    postfix := 1\\n    for i := len(nums) - 1; i >= 0; i-- {\\n        res[i] = res[i] * postfix\\n        postfix = postfix * nums[i]\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc productExceptSelf(nums []int) []int {\\n    res := make([]int, len(nums))\\n    \\n    for i := range nums {\\n        res[i] = 1\\n    }\\n    \\n    prefix := 1\\n    for i := 0; i < len(nums); i++ {\\n        res[i] = prefix\\n        prefix = prefix * nums[i]\\n    }\\n    \\n    postfix := 1\\n    for i := len(nums) - 1; i >= 0; i-- {\\n        res[i] = res[i] * postfix\\n        postfix = postfix * nums[i]\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1672404,
                "title": "java-solution-faster-than-100-with-explanation",
                "content": "```\\npublic int[] productExceptSelf(int[] nums) {\\n\\tint[] result = new int[nums.length];\\n\\t\\n\\t// I will explain this down the line\\n\\tint leftOver = 1;\\n\\t\\n\\t// The first element of the result array by default will \\n\\t// be the first element of the original array.\\n\\tresult[0] = nums[0]\\n\\t\\n\\t//Consider the following\\n\\t// original: [1, 2, 3, 4]\\n\\t// result:    [1, 2, 6, 24]\\n\\t// Recall first element of result is = first element of original\\n\\t// Subsequent elements will be : result[i] = result[i - 1] * nums[i];\\n\\t//Example: result[1] = result[0] * nums[1] => 1 * 2\\n\\t//                result[2] = result[1] * nums[2] => 2 * 3\\n\\t\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tresult[i] = result[i - 1] * nums[i];\\n\\t}\\n\\t\\n\\t// At this point, the result array is:    [1, 2, 6, 24]\\n\\t// We now iterate from the end of the array to the start.\\n\\t// At a given position i, the \"product except i\" = result[i - 1] * leftOver\\n\\t\\n\\t// leftOver is simply the multiplication of all elements from the end.\\n\\t// Example: at index 3, this is the end of the array, so leftOver is default  i.e 1\\n\\t// at index 2, leftOver = leftOver * nums[i + 1] = 1 *  4 = 4\\n\\t// at index 1, leftOver =  leftOver * nums[i + 1] = 4 * 3 = 12\\n\\t// Now see it in action.\\n\\t\\n\\tfor (int i = nums.length - 1; i >= 0; i--) {\\n\\t\\tif (i < nums.length - 1)\\n\\t\\t\\tleftOver = leftOver * nums[i + 1];\\n\\t\\t\\t\\n\\t\\tif (i > 0)\\n\\t\\t\\tresult[i] = result[i - 1] * leftOver;\\n\\t\\telse \\n\\t\\t\\tresult[i] = leftOver;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] productExceptSelf(int[] nums) {\\n\\tint[] result = new int[nums.length];\\n\\t\\n\\t// I will explain this down the line\\n\\tint leftOver = 1;\\n\\t\\n\\t// The first element of the result array by default will \\n\\t// be the first element of the original array.\\n\\tresult[0] = nums[0]\\n\\t\\n\\t//Consider the following\\n\\t// original: [1, 2, 3, 4]\\n\\t// result:    [1, 2, 6, 24]\\n\\t// Recall first element of result is = first element of original\\n\\t// Subsequent elements will be : result[i] = result[i - 1] * nums[i];\\n\\t//Example: result[1] = result[0] * nums[1] => 1 * 2\\n\\t//                result[2] = result[1] * nums[2] => 2 * 3\\n\\t\\n\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\tresult[i] = result[i - 1] * nums[i];\\n\\t}\\n\\t\\n\\t// At this point, the result array is:    [1, 2, 6, 24]\\n\\t// We now iterate from the end of the array to the start.\\n\\t// At a given position i, the \"product except i\" = result[i - 1] * leftOver\\n\\t\\n\\t// leftOver is simply the multiplication of all elements from the end.\\n\\t// Example: at index 3, this is the end of the array, so leftOver is default  i.e 1\\n\\t// at index 2, leftOver = leftOver * nums[i + 1] = 1 *  4 = 4\\n\\t// at index 1, leftOver =  leftOver * nums[i + 1] = 4 * 3 = 12\\n\\t// Now see it in action.\\n\\t\\n\\tfor (int i = nums.length - 1; i >= 0; i--) {\\n\\t\\tif (i < nums.length - 1)\\n\\t\\t\\tleftOver = leftOver * nums[i + 1];\\n\\t\\t\\t\\n\\t\\tif (i > 0)\\n\\t\\t\\tresult[i] = result[i - 1] * leftOver;\\n\\t\\telse \\n\\t\\t\\tresult[i] = leftOver;\\n\\t}\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1640693,
                "title": "runtime-1-ms-faster-than-100-00-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic int[] productExceptSelf(int[] nums) {\\n\\n\\t\\tint n = nums.length;\\n\\t\\tint[] right = new int[n];\\n\\t\\tint[] ans = new int[n];\\n\\n\\t\\tint r = 1;\\n\\t\\t\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tright[i] = r;\\n\\n\\t\\t\\tr *= nums[i];\\n\\t\\t}\\n\\t\\t\\n\\t\\tint l = 1;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tans[i] = l * right[i];\\n\\t\\t\\tl *= nums[i];\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic int[] productExceptSelf(int[] nums) {\\n\\n\\t\\tint n = nums.length;\\n\\t\\tint[] right = new int[n];\\n\\t\\tint[] ans = new int[n];\\n\\n\\t\\tint r = 1;\\n\\t\\t\\n\\t\\tfor (int i = n - 1; i >= 0; i--) {\\n\\t\\t\\tright[i] = r;\\n\\n\\t\\t\\tr *= nums[i];\\n\\t\\t}\\n\\t\\t\\n\\t\\tint l = 1;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tans[i] = l * right[i];\\n\\t\\t\\tl *= nums[i];\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527525,
                "title": "java-100-faster",
                "content": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] array) {\\n        int[] products = new int[array.length];\\n\\t\\t\\n\\t\\tint leftRunningProduct=1;\\n\\t\\tfor(int i=0;i<array.length;i++){\\n\\t\\t\\tproducts[i]=leftRunningProduct;\\n\\t\\t\\tleftRunningProduct*=array[i];\\n\\t\\t}\\n\\n\\t\\tint rightRunningProduct=1;\\n\\t\\tfor(int i=array.length -1;i>=0;i--){\\n\\t\\t\\tproducts[i]*= rightRunningProduct;\\n\\t\\t\\trightRunningProduct *= array[i];\\n\\t\\t}\\n\\t\\treturn products;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] array) {\\n        int[] products = new int[array.length];\\n\\t\\t\\n\\t\\tint leftRunningProduct=1;\\n\\t\\tfor(int i=0;i<array.length;i++){\\n\\t\\t\\tproducts[i]=leftRunningProduct;\\n\\t\\t\\tleftRunningProduct*=array[i];\\n\\t\\t}\\n\\n\\t\\tint rightRunningProduct=1;\\n\\t\\tfor(int i=array.length -1;i>=0;i--){\\n\\t\\t\\tproducts[i]*= rightRunningProduct;\\n\\t\\t\\trightRunningProduct *= array[i];\\n\\t\\t}\\n\\t\\treturn products;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305029,
                "title": "java-simplest-solution-with-3-approaches-thought-process-and-logic",
                "content": "Solution1: Looking at the problem, the first solution that comes to mind is to use the division method.\\n1. Calculate the product of all elements in the array.\\n2. Iterate over the array and divide current element with the product calculated and replace in the array.\\n\\nTime complexity: O(N)\\nSpace complexity: O(1)\\n\\nSolution2: Two arrays approach\\n\\n1. Use two arrays and let one store the product upto i-1 elements for ith element. Let the other array store product upto n-i-1 elements for the ith element.\\n2. Iterate over the array and output[i] = array1[i] * array2[i]\\n\\n\\nTime complexity: O(N)\\nSpace complexity: O(N)\\n\\n\\nSolution3: One output array approach\\n\\n1. Similar to above approach, but instead of using second array, multiply the array1[i] with the product of n-i-1 elements. \\n\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] output = new int[nums.length];\\n        int c = 1;\\n        for(int i=0; i<nums.length; i++){\\n            output[i] = c;\\n            c = nums[i]*c;\\n        }\\n        c = 1;\\n        for(int i=nums.length-1; i>=0; i--){\\n            output[i] *= c;\\n            c = nums[i]*c;\\n        }\\n        return output;\\n    }\\n}\\n```\\n\\n\\nTime complexity: O(N)\\nSpace complexity: O(N) but as they say output array doesnt count this will be O(1)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] output = new int[nums.length];\\n        int c = 1;\\n        for(int i=0; i<nums.length; i++){\\n            output[i] = c;\\n            c = nums[i]*c;\\n        }\\n        c = 1;\\n        for(int i=nums.length-1; i>=0; i--){\\n            output[i] *= c;\\n            c = nums[i]*c;\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931449,
                "title": "scala-3-lines",
                "content": "```scala\\nobject Solution {\\n    def productExceptSelf(nums: Array[Int]): Array[Int] = {\\n        val _left = nums.scanLeft(1)(_*_).dropRight(1)\\n        val _right = nums.scanRight(1)(_*_).tail\\n        \\n        _left zip _right map {case (l,r) => l*r}\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```scala\\nobject Solution {\\n    def productExceptSelf(nums: Array[Int]): Array[Int] = {\\n        val _left = nums.scanLeft(1)(_*_).dropRight(1)\\n        val _right = nums.scanRight(1)(_*_).tail\\n        \\n        _left zip _right map {case (l,r) => l*r}\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 580788,
                "title": "kotlin",
                "content": "```\\nclass Solution {\\n    fun productExceptSelf(nums: IntArray): IntArray {\\n        val output: IntArray = IntArray(nums.size) { 1 }\\n        val end: Int = nums.size - 1\\n        \\n        var left: Int = 1\\n        var right: Int = 1\\n        \\n        for (index: Int in 0 until nums.size) {\\n            output[index] *= left\\n            output[end - index] *= right\\n            \\n            left *= nums[index]\\n            right *= nums[end - index]\\n        }\\n        \\n        return output\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun productExceptSelf(nums: IntArray): IntArray {\\n        val output: IntArray = IntArray(nums.size) { 1 }\\n        val end: Int = nums.size - 1\\n        \\n        var left: Int = 1\\n        var right: Int = 1\\n        \\n        for (index: Int in 0 until nums.size) {\\n            output[index] *= left\\n            output[end - index] *= right\\n            \\n            left *= nums[index]\\n            right *= nums[end - index]\\n        }\\n        \\n        return output\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 503099,
                "title": "c-single-pass-fast-but-memory-inefficient",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> results(nums.size(), 1);\\n        int left = 1, right = 1;\\n        for (int i=0, j=nums.size()-1; i < nums.size() && j >=0; i++, j--) {\\n            results[i] *= left;\\n            results[j] *= right;\\n            left *= nums[i];\\n            right *= nums[j];\\n        }\\n        return results;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> results(nums.size(), 1);\\n        int left = 1, right = 1;\\n        for (int i=0, j=nums.size()-1; i < nums.size() && j >=0; i++, j--) {\\n            results[i] *= left;\\n            results[j] *= right;\\n            left *= nums[i];\\n            right *= nums[j];\\n        }\\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 421571,
                "title": "straightforward-python-solution",
                "content": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n\\t\\n        left, right, res = [1] * len(nums), [1] * len(nums), [1] * len(nums)\\n\\t\\t\\n        for i in range(1, len(nums)):\\n            left[i] = nums[i - 1] * left[i - 1]\\n\\t\\t\\t\\n        for i in range(len(nums) - 2, -1, -1):\\n            right[i] = nums[i + 1] * right[i + 1]\\n\\t\\t\\t\\n        for i in range(len(res)):\\n            res[i] = left[i] * right[i]\\n\\t\\t\\t\\n        return res\\n    \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n\\t\\n        left, right, res = [1] * len(nums), [1] * len(nums), [1] * len(nums)\\n\\t\\t\\n        for i in range(1, len(nums)):\\n            left[i] = nums[i - 1] * left[i - 1]\\n\\t\\t\\t\\n        for i in range(len(nums) - 2, -1, -1):\\n            right[i] = nums[i + 1] * right[i + 1]\\n\\t\\t\\t\\n        for i in range(len(res)):\\n            res[i] = left[i] * right[i]\\n\\t\\t\\t\\n        return res\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 65697,
                "title": "share-my-o-n-no-extra-space-c-solution-with-thinking-process-and-explanation",
                "content": "---\\n## 1. Problem\\n\\n---\\nThe problem is\\n\\nGiven an array of n integers where n > 1, nums, return an array output such that **output[i] is equal to the product of all the elements of nums except nums[i].**\\n\\n---\\n## 2. Thinking process\\n\\n---\\nWe assume the **input array is {a(1), a(2),..., a(n)} (n \\u2265 1)**, and the **output array is {d(1), d(2),..., d(n)}**.\\n\\n---\\n#### 2.1 Trivial approach\\n\\n---\\n\\n1. A variable **X** is used for **saving the multiplication result**. **At the beginning , X = 1**.\\n\\n2. In **loop i (1 \\u2264 i \\u2264 n)**, the program visit a(k)(1 \\u2264 k \\u2264 n, k \\u2260 i), and **save X \\xd7 a(k) to X**.\\n\\n**In total, the program will visit n(n - 1) times! That's too much.**\\n\\n---\\n#### 2.2 New idea\\n\\n---\\n\\nIf we focus on the output array : d(1), d(2),..., d(n) (assuming n > 2), we can get:\\n\\n> #### **d(i) = [1] \\xd7 [a(2) \\xd7 ... \\xd7 a(n)] (i = 1)**\\n> #### **d(i) = [a(1) \\xd7 ... \\xd7 a(n - 1)] \\xd7 [1] (i = n)**\\n> #### **d(i) = [a(1) \\xd7 ... \\xd7 a(i - 1)] \\xd7 [a(i + 1) \\xd7 ... \\xd7 a(n)] (1 < i < n)**\\n\\nIf n > 2, d(i) can be divided in to **2 parts**, **the left** (called **L(i)**), and **the right**  (called **R(i)**). We have\\n\\n> #### **d(i) = L(i) \\xd7 R(i)**\\n\\nThe left\\n\\n> #### **L(i) = 1 (i = 1)**\\n> #### **L(i) = a(1) \\xd7 ... \\xd7 a(i - 1) (1 < i \\u2264 n)**\\n\\nThe right\\n\\n> #### **R(i) = a(i + 1) \\xd7 ... \\xd7 a(n) (1 \\u2264 i < n)**\\n> #### **R(i) = 1 (i = n)**\\n\\nHere, I use an **array P to save L**, let\\n> #### **P(i) = L(i + 1) (1 \\u2264 i < n) (P(n) is not used)**\\n\\nAlso, I use an **array Q to save R**, let\\n> #### **Q(i + 1) = R(i) (1 \\u2264 i < n) (Q(1) is not used)**\\n\\nFor example,\\n\\n> ####  **if the input is  [a, b, c, d]**\\n\\nthen\\n\\n> #### **P is [a, ab, abc, abcd]**\\n\\n> #### **Q is [abcd, bcd, cd, d] (abcd in both P and Q are not used)**\\n\\nThe output \\n\\n> #### **D(i) = Q(i + 1) (i = 1)**\\n> #### **D(i) = P(i - 1) \\xd7 Q(i + 1) (1 < i < n)**\\n> #### **D(i) = P(i - 1) (i = n)**\\n\\n---\\n#### 2.3 Time Complexity\\n\\n---\\nHere, we assume i is from 0 to n - 1. **The algorithm can be divided into 3 steps.**\\n\\n**Step 1**. Setting **P(i) = a(i), Q(i) = a(i)**, and **do iteration from i = 0 to n - 1**. **(1 pass, 2n visits)**\\n\\n**Step 2**. Using **P(i) = P(i) \\xd7 P(i - 1), Q(n - i - 1) = Q(n - i - 1) \\xd7 Q(n - i)**, and **do iteration from i = 0 to n - 1**, P and Q are finished. **(1 pass, 2n visits)**\\n\\n**Step 3**. **Setting D(i)**. **(1 pass, 3n visits)**\\n\\n**The time complexity is 2n + 2n + 3n = 7n = O(n)**.\\n\\nThe algorithm **meets the time complexity requirement** for the problem, **but P and Q are extra space**.\\n\\n---\\n## 4. Optimization\\n\\n---\\n\\nHere, I try to **optimize the extra space usage**. Assume the **output array is 'ans'**.\\n\\nFor **Step 1 in 2.3,**\\n\\nSince the **input** of the productExceptSelf function is a **vector reference**, **the input array nums can be used to save P. (no need to initialize P)**\\n\\nSince the **output array does not count as extra space for the purpose of space complexity analysis**, the **output array 'ans' can be used to save Q**.\\n\\n**Before saving P in nums**, we **use nums to initialize the output array ans (Step 1 in 2.3 is finished)**.\\n\\n---\\nThen, do **Step 2 in 2.3**.\\n\\nNow , **P[i] is in nums[i], and Q[i] is in ans[i]**.\\n\\n---\\n\\nFor **Step 3 in 2.3**, since the output \\n\\n> #### **D(i) = Q(i + 1) (i = 1)**\\n> #### **D(i) = P(i - 1) \\xd7 Q(i + 1) (1 < i < n)**\\n> #### **D(i) = P(i - 1) (i = n)**\\n\\nNotice that\\n\\n> #### **Q(k) (k \\u2264 i) is NEVER USED in calculating D(i).**\\n\\nIf we do iteration by **increasing i from 0 to n - 1**, \\n\\n>#### **ans[i] can be used to save D(i)**.\\n\\n**Without any extra space, the time complexity keeps the same.**\\n\\nSince **'ans' is the output array, after the iteration, the result is generated automatically.**\\n\\n---\\n## 5. Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int size = nums.size();\\n        //initialize Q\\n        vector<int> ans = vector<int>(nums);\\n        if(size == 0) return ans;\\n        if(size == 1) return nums;\\n        if(size == 2)\\n        {\\n            int temp = nums[0];\\n            nums[0] = nums[1];\\n            nums[1] = temp;\\n            return nums;\\n        }else{\\n            //generate P and Q\\n            for(int i = 1; i < size; i++)\\n            {\\n                nums[i] *= nums[i - 1];\\n                ans[size - i - 1] *= ans[size - i];\\n            }\\n            //calculate and save D(i) in ans[i]\\n            for(int i = 0; i < size; i++)\\n            {\\n                if(i == 0) ans[i] = ans[i + 1];\\n                if(i == size - 1) ans[i] = nums[i - 1];\\n                if(i > 0 && i < size - 1) ans[i] = nums[i - 1] * ans[i + 1];\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```\\n---",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int size = nums.size();\\n        //initialize Q\\n        vector<int> ans = vector<int>(nums);\\n        if(size == 0) return ans;\\n        if(size == 1) return nums;\\n        if(size == 2)\\n        {\\n            int temp = nums[0];\\n            nums[0] = nums[1];\\n            nums[1] = temp;\\n            return nums;\\n        }else{\\n            //generate P and Q\\n            for(int i = 1; i < size; i++)\\n            {\\n                nums[i] *= nums[i - 1];\\n                ans[size - i - 1] *= ans[size - i];\\n            }\\n            //calculate and save D(i) in ans[i]\\n            for(int i = 0; i < size; i++)\\n            {\\n                if(i == 0) ans[i] = ans[i + 1];\\n                if(i == size - 1) ans[i] = nums[i - 1];\\n                if(i > 0 && i < size - 1) ans[i] = nums[i - 1] * ans[i + 1];\\n            }\\n            return ans;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 65767,
                "title": "c-o-n-time-o-1-extra-space",
                "content": "\\n\\n    class Solution {\\n    public:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int k = nums.size();\\n        vector<int> res(k,1);\\n        for (int i=1;i<k;i++){\\n            res[i]=res[i-1]*nums[i-1];\\n        }\\n        int temp = 1;\\n        for (int i=k-1;i>=0;i--){\\n            res[i]=res[i]*temp;\\n            temp*=nums[i];\\n        }\\n        return res;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int k = nums.size();\\n        vector<int> res(k,1);\\n        for (int i=1;i<k;i++){\\n            res[i]=res[i-1]*nums[i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 65785,
                "title": "share-my-c-solution-with-constant-space-complexity-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        vector<int> productExceptSelf(vector<int>& nums) {\\n            int n = nums.size(), i = 0;\\n            vector<int> output(n, 1);\\n            \\n            int k = nums[n-1];\\n            for (i = 1; i < n; ++i)\\n                output[i] = output[i-1] * nums[i-1];\\n            for (i = n - 2; i >=0; --i)\\n            {\\n                output[i] *= k;\\n                k *= nums[i];\\n            }\\n            \\n            return output;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<int> productExceptSelf(vector<int>& nums) {\\n            int n = nums.size(), i = 0;\\n            vector<int> output(n, 1);\\n            \\n            int k = nums[n-1];\\n            for (i = 1; i < n; ++i)\\n                output[i] = output[i-1] * nums[i-1];\\n            for (i = n - 2; i >=0; --i)\\n            {\\n                output[i] *= k;\\n                k *= nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 4053676,
                "title": "0-n-space-c-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IF YOU LIKE IT**\\n# **CONNECT WITH ME**\\n### **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n### **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\nFunction productExceptSelf that takes a vector nums as input and returns a vector ans containing the product of all elements in the input vector except for the element at the current index. Here\\'s a step-by-step explanation of the approach used in this code:\\n\\nInitialize variables and the result vector:\\n\\n- n is the size of the input vector nums.Initialize a vector ans of the same size as nums and initialize all elements to 1. This vector will store the final result . Calculate products of elements to the left:\\n\\n- Use a product variable initially set to 1.\\nIterate through the input vector nums from left to right using a for loop.\\n-  For each element at index i, update ans[i] by multiplying it with the current value of product. This step effectively calculates the product of all elements to the left of the current index i.\\nUpdate the product variable by multiplying it with the current element nums[i].\\n- Calculate products of elements to the right:\\n\\n- Reset the product variable to 1.\\n- Iterate through the input vector nums from right to left using a for loop.\\n- For each element at index i, update ans[i] by multiplying it with the current value of product. This step effectively calculates the product of all elements to the right of the current index i.\\n- Update the product variable by multiplying it with the current element nums[i].\\n- After both loops are completed, the ans vector will contain the desired result, i.e., the product of all elements in nums except for the element at the current index.\\n\\n- Finally, return the ans vector as the output of the productExceptSelf function.\\n\\nThis approach efficiently computes the product of all elements to the left and right of each element in the input vector, providing the result in linear time complexity without using division.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:**0(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:**0(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 1); // Initialize ans with all 1s.\\n\\n        int leftProduct = 1;\\n        for (int i = 0; i < n; i++) {\\n            ans[i] *= leftProduct; // Multiply by the product of elements to the left.\\n            leftProduct *= nums[i];\\n        }\\n\\n        int rightProduct = 1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            ans[i] *= rightProduct; // Multiply by the product of elements to the right.\\n            rightProduct *= nums[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n, 1); // Initialize ans with all 1s.\\n\\n        int leftProduct = 1;\\n        for (int i = 0; i < n; i++) {\\n            ans[i] *= leftProduct; // Multiply by the product of elements to the left.\\n            leftProduct *= nums[i];\\n        }\\n\\n        int rightProduct = 1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            ans[i] *= rightProduct; // Multiply by the product of elements to the right.\\n            rightProduct *= nums[i];\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643631,
                "title": "java-100-beats-1ms-o-n-fastest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        int temp = 1;\\n        for(int i = 0; i< nums.length; i++) {\\n            ans[i] = temp;\\n            temp *= nums[i];\\n        }\\n        temp = 1;\\n        for(int i = nums.length-1; i >= 0; i--) {\\n            ans[i] *= temp;\\n            temp *= nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        int temp = 1;\\n        for(int i = 0; i< nums.length; i++) {\\n            ans[i] = temp;\\n            temp *= nums[i];\\n        }\\n        temp = 1;\\n        for(int i = nums.length-1; i >= 0; i--) {\\n            ans[i] *= temp;\\n            temp *= nums[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539676,
                "title": "java",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] result = new int[nums.length];\\n\\n        result[0] = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            result[i] = result[i-1] * nums[i-1];\\n        }\\n        \\n        int suffix = 1;\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            suffix *= nums[i + 1];\\n            result[i] *= suffix;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] result = new int[nums.length];\\n\\n        result[0] = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            result[i] = result[i-1] * nums[i-1];\\n        }\\n        \\n        int suffix = 1;\\n        for (int i = nums.length - 2; i >= 0; i--) {\\n            suffix *= nums[i + 1];\\n            result[i] *= suffix;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447796,
                "title": "golang-prefix-sum-easy-to-understand",
                "content": "# Intuition\\nLet\\'s say we have five elements\\n```\\n[a, b, c, d]\\n```\\n\\nWe can use left prefix and right prefix product arrays to calculate the answer\\n\\n```\\nLEFT  [1     a    ab    abc]\\nRIGHT [bcd  cd     d     1 ]\\nANS  [bcd   acd   abd   abc]\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nfunc productExceptSelf(nums []int) []int {\\n    l := len(nums)\\n\\tleft := make([]int, l)\\n\\tright := make([]int, l)\\n\\tans := make([]int, l)\\n\\tleft[0] = 1\\n\\tright[l-1] = 1\\n\\tfor i := 1; i < l; i++ {\\n\\t\\tj := len(nums) - i - 1\\n\\t\\tleft[i] = nums[i-1] * left[i-1]\\n\\t\\tright[j] = nums[j+1] * right[j+1]\\n\\t}\\n\\tfor i := 0; i < l; i++ {\\n\\t\\tans[i] = left[i] * right[i]\\n\\t}\\n\\treturn ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n[a, b, c, d]\\n```\n```\\nLEFT  [1     a    ab    abc]\\nRIGHT [bcd  cd     d     1 ]\\nANS  [bcd   acd   abd   abc]\\n```\n```\\nfunc productExceptSelf(nums []int) []int {\\n    l := len(nums)\\n\\tleft := make([]int, l)\\n\\tright := make([]int, l)\\n\\tans := make([]int, l)\\n\\tleft[0] = 1\\n\\tright[l-1] = 1\\n\\tfor i := 1; i < l; i++ {\\n\\t\\tj := len(nums) - i - 1\\n\\t\\tleft[i] = nums[i-1] * left[i-1]\\n\\t\\tright[j] = nums[j+1] * right[j+1]\\n\\t}\\n\\tfor i := 0; i < l; i++ {\\n\\t\\tans[i] = left[i] * right[i]\\n\\t}\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3341986,
                "title": "easy-java-solution-prefix-and-postfix-sum-tc-o-n",
                "content": "\\n\\n# Approach\\nPrefix and Postfix sum\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] left = new int[nums.length];\\n        left[0] = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            left[i] = nums[i - 1] * left[i - 1];\\n        }\\n        int[] right = new int[nums.length];\\n        right[nums.length - 1] = 1;\\n        for (int i = right.length - 2; i >= 0; i--) {\\n            right[i] = right[i + 1] * nums[i + 1];\\n        }\\n        for (int i = 0; i < right.length; i++) {\\n            left[i] = left[i] * right[i];\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] left = new int[nums.length];\\n        left[0] = 1;\\n        for (int i = 1; i < nums.length; i++) {\\n            left[i] = nums[i - 1] * left[i - 1];\\n        }\\n        int[] right = new int[nums.length];\\n        right[nums.length - 1] = 1;\\n        for (int i = right.length - 2; i >= 0; i--) {\\n            right[i] = right[i + 1] * nums[i + 1];\\n        }\\n        for (int i = 0; i < right.length; i++) {\\n            left[i] = left[i] * right[i];\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2949660,
                "title": "product-of-array-except-self-with-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsolve the question thinking of prefix and postfix product\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nupdate prefix and update each array value with prefix\\nlater update postfix and update each array with postfix\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)->because we are using one for loop\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)->we created extra space of vector<int>res(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n=nums.size();\\n        int prefix=1,postfix=1;\\n        vector<int>res(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=prefix;\\n            prefix*=nums[i];\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            res[i]*=postfix;\\n            postfix*=nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n=nums.size();\\n        int prefix=1,postfix=1;\\n        vector<int>res(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=prefix;\\n            prefix*=nums[i];\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            res[i]*=postfix;\\n            postfix*=nums[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2215275,
                "title": "beginner-friendly-solution-python",
                "content": "# **[Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)**\\n\\n## Question\\n\\n---\\n\\nGiven an integer array nums, return an array answer such that answer[i] is equal to the product of all elements of nums except nums[i]. We have to do it in linear time O(N). There will be negative integers in the array,\\n\\n## Inputs\\n\\n---\\n\\n### How will you do it by hand?\\n\\nCases:\\n\\nAll positive\\n\\n```python\\nInput: nums = [1,2,3,4]\\nOutput: [24,12,8,6]\\n\\nWhat will the answer array look like\\nanswer = [2*3*4, 1*3*4 , 1*2*4 ,1*2*3]\\n\\nSo will take the product of all values accept of the index \\nwe are on(for index 0 we didn\\'t take the value of 1)Input: nums = [-1,1,0,-3,3]\\nOutput: [0,0,9,0,0]\\n```\\n\\nnegative\\n\\n```python\\n\\nInput: nums = [-1,1,0,-3,3]\\nOutput: [0,0,9,0,0]\\n\\nWe will do the same[1*0*3*3,....-1*1*0*-3]\\n\\nWe know once we have a zero in the array all elements \\nare going to be zero except the index where zero is. \\nAnd if we have 2 negatives the product will be positive/\\n```\\n\\n## Solution\\n\\n---\\n\\n### Explanation\\n\\n```python\\nnums = [1,2,3,4]\\nanswer = [2*3*4, 1*3*4 , 1*2*4 ,1*2*3]\\n```\\n\\nSince we have the answer like this what insights you can derive about the answer.\\n\\n```python\\nAT index 2 of the answer [1*2*4] \\nCan be decomposed into (1*2) * (4)\\n```\\n\\nWe are taking the product of values to the left side of the index as well as the right side.\\n\\nWhat if we had an array that on each index had the product of all its values on the right and the other all the values on the left.\\n\\n```python\\nnums = [1,2,3,4]\\nleftProduct = [1,1,2,6]\\nrightProduct = [24,12,4,1]\\nleftProduct[i] * rightProduct[i] = answer[i]  \\n```\\n\\nIn code\\n\\n```python\\nleftProduct = [None] * len(nums)\\n#leftProduct = [1,1,2,6] \\n#left Product \\nproductSoFar = 1\\nfor index in range(len(nums)):\\n    leftProduct[index] = productSoFar\\n    productSoFar *= nums[index]\\n```\\n\\nSame for right but in reverse \\n\\n```python\\n#right Product = [24,12,4,1]\\nproductSoFar = 1\\nfor index in range((len(nums))-1,-1,-1):\\n    rightProduct[index] = productSoFar\\n    productSoFar *= nums[index]\\n```\\n\\nnow we take the product\\n\\n```python\\nanswer = [None] * len(nums)\\n  #total Product\\n  for i in range(len(nums)):\\n      answer[i] = leftProduct[i] * rightProduct[i]\\n      \\n  return answer\\n```\\n\\n### Code\\n\\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        \\n        \\n       \\n        \\n    #left Product    \\n    #O(N) Space\\n    #O(N) Time\\n    \\n        leftProduct = [None] * len(nums)\\n        \\n        productSoFar = 1\\n        for index in range(len(nums)):\\n            leftProduct[index] = productSoFar\\n            productSoFar *= nums[index]\\n        \\n    #right Product\\n    #O(N) Space\\n    #O(N) Time\\n    \\n        rightProduct = [None] * len(nums)\\n        \\n        productSoFar = 1\\n        for index in range((len(nums))-1,-1,-1):\\n            rightProduct[index] = productSoFar\\n            productSoFar *= nums[index]\\n        \\n    #total Product\\n    #O(N) Space\\n    #O(N) Time\\n        \\n        answer = [None] * len(nums)\\n        \\n        for i in range(len(nums)):\\n            answer[i] = leftProduct[i] * rightProduct[i]\\n            \\n        return answer\\n```\\n\\n### Time Complexity\\n\\n> Time \\u23F0\\xA0O(3N) Space \\uD83D\\uDCBE\\xA0O(3N)\\n> \\n\\nWe are using a lot of space instead of doing the product in separate arrays can we do it in one and return that array.\\n\\nSure can\\n\\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        \\n    #O(N) Space\\n        answer = [None] * len(nums)\\n        \\n        \\n    #leftProduct\\n    #0(N) time\\n\\n        productSofar = 1\\n        for index in range(len(nums)):\\n            answer[index] = productSofar\\n            productSofar *= nums[index]\\n    \\n    #rightProduct * leftProduct = answer    \\n    #0(N) time\\n        \\n        productSofar = 1\\n        for index in range((len(nums)-1),-1,-1):\\n            answer[index] *= productSofar\\n            productSofar *= nums[index]\\n            \\n            \\n        return answer\\n```\\n\\n> Time \\u23F0\\xA0O(2N) Space \\uD83D\\uDCBE\\xA0O(N)\\n> \\n\\nWe did it we saved some time complexity and saved space.\\n\\n## Links\\n\\n---\\n\\n### [PythonTutor(Visualized)](https://pythontutor.com/render.html#code=class%20Solution%3A%0A%20%20%20%20def%20productExceptSelf%28self,nums%29%3A%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%23O%28N%29%20Space%0A%20%20%20%20%20%20%20%20answer%20%3D%20%5BNone%5D%20*%20len%28nums%29%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%23leftProduct%0A%20%20%20%20%230%28N%29%20time%0A%0A%20%20%20%20%20%20%20%20productSofar%20%3D%201%0A%20%20%20%20%20%20%20%20for%20index%20in%20range%28len%28nums%29%29%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20answer%5Bindex%5D%20%3D%20productSofar%0A%20%20%20%20%20%20%20%20%20%20%20%20productSofar%20*%3D%20nums%5Bindex%5D%0A%20%20%20%20%0A%20%20%20%20%23rightProduct%20*%20leftProduct%20%3D%20answer%20%20%20%20%0A%20%20%20%20%230%28N%29%20time%0A%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20productSofar%20%3D%201%0A%20%20%20%20%20%20%20%20for%20index%20in%20range%28%28len%28nums%29-1%29,-1,-1%29%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20answer%5Bindex%5D%20*%3D%20productSofar%0A%20%20%20%20%20%20%20%20%20%20%20%20productSofar%20*%3D%20nums%5Bindex%5D%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20return%20answer%0A%0AS%20%3D%20Solution%28%29%0AS.productExceptSelf%28%5B1,2,3,4%5D%29&cumulative=false&curInstr=35&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false)\\n\\n### [Blind 75 Beginner-Friendly Solutions](https://leetcode.com/discuss/general-discussion/2210574/Blind-75-with-solutions.)\\n\\n- A list in progress for solutions from the blind 75, a list of the most asked interview questions.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nInput: nums = [1,2,3,4]\\nOutput: [24,12,8,6]\\n\\nWhat will the answer array look like\\nanswer = [2*3*4, 1*3*4 , 1*2*4 ,1*2*3]\\n\\nSo will take the product of all values accept of the index \\nwe are on(for index 0 we didn\\'t take the value of 1)Input: nums = [-1,1,0,-3,3]\\nOutput: [0,0,9,0,0]\\n```\n```python\\n\\nInput: nums = [-1,1,0,-3,3]\\nOutput: [0,0,9,0,0]\\n\\nWe will do the same[1*0*3*3,....-1*1*0*-3]\\n\\nWe know once we have a zero in the array all elements \\nare going to be zero except the index where zero is. \\nAnd if we have 2 negatives the product will be positive/\\n```\n```python\\nnums = [1,2,3,4]\\nanswer = [2*3*4, 1*3*4 , 1*2*4 ,1*2*3]\\n```\n```python\\nAT index 2 of the answer [1*2*4] \\nCan be decomposed into (1*2) * (4)\\n```\n```python\\nnums = [1,2,3,4]\\nleftProduct = [1,1,2,6]\\nrightProduct = [24,12,4,1]\\nleftProduct[i] * rightProduct[i] = answer[i]  \\n```\n```python\\nleftProduct = [None] * len(nums)\\n#leftProduct = [1,1,2,6] \\n#left Product \\nproductSoFar = 1\\nfor index in range(len(nums)):\\n    leftProduct[index] = productSoFar\\n    productSoFar *= nums[index]\\n```\n```python\\n#right Product = [24,12,4,1]\\nproductSoFar = 1\\nfor index in range((len(nums))-1,-1,-1):\\n    rightProduct[index] = productSoFar\\n    productSoFar *= nums[index]\\n```\n```python\\nanswer = [None] * len(nums)\\n  #total Product\\n  for i in range(len(nums)):\\n      answer[i] = leftProduct[i] * rightProduct[i]\\n      \\n  return answer\\n```\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        \\n        \\n       \\n        \\n    #left Product    \\n    #O(N) Space\\n    #O(N) Time\\n    \\n        leftProduct = [None] * len(nums)\\n        \\n        productSoFar = 1\\n        for index in range(len(nums)):\\n            leftProduct[index] = productSoFar\\n            productSoFar *= nums[index]\\n        \\n    #right Product\\n    #O(N) Space\\n    #O(N) Time\\n    \\n        rightProduct = [None] * len(nums)\\n        \\n        productSoFar = 1\\n        for index in range((len(nums))-1,-1,-1):\\n            rightProduct[index] = productSoFar\\n            productSoFar *= nums[index]\\n        \\n    #total Product\\n    #O(N) Space\\n    #O(N) Time\\n        \\n        answer = [None] * len(nums)\\n        \\n        for i in range(len(nums)):\\n            answer[i] = leftProduct[i] * rightProduct[i]\\n            \\n        return answer\\n```\n```python\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        \\n    #O(N) Space\\n        answer = [None] * len(nums)\\n        \\n        \\n    #leftProduct\\n    #0(N) time\\n\\n        productSofar = 1\\n        for index in range(len(nums)):\\n            answer[index] = productSofar\\n            productSofar *= nums[index]\\n    \\n    #rightProduct * leftProduct = answer    \\n    #0(N) time\\n        \\n        productSofar = 1\\n        for index in range((len(nums)-1),-1,-1):\\n            answer[index] *= productSofar\\n            productSofar *= nums[index]\\n            \\n            \\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2095277,
                "title": "space-optimal-c-o-n-tc",
                "content": "```\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans;\\n        int n=nums.size();\\n        if(n<2)\\n            return ans\\n            ;\\n        int prod=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            prod*=nums[i];\\n            ans.push_back(prod);\\n        }\\n        prod=1;\\n        for(int i=n-1;i>0;i--)\\n        {\\n            ans[i]=ans[i-1]*prod;\\n            prod*=nums[i];\\n        }\\n        ans[0]=prod;\\n        return ans;\\n            \\n    }",
                "solutionTags": [],
                "code": "```\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans;\\n        int n=nums.size();\\n        if(n<2)\\n            return ans\\n            ;\\n        int prod=1;\\n        for(int i=0;i<n;i++)\\n        {\\n            prod*=nums[i];\\n            ans.push_back(prod);\\n        }\\n        prod=1;\\n        for(int i=n-1;i>0;i--)\\n        {\\n            ans[i]=ans[i-1]*prod;\\n            prod*=nums[i];\\n        }\\n        ans[0]=prod;\\n        return ans;\\n            \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2035839,
                "title": "two-methods-using-prefix-in-python-clearly-explained-to-details",
                "content": "Great question which is a **transformation** of **prefix product**!\\nThis time we just need to generate **prefix list of both sides**!\\n\\n**Method 1:**\\n\\n**Time:** O(n)\\n**Space:** O(n)\\n\\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        \\n        length = len(nums)\\n        left, right, res = [0] * length, [0] * length, [0] * length\\n        \\n        # Construct the left prefix array\\n        left[0] = 1\\n        for i in range(1, length):\\n            left[i] = nums[i - 1] * left[i - 1]\\n        \\n        # Construct the right prefix array\\n        right[length - 1] = 1\\n        for i in range(length - 2, -1, -1):\\n            right[i] = nums[i + 1] * right[i + 1]\\n        \\n        # Construct the answer array\\n        for i in range(length):\\n            res[i] = left[i] * right[i]\\n        \\n        return res\\n```\\n\\n**Method 2:**\\nDeal with the **follow up**: Solve the problem in O(1) extra space complexity.\\n\\nWe will add right prefix multiply product of each number directly onto the resulting list.\\n\\n**Time:** O(n)\\n**Space:** O(1), except the output\\n\\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        \\n        length = len(nums)\\n        res = [0] * length\\n        \\n        res[0] = 1\\n        for i in range(1, length):\\n\\n            res[i] = nums[i - 1] * res[i - 1]\\n        \\n        right = 1\\n        for i in reversed(range(length)):\\n            \\n            res[i] = res[i] * right\\n            right *= nums[i]\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        \\n        length = len(nums)\\n        left, right, res = [0] * length, [0] * length, [0] * length\\n        \\n        # Construct the left prefix array\\n        left[0] = 1\\n        for i in range(1, length):\\n            left[i] = nums[i - 1] * left[i - 1]\\n        \\n        # Construct the right prefix array\\n        right[length - 1] = 1\\n        for i in range(length - 2, -1, -1):\\n            right[i] = nums[i + 1] * right[i + 1]\\n        \\n        # Construct the answer array\\n        for i in range(length):\\n            res[i] = left[i] * right[i]\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        \\n        length = len(nums)\\n        res = [0] * length\\n        \\n        res[0] = 1\\n        for i in range(1, length):\\n\\n            res[i] = nums[i - 1] * res[i - 1]\\n        \\n        right = 1\\n        for i in reversed(range(length)):\\n            \\n            res[i] = res[i] * right\\n            right *= nums[i]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008283,
                "title": "explained-simple-solution",
                "content": "```\\n/*\\n  The idea is to initialize an array of the size nums.length\\n  and filled with 1s. After that, go over the array from the start\\n  until the end and set each element as the product of the previous elements.\\n  \\n  Then, iterate one more time from the end until the start and update each element\\n  of the resulted array with the product of the elements which go after it.\\n*/\\nfunction productExceptSelf(nums: number[]): number[] {\\n  // No division operator\\n  // Time complexity: O(n)\\n  // Space complexity: O(1)\\n    \\n  let product = 1;\\n  let result = new Array(nums.length);\\n    \\n  // Modify from start to end\\n  for (let i = 0; i < nums.length; i += 1) {\\n    result[i] = product;\\n    product *= nums[i];\\n  }\\n    \\n  // Modify from end to start\\n  product = 1;\\n  for (let i = nums.length - 1; i >= 0; i -= 1) {\\n    result[i] *= product;\\n    product *= nums[i];\\n  }\\n    \\n  return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array"
                ],
                "code": "```\\n/*\\n  The idea is to initialize an array of the size nums.length\\n  and filled with 1s. After that, go over the array from the start\\n  until the end and set each element as the product of the previous elements.\\n  \\n  Then, iterate one more time from the end until the start and update each element\\n  of the resulted array with the product of the elements which go after it.\\n*/\\nfunction productExceptSelf(nums: number[]): number[] {\\n  // No division operator\\n  // Time complexity: O(n)\\n  // Space complexity: O(1)\\n    \\n  let product = 1;\\n  let result = new Array(nums.length);\\n    \\n  // Modify from start to end\\n  for (let i = 0; i < nums.length; i += 1) {\\n    result[i] = product;\\n    product *= nums[i];\\n  }\\n    \\n  // Modify from end to start\\n  product = 1;\\n  for (let i = nums.length - 1; i >= 0; i -= 1) {\\n    result[i] *= product;\\n    product *= nums[i];\\n  }\\n    \\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1978301,
                "title": "c-tricky-o-n-tc-and-o-1-sc-solution",
                "content": "Hey all..\\nI have solved this in cpp using left product and right product vectors method.\\nI have commented in the code so that it can be useful..\\nIf you have any doubts be free to ask..\\nand please upvote if you understood or found it useful :)\\n\\nThank you..\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n=nums.size();\\n\\t\\t//Vector to store left side product of an element.\\n        vector<int> lp(n,0);\\n\\t\\t//Nothing is there in leftside of first element.\\n        lp[0]=1;\\n        \\n\\t\\t//Traversing to get the all left products\\n        for(int i=1;i<n;i++){\\n            lp[i]=lp[i-1]*nums[i-1];\\n        }\\n        \\n\\t\\t//Traversing using a variable to reduce using another vector.\\n        int r=1;\\n        for(int i=n-1;i>=0;i--){\\n            lp[i]=lp[i]*r;\\n            r*=nums[i];\\n        }\\n        \\n        return lp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n=nums.size();\\n\\t\\t//Vector to store left side product of an element.\\n        vector<int> lp(n,0);\\n\\t\\t//Nothing is there in leftside of first element.\\n        lp[0]=1;\\n        \\n\\t\\t//Traversing to get the all left products\\n        for(int i=1;i<n;i++){\\n            lp[i]=lp[i-1]*nums[i-1];\\n        }\\n        \\n\\t\\t//Traversing using a variable to reduce using another vector.\\n        int r=1;\\n        for(int i=n-1;i>=0;i--){\\n            lp[i]=lp[i]*r;\\n            r*=nums[i];\\n        }\\n        \\n        return lp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827443,
                "title": "python3-time-o-n-space-o-1-simplest-approach",
                "content": "Simplest approach in python with low complexity.\\n\\n```\\ndef productExceptSelf(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        output = [0]*n\\n        left = 1\\n        right = 1\\n\\t\\t\\n\\t\\t#Left array\\n        for i in range(n):\\n            output[i] = left\\n            left *= nums[i]\\n\\t\\t\\t\\n\\t\\t# Right array\\n        for i in range(n-1, -1, -1):\\n            output[i] *= right\\n            right *= nums[i]\\n\\t\\t\\n\\t\\t#Used only one output array modified inside the array O(1) space.\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\ndef productExceptSelf(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        output = [0]*n\\n        left = 1\\n        right = 1\\n\\t\\t\\n\\t\\t#Left array\\n        for i in range(n):\\n            output[i] = left\\n            left *= nums[i]\\n\\t\\t\\t\\n\\t\\t# Right array\\n        for i in range(n-1, -1, -1):\\n            output[i] *= right\\n            right *= nums[i]\\n\\t\\t\\n\\t\\t#Used only one output array modified inside the array O(1) space.\\n        return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1690601,
                "title": "simple-java-solution-without-extra-space",
                "content": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        \\n        int length = nums.length;\\n        \\n        int ans[] = new int[length];\\n        \\n        ans[0] = 1;\\n        for(int i = 1; i < length; i++) {\\n            ans[i] = nums[i-1] * ans[i-1];\\n        }\\n        \\n        int R = 1;\\n        for(int i=length-1; i>=0; i--) {\\n            ans[i] *= R;\\n            R *= nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        \\n        int length = nums.length;\\n        \\n        int ans[] = new int[length];\\n        \\n        ans[0] = 1;\\n        for(int i = 1; i < length; i++) {\\n            ans[i] = nums[i-1] * ans[i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1617643,
                "title": "tc-o-n-sc-o-1-prefix-and-postfix-product-solution",
                "content": "Intution: At any index i in nums[i] the value is product of elements to its left times the product to its right:\\n\\n[1,2,3,4]\\nPrefix: [1,1,2,6]\\nPostfix: [24,12,4,1]\\n\\n`ouputs: [ 1*24, 1*12, 2*4, 6*1]`\\n\\nTo optimize the space complexity further instead of creatng two arrays we create the initial res array with prefix and multiple it with the postfix array values \\n```\\n\\'\\'\\'\\nTC: O(n)\\nSC: O(1)\\n\\'\\'\\'\\n\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        rp=1\\n        res=[1]\\n        for i in range(1,len(nums)):\\n            rp=rp*nums[i-1]\\n            res.append(rp)\\n        \\n        rp=1\\n        for i in range(len(nums)-2,-1,-1):\\n            rp=rp*nums[i+1]\\n            res[i]=res[i]*rp\\n        return res\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\n\\'\\'\\'\\nTC: O(n)\\nSC: O(1)\\n\\'\\'\\'\\n\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        rp=1\\n        res=[1]\\n        for i in range(1,len(nums)):\\n            rp=rp*nums[i-1]\\n            res.append(rp)\\n        \\n        rp=1\\n        for i in range(len(nums)-2,-1,-1):\\n            rp=rp*nums[i+1]\\n            res[i]=res[i]*rp\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597963,
                "title": "java-100-fast-o-1-space",
                "content": "**Honestly this is a easy problem disguised as medium**\\nIt Seems asusual I didnt read the question properly. they clearly say **not to use divide**\\n**Therefore below code is illegal.**\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int product = 1;\\n        int zeroCount = 0;\\n        for(int i:nums){\\n            if(i==0){\\n                zeroCount++;\\n            }else{\\n                product*=i;\\n            }\\n        }\\n        if(zeroCount>=2){\\n            return new int[nums.length];\\n        }else{\\n            int[] answer = new int[nums.length];\\n            for(int i = 0;i<nums.length;i++){\\n                if(zeroCount!=0){\\n                    answer[i] = nums[i]==0 ? product : 0;\\n                }else{\\n                    answer[i] = product/nums[i];   \\n                } \\n            }\\n            return answer;\\n        } \\n    }\\n}\\n```\\n# Working/Legal Code\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] answers = new int[n];\\n        answers[0]=1;\\n        for(int i=1;i<n;i++){\\n            answers[i] = answers[i-1]*nums[i-1];\\n        }\\n        int last = nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            answers[i] = answers[i]*last;\\n            last *= nums[i];\\n        }\\n        return answers;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int product = 1;\\n        int zeroCount = 0;\\n        for(int i:nums){\\n            if(i==0){\\n                zeroCount++;\\n            }else{\\n                product*=i;\\n            }\\n        }\\n        if(zeroCount>=2){\\n            return new int[nums.length];\\n        }else{\\n            int[] answer = new int[nums.length];\\n            for(int i = 0;i<nums.length;i++){\\n                if(zeroCount!=0){\\n                    answer[i] = nums[i]==0 ? product : 0;\\n                }else{\\n                    answer[i] = product/nums[i];   \\n                } \\n            }\\n            return answer;\\n        } \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] answers = new int[n];\\n        answers[0]=1;\\n        for(int i=1;i<n;i++){\\n            answers[i] = answers[i-1]*nums[i-1];\\n        }\\n        int last = nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            answers[i] = answers[i]*last;\\n            last *= nums[i];\\n        }\\n        return answers;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597916,
                "title": "python-o-n-without-extra-space-explanation",
                "content": "We need to multiply all numbers except the current one, e. g: \\nresult<sub>i</sub> = a<sub>1</sub> * a<sub>2</sub> ... * a<sub>i-1</sub> * a<sub>i+1</sub> * ... * a<sub>n</sub>\\nWe could divide that into two parts:\\nresult<sub>i</sub> = l<sub>i</sub> * r<sub>i</sub>\\nl<sub>i</sub> = a<sub>1</sub> * a<sub>2</sub> ... * a<sub>i-1</sub>\\nr<sub>i</sub> = a<sub>i+1</sub> * ... * a<sub>n</sub>\\nl<sub>0</sub> = r<sub>n+1</sub> = 1\\n\\nWe could initialize our result with ones and then do two traversal - forward and backward. \\nWhile traversing we could accumulate product of visited items and multiply result at current index by accumulated value from previous step, initializing this value with ``1``. Thus while traversing forward we would have: \\n```\\nresult[i] *= accumulated_product\\naccumulated_product *= nums[i]\\n```\\nBefore traversing setting ``accumulated_product`` to ``1``. \\nThus going both directions each result item would get multiplied by all previous values from the forward traversal and by all following values from backward traversal, thus would end up having all values except the value at current index multiplied.\\n\\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        result = [1] * n\\n        prev = 1\\n        for i in range(n):\\n            result[i] *= prev\\n            prev *= nums[i]\\n        prev = 1\\n        for i in range(n-1, -1, -1):\\n            result[i] *= prev\\n            prev *= nums[i]\\n        return result\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nresult[i] *= accumulated_product\\naccumulated_product *= nums[i]\\n```\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        result = [1] * n\\n        prev = 1\\n        for i in range(n):\\n            result[i] *= prev\\n            prev *= nums[i]\\n        prev = 1\\n        for i in range(n-1, -1, -1):\\n            result[i] *= prev\\n            prev *= nums[i]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1558354,
                "title": "java-solution-easy-and-explained",
                "content": "# JAVA SOLUTION @DeepakKumar\\n# In Case of Any Doubt Feel Free to ASK....\\n\\n ```\\n /*\\n        CODE Explanation:\\n        let\\n              index -->  0   1   2   3   4\\n              nums -->  [1,  2,  3,  4,  5]\\n\\n   initially output_arr is:\\n             output_arr --> [0, 0, 0, 0 , 0]\\n          Step 1: output_arr[0] = 1 --> [1, 0, 0, 0, 0]\\n       1st Pass:  i = 1\\n                  output[1] = output[0] * nums[0]\\n                  output[1] = 1 * 1  --> [1, 1, 0, 0, 0]\\n       2nd Pass:  i = 2\\n                 output[2] = output[1] * nums[1]\\n                 output[1] = 1 * 2  --> [1, 1, 2, 0, 0]\\n       3rd Pass:  i = 3\\n                 output[3] = output[2] * nums[2]\\n                 output[1] = 2 * 3  --> [1, 1, 2, 6, 0]\\n       4th Pass:  i = 4           4 < 5  TRUE\\n                 output[4] = output[3] * nums[3]\\n                 output[4] = 6 * 4  --> [1, 1, 2, 6, 24]    --> Here NOTE 24 is the Product for nums[4] except itself\\n\\n    Now\\n          let rightProduct = 1\\n        1st Pass:  i = 4              4 >= 0 TRUE\\n                  output[4] = output[4] * 1                   As, output[i] = output[i] * rightProduct\\n                  output[4] = 24 * 1  --> [1, 1, 2, 6, 24]\\n                  rightProduct = 1 * 5 = 5                    As, rightProduct = rightProduct * nums[i]\\n       2st Pass:  i = 3               3 >= 0 TRUE\\n                  output[3] = output[3] * 5                   As, output[i] = output[i] * rightProduct\\n                  output[3] = 6 * 5  --> [1, 1, 2, 30, 24]\\n                  rightProduct = 5 * 4 = 20                    As, rightProduct = rightProduct * nums[i]\\n       3rd Pass:  i = 2                2 >= 0 TRUE\\n                  output[2] = output[2] * 20                   As, output[i] = output[i] * rightProduct\\n                  output[2] = 2 * 20  --> [1, 1, 40, 30, 24]\\n                  rightProduct = 20 * 3 = 60                    As, rightProduct = rightProduct * nums[i]\\n       4th Pass:  i = 1                1 >= 0 TRUE\\n                  output[1] = output[1] * 60                   As, output[i] = output[i] * rightProduct\\n                  output[1] = 1 * 60  --> [1, 60, 40, 30, 24]\\n                  rightProduct = 60 * 2 = 120                    As, rightProduct = rightProduct * nums[i]\\n         5th Pass:  i = 0                0 >= 0 TRUE\\n                  output[0] = output[1] * 120                   As, output[i] = output[i] * rightProduct\\n                  output[0] = 1 * 120  --> [120, 60, 40, 30, 24]\\n                  rightProduct = 120 * 1 = 120                    As, rightProduct = rightProduct * nums[i]\\n\\n      So,\\n         Resultant Output Array is -->  [120, 60, 40, 30, 24]\\n         */\\n```\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int [] output_arr = new int[nums.length];\\n\\n        output_arr[0] = 1;\\n        for(int i=1; i<nums.length; i++){\\n            output_arr[i] = output_arr[i-1] * nums[i-1];\\n        }\\n\\n        int rightProduct = 1;\\n        for(int i= nums.length-1; i>=0; i--){\\n            output_arr[i] = output_arr[i]*rightProduct;\\n            rightProduct = rightProduct * nums[i];\\n        }\\n        return  output_arr;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n /*\\n        CODE Explanation:\\n        let\\n              index -->  0   1   2   3   4\\n              nums -->  [1,  2,  3,  4,  5]\\n\\n   initially output_arr is:\\n             output_arr --> [0, 0, 0, 0 , 0]\\n          Step 1: output_arr[0] = 1 --> [1, 0, 0, 0, 0]\\n       1st Pass:  i = 1\\n                  output[1] = output[0] * nums[0]\\n                  output[1] = 1 * 1  --> [1, 1, 0, 0, 0]\\n       2nd Pass:  i = 2\\n                 output[2] = output[1] * nums[1]\\n                 output[1] = 1 * 2  --> [1, 1, 2, 0, 0]\\n       3rd Pass:  i = 3\\n                 output[3] = output[2] * nums[2]\\n                 output[1] = 2 * 3  --> [1, 1, 2, 6, 0]\\n       4th Pass:  i = 4           4 < 5  TRUE\\n                 output[4] = output[3] * nums[3]\\n                 output[4] = 6 * 4  --> [1, 1, 2, 6, 24]    --> Here NOTE 24 is the Product for nums[4] except itself\\n\\n    Now\\n          let rightProduct = 1\\n        1st Pass:  i = 4              4 >= 0 TRUE\\n                  output[4] = output[4] * 1                   As, output[i] = output[i] * rightProduct\\n                  output[4] = 24 * 1  --> [1, 1, 2, 6, 24]\\n                  rightProduct = 1 * 5 = 5                    As, rightProduct = rightProduct * nums[i]\\n       2st Pass:  i = 3               3 >= 0 TRUE\\n                  output[3] = output[3] * 5                   As, output[i] = output[i] * rightProduct\\n                  output[3] = 6 * 5  --> [1, 1, 2, 30, 24]\\n                  rightProduct = 5 * 4 = 20                    As, rightProduct = rightProduct * nums[i]\\n       3rd Pass:  i = 2                2 >= 0 TRUE\\n                  output[2] = output[2] * 20                   As, output[i] = output[i] * rightProduct\\n                  output[2] = 2 * 20  --> [1, 1, 40, 30, 24]\\n                  rightProduct = 20 * 3 = 60                    As, rightProduct = rightProduct * nums[i]\\n       4th Pass:  i = 1                1 >= 0 TRUE\\n                  output[1] = output[1] * 60                   As, output[i] = output[i] * rightProduct\\n                  output[1] = 1 * 60  --> [1, 60, 40, 30, 24]\\n                  rightProduct = 60 * 2 = 120                    As, rightProduct = rightProduct * nums[i]\\n         5th Pass:  i = 0                0 >= 0 TRUE\\n                  output[0] = output[1] * 120                   As, output[i] = output[i] * rightProduct\\n                  output[0] = 1 * 120  --> [120, 60, 40, 30, 24]\\n                  rightProduct = 120 * 1 = 120                    As, rightProduct = rightProduct * nums[i]\\n\\n      So,\\n         Resultant Output Array is -->  [120, 60, 40, 30, 24]\\n         */\\n```\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int [] output_arr = new int[nums.length];\\n\\n        output_arr[0] = 1;\\n        for(int i=1; i<nums.length; i++){\\n            output_arr[i] = output_arr[i-1] * nums[i-1];\\n        }\\n\\n        int rightProduct = 1;\\n        for(int i= nums.length-1; i>=0; i--){\\n            output_arr[i] = output_arr[i]*rightProduct;\\n            rightProduct = rightProduct * nums[i];\\n        }\\n        return  output_arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420908,
                "title": "simple-java-solution-100-faster-with-and-without-extra-space",
                "content": "```\\n//Using Extra Space \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        int[] output = new int[n];\\n        \\n        left[0] = 1;\\n        right[n-1] = 1;\\n        \\n        //Calculating left value\\n        for(int i=1;i<n;i++){\\n            left[i] = nums[i-1]*left[i-1];\\n        }\\n        \\n        //Calculating the right value\\n        for(int i=n-2;i>=0;i--){\\n            right[i] = nums[i+1]*right[i+1];\\n        }\\n        \\n        //Calculating output\\n        for(int i=0;i<n;i++){\\n            output[i] = left[i]*right[i];\\n        }\\n        return output;\\n    }\\n}\\n\\n//Without using Extra Space\\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        \\n        int[] output = new int[n];\\n        \\n        output[0] = 1;\\n        //Storing left value in output itslef\\n        for(int i=1;i<n;i++){\\n            output[i] = nums[i-1] * output[i-1];\\n        }\\n        \\n        //Calculating right value in output\\n        int r = 1;\\n        for(int i=n-1;i>=0;i--){\\n            output[i] = output[i]*r;\\n            r=r*nums[i];\\n        }\\n        \\n        return output;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n//Using Extra Space \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        int[] output = new int[n];\\n        \\n        left[0] = 1;\\n        right[n-1] = 1;\\n        \\n        //Calculating left value\\n        for(int i=1;i<n;i++){\\n            left[i] = nums[i-1]*left[i-1];\\n        }\\n        \\n        //Calculating the right value\\n        for(int i=n-2;i>=0;i--){\\n            right[i] = nums[i+1]*right[i+1];\\n        }\\n        \\n        //Calculating output\\n        for(int i=0;i<n;i++){\\n            output[i] = left[i]*right[i];\\n        }\\n        return output;\\n    }\\n}\\n\\n//Without using Extra Space\\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int n = nums.length;\\n        \\n        int[] output = new int[n];\\n        \\n        output[0] = 1;\\n        //Storing left value in output itslef\\n        for(int i=1;i<n;i++){\\n            output[i] = nums[i-1] * output[i-1];\\n        }\\n        \\n        //Calculating right value in output\\n        int r = 1;\\n        for(int i=n-1;i>=0;i--){\\n            output[i] = output[i]*r;\\n            r=r*nums[i];\\n        }\\n        \\n        return output;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1377106,
                "title": "o-n-time-no-division-o-1-space-minimal-code-explained",
                "content": "Approach: simple approach: have product in left array side of current index and right array side of current index and multiply both.( prefix product and postfix product).\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> v(nums.size(),1);\\n        // just store prefix products upto current location  excuding current index\\n        for(int i=1;i<nums.size();i++){\\n            v[i]=v[i-1]*nums[i-1];\\n        }\\n        int p=1; // product variable to keep track of postfix product starting from (current+1) index to end\\n        for(int j=nums.size()-2;j>=0;j--){\\n            p=nums[j+1]*p;\\n            v[j]*=p;   // multify with postfix product \\n        }\\n        return v;\\n    }\\n};\\n```\\nHappy coding !!\\nDo upvote if u like :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> v(nums.size(),1);\\n        // just store prefix products upto current location  excuding current index\\n        for(int i=1;i<nums.size();i++){\\n            v[i]=v[i-1]*nums[i-1];\\n        }\\n        int p=1; // product variable to keep track of postfix product starting from (current+1) index to end\\n        for(int j=nums.size()-2;j>=0;j--){\\n            p=nums[j+1]*p;\\n            v[j]*=p;   // multify with postfix product \\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159987,
                "title": "python-o-n-time-o-1-space-explained",
                "content": "I was able to find the optimal solution myself and here was my thought process. Initially I had a nested loop that would multiply each number by every other number to find the result, but I quickly realised that this was O(n^2). I then started thinking about how I could reduce some of the operations I was doing and realised that I could compute the cumulative product as I went without multiply by the current element.\\n\\nWith the example input: `[2, 3, 4, 5]`\\nThe cumulative array creates `[1, 2, 6, 24]` so you can see that for the 4th element we only had to 6x4 instead of 2x3x4. I then realised I could do the same in reverse to create `[60, 20, 5, 1]`.\\nTaking the element-wise product of these arrays creates the result array.\\n\\nAs we make two passes over the data this is O(2n) = O(n).\\n\\n```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        # Create an array that will return        \\n        ret = [1] * len(nums)\\n        # Store the cumulative product\\n        cumprod = 1\\n        \\n        # Iterate over nums\\n        for i in range(len(nums)):\\n            ret[i] = cumprod\\n            cumprod = nums[i] * cumprod\\n            \\n        cumprod = 1\\n            \\n        for i in range(len(nums) -1, -1, -1):\\n            ret[i] *= cumprod\\n            cumprod = nums[i] * cumprod\\n            \\n        return ret\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        # Create an array that will return        \\n        ret = [1] * len(nums)\\n        # Store the cumulative product\\n        cumprod = 1\\n        \\n        # Iterate over nums\\n        for i in range(len(nums)):\\n            ret[i] = cumprod\\n            cumprod = nums[i] * cumprod\\n            \\n        cumprod = 1\\n            \\n        for i in range(len(nums) -1, -1, -1):\\n            ret[i] *= cumprod\\n            cumprod = nums[i] * cumprod\\n            \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 955158,
                "title": "c-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        ans[0] = 1;\\n        \\n        for(int i = 1; i < nums.size(); i++) {\\n            ans[i] = ans[i-1]*nums[i-1];\\n        }\\n        \\n        int R = 1;\\n        for(int i = nums.size()-1; i >= 0; i--) {\\n            ans[i] = ans[i]*R;\\n            R *= nums[i];\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        ans[0] = 1;\\n        \\n        for(int i = 1; i < nums.size(); i++) {\\n            ans[i] = ans[i-1]*nums[i-1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 681718,
                "title": "runtime-1-ms-faster-than-100-00-of-java-online-submissions",
                "content": "Runtime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 48.1 MB, less than 46.56% of Java online submissions for Product of Array Except Self.\\n```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] res=new int[nums.length];\\n        int m=1;\\n        for(int i=0;i<res.length;i++){\\n            res[i]=m;\\n            m=m*nums[i];\\n        }\\n        m=1;\\n        for(int i=res.length-1;i>=0;i--){\\n            res[i]=res[i]*m;\\n            m*=nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] res=new int[nums.length];\\n        int m=1;\\n        for(int i=0;i<res.length;i++){\\n            res[i]=m;\\n            m=m*nums[i];\\n        }\\n        m=1;\\n        for(int i=res.length-1;i>=0;i--){\\n            res[i]=res[i]*m;\\n            m*=nums[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558985,
                "title": "c-o-n-solution-o-1-space-in-single-loop",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        \\n        int len = nums.size();\\n        int prod = 1, revProd = 1;\\n        vector <int> ans(len, 1);\\n        for(int i = 0; i < len; ++i)\\n        {\\n            ans[i] *= prod;\\n            ans[len-1-i] *= revProd;\\n            prod *= nums[i];\\n            revProd *= nums[len-1-i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        \\n        int len = nums.size();\\n        int prod = 1, revProd = 1;\\n        vector <int> ans(len, 1);\\n        for(int i = 0; i < len; ++i)\\n        {\\n            ans[i] *= prod;\\n            ans[len-1-i] *= revProd;\\n            prod *= nums[i];\\n            revProd *= nums[len-1-i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278821,
                "title": "golang",
                "content": "```\\nfunc productExceptSelf(nums []int) []int {\\n\\tres := make([]int, len(nums))\\n\\tfor i := 0; i < len(res); i++ {\\n\\t\\tres[i] = 1\\n\\t}\\n\\tleft := 1\\n\\tright := 1\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tj := len(nums) - 1 - i\\n\\t\\tres[j] = res[j] * right\\n\\t\\tright = right * nums[j]\\n\\t\\tres[i] = res[i] * left\\n\\t\\tleft = left * nums[i]\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc productExceptSelf(nums []int) []int {\\n\\tres := make([]int, len(nums))\\n\\tfor i := 0; i < len(res); i++ {\\n\\t\\tres[i] = 1\\n\\t}\\n\\tleft := 1\\n\\tright := 1\\n\\tfor i := 0; i < len(nums); i++ {\\n\\t\\tj := len(nums) - 1 - i\\n\\t\\tres[j] = res[j] * right\\n\\t\\tright = right * nums[j]\\n\\t\\tres[i] = res[i] * left\\n\\t\\tleft = left * nums[i]\\n\\t}\\n\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1782373,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 1700615,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 1569040,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 1574257,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 1932414,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 1565091,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 1800984,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 1575049,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 1571479,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 2023318,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 1782373,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 1700615,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 1569040,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 1574257,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 1932414,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 1565091,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 1800984,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 1575049,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 1571479,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 2023318,
                "content": [
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "TAKE HINT AND SOLVE BY YOURSELF:\n\nFor any nums[i], calculate its left product and calculate its right product, without including nums[i].\nThen multiply these left and right product, This will give product of array excluding nums[i].\n\nDo upvote, if you like :)"
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@alexlomm](/alexlomm) It\\'s O(2*n) which is O(n). "
                    },
                    {
                        "username": "lucaskoontz",
                        "content": "[@HS26](/HS26) According to the description, the output array does not count as extra space for space complexity analysis. So if you apply this hint, your solution should be O(1) space complexity"
                    },
                    {
                        "username": "yourMama",
                        "content": "but that would make it O(n^2), would it  not?"
                    },
                    {
                        "username": "buri_buri_zaimon",
                        "content": "[@minhphamduy](/minhphamduy)  can you explain the second dec. loop what is happening ...?"
                    },
                    {
                        "username": "NonnoPinto",
                        "content": "let\\'s say n=5 and i\\'m in nums[0]. With this idea, I need to check nums[1-5], thats already O(n) and i have done only one. This is the hint just to avoid division"
                    },
                    {
                        "username": "oops_moment",
                        "content": "[@dungtuanuet](/dungtuanuet) Hey hi, actually what he means is to pre-store , maintain two arrays one for the left and one for the right , and pre store the result."
                    },
                    {
                        "username": "HS26",
                        "content": "[@Vikas0693](/Vikas0693) But still gonna cost O(N) space. The thing is how to solve it in O(1) space?"
                    },
                    {
                        "username": "HS26",
                        "content": "[@dungtuanuet](/dungtuanuet) The complexity will be O(N) but it will cost O(N) space."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "[@lance2k](/lance2k)  No it only n : https://leetcode.com/problems/product-of-array-except-self/submissions/988226077\\n"
                    },
                    {
                        "username": "dungtuanuet",
                        "content": "So this solution gonna costs O(N^2) time complexity right?"
                    },
                    {
                        "username": "_solver",
                        "content": "I am facing this error\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v"
                    },
                    {
                        "username": "Vikas0693",
                        "content": "Hint to improve performance & space: you dont need to maintain both left and right product arrays, either of them is enough."
                    },
                    {
                        "username": "user0335jo",
                        "content": "code is being executed, but the time complexity is more .Is there any way to reduce time complexity?"
                    },
                    {
                        "username": "lance2k",
                        "content": "Isn\\'t it n * n-1 or n\\xB2? Since we\\'re going to iterate to nums list then iterate to the left and right of nums[i] to get the product?"
                    },
                    {
                        "username": "alexlomm",
                        "content": "This solution is not O(n), it\\'s O(n^2)"
                    },
                    {
                        "username": "Aatish_sharma",
                        "content": "did it thanks man "
                    },
                    {
                        "username": "gauravkashyap000",
                        "content": "Time limit increased \\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int[] result=new int[nums.length];\\n        int[] lsubarray={};\\n        int[] rsubarray={};\\n        int rprod,lprod=1;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            lsubarray=Arrays.copyOfRange(nums, 0, i);\\n            lprod=arraymultiplication(lsubarray);\\n            rsubarray=Arrays.copyOfRange(nums, i+1, nums.length);\\n            rprod=arraymultiplication(rsubarray);\\n            result[i]=lprod*rprod;\\n\\n               \\n        }\\n        return result;\\n    }\\n\\n   public int arraymultiplication(int[] a){\\n       int prod=1;\\n             for(int i=0;i<a.length;i++){\\n                prod=prod*a[i];\\n\\n        }\\n        return prod;\\n}\\n}"
                    },
                    {
                        "username": "khandaniyaal",
                        "content": "Very tricky and simple nice hint brother."
                    },
                    {
                        "username": "sav_vimal",
                        "content": "[@hggehlot777](/hggehlot777) it is o(n) it is working : )"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "[@hggehlot777](/hggehlot777) \n`To reduce time complexity, use space, this will pass O(n) time and beats 100%`\nThe idea is to maintain two arrays 'left' and 'right'.\nleft[i] will have the product from[0, i-1] and right[i] will have product from [i+1, n-1].\nFor maintaining left array, traverse from left to right \nFor maintaining right array, traverse from right to left\nThen update the 'answer' array with the product of left[i] * right[i]\n\nCODE FOR REFERENCE (JAVA):\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        //WITHOUT DIVISION\n        int n = nums.length;\n        int ans[] = new int[n];\n        int left[] = new int[n];\n        int right[] = new int[n];\n\n        int cur=1;\n        //Calculating product till i except nums[i] from left\n        for(int i = 0; i < n; i++){\n            left[i]=cur;\n            cur*=nums[i];\n        }    \n        //Calculating product from i+1 to n-1 (except nums[i]) \n        cur = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            right[i]=cur;\n            cur*=nums[i];\n        }\n        //Updating answer array\n        for(int i = 0; i<nums.length; i++)\n            ans[i] = left[i]*right[i];  \n\n        return ans;\n    }\n}"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "With this approch the time limit will exceed"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "This is hard..."
                    },
                    {
                        "username": "dbekel",
                        "content": "people are just throwing their code here, not one really explain what is the intuition or the idea behind their solution. \\nI don't see any choice than memorizing it."
                    },
                    {
                        "username": "viveksapra",
                        "content": "[@marksworn](/marksworn) try the second given testcase and you will get yourself proved wrong.\\n"
                    },
                    {
                        "username": "marksworn",
                        "content": "You just need to remember the identity:\\n`a/b = a*(b^-1)`\\nThe problem is not how to calculate the elements. The problem is how to avoid using the division operator."
                    },
                    {
                        "username": "SaikatDass",
                        "content": "https://leetcode.com/problems/product-of-array-except-self/solutions/3182074/super-easy-explained-java-solution-100-0ms-faster/\\ncheck this out, you maybe found it helpful"
                    },
                    {
                        "username": "Lordacus",
                        "content": "[@bah](/bah) What was the intuition behind, `it turns out we can find all prefixes and suffixes in O(n):`? I managed to do it but only with trial and error, but it feels wrong doing that"
                    },
                    {
                        "username": "bah",
                        "content": "here\\'s the intuition: let\\'s call the array of the solution `answer`.\\nthen `answer[i] = nums[0]*nums[1]*...*nums[i-1]*nums[i+1]*...*nums[n-1]`.\\nwe can split this product into 2 parts: prefix and suffix:\\n`prefix = num[0]*...*nums[i-1]`, `suffix = nums[i+1]*...*nums[n-1]`. therefore, `answer[i] = prefix * suffix`.\\nit turns out we can find all prefixes and suffixes in O(n):\\n`prefix[0] = nums[0], prefix[1] = prefix[0] * nums[1], ... prefix[n-1] = prefix[n-2] * nums[n-1]`.\\nsimilarly for all suffixes.\\nnow, all we have left to do, is construct the answer: `answer[i] = prefix[i-1] * suffix[i+1]`, for every i. done :)"
                    },
                    {
                        "username": "KyleOckerlund",
                        "content": "I\\'ll leave my hobbled code out of this. However, this is a fundamentally different approach from the given ones, and I figure it\\'s worth considering: Use the Fundamental Theorem of Arithmetic. \\n\\nThe theorem states that any number can be broken into primes. 10 becomes 2x5, 20 becomes 2x2x5, and so on. Further, we can represent every number purely by prime exponents, we need only set a, b, c, ... as desired: -1^a x 1^b x 2^c x 3^d x 5^e x 7^f x....  \\n\\nWe can put those in an array.\\n\\nSuppose we looked at [0, 1, 1, 3, 1, 1]. Using these values as exponents yields the number:  (-1^0) x (1^1) x (2^3) x (3^1) x (5^1)  = 120.\\n\\nThen, division is simply seeing what \"cancels\". So, to \\'divide\\', we need only subtract these exponent arrays. 120/ 2 = [0, 1, 1, 3, 1, 1] - [0, 0, 0, 1, 0, 0] = [0, 1, 1, 2, 1, 1], or, to go through the formula above, 60. For multiplication, add instead, and you\\'re done. \\n\\nThis approach has a major downside: Calculation. You need to calculate maps of numers to their factor-arrays, which takes some time. However, *it only needs to be called once*. So, this concept may work well in production, where a table can be stored. This is especially true if all of the numbers are under, say, 1000.\\n\\nAn advantage you get in return, then, is that manipulation becomes much easier. Want to exclude two indicies? Easily done, just subtract the exponents from index i+1 or whatever the case may be. Want to halve everything? Easily done, just pull out a two. \\n\\nIt\\'s a nifty trick that gives a lot of flexibility, albeit for a hefty initialization time."
                    },
                    {
                        "username": "_Veil_",
                        "content": "Am I the only one that doesn\\'t know what the \\'prefix or suffix of nums\\' means? "
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "basically a prefix of nums[i] will be everything from nums[0] till nums[i-1] and nums suffix/postfix will be everything from nums[i+1] till nums[end]. \\n\\nSay we have an array called nums of size 10 and it is 1 based indexed i.e. the array starts from 1 instead of the usual 0.\\nIf we want to find the prefix and suffix of the 6th element of the nums array then it will be\\n```\\nprefix = nums[1] to nums[5]   // 5 because i here is 6 and 6-1 is 5. We dont count 6\\nsuffix = nums[7] to nums[10] // 7 because we dont include 6 again lol\\n``` \\nIt\\'s kind of a grammar thingy lol"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/product-of-array-except-self/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Left and Right product lists\n\n  \n**Approach 2:** O(1) space approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n        int[] ans = new int[nums.length];\\n        int left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\n        for(int i = 0; i < nums.length; i++){\\n            while(left < i){\\n                var1 = var1 * nums[left];\\n                left++;\\n            }\\n            while(right > i){\\n                var2 = var2 * nums[right];\\n                right--;\\n            }\\n            ans[i] = var1 * var2;\\n        }\\n        return ans;"
                    },
                    {
                        "username": "ndrwknsh",
                        "content": "Hint #1: Could you solve this problem in $$O(n)$$ if division was allowed?\nHint #2: Think about this line: \"The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\""
                    },
                    {
                        "username": "sagdullin",
                        "content": "good hints!"
                    },
                    {
                        "username": "joydeep1982",
                        "content": "Detailed video with dry run and code, includes explanation of every single line\\nThis video covers group up details on understanding and solving the problem\\nhttps://youtu.be/RBXJvhgcWgM\\n\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Product of Array Except Self.\\nMemory Usage: 49.6 MB, less than 81.69% of Java online submissions for Product of Array Except Self.\\n\\n**Note:** If the embedded video doesnot work try copy pasting the url in a new window/tab"
                    },
                    {
                        "username": "AtVancouver",
                        "content": "Thanks"
                    },
                    {
                        "username": "qiuping345",
                        "content": "Maybe some people answered with dynamic programming.  But when I was asked of this question before, I questioned the interviewer: how could you put the product of two \"int\" into a single \"int\"? not mentioning it's the product of \"n-1\" int ? as far as I remember , the factorial of 13 would cause overflow on 32-bit computers. Anyway, I think this is a buggy question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "[@PervezAlam](/PervezAlam) the fuck you talking about??? there is no such thing in real life as a missing division operator so how the fuck can you even real life anything about this problem. its 100% gotcha the clown trash.\\n\\n"
                    },
                    {
                        "username": "PervezAlam",
                        "content": "You need to think the problem in real life. For example, think like there is some operation which needs two int and outputs an int, the operation is heavy and takes time, thus we want to reduce number of times we call it. Also, when we think of multiply, divide is a reverse operation. But in our case the operation might not have any invert operation."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Visualization of O(n) solution\\n\\nhttps://youtu.be/5bS636lE_R0?si=qUPiUy6YKb9a4zSL"
                    }
                ]
            },
            {
                "id": 1912869,
                "content": [
                    {
                        "username": "wangzhangwu",
                        "content": "Let `dp[i]` to be the product from index `0` to index `i-1`;\nLet `dp2[i]` to be the product from index `n` to index `i+1`;\nCompute `dp` from left to right and compute `dp2` from right to left.\n\nHopefully give you some basic idea to solve this problem in linear time. Plz do upvote if it helps!"
                    },
                    {
                        "username": "hisully",
                        "content": "[Here](https://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self) is my solution with explanations and visualizations.\\nhttps://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "To archive O(n), first write your programing in O(n*n) then find a way to acrchive O(2n) loop, try to decrease memory consuming by only using one array then you will having O(n), "
                    },
                    {
                        "username": "Ambioid",
                        "content": "this was helpful."
                    },
                    {
                        "username": "Nazanin1369",
                        "content": "![image](https://assets.leetcode.com/users/nazanin1369/image_1542669074.png)\\n"
                    },
                    {
                        "username": "wwboyer",
                        "content": "Not to be rude, but the problem explicitly states that the solution *needs* to be `O(n)` and this is `O(n^2)`. Finding a solution that is `O(n^2)` is pretty trivial..."
                    },
                    {
                        "username": "devenderdalal8",
                        "content": "time out "
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "[@MERVIN-dev254](/MERVIN-dev254) Only this is O(n ** 2) solution at best\\n"
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "this is so fucking crazy, massive RESPECT!!!"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Transforming array elements with prefix and suffix products! \\uD83D\\uDCA1\\n\\nGiven an array, we want to find a smart way to compute each element by multiplying all the other elements. To do this efficiently without division and in linear time, we employ prefix and suffix products.\\n\\nWe calculate the prefix products, storing the product of all previous elements. Then, we compute the suffix products, storing the product of all following elements.\\n\\nThe magic happens when we combine the prefix and suffix values! Each element\\'s product is simply the multiplication of its prefix and suffix. Voila! \\uD83C\\uDF89\\n\\nWith this approach, we crack the problem in O(n) time complexity, where n is the array\\'s size, unleashing the power of efficient algorithms! \\uD83D\\uDD25"
                    },
                    {
                        "username": "kbi201",
                        "content": "my two solutions ive come up with both fail the following testcase: [-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,...,-1] whoever came up with this testcase is an opp"
                    },
                    {
                        "username": "ambeshpm",
                        "content": "I get this question in 70% of rthe interviews :)\\nafter solving I realised the reason! "
                    },
                    {
                        "username": "abenkov2",
                        "content": "I\\'m getting this when I run the code:\\n![image](https://assets.leetcode.com/users/images/85ac1120-f936-4d83-9571-a5bd311125d6_1612500420.4465399.png)\\nBut this when I submit:\\n![image](https://assets.leetcode.com/users/images/e4001975-543e-4458-aecd-b8e22c1d37d5_1612500412.6833165.png)\\n\\nUsed the debugger to confirm that my code ws working as expected. \\n"
                    },
                    {
                        "username": "User18081971",
                        "content": "isthisdp.jpg? (im still trying to figure it out)"
                    },
                    {
                        "username": "marksworn",
                        "content": "Could you use the obvious method, but multiply by the number raised to the power of -1, instead of using divide - would it still satisfy the complexity constraint? \n\n ```\nP=1\nfor i in range(nums.length()):\n    P*=nums(i)\nfor j in range(nums.length()):\n    answer(j)=P*(nums(j)**-1)\n```\n\nI feel like this is a concise, elegant solution that would otherwise solve the problem. You could also just spray some WD-40 on your / key, rather than trying to avoid using it in your code ))"
                    },
                    {
                        "username": "drekuru",
                        "content": "What happens when you have\\nconst arr = [-1, 1, 0, -3, 3]; for the input? \\nThe 0 breaks all of it"
                    }
                ]
            },
            {
                "id": 1575717,
                "content": [
                    {
                        "username": "wangzhangwu",
                        "content": "Let `dp[i]` to be the product from index `0` to index `i-1`;\nLet `dp2[i]` to be the product from index `n` to index `i+1`;\nCompute `dp` from left to right and compute `dp2` from right to left.\n\nHopefully give you some basic idea to solve this problem in linear time. Plz do upvote if it helps!"
                    },
                    {
                        "username": "hisully",
                        "content": "[Here](https://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self) is my solution with explanations and visualizations.\\nhttps://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "To archive O(n), first write your programing in O(n*n) then find a way to acrchive O(2n) loop, try to decrease memory consuming by only using one array then you will having O(n), "
                    },
                    {
                        "username": "Ambioid",
                        "content": "this was helpful."
                    },
                    {
                        "username": "Nazanin1369",
                        "content": "![image](https://assets.leetcode.com/users/nazanin1369/image_1542669074.png)\\n"
                    },
                    {
                        "username": "wwboyer",
                        "content": "Not to be rude, but the problem explicitly states that the solution *needs* to be `O(n)` and this is `O(n^2)`. Finding a solution that is `O(n^2)` is pretty trivial..."
                    },
                    {
                        "username": "devenderdalal8",
                        "content": "time out "
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "[@MERVIN-dev254](/MERVIN-dev254) Only this is O(n ** 2) solution at best\\n"
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "this is so fucking crazy, massive RESPECT!!!"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Transforming array elements with prefix and suffix products! \\uD83D\\uDCA1\\n\\nGiven an array, we want to find a smart way to compute each element by multiplying all the other elements. To do this efficiently without division and in linear time, we employ prefix and suffix products.\\n\\nWe calculate the prefix products, storing the product of all previous elements. Then, we compute the suffix products, storing the product of all following elements.\\n\\nThe magic happens when we combine the prefix and suffix values! Each element\\'s product is simply the multiplication of its prefix and suffix. Voila! \\uD83C\\uDF89\\n\\nWith this approach, we crack the problem in O(n) time complexity, where n is the array\\'s size, unleashing the power of efficient algorithms! \\uD83D\\uDD25"
                    },
                    {
                        "username": "kbi201",
                        "content": "my two solutions ive come up with both fail the following testcase: [-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,...,-1] whoever came up with this testcase is an opp"
                    },
                    {
                        "username": "ambeshpm",
                        "content": "I get this question in 70% of rthe interviews :)\\nafter solving I realised the reason! "
                    },
                    {
                        "username": "abenkov2",
                        "content": "I\\'m getting this when I run the code:\\n![image](https://assets.leetcode.com/users/images/85ac1120-f936-4d83-9571-a5bd311125d6_1612500420.4465399.png)\\nBut this when I submit:\\n![image](https://assets.leetcode.com/users/images/e4001975-543e-4458-aecd-b8e22c1d37d5_1612500412.6833165.png)\\n\\nUsed the debugger to confirm that my code ws working as expected. \\n"
                    },
                    {
                        "username": "User18081971",
                        "content": "isthisdp.jpg? (im still trying to figure it out)"
                    },
                    {
                        "username": "marksworn",
                        "content": "Could you use the obvious method, but multiply by the number raised to the power of -1, instead of using divide - would it still satisfy the complexity constraint? \n\n ```\nP=1\nfor i in range(nums.length()):\n    P*=nums(i)\nfor j in range(nums.length()):\n    answer(j)=P*(nums(j)**-1)\n```\n\nI feel like this is a concise, elegant solution that would otherwise solve the problem. You could also just spray some WD-40 on your / key, rather than trying to avoid using it in your code ))"
                    },
                    {
                        "username": "drekuru",
                        "content": "What happens when you have\\nconst arr = [-1, 1, 0, -3, 3]; for the input? \\nThe 0 breaks all of it"
                    }
                ]
            },
            {
                "id": 1927956,
                "content": [
                    {
                        "username": "wangzhangwu",
                        "content": "Let `dp[i]` to be the product from index `0` to index `i-1`;\nLet `dp2[i]` to be the product from index `n` to index `i+1`;\nCompute `dp` from left to right and compute `dp2` from right to left.\n\nHopefully give you some basic idea to solve this problem in linear time. Plz do upvote if it helps!"
                    },
                    {
                        "username": "hisully",
                        "content": "[Here](https://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self) is my solution with explanations and visualizations.\\nhttps://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "To archive O(n), first write your programing in O(n*n) then find a way to acrchive O(2n) loop, try to decrease memory consuming by only using one array then you will having O(n), "
                    },
                    {
                        "username": "Ambioid",
                        "content": "this was helpful."
                    },
                    {
                        "username": "Nazanin1369",
                        "content": "![image](https://assets.leetcode.com/users/nazanin1369/image_1542669074.png)\\n"
                    },
                    {
                        "username": "wwboyer",
                        "content": "Not to be rude, but the problem explicitly states that the solution *needs* to be `O(n)` and this is `O(n^2)`. Finding a solution that is `O(n^2)` is pretty trivial..."
                    },
                    {
                        "username": "devenderdalal8",
                        "content": "time out "
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "[@MERVIN-dev254](/MERVIN-dev254) Only this is O(n ** 2) solution at best\\n"
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "this is so fucking crazy, massive RESPECT!!!"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Transforming array elements with prefix and suffix products! \\uD83D\\uDCA1\\n\\nGiven an array, we want to find a smart way to compute each element by multiplying all the other elements. To do this efficiently without division and in linear time, we employ prefix and suffix products.\\n\\nWe calculate the prefix products, storing the product of all previous elements. Then, we compute the suffix products, storing the product of all following elements.\\n\\nThe magic happens when we combine the prefix and suffix values! Each element\\'s product is simply the multiplication of its prefix and suffix. Voila! \\uD83C\\uDF89\\n\\nWith this approach, we crack the problem in O(n) time complexity, where n is the array\\'s size, unleashing the power of efficient algorithms! \\uD83D\\uDD25"
                    },
                    {
                        "username": "kbi201",
                        "content": "my two solutions ive come up with both fail the following testcase: [-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,...,-1] whoever came up with this testcase is an opp"
                    },
                    {
                        "username": "ambeshpm",
                        "content": "I get this question in 70% of rthe interviews :)\\nafter solving I realised the reason! "
                    },
                    {
                        "username": "abenkov2",
                        "content": "I\\'m getting this when I run the code:\\n![image](https://assets.leetcode.com/users/images/85ac1120-f936-4d83-9571-a5bd311125d6_1612500420.4465399.png)\\nBut this when I submit:\\n![image](https://assets.leetcode.com/users/images/e4001975-543e-4458-aecd-b8e22c1d37d5_1612500412.6833165.png)\\n\\nUsed the debugger to confirm that my code ws working as expected. \\n"
                    },
                    {
                        "username": "User18081971",
                        "content": "isthisdp.jpg? (im still trying to figure it out)"
                    },
                    {
                        "username": "marksworn",
                        "content": "Could you use the obvious method, but multiply by the number raised to the power of -1, instead of using divide - would it still satisfy the complexity constraint? \n\n ```\nP=1\nfor i in range(nums.length()):\n    P*=nums(i)\nfor j in range(nums.length()):\n    answer(j)=P*(nums(j)**-1)\n```\n\nI feel like this is a concise, elegant solution that would otherwise solve the problem. You could also just spray some WD-40 on your / key, rather than trying to avoid using it in your code ))"
                    },
                    {
                        "username": "drekuru",
                        "content": "What happens when you have\\nconst arr = [-1, 1, 0, -3, 3]; for the input? \\nThe 0 breaks all of it"
                    }
                ]
            },
            {
                "id": 1566289,
                "content": [
                    {
                        "username": "wangzhangwu",
                        "content": "Let `dp[i]` to be the product from index `0` to index `i-1`;\nLet `dp2[i]` to be the product from index `n` to index `i+1`;\nCompute `dp` from left to right and compute `dp2` from right to left.\n\nHopefully give you some basic idea to solve this problem in linear time. Plz do upvote if it helps!"
                    },
                    {
                        "username": "hisully",
                        "content": "[Here](https://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self) is my solution with explanations and visualizations.\\nhttps://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "To archive O(n), first write your programing in O(n*n) then find a way to acrchive O(2n) loop, try to decrease memory consuming by only using one array then you will having O(n), "
                    },
                    {
                        "username": "Ambioid",
                        "content": "this was helpful."
                    },
                    {
                        "username": "Nazanin1369",
                        "content": "![image](https://assets.leetcode.com/users/nazanin1369/image_1542669074.png)\\n"
                    },
                    {
                        "username": "wwboyer",
                        "content": "Not to be rude, but the problem explicitly states that the solution *needs* to be `O(n)` and this is `O(n^2)`. Finding a solution that is `O(n^2)` is pretty trivial..."
                    },
                    {
                        "username": "devenderdalal8",
                        "content": "time out "
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "[@MERVIN-dev254](/MERVIN-dev254) Only this is O(n ** 2) solution at best\\n"
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "this is so fucking crazy, massive RESPECT!!!"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Transforming array elements with prefix and suffix products! \\uD83D\\uDCA1\\n\\nGiven an array, we want to find a smart way to compute each element by multiplying all the other elements. To do this efficiently without division and in linear time, we employ prefix and suffix products.\\n\\nWe calculate the prefix products, storing the product of all previous elements. Then, we compute the suffix products, storing the product of all following elements.\\n\\nThe magic happens when we combine the prefix and suffix values! Each element\\'s product is simply the multiplication of its prefix and suffix. Voila! \\uD83C\\uDF89\\n\\nWith this approach, we crack the problem in O(n) time complexity, where n is the array\\'s size, unleashing the power of efficient algorithms! \\uD83D\\uDD25"
                    },
                    {
                        "username": "kbi201",
                        "content": "my two solutions ive come up with both fail the following testcase: [-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,...,-1] whoever came up with this testcase is an opp"
                    },
                    {
                        "username": "ambeshpm",
                        "content": "I get this question in 70% of rthe interviews :)\\nafter solving I realised the reason! "
                    },
                    {
                        "username": "abenkov2",
                        "content": "I\\'m getting this when I run the code:\\n![image](https://assets.leetcode.com/users/images/85ac1120-f936-4d83-9571-a5bd311125d6_1612500420.4465399.png)\\nBut this when I submit:\\n![image](https://assets.leetcode.com/users/images/e4001975-543e-4458-aecd-b8e22c1d37d5_1612500412.6833165.png)\\n\\nUsed the debugger to confirm that my code ws working as expected. \\n"
                    },
                    {
                        "username": "User18081971",
                        "content": "isthisdp.jpg? (im still trying to figure it out)"
                    },
                    {
                        "username": "marksworn",
                        "content": "Could you use the obvious method, but multiply by the number raised to the power of -1, instead of using divide - would it still satisfy the complexity constraint? \n\n ```\nP=1\nfor i in range(nums.length()):\n    P*=nums(i)\nfor j in range(nums.length()):\n    answer(j)=P*(nums(j)**-1)\n```\n\nI feel like this is a concise, elegant solution that would otherwise solve the problem. You could also just spray some WD-40 on your / key, rather than trying to avoid using it in your code ))"
                    },
                    {
                        "username": "drekuru",
                        "content": "What happens when you have\\nconst arr = [-1, 1, 0, -3, 3]; for the input? \\nThe 0 breaks all of it"
                    }
                ]
            },
            {
                "id": 1967765,
                "content": [
                    {
                        "username": "wangzhangwu",
                        "content": "Let `dp[i]` to be the product from index `0` to index `i-1`;\nLet `dp2[i]` to be the product from index `n` to index `i+1`;\nCompute `dp` from left to right and compute `dp2` from right to left.\n\nHopefully give you some basic idea to solve this problem in linear time. Plz do upvote if it helps!"
                    },
                    {
                        "username": "hisully",
                        "content": "[Here](https://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self) is my solution with explanations and visualizations.\\nhttps://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "To archive O(n), first write your programing in O(n*n) then find a way to acrchive O(2n) loop, try to decrease memory consuming by only using one array then you will having O(n), "
                    },
                    {
                        "username": "Ambioid",
                        "content": "this was helpful."
                    },
                    {
                        "username": "Nazanin1369",
                        "content": "![image](https://assets.leetcode.com/users/nazanin1369/image_1542669074.png)\\n"
                    },
                    {
                        "username": "wwboyer",
                        "content": "Not to be rude, but the problem explicitly states that the solution *needs* to be `O(n)` and this is `O(n^2)`. Finding a solution that is `O(n^2)` is pretty trivial..."
                    },
                    {
                        "username": "devenderdalal8",
                        "content": "time out "
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "[@MERVIN-dev254](/MERVIN-dev254) Only this is O(n ** 2) solution at best\\n"
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "this is so fucking crazy, massive RESPECT!!!"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Transforming array elements with prefix and suffix products! \\uD83D\\uDCA1\\n\\nGiven an array, we want to find a smart way to compute each element by multiplying all the other elements. To do this efficiently without division and in linear time, we employ prefix and suffix products.\\n\\nWe calculate the prefix products, storing the product of all previous elements. Then, we compute the suffix products, storing the product of all following elements.\\n\\nThe magic happens when we combine the prefix and suffix values! Each element\\'s product is simply the multiplication of its prefix and suffix. Voila! \\uD83C\\uDF89\\n\\nWith this approach, we crack the problem in O(n) time complexity, where n is the array\\'s size, unleashing the power of efficient algorithms! \\uD83D\\uDD25"
                    },
                    {
                        "username": "kbi201",
                        "content": "my two solutions ive come up with both fail the following testcase: [-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,...,-1] whoever came up with this testcase is an opp"
                    },
                    {
                        "username": "ambeshpm",
                        "content": "I get this question in 70% of rthe interviews :)\\nafter solving I realised the reason! "
                    },
                    {
                        "username": "abenkov2",
                        "content": "I\\'m getting this when I run the code:\\n![image](https://assets.leetcode.com/users/images/85ac1120-f936-4d83-9571-a5bd311125d6_1612500420.4465399.png)\\nBut this when I submit:\\n![image](https://assets.leetcode.com/users/images/e4001975-543e-4458-aecd-b8e22c1d37d5_1612500412.6833165.png)\\n\\nUsed the debugger to confirm that my code ws working as expected. \\n"
                    },
                    {
                        "username": "User18081971",
                        "content": "isthisdp.jpg? (im still trying to figure it out)"
                    },
                    {
                        "username": "marksworn",
                        "content": "Could you use the obvious method, but multiply by the number raised to the power of -1, instead of using divide - would it still satisfy the complexity constraint? \n\n ```\nP=1\nfor i in range(nums.length()):\n    P*=nums(i)\nfor j in range(nums.length()):\n    answer(j)=P*(nums(j)**-1)\n```\n\nI feel like this is a concise, elegant solution that would otherwise solve the problem. You could also just spray some WD-40 on your / key, rather than trying to avoid using it in your code ))"
                    },
                    {
                        "username": "drekuru",
                        "content": "What happens when you have\\nconst arr = [-1, 1, 0, -3, 3]; for the input? \\nThe 0 breaks all of it"
                    }
                ]
            },
            {
                "id": 2045524,
                "content": [
                    {
                        "username": "wangzhangwu",
                        "content": "Let `dp[i]` to be the product from index `0` to index `i-1`;\nLet `dp2[i]` to be the product from index `n` to index `i+1`;\nCompute `dp` from left to right and compute `dp2` from right to left.\n\nHopefully give you some basic idea to solve this problem in linear time. Plz do upvote if it helps!"
                    },
                    {
                        "username": "hisully",
                        "content": "[Here](https://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self) is my solution with explanations and visualizations.\\nhttps://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "To archive O(n), first write your programing in O(n*n) then find a way to acrchive O(2n) loop, try to decrease memory consuming by only using one array then you will having O(n), "
                    },
                    {
                        "username": "Ambioid",
                        "content": "this was helpful."
                    },
                    {
                        "username": "Nazanin1369",
                        "content": "![image](https://assets.leetcode.com/users/nazanin1369/image_1542669074.png)\\n"
                    },
                    {
                        "username": "wwboyer",
                        "content": "Not to be rude, but the problem explicitly states that the solution *needs* to be `O(n)` and this is `O(n^2)`. Finding a solution that is `O(n^2)` is pretty trivial..."
                    },
                    {
                        "username": "devenderdalal8",
                        "content": "time out "
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "[@MERVIN-dev254](/MERVIN-dev254) Only this is O(n ** 2) solution at best\\n"
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "this is so fucking crazy, massive RESPECT!!!"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Transforming array elements with prefix and suffix products! \\uD83D\\uDCA1\\n\\nGiven an array, we want to find a smart way to compute each element by multiplying all the other elements. To do this efficiently without division and in linear time, we employ prefix and suffix products.\\n\\nWe calculate the prefix products, storing the product of all previous elements. Then, we compute the suffix products, storing the product of all following elements.\\n\\nThe magic happens when we combine the prefix and suffix values! Each element\\'s product is simply the multiplication of its prefix and suffix. Voila! \\uD83C\\uDF89\\n\\nWith this approach, we crack the problem in O(n) time complexity, where n is the array\\'s size, unleashing the power of efficient algorithms! \\uD83D\\uDD25"
                    },
                    {
                        "username": "kbi201",
                        "content": "my two solutions ive come up with both fail the following testcase: [-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,...,-1] whoever came up with this testcase is an opp"
                    },
                    {
                        "username": "ambeshpm",
                        "content": "I get this question in 70% of rthe interviews :)\\nafter solving I realised the reason! "
                    },
                    {
                        "username": "abenkov2",
                        "content": "I\\'m getting this when I run the code:\\n![image](https://assets.leetcode.com/users/images/85ac1120-f936-4d83-9571-a5bd311125d6_1612500420.4465399.png)\\nBut this when I submit:\\n![image](https://assets.leetcode.com/users/images/e4001975-543e-4458-aecd-b8e22c1d37d5_1612500412.6833165.png)\\n\\nUsed the debugger to confirm that my code ws working as expected. \\n"
                    },
                    {
                        "username": "User18081971",
                        "content": "isthisdp.jpg? (im still trying to figure it out)"
                    },
                    {
                        "username": "marksworn",
                        "content": "Could you use the obvious method, but multiply by the number raised to the power of -1, instead of using divide - would it still satisfy the complexity constraint? \n\n ```\nP=1\nfor i in range(nums.length()):\n    P*=nums(i)\nfor j in range(nums.length()):\n    answer(j)=P*(nums(j)**-1)\n```\n\nI feel like this is a concise, elegant solution that would otherwise solve the problem. You could also just spray some WD-40 on your / key, rather than trying to avoid using it in your code ))"
                    },
                    {
                        "username": "drekuru",
                        "content": "What happens when you have\\nconst arr = [-1, 1, 0, -3, 3]; for the input? \\nThe 0 breaks all of it"
                    }
                ]
            },
            {
                "id": 1969697,
                "content": [
                    {
                        "username": "wangzhangwu",
                        "content": "Let `dp[i]` to be the product from index `0` to index `i-1`;\nLet `dp2[i]` to be the product from index `n` to index `i+1`;\nCompute `dp` from left to right and compute `dp2` from right to left.\n\nHopefully give you some basic idea to solve this problem in linear time. Plz do upvote if it helps!"
                    },
                    {
                        "username": "hisully",
                        "content": "[Here](https://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self) is my solution with explanations and visualizations.\\nhttps://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "To archive O(n), first write your programing in O(n*n) then find a way to acrchive O(2n) loop, try to decrease memory consuming by only using one array then you will having O(n), "
                    },
                    {
                        "username": "Ambioid",
                        "content": "this was helpful."
                    },
                    {
                        "username": "Nazanin1369",
                        "content": "![image](https://assets.leetcode.com/users/nazanin1369/image_1542669074.png)\\n"
                    },
                    {
                        "username": "wwboyer",
                        "content": "Not to be rude, but the problem explicitly states that the solution *needs* to be `O(n)` and this is `O(n^2)`. Finding a solution that is `O(n^2)` is pretty trivial..."
                    },
                    {
                        "username": "devenderdalal8",
                        "content": "time out "
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "[@MERVIN-dev254](/MERVIN-dev254) Only this is O(n ** 2) solution at best\\n"
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "this is so fucking crazy, massive RESPECT!!!"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Transforming array elements with prefix and suffix products! \\uD83D\\uDCA1\\n\\nGiven an array, we want to find a smart way to compute each element by multiplying all the other elements. To do this efficiently without division and in linear time, we employ prefix and suffix products.\\n\\nWe calculate the prefix products, storing the product of all previous elements. Then, we compute the suffix products, storing the product of all following elements.\\n\\nThe magic happens when we combine the prefix and suffix values! Each element\\'s product is simply the multiplication of its prefix and suffix. Voila! \\uD83C\\uDF89\\n\\nWith this approach, we crack the problem in O(n) time complexity, where n is the array\\'s size, unleashing the power of efficient algorithms! \\uD83D\\uDD25"
                    },
                    {
                        "username": "kbi201",
                        "content": "my two solutions ive come up with both fail the following testcase: [-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,...,-1] whoever came up with this testcase is an opp"
                    },
                    {
                        "username": "ambeshpm",
                        "content": "I get this question in 70% of rthe interviews :)\\nafter solving I realised the reason! "
                    },
                    {
                        "username": "abenkov2",
                        "content": "I\\'m getting this when I run the code:\\n![image](https://assets.leetcode.com/users/images/85ac1120-f936-4d83-9571-a5bd311125d6_1612500420.4465399.png)\\nBut this when I submit:\\n![image](https://assets.leetcode.com/users/images/e4001975-543e-4458-aecd-b8e22c1d37d5_1612500412.6833165.png)\\n\\nUsed the debugger to confirm that my code ws working as expected. \\n"
                    },
                    {
                        "username": "User18081971",
                        "content": "isthisdp.jpg? (im still trying to figure it out)"
                    },
                    {
                        "username": "marksworn",
                        "content": "Could you use the obvious method, but multiply by the number raised to the power of -1, instead of using divide - would it still satisfy the complexity constraint? \n\n ```\nP=1\nfor i in range(nums.length()):\n    P*=nums(i)\nfor j in range(nums.length()):\n    answer(j)=P*(nums(j)**-1)\n```\n\nI feel like this is a concise, elegant solution that would otherwise solve the problem. You could also just spray some WD-40 on your / key, rather than trying to avoid using it in your code ))"
                    },
                    {
                        "username": "drekuru",
                        "content": "What happens when you have\\nconst arr = [-1, 1, 0, -3, 3]; for the input? \\nThe 0 breaks all of it"
                    }
                ]
            },
            {
                "id": 1574922,
                "content": [
                    {
                        "username": "wangzhangwu",
                        "content": "Let `dp[i]` to be the product from index `0` to index `i-1`;\nLet `dp2[i]` to be the product from index `n` to index `i+1`;\nCompute `dp` from left to right and compute `dp2` from right to left.\n\nHopefully give you some basic idea to solve this problem in linear time. Plz do upvote if it helps!"
                    },
                    {
                        "username": "hisully",
                        "content": "[Here](https://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self) is my solution with explanations and visualizations.\\nhttps://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "To archive O(n), first write your programing in O(n*n) then find a way to acrchive O(2n) loop, try to decrease memory consuming by only using one array then you will having O(n), "
                    },
                    {
                        "username": "Ambioid",
                        "content": "this was helpful."
                    },
                    {
                        "username": "Nazanin1369",
                        "content": "![image](https://assets.leetcode.com/users/nazanin1369/image_1542669074.png)\\n"
                    },
                    {
                        "username": "wwboyer",
                        "content": "Not to be rude, but the problem explicitly states that the solution *needs* to be `O(n)` and this is `O(n^2)`. Finding a solution that is `O(n^2)` is pretty trivial..."
                    },
                    {
                        "username": "devenderdalal8",
                        "content": "time out "
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "[@MERVIN-dev254](/MERVIN-dev254) Only this is O(n ** 2) solution at best\\n"
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "this is so fucking crazy, massive RESPECT!!!"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Transforming array elements with prefix and suffix products! \\uD83D\\uDCA1\\n\\nGiven an array, we want to find a smart way to compute each element by multiplying all the other elements. To do this efficiently without division and in linear time, we employ prefix and suffix products.\\n\\nWe calculate the prefix products, storing the product of all previous elements. Then, we compute the suffix products, storing the product of all following elements.\\n\\nThe magic happens when we combine the prefix and suffix values! Each element\\'s product is simply the multiplication of its prefix and suffix. Voila! \\uD83C\\uDF89\\n\\nWith this approach, we crack the problem in O(n) time complexity, where n is the array\\'s size, unleashing the power of efficient algorithms! \\uD83D\\uDD25"
                    },
                    {
                        "username": "kbi201",
                        "content": "my two solutions ive come up with both fail the following testcase: [-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,...,-1] whoever came up with this testcase is an opp"
                    },
                    {
                        "username": "ambeshpm",
                        "content": "I get this question in 70% of rthe interviews :)\\nafter solving I realised the reason! "
                    },
                    {
                        "username": "abenkov2",
                        "content": "I\\'m getting this when I run the code:\\n![image](https://assets.leetcode.com/users/images/85ac1120-f936-4d83-9571-a5bd311125d6_1612500420.4465399.png)\\nBut this when I submit:\\n![image](https://assets.leetcode.com/users/images/e4001975-543e-4458-aecd-b8e22c1d37d5_1612500412.6833165.png)\\n\\nUsed the debugger to confirm that my code ws working as expected. \\n"
                    },
                    {
                        "username": "User18081971",
                        "content": "isthisdp.jpg? (im still trying to figure it out)"
                    },
                    {
                        "username": "marksworn",
                        "content": "Could you use the obvious method, but multiply by the number raised to the power of -1, instead of using divide - would it still satisfy the complexity constraint? \n\n ```\nP=1\nfor i in range(nums.length()):\n    P*=nums(i)\nfor j in range(nums.length()):\n    answer(j)=P*(nums(j)**-1)\n```\n\nI feel like this is a concise, elegant solution that would otherwise solve the problem. You could also just spray some WD-40 on your / key, rather than trying to avoid using it in your code ))"
                    },
                    {
                        "username": "drekuru",
                        "content": "What happens when you have\\nconst arr = [-1, 1, 0, -3, 3]; for the input? \\nThe 0 breaks all of it"
                    }
                ]
            },
            {
                "id": 1896359,
                "content": [
                    {
                        "username": "wangzhangwu",
                        "content": "Let `dp[i]` to be the product from index `0` to index `i-1`;\nLet `dp2[i]` to be the product from index `n` to index `i+1`;\nCompute `dp` from left to right and compute `dp2` from right to left.\n\nHopefully give you some basic idea to solve this problem in linear time. Plz do upvote if it helps!"
                    },
                    {
                        "username": "hisully",
                        "content": "[Here](https://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self) is my solution with explanations and visualizations.\\nhttps://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "To archive O(n), first write your programing in O(n*n) then find a way to acrchive O(2n) loop, try to decrease memory consuming by only using one array then you will having O(n), "
                    },
                    {
                        "username": "Ambioid",
                        "content": "this was helpful."
                    },
                    {
                        "username": "Nazanin1369",
                        "content": "![image](https://assets.leetcode.com/users/nazanin1369/image_1542669074.png)\\n"
                    },
                    {
                        "username": "wwboyer",
                        "content": "Not to be rude, but the problem explicitly states that the solution *needs* to be `O(n)` and this is `O(n^2)`. Finding a solution that is `O(n^2)` is pretty trivial..."
                    },
                    {
                        "username": "devenderdalal8",
                        "content": "time out "
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "[@MERVIN-dev254](/MERVIN-dev254) Only this is O(n ** 2) solution at best\\n"
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "this is so fucking crazy, massive RESPECT!!!"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Transforming array elements with prefix and suffix products! \\uD83D\\uDCA1\\n\\nGiven an array, we want to find a smart way to compute each element by multiplying all the other elements. To do this efficiently without division and in linear time, we employ prefix and suffix products.\\n\\nWe calculate the prefix products, storing the product of all previous elements. Then, we compute the suffix products, storing the product of all following elements.\\n\\nThe magic happens when we combine the prefix and suffix values! Each element\\'s product is simply the multiplication of its prefix and suffix. Voila! \\uD83C\\uDF89\\n\\nWith this approach, we crack the problem in O(n) time complexity, where n is the array\\'s size, unleashing the power of efficient algorithms! \\uD83D\\uDD25"
                    },
                    {
                        "username": "kbi201",
                        "content": "my two solutions ive come up with both fail the following testcase: [-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,...,-1] whoever came up with this testcase is an opp"
                    },
                    {
                        "username": "ambeshpm",
                        "content": "I get this question in 70% of rthe interviews :)\\nafter solving I realised the reason! "
                    },
                    {
                        "username": "abenkov2",
                        "content": "I\\'m getting this when I run the code:\\n![image](https://assets.leetcode.com/users/images/85ac1120-f936-4d83-9571-a5bd311125d6_1612500420.4465399.png)\\nBut this when I submit:\\n![image](https://assets.leetcode.com/users/images/e4001975-543e-4458-aecd-b8e22c1d37d5_1612500412.6833165.png)\\n\\nUsed the debugger to confirm that my code ws working as expected. \\n"
                    },
                    {
                        "username": "User18081971",
                        "content": "isthisdp.jpg? (im still trying to figure it out)"
                    },
                    {
                        "username": "marksworn",
                        "content": "Could you use the obvious method, but multiply by the number raised to the power of -1, instead of using divide - would it still satisfy the complexity constraint? \n\n ```\nP=1\nfor i in range(nums.length()):\n    P*=nums(i)\nfor j in range(nums.length()):\n    answer(j)=P*(nums(j)**-1)\n```\n\nI feel like this is a concise, elegant solution that would otherwise solve the problem. You could also just spray some WD-40 on your / key, rather than trying to avoid using it in your code ))"
                    },
                    {
                        "username": "drekuru",
                        "content": "What happens when you have\\nconst arr = [-1, 1, 0, -3, 3]; for the input? \\nThe 0 breaks all of it"
                    }
                ]
            },
            {
                "id": 1817794,
                "content": [
                    {
                        "username": "wangzhangwu",
                        "content": "Let `dp[i]` to be the product from index `0` to index `i-1`;\nLet `dp2[i]` to be the product from index `n` to index `i+1`;\nCompute `dp` from left to right and compute `dp2` from right to left.\n\nHopefully give you some basic idea to solve this problem in linear time. Plz do upvote if it helps!"
                    },
                    {
                        "username": "hisully",
                        "content": "[Here](https://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self) is my solution with explanations and visualizations.\\nhttps://andrewsullivan.co/articles/2021/9/2/algorithms-product-of-array-except-self"
                    },
                    {
                        "username": "tungbuivn",
                        "content": "To archive O(n), first write your programing in O(n*n) then find a way to acrchive O(2n) loop, try to decrease memory consuming by only using one array then you will having O(n), "
                    },
                    {
                        "username": "Ambioid",
                        "content": "this was helpful."
                    },
                    {
                        "username": "Nazanin1369",
                        "content": "![image](https://assets.leetcode.com/users/nazanin1369/image_1542669074.png)\\n"
                    },
                    {
                        "username": "wwboyer",
                        "content": "Not to be rude, but the problem explicitly states that the solution *needs* to be `O(n)` and this is `O(n^2)`. Finding a solution that is `O(n^2)` is pretty trivial..."
                    },
                    {
                        "username": "devenderdalal8",
                        "content": "time out "
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "[@MERVIN-dev254](/MERVIN-dev254) Only this is O(n ** 2) solution at best\\n"
                    },
                    {
                        "username": "MERVIN-dev254",
                        "content": "this is so fucking crazy, massive RESPECT!!!"
                    },
                    {
                        "username": "hadhilnjrbrototype",
                        "content": "Transforming array elements with prefix and suffix products! \\uD83D\\uDCA1\\n\\nGiven an array, we want to find a smart way to compute each element by multiplying all the other elements. To do this efficiently without division and in linear time, we employ prefix and suffix products.\\n\\nWe calculate the prefix products, storing the product of all previous elements. Then, we compute the suffix products, storing the product of all following elements.\\n\\nThe magic happens when we combine the prefix and suffix values! Each element\\'s product is simply the multiplication of its prefix and suffix. Voila! \\uD83C\\uDF89\\n\\nWith this approach, we crack the problem in O(n) time complexity, where n is the array\\'s size, unleashing the power of efficient algorithms! \\uD83D\\uDD25"
                    },
                    {
                        "username": "kbi201",
                        "content": "my two solutions ive come up with both fail the following testcase: [-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,...,-1] whoever came up with this testcase is an opp"
                    },
                    {
                        "username": "ambeshpm",
                        "content": "I get this question in 70% of rthe interviews :)\\nafter solving I realised the reason! "
                    },
                    {
                        "username": "abenkov2",
                        "content": "I\\'m getting this when I run the code:\\n![image](https://assets.leetcode.com/users/images/85ac1120-f936-4d83-9571-a5bd311125d6_1612500420.4465399.png)\\nBut this when I submit:\\n![image](https://assets.leetcode.com/users/images/e4001975-543e-4458-aecd-b8e22c1d37d5_1612500412.6833165.png)\\n\\nUsed the debugger to confirm that my code ws working as expected. \\n"
                    },
                    {
                        "username": "User18081971",
                        "content": "isthisdp.jpg? (im still trying to figure it out)"
                    },
                    {
                        "username": "marksworn",
                        "content": "Could you use the obvious method, but multiply by the number raised to the power of -1, instead of using divide - would it still satisfy the complexity constraint? \n\n ```\nP=1\nfor i in range(nums.length()):\n    P*=nums(i)\nfor j in range(nums.length()):\n    answer(j)=P*(nums(j)**-1)\n```\n\nI feel like this is a concise, elegant solution that would otherwise solve the problem. You could also just spray some WD-40 on your / key, rather than trying to avoid using it in your code ))"
                    },
                    {
                        "username": "drekuru",
                        "content": "What happens when you have\\nconst arr = [-1, 1, 0, -3, 3]; for the input? \\nThe 0 breaks all of it"
                    }
                ]
            },
            {
                "id": 1793573,
                "content": [
                    {
                        "username": "gawari",
                        "content": "C++ solution:  \\n`\\n\\n\\n\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        if(0 == n)  return ans;\\n\\n        ans[0] = 1;\\n        int prod = 1;\\n        for(int i = 1; i < n; i++)\\n        {\\n            prod = prod * nums[i - 1];\\n            ans[i] = prod;\\n        }\\n\\n        prod = 1;\\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            ans[i] = prod * ans[i];\\n            prod = nums[i] * prod;\\n        }\\n\\n        return ans;\\n\\n    \\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pankajj_",
                        "content": "test case 22 does not even has an array :) "
                    },
                    {
                        "username": "Harsh790",
                        "content": "In this question if you are trying a brute force approach then there are three cases that you need to take care of \\nCase1:-- when there are no zeros\\nCase2:-when there is one zero\\nCase 3:-when there is more than one zero"
                    },
                    {
                        "username": "Yeswanth_G",
                        "content": "This is how you do it\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function(nums) {\\n    let totalProduct = 1;\\n    const n = nums.length;\\n    const zeroCount = nums.filter(nums => nums===0).length;\\n    const finalArray = new Array(n);\\n    for(let i =0; i<n;i++){\\n        if(nums[i] !== 0){\\n            totalProduct*=nums[i];\\n        }\\n    }\\n    for(let j = 0;j<n;j++){\\n        if (zeroCount === 1 && nums[j] === 0) {\\n            // If there\\'s exactly one zero in the array, the result is zero for all elements except that zero.\\n            finalArray[j] = totalProduct;\\n        } else if (zeroCount > 1 || nums[j] !== 0) {\\n            // If there are more than one zero or the current element is not zero, calculate normally.\\n            finalArray[j] = zeroCount > 0 ? 0 : totalProduct / nums[j];\\n        } else {\\n            // If there are no zeros in the array, set the result to zero for this element.\\n            finalArray[j] = 0;\\n        }\\n    }\\n    return finalArray;\\n};"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time."
                    },
                    {
                        "username": "Rohit_Dabas",
                        "content": "BRO WTF IS THIS TEST CASE 18: it shows time limit exceeded everytime i run it, My all test cases are passed except this one\\nCAN ANYONE TELL WHATS WRONG WITH CODE(JAVA)??\\nCODE:\\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int i=0;\\n\\n        int ans[] = new int[nums.length];\\n        int count=0;\\n        while(i<nums.length){\\n            int answer=1;\\n            int j =0;\\n            while(j<nums.length){\\n                if(i!=j){\\n                    answer = answer*nums[j];\\n                    j++;\\n                }else{\\n                    j++;\\n                }\\n            }\\n            ans[count]=answer;\\n            count++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n}\\n\\nTest Case looks Something like this:\\n[-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,-1,1,1,1,1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,1,1,1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,1,1,1,1,1,1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,-1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,1,1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,1,-1,-1,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,-1,1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1........................................................................]\\n"
                    },
                    {
                        "username": "RashilDudhara",
                        "content": "Your doing O(n2) test case is to catch folks like us who said screw it to the condition stating solution needs to be O(n)"
                    },
                    {
                        "username": "foal20ym",
                        "content": "[@willq1](/willq1)  Yep, that was the reason the first time. I had made an error with the index, since i used the method to divide by each of the current indexes. "
                    },
                    {
                        "username": "willq1",
                        "content": "I'm pretty sure that's O(N^2) when the problem states you need it to be in O(N). Otherwise it'll time out."
                    },
                    {
                        "username": "foal20ym",
                        "content": "My C++ code also fails that test case. I don\\'t understand what\\'s wrong. "
                    },
                    {
                        "username": "RIGIK93",
                        "content": "**A Hint**:\\nUse sliding window technique. Iterate two times, first from left to right, then from right to left, while accumulating a buffer of products."
                    },
                    {
                        "username": "neozyan",
                        "content": "make two passes, first in-order, second in-reverse, to compute products"
                    },
                    {
                        "username": "nimox",
                        "content": "JAVA SOLUTION:\n\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int ans[] = new int[n];\n        Arrays.fill(ans, 1);\n        int curr = 1;\n        for(int i = 0; i < n; i++) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        curr = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        return ans;\n    }\n}\n\nWe multiply suffix and prefix product for each element"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "basic intuition without solution -> \\n![b5cc1c65-b4ac-4cfb-b151-b79bd15d07cf.jpeg](https://assets.leetcode.com/users/images/03350759-b360-4054-b904-73612138b0af_1664570838.9668634.jpeg)\\n"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "So in this solution we took first left side count\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n_______________________________________________________________________________\\narr[0] = 1;\\narr = 1\\n\\narr[1] = arr[0] * nums[1]  // 1 * 2\\narr= 1, 2\\n\\narr[2] = arr[1] * nums[2]  //  2 * 3\\narr = 1, 2, 6\\n\\narr[3] = arr[2] * nums[3] //  6 * 4\\narr= 1, 2, 6, 24\\n\\nafter left array count we started reverse loop for arr and taken one variable called product which will be handling right count .\\n\\n____________________________________________________________________________\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n\\nint product  = 1;\\nloop -> i = nums.length-1;  i>0;  i--\\n\\narr[3] = arr[2] * product  // 6 * 1\\nproduct = product * nums[3]  // 1 * 4 \\narr = 1, 2, 6, 6\\nproduct = 4\\n\\narr[2] = arr[1] * product  //  2 * 4\\nproduct  =  product * nums[2]  //  4 * 3\\narr = 1, 2, 8, 6\\nproduct = 12\\n\\narr[1] = arr[0] * product  //  1 * 12\\nproduct  =  product * nums[1]  //  12 * 2\\narr = 1, 12, 8, 6\\nproduct = 24\\n\\n\\nloop runs till i>0 only which means till i==1 only, so for arr 0th index we will add product value only\\n\\narr[0] = product // 24\\n\\narr = 24, 12, 8, 6\\n"
                    },
                    {
                        "username": "Nbs-26",
                        "content": "The explanation is very detailed! Thank you."
                    },
                    {
                        "username": "axemaneric",
                        "content": "Great, essential problem for interviews"
                    }
                ]
            },
            {
                "id": 2036899,
                "content": [
                    {
                        "username": "gawari",
                        "content": "C++ solution:  \\n`\\n\\n\\n\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        if(0 == n)  return ans;\\n\\n        ans[0] = 1;\\n        int prod = 1;\\n        for(int i = 1; i < n; i++)\\n        {\\n            prod = prod * nums[i - 1];\\n            ans[i] = prod;\\n        }\\n\\n        prod = 1;\\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            ans[i] = prod * ans[i];\\n            prod = nums[i] * prod;\\n        }\\n\\n        return ans;\\n\\n    \\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pankajj_",
                        "content": "test case 22 does not even has an array :) "
                    },
                    {
                        "username": "Harsh790",
                        "content": "In this question if you are trying a brute force approach then there are three cases that you need to take care of \\nCase1:-- when there are no zeros\\nCase2:-when there is one zero\\nCase 3:-when there is more than one zero"
                    },
                    {
                        "username": "Yeswanth_G",
                        "content": "This is how you do it\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function(nums) {\\n    let totalProduct = 1;\\n    const n = nums.length;\\n    const zeroCount = nums.filter(nums => nums===0).length;\\n    const finalArray = new Array(n);\\n    for(let i =0; i<n;i++){\\n        if(nums[i] !== 0){\\n            totalProduct*=nums[i];\\n        }\\n    }\\n    for(let j = 0;j<n;j++){\\n        if (zeroCount === 1 && nums[j] === 0) {\\n            // If there\\'s exactly one zero in the array, the result is zero for all elements except that zero.\\n            finalArray[j] = totalProduct;\\n        } else if (zeroCount > 1 || nums[j] !== 0) {\\n            // If there are more than one zero or the current element is not zero, calculate normally.\\n            finalArray[j] = zeroCount > 0 ? 0 : totalProduct / nums[j];\\n        } else {\\n            // If there are no zeros in the array, set the result to zero for this element.\\n            finalArray[j] = 0;\\n        }\\n    }\\n    return finalArray;\\n};"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time."
                    },
                    {
                        "username": "Rohit_Dabas",
                        "content": "BRO WTF IS THIS TEST CASE 18: it shows time limit exceeded everytime i run it, My all test cases are passed except this one\\nCAN ANYONE TELL WHATS WRONG WITH CODE(JAVA)??\\nCODE:\\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int i=0;\\n\\n        int ans[] = new int[nums.length];\\n        int count=0;\\n        while(i<nums.length){\\n            int answer=1;\\n            int j =0;\\n            while(j<nums.length){\\n                if(i!=j){\\n                    answer = answer*nums[j];\\n                    j++;\\n                }else{\\n                    j++;\\n                }\\n            }\\n            ans[count]=answer;\\n            count++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n}\\n\\nTest Case looks Something like this:\\n[-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,-1,1,1,1,1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,1,1,1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,1,1,1,1,1,1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,-1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,1,1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,1,-1,-1,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,-1,1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1........................................................................]\\n"
                    },
                    {
                        "username": "RashilDudhara",
                        "content": "Your doing O(n2) test case is to catch folks like us who said screw it to the condition stating solution needs to be O(n)"
                    },
                    {
                        "username": "foal20ym",
                        "content": "[@willq1](/willq1)  Yep, that was the reason the first time. I had made an error with the index, since i used the method to divide by each of the current indexes. "
                    },
                    {
                        "username": "willq1",
                        "content": "I'm pretty sure that's O(N^2) when the problem states you need it to be in O(N). Otherwise it'll time out."
                    },
                    {
                        "username": "foal20ym",
                        "content": "My C++ code also fails that test case. I don\\'t understand what\\'s wrong. "
                    },
                    {
                        "username": "RIGIK93",
                        "content": "**A Hint**:\\nUse sliding window technique. Iterate two times, first from left to right, then from right to left, while accumulating a buffer of products."
                    },
                    {
                        "username": "neozyan",
                        "content": "make two passes, first in-order, second in-reverse, to compute products"
                    },
                    {
                        "username": "nimox",
                        "content": "JAVA SOLUTION:\n\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int ans[] = new int[n];\n        Arrays.fill(ans, 1);\n        int curr = 1;\n        for(int i = 0; i < n; i++) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        curr = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        return ans;\n    }\n}\n\nWe multiply suffix and prefix product for each element"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "basic intuition without solution -> \\n![b5cc1c65-b4ac-4cfb-b151-b79bd15d07cf.jpeg](https://assets.leetcode.com/users/images/03350759-b360-4054-b904-73612138b0af_1664570838.9668634.jpeg)\\n"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "So in this solution we took first left side count\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n_______________________________________________________________________________\\narr[0] = 1;\\narr = 1\\n\\narr[1] = arr[0] * nums[1]  // 1 * 2\\narr= 1, 2\\n\\narr[2] = arr[1] * nums[2]  //  2 * 3\\narr = 1, 2, 6\\n\\narr[3] = arr[2] * nums[3] //  6 * 4\\narr= 1, 2, 6, 24\\n\\nafter left array count we started reverse loop for arr and taken one variable called product which will be handling right count .\\n\\n____________________________________________________________________________\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n\\nint product  = 1;\\nloop -> i = nums.length-1;  i>0;  i--\\n\\narr[3] = arr[2] * product  // 6 * 1\\nproduct = product * nums[3]  // 1 * 4 \\narr = 1, 2, 6, 6\\nproduct = 4\\n\\narr[2] = arr[1] * product  //  2 * 4\\nproduct  =  product * nums[2]  //  4 * 3\\narr = 1, 2, 8, 6\\nproduct = 12\\n\\narr[1] = arr[0] * product  //  1 * 12\\nproduct  =  product * nums[1]  //  12 * 2\\narr = 1, 12, 8, 6\\nproduct = 24\\n\\n\\nloop runs till i>0 only which means till i==1 only, so for arr 0th index we will add product value only\\n\\narr[0] = product // 24\\n\\narr = 24, 12, 8, 6\\n"
                    },
                    {
                        "username": "Nbs-26",
                        "content": "The explanation is very detailed! Thank you."
                    },
                    {
                        "username": "axemaneric",
                        "content": "Great, essential problem for interviews"
                    }
                ]
            },
            {
                "id": 2036262,
                "content": [
                    {
                        "username": "gawari",
                        "content": "C++ solution:  \\n`\\n\\n\\n\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        if(0 == n)  return ans;\\n\\n        ans[0] = 1;\\n        int prod = 1;\\n        for(int i = 1; i < n; i++)\\n        {\\n            prod = prod * nums[i - 1];\\n            ans[i] = prod;\\n        }\\n\\n        prod = 1;\\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            ans[i] = prod * ans[i];\\n            prod = nums[i] * prod;\\n        }\\n\\n        return ans;\\n\\n    \\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pankajj_",
                        "content": "test case 22 does not even has an array :) "
                    },
                    {
                        "username": "Harsh790",
                        "content": "In this question if you are trying a brute force approach then there are three cases that you need to take care of \\nCase1:-- when there are no zeros\\nCase2:-when there is one zero\\nCase 3:-when there is more than one zero"
                    },
                    {
                        "username": "Yeswanth_G",
                        "content": "This is how you do it\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function(nums) {\\n    let totalProduct = 1;\\n    const n = nums.length;\\n    const zeroCount = nums.filter(nums => nums===0).length;\\n    const finalArray = new Array(n);\\n    for(let i =0; i<n;i++){\\n        if(nums[i] !== 0){\\n            totalProduct*=nums[i];\\n        }\\n    }\\n    for(let j = 0;j<n;j++){\\n        if (zeroCount === 1 && nums[j] === 0) {\\n            // If there\\'s exactly one zero in the array, the result is zero for all elements except that zero.\\n            finalArray[j] = totalProduct;\\n        } else if (zeroCount > 1 || nums[j] !== 0) {\\n            // If there are more than one zero or the current element is not zero, calculate normally.\\n            finalArray[j] = zeroCount > 0 ? 0 : totalProduct / nums[j];\\n        } else {\\n            // If there are no zeros in the array, set the result to zero for this element.\\n            finalArray[j] = 0;\\n        }\\n    }\\n    return finalArray;\\n};"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time."
                    },
                    {
                        "username": "Rohit_Dabas",
                        "content": "BRO WTF IS THIS TEST CASE 18: it shows time limit exceeded everytime i run it, My all test cases are passed except this one\\nCAN ANYONE TELL WHATS WRONG WITH CODE(JAVA)??\\nCODE:\\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int i=0;\\n\\n        int ans[] = new int[nums.length];\\n        int count=0;\\n        while(i<nums.length){\\n            int answer=1;\\n            int j =0;\\n            while(j<nums.length){\\n                if(i!=j){\\n                    answer = answer*nums[j];\\n                    j++;\\n                }else{\\n                    j++;\\n                }\\n            }\\n            ans[count]=answer;\\n            count++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n}\\n\\nTest Case looks Something like this:\\n[-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,-1,1,1,1,1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,1,1,1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,1,1,1,1,1,1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,-1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,1,1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,1,-1,-1,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,-1,1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1........................................................................]\\n"
                    },
                    {
                        "username": "RashilDudhara",
                        "content": "Your doing O(n2) test case is to catch folks like us who said screw it to the condition stating solution needs to be O(n)"
                    },
                    {
                        "username": "foal20ym",
                        "content": "[@willq1](/willq1)  Yep, that was the reason the first time. I had made an error with the index, since i used the method to divide by each of the current indexes. "
                    },
                    {
                        "username": "willq1",
                        "content": "I'm pretty sure that's O(N^2) when the problem states you need it to be in O(N). Otherwise it'll time out."
                    },
                    {
                        "username": "foal20ym",
                        "content": "My C++ code also fails that test case. I don\\'t understand what\\'s wrong. "
                    },
                    {
                        "username": "RIGIK93",
                        "content": "**A Hint**:\\nUse sliding window technique. Iterate two times, first from left to right, then from right to left, while accumulating a buffer of products."
                    },
                    {
                        "username": "neozyan",
                        "content": "make two passes, first in-order, second in-reverse, to compute products"
                    },
                    {
                        "username": "nimox",
                        "content": "JAVA SOLUTION:\n\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int ans[] = new int[n];\n        Arrays.fill(ans, 1);\n        int curr = 1;\n        for(int i = 0; i < n; i++) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        curr = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        return ans;\n    }\n}\n\nWe multiply suffix and prefix product for each element"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "basic intuition without solution -> \\n![b5cc1c65-b4ac-4cfb-b151-b79bd15d07cf.jpeg](https://assets.leetcode.com/users/images/03350759-b360-4054-b904-73612138b0af_1664570838.9668634.jpeg)\\n"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "So in this solution we took first left side count\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n_______________________________________________________________________________\\narr[0] = 1;\\narr = 1\\n\\narr[1] = arr[0] * nums[1]  // 1 * 2\\narr= 1, 2\\n\\narr[2] = arr[1] * nums[2]  //  2 * 3\\narr = 1, 2, 6\\n\\narr[3] = arr[2] * nums[3] //  6 * 4\\narr= 1, 2, 6, 24\\n\\nafter left array count we started reverse loop for arr and taken one variable called product which will be handling right count .\\n\\n____________________________________________________________________________\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n\\nint product  = 1;\\nloop -> i = nums.length-1;  i>0;  i--\\n\\narr[3] = arr[2] * product  // 6 * 1\\nproduct = product * nums[3]  // 1 * 4 \\narr = 1, 2, 6, 6\\nproduct = 4\\n\\narr[2] = arr[1] * product  //  2 * 4\\nproduct  =  product * nums[2]  //  4 * 3\\narr = 1, 2, 8, 6\\nproduct = 12\\n\\narr[1] = arr[0] * product  //  1 * 12\\nproduct  =  product * nums[1]  //  12 * 2\\narr = 1, 12, 8, 6\\nproduct = 24\\n\\n\\nloop runs till i>0 only which means till i==1 only, so for arr 0th index we will add product value only\\n\\narr[0] = product // 24\\n\\narr = 24, 12, 8, 6\\n"
                    },
                    {
                        "username": "Nbs-26",
                        "content": "The explanation is very detailed! Thank you."
                    },
                    {
                        "username": "axemaneric",
                        "content": "Great, essential problem for interviews"
                    }
                ]
            },
            {
                "id": 1980384,
                "content": [
                    {
                        "username": "gawari",
                        "content": "C++ solution:  \\n`\\n\\n\\n\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        if(0 == n)  return ans;\\n\\n        ans[0] = 1;\\n        int prod = 1;\\n        for(int i = 1; i < n; i++)\\n        {\\n            prod = prod * nums[i - 1];\\n            ans[i] = prod;\\n        }\\n\\n        prod = 1;\\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            ans[i] = prod * ans[i];\\n            prod = nums[i] * prod;\\n        }\\n\\n        return ans;\\n\\n    \\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pankajj_",
                        "content": "test case 22 does not even has an array :) "
                    },
                    {
                        "username": "Harsh790",
                        "content": "In this question if you are trying a brute force approach then there are three cases that you need to take care of \\nCase1:-- when there are no zeros\\nCase2:-when there is one zero\\nCase 3:-when there is more than one zero"
                    },
                    {
                        "username": "Yeswanth_G",
                        "content": "This is how you do it\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function(nums) {\\n    let totalProduct = 1;\\n    const n = nums.length;\\n    const zeroCount = nums.filter(nums => nums===0).length;\\n    const finalArray = new Array(n);\\n    for(let i =0; i<n;i++){\\n        if(nums[i] !== 0){\\n            totalProduct*=nums[i];\\n        }\\n    }\\n    for(let j = 0;j<n;j++){\\n        if (zeroCount === 1 && nums[j] === 0) {\\n            // If there\\'s exactly one zero in the array, the result is zero for all elements except that zero.\\n            finalArray[j] = totalProduct;\\n        } else if (zeroCount > 1 || nums[j] !== 0) {\\n            // If there are more than one zero or the current element is not zero, calculate normally.\\n            finalArray[j] = zeroCount > 0 ? 0 : totalProduct / nums[j];\\n        } else {\\n            // If there are no zeros in the array, set the result to zero for this element.\\n            finalArray[j] = 0;\\n        }\\n    }\\n    return finalArray;\\n};"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time."
                    },
                    {
                        "username": "Rohit_Dabas",
                        "content": "BRO WTF IS THIS TEST CASE 18: it shows time limit exceeded everytime i run it, My all test cases are passed except this one\\nCAN ANYONE TELL WHATS WRONG WITH CODE(JAVA)??\\nCODE:\\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int i=0;\\n\\n        int ans[] = new int[nums.length];\\n        int count=0;\\n        while(i<nums.length){\\n            int answer=1;\\n            int j =0;\\n            while(j<nums.length){\\n                if(i!=j){\\n                    answer = answer*nums[j];\\n                    j++;\\n                }else{\\n                    j++;\\n                }\\n            }\\n            ans[count]=answer;\\n            count++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n}\\n\\nTest Case looks Something like this:\\n[-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,-1,1,1,1,1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,1,1,1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,1,1,1,1,1,1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,-1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,1,1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,1,-1,-1,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,-1,1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1........................................................................]\\n"
                    },
                    {
                        "username": "RashilDudhara",
                        "content": "Your doing O(n2) test case is to catch folks like us who said screw it to the condition stating solution needs to be O(n)"
                    },
                    {
                        "username": "foal20ym",
                        "content": "[@willq1](/willq1)  Yep, that was the reason the first time. I had made an error with the index, since i used the method to divide by each of the current indexes. "
                    },
                    {
                        "username": "willq1",
                        "content": "I'm pretty sure that's O(N^2) when the problem states you need it to be in O(N). Otherwise it'll time out."
                    },
                    {
                        "username": "foal20ym",
                        "content": "My C++ code also fails that test case. I don\\'t understand what\\'s wrong. "
                    },
                    {
                        "username": "RIGIK93",
                        "content": "**A Hint**:\\nUse sliding window technique. Iterate two times, first from left to right, then from right to left, while accumulating a buffer of products."
                    },
                    {
                        "username": "neozyan",
                        "content": "make two passes, first in-order, second in-reverse, to compute products"
                    },
                    {
                        "username": "nimox",
                        "content": "JAVA SOLUTION:\n\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int ans[] = new int[n];\n        Arrays.fill(ans, 1);\n        int curr = 1;\n        for(int i = 0; i < n; i++) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        curr = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        return ans;\n    }\n}\n\nWe multiply suffix and prefix product for each element"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "basic intuition without solution -> \\n![b5cc1c65-b4ac-4cfb-b151-b79bd15d07cf.jpeg](https://assets.leetcode.com/users/images/03350759-b360-4054-b904-73612138b0af_1664570838.9668634.jpeg)\\n"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "So in this solution we took first left side count\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n_______________________________________________________________________________\\narr[0] = 1;\\narr = 1\\n\\narr[1] = arr[0] * nums[1]  // 1 * 2\\narr= 1, 2\\n\\narr[2] = arr[1] * nums[2]  //  2 * 3\\narr = 1, 2, 6\\n\\narr[3] = arr[2] * nums[3] //  6 * 4\\narr= 1, 2, 6, 24\\n\\nafter left array count we started reverse loop for arr and taken one variable called product which will be handling right count .\\n\\n____________________________________________________________________________\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n\\nint product  = 1;\\nloop -> i = nums.length-1;  i>0;  i--\\n\\narr[3] = arr[2] * product  // 6 * 1\\nproduct = product * nums[3]  // 1 * 4 \\narr = 1, 2, 6, 6\\nproduct = 4\\n\\narr[2] = arr[1] * product  //  2 * 4\\nproduct  =  product * nums[2]  //  4 * 3\\narr = 1, 2, 8, 6\\nproduct = 12\\n\\narr[1] = arr[0] * product  //  1 * 12\\nproduct  =  product * nums[1]  //  12 * 2\\narr = 1, 12, 8, 6\\nproduct = 24\\n\\n\\nloop runs till i>0 only which means till i==1 only, so for arr 0th index we will add product value only\\n\\narr[0] = product // 24\\n\\narr = 24, 12, 8, 6\\n"
                    },
                    {
                        "username": "Nbs-26",
                        "content": "The explanation is very detailed! Thank you."
                    },
                    {
                        "username": "axemaneric",
                        "content": "Great, essential problem for interviews"
                    }
                ]
            },
            {
                "id": 1925706,
                "content": [
                    {
                        "username": "gawari",
                        "content": "C++ solution:  \\n`\\n\\n\\n\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        if(0 == n)  return ans;\\n\\n        ans[0] = 1;\\n        int prod = 1;\\n        for(int i = 1; i < n; i++)\\n        {\\n            prod = prod * nums[i - 1];\\n            ans[i] = prod;\\n        }\\n\\n        prod = 1;\\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            ans[i] = prod * ans[i];\\n            prod = nums[i] * prod;\\n        }\\n\\n        return ans;\\n\\n    \\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pankajj_",
                        "content": "test case 22 does not even has an array :) "
                    },
                    {
                        "username": "Harsh790",
                        "content": "In this question if you are trying a brute force approach then there are three cases that you need to take care of \\nCase1:-- when there are no zeros\\nCase2:-when there is one zero\\nCase 3:-when there is more than one zero"
                    },
                    {
                        "username": "Yeswanth_G",
                        "content": "This is how you do it\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function(nums) {\\n    let totalProduct = 1;\\n    const n = nums.length;\\n    const zeroCount = nums.filter(nums => nums===0).length;\\n    const finalArray = new Array(n);\\n    for(let i =0; i<n;i++){\\n        if(nums[i] !== 0){\\n            totalProduct*=nums[i];\\n        }\\n    }\\n    for(let j = 0;j<n;j++){\\n        if (zeroCount === 1 && nums[j] === 0) {\\n            // If there\\'s exactly one zero in the array, the result is zero for all elements except that zero.\\n            finalArray[j] = totalProduct;\\n        } else if (zeroCount > 1 || nums[j] !== 0) {\\n            // If there are more than one zero or the current element is not zero, calculate normally.\\n            finalArray[j] = zeroCount > 0 ? 0 : totalProduct / nums[j];\\n        } else {\\n            // If there are no zeros in the array, set the result to zero for this element.\\n            finalArray[j] = 0;\\n        }\\n    }\\n    return finalArray;\\n};"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time."
                    },
                    {
                        "username": "Rohit_Dabas",
                        "content": "BRO WTF IS THIS TEST CASE 18: it shows time limit exceeded everytime i run it, My all test cases are passed except this one\\nCAN ANYONE TELL WHATS WRONG WITH CODE(JAVA)??\\nCODE:\\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int i=0;\\n\\n        int ans[] = new int[nums.length];\\n        int count=0;\\n        while(i<nums.length){\\n            int answer=1;\\n            int j =0;\\n            while(j<nums.length){\\n                if(i!=j){\\n                    answer = answer*nums[j];\\n                    j++;\\n                }else{\\n                    j++;\\n                }\\n            }\\n            ans[count]=answer;\\n            count++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n}\\n\\nTest Case looks Something like this:\\n[-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,-1,1,1,1,1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,1,1,1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,1,1,1,1,1,1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,-1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,1,1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,1,-1,-1,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,-1,1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1........................................................................]\\n"
                    },
                    {
                        "username": "RashilDudhara",
                        "content": "Your doing O(n2) test case is to catch folks like us who said screw it to the condition stating solution needs to be O(n)"
                    },
                    {
                        "username": "foal20ym",
                        "content": "[@willq1](/willq1)  Yep, that was the reason the first time. I had made an error with the index, since i used the method to divide by each of the current indexes. "
                    },
                    {
                        "username": "willq1",
                        "content": "I'm pretty sure that's O(N^2) when the problem states you need it to be in O(N). Otherwise it'll time out."
                    },
                    {
                        "username": "foal20ym",
                        "content": "My C++ code also fails that test case. I don\\'t understand what\\'s wrong. "
                    },
                    {
                        "username": "RIGIK93",
                        "content": "**A Hint**:\\nUse sliding window technique. Iterate two times, first from left to right, then from right to left, while accumulating a buffer of products."
                    },
                    {
                        "username": "neozyan",
                        "content": "make two passes, first in-order, second in-reverse, to compute products"
                    },
                    {
                        "username": "nimox",
                        "content": "JAVA SOLUTION:\n\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int ans[] = new int[n];\n        Arrays.fill(ans, 1);\n        int curr = 1;\n        for(int i = 0; i < n; i++) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        curr = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        return ans;\n    }\n}\n\nWe multiply suffix and prefix product for each element"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "basic intuition without solution -> \\n![b5cc1c65-b4ac-4cfb-b151-b79bd15d07cf.jpeg](https://assets.leetcode.com/users/images/03350759-b360-4054-b904-73612138b0af_1664570838.9668634.jpeg)\\n"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "So in this solution we took first left side count\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n_______________________________________________________________________________\\narr[0] = 1;\\narr = 1\\n\\narr[1] = arr[0] * nums[1]  // 1 * 2\\narr= 1, 2\\n\\narr[2] = arr[1] * nums[2]  //  2 * 3\\narr = 1, 2, 6\\n\\narr[3] = arr[2] * nums[3] //  6 * 4\\narr= 1, 2, 6, 24\\n\\nafter left array count we started reverse loop for arr and taken one variable called product which will be handling right count .\\n\\n____________________________________________________________________________\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n\\nint product  = 1;\\nloop -> i = nums.length-1;  i>0;  i--\\n\\narr[3] = arr[2] * product  // 6 * 1\\nproduct = product * nums[3]  // 1 * 4 \\narr = 1, 2, 6, 6\\nproduct = 4\\n\\narr[2] = arr[1] * product  //  2 * 4\\nproduct  =  product * nums[2]  //  4 * 3\\narr = 1, 2, 8, 6\\nproduct = 12\\n\\narr[1] = arr[0] * product  //  1 * 12\\nproduct  =  product * nums[1]  //  12 * 2\\narr = 1, 12, 8, 6\\nproduct = 24\\n\\n\\nloop runs till i>0 only which means till i==1 only, so for arr 0th index we will add product value only\\n\\narr[0] = product // 24\\n\\narr = 24, 12, 8, 6\\n"
                    },
                    {
                        "username": "Nbs-26",
                        "content": "The explanation is very detailed! Thank you."
                    },
                    {
                        "username": "axemaneric",
                        "content": "Great, essential problem for interviews"
                    }
                ]
            },
            {
                "id": 1833146,
                "content": [
                    {
                        "username": "gawari",
                        "content": "C++ solution:  \\n`\\n\\n\\n\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        if(0 == n)  return ans;\\n\\n        ans[0] = 1;\\n        int prod = 1;\\n        for(int i = 1; i < n; i++)\\n        {\\n            prod = prod * nums[i - 1];\\n            ans[i] = prod;\\n        }\\n\\n        prod = 1;\\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            ans[i] = prod * ans[i];\\n            prod = nums[i] * prod;\\n        }\\n\\n        return ans;\\n\\n    \\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pankajj_",
                        "content": "test case 22 does not even has an array :) "
                    },
                    {
                        "username": "Harsh790",
                        "content": "In this question if you are trying a brute force approach then there are three cases that you need to take care of \\nCase1:-- when there are no zeros\\nCase2:-when there is one zero\\nCase 3:-when there is more than one zero"
                    },
                    {
                        "username": "Yeswanth_G",
                        "content": "This is how you do it\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function(nums) {\\n    let totalProduct = 1;\\n    const n = nums.length;\\n    const zeroCount = nums.filter(nums => nums===0).length;\\n    const finalArray = new Array(n);\\n    for(let i =0; i<n;i++){\\n        if(nums[i] !== 0){\\n            totalProduct*=nums[i];\\n        }\\n    }\\n    for(let j = 0;j<n;j++){\\n        if (zeroCount === 1 && nums[j] === 0) {\\n            // If there\\'s exactly one zero in the array, the result is zero for all elements except that zero.\\n            finalArray[j] = totalProduct;\\n        } else if (zeroCount > 1 || nums[j] !== 0) {\\n            // If there are more than one zero or the current element is not zero, calculate normally.\\n            finalArray[j] = zeroCount > 0 ? 0 : totalProduct / nums[j];\\n        } else {\\n            // If there are no zeros in the array, set the result to zero for this element.\\n            finalArray[j] = 0;\\n        }\\n    }\\n    return finalArray;\\n};"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time."
                    },
                    {
                        "username": "Rohit_Dabas",
                        "content": "BRO WTF IS THIS TEST CASE 18: it shows time limit exceeded everytime i run it, My all test cases are passed except this one\\nCAN ANYONE TELL WHATS WRONG WITH CODE(JAVA)??\\nCODE:\\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int i=0;\\n\\n        int ans[] = new int[nums.length];\\n        int count=0;\\n        while(i<nums.length){\\n            int answer=1;\\n            int j =0;\\n            while(j<nums.length){\\n                if(i!=j){\\n                    answer = answer*nums[j];\\n                    j++;\\n                }else{\\n                    j++;\\n                }\\n            }\\n            ans[count]=answer;\\n            count++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n}\\n\\nTest Case looks Something like this:\\n[-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,-1,1,1,1,1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,1,1,1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,1,1,1,1,1,1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,-1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,1,1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,1,-1,-1,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,-1,1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1........................................................................]\\n"
                    },
                    {
                        "username": "RashilDudhara",
                        "content": "Your doing O(n2) test case is to catch folks like us who said screw it to the condition stating solution needs to be O(n)"
                    },
                    {
                        "username": "foal20ym",
                        "content": "[@willq1](/willq1)  Yep, that was the reason the first time. I had made an error with the index, since i used the method to divide by each of the current indexes. "
                    },
                    {
                        "username": "willq1",
                        "content": "I'm pretty sure that's O(N^2) when the problem states you need it to be in O(N). Otherwise it'll time out."
                    },
                    {
                        "username": "foal20ym",
                        "content": "My C++ code also fails that test case. I don\\'t understand what\\'s wrong. "
                    },
                    {
                        "username": "RIGIK93",
                        "content": "**A Hint**:\\nUse sliding window technique. Iterate two times, first from left to right, then from right to left, while accumulating a buffer of products."
                    },
                    {
                        "username": "neozyan",
                        "content": "make two passes, first in-order, second in-reverse, to compute products"
                    },
                    {
                        "username": "nimox",
                        "content": "JAVA SOLUTION:\n\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int ans[] = new int[n];\n        Arrays.fill(ans, 1);\n        int curr = 1;\n        for(int i = 0; i < n; i++) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        curr = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        return ans;\n    }\n}\n\nWe multiply suffix and prefix product for each element"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "basic intuition without solution -> \\n![b5cc1c65-b4ac-4cfb-b151-b79bd15d07cf.jpeg](https://assets.leetcode.com/users/images/03350759-b360-4054-b904-73612138b0af_1664570838.9668634.jpeg)\\n"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "So in this solution we took first left side count\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n_______________________________________________________________________________\\narr[0] = 1;\\narr = 1\\n\\narr[1] = arr[0] * nums[1]  // 1 * 2\\narr= 1, 2\\n\\narr[2] = arr[1] * nums[2]  //  2 * 3\\narr = 1, 2, 6\\n\\narr[3] = arr[2] * nums[3] //  6 * 4\\narr= 1, 2, 6, 24\\n\\nafter left array count we started reverse loop for arr and taken one variable called product which will be handling right count .\\n\\n____________________________________________________________________________\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n\\nint product  = 1;\\nloop -> i = nums.length-1;  i>0;  i--\\n\\narr[3] = arr[2] * product  // 6 * 1\\nproduct = product * nums[3]  // 1 * 4 \\narr = 1, 2, 6, 6\\nproduct = 4\\n\\narr[2] = arr[1] * product  //  2 * 4\\nproduct  =  product * nums[2]  //  4 * 3\\narr = 1, 2, 8, 6\\nproduct = 12\\n\\narr[1] = arr[0] * product  //  1 * 12\\nproduct  =  product * nums[1]  //  12 * 2\\narr = 1, 12, 8, 6\\nproduct = 24\\n\\n\\nloop runs till i>0 only which means till i==1 only, so for arr 0th index we will add product value only\\n\\narr[0] = product // 24\\n\\narr = 24, 12, 8, 6\\n"
                    },
                    {
                        "username": "Nbs-26",
                        "content": "The explanation is very detailed! Thank you."
                    },
                    {
                        "username": "axemaneric",
                        "content": "Great, essential problem for interviews"
                    }
                ]
            },
            {
                "id": 1785189,
                "content": [
                    {
                        "username": "gawari",
                        "content": "C++ solution:  \\n`\\n\\n\\n\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        if(0 == n)  return ans;\\n\\n        ans[0] = 1;\\n        int prod = 1;\\n        for(int i = 1; i < n; i++)\\n        {\\n            prod = prod * nums[i - 1];\\n            ans[i] = prod;\\n        }\\n\\n        prod = 1;\\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            ans[i] = prod * ans[i];\\n            prod = nums[i] * prod;\\n        }\\n\\n        return ans;\\n\\n    \\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pankajj_",
                        "content": "test case 22 does not even has an array :) "
                    },
                    {
                        "username": "Harsh790",
                        "content": "In this question if you are trying a brute force approach then there are three cases that you need to take care of \\nCase1:-- when there are no zeros\\nCase2:-when there is one zero\\nCase 3:-when there is more than one zero"
                    },
                    {
                        "username": "Yeswanth_G",
                        "content": "This is how you do it\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function(nums) {\\n    let totalProduct = 1;\\n    const n = nums.length;\\n    const zeroCount = nums.filter(nums => nums===0).length;\\n    const finalArray = new Array(n);\\n    for(let i =0; i<n;i++){\\n        if(nums[i] !== 0){\\n            totalProduct*=nums[i];\\n        }\\n    }\\n    for(let j = 0;j<n;j++){\\n        if (zeroCount === 1 && nums[j] === 0) {\\n            // If there\\'s exactly one zero in the array, the result is zero for all elements except that zero.\\n            finalArray[j] = totalProduct;\\n        } else if (zeroCount > 1 || nums[j] !== 0) {\\n            // If there are more than one zero or the current element is not zero, calculate normally.\\n            finalArray[j] = zeroCount > 0 ? 0 : totalProduct / nums[j];\\n        } else {\\n            // If there are no zeros in the array, set the result to zero for this element.\\n            finalArray[j] = 0;\\n        }\\n    }\\n    return finalArray;\\n};"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time."
                    },
                    {
                        "username": "Rohit_Dabas",
                        "content": "BRO WTF IS THIS TEST CASE 18: it shows time limit exceeded everytime i run it, My all test cases are passed except this one\\nCAN ANYONE TELL WHATS WRONG WITH CODE(JAVA)??\\nCODE:\\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int i=0;\\n\\n        int ans[] = new int[nums.length];\\n        int count=0;\\n        while(i<nums.length){\\n            int answer=1;\\n            int j =0;\\n            while(j<nums.length){\\n                if(i!=j){\\n                    answer = answer*nums[j];\\n                    j++;\\n                }else{\\n                    j++;\\n                }\\n            }\\n            ans[count]=answer;\\n            count++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n}\\n\\nTest Case looks Something like this:\\n[-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,-1,1,1,1,1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,1,1,1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,1,1,1,1,1,1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,-1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,1,1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,1,-1,-1,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,-1,1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1........................................................................]\\n"
                    },
                    {
                        "username": "RashilDudhara",
                        "content": "Your doing O(n2) test case is to catch folks like us who said screw it to the condition stating solution needs to be O(n)"
                    },
                    {
                        "username": "foal20ym",
                        "content": "[@willq1](/willq1)  Yep, that was the reason the first time. I had made an error with the index, since i used the method to divide by each of the current indexes. "
                    },
                    {
                        "username": "willq1",
                        "content": "I'm pretty sure that's O(N^2) when the problem states you need it to be in O(N). Otherwise it'll time out."
                    },
                    {
                        "username": "foal20ym",
                        "content": "My C++ code also fails that test case. I don\\'t understand what\\'s wrong. "
                    },
                    {
                        "username": "RIGIK93",
                        "content": "**A Hint**:\\nUse sliding window technique. Iterate two times, first from left to right, then from right to left, while accumulating a buffer of products."
                    },
                    {
                        "username": "neozyan",
                        "content": "make two passes, first in-order, second in-reverse, to compute products"
                    },
                    {
                        "username": "nimox",
                        "content": "JAVA SOLUTION:\n\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int ans[] = new int[n];\n        Arrays.fill(ans, 1);\n        int curr = 1;\n        for(int i = 0; i < n; i++) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        curr = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        return ans;\n    }\n}\n\nWe multiply suffix and prefix product for each element"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "basic intuition without solution -> \\n![b5cc1c65-b4ac-4cfb-b151-b79bd15d07cf.jpeg](https://assets.leetcode.com/users/images/03350759-b360-4054-b904-73612138b0af_1664570838.9668634.jpeg)\\n"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "So in this solution we took first left side count\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n_______________________________________________________________________________\\narr[0] = 1;\\narr = 1\\n\\narr[1] = arr[0] * nums[1]  // 1 * 2\\narr= 1, 2\\n\\narr[2] = arr[1] * nums[2]  //  2 * 3\\narr = 1, 2, 6\\n\\narr[3] = arr[2] * nums[3] //  6 * 4\\narr= 1, 2, 6, 24\\n\\nafter left array count we started reverse loop for arr and taken one variable called product which will be handling right count .\\n\\n____________________________________________________________________________\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n\\nint product  = 1;\\nloop -> i = nums.length-1;  i>0;  i--\\n\\narr[3] = arr[2] * product  // 6 * 1\\nproduct = product * nums[3]  // 1 * 4 \\narr = 1, 2, 6, 6\\nproduct = 4\\n\\narr[2] = arr[1] * product  //  2 * 4\\nproduct  =  product * nums[2]  //  4 * 3\\narr = 1, 2, 8, 6\\nproduct = 12\\n\\narr[1] = arr[0] * product  //  1 * 12\\nproduct  =  product * nums[1]  //  12 * 2\\narr = 1, 12, 8, 6\\nproduct = 24\\n\\n\\nloop runs till i>0 only which means till i==1 only, so for arr 0th index we will add product value only\\n\\narr[0] = product // 24\\n\\narr = 24, 12, 8, 6\\n"
                    },
                    {
                        "username": "Nbs-26",
                        "content": "The explanation is very detailed! Thank you."
                    },
                    {
                        "username": "axemaneric",
                        "content": "Great, essential problem for interviews"
                    }
                ]
            },
            {
                "id": 1625043,
                "content": [
                    {
                        "username": "gawari",
                        "content": "C++ solution:  \\n`\\n\\n\\n\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        if(0 == n)  return ans;\\n\\n        ans[0] = 1;\\n        int prod = 1;\\n        for(int i = 1; i < n; i++)\\n        {\\n            prod = prod * nums[i - 1];\\n            ans[i] = prod;\\n        }\\n\\n        prod = 1;\\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            ans[i] = prod * ans[i];\\n            prod = nums[i] * prod;\\n        }\\n\\n        return ans;\\n\\n    \\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pankajj_",
                        "content": "test case 22 does not even has an array :) "
                    },
                    {
                        "username": "Harsh790",
                        "content": "In this question if you are trying a brute force approach then there are three cases that you need to take care of \\nCase1:-- when there are no zeros\\nCase2:-when there is one zero\\nCase 3:-when there is more than one zero"
                    },
                    {
                        "username": "Yeswanth_G",
                        "content": "This is how you do it\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function(nums) {\\n    let totalProduct = 1;\\n    const n = nums.length;\\n    const zeroCount = nums.filter(nums => nums===0).length;\\n    const finalArray = new Array(n);\\n    for(let i =0; i<n;i++){\\n        if(nums[i] !== 0){\\n            totalProduct*=nums[i];\\n        }\\n    }\\n    for(let j = 0;j<n;j++){\\n        if (zeroCount === 1 && nums[j] === 0) {\\n            // If there\\'s exactly one zero in the array, the result is zero for all elements except that zero.\\n            finalArray[j] = totalProduct;\\n        } else if (zeroCount > 1 || nums[j] !== 0) {\\n            // If there are more than one zero or the current element is not zero, calculate normally.\\n            finalArray[j] = zeroCount > 0 ? 0 : totalProduct / nums[j];\\n        } else {\\n            // If there are no zeros in the array, set the result to zero for this element.\\n            finalArray[j] = 0;\\n        }\\n    }\\n    return finalArray;\\n};"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time."
                    },
                    {
                        "username": "Rohit_Dabas",
                        "content": "BRO WTF IS THIS TEST CASE 18: it shows time limit exceeded everytime i run it, My all test cases are passed except this one\\nCAN ANYONE TELL WHATS WRONG WITH CODE(JAVA)??\\nCODE:\\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int i=0;\\n\\n        int ans[] = new int[nums.length];\\n        int count=0;\\n        while(i<nums.length){\\n            int answer=1;\\n            int j =0;\\n            while(j<nums.length){\\n                if(i!=j){\\n                    answer = answer*nums[j];\\n                    j++;\\n                }else{\\n                    j++;\\n                }\\n            }\\n            ans[count]=answer;\\n            count++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n}\\n\\nTest Case looks Something like this:\\n[-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,-1,1,1,1,1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,1,1,1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,1,1,1,1,1,1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,-1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,1,1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,1,-1,-1,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,-1,1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1........................................................................]\\n"
                    },
                    {
                        "username": "RashilDudhara",
                        "content": "Your doing O(n2) test case is to catch folks like us who said screw it to the condition stating solution needs to be O(n)"
                    },
                    {
                        "username": "foal20ym",
                        "content": "[@willq1](/willq1)  Yep, that was the reason the first time. I had made an error with the index, since i used the method to divide by each of the current indexes. "
                    },
                    {
                        "username": "willq1",
                        "content": "I'm pretty sure that's O(N^2) when the problem states you need it to be in O(N). Otherwise it'll time out."
                    },
                    {
                        "username": "foal20ym",
                        "content": "My C++ code also fails that test case. I don\\'t understand what\\'s wrong. "
                    },
                    {
                        "username": "RIGIK93",
                        "content": "**A Hint**:\\nUse sliding window technique. Iterate two times, first from left to right, then from right to left, while accumulating a buffer of products."
                    },
                    {
                        "username": "neozyan",
                        "content": "make two passes, first in-order, second in-reverse, to compute products"
                    },
                    {
                        "username": "nimox",
                        "content": "JAVA SOLUTION:\n\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int ans[] = new int[n];\n        Arrays.fill(ans, 1);\n        int curr = 1;\n        for(int i = 0; i < n; i++) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        curr = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        return ans;\n    }\n}\n\nWe multiply suffix and prefix product for each element"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "basic intuition without solution -> \\n![b5cc1c65-b4ac-4cfb-b151-b79bd15d07cf.jpeg](https://assets.leetcode.com/users/images/03350759-b360-4054-b904-73612138b0af_1664570838.9668634.jpeg)\\n"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "So in this solution we took first left side count\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n_______________________________________________________________________________\\narr[0] = 1;\\narr = 1\\n\\narr[1] = arr[0] * nums[1]  // 1 * 2\\narr= 1, 2\\n\\narr[2] = arr[1] * nums[2]  //  2 * 3\\narr = 1, 2, 6\\n\\narr[3] = arr[2] * nums[3] //  6 * 4\\narr= 1, 2, 6, 24\\n\\nafter left array count we started reverse loop for arr and taken one variable called product which will be handling right count .\\n\\n____________________________________________________________________________\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n\\nint product  = 1;\\nloop -> i = nums.length-1;  i>0;  i--\\n\\narr[3] = arr[2] * product  // 6 * 1\\nproduct = product * nums[3]  // 1 * 4 \\narr = 1, 2, 6, 6\\nproduct = 4\\n\\narr[2] = arr[1] * product  //  2 * 4\\nproduct  =  product * nums[2]  //  4 * 3\\narr = 1, 2, 8, 6\\nproduct = 12\\n\\narr[1] = arr[0] * product  //  1 * 12\\nproduct  =  product * nums[1]  //  12 * 2\\narr = 1, 12, 8, 6\\nproduct = 24\\n\\n\\nloop runs till i>0 only which means till i==1 only, so for arr 0th index we will add product value only\\n\\narr[0] = product // 24\\n\\narr = 24, 12, 8, 6\\n"
                    },
                    {
                        "username": "Nbs-26",
                        "content": "The explanation is very detailed! Thank you."
                    },
                    {
                        "username": "axemaneric",
                        "content": "Great, essential problem for interviews"
                    }
                ]
            },
            {
                "id": 1775146,
                "content": [
                    {
                        "username": "gawari",
                        "content": "C++ solution:  \\n`\\n\\n\\n\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        if(0 == n)  return ans;\\n\\n        ans[0] = 1;\\n        int prod = 1;\\n        for(int i = 1; i < n; i++)\\n        {\\n            prod = prod * nums[i - 1];\\n            ans[i] = prod;\\n        }\\n\\n        prod = 1;\\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            ans[i] = prod * ans[i];\\n            prod = nums[i] * prod;\\n        }\\n\\n        return ans;\\n\\n    \\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pankajj_",
                        "content": "test case 22 does not even has an array :) "
                    },
                    {
                        "username": "Harsh790",
                        "content": "In this question if you are trying a brute force approach then there are three cases that you need to take care of \\nCase1:-- when there are no zeros\\nCase2:-when there is one zero\\nCase 3:-when there is more than one zero"
                    },
                    {
                        "username": "Yeswanth_G",
                        "content": "This is how you do it\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function(nums) {\\n    let totalProduct = 1;\\n    const n = nums.length;\\n    const zeroCount = nums.filter(nums => nums===0).length;\\n    const finalArray = new Array(n);\\n    for(let i =0; i<n;i++){\\n        if(nums[i] !== 0){\\n            totalProduct*=nums[i];\\n        }\\n    }\\n    for(let j = 0;j<n;j++){\\n        if (zeroCount === 1 && nums[j] === 0) {\\n            // If there\\'s exactly one zero in the array, the result is zero for all elements except that zero.\\n            finalArray[j] = totalProduct;\\n        } else if (zeroCount > 1 || nums[j] !== 0) {\\n            // If there are more than one zero or the current element is not zero, calculate normally.\\n            finalArray[j] = zeroCount > 0 ? 0 : totalProduct / nums[j];\\n        } else {\\n            // If there are no zeros in the array, set the result to zero for this element.\\n            finalArray[j] = 0;\\n        }\\n    }\\n    return finalArray;\\n};"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time."
                    },
                    {
                        "username": "Rohit_Dabas",
                        "content": "BRO WTF IS THIS TEST CASE 18: it shows time limit exceeded everytime i run it, My all test cases are passed except this one\\nCAN ANYONE TELL WHATS WRONG WITH CODE(JAVA)??\\nCODE:\\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int i=0;\\n\\n        int ans[] = new int[nums.length];\\n        int count=0;\\n        while(i<nums.length){\\n            int answer=1;\\n            int j =0;\\n            while(j<nums.length){\\n                if(i!=j){\\n                    answer = answer*nums[j];\\n                    j++;\\n                }else{\\n                    j++;\\n                }\\n            }\\n            ans[count]=answer;\\n            count++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n}\\n\\nTest Case looks Something like this:\\n[-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,-1,1,1,1,1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,1,1,1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,1,1,1,1,1,1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,-1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,1,1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,1,-1,-1,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,-1,1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1........................................................................]\\n"
                    },
                    {
                        "username": "RashilDudhara",
                        "content": "Your doing O(n2) test case is to catch folks like us who said screw it to the condition stating solution needs to be O(n)"
                    },
                    {
                        "username": "foal20ym",
                        "content": "[@willq1](/willq1)  Yep, that was the reason the first time. I had made an error with the index, since i used the method to divide by each of the current indexes. "
                    },
                    {
                        "username": "willq1",
                        "content": "I'm pretty sure that's O(N^2) when the problem states you need it to be in O(N). Otherwise it'll time out."
                    },
                    {
                        "username": "foal20ym",
                        "content": "My C++ code also fails that test case. I don\\'t understand what\\'s wrong. "
                    },
                    {
                        "username": "RIGIK93",
                        "content": "**A Hint**:\\nUse sliding window technique. Iterate two times, first from left to right, then from right to left, while accumulating a buffer of products."
                    },
                    {
                        "username": "neozyan",
                        "content": "make two passes, first in-order, second in-reverse, to compute products"
                    },
                    {
                        "username": "nimox",
                        "content": "JAVA SOLUTION:\n\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int ans[] = new int[n];\n        Arrays.fill(ans, 1);\n        int curr = 1;\n        for(int i = 0; i < n; i++) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        curr = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        return ans;\n    }\n}\n\nWe multiply suffix and prefix product for each element"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "basic intuition without solution -> \\n![b5cc1c65-b4ac-4cfb-b151-b79bd15d07cf.jpeg](https://assets.leetcode.com/users/images/03350759-b360-4054-b904-73612138b0af_1664570838.9668634.jpeg)\\n"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "So in this solution we took first left side count\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n_______________________________________________________________________________\\narr[0] = 1;\\narr = 1\\n\\narr[1] = arr[0] * nums[1]  // 1 * 2\\narr= 1, 2\\n\\narr[2] = arr[1] * nums[2]  //  2 * 3\\narr = 1, 2, 6\\n\\narr[3] = arr[2] * nums[3] //  6 * 4\\narr= 1, 2, 6, 24\\n\\nafter left array count we started reverse loop for arr and taken one variable called product which will be handling right count .\\n\\n____________________________________________________________________________\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n\\nint product  = 1;\\nloop -> i = nums.length-1;  i>0;  i--\\n\\narr[3] = arr[2] * product  // 6 * 1\\nproduct = product * nums[3]  // 1 * 4 \\narr = 1, 2, 6, 6\\nproduct = 4\\n\\narr[2] = arr[1] * product  //  2 * 4\\nproduct  =  product * nums[2]  //  4 * 3\\narr = 1, 2, 8, 6\\nproduct = 12\\n\\narr[1] = arr[0] * product  //  1 * 12\\nproduct  =  product * nums[1]  //  12 * 2\\narr = 1, 12, 8, 6\\nproduct = 24\\n\\n\\nloop runs till i>0 only which means till i==1 only, so for arr 0th index we will add product value only\\n\\narr[0] = product // 24\\n\\narr = 24, 12, 8, 6\\n"
                    },
                    {
                        "username": "Nbs-26",
                        "content": "The explanation is very detailed! Thank you."
                    },
                    {
                        "username": "axemaneric",
                        "content": "Great, essential problem for interviews"
                    }
                ]
            },
            {
                "id": 1574102,
                "content": [
                    {
                        "username": "gawari",
                        "content": "C++ solution:  \\n`\\n\\n\\n\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        if(0 == n)  return ans;\\n\\n        ans[0] = 1;\\n        int prod = 1;\\n        for(int i = 1; i < n; i++)\\n        {\\n            prod = prod * nums[i - 1];\\n            ans[i] = prod;\\n        }\\n\\n        prod = 1;\\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            ans[i] = prod * ans[i];\\n            prod = nums[i] * prod;\\n        }\\n\\n        return ans;\\n\\n    \\n`"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "You are so smart!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "pankajj_",
                        "content": "test case 22 does not even has an array :) "
                    },
                    {
                        "username": "Harsh790",
                        "content": "In this question if you are trying a brute force approach then there are three cases that you need to take care of \\nCase1:-- when there are no zeros\\nCase2:-when there is one zero\\nCase 3:-when there is more than one zero"
                    },
                    {
                        "username": "Yeswanth_G",
                        "content": "This is how you do it\\n\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar productExceptSelf = function(nums) {\\n    let totalProduct = 1;\\n    const n = nums.length;\\n    const zeroCount = nums.filter(nums => nums===0).length;\\n    const finalArray = new Array(n);\\n    for(let i =0; i<n;i++){\\n        if(nums[i] !== 0){\\n            totalProduct*=nums[i];\\n        }\\n    }\\n    for(let j = 0;j<n;j++){\\n        if (zeroCount === 1 && nums[j] === 0) {\\n            // If there\\'s exactly one zero in the array, the result is zero for all elements except that zero.\\n            finalArray[j] = totalProduct;\\n        } else if (zeroCount > 1 || nums[j] !== 0) {\\n            // If there are more than one zero or the current element is not zero, calculate normally.\\n            finalArray[j] = zeroCount > 0 ? 0 : totalProduct / nums[j];\\n        } else {\\n            // If there are no zeros in the array, set the result to zero for this element.\\n            finalArray[j] = 0;\\n        }\\n    }\\n    return finalArray;\\n};"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time."
                    },
                    {
                        "username": "Rohit_Dabas",
                        "content": "BRO WTF IS THIS TEST CASE 18: it shows time limit exceeded everytime i run it, My all test cases are passed except this one\\nCAN ANYONE TELL WHATS WRONG WITH CODE(JAVA)??\\nCODE:\\n\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n\\n        int i=0;\\n\\n        int ans[] = new int[nums.length];\\n        int count=0;\\n        while(i<nums.length){\\n            int answer=1;\\n            int j =0;\\n            while(j<nums.length){\\n                if(i!=j){\\n                    answer = answer*nums[j];\\n                    j++;\\n                }else{\\n                    j++;\\n                }\\n            }\\n            ans[count]=answer;\\n            count++;\\n            i++;\\n        }\\n        return ans;\\n    }\\n\\n}\\n\\nTest Case looks Something like this:\\n[-1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,-1,1,1,-1,-1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,1,-1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,-1,1,1,1,1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,-1,-1,1,1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,-1,1,-1,1,-1,1,1,1,1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,1,1,1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,1,-1,1,1,1,1,1,1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,-1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,1,1,1,-1,-1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,1,1,1,-1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,1,-1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,1,1,-1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,-1,-1,1,-1,1,1,1,1,1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,-1,-1,1,1,-1,-1,1,1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,1,-1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,-1,1,-1,-1,1,1,1,1,1,1,1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,1,1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,-1,1,-1,-1,1,-1,-1,1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,-1,-1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1........................................................................]\\n"
                    },
                    {
                        "username": "RashilDudhara",
                        "content": "Your doing O(n2) test case is to catch folks like us who said screw it to the condition stating solution needs to be O(n)"
                    },
                    {
                        "username": "foal20ym",
                        "content": "[@willq1](/willq1)  Yep, that was the reason the first time. I had made an error with the index, since i used the method to divide by each of the current indexes. "
                    },
                    {
                        "username": "willq1",
                        "content": "I'm pretty sure that's O(N^2) when the problem states you need it to be in O(N). Otherwise it'll time out."
                    },
                    {
                        "username": "foal20ym",
                        "content": "My C++ code also fails that test case. I don\\'t understand what\\'s wrong. "
                    },
                    {
                        "username": "RIGIK93",
                        "content": "**A Hint**:\\nUse sliding window technique. Iterate two times, first from left to right, then from right to left, while accumulating a buffer of products."
                    },
                    {
                        "username": "neozyan",
                        "content": "make two passes, first in-order, second in-reverse, to compute products"
                    },
                    {
                        "username": "nimox",
                        "content": "JAVA SOLUTION:\n\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        int ans[] = new int[n];\n        Arrays.fill(ans, 1);\n        int curr = 1;\n        for(int i = 0; i < n; i++) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        curr = 1;\n        for(int i = n - 1; i >= 0; i--) {\n            ans[i] *= curr;\n            curr *= nums[i];\n        }\n        return ans;\n    }\n}\n\nWe multiply suffix and prefix product for each element"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "basic intuition without solution -> \\n![b5cc1c65-b4ac-4cfb-b151-b79bd15d07cf.jpeg](https://assets.leetcode.com/users/images/03350759-b360-4054-b904-73612138b0af_1664570838.9668634.jpeg)\\n"
                    },
                    {
                        "username": "hggehlot777",
                        "content": "So in this solution we took first left side count\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n_______________________________________________________________________________\\narr[0] = 1;\\narr = 1\\n\\narr[1] = arr[0] * nums[1]  // 1 * 2\\narr= 1, 2\\n\\narr[2] = arr[1] * nums[2]  //  2 * 3\\narr = 1, 2, 6\\n\\narr[3] = arr[2] * nums[3] //  6 * 4\\narr= 1, 2, 6, 24\\n\\nafter left array count we started reverse loop for arr and taken one variable called product which will be handling right count .\\n\\n____________________________________________________________________________\\nnums = 1, 2, 3, 4\\narr = 1,2,6,24\\n\\nint product  = 1;\\nloop -> i = nums.length-1;  i>0;  i--\\n\\narr[3] = arr[2] * product  // 6 * 1\\nproduct = product * nums[3]  // 1 * 4 \\narr = 1, 2, 6, 6\\nproduct = 4\\n\\narr[2] = arr[1] * product  //  2 * 4\\nproduct  =  product * nums[2]  //  4 * 3\\narr = 1, 2, 8, 6\\nproduct = 12\\n\\narr[1] = arr[0] * product  //  1 * 12\\nproduct  =  product * nums[1]  //  12 * 2\\narr = 1, 12, 8, 6\\nproduct = 24\\n\\n\\nloop runs till i>0 only which means till i==1 only, so for arr 0th index we will add product value only\\n\\narr[0] = product // 24\\n\\narr = 24, 12, 8, 6\\n"
                    },
                    {
                        "username": "Nbs-26",
                        "content": "The explanation is very detailed! Thank you."
                    },
                    {
                        "username": "axemaneric",
                        "content": "Great, essential problem for interviews"
                    }
                ]
            },
            {
                "id": 2073707,
                "content": [
                    {
                        "username": "fractalboi",
                        "content": "TENET"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Tips:\\nfirst find out the product of complete array\\nif nums[i]!=0 then do  product/nums[i]\\nif nums[i]=0,find the product of the array excluding zero "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Actually you can see in all the comments mentioning multiply left and right product of index .To be frank yes using that hint we can solve the problem but forming the code for it in order(n) just by that hint is difficult . I came to know how to implement this only by looking at the solution . But i don't want other coders to do that just read these steps and try to implement this by yourself..\n1.firstly create an array of size n this array can be used as your output array tooo. \n2.Now In this array you need to store product of left part of index that is if array is [1,2,3,4,5] the new_array must be [1,1,2,6,24] use a loop for this\n3.Now take another loop and iterate it from backwards this is because here we want to acquire the right product of index that is consider you are at index i = n-1 so now your product should be \nbased on our consideration left * right==new_array[i] * right; here right can be a int variable\nhere right = 1; initially for index n-1; for index n-2 it will be right*array[i];\n\n(Note no need of taking another array for finding right_product within this second loop you can calculate the whole index product and right product. I hope i didn't confuse if so sorry guys :) i tried my best  )\n\nI think you understood the logic guys so now go fella's implement it....."
                    },
                    {
                        "username": "LynxSumit",
                        "content": "wtf is this shit  [-1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,1,-1,-1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,-1,1,1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,-1,1,-1,1,-1,1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1..to the infinity..]  why leetcode why "
                    },
                    {
                        "username": "saibalajivukkalkar",
                        "content": "if only one zero is present product of remaining is assigned to that index in new array and remaining as zero,\nif two or more zeros in nums all are zeroes,\nif no zeroes product of all and divide with nums[i] then assign.\n\n\n\n\ndo upvote and suggest new opinions."
                    },
                    {
                        "username": "2020B0101103",
                        "content": "class Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]: \\n        product=1\\n        for i in range(len(nums)):\\n            for j in nums:\\n                if j!=nums[i]:\\n                    product *=j\\n            nums[i]=int(product)\\n            product = 1\\n        return nums\\n\\ncan anybody tell what is the problem?\\nin this code product value is not updated to 1"
                    },
                    {
                        "username": "yashpatels",
                        "content": "My solution is failing for that long 1, -1 case with Time Limit.\\nEven though I\\'ve just 2 loops, running one after another.\\nAny suggestions?"
                    },
                    {
                        "username": "pankajj_",
                        "content": "[@yashpatels](/yashpatels)  Cool bro, lesgoo"
                    },
                    {
                        "username": "yashpatels",
                        "content": "Able to solve it! Used insert function of vector that was taking O(n+m) extra.\\nRemoving it passed the solution. :)"
                    },
                    {
                        "username": "pankajj_",
                        "content": "Maybe post your solution here so we could help"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I have three loops after another in C++. Solution accepted. Only nested loops should fail. Which programming language are you using?"
                    },
                    {
                        "username": "tatavrishi",
                        "content": "o(n) solution why isn\\'t this working\\nimport numpy\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n                temp = nums[i]\\n                nums[i]=1\\n                ans.append(round(numpy.prod(nums)))\\n                nums[i]=temp\\n            \\n\\n        return ans\\n\\n"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "anyone else getting int overflow?"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "Im using the method of creating prefix and suffix product but my result array gives me -1094795586  as a solution, can anyone tell me why?"
                    }
                ]
            },
            {
                "id": 2071607,
                "content": [
                    {
                        "username": "fractalboi",
                        "content": "TENET"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Tips:\\nfirst find out the product of complete array\\nif nums[i]!=0 then do  product/nums[i]\\nif nums[i]=0,find the product of the array excluding zero "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Actually you can see in all the comments mentioning multiply left and right product of index .To be frank yes using that hint we can solve the problem but forming the code for it in order(n) just by that hint is difficult . I came to know how to implement this only by looking at the solution . But i don't want other coders to do that just read these steps and try to implement this by yourself..\n1.firstly create an array of size n this array can be used as your output array tooo. \n2.Now In this array you need to store product of left part of index that is if array is [1,2,3,4,5] the new_array must be [1,1,2,6,24] use a loop for this\n3.Now take another loop and iterate it from backwards this is because here we want to acquire the right product of index that is consider you are at index i = n-1 so now your product should be \nbased on our consideration left * right==new_array[i] * right; here right can be a int variable\nhere right = 1; initially for index n-1; for index n-2 it will be right*array[i];\n\n(Note no need of taking another array for finding right_product within this second loop you can calculate the whole index product and right product. I hope i didn't confuse if so sorry guys :) i tried my best  )\n\nI think you understood the logic guys so now go fella's implement it....."
                    },
                    {
                        "username": "LynxSumit",
                        "content": "wtf is this shit  [-1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,1,-1,-1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,-1,1,1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,-1,1,-1,1,-1,1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1..to the infinity..]  why leetcode why "
                    },
                    {
                        "username": "saibalajivukkalkar",
                        "content": "if only one zero is present product of remaining is assigned to that index in new array and remaining as zero,\nif two or more zeros in nums all are zeroes,\nif no zeroes product of all and divide with nums[i] then assign.\n\n\n\n\ndo upvote and suggest new opinions."
                    },
                    {
                        "username": "2020B0101103",
                        "content": "class Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]: \\n        product=1\\n        for i in range(len(nums)):\\n            for j in nums:\\n                if j!=nums[i]:\\n                    product *=j\\n            nums[i]=int(product)\\n            product = 1\\n        return nums\\n\\ncan anybody tell what is the problem?\\nin this code product value is not updated to 1"
                    },
                    {
                        "username": "yashpatels",
                        "content": "My solution is failing for that long 1, -1 case with Time Limit.\\nEven though I\\'ve just 2 loops, running one after another.\\nAny suggestions?"
                    },
                    {
                        "username": "pankajj_",
                        "content": "[@yashpatels](/yashpatels)  Cool bro, lesgoo"
                    },
                    {
                        "username": "yashpatels",
                        "content": "Able to solve it! Used insert function of vector that was taking O(n+m) extra.\\nRemoving it passed the solution. :)"
                    },
                    {
                        "username": "pankajj_",
                        "content": "Maybe post your solution here so we could help"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I have three loops after another in C++. Solution accepted. Only nested loops should fail. Which programming language are you using?"
                    },
                    {
                        "username": "tatavrishi",
                        "content": "o(n) solution why isn\\'t this working\\nimport numpy\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n                temp = nums[i]\\n                nums[i]=1\\n                ans.append(round(numpy.prod(nums)))\\n                nums[i]=temp\\n            \\n\\n        return ans\\n\\n"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "anyone else getting int overflow?"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "Im using the method of creating prefix and suffix product but my result array gives me -1094795586  as a solution, can anyone tell me why?"
                    }
                ]
            },
            {
                "id": 2071483,
                "content": [
                    {
                        "username": "fractalboi",
                        "content": "TENET"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Tips:\\nfirst find out the product of complete array\\nif nums[i]!=0 then do  product/nums[i]\\nif nums[i]=0,find the product of the array excluding zero "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Actually you can see in all the comments mentioning multiply left and right product of index .To be frank yes using that hint we can solve the problem but forming the code for it in order(n) just by that hint is difficult . I came to know how to implement this only by looking at the solution . But i don't want other coders to do that just read these steps and try to implement this by yourself..\n1.firstly create an array of size n this array can be used as your output array tooo. \n2.Now In this array you need to store product of left part of index that is if array is [1,2,3,4,5] the new_array must be [1,1,2,6,24] use a loop for this\n3.Now take another loop and iterate it from backwards this is because here we want to acquire the right product of index that is consider you are at index i = n-1 so now your product should be \nbased on our consideration left * right==new_array[i] * right; here right can be a int variable\nhere right = 1; initially for index n-1; for index n-2 it will be right*array[i];\n\n(Note no need of taking another array for finding right_product within this second loop you can calculate the whole index product and right product. I hope i didn't confuse if so sorry guys :) i tried my best  )\n\nI think you understood the logic guys so now go fella's implement it....."
                    },
                    {
                        "username": "LynxSumit",
                        "content": "wtf is this shit  [-1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,1,-1,-1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,-1,1,1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,-1,1,-1,1,-1,1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1..to the infinity..]  why leetcode why "
                    },
                    {
                        "username": "saibalajivukkalkar",
                        "content": "if only one zero is present product of remaining is assigned to that index in new array and remaining as zero,\nif two or more zeros in nums all are zeroes,\nif no zeroes product of all and divide with nums[i] then assign.\n\n\n\n\ndo upvote and suggest new opinions."
                    },
                    {
                        "username": "2020B0101103",
                        "content": "class Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]: \\n        product=1\\n        for i in range(len(nums)):\\n            for j in nums:\\n                if j!=nums[i]:\\n                    product *=j\\n            nums[i]=int(product)\\n            product = 1\\n        return nums\\n\\ncan anybody tell what is the problem?\\nin this code product value is not updated to 1"
                    },
                    {
                        "username": "yashpatels",
                        "content": "My solution is failing for that long 1, -1 case with Time Limit.\\nEven though I\\'ve just 2 loops, running one after another.\\nAny suggestions?"
                    },
                    {
                        "username": "pankajj_",
                        "content": "[@yashpatels](/yashpatels)  Cool bro, lesgoo"
                    },
                    {
                        "username": "yashpatels",
                        "content": "Able to solve it! Used insert function of vector that was taking O(n+m) extra.\\nRemoving it passed the solution. :)"
                    },
                    {
                        "username": "pankajj_",
                        "content": "Maybe post your solution here so we could help"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I have three loops after another in C++. Solution accepted. Only nested loops should fail. Which programming language are you using?"
                    },
                    {
                        "username": "tatavrishi",
                        "content": "o(n) solution why isn\\'t this working\\nimport numpy\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n                temp = nums[i]\\n                nums[i]=1\\n                ans.append(round(numpy.prod(nums)))\\n                nums[i]=temp\\n            \\n\\n        return ans\\n\\n"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "anyone else getting int overflow?"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "Im using the method of creating prefix and suffix product but my result array gives me -1094795586  as a solution, can anyone tell me why?"
                    }
                ]
            },
            {
                "id": 2070891,
                "content": [
                    {
                        "username": "fractalboi",
                        "content": "TENET"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Tips:\\nfirst find out the product of complete array\\nif nums[i]!=0 then do  product/nums[i]\\nif nums[i]=0,find the product of the array excluding zero "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Actually you can see in all the comments mentioning multiply left and right product of index .To be frank yes using that hint we can solve the problem but forming the code for it in order(n) just by that hint is difficult . I came to know how to implement this only by looking at the solution . But i don't want other coders to do that just read these steps and try to implement this by yourself..\n1.firstly create an array of size n this array can be used as your output array tooo. \n2.Now In this array you need to store product of left part of index that is if array is [1,2,3,4,5] the new_array must be [1,1,2,6,24] use a loop for this\n3.Now take another loop and iterate it from backwards this is because here we want to acquire the right product of index that is consider you are at index i = n-1 so now your product should be \nbased on our consideration left * right==new_array[i] * right; here right can be a int variable\nhere right = 1; initially for index n-1; for index n-2 it will be right*array[i];\n\n(Note no need of taking another array for finding right_product within this second loop you can calculate the whole index product and right product. I hope i didn't confuse if so sorry guys :) i tried my best  )\n\nI think you understood the logic guys so now go fella's implement it....."
                    },
                    {
                        "username": "LynxSumit",
                        "content": "wtf is this shit  [-1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,1,-1,-1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,-1,1,1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,-1,1,-1,1,-1,1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1..to the infinity..]  why leetcode why "
                    },
                    {
                        "username": "saibalajivukkalkar",
                        "content": "if only one zero is present product of remaining is assigned to that index in new array and remaining as zero,\nif two or more zeros in nums all are zeroes,\nif no zeroes product of all and divide with nums[i] then assign.\n\n\n\n\ndo upvote and suggest new opinions."
                    },
                    {
                        "username": "2020B0101103",
                        "content": "class Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]: \\n        product=1\\n        for i in range(len(nums)):\\n            for j in nums:\\n                if j!=nums[i]:\\n                    product *=j\\n            nums[i]=int(product)\\n            product = 1\\n        return nums\\n\\ncan anybody tell what is the problem?\\nin this code product value is not updated to 1"
                    },
                    {
                        "username": "yashpatels",
                        "content": "My solution is failing for that long 1, -1 case with Time Limit.\\nEven though I\\'ve just 2 loops, running one after another.\\nAny suggestions?"
                    },
                    {
                        "username": "pankajj_",
                        "content": "[@yashpatels](/yashpatels)  Cool bro, lesgoo"
                    },
                    {
                        "username": "yashpatels",
                        "content": "Able to solve it! Used insert function of vector that was taking O(n+m) extra.\\nRemoving it passed the solution. :)"
                    },
                    {
                        "username": "pankajj_",
                        "content": "Maybe post your solution here so we could help"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I have three loops after another in C++. Solution accepted. Only nested loops should fail. Which programming language are you using?"
                    },
                    {
                        "username": "tatavrishi",
                        "content": "o(n) solution why isn\\'t this working\\nimport numpy\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n                temp = nums[i]\\n                nums[i]=1\\n                ans.append(round(numpy.prod(nums)))\\n                nums[i]=temp\\n            \\n\\n        return ans\\n\\n"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "anyone else getting int overflow?"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "Im using the method of creating prefix and suffix product but my result array gives me -1094795586  as a solution, can anyone tell me why?"
                    }
                ]
            },
            {
                "id": 2070378,
                "content": [
                    {
                        "username": "fractalboi",
                        "content": "TENET"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Tips:\\nfirst find out the product of complete array\\nif nums[i]!=0 then do  product/nums[i]\\nif nums[i]=0,find the product of the array excluding zero "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Actually you can see in all the comments mentioning multiply left and right product of index .To be frank yes using that hint we can solve the problem but forming the code for it in order(n) just by that hint is difficult . I came to know how to implement this only by looking at the solution . But i don't want other coders to do that just read these steps and try to implement this by yourself..\n1.firstly create an array of size n this array can be used as your output array tooo. \n2.Now In this array you need to store product of left part of index that is if array is [1,2,3,4,5] the new_array must be [1,1,2,6,24] use a loop for this\n3.Now take another loop and iterate it from backwards this is because here we want to acquire the right product of index that is consider you are at index i = n-1 so now your product should be \nbased on our consideration left * right==new_array[i] * right; here right can be a int variable\nhere right = 1; initially for index n-1; for index n-2 it will be right*array[i];\n\n(Note no need of taking another array for finding right_product within this second loop you can calculate the whole index product and right product. I hope i didn't confuse if so sorry guys :) i tried my best  )\n\nI think you understood the logic guys so now go fella's implement it....."
                    },
                    {
                        "username": "LynxSumit",
                        "content": "wtf is this shit  [-1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,1,-1,-1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,-1,1,1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,-1,1,-1,1,-1,1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1..to the infinity..]  why leetcode why "
                    },
                    {
                        "username": "saibalajivukkalkar",
                        "content": "if only one zero is present product of remaining is assigned to that index in new array and remaining as zero,\nif two or more zeros in nums all are zeroes,\nif no zeroes product of all and divide with nums[i] then assign.\n\n\n\n\ndo upvote and suggest new opinions."
                    },
                    {
                        "username": "2020B0101103",
                        "content": "class Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]: \\n        product=1\\n        for i in range(len(nums)):\\n            for j in nums:\\n                if j!=nums[i]:\\n                    product *=j\\n            nums[i]=int(product)\\n            product = 1\\n        return nums\\n\\ncan anybody tell what is the problem?\\nin this code product value is not updated to 1"
                    },
                    {
                        "username": "yashpatels",
                        "content": "My solution is failing for that long 1, -1 case with Time Limit.\\nEven though I\\'ve just 2 loops, running one after another.\\nAny suggestions?"
                    },
                    {
                        "username": "pankajj_",
                        "content": "[@yashpatels](/yashpatels)  Cool bro, lesgoo"
                    },
                    {
                        "username": "yashpatels",
                        "content": "Able to solve it! Used insert function of vector that was taking O(n+m) extra.\\nRemoving it passed the solution. :)"
                    },
                    {
                        "username": "pankajj_",
                        "content": "Maybe post your solution here so we could help"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I have three loops after another in C++. Solution accepted. Only nested loops should fail. Which programming language are you using?"
                    },
                    {
                        "username": "tatavrishi",
                        "content": "o(n) solution why isn\\'t this working\\nimport numpy\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n                temp = nums[i]\\n                nums[i]=1\\n                ans.append(round(numpy.prod(nums)))\\n                nums[i]=temp\\n            \\n\\n        return ans\\n\\n"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "anyone else getting int overflow?"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "Im using the method of creating prefix and suffix product but my result array gives me -1094795586  as a solution, can anyone tell me why?"
                    }
                ]
            },
            {
                "id": 2069076,
                "content": [
                    {
                        "username": "fractalboi",
                        "content": "TENET"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Tips:\\nfirst find out the product of complete array\\nif nums[i]!=0 then do  product/nums[i]\\nif nums[i]=0,find the product of the array excluding zero "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Actually you can see in all the comments mentioning multiply left and right product of index .To be frank yes using that hint we can solve the problem but forming the code for it in order(n) just by that hint is difficult . I came to know how to implement this only by looking at the solution . But i don't want other coders to do that just read these steps and try to implement this by yourself..\n1.firstly create an array of size n this array can be used as your output array tooo. \n2.Now In this array you need to store product of left part of index that is if array is [1,2,3,4,5] the new_array must be [1,1,2,6,24] use a loop for this\n3.Now take another loop and iterate it from backwards this is because here we want to acquire the right product of index that is consider you are at index i = n-1 so now your product should be \nbased on our consideration left * right==new_array[i] * right; here right can be a int variable\nhere right = 1; initially for index n-1; for index n-2 it will be right*array[i];\n\n(Note no need of taking another array for finding right_product within this second loop you can calculate the whole index product and right product. I hope i didn't confuse if so sorry guys :) i tried my best  )\n\nI think you understood the logic guys so now go fella's implement it....."
                    },
                    {
                        "username": "LynxSumit",
                        "content": "wtf is this shit  [-1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,1,-1,-1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,-1,1,1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,-1,1,-1,1,-1,1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1..to the infinity..]  why leetcode why "
                    },
                    {
                        "username": "saibalajivukkalkar",
                        "content": "if only one zero is present product of remaining is assigned to that index in new array and remaining as zero,\nif two or more zeros in nums all are zeroes,\nif no zeroes product of all and divide with nums[i] then assign.\n\n\n\n\ndo upvote and suggest new opinions."
                    },
                    {
                        "username": "2020B0101103",
                        "content": "class Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]: \\n        product=1\\n        for i in range(len(nums)):\\n            for j in nums:\\n                if j!=nums[i]:\\n                    product *=j\\n            nums[i]=int(product)\\n            product = 1\\n        return nums\\n\\ncan anybody tell what is the problem?\\nin this code product value is not updated to 1"
                    },
                    {
                        "username": "yashpatels",
                        "content": "My solution is failing for that long 1, -1 case with Time Limit.\\nEven though I\\'ve just 2 loops, running one after another.\\nAny suggestions?"
                    },
                    {
                        "username": "pankajj_",
                        "content": "[@yashpatels](/yashpatels)  Cool bro, lesgoo"
                    },
                    {
                        "username": "yashpatels",
                        "content": "Able to solve it! Used insert function of vector that was taking O(n+m) extra.\\nRemoving it passed the solution. :)"
                    },
                    {
                        "username": "pankajj_",
                        "content": "Maybe post your solution here so we could help"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I have three loops after another in C++. Solution accepted. Only nested loops should fail. Which programming language are you using?"
                    },
                    {
                        "username": "tatavrishi",
                        "content": "o(n) solution why isn\\'t this working\\nimport numpy\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n                temp = nums[i]\\n                nums[i]=1\\n                ans.append(round(numpy.prod(nums)))\\n                nums[i]=temp\\n            \\n\\n        return ans\\n\\n"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "anyone else getting int overflow?"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "Im using the method of creating prefix and suffix product but my result array gives me -1094795586  as a solution, can anyone tell me why?"
                    }
                ]
            },
            {
                "id": 2068646,
                "content": [
                    {
                        "username": "fractalboi",
                        "content": "TENET"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Tips:\\nfirst find out the product of complete array\\nif nums[i]!=0 then do  product/nums[i]\\nif nums[i]=0,find the product of the array excluding zero "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Actually you can see in all the comments mentioning multiply left and right product of index .To be frank yes using that hint we can solve the problem but forming the code for it in order(n) just by that hint is difficult . I came to know how to implement this only by looking at the solution . But i don't want other coders to do that just read these steps and try to implement this by yourself..\n1.firstly create an array of size n this array can be used as your output array tooo. \n2.Now In this array you need to store product of left part of index that is if array is [1,2,3,4,5] the new_array must be [1,1,2,6,24] use a loop for this\n3.Now take another loop and iterate it from backwards this is because here we want to acquire the right product of index that is consider you are at index i = n-1 so now your product should be \nbased on our consideration left * right==new_array[i] * right; here right can be a int variable\nhere right = 1; initially for index n-1; for index n-2 it will be right*array[i];\n\n(Note no need of taking another array for finding right_product within this second loop you can calculate the whole index product and right product. I hope i didn't confuse if so sorry guys :) i tried my best  )\n\nI think you understood the logic guys so now go fella's implement it....."
                    },
                    {
                        "username": "LynxSumit",
                        "content": "wtf is this shit  [-1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,1,-1,-1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,-1,1,1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,-1,1,-1,1,-1,1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1..to the infinity..]  why leetcode why "
                    },
                    {
                        "username": "saibalajivukkalkar",
                        "content": "if only one zero is present product of remaining is assigned to that index in new array and remaining as zero,\nif two or more zeros in nums all are zeroes,\nif no zeroes product of all and divide with nums[i] then assign.\n\n\n\n\ndo upvote and suggest new opinions."
                    },
                    {
                        "username": "2020B0101103",
                        "content": "class Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]: \\n        product=1\\n        for i in range(len(nums)):\\n            for j in nums:\\n                if j!=nums[i]:\\n                    product *=j\\n            nums[i]=int(product)\\n            product = 1\\n        return nums\\n\\ncan anybody tell what is the problem?\\nin this code product value is not updated to 1"
                    },
                    {
                        "username": "yashpatels",
                        "content": "My solution is failing for that long 1, -1 case with Time Limit.\\nEven though I\\'ve just 2 loops, running one after another.\\nAny suggestions?"
                    },
                    {
                        "username": "pankajj_",
                        "content": "[@yashpatels](/yashpatels)  Cool bro, lesgoo"
                    },
                    {
                        "username": "yashpatels",
                        "content": "Able to solve it! Used insert function of vector that was taking O(n+m) extra.\\nRemoving it passed the solution. :)"
                    },
                    {
                        "username": "pankajj_",
                        "content": "Maybe post your solution here so we could help"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I have three loops after another in C++. Solution accepted. Only nested loops should fail. Which programming language are you using?"
                    },
                    {
                        "username": "tatavrishi",
                        "content": "o(n) solution why isn\\'t this working\\nimport numpy\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n                temp = nums[i]\\n                nums[i]=1\\n                ans.append(round(numpy.prod(nums)))\\n                nums[i]=temp\\n            \\n\\n        return ans\\n\\n"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "anyone else getting int overflow?"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "Im using the method of creating prefix and suffix product but my result array gives me -1094795586  as a solution, can anyone tell me why?"
                    }
                ]
            },
            {
                "id": 2067076,
                "content": [
                    {
                        "username": "fractalboi",
                        "content": "TENET"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Tips:\\nfirst find out the product of complete array\\nif nums[i]!=0 then do  product/nums[i]\\nif nums[i]=0,find the product of the array excluding zero "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Actually you can see in all the comments mentioning multiply left and right product of index .To be frank yes using that hint we can solve the problem but forming the code for it in order(n) just by that hint is difficult . I came to know how to implement this only by looking at the solution . But i don't want other coders to do that just read these steps and try to implement this by yourself..\n1.firstly create an array of size n this array can be used as your output array tooo. \n2.Now In this array you need to store product of left part of index that is if array is [1,2,3,4,5] the new_array must be [1,1,2,6,24] use a loop for this\n3.Now take another loop and iterate it from backwards this is because here we want to acquire the right product of index that is consider you are at index i = n-1 so now your product should be \nbased on our consideration left * right==new_array[i] * right; here right can be a int variable\nhere right = 1; initially for index n-1; for index n-2 it will be right*array[i];\n\n(Note no need of taking another array for finding right_product within this second loop you can calculate the whole index product and right product. I hope i didn't confuse if so sorry guys :) i tried my best  )\n\nI think you understood the logic guys so now go fella's implement it....."
                    },
                    {
                        "username": "LynxSumit",
                        "content": "wtf is this shit  [-1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,1,-1,-1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,-1,1,1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,-1,1,-1,1,-1,1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1..to the infinity..]  why leetcode why "
                    },
                    {
                        "username": "saibalajivukkalkar",
                        "content": "if only one zero is present product of remaining is assigned to that index in new array and remaining as zero,\nif two or more zeros in nums all are zeroes,\nif no zeroes product of all and divide with nums[i] then assign.\n\n\n\n\ndo upvote and suggest new opinions."
                    },
                    {
                        "username": "2020B0101103",
                        "content": "class Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]: \\n        product=1\\n        for i in range(len(nums)):\\n            for j in nums:\\n                if j!=nums[i]:\\n                    product *=j\\n            nums[i]=int(product)\\n            product = 1\\n        return nums\\n\\ncan anybody tell what is the problem?\\nin this code product value is not updated to 1"
                    },
                    {
                        "username": "yashpatels",
                        "content": "My solution is failing for that long 1, -1 case with Time Limit.\\nEven though I\\'ve just 2 loops, running one after another.\\nAny suggestions?"
                    },
                    {
                        "username": "pankajj_",
                        "content": "[@yashpatels](/yashpatels)  Cool bro, lesgoo"
                    },
                    {
                        "username": "yashpatels",
                        "content": "Able to solve it! Used insert function of vector that was taking O(n+m) extra.\\nRemoving it passed the solution. :)"
                    },
                    {
                        "username": "pankajj_",
                        "content": "Maybe post your solution here so we could help"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I have three loops after another in C++. Solution accepted. Only nested loops should fail. Which programming language are you using?"
                    },
                    {
                        "username": "tatavrishi",
                        "content": "o(n) solution why isn\\'t this working\\nimport numpy\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n                temp = nums[i]\\n                nums[i]=1\\n                ans.append(round(numpy.prod(nums)))\\n                nums[i]=temp\\n            \\n\\n        return ans\\n\\n"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "anyone else getting int overflow?"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "Im using the method of creating prefix and suffix product but my result array gives me -1094795586  as a solution, can anyone tell me why?"
                    }
                ]
            },
            {
                "id": 2064866,
                "content": [
                    {
                        "username": "fractalboi",
                        "content": "TENET"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Tips:\\nfirst find out the product of complete array\\nif nums[i]!=0 then do  product/nums[i]\\nif nums[i]=0,find the product of the array excluding zero "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Actually you can see in all the comments mentioning multiply left and right product of index .To be frank yes using that hint we can solve the problem but forming the code for it in order(n) just by that hint is difficult . I came to know how to implement this only by looking at the solution . But i don't want other coders to do that just read these steps and try to implement this by yourself..\n1.firstly create an array of size n this array can be used as your output array tooo. \n2.Now In this array you need to store product of left part of index that is if array is [1,2,3,4,5] the new_array must be [1,1,2,6,24] use a loop for this\n3.Now take another loop and iterate it from backwards this is because here we want to acquire the right product of index that is consider you are at index i = n-1 so now your product should be \nbased on our consideration left * right==new_array[i] * right; here right can be a int variable\nhere right = 1; initially for index n-1; for index n-2 it will be right*array[i];\n\n(Note no need of taking another array for finding right_product within this second loop you can calculate the whole index product and right product. I hope i didn't confuse if so sorry guys :) i tried my best  )\n\nI think you understood the logic guys so now go fella's implement it....."
                    },
                    {
                        "username": "LynxSumit",
                        "content": "wtf is this shit  [-1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,1,-1,-1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,-1,1,1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,-1,1,-1,1,-1,1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1..to the infinity..]  why leetcode why "
                    },
                    {
                        "username": "saibalajivukkalkar",
                        "content": "if only one zero is present product of remaining is assigned to that index in new array and remaining as zero,\nif two or more zeros in nums all are zeroes,\nif no zeroes product of all and divide with nums[i] then assign.\n\n\n\n\ndo upvote and suggest new opinions."
                    },
                    {
                        "username": "2020B0101103",
                        "content": "class Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]: \\n        product=1\\n        for i in range(len(nums)):\\n            for j in nums:\\n                if j!=nums[i]:\\n                    product *=j\\n            nums[i]=int(product)\\n            product = 1\\n        return nums\\n\\ncan anybody tell what is the problem?\\nin this code product value is not updated to 1"
                    },
                    {
                        "username": "yashpatels",
                        "content": "My solution is failing for that long 1, -1 case with Time Limit.\\nEven though I\\'ve just 2 loops, running one after another.\\nAny suggestions?"
                    },
                    {
                        "username": "pankajj_",
                        "content": "[@yashpatels](/yashpatels)  Cool bro, lesgoo"
                    },
                    {
                        "username": "yashpatels",
                        "content": "Able to solve it! Used insert function of vector that was taking O(n+m) extra.\\nRemoving it passed the solution. :)"
                    },
                    {
                        "username": "pankajj_",
                        "content": "Maybe post your solution here so we could help"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I have three loops after another in C++. Solution accepted. Only nested loops should fail. Which programming language are you using?"
                    },
                    {
                        "username": "tatavrishi",
                        "content": "o(n) solution why isn\\'t this working\\nimport numpy\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n                temp = nums[i]\\n                nums[i]=1\\n                ans.append(round(numpy.prod(nums)))\\n                nums[i]=temp\\n            \\n\\n        return ans\\n\\n"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "anyone else getting int overflow?"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "Im using the method of creating prefix and suffix product but my result array gives me -1094795586  as a solution, can anyone tell me why?"
                    }
                ]
            },
            {
                "id": 2064825,
                "content": [
                    {
                        "username": "fractalboi",
                        "content": "TENET"
                    },
                    {
                        "username": "Ravitejai1",
                        "content": "Tips:\\nfirst find out the product of complete array\\nif nums[i]!=0 then do  product/nums[i]\\nif nums[i]=0,find the product of the array excluding zero "
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "Manidgyf_6",
                        "content": "Actually you can see in all the comments mentioning multiply left and right product of index .To be frank yes using that hint we can solve the problem but forming the code for it in order(n) just by that hint is difficult . I came to know how to implement this only by looking at the solution . But i don't want other coders to do that just read these steps and try to implement this by yourself..\n1.firstly create an array of size n this array can be used as your output array tooo. \n2.Now In this array you need to store product of left part of index that is if array is [1,2,3,4,5] the new_array must be [1,1,2,6,24] use a loop for this\n3.Now take another loop and iterate it from backwards this is because here we want to acquire the right product of index that is consider you are at index i = n-1 so now your product should be \nbased on our consideration left * right==new_array[i] * right; here right can be a int variable\nhere right = 1; initially for index n-1; for index n-2 it will be right*array[i];\n\n(Note no need of taking another array for finding right_product within this second loop you can calculate the whole index product and right product. I hope i didn't confuse if so sorry guys :) i tried my best  )\n\nI think you understood the logic guys so now go fella's implement it....."
                    },
                    {
                        "username": "LynxSumit",
                        "content": "wtf is this shit  [-1,-1,1,-1,-1,-1,1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,1,1,-1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,1,1,-1,1,1,1,-1,-1,1,-1,1,1,1,1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,-1,1,1,-1,1,1,1,1,-1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,1,-1,1,-1,1,1,-1,1,-1,-1,-1,1,1,-1,-1,1,1,-1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,-1,1,1,1,-1,-1,1,1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,-1,1,1,-1,-1,1,-1,1,-1,-1,1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,1,1,1,1,-1,1,1,1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,1,-1,-1,-1,-1,-1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,-1,1,-1,-1,-1,1,1,1,1,-1,1,1,-1,-1,1,1,-1,1,-1,1,1,1,1,1,1,1,-1,1,-1,1,1,1,1,1,-1,1,1,1,1,1,-1,-1,-1,1,-1,-1,-1,1,1,1,-1,-1,1,1,-1,1,1,1,-1,1,-1,1,-1,-1,-1,1,1,-1,-1,-1,1,1,1,-1,1,1,-1,1,1,1,-1,-1,-1,1,-1,1,1,1,-1,1,-1,1,1,-1,1,1,1,1,1,-1,1,-1,1,-1,1,-1,-1,1,1,1,-1,1,-1,-1,1,-1,1,1,-1,1,1,1,1,1,1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,1,1,1,-1,1,1,-1,1,-1,1,-1,1,1,-1,1,1,-1,1,-1,1,-1,1,-1,-1,-1,1,-1,-1,1,1,1,-1,-1,-1,-1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,-1,1,1,1,1,1,1,1,1,1,1,1,-1,1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,-1,-1,1,-1,1,1,-1,-1,-1,1,-1,1,1,-1,-1,1,1,1,1,1,-1,-1,-1,-1,1,1,1,1,-1,-1,1,1,1,-1,-1,-1,1,-1,-1,-1,-1,-1,1,1,-1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,1,1,1,-1,1,1,-1,1,1,-1,-1,1,-1,-1,1,1,-1,1,-1,-1,-1,1,1,1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,1,-1,-1,-1,-1,1,-1,1,1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,1,1,-1,-1,-1,1..to the infinity..]  why leetcode why "
                    },
                    {
                        "username": "saibalajivukkalkar",
                        "content": "if only one zero is present product of remaining is assigned to that index in new array and remaining as zero,\nif two or more zeros in nums all are zeroes,\nif no zeroes product of all and divide with nums[i] then assign.\n\n\n\n\ndo upvote and suggest new opinions."
                    },
                    {
                        "username": "2020B0101103",
                        "content": "class Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]: \\n        product=1\\n        for i in range(len(nums)):\\n            for j in nums:\\n                if j!=nums[i]:\\n                    product *=j\\n            nums[i]=int(product)\\n            product = 1\\n        return nums\\n\\ncan anybody tell what is the problem?\\nin this code product value is not updated to 1"
                    },
                    {
                        "username": "yashpatels",
                        "content": "My solution is failing for that long 1, -1 case with Time Limit.\\nEven though I\\'ve just 2 loops, running one after another.\\nAny suggestions?"
                    },
                    {
                        "username": "pankajj_",
                        "content": "[@yashpatels](/yashpatels)  Cool bro, lesgoo"
                    },
                    {
                        "username": "yashpatels",
                        "content": "Able to solve it! Used insert function of vector that was taking O(n+m) extra.\\nRemoving it passed the solution. :)"
                    },
                    {
                        "username": "pankajj_",
                        "content": "Maybe post your solution here so we could help"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "I have three loops after another in C++. Solution accepted. Only nested loops should fail. Which programming language are you using?"
                    },
                    {
                        "username": "tatavrishi",
                        "content": "o(n) solution why isn\\'t this working\\nimport numpy\\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n                temp = nums[i]\\n                nums[i]=1\\n                ans.append(round(numpy.prod(nums)))\\n                nums[i]=temp\\n            \\n\\n        return ans\\n\\n"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "anyone else getting int overflow?"
                    },
                    {
                        "username": "Edwin9S",
                        "content": "Im using the method of creating prefix and suffix product but my result array gives me -1094795586  as a solution, can anyone tell me why?"
                    }
                ]
            },
            {
                "id": 2063201,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "I used an O(n^2) solution, im posting it here because it fails over time limits:\n```\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        ans = []\n        for i in range(0,len(nums)):\n            ans.append(1)\n            for j in range(0, len(nums)):\n                if j == i:\n                    continue \n                ans[i] = nums[j] * ans[i]\n        \n        return ans \n```\n\nBut you get time limit exceeded. Reading the editorial I don't think this is a reasonable 'leetcode' type question, it's almost completely mathematical. I hope that the O(n^2) approach would be accepted in a job interview."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "They could ask you to come up with a more efficient method, than brute force.\nO(n^2) is very bad. I don't think that will get accepted."
                    },
                    {
                        "username": "cphillips09",
                        "content": "Would love some help. I spent too much time on this problem and thought I had a solution but kept getting an unexpected result using javascript:\\n\\nconst answer = [];\\nfor (let i = 0; i < nums.length; i++) {\\n    let tempArr = nums;\\n    tempArr[i] = 1;\\n    answer[i] = tempArr.reduce((a, b) => a * b);\\n}\\nreturn answer;\\n\\nFor the testcase [1, 2, 3, 4] I was getting [24, 12, 4, 1] as the output instead of [24, 12, 8, 6] and I have no idea why. For the third and forth iteration of the loop the tempArr should be [1, 2, 1, 4] and [1, 2, 3, 1] which should reduce to 8 and 6 respectively... what am I doing wrong?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The product of the entire array will be divisible by any number within. That said, your current result is the overall product divided by the current number. The only issue you now have is dealing with zeros. `Hint`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "itmevic",
                        "content": "\nWarning: Contains answer\n\nQuestion : Is my code O(n) run time?\n`\nvar productExceptSelf = function(nums) {\n\n    //Store product ith element with everything to its left\n    let left = []\n    //Store product ith element with everything to its right\n    let right = []\n\n    let product = 1\n    let result = []\n\n    for(let i = 0; i < nums.length; i++){\n        product *= nums[i]\n        left.push(product)\n    }\n    product = 1\n    for(let i = nums.length-1; i >= 0 ; i--){\n        product *= nums[i]\n        right.unshift(product)\n    }\n    for(let i = 0; i < nums.length; i++){\n        if(i === 0)\n          product = right[i+1]\n        else if(i === nums.length-1)\n          product = left[i-1]  \n        else\n            product = right[i+1]* left[i-1]\n        result.push(product)\n    }\n        return result\n};`\n\n"
                    },
                    {
                        "username": "Zomgnomes",
                        "content": "This is an absolutely garbage question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "just overload the division operator in c++ and if that does not work punch the person in the face for giving you a stupid fucking gotcha problem.\n\nno one writes DP in real life and you would never handicap yourself to do such a thing.\n\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Division is not allowed and does not work, if the element is zero."
                    },
                    {
                        "username": "Artemchege",
                        "content": "... to the product of all the elements...\\n\\nit means that you should multiple each number. \\n[1,2,3,4] if i = 0, then we should remove 1 from nums and multiply 2 * 3 * 4"
                    },
                    {
                        "username": "dnt1997",
                        "content": "So using nested for loop is not allowed?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would be O(n^2)."
                    },
                    {
                        "username": "user2411qn",
                        "content": "Use reduce method if you are using javascript"
                    },
                    {
                        "username": "Zantus",
                        "content": "Its pretty simple if we just take the product of the right side elements and store it in a variable(x) and take product of left side of elements and store it in a variable(y) and the take product of both x*y and then update the array. easy solution."
                    }
                ]
            },
            {
                "id": 2062006,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "I used an O(n^2) solution, im posting it here because it fails over time limits:\n```\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        ans = []\n        for i in range(0,len(nums)):\n            ans.append(1)\n            for j in range(0, len(nums)):\n                if j == i:\n                    continue \n                ans[i] = nums[j] * ans[i]\n        \n        return ans \n```\n\nBut you get time limit exceeded. Reading the editorial I don't think this is a reasonable 'leetcode' type question, it's almost completely mathematical. I hope that the O(n^2) approach would be accepted in a job interview."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "They could ask you to come up with a more efficient method, than brute force.\nO(n^2) is very bad. I don't think that will get accepted."
                    },
                    {
                        "username": "cphillips09",
                        "content": "Would love some help. I spent too much time on this problem and thought I had a solution but kept getting an unexpected result using javascript:\\n\\nconst answer = [];\\nfor (let i = 0; i < nums.length; i++) {\\n    let tempArr = nums;\\n    tempArr[i] = 1;\\n    answer[i] = tempArr.reduce((a, b) => a * b);\\n}\\nreturn answer;\\n\\nFor the testcase [1, 2, 3, 4] I was getting [24, 12, 4, 1] as the output instead of [24, 12, 8, 6] and I have no idea why. For the third and forth iteration of the loop the tempArr should be [1, 2, 1, 4] and [1, 2, 3, 1] which should reduce to 8 and 6 respectively... what am I doing wrong?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The product of the entire array will be divisible by any number within. That said, your current result is the overall product divided by the current number. The only issue you now have is dealing with zeros. `Hint`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "itmevic",
                        "content": "\nWarning: Contains answer\n\nQuestion : Is my code O(n) run time?\n`\nvar productExceptSelf = function(nums) {\n\n    //Store product ith element with everything to its left\n    let left = []\n    //Store product ith element with everything to its right\n    let right = []\n\n    let product = 1\n    let result = []\n\n    for(let i = 0; i < nums.length; i++){\n        product *= nums[i]\n        left.push(product)\n    }\n    product = 1\n    for(let i = nums.length-1; i >= 0 ; i--){\n        product *= nums[i]\n        right.unshift(product)\n    }\n    for(let i = 0; i < nums.length; i++){\n        if(i === 0)\n          product = right[i+1]\n        else if(i === nums.length-1)\n          product = left[i-1]  \n        else\n            product = right[i+1]* left[i-1]\n        result.push(product)\n    }\n        return result\n};`\n\n"
                    },
                    {
                        "username": "Zomgnomes",
                        "content": "This is an absolutely garbage question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "just overload the division operator in c++ and if that does not work punch the person in the face for giving you a stupid fucking gotcha problem.\n\nno one writes DP in real life and you would never handicap yourself to do such a thing.\n\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Division is not allowed and does not work, if the element is zero."
                    },
                    {
                        "username": "Artemchege",
                        "content": "... to the product of all the elements...\\n\\nit means that you should multiple each number. \\n[1,2,3,4] if i = 0, then we should remove 1 from nums and multiply 2 * 3 * 4"
                    },
                    {
                        "username": "dnt1997",
                        "content": "So using nested for loop is not allowed?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would be O(n^2)."
                    },
                    {
                        "username": "user2411qn",
                        "content": "Use reduce method if you are using javascript"
                    },
                    {
                        "username": "Zantus",
                        "content": "Its pretty simple if we just take the product of the right side elements and store it in a variable(x) and take product of left side of elements and store it in a variable(y) and the take product of both x*y and then update the array. easy solution."
                    }
                ]
            },
            {
                "id": 2061753,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "I used an O(n^2) solution, im posting it here because it fails over time limits:\n```\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        ans = []\n        for i in range(0,len(nums)):\n            ans.append(1)\n            for j in range(0, len(nums)):\n                if j == i:\n                    continue \n                ans[i] = nums[j] * ans[i]\n        \n        return ans \n```\n\nBut you get time limit exceeded. Reading the editorial I don't think this is a reasonable 'leetcode' type question, it's almost completely mathematical. I hope that the O(n^2) approach would be accepted in a job interview."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "They could ask you to come up with a more efficient method, than brute force.\nO(n^2) is very bad. I don't think that will get accepted."
                    },
                    {
                        "username": "cphillips09",
                        "content": "Would love some help. I spent too much time on this problem and thought I had a solution but kept getting an unexpected result using javascript:\\n\\nconst answer = [];\\nfor (let i = 0; i < nums.length; i++) {\\n    let tempArr = nums;\\n    tempArr[i] = 1;\\n    answer[i] = tempArr.reduce((a, b) => a * b);\\n}\\nreturn answer;\\n\\nFor the testcase [1, 2, 3, 4] I was getting [24, 12, 4, 1] as the output instead of [24, 12, 8, 6] and I have no idea why. For the third and forth iteration of the loop the tempArr should be [1, 2, 1, 4] and [1, 2, 3, 1] which should reduce to 8 and 6 respectively... what am I doing wrong?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The product of the entire array will be divisible by any number within. That said, your current result is the overall product divided by the current number. The only issue you now have is dealing with zeros. `Hint`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "itmevic",
                        "content": "\nWarning: Contains answer\n\nQuestion : Is my code O(n) run time?\n`\nvar productExceptSelf = function(nums) {\n\n    //Store product ith element with everything to its left\n    let left = []\n    //Store product ith element with everything to its right\n    let right = []\n\n    let product = 1\n    let result = []\n\n    for(let i = 0; i < nums.length; i++){\n        product *= nums[i]\n        left.push(product)\n    }\n    product = 1\n    for(let i = nums.length-1; i >= 0 ; i--){\n        product *= nums[i]\n        right.unshift(product)\n    }\n    for(let i = 0; i < nums.length; i++){\n        if(i === 0)\n          product = right[i+1]\n        else if(i === nums.length-1)\n          product = left[i-1]  \n        else\n            product = right[i+1]* left[i-1]\n        result.push(product)\n    }\n        return result\n};`\n\n"
                    },
                    {
                        "username": "Zomgnomes",
                        "content": "This is an absolutely garbage question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "just overload the division operator in c++ and if that does not work punch the person in the face for giving you a stupid fucking gotcha problem.\n\nno one writes DP in real life and you would never handicap yourself to do such a thing.\n\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Division is not allowed and does not work, if the element is zero."
                    },
                    {
                        "username": "Artemchege",
                        "content": "... to the product of all the elements...\\n\\nit means that you should multiple each number. \\n[1,2,3,4] if i = 0, then we should remove 1 from nums and multiply 2 * 3 * 4"
                    },
                    {
                        "username": "dnt1997",
                        "content": "So using nested for loop is not allowed?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would be O(n^2)."
                    },
                    {
                        "username": "user2411qn",
                        "content": "Use reduce method if you are using javascript"
                    },
                    {
                        "username": "Zantus",
                        "content": "Its pretty simple if we just take the product of the right side elements and store it in a variable(x) and take product of left side of elements and store it in a variable(y) and the take product of both x*y and then update the array. easy solution."
                    }
                ]
            },
            {
                "id": 2058888,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "I used an O(n^2) solution, im posting it here because it fails over time limits:\n```\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        ans = []\n        for i in range(0,len(nums)):\n            ans.append(1)\n            for j in range(0, len(nums)):\n                if j == i:\n                    continue \n                ans[i] = nums[j] * ans[i]\n        \n        return ans \n```\n\nBut you get time limit exceeded. Reading the editorial I don't think this is a reasonable 'leetcode' type question, it's almost completely mathematical. I hope that the O(n^2) approach would be accepted in a job interview."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "They could ask you to come up with a more efficient method, than brute force.\nO(n^2) is very bad. I don't think that will get accepted."
                    },
                    {
                        "username": "cphillips09",
                        "content": "Would love some help. I spent too much time on this problem and thought I had a solution but kept getting an unexpected result using javascript:\\n\\nconst answer = [];\\nfor (let i = 0; i < nums.length; i++) {\\n    let tempArr = nums;\\n    tempArr[i] = 1;\\n    answer[i] = tempArr.reduce((a, b) => a * b);\\n}\\nreturn answer;\\n\\nFor the testcase [1, 2, 3, 4] I was getting [24, 12, 4, 1] as the output instead of [24, 12, 8, 6] and I have no idea why. For the third and forth iteration of the loop the tempArr should be [1, 2, 1, 4] and [1, 2, 3, 1] which should reduce to 8 and 6 respectively... what am I doing wrong?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The product of the entire array will be divisible by any number within. That said, your current result is the overall product divided by the current number. The only issue you now have is dealing with zeros. `Hint`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "itmevic",
                        "content": "\nWarning: Contains answer\n\nQuestion : Is my code O(n) run time?\n`\nvar productExceptSelf = function(nums) {\n\n    //Store product ith element with everything to its left\n    let left = []\n    //Store product ith element with everything to its right\n    let right = []\n\n    let product = 1\n    let result = []\n\n    for(let i = 0; i < nums.length; i++){\n        product *= nums[i]\n        left.push(product)\n    }\n    product = 1\n    for(let i = nums.length-1; i >= 0 ; i--){\n        product *= nums[i]\n        right.unshift(product)\n    }\n    for(let i = 0; i < nums.length; i++){\n        if(i === 0)\n          product = right[i+1]\n        else if(i === nums.length-1)\n          product = left[i-1]  \n        else\n            product = right[i+1]* left[i-1]\n        result.push(product)\n    }\n        return result\n};`\n\n"
                    },
                    {
                        "username": "Zomgnomes",
                        "content": "This is an absolutely garbage question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "just overload the division operator in c++ and if that does not work punch the person in the face for giving you a stupid fucking gotcha problem.\n\nno one writes DP in real life and you would never handicap yourself to do such a thing.\n\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Division is not allowed and does not work, if the element is zero."
                    },
                    {
                        "username": "Artemchege",
                        "content": "... to the product of all the elements...\\n\\nit means that you should multiple each number. \\n[1,2,3,4] if i = 0, then we should remove 1 from nums and multiply 2 * 3 * 4"
                    },
                    {
                        "username": "dnt1997",
                        "content": "So using nested for loop is not allowed?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would be O(n^2)."
                    },
                    {
                        "username": "user2411qn",
                        "content": "Use reduce method if you are using javascript"
                    },
                    {
                        "username": "Zantus",
                        "content": "Its pretty simple if we just take the product of the right side elements and store it in a variable(x) and take product of left side of elements and store it in a variable(y) and the take product of both x*y and then update the array. easy solution."
                    }
                ]
            },
            {
                "id": 2055413,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "I used an O(n^2) solution, im posting it here because it fails over time limits:\n```\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        ans = []\n        for i in range(0,len(nums)):\n            ans.append(1)\n            for j in range(0, len(nums)):\n                if j == i:\n                    continue \n                ans[i] = nums[j] * ans[i]\n        \n        return ans \n```\n\nBut you get time limit exceeded. Reading the editorial I don't think this is a reasonable 'leetcode' type question, it's almost completely mathematical. I hope that the O(n^2) approach would be accepted in a job interview."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "They could ask you to come up with a more efficient method, than brute force.\nO(n^2) is very bad. I don't think that will get accepted."
                    },
                    {
                        "username": "cphillips09",
                        "content": "Would love some help. I spent too much time on this problem and thought I had a solution but kept getting an unexpected result using javascript:\\n\\nconst answer = [];\\nfor (let i = 0; i < nums.length; i++) {\\n    let tempArr = nums;\\n    tempArr[i] = 1;\\n    answer[i] = tempArr.reduce((a, b) => a * b);\\n}\\nreturn answer;\\n\\nFor the testcase [1, 2, 3, 4] I was getting [24, 12, 4, 1] as the output instead of [24, 12, 8, 6] and I have no idea why. For the third and forth iteration of the loop the tempArr should be [1, 2, 1, 4] and [1, 2, 3, 1] which should reduce to 8 and 6 respectively... what am I doing wrong?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The product of the entire array will be divisible by any number within. That said, your current result is the overall product divided by the current number. The only issue you now have is dealing with zeros. `Hint`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "itmevic",
                        "content": "\nWarning: Contains answer\n\nQuestion : Is my code O(n) run time?\n`\nvar productExceptSelf = function(nums) {\n\n    //Store product ith element with everything to its left\n    let left = []\n    //Store product ith element with everything to its right\n    let right = []\n\n    let product = 1\n    let result = []\n\n    for(let i = 0; i < nums.length; i++){\n        product *= nums[i]\n        left.push(product)\n    }\n    product = 1\n    for(let i = nums.length-1; i >= 0 ; i--){\n        product *= nums[i]\n        right.unshift(product)\n    }\n    for(let i = 0; i < nums.length; i++){\n        if(i === 0)\n          product = right[i+1]\n        else if(i === nums.length-1)\n          product = left[i-1]  \n        else\n            product = right[i+1]* left[i-1]\n        result.push(product)\n    }\n        return result\n};`\n\n"
                    },
                    {
                        "username": "Zomgnomes",
                        "content": "This is an absolutely garbage question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "just overload the division operator in c++ and if that does not work punch the person in the face for giving you a stupid fucking gotcha problem.\n\nno one writes DP in real life and you would never handicap yourself to do such a thing.\n\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Division is not allowed and does not work, if the element is zero."
                    },
                    {
                        "username": "Artemchege",
                        "content": "... to the product of all the elements...\\n\\nit means that you should multiple each number. \\n[1,2,3,4] if i = 0, then we should remove 1 from nums and multiply 2 * 3 * 4"
                    },
                    {
                        "username": "dnt1997",
                        "content": "So using nested for loop is not allowed?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would be O(n^2)."
                    },
                    {
                        "username": "user2411qn",
                        "content": "Use reduce method if you are using javascript"
                    },
                    {
                        "username": "Zantus",
                        "content": "Its pretty simple if we just take the product of the right side elements and store it in a variable(x) and take product of left side of elements and store it in a variable(y) and the take product of both x*y and then update the array. easy solution."
                    }
                ]
            },
            {
                "id": 2050930,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "I used an O(n^2) solution, im posting it here because it fails over time limits:\n```\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        ans = []\n        for i in range(0,len(nums)):\n            ans.append(1)\n            for j in range(0, len(nums)):\n                if j == i:\n                    continue \n                ans[i] = nums[j] * ans[i]\n        \n        return ans \n```\n\nBut you get time limit exceeded. Reading the editorial I don't think this is a reasonable 'leetcode' type question, it's almost completely mathematical. I hope that the O(n^2) approach would be accepted in a job interview."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "They could ask you to come up with a more efficient method, than brute force.\nO(n^2) is very bad. I don't think that will get accepted."
                    },
                    {
                        "username": "cphillips09",
                        "content": "Would love some help. I spent too much time on this problem and thought I had a solution but kept getting an unexpected result using javascript:\\n\\nconst answer = [];\\nfor (let i = 0; i < nums.length; i++) {\\n    let tempArr = nums;\\n    tempArr[i] = 1;\\n    answer[i] = tempArr.reduce((a, b) => a * b);\\n}\\nreturn answer;\\n\\nFor the testcase [1, 2, 3, 4] I was getting [24, 12, 4, 1] as the output instead of [24, 12, 8, 6] and I have no idea why. For the third and forth iteration of the loop the tempArr should be [1, 2, 1, 4] and [1, 2, 3, 1] which should reduce to 8 and 6 respectively... what am I doing wrong?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The product of the entire array will be divisible by any number within. That said, your current result is the overall product divided by the current number. The only issue you now have is dealing with zeros. `Hint`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "itmevic",
                        "content": "\nWarning: Contains answer\n\nQuestion : Is my code O(n) run time?\n`\nvar productExceptSelf = function(nums) {\n\n    //Store product ith element with everything to its left\n    let left = []\n    //Store product ith element with everything to its right\n    let right = []\n\n    let product = 1\n    let result = []\n\n    for(let i = 0; i < nums.length; i++){\n        product *= nums[i]\n        left.push(product)\n    }\n    product = 1\n    for(let i = nums.length-1; i >= 0 ; i--){\n        product *= nums[i]\n        right.unshift(product)\n    }\n    for(let i = 0; i < nums.length; i++){\n        if(i === 0)\n          product = right[i+1]\n        else if(i === nums.length-1)\n          product = left[i-1]  \n        else\n            product = right[i+1]* left[i-1]\n        result.push(product)\n    }\n        return result\n};`\n\n"
                    },
                    {
                        "username": "Zomgnomes",
                        "content": "This is an absolutely garbage question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "just overload the division operator in c++ and if that does not work punch the person in the face for giving you a stupid fucking gotcha problem.\n\nno one writes DP in real life and you would never handicap yourself to do such a thing.\n\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Division is not allowed and does not work, if the element is zero."
                    },
                    {
                        "username": "Artemchege",
                        "content": "... to the product of all the elements...\\n\\nit means that you should multiple each number. \\n[1,2,3,4] if i = 0, then we should remove 1 from nums and multiply 2 * 3 * 4"
                    },
                    {
                        "username": "dnt1997",
                        "content": "So using nested for loop is not allowed?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would be O(n^2)."
                    },
                    {
                        "username": "user2411qn",
                        "content": "Use reduce method if you are using javascript"
                    },
                    {
                        "username": "Zantus",
                        "content": "Its pretty simple if we just take the product of the right side elements and store it in a variable(x) and take product of left side of elements and store it in a variable(y) and the take product of both x*y and then update the array. easy solution."
                    }
                ]
            },
            {
                "id": 2049612,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "I used an O(n^2) solution, im posting it here because it fails over time limits:\n```\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        ans = []\n        for i in range(0,len(nums)):\n            ans.append(1)\n            for j in range(0, len(nums)):\n                if j == i:\n                    continue \n                ans[i] = nums[j] * ans[i]\n        \n        return ans \n```\n\nBut you get time limit exceeded. Reading the editorial I don't think this is a reasonable 'leetcode' type question, it's almost completely mathematical. I hope that the O(n^2) approach would be accepted in a job interview."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "They could ask you to come up with a more efficient method, than brute force.\nO(n^2) is very bad. I don't think that will get accepted."
                    },
                    {
                        "username": "cphillips09",
                        "content": "Would love some help. I spent too much time on this problem and thought I had a solution but kept getting an unexpected result using javascript:\\n\\nconst answer = [];\\nfor (let i = 0; i < nums.length; i++) {\\n    let tempArr = nums;\\n    tempArr[i] = 1;\\n    answer[i] = tempArr.reduce((a, b) => a * b);\\n}\\nreturn answer;\\n\\nFor the testcase [1, 2, 3, 4] I was getting [24, 12, 4, 1] as the output instead of [24, 12, 8, 6] and I have no idea why. For the third and forth iteration of the loop the tempArr should be [1, 2, 1, 4] and [1, 2, 3, 1] which should reduce to 8 and 6 respectively... what am I doing wrong?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The product of the entire array will be divisible by any number within. That said, your current result is the overall product divided by the current number. The only issue you now have is dealing with zeros. `Hint`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "itmevic",
                        "content": "\nWarning: Contains answer\n\nQuestion : Is my code O(n) run time?\n`\nvar productExceptSelf = function(nums) {\n\n    //Store product ith element with everything to its left\n    let left = []\n    //Store product ith element with everything to its right\n    let right = []\n\n    let product = 1\n    let result = []\n\n    for(let i = 0; i < nums.length; i++){\n        product *= nums[i]\n        left.push(product)\n    }\n    product = 1\n    for(let i = nums.length-1; i >= 0 ; i--){\n        product *= nums[i]\n        right.unshift(product)\n    }\n    for(let i = 0; i < nums.length; i++){\n        if(i === 0)\n          product = right[i+1]\n        else if(i === nums.length-1)\n          product = left[i-1]  \n        else\n            product = right[i+1]* left[i-1]\n        result.push(product)\n    }\n        return result\n};`\n\n"
                    },
                    {
                        "username": "Zomgnomes",
                        "content": "This is an absolutely garbage question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "just overload the division operator in c++ and if that does not work punch the person in the face for giving you a stupid fucking gotcha problem.\n\nno one writes DP in real life and you would never handicap yourself to do such a thing.\n\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Division is not allowed and does not work, if the element is zero."
                    },
                    {
                        "username": "Artemchege",
                        "content": "... to the product of all the elements...\\n\\nit means that you should multiple each number. \\n[1,2,3,4] if i = 0, then we should remove 1 from nums and multiply 2 * 3 * 4"
                    },
                    {
                        "username": "dnt1997",
                        "content": "So using nested for loop is not allowed?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would be O(n^2)."
                    },
                    {
                        "username": "user2411qn",
                        "content": "Use reduce method if you are using javascript"
                    },
                    {
                        "username": "Zantus",
                        "content": "Its pretty simple if we just take the product of the right side elements and store it in a variable(x) and take product of left side of elements and store it in a variable(y) and the take product of both x*y and then update the array. easy solution."
                    }
                ]
            },
            {
                "id": 2047742,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "I used an O(n^2) solution, im posting it here because it fails over time limits:\n```\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        ans = []\n        for i in range(0,len(nums)):\n            ans.append(1)\n            for j in range(0, len(nums)):\n                if j == i:\n                    continue \n                ans[i] = nums[j] * ans[i]\n        \n        return ans \n```\n\nBut you get time limit exceeded. Reading the editorial I don't think this is a reasonable 'leetcode' type question, it's almost completely mathematical. I hope that the O(n^2) approach would be accepted in a job interview."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "They could ask you to come up with a more efficient method, than brute force.\nO(n^2) is very bad. I don't think that will get accepted."
                    },
                    {
                        "username": "cphillips09",
                        "content": "Would love some help. I spent too much time on this problem and thought I had a solution but kept getting an unexpected result using javascript:\\n\\nconst answer = [];\\nfor (let i = 0; i < nums.length; i++) {\\n    let tempArr = nums;\\n    tempArr[i] = 1;\\n    answer[i] = tempArr.reduce((a, b) => a * b);\\n}\\nreturn answer;\\n\\nFor the testcase [1, 2, 3, 4] I was getting [24, 12, 4, 1] as the output instead of [24, 12, 8, 6] and I have no idea why. For the third and forth iteration of the loop the tempArr should be [1, 2, 1, 4] and [1, 2, 3, 1] which should reduce to 8 and 6 respectively... what am I doing wrong?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The product of the entire array will be divisible by any number within. That said, your current result is the overall product divided by the current number. The only issue you now have is dealing with zeros. `Hint`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "itmevic",
                        "content": "\nWarning: Contains answer\n\nQuestion : Is my code O(n) run time?\n`\nvar productExceptSelf = function(nums) {\n\n    //Store product ith element with everything to its left\n    let left = []\n    //Store product ith element with everything to its right\n    let right = []\n\n    let product = 1\n    let result = []\n\n    for(let i = 0; i < nums.length; i++){\n        product *= nums[i]\n        left.push(product)\n    }\n    product = 1\n    for(let i = nums.length-1; i >= 0 ; i--){\n        product *= nums[i]\n        right.unshift(product)\n    }\n    for(let i = 0; i < nums.length; i++){\n        if(i === 0)\n          product = right[i+1]\n        else if(i === nums.length-1)\n          product = left[i-1]  \n        else\n            product = right[i+1]* left[i-1]\n        result.push(product)\n    }\n        return result\n};`\n\n"
                    },
                    {
                        "username": "Zomgnomes",
                        "content": "This is an absolutely garbage question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "just overload the division operator in c++ and if that does not work punch the person in the face for giving you a stupid fucking gotcha problem.\n\nno one writes DP in real life and you would never handicap yourself to do such a thing.\n\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Division is not allowed and does not work, if the element is zero."
                    },
                    {
                        "username": "Artemchege",
                        "content": "... to the product of all the elements...\\n\\nit means that you should multiple each number. \\n[1,2,3,4] if i = 0, then we should remove 1 from nums and multiply 2 * 3 * 4"
                    },
                    {
                        "username": "dnt1997",
                        "content": "So using nested for loop is not allowed?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would be O(n^2)."
                    },
                    {
                        "username": "user2411qn",
                        "content": "Use reduce method if you are using javascript"
                    },
                    {
                        "username": "Zantus",
                        "content": "Its pretty simple if we just take the product of the right side elements and store it in a variable(x) and take product of left side of elements and store it in a variable(y) and the take product of both x*y and then update the array. easy solution."
                    }
                ]
            },
            {
                "id": 2035929,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "I used an O(n^2) solution, im posting it here because it fails over time limits:\n```\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        ans = []\n        for i in range(0,len(nums)):\n            ans.append(1)\n            for j in range(0, len(nums)):\n                if j == i:\n                    continue \n                ans[i] = nums[j] * ans[i]\n        \n        return ans \n```\n\nBut you get time limit exceeded. Reading the editorial I don't think this is a reasonable 'leetcode' type question, it's almost completely mathematical. I hope that the O(n^2) approach would be accepted in a job interview."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "They could ask you to come up with a more efficient method, than brute force.\nO(n^2) is very bad. I don't think that will get accepted."
                    },
                    {
                        "username": "cphillips09",
                        "content": "Would love some help. I spent too much time on this problem and thought I had a solution but kept getting an unexpected result using javascript:\\n\\nconst answer = [];\\nfor (let i = 0; i < nums.length; i++) {\\n    let tempArr = nums;\\n    tempArr[i] = 1;\\n    answer[i] = tempArr.reduce((a, b) => a * b);\\n}\\nreturn answer;\\n\\nFor the testcase [1, 2, 3, 4] I was getting [24, 12, 4, 1] as the output instead of [24, 12, 8, 6] and I have no idea why. For the third and forth iteration of the loop the tempArr should be [1, 2, 1, 4] and [1, 2, 3, 1] which should reduce to 8 and 6 respectively... what am I doing wrong?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The product of the entire array will be divisible by any number within. That said, your current result is the overall product divided by the current number. The only issue you now have is dealing with zeros. `Hint`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "itmevic",
                        "content": "\nWarning: Contains answer\n\nQuestion : Is my code O(n) run time?\n`\nvar productExceptSelf = function(nums) {\n\n    //Store product ith element with everything to its left\n    let left = []\n    //Store product ith element with everything to its right\n    let right = []\n\n    let product = 1\n    let result = []\n\n    for(let i = 0; i < nums.length; i++){\n        product *= nums[i]\n        left.push(product)\n    }\n    product = 1\n    for(let i = nums.length-1; i >= 0 ; i--){\n        product *= nums[i]\n        right.unshift(product)\n    }\n    for(let i = 0; i < nums.length; i++){\n        if(i === 0)\n          product = right[i+1]\n        else if(i === nums.length-1)\n          product = left[i-1]  \n        else\n            product = right[i+1]* left[i-1]\n        result.push(product)\n    }\n        return result\n};`\n\n"
                    },
                    {
                        "username": "Zomgnomes",
                        "content": "This is an absolutely garbage question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "just overload the division operator in c++ and if that does not work punch the person in the face for giving you a stupid fucking gotcha problem.\n\nno one writes DP in real life and you would never handicap yourself to do such a thing.\n\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Division is not allowed and does not work, if the element is zero."
                    },
                    {
                        "username": "Artemchege",
                        "content": "... to the product of all the elements...\\n\\nit means that you should multiple each number. \\n[1,2,3,4] if i = 0, then we should remove 1 from nums and multiply 2 * 3 * 4"
                    },
                    {
                        "username": "dnt1997",
                        "content": "So using nested for loop is not allowed?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would be O(n^2)."
                    },
                    {
                        "username": "user2411qn",
                        "content": "Use reduce method if you are using javascript"
                    },
                    {
                        "username": "Zantus",
                        "content": "Its pretty simple if we just take the product of the right side elements and store it in a variable(x) and take product of left side of elements and store it in a variable(y) and the take product of both x*y and then update the array. easy solution."
                    }
                ]
            },
            {
                "id": 2033299,
                "content": [
                    {
                        "username": "caldempsey",
                        "content": "I used an O(n^2) solution, im posting it here because it fails over time limits:\n```\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        ans = []\n        for i in range(0,len(nums)):\n            ans.append(1)\n            for j in range(0, len(nums)):\n                if j == i:\n                    continue \n                ans[i] = nums[j] * ans[i]\n        \n        return ans \n```\n\nBut you get time limit exceeded. Reading the editorial I don't think this is a reasonable 'leetcode' type question, it's almost completely mathematical. I hope that the O(n^2) approach would be accepted in a job interview."
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "They could ask you to come up with a more efficient method, than brute force.\nO(n^2) is very bad. I don't think that will get accepted."
                    },
                    {
                        "username": "cphillips09",
                        "content": "Would love some help. I spent too much time on this problem and thought I had a solution but kept getting an unexpected result using javascript:\\n\\nconst answer = [];\\nfor (let i = 0; i < nums.length; i++) {\\n    let tempArr = nums;\\n    tempArr[i] = 1;\\n    answer[i] = tempArr.reduce((a, b) => a * b);\\n}\\nreturn answer;\\n\\nFor the testcase [1, 2, 3, 4] I was getting [24, 12, 4, 1] as the output instead of [24, 12, 8, 6] and I have no idea why. For the third and forth iteration of the loop the tempArr should be [1, 2, 1, 4] and [1, 2, 3, 1] which should reduce to 8 and 6 respectively... what am I doing wrong?"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "The product of the entire array will be divisible by any number within. That said, your current result is the overall product divided by the current number. The only issue you now have is dealing with zeros. `Hint`"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You must write an algorithm that runs in O(n) time and without using the division operation."
                    },
                    {
                        "username": "itmevic",
                        "content": "\nWarning: Contains answer\n\nQuestion : Is my code O(n) run time?\n`\nvar productExceptSelf = function(nums) {\n\n    //Store product ith element with everything to its left\n    let left = []\n    //Store product ith element with everything to its right\n    let right = []\n\n    let product = 1\n    let result = []\n\n    for(let i = 0; i < nums.length; i++){\n        product *= nums[i]\n        left.push(product)\n    }\n    product = 1\n    for(let i = nums.length-1; i >= 0 ; i--){\n        product *= nums[i]\n        right.unshift(product)\n    }\n    for(let i = 0; i < nums.length; i++){\n        if(i === 0)\n          product = right[i+1]\n        else if(i === nums.length-1)\n          product = left[i-1]  \n        else\n            product = right[i+1]* left[i-1]\n        result.push(product)\n    }\n        return result\n};`\n\n"
                    },
                    {
                        "username": "Zomgnomes",
                        "content": "This is an absolutely garbage question."
                    },
                    {
                        "username": "LMS5400",
                        "content": "just overload the division operator in c++ and if that does not work punch the person in the face for giving you a stupid fucking gotcha problem.\n\nno one writes DP in real life and you would never handicap yourself to do such a thing.\n\n"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Division is not allowed and does not work, if the element is zero."
                    },
                    {
                        "username": "Artemchege",
                        "content": "... to the product of all the elements...\\n\\nit means that you should multiple each number. \\n[1,2,3,4] if i = 0, then we should remove 1 from nums and multiply 2 * 3 * 4"
                    },
                    {
                        "username": "dnt1997",
                        "content": "So using nested for loop is not allowed?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "No, that would be O(n^2)."
                    },
                    {
                        "username": "user2411qn",
                        "content": "Use reduce method if you are using javascript"
                    },
                    {
                        "username": "Zantus",
                        "content": "Its pretty simple if we just take the product of the right side elements and store it in a variable(x) and take product of left side of elements and store it in a variable(y) and the take product of both x*y and then update the array. easy solution."
                    }
                ]
            },
            {
                "id": 2032640,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "Magic happens with suffix and prefix "
                    },
                    {
                        "username": "TB09",
                        "content": "Here's the idea of my solution (Python3 97.81% runtime, 87.61% memory):\n\n==preparation==\n-keeping the product of whole array(excluding 0's)\n-keeping track of zeroes in array\n\n\n==operation (iterating through nums)==\n-if the current value is 0 and the zero counter > 1, we add ans to 0 ***, else we add total product\n-if the value is not 0 and we don't have any more zero in nums, we add total product/value (integer division) to ans, else we add 0 ***\n\n***(since there's another zero, product will be 0)\n\nnotes are signed with ***\n\nThanks for reading, good luck :)\n"
                    },
                    {
                        "username": "Lunagaron",
                        "content": "But why?. . ."
                    },
                    {
                        "username": "ankitz013",
                        "content": "**Explanation With Example** \\nHere\\'s an explanation of the example with the input nums = [1, 2, 3, 4]:\\n\\nInitial Array: [1, 2, 3, 4]\\n\\nInitialize the Result Array: [1, 1, 1, 1] - This array will store the product of all elements to the left of the current index.\\n\\nLeft Pass: Starting from the second element (index 1), for each element, update the result array by multiplying it with the element at the previous index.\\n\\nUpdated result array: [1, 1*1, 1*2, 1*2*3] = [1, 1, 2, 6]\\n\\nInitialize a Variable for Right Product: Start with a variable right_product initialized to 1. This variable will store the product of all elements to the right of the current index.\\n\\nRight Pass: Starting from the second-to-last element (index n-2), for each element, update the element in the result array by multiplying it with right_product and update right_product by multiplying it with the element at the current index.\\n\\nFor example, when processing index 2 (element 2), the element at index 2 in the result array will be updated as: result[2] = result[2] * right_product = 2 * 4 = 8, and right_product will be updated to right_product * nums[2] = 4 * 3 = 12.\\n\\nUpdated result array: [1, 1, 8, 6]\\n\\nFinal Pass: In this final step, update the last element in the result array (index n-1) with right_product.\\n\\nUpdated result array: [1, 1, 8, 12]\\n\\nSo, the final answer array will be [1 * 12, 1 * 12, 8 * 4, 6 * 1] = [12, 12, 32, 6], which matches the expected output [24, 12, 8, 6].\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "TsuiSauChi",
                        "content": "geez... chatgpt can solve this faster then I can count 1 2 3\\nMeanwhile I\\'m screaming at my scream for 15mins "
                    },
                    {
                        "username": "chirag_shah_16",
                        "content": "I solved the problem using recursion, and having l_arr and r_arr as global keywords but they don\\'t pass the scenarios when you try to submit. The Leetcode compiler should reset global variables before each test case."
                    },
                    {
                        "username": "ibrahimrifat221",
                        "content": "In this problem, we aim to compute an array\\'s element-wise product, excluding the current index. First, we multiply all values, e.g., given `nums = [1, 2, 3, 4]`, the product is `[24, 24, 24, 24]`. Next, we divide each element by its index value, skipping zeros. For instance, `nums = [24//nums[0], 24//nums[1], 24//nums[2], 24//nums[3]]`.  now return `nums` "
                    },
                    {
                        "username": "joemackay",
                        "content": "You skipped the instructions"
                    },
                    {
                        "username": "palak-agg",
                        "content": "How happy I feel after solving this one myself :)"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I could solve in linear time and const space only when i used `/` operator\\n\\nHint:\\nget `array` product with `zero` count\\nusing `in-place` operation conditionally divide `nums[i]` from `product` "
                    },
                    {
                        "username": "psionl0",
                        "content": "\"You must write an algorithm that runs in O(n) time and without using the division operation\".\\n"
                    },
                    {
                        "username": "himanshuone",
                        "content": "I have used Prefix and postfixes to solve this problem,\nAssume the \"nums = [1,2,3,4]\" array, we need to find the prefix and postfix of the same. Store prefixes in result list.\nPrefix of :                                   prefix=Multiplication of the element before that\n               index 0: 1 ,     1 is the default prefix\n               index 1: 1 ,    prefix*element on index\nWe will do the same with postfix but from the reverse.\n\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res=[1]* (len(nums))\n        prefix=1\n        for i in range(len(nums)):\n            res[i]=prefix\n            prefix*=nums[i]\n        postfix=1\n        for i in range(len(nums)-1,-1,-1):\n            res[i]*=postfix\n            postfix*=nums[i]\n        return res\n"
                    }
                ]
            },
            {
                "id": 2029922,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "Magic happens with suffix and prefix "
                    },
                    {
                        "username": "TB09",
                        "content": "Here's the idea of my solution (Python3 97.81% runtime, 87.61% memory):\n\n==preparation==\n-keeping the product of whole array(excluding 0's)\n-keeping track of zeroes in array\n\n\n==operation (iterating through nums)==\n-if the current value is 0 and the zero counter > 1, we add ans to 0 ***, else we add total product\n-if the value is not 0 and we don't have any more zero in nums, we add total product/value (integer division) to ans, else we add 0 ***\n\n***(since there's another zero, product will be 0)\n\nnotes are signed with ***\n\nThanks for reading, good luck :)\n"
                    },
                    {
                        "username": "Lunagaron",
                        "content": "But why?. . ."
                    },
                    {
                        "username": "ankitz013",
                        "content": "**Explanation With Example** \\nHere\\'s an explanation of the example with the input nums = [1, 2, 3, 4]:\\n\\nInitial Array: [1, 2, 3, 4]\\n\\nInitialize the Result Array: [1, 1, 1, 1] - This array will store the product of all elements to the left of the current index.\\n\\nLeft Pass: Starting from the second element (index 1), for each element, update the result array by multiplying it with the element at the previous index.\\n\\nUpdated result array: [1, 1*1, 1*2, 1*2*3] = [1, 1, 2, 6]\\n\\nInitialize a Variable for Right Product: Start with a variable right_product initialized to 1. This variable will store the product of all elements to the right of the current index.\\n\\nRight Pass: Starting from the second-to-last element (index n-2), for each element, update the element in the result array by multiplying it with right_product and update right_product by multiplying it with the element at the current index.\\n\\nFor example, when processing index 2 (element 2), the element at index 2 in the result array will be updated as: result[2] = result[2] * right_product = 2 * 4 = 8, and right_product will be updated to right_product * nums[2] = 4 * 3 = 12.\\n\\nUpdated result array: [1, 1, 8, 6]\\n\\nFinal Pass: In this final step, update the last element in the result array (index n-1) with right_product.\\n\\nUpdated result array: [1, 1, 8, 12]\\n\\nSo, the final answer array will be [1 * 12, 1 * 12, 8 * 4, 6 * 1] = [12, 12, 32, 6], which matches the expected output [24, 12, 8, 6].\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "TsuiSauChi",
                        "content": "geez... chatgpt can solve this faster then I can count 1 2 3\\nMeanwhile I\\'m screaming at my scream for 15mins "
                    },
                    {
                        "username": "chirag_shah_16",
                        "content": "I solved the problem using recursion, and having l_arr and r_arr as global keywords but they don\\'t pass the scenarios when you try to submit. The Leetcode compiler should reset global variables before each test case."
                    },
                    {
                        "username": "ibrahimrifat221",
                        "content": "In this problem, we aim to compute an array\\'s element-wise product, excluding the current index. First, we multiply all values, e.g., given `nums = [1, 2, 3, 4]`, the product is `[24, 24, 24, 24]`. Next, we divide each element by its index value, skipping zeros. For instance, `nums = [24//nums[0], 24//nums[1], 24//nums[2], 24//nums[3]]`.  now return `nums` "
                    },
                    {
                        "username": "joemackay",
                        "content": "You skipped the instructions"
                    },
                    {
                        "username": "palak-agg",
                        "content": "How happy I feel after solving this one myself :)"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I could solve in linear time and const space only when i used `/` operator\\n\\nHint:\\nget `array` product with `zero` count\\nusing `in-place` operation conditionally divide `nums[i]` from `product` "
                    },
                    {
                        "username": "psionl0",
                        "content": "\"You must write an algorithm that runs in O(n) time and without using the division operation\".\\n"
                    },
                    {
                        "username": "himanshuone",
                        "content": "I have used Prefix and postfixes to solve this problem,\nAssume the \"nums = [1,2,3,4]\" array, we need to find the prefix and postfix of the same. Store prefixes in result list.\nPrefix of :                                   prefix=Multiplication of the element before that\n               index 0: 1 ,     1 is the default prefix\n               index 1: 1 ,    prefix*element on index\nWe will do the same with postfix but from the reverse.\n\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res=[1]* (len(nums))\n        prefix=1\n        for i in range(len(nums)):\n            res[i]=prefix\n            prefix*=nums[i]\n        postfix=1\n        for i in range(len(nums)-1,-1,-1):\n            res[i]*=postfix\n            postfix*=nums[i]\n        return res\n"
                    }
                ]
            },
            {
                "id": 2029472,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "Magic happens with suffix and prefix "
                    },
                    {
                        "username": "TB09",
                        "content": "Here's the idea of my solution (Python3 97.81% runtime, 87.61% memory):\n\n==preparation==\n-keeping the product of whole array(excluding 0's)\n-keeping track of zeroes in array\n\n\n==operation (iterating through nums)==\n-if the current value is 0 and the zero counter > 1, we add ans to 0 ***, else we add total product\n-if the value is not 0 and we don't have any more zero in nums, we add total product/value (integer division) to ans, else we add 0 ***\n\n***(since there's another zero, product will be 0)\n\nnotes are signed with ***\n\nThanks for reading, good luck :)\n"
                    },
                    {
                        "username": "Lunagaron",
                        "content": "But why?. . ."
                    },
                    {
                        "username": "ankitz013",
                        "content": "**Explanation With Example** \\nHere\\'s an explanation of the example with the input nums = [1, 2, 3, 4]:\\n\\nInitial Array: [1, 2, 3, 4]\\n\\nInitialize the Result Array: [1, 1, 1, 1] - This array will store the product of all elements to the left of the current index.\\n\\nLeft Pass: Starting from the second element (index 1), for each element, update the result array by multiplying it with the element at the previous index.\\n\\nUpdated result array: [1, 1*1, 1*2, 1*2*3] = [1, 1, 2, 6]\\n\\nInitialize a Variable for Right Product: Start with a variable right_product initialized to 1. This variable will store the product of all elements to the right of the current index.\\n\\nRight Pass: Starting from the second-to-last element (index n-2), for each element, update the element in the result array by multiplying it with right_product and update right_product by multiplying it with the element at the current index.\\n\\nFor example, when processing index 2 (element 2), the element at index 2 in the result array will be updated as: result[2] = result[2] * right_product = 2 * 4 = 8, and right_product will be updated to right_product * nums[2] = 4 * 3 = 12.\\n\\nUpdated result array: [1, 1, 8, 6]\\n\\nFinal Pass: In this final step, update the last element in the result array (index n-1) with right_product.\\n\\nUpdated result array: [1, 1, 8, 12]\\n\\nSo, the final answer array will be [1 * 12, 1 * 12, 8 * 4, 6 * 1] = [12, 12, 32, 6], which matches the expected output [24, 12, 8, 6].\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "TsuiSauChi",
                        "content": "geez... chatgpt can solve this faster then I can count 1 2 3\\nMeanwhile I\\'m screaming at my scream for 15mins "
                    },
                    {
                        "username": "chirag_shah_16",
                        "content": "I solved the problem using recursion, and having l_arr and r_arr as global keywords but they don\\'t pass the scenarios when you try to submit. The Leetcode compiler should reset global variables before each test case."
                    },
                    {
                        "username": "ibrahimrifat221",
                        "content": "In this problem, we aim to compute an array\\'s element-wise product, excluding the current index. First, we multiply all values, e.g., given `nums = [1, 2, 3, 4]`, the product is `[24, 24, 24, 24]`. Next, we divide each element by its index value, skipping zeros. For instance, `nums = [24//nums[0], 24//nums[1], 24//nums[2], 24//nums[3]]`.  now return `nums` "
                    },
                    {
                        "username": "joemackay",
                        "content": "You skipped the instructions"
                    },
                    {
                        "username": "palak-agg",
                        "content": "How happy I feel after solving this one myself :)"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I could solve in linear time and const space only when i used `/` operator\\n\\nHint:\\nget `array` product with `zero` count\\nusing `in-place` operation conditionally divide `nums[i]` from `product` "
                    },
                    {
                        "username": "psionl0",
                        "content": "\"You must write an algorithm that runs in O(n) time and without using the division operation\".\\n"
                    },
                    {
                        "username": "himanshuone",
                        "content": "I have used Prefix and postfixes to solve this problem,\nAssume the \"nums = [1,2,3,4]\" array, we need to find the prefix and postfix of the same. Store prefixes in result list.\nPrefix of :                                   prefix=Multiplication of the element before that\n               index 0: 1 ,     1 is the default prefix\n               index 1: 1 ,    prefix*element on index\nWe will do the same with postfix but from the reverse.\n\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res=[1]* (len(nums))\n        prefix=1\n        for i in range(len(nums)):\n            res[i]=prefix\n            prefix*=nums[i]\n        postfix=1\n        for i in range(len(nums)-1,-1,-1):\n            res[i]*=postfix\n            postfix*=nums[i]\n        return res\n"
                    }
                ]
            },
            {
                "id": 2021334,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "Magic happens with suffix and prefix "
                    },
                    {
                        "username": "TB09",
                        "content": "Here's the idea of my solution (Python3 97.81% runtime, 87.61% memory):\n\n==preparation==\n-keeping the product of whole array(excluding 0's)\n-keeping track of zeroes in array\n\n\n==operation (iterating through nums)==\n-if the current value is 0 and the zero counter > 1, we add ans to 0 ***, else we add total product\n-if the value is not 0 and we don't have any more zero in nums, we add total product/value (integer division) to ans, else we add 0 ***\n\n***(since there's another zero, product will be 0)\n\nnotes are signed with ***\n\nThanks for reading, good luck :)\n"
                    },
                    {
                        "username": "Lunagaron",
                        "content": "But why?. . ."
                    },
                    {
                        "username": "ankitz013",
                        "content": "**Explanation With Example** \\nHere\\'s an explanation of the example with the input nums = [1, 2, 3, 4]:\\n\\nInitial Array: [1, 2, 3, 4]\\n\\nInitialize the Result Array: [1, 1, 1, 1] - This array will store the product of all elements to the left of the current index.\\n\\nLeft Pass: Starting from the second element (index 1), for each element, update the result array by multiplying it with the element at the previous index.\\n\\nUpdated result array: [1, 1*1, 1*2, 1*2*3] = [1, 1, 2, 6]\\n\\nInitialize a Variable for Right Product: Start with a variable right_product initialized to 1. This variable will store the product of all elements to the right of the current index.\\n\\nRight Pass: Starting from the second-to-last element (index n-2), for each element, update the element in the result array by multiplying it with right_product and update right_product by multiplying it with the element at the current index.\\n\\nFor example, when processing index 2 (element 2), the element at index 2 in the result array will be updated as: result[2] = result[2] * right_product = 2 * 4 = 8, and right_product will be updated to right_product * nums[2] = 4 * 3 = 12.\\n\\nUpdated result array: [1, 1, 8, 6]\\n\\nFinal Pass: In this final step, update the last element in the result array (index n-1) with right_product.\\n\\nUpdated result array: [1, 1, 8, 12]\\n\\nSo, the final answer array will be [1 * 12, 1 * 12, 8 * 4, 6 * 1] = [12, 12, 32, 6], which matches the expected output [24, 12, 8, 6].\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "TsuiSauChi",
                        "content": "geez... chatgpt can solve this faster then I can count 1 2 3\\nMeanwhile I\\'m screaming at my scream for 15mins "
                    },
                    {
                        "username": "chirag_shah_16",
                        "content": "I solved the problem using recursion, and having l_arr and r_arr as global keywords but they don\\'t pass the scenarios when you try to submit. The Leetcode compiler should reset global variables before each test case."
                    },
                    {
                        "username": "ibrahimrifat221",
                        "content": "In this problem, we aim to compute an array\\'s element-wise product, excluding the current index. First, we multiply all values, e.g., given `nums = [1, 2, 3, 4]`, the product is `[24, 24, 24, 24]`. Next, we divide each element by its index value, skipping zeros. For instance, `nums = [24//nums[0], 24//nums[1], 24//nums[2], 24//nums[3]]`.  now return `nums` "
                    },
                    {
                        "username": "joemackay",
                        "content": "You skipped the instructions"
                    },
                    {
                        "username": "palak-agg",
                        "content": "How happy I feel after solving this one myself :)"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I could solve in linear time and const space only when i used `/` operator\\n\\nHint:\\nget `array` product with `zero` count\\nusing `in-place` operation conditionally divide `nums[i]` from `product` "
                    },
                    {
                        "username": "psionl0",
                        "content": "\"You must write an algorithm that runs in O(n) time and without using the division operation\".\\n"
                    },
                    {
                        "username": "himanshuone",
                        "content": "I have used Prefix and postfixes to solve this problem,\nAssume the \"nums = [1,2,3,4]\" array, we need to find the prefix and postfix of the same. Store prefixes in result list.\nPrefix of :                                   prefix=Multiplication of the element before that\n               index 0: 1 ,     1 is the default prefix\n               index 1: 1 ,    prefix*element on index\nWe will do the same with postfix but from the reverse.\n\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res=[1]* (len(nums))\n        prefix=1\n        for i in range(len(nums)):\n            res[i]=prefix\n            prefix*=nums[i]\n        postfix=1\n        for i in range(len(nums)-1,-1,-1):\n            res[i]*=postfix\n            postfix*=nums[i]\n        return res\n"
                    }
                ]
            },
            {
                "id": 2013993,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "Magic happens with suffix and prefix "
                    },
                    {
                        "username": "TB09",
                        "content": "Here's the idea of my solution (Python3 97.81% runtime, 87.61% memory):\n\n==preparation==\n-keeping the product of whole array(excluding 0's)\n-keeping track of zeroes in array\n\n\n==operation (iterating through nums)==\n-if the current value is 0 and the zero counter > 1, we add ans to 0 ***, else we add total product\n-if the value is not 0 and we don't have any more zero in nums, we add total product/value (integer division) to ans, else we add 0 ***\n\n***(since there's another zero, product will be 0)\n\nnotes are signed with ***\n\nThanks for reading, good luck :)\n"
                    },
                    {
                        "username": "Lunagaron",
                        "content": "But why?. . ."
                    },
                    {
                        "username": "ankitz013",
                        "content": "**Explanation With Example** \\nHere\\'s an explanation of the example with the input nums = [1, 2, 3, 4]:\\n\\nInitial Array: [1, 2, 3, 4]\\n\\nInitialize the Result Array: [1, 1, 1, 1] - This array will store the product of all elements to the left of the current index.\\n\\nLeft Pass: Starting from the second element (index 1), for each element, update the result array by multiplying it with the element at the previous index.\\n\\nUpdated result array: [1, 1*1, 1*2, 1*2*3] = [1, 1, 2, 6]\\n\\nInitialize a Variable for Right Product: Start with a variable right_product initialized to 1. This variable will store the product of all elements to the right of the current index.\\n\\nRight Pass: Starting from the second-to-last element (index n-2), for each element, update the element in the result array by multiplying it with right_product and update right_product by multiplying it with the element at the current index.\\n\\nFor example, when processing index 2 (element 2), the element at index 2 in the result array will be updated as: result[2] = result[2] * right_product = 2 * 4 = 8, and right_product will be updated to right_product * nums[2] = 4 * 3 = 12.\\n\\nUpdated result array: [1, 1, 8, 6]\\n\\nFinal Pass: In this final step, update the last element in the result array (index n-1) with right_product.\\n\\nUpdated result array: [1, 1, 8, 12]\\n\\nSo, the final answer array will be [1 * 12, 1 * 12, 8 * 4, 6 * 1] = [12, 12, 32, 6], which matches the expected output [24, 12, 8, 6].\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "TsuiSauChi",
                        "content": "geez... chatgpt can solve this faster then I can count 1 2 3\\nMeanwhile I\\'m screaming at my scream for 15mins "
                    },
                    {
                        "username": "chirag_shah_16",
                        "content": "I solved the problem using recursion, and having l_arr and r_arr as global keywords but they don\\'t pass the scenarios when you try to submit. The Leetcode compiler should reset global variables before each test case."
                    },
                    {
                        "username": "ibrahimrifat221",
                        "content": "In this problem, we aim to compute an array\\'s element-wise product, excluding the current index. First, we multiply all values, e.g., given `nums = [1, 2, 3, 4]`, the product is `[24, 24, 24, 24]`. Next, we divide each element by its index value, skipping zeros. For instance, `nums = [24//nums[0], 24//nums[1], 24//nums[2], 24//nums[3]]`.  now return `nums` "
                    },
                    {
                        "username": "joemackay",
                        "content": "You skipped the instructions"
                    },
                    {
                        "username": "palak-agg",
                        "content": "How happy I feel after solving this one myself :)"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I could solve in linear time and const space only when i used `/` operator\\n\\nHint:\\nget `array` product with `zero` count\\nusing `in-place` operation conditionally divide `nums[i]` from `product` "
                    },
                    {
                        "username": "psionl0",
                        "content": "\"You must write an algorithm that runs in O(n) time and without using the division operation\".\\n"
                    },
                    {
                        "username": "himanshuone",
                        "content": "I have used Prefix and postfixes to solve this problem,\nAssume the \"nums = [1,2,3,4]\" array, we need to find the prefix and postfix of the same. Store prefixes in result list.\nPrefix of :                                   prefix=Multiplication of the element before that\n               index 0: 1 ,     1 is the default prefix\n               index 1: 1 ,    prefix*element on index\nWe will do the same with postfix but from the reverse.\n\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res=[1]* (len(nums))\n        prefix=1\n        for i in range(len(nums)):\n            res[i]=prefix\n            prefix*=nums[i]\n        postfix=1\n        for i in range(len(nums)-1,-1,-1):\n            res[i]*=postfix\n            postfix*=nums[i]\n        return res\n"
                    }
                ]
            },
            {
                "id": 2008220,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "Magic happens with suffix and prefix "
                    },
                    {
                        "username": "TB09",
                        "content": "Here's the idea of my solution (Python3 97.81% runtime, 87.61% memory):\n\n==preparation==\n-keeping the product of whole array(excluding 0's)\n-keeping track of zeroes in array\n\n\n==operation (iterating through nums)==\n-if the current value is 0 and the zero counter > 1, we add ans to 0 ***, else we add total product\n-if the value is not 0 and we don't have any more zero in nums, we add total product/value (integer division) to ans, else we add 0 ***\n\n***(since there's another zero, product will be 0)\n\nnotes are signed with ***\n\nThanks for reading, good luck :)\n"
                    },
                    {
                        "username": "Lunagaron",
                        "content": "But why?. . ."
                    },
                    {
                        "username": "ankitz013",
                        "content": "**Explanation With Example** \\nHere\\'s an explanation of the example with the input nums = [1, 2, 3, 4]:\\n\\nInitial Array: [1, 2, 3, 4]\\n\\nInitialize the Result Array: [1, 1, 1, 1] - This array will store the product of all elements to the left of the current index.\\n\\nLeft Pass: Starting from the second element (index 1), for each element, update the result array by multiplying it with the element at the previous index.\\n\\nUpdated result array: [1, 1*1, 1*2, 1*2*3] = [1, 1, 2, 6]\\n\\nInitialize a Variable for Right Product: Start with a variable right_product initialized to 1. This variable will store the product of all elements to the right of the current index.\\n\\nRight Pass: Starting from the second-to-last element (index n-2), for each element, update the element in the result array by multiplying it with right_product and update right_product by multiplying it with the element at the current index.\\n\\nFor example, when processing index 2 (element 2), the element at index 2 in the result array will be updated as: result[2] = result[2] * right_product = 2 * 4 = 8, and right_product will be updated to right_product * nums[2] = 4 * 3 = 12.\\n\\nUpdated result array: [1, 1, 8, 6]\\n\\nFinal Pass: In this final step, update the last element in the result array (index n-1) with right_product.\\n\\nUpdated result array: [1, 1, 8, 12]\\n\\nSo, the final answer array will be [1 * 12, 1 * 12, 8 * 4, 6 * 1] = [12, 12, 32, 6], which matches the expected output [24, 12, 8, 6].\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "TsuiSauChi",
                        "content": "geez... chatgpt can solve this faster then I can count 1 2 3\\nMeanwhile I\\'m screaming at my scream for 15mins "
                    },
                    {
                        "username": "chirag_shah_16",
                        "content": "I solved the problem using recursion, and having l_arr and r_arr as global keywords but they don\\'t pass the scenarios when you try to submit. The Leetcode compiler should reset global variables before each test case."
                    },
                    {
                        "username": "ibrahimrifat221",
                        "content": "In this problem, we aim to compute an array\\'s element-wise product, excluding the current index. First, we multiply all values, e.g., given `nums = [1, 2, 3, 4]`, the product is `[24, 24, 24, 24]`. Next, we divide each element by its index value, skipping zeros. For instance, `nums = [24//nums[0], 24//nums[1], 24//nums[2], 24//nums[3]]`.  now return `nums` "
                    },
                    {
                        "username": "joemackay",
                        "content": "You skipped the instructions"
                    },
                    {
                        "username": "palak-agg",
                        "content": "How happy I feel after solving this one myself :)"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I could solve in linear time and const space only when i used `/` operator\\n\\nHint:\\nget `array` product with `zero` count\\nusing `in-place` operation conditionally divide `nums[i]` from `product` "
                    },
                    {
                        "username": "psionl0",
                        "content": "\"You must write an algorithm that runs in O(n) time and without using the division operation\".\\n"
                    },
                    {
                        "username": "himanshuone",
                        "content": "I have used Prefix and postfixes to solve this problem,\nAssume the \"nums = [1,2,3,4]\" array, we need to find the prefix and postfix of the same. Store prefixes in result list.\nPrefix of :                                   prefix=Multiplication of the element before that\n               index 0: 1 ,     1 is the default prefix\n               index 1: 1 ,    prefix*element on index\nWe will do the same with postfix but from the reverse.\n\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res=[1]* (len(nums))\n        prefix=1\n        for i in range(len(nums)):\n            res[i]=prefix\n            prefix*=nums[i]\n        postfix=1\n        for i in range(len(nums)-1,-1,-1):\n            res[i]*=postfix\n            postfix*=nums[i]\n        return res\n"
                    }
                ]
            },
            {
                "id": 2007402,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "Magic happens with suffix and prefix "
                    },
                    {
                        "username": "TB09",
                        "content": "Here's the idea of my solution (Python3 97.81% runtime, 87.61% memory):\n\n==preparation==\n-keeping the product of whole array(excluding 0's)\n-keeping track of zeroes in array\n\n\n==operation (iterating through nums)==\n-if the current value is 0 and the zero counter > 1, we add ans to 0 ***, else we add total product\n-if the value is not 0 and we don't have any more zero in nums, we add total product/value (integer division) to ans, else we add 0 ***\n\n***(since there's another zero, product will be 0)\n\nnotes are signed with ***\n\nThanks for reading, good luck :)\n"
                    },
                    {
                        "username": "Lunagaron",
                        "content": "But why?. . ."
                    },
                    {
                        "username": "ankitz013",
                        "content": "**Explanation With Example** \\nHere\\'s an explanation of the example with the input nums = [1, 2, 3, 4]:\\n\\nInitial Array: [1, 2, 3, 4]\\n\\nInitialize the Result Array: [1, 1, 1, 1] - This array will store the product of all elements to the left of the current index.\\n\\nLeft Pass: Starting from the second element (index 1), for each element, update the result array by multiplying it with the element at the previous index.\\n\\nUpdated result array: [1, 1*1, 1*2, 1*2*3] = [1, 1, 2, 6]\\n\\nInitialize a Variable for Right Product: Start with a variable right_product initialized to 1. This variable will store the product of all elements to the right of the current index.\\n\\nRight Pass: Starting from the second-to-last element (index n-2), for each element, update the element in the result array by multiplying it with right_product and update right_product by multiplying it with the element at the current index.\\n\\nFor example, when processing index 2 (element 2), the element at index 2 in the result array will be updated as: result[2] = result[2] * right_product = 2 * 4 = 8, and right_product will be updated to right_product * nums[2] = 4 * 3 = 12.\\n\\nUpdated result array: [1, 1, 8, 6]\\n\\nFinal Pass: In this final step, update the last element in the result array (index n-1) with right_product.\\n\\nUpdated result array: [1, 1, 8, 12]\\n\\nSo, the final answer array will be [1 * 12, 1 * 12, 8 * 4, 6 * 1] = [12, 12, 32, 6], which matches the expected output [24, 12, 8, 6].\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "TsuiSauChi",
                        "content": "geez... chatgpt can solve this faster then I can count 1 2 3\\nMeanwhile I\\'m screaming at my scream for 15mins "
                    },
                    {
                        "username": "chirag_shah_16",
                        "content": "I solved the problem using recursion, and having l_arr and r_arr as global keywords but they don\\'t pass the scenarios when you try to submit. The Leetcode compiler should reset global variables before each test case."
                    },
                    {
                        "username": "ibrahimrifat221",
                        "content": "In this problem, we aim to compute an array\\'s element-wise product, excluding the current index. First, we multiply all values, e.g., given `nums = [1, 2, 3, 4]`, the product is `[24, 24, 24, 24]`. Next, we divide each element by its index value, skipping zeros. For instance, `nums = [24//nums[0], 24//nums[1], 24//nums[2], 24//nums[3]]`.  now return `nums` "
                    },
                    {
                        "username": "joemackay",
                        "content": "You skipped the instructions"
                    },
                    {
                        "username": "palak-agg",
                        "content": "How happy I feel after solving this one myself :)"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I could solve in linear time and const space only when i used `/` operator\\n\\nHint:\\nget `array` product with `zero` count\\nusing `in-place` operation conditionally divide `nums[i]` from `product` "
                    },
                    {
                        "username": "psionl0",
                        "content": "\"You must write an algorithm that runs in O(n) time and without using the division operation\".\\n"
                    },
                    {
                        "username": "himanshuone",
                        "content": "I have used Prefix and postfixes to solve this problem,\nAssume the \"nums = [1,2,3,4]\" array, we need to find the prefix and postfix of the same. Store prefixes in result list.\nPrefix of :                                   prefix=Multiplication of the element before that\n               index 0: 1 ,     1 is the default prefix\n               index 1: 1 ,    prefix*element on index\nWe will do the same with postfix but from the reverse.\n\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res=[1]* (len(nums))\n        prefix=1\n        for i in range(len(nums)):\n            res[i]=prefix\n            prefix*=nums[i]\n        postfix=1\n        for i in range(len(nums)-1,-1,-1):\n            res[i]*=postfix\n            postfix*=nums[i]\n        return res\n"
                    }
                ]
            },
            {
                "id": 2004005,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "Magic happens with suffix and prefix "
                    },
                    {
                        "username": "TB09",
                        "content": "Here's the idea of my solution (Python3 97.81% runtime, 87.61% memory):\n\n==preparation==\n-keeping the product of whole array(excluding 0's)\n-keeping track of zeroes in array\n\n\n==operation (iterating through nums)==\n-if the current value is 0 and the zero counter > 1, we add ans to 0 ***, else we add total product\n-if the value is not 0 and we don't have any more zero in nums, we add total product/value (integer division) to ans, else we add 0 ***\n\n***(since there's another zero, product will be 0)\n\nnotes are signed with ***\n\nThanks for reading, good luck :)\n"
                    },
                    {
                        "username": "Lunagaron",
                        "content": "But why?. . ."
                    },
                    {
                        "username": "ankitz013",
                        "content": "**Explanation With Example** \\nHere\\'s an explanation of the example with the input nums = [1, 2, 3, 4]:\\n\\nInitial Array: [1, 2, 3, 4]\\n\\nInitialize the Result Array: [1, 1, 1, 1] - This array will store the product of all elements to the left of the current index.\\n\\nLeft Pass: Starting from the second element (index 1), for each element, update the result array by multiplying it with the element at the previous index.\\n\\nUpdated result array: [1, 1*1, 1*2, 1*2*3] = [1, 1, 2, 6]\\n\\nInitialize a Variable for Right Product: Start with a variable right_product initialized to 1. This variable will store the product of all elements to the right of the current index.\\n\\nRight Pass: Starting from the second-to-last element (index n-2), for each element, update the element in the result array by multiplying it with right_product and update right_product by multiplying it with the element at the current index.\\n\\nFor example, when processing index 2 (element 2), the element at index 2 in the result array will be updated as: result[2] = result[2] * right_product = 2 * 4 = 8, and right_product will be updated to right_product * nums[2] = 4 * 3 = 12.\\n\\nUpdated result array: [1, 1, 8, 6]\\n\\nFinal Pass: In this final step, update the last element in the result array (index n-1) with right_product.\\n\\nUpdated result array: [1, 1, 8, 12]\\n\\nSo, the final answer array will be [1 * 12, 1 * 12, 8 * 4, 6 * 1] = [12, 12, 32, 6], which matches the expected output [24, 12, 8, 6].\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "TsuiSauChi",
                        "content": "geez... chatgpt can solve this faster then I can count 1 2 3\\nMeanwhile I\\'m screaming at my scream for 15mins "
                    },
                    {
                        "username": "chirag_shah_16",
                        "content": "I solved the problem using recursion, and having l_arr and r_arr as global keywords but they don\\'t pass the scenarios when you try to submit. The Leetcode compiler should reset global variables before each test case."
                    },
                    {
                        "username": "ibrahimrifat221",
                        "content": "In this problem, we aim to compute an array\\'s element-wise product, excluding the current index. First, we multiply all values, e.g., given `nums = [1, 2, 3, 4]`, the product is `[24, 24, 24, 24]`. Next, we divide each element by its index value, skipping zeros. For instance, `nums = [24//nums[0], 24//nums[1], 24//nums[2], 24//nums[3]]`.  now return `nums` "
                    },
                    {
                        "username": "joemackay",
                        "content": "You skipped the instructions"
                    },
                    {
                        "username": "palak-agg",
                        "content": "How happy I feel after solving this one myself :)"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I could solve in linear time and const space only when i used `/` operator\\n\\nHint:\\nget `array` product with `zero` count\\nusing `in-place` operation conditionally divide `nums[i]` from `product` "
                    },
                    {
                        "username": "psionl0",
                        "content": "\"You must write an algorithm that runs in O(n) time and without using the division operation\".\\n"
                    },
                    {
                        "username": "himanshuone",
                        "content": "I have used Prefix and postfixes to solve this problem,\nAssume the \"nums = [1,2,3,4]\" array, we need to find the prefix and postfix of the same. Store prefixes in result list.\nPrefix of :                                   prefix=Multiplication of the element before that\n               index 0: 1 ,     1 is the default prefix\n               index 1: 1 ,    prefix*element on index\nWe will do the same with postfix but from the reverse.\n\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res=[1]* (len(nums))\n        prefix=1\n        for i in range(len(nums)):\n            res[i]=prefix\n            prefix*=nums[i]\n        postfix=1\n        for i in range(len(nums)-1,-1,-1):\n            res[i]*=postfix\n            postfix*=nums[i]\n        return res\n"
                    }
                ]
            },
            {
                "id": 1997997,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "Magic happens with suffix and prefix "
                    },
                    {
                        "username": "TB09",
                        "content": "Here's the idea of my solution (Python3 97.81% runtime, 87.61% memory):\n\n==preparation==\n-keeping the product of whole array(excluding 0's)\n-keeping track of zeroes in array\n\n\n==operation (iterating through nums)==\n-if the current value is 0 and the zero counter > 1, we add ans to 0 ***, else we add total product\n-if the value is not 0 and we don't have any more zero in nums, we add total product/value (integer division) to ans, else we add 0 ***\n\n***(since there's another zero, product will be 0)\n\nnotes are signed with ***\n\nThanks for reading, good luck :)\n"
                    },
                    {
                        "username": "Lunagaron",
                        "content": "But why?. . ."
                    },
                    {
                        "username": "ankitz013",
                        "content": "**Explanation With Example** \\nHere\\'s an explanation of the example with the input nums = [1, 2, 3, 4]:\\n\\nInitial Array: [1, 2, 3, 4]\\n\\nInitialize the Result Array: [1, 1, 1, 1] - This array will store the product of all elements to the left of the current index.\\n\\nLeft Pass: Starting from the second element (index 1), for each element, update the result array by multiplying it with the element at the previous index.\\n\\nUpdated result array: [1, 1*1, 1*2, 1*2*3] = [1, 1, 2, 6]\\n\\nInitialize a Variable for Right Product: Start with a variable right_product initialized to 1. This variable will store the product of all elements to the right of the current index.\\n\\nRight Pass: Starting from the second-to-last element (index n-2), for each element, update the element in the result array by multiplying it with right_product and update right_product by multiplying it with the element at the current index.\\n\\nFor example, when processing index 2 (element 2), the element at index 2 in the result array will be updated as: result[2] = result[2] * right_product = 2 * 4 = 8, and right_product will be updated to right_product * nums[2] = 4 * 3 = 12.\\n\\nUpdated result array: [1, 1, 8, 6]\\n\\nFinal Pass: In this final step, update the last element in the result array (index n-1) with right_product.\\n\\nUpdated result array: [1, 1, 8, 12]\\n\\nSo, the final answer array will be [1 * 12, 1 * 12, 8 * 4, 6 * 1] = [12, 12, 32, 6], which matches the expected output [24, 12, 8, 6].\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "TsuiSauChi",
                        "content": "geez... chatgpt can solve this faster then I can count 1 2 3\\nMeanwhile I\\'m screaming at my scream for 15mins "
                    },
                    {
                        "username": "chirag_shah_16",
                        "content": "I solved the problem using recursion, and having l_arr and r_arr as global keywords but they don\\'t pass the scenarios when you try to submit. The Leetcode compiler should reset global variables before each test case."
                    },
                    {
                        "username": "ibrahimrifat221",
                        "content": "In this problem, we aim to compute an array\\'s element-wise product, excluding the current index. First, we multiply all values, e.g., given `nums = [1, 2, 3, 4]`, the product is `[24, 24, 24, 24]`. Next, we divide each element by its index value, skipping zeros. For instance, `nums = [24//nums[0], 24//nums[1], 24//nums[2], 24//nums[3]]`.  now return `nums` "
                    },
                    {
                        "username": "joemackay",
                        "content": "You skipped the instructions"
                    },
                    {
                        "username": "palak-agg",
                        "content": "How happy I feel after solving this one myself :)"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I could solve in linear time and const space only when i used `/` operator\\n\\nHint:\\nget `array` product with `zero` count\\nusing `in-place` operation conditionally divide `nums[i]` from `product` "
                    },
                    {
                        "username": "psionl0",
                        "content": "\"You must write an algorithm that runs in O(n) time and without using the division operation\".\\n"
                    },
                    {
                        "username": "himanshuone",
                        "content": "I have used Prefix and postfixes to solve this problem,\nAssume the \"nums = [1,2,3,4]\" array, we need to find the prefix and postfix of the same. Store prefixes in result list.\nPrefix of :                                   prefix=Multiplication of the element before that\n               index 0: 1 ,     1 is the default prefix\n               index 1: 1 ,    prefix*element on index\nWe will do the same with postfix but from the reverse.\n\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res=[1]* (len(nums))\n        prefix=1\n        for i in range(len(nums)):\n            res[i]=prefix\n            prefix*=nums[i]\n        postfix=1\n        for i in range(len(nums)-1,-1,-1):\n            res[i]*=postfix\n            postfix*=nums[i]\n        return res\n"
                    }
                ]
            },
            {
                "id": 1997464,
                "content": [
                    {
                        "username": "ankitk742",
                        "content": "Magic happens with suffix and prefix "
                    },
                    {
                        "username": "TB09",
                        "content": "Here's the idea of my solution (Python3 97.81% runtime, 87.61% memory):\n\n==preparation==\n-keeping the product of whole array(excluding 0's)\n-keeping track of zeroes in array\n\n\n==operation (iterating through nums)==\n-if the current value is 0 and the zero counter > 1, we add ans to 0 ***, else we add total product\n-if the value is not 0 and we don't have any more zero in nums, we add total product/value (integer division) to ans, else we add 0 ***\n\n***(since there's another zero, product will be 0)\n\nnotes are signed with ***\n\nThanks for reading, good luck :)\n"
                    },
                    {
                        "username": "Lunagaron",
                        "content": "But why?. . ."
                    },
                    {
                        "username": "ankitz013",
                        "content": "**Explanation With Example** \\nHere\\'s an explanation of the example with the input nums = [1, 2, 3, 4]:\\n\\nInitial Array: [1, 2, 3, 4]\\n\\nInitialize the Result Array: [1, 1, 1, 1] - This array will store the product of all elements to the left of the current index.\\n\\nLeft Pass: Starting from the second element (index 1), for each element, update the result array by multiplying it with the element at the previous index.\\n\\nUpdated result array: [1, 1*1, 1*2, 1*2*3] = [1, 1, 2, 6]\\n\\nInitialize a Variable for Right Product: Start with a variable right_product initialized to 1. This variable will store the product of all elements to the right of the current index.\\n\\nRight Pass: Starting from the second-to-last element (index n-2), for each element, update the element in the result array by multiplying it with right_product and update right_product by multiplying it with the element at the current index.\\n\\nFor example, when processing index 2 (element 2), the element at index 2 in the result array will be updated as: result[2] = result[2] * right_product = 2 * 4 = 8, and right_product will be updated to right_product * nums[2] = 4 * 3 = 12.\\n\\nUpdated result array: [1, 1, 8, 6]\\n\\nFinal Pass: In this final step, update the last element in the result array (index n-1) with right_product.\\n\\nUpdated result array: [1, 1, 8, 12]\\n\\nSo, the final answer array will be [1 * 12, 1 * 12, 8 * 4, 6 * 1] = [12, 12, 32, 6], which matches the expected output [24, 12, 8, 6].\\n\\n\\n\\n\\n"
                    },
                    {
                        "username": "TsuiSauChi",
                        "content": "geez... chatgpt can solve this faster then I can count 1 2 3\\nMeanwhile I\\'m screaming at my scream for 15mins "
                    },
                    {
                        "username": "chirag_shah_16",
                        "content": "I solved the problem using recursion, and having l_arr and r_arr as global keywords but they don\\'t pass the scenarios when you try to submit. The Leetcode compiler should reset global variables before each test case."
                    },
                    {
                        "username": "ibrahimrifat221",
                        "content": "In this problem, we aim to compute an array\\'s element-wise product, excluding the current index. First, we multiply all values, e.g., given `nums = [1, 2, 3, 4]`, the product is `[24, 24, 24, 24]`. Next, we divide each element by its index value, skipping zeros. For instance, `nums = [24//nums[0], 24//nums[1], 24//nums[2], 24//nums[3]]`.  now return `nums` "
                    },
                    {
                        "username": "joemackay",
                        "content": "You skipped the instructions"
                    },
                    {
                        "username": "palak-agg",
                        "content": "How happy I feel after solving this one myself :)"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "I could solve in linear time and const space only when i used `/` operator\\n\\nHint:\\nget `array` product with `zero` count\\nusing `in-place` operation conditionally divide `nums[i]` from `product` "
                    },
                    {
                        "username": "psionl0",
                        "content": "\"You must write an algorithm that runs in O(n) time and without using the division operation\".\\n"
                    },
                    {
                        "username": "himanshuone",
                        "content": "I have used Prefix and postfixes to solve this problem,\nAssume the \"nums = [1,2,3,4]\" array, we need to find the prefix and postfix of the same. Store prefixes in result list.\nPrefix of :                                   prefix=Multiplication of the element before that\n               index 0: 1 ,     1 is the default prefix\n               index 1: 1 ,    prefix*element on index\nWe will do the same with postfix but from the reverse.\n\n\nclass Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res=[1]* (len(nums))\n        prefix=1\n        for i in range(len(nums)):\n            res[i]=prefix\n            prefix*=nums[i]\n        postfix=1\n        for i in range(len(nums)-1,-1,-1):\n            res[i]*=postfix\n            postfix*=nums[i]\n        return res\n"
                    }
                ]
            },
            {
                "id": 1997425,
                "content": [
                    {
                        "username": "wae57",
                        "content": "This is a very difficult question but has been tagged as medium. I have submitted several answers that was not accepted because of \"Time limit exceeded\". \n\nFinally got and answer. It took me a day to figure that out Loool"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "I created two helper functions to calculate the prefix and the suffix product.\nLeetcode isn't accepting this solution because of the time limit exceeded.\nbut the code that i used (as you would see) has a time complexity of O(n) since there's only a single pass through the array, and a space complexity of O(1) since I am not using any extra data structure. \n\nclass Solution:\n\n    def pre(self, i , nums):\n        if i == 0:\n            return 1\n        result = 1\n        for num in range(i):\n            result *= nums[num]\n        return result\n\n    def suf(self, i, nums):\n        if i == len(nums) - 1:\n            return 1\n        result = 1\n        for num in range(i + 1, len(nums)):\n            result *= nums[num]\n        return result\n\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        answer = []\n        for i in range(len(nums)):\n            ans = self.pre(i, nums) * self.suf(i, nums)\n            answer.append(ans)\n        return answer\n\n\n\nIn a real interview, this should be perfect right?"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "[@willq1](/willq1)  thanks mate."
                    },
                    {
                        "username": "willq1",
                        "content": "Your `pre` and `suf` methods iterate the entirety of `nums` length and your main loop calls that every single time. It's still O(N^2) unfortunately"
                    },
                    {
                        "username": "Rajan_Pandey",
                        "content": "Can you guys please let me know what is the problem in my code by dry run it should be working but instead of [ 24,12,8,6 ] I am getting [24,12,4,2];\\n\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            int pSum=1;\\n            for(int j=0;j<nums.size();j++){\\n                if(j==i){\\n                    nums[j]=1;\\n                }\\n                pSum = pSum * nums[j];\\n            }\\n            ans[i]= pSum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "What is the Constraints is 10^9 then this solution wont work ?"
                    },
                    {
                        "username": "ALmighty_25",
                        "content": "public class Solution {\\n    public int[] ProductExceptSelf(int[] nums) {\\n        \\n        int product = 1;\\n        int p= 1;\\n        bool zero = true;\\n        int[] res = new int[nums.Length];\\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n                res[i]=0;\\n            }\\n            else{\\n                zero=false;\\n            }\\n        }\\n        if(zero == true){\\n            return res;\\n        }\\n        for(int i=0;i<nums.Length;i++){\\n            product = product * nums[i]; \\n            if(nums[i]!=0){\\n                p = p* nums[i];\\n            }\\n        }\\n       \\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n              nums[i] = p;\\n                continue;\\n               \\n            }\\n            nums[i] = product / nums[i];\\n        }\\n        return nums;\\n    }\\n}\\n\\n\\nEasy to get but fail"
                    },
                    {
                        "username": "MicahSherry",
                        "content": "O(n)? am I missing something?\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s O(3N) but we drop the constant, so O(N)"
                    },
                    {
                        "username": "AnishJoshi13",
                        "content": "Try to look at the problem like this -- At any position of the array answer the value to be inserted is equal to product of numbers just before that number multiplied by the product of the numbers just after that. "
                    },
                    {
                        "username": "Radhika_20",
                        "content": "calculate the left product of all the elements in the array except for the current element, and stores it in an array, then multiplies the prefix (left product)product with the suffix product(right product) (obtained by traversing from back)to get the final answer."
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "First of all find the number of zeroes present in the array and store it in a count variable \\nand find the product of the array with zeroes and without zeroes .Take if conditions for count \\nwith that you can easily get the desired output.please do upvote if you like it"
                    },
                    {
                        "username": "oops_moment",
                        "content": "HOW TO THINK A QUESTION ?\\nSo when you first get this question , proceed with the brute force that is precalculate the product of all numbers , now to output the answer just output (product/nums[i]) this will be product all numbers execept that number . I guess youare intelligent enough to handle the zero case if more than one zero answer gonna be zero for all, if one zero handle it .\\nBut we are not allowed to use divide aah let us see what else \\nSo may be for each i let\\'s go iterate to the right and left and take product but my brotha it will be N2 , leetcode wont allow you to submit that :(\\nYes here comes memoization , prestore the product of say all number to left of i just like prefix multiplication may be , same do from back side then for each i multiply left[i]*right[i]."
                    }
                ]
            },
            {
                "id": 1996009,
                "content": [
                    {
                        "username": "wae57",
                        "content": "This is a very difficult question but has been tagged as medium. I have submitted several answers that was not accepted because of \"Time limit exceeded\". \n\nFinally got and answer. It took me a day to figure that out Loool"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "I created two helper functions to calculate the prefix and the suffix product.\nLeetcode isn't accepting this solution because of the time limit exceeded.\nbut the code that i used (as you would see) has a time complexity of O(n) since there's only a single pass through the array, and a space complexity of O(1) since I am not using any extra data structure. \n\nclass Solution:\n\n    def pre(self, i , nums):\n        if i == 0:\n            return 1\n        result = 1\n        for num in range(i):\n            result *= nums[num]\n        return result\n\n    def suf(self, i, nums):\n        if i == len(nums) - 1:\n            return 1\n        result = 1\n        for num in range(i + 1, len(nums)):\n            result *= nums[num]\n        return result\n\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        answer = []\n        for i in range(len(nums)):\n            ans = self.pre(i, nums) * self.suf(i, nums)\n            answer.append(ans)\n        return answer\n\n\n\nIn a real interview, this should be perfect right?"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "[@willq1](/willq1)  thanks mate."
                    },
                    {
                        "username": "willq1",
                        "content": "Your `pre` and `suf` methods iterate the entirety of `nums` length and your main loop calls that every single time. It's still O(N^2) unfortunately"
                    },
                    {
                        "username": "Rajan_Pandey",
                        "content": "Can you guys please let me know what is the problem in my code by dry run it should be working but instead of [ 24,12,8,6 ] I am getting [24,12,4,2];\\n\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            int pSum=1;\\n            for(int j=0;j<nums.size();j++){\\n                if(j==i){\\n                    nums[j]=1;\\n                }\\n                pSum = pSum * nums[j];\\n            }\\n            ans[i]= pSum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "What is the Constraints is 10^9 then this solution wont work ?"
                    },
                    {
                        "username": "ALmighty_25",
                        "content": "public class Solution {\\n    public int[] ProductExceptSelf(int[] nums) {\\n        \\n        int product = 1;\\n        int p= 1;\\n        bool zero = true;\\n        int[] res = new int[nums.Length];\\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n                res[i]=0;\\n            }\\n            else{\\n                zero=false;\\n            }\\n        }\\n        if(zero == true){\\n            return res;\\n        }\\n        for(int i=0;i<nums.Length;i++){\\n            product = product * nums[i]; \\n            if(nums[i]!=0){\\n                p = p* nums[i];\\n            }\\n        }\\n       \\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n              nums[i] = p;\\n                continue;\\n               \\n            }\\n            nums[i] = product / nums[i];\\n        }\\n        return nums;\\n    }\\n}\\n\\n\\nEasy to get but fail"
                    },
                    {
                        "username": "MicahSherry",
                        "content": "O(n)? am I missing something?\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s O(3N) but we drop the constant, so O(N)"
                    },
                    {
                        "username": "AnishJoshi13",
                        "content": "Try to look at the problem like this -- At any position of the array answer the value to be inserted is equal to product of numbers just before that number multiplied by the product of the numbers just after that. "
                    },
                    {
                        "username": "Radhika_20",
                        "content": "calculate the left product of all the elements in the array except for the current element, and stores it in an array, then multiplies the prefix (left product)product with the suffix product(right product) (obtained by traversing from back)to get the final answer."
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "First of all find the number of zeroes present in the array and store it in a count variable \\nand find the product of the array with zeroes and without zeroes .Take if conditions for count \\nwith that you can easily get the desired output.please do upvote if you like it"
                    },
                    {
                        "username": "oops_moment",
                        "content": "HOW TO THINK A QUESTION ?\\nSo when you first get this question , proceed with the brute force that is precalculate the product of all numbers , now to output the answer just output (product/nums[i]) this will be product all numbers execept that number . I guess youare intelligent enough to handle the zero case if more than one zero answer gonna be zero for all, if one zero handle it .\\nBut we are not allowed to use divide aah let us see what else \\nSo may be for each i let\\'s go iterate to the right and left and take product but my brotha it will be N2 , leetcode wont allow you to submit that :(\\nYes here comes memoization , prestore the product of say all number to left of i just like prefix multiplication may be , same do from back side then for each i multiply left[i]*right[i]."
                    }
                ]
            },
            {
                "id": 1995774,
                "content": [
                    {
                        "username": "wae57",
                        "content": "This is a very difficult question but has been tagged as medium. I have submitted several answers that was not accepted because of \"Time limit exceeded\". \n\nFinally got and answer. It took me a day to figure that out Loool"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "I created two helper functions to calculate the prefix and the suffix product.\nLeetcode isn't accepting this solution because of the time limit exceeded.\nbut the code that i used (as you would see) has a time complexity of O(n) since there's only a single pass through the array, and a space complexity of O(1) since I am not using any extra data structure. \n\nclass Solution:\n\n    def pre(self, i , nums):\n        if i == 0:\n            return 1\n        result = 1\n        for num in range(i):\n            result *= nums[num]\n        return result\n\n    def suf(self, i, nums):\n        if i == len(nums) - 1:\n            return 1\n        result = 1\n        for num in range(i + 1, len(nums)):\n            result *= nums[num]\n        return result\n\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        answer = []\n        for i in range(len(nums)):\n            ans = self.pre(i, nums) * self.suf(i, nums)\n            answer.append(ans)\n        return answer\n\n\n\nIn a real interview, this should be perfect right?"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "[@willq1](/willq1)  thanks mate."
                    },
                    {
                        "username": "willq1",
                        "content": "Your `pre` and `suf` methods iterate the entirety of `nums` length and your main loop calls that every single time. It's still O(N^2) unfortunately"
                    },
                    {
                        "username": "Rajan_Pandey",
                        "content": "Can you guys please let me know what is the problem in my code by dry run it should be working but instead of [ 24,12,8,6 ] I am getting [24,12,4,2];\\n\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            int pSum=1;\\n            for(int j=0;j<nums.size();j++){\\n                if(j==i){\\n                    nums[j]=1;\\n                }\\n                pSum = pSum * nums[j];\\n            }\\n            ans[i]= pSum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "What is the Constraints is 10^9 then this solution wont work ?"
                    },
                    {
                        "username": "ALmighty_25",
                        "content": "public class Solution {\\n    public int[] ProductExceptSelf(int[] nums) {\\n        \\n        int product = 1;\\n        int p= 1;\\n        bool zero = true;\\n        int[] res = new int[nums.Length];\\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n                res[i]=0;\\n            }\\n            else{\\n                zero=false;\\n            }\\n        }\\n        if(zero == true){\\n            return res;\\n        }\\n        for(int i=0;i<nums.Length;i++){\\n            product = product * nums[i]; \\n            if(nums[i]!=0){\\n                p = p* nums[i];\\n            }\\n        }\\n       \\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n              nums[i] = p;\\n                continue;\\n               \\n            }\\n            nums[i] = product / nums[i];\\n        }\\n        return nums;\\n    }\\n}\\n\\n\\nEasy to get but fail"
                    },
                    {
                        "username": "MicahSherry",
                        "content": "O(n)? am I missing something?\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s O(3N) but we drop the constant, so O(N)"
                    },
                    {
                        "username": "AnishJoshi13",
                        "content": "Try to look at the problem like this -- At any position of the array answer the value to be inserted is equal to product of numbers just before that number multiplied by the product of the numbers just after that. "
                    },
                    {
                        "username": "Radhika_20",
                        "content": "calculate the left product of all the elements in the array except for the current element, and stores it in an array, then multiplies the prefix (left product)product with the suffix product(right product) (obtained by traversing from back)to get the final answer."
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "First of all find the number of zeroes present in the array and store it in a count variable \\nand find the product of the array with zeroes and without zeroes .Take if conditions for count \\nwith that you can easily get the desired output.please do upvote if you like it"
                    },
                    {
                        "username": "oops_moment",
                        "content": "HOW TO THINK A QUESTION ?\\nSo when you first get this question , proceed with the brute force that is precalculate the product of all numbers , now to output the answer just output (product/nums[i]) this will be product all numbers execept that number . I guess youare intelligent enough to handle the zero case if more than one zero answer gonna be zero for all, if one zero handle it .\\nBut we are not allowed to use divide aah let us see what else \\nSo may be for each i let\\'s go iterate to the right and left and take product but my brotha it will be N2 , leetcode wont allow you to submit that :(\\nYes here comes memoization , prestore the product of say all number to left of i just like prefix multiplication may be , same do from back side then for each i multiply left[i]*right[i]."
                    }
                ]
            },
            {
                "id": 1989689,
                "content": [
                    {
                        "username": "wae57",
                        "content": "This is a very difficult question but has been tagged as medium. I have submitted several answers that was not accepted because of \"Time limit exceeded\". \n\nFinally got and answer. It took me a day to figure that out Loool"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "I created two helper functions to calculate the prefix and the suffix product.\nLeetcode isn't accepting this solution because of the time limit exceeded.\nbut the code that i used (as you would see) has a time complexity of O(n) since there's only a single pass through the array, and a space complexity of O(1) since I am not using any extra data structure. \n\nclass Solution:\n\n    def pre(self, i , nums):\n        if i == 0:\n            return 1\n        result = 1\n        for num in range(i):\n            result *= nums[num]\n        return result\n\n    def suf(self, i, nums):\n        if i == len(nums) - 1:\n            return 1\n        result = 1\n        for num in range(i + 1, len(nums)):\n            result *= nums[num]\n        return result\n\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        answer = []\n        for i in range(len(nums)):\n            ans = self.pre(i, nums) * self.suf(i, nums)\n            answer.append(ans)\n        return answer\n\n\n\nIn a real interview, this should be perfect right?"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "[@willq1](/willq1)  thanks mate."
                    },
                    {
                        "username": "willq1",
                        "content": "Your `pre` and `suf` methods iterate the entirety of `nums` length and your main loop calls that every single time. It's still O(N^2) unfortunately"
                    },
                    {
                        "username": "Rajan_Pandey",
                        "content": "Can you guys please let me know what is the problem in my code by dry run it should be working but instead of [ 24,12,8,6 ] I am getting [24,12,4,2];\\n\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            int pSum=1;\\n            for(int j=0;j<nums.size();j++){\\n                if(j==i){\\n                    nums[j]=1;\\n                }\\n                pSum = pSum * nums[j];\\n            }\\n            ans[i]= pSum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "What is the Constraints is 10^9 then this solution wont work ?"
                    },
                    {
                        "username": "ALmighty_25",
                        "content": "public class Solution {\\n    public int[] ProductExceptSelf(int[] nums) {\\n        \\n        int product = 1;\\n        int p= 1;\\n        bool zero = true;\\n        int[] res = new int[nums.Length];\\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n                res[i]=0;\\n            }\\n            else{\\n                zero=false;\\n            }\\n        }\\n        if(zero == true){\\n            return res;\\n        }\\n        for(int i=0;i<nums.Length;i++){\\n            product = product * nums[i]; \\n            if(nums[i]!=0){\\n                p = p* nums[i];\\n            }\\n        }\\n       \\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n              nums[i] = p;\\n                continue;\\n               \\n            }\\n            nums[i] = product / nums[i];\\n        }\\n        return nums;\\n    }\\n}\\n\\n\\nEasy to get but fail"
                    },
                    {
                        "username": "MicahSherry",
                        "content": "O(n)? am I missing something?\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s O(3N) but we drop the constant, so O(N)"
                    },
                    {
                        "username": "AnishJoshi13",
                        "content": "Try to look at the problem like this -- At any position of the array answer the value to be inserted is equal to product of numbers just before that number multiplied by the product of the numbers just after that. "
                    },
                    {
                        "username": "Radhika_20",
                        "content": "calculate the left product of all the elements in the array except for the current element, and stores it in an array, then multiplies the prefix (left product)product with the suffix product(right product) (obtained by traversing from back)to get the final answer."
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "First of all find the number of zeroes present in the array and store it in a count variable \\nand find the product of the array with zeroes and without zeroes .Take if conditions for count \\nwith that you can easily get the desired output.please do upvote if you like it"
                    },
                    {
                        "username": "oops_moment",
                        "content": "HOW TO THINK A QUESTION ?\\nSo when you first get this question , proceed with the brute force that is precalculate the product of all numbers , now to output the answer just output (product/nums[i]) this will be product all numbers execept that number . I guess youare intelligent enough to handle the zero case if more than one zero answer gonna be zero for all, if one zero handle it .\\nBut we are not allowed to use divide aah let us see what else \\nSo may be for each i let\\'s go iterate to the right and left and take product but my brotha it will be N2 , leetcode wont allow you to submit that :(\\nYes here comes memoization , prestore the product of say all number to left of i just like prefix multiplication may be , same do from back side then for each i multiply left[i]*right[i]."
                    }
                ]
            },
            {
                "id": 1982323,
                "content": [
                    {
                        "username": "wae57",
                        "content": "This is a very difficult question but has been tagged as medium. I have submitted several answers that was not accepted because of \"Time limit exceeded\". \n\nFinally got and answer. It took me a day to figure that out Loool"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "I created two helper functions to calculate the prefix and the suffix product.\nLeetcode isn't accepting this solution because of the time limit exceeded.\nbut the code that i used (as you would see) has a time complexity of O(n) since there's only a single pass through the array, and a space complexity of O(1) since I am not using any extra data structure. \n\nclass Solution:\n\n    def pre(self, i , nums):\n        if i == 0:\n            return 1\n        result = 1\n        for num in range(i):\n            result *= nums[num]\n        return result\n\n    def suf(self, i, nums):\n        if i == len(nums) - 1:\n            return 1\n        result = 1\n        for num in range(i + 1, len(nums)):\n            result *= nums[num]\n        return result\n\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        answer = []\n        for i in range(len(nums)):\n            ans = self.pre(i, nums) * self.suf(i, nums)\n            answer.append(ans)\n        return answer\n\n\n\nIn a real interview, this should be perfect right?"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "[@willq1](/willq1)  thanks mate."
                    },
                    {
                        "username": "willq1",
                        "content": "Your `pre` and `suf` methods iterate the entirety of `nums` length and your main loop calls that every single time. It's still O(N^2) unfortunately"
                    },
                    {
                        "username": "Rajan_Pandey",
                        "content": "Can you guys please let me know what is the problem in my code by dry run it should be working but instead of [ 24,12,8,6 ] I am getting [24,12,4,2];\\n\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            int pSum=1;\\n            for(int j=0;j<nums.size();j++){\\n                if(j==i){\\n                    nums[j]=1;\\n                }\\n                pSum = pSum * nums[j];\\n            }\\n            ans[i]= pSum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "What is the Constraints is 10^9 then this solution wont work ?"
                    },
                    {
                        "username": "ALmighty_25",
                        "content": "public class Solution {\\n    public int[] ProductExceptSelf(int[] nums) {\\n        \\n        int product = 1;\\n        int p= 1;\\n        bool zero = true;\\n        int[] res = new int[nums.Length];\\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n                res[i]=0;\\n            }\\n            else{\\n                zero=false;\\n            }\\n        }\\n        if(zero == true){\\n            return res;\\n        }\\n        for(int i=0;i<nums.Length;i++){\\n            product = product * nums[i]; \\n            if(nums[i]!=0){\\n                p = p* nums[i];\\n            }\\n        }\\n       \\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n              nums[i] = p;\\n                continue;\\n               \\n            }\\n            nums[i] = product / nums[i];\\n        }\\n        return nums;\\n    }\\n}\\n\\n\\nEasy to get but fail"
                    },
                    {
                        "username": "MicahSherry",
                        "content": "O(n)? am I missing something?\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s O(3N) but we drop the constant, so O(N)"
                    },
                    {
                        "username": "AnishJoshi13",
                        "content": "Try to look at the problem like this -- At any position of the array answer the value to be inserted is equal to product of numbers just before that number multiplied by the product of the numbers just after that. "
                    },
                    {
                        "username": "Radhika_20",
                        "content": "calculate the left product of all the elements in the array except for the current element, and stores it in an array, then multiplies the prefix (left product)product with the suffix product(right product) (obtained by traversing from back)to get the final answer."
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "First of all find the number of zeroes present in the array and store it in a count variable \\nand find the product of the array with zeroes and without zeroes .Take if conditions for count \\nwith that you can easily get the desired output.please do upvote if you like it"
                    },
                    {
                        "username": "oops_moment",
                        "content": "HOW TO THINK A QUESTION ?\\nSo when you first get this question , proceed with the brute force that is precalculate the product of all numbers , now to output the answer just output (product/nums[i]) this will be product all numbers execept that number . I guess youare intelligent enough to handle the zero case if more than one zero answer gonna be zero for all, if one zero handle it .\\nBut we are not allowed to use divide aah let us see what else \\nSo may be for each i let\\'s go iterate to the right and left and take product but my brotha it will be N2 , leetcode wont allow you to submit that :(\\nYes here comes memoization , prestore the product of say all number to left of i just like prefix multiplication may be , same do from back side then for each i multiply left[i]*right[i]."
                    }
                ]
            },
            {
                "id": 1979159,
                "content": [
                    {
                        "username": "wae57",
                        "content": "This is a very difficult question but has been tagged as medium. I have submitted several answers that was not accepted because of \"Time limit exceeded\". \n\nFinally got and answer. It took me a day to figure that out Loool"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "I created two helper functions to calculate the prefix and the suffix product.\nLeetcode isn't accepting this solution because of the time limit exceeded.\nbut the code that i used (as you would see) has a time complexity of O(n) since there's only a single pass through the array, and a space complexity of O(1) since I am not using any extra data structure. \n\nclass Solution:\n\n    def pre(self, i , nums):\n        if i == 0:\n            return 1\n        result = 1\n        for num in range(i):\n            result *= nums[num]\n        return result\n\n    def suf(self, i, nums):\n        if i == len(nums) - 1:\n            return 1\n        result = 1\n        for num in range(i + 1, len(nums)):\n            result *= nums[num]\n        return result\n\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        answer = []\n        for i in range(len(nums)):\n            ans = self.pre(i, nums) * self.suf(i, nums)\n            answer.append(ans)\n        return answer\n\n\n\nIn a real interview, this should be perfect right?"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "[@willq1](/willq1)  thanks mate."
                    },
                    {
                        "username": "willq1",
                        "content": "Your `pre` and `suf` methods iterate the entirety of `nums` length and your main loop calls that every single time. It's still O(N^2) unfortunately"
                    },
                    {
                        "username": "Rajan_Pandey",
                        "content": "Can you guys please let me know what is the problem in my code by dry run it should be working but instead of [ 24,12,8,6 ] I am getting [24,12,4,2];\\n\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            int pSum=1;\\n            for(int j=0;j<nums.size();j++){\\n                if(j==i){\\n                    nums[j]=1;\\n                }\\n                pSum = pSum * nums[j];\\n            }\\n            ans[i]= pSum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "What is the Constraints is 10^9 then this solution wont work ?"
                    },
                    {
                        "username": "ALmighty_25",
                        "content": "public class Solution {\\n    public int[] ProductExceptSelf(int[] nums) {\\n        \\n        int product = 1;\\n        int p= 1;\\n        bool zero = true;\\n        int[] res = new int[nums.Length];\\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n                res[i]=0;\\n            }\\n            else{\\n                zero=false;\\n            }\\n        }\\n        if(zero == true){\\n            return res;\\n        }\\n        for(int i=0;i<nums.Length;i++){\\n            product = product * nums[i]; \\n            if(nums[i]!=0){\\n                p = p* nums[i];\\n            }\\n        }\\n       \\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n              nums[i] = p;\\n                continue;\\n               \\n            }\\n            nums[i] = product / nums[i];\\n        }\\n        return nums;\\n    }\\n}\\n\\n\\nEasy to get but fail"
                    },
                    {
                        "username": "MicahSherry",
                        "content": "O(n)? am I missing something?\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s O(3N) but we drop the constant, so O(N)"
                    },
                    {
                        "username": "AnishJoshi13",
                        "content": "Try to look at the problem like this -- At any position of the array answer the value to be inserted is equal to product of numbers just before that number multiplied by the product of the numbers just after that. "
                    },
                    {
                        "username": "Radhika_20",
                        "content": "calculate the left product of all the elements in the array except for the current element, and stores it in an array, then multiplies the prefix (left product)product with the suffix product(right product) (obtained by traversing from back)to get the final answer."
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "First of all find the number of zeroes present in the array and store it in a count variable \\nand find the product of the array with zeroes and without zeroes .Take if conditions for count \\nwith that you can easily get the desired output.please do upvote if you like it"
                    },
                    {
                        "username": "oops_moment",
                        "content": "HOW TO THINK A QUESTION ?\\nSo when you first get this question , proceed with the brute force that is precalculate the product of all numbers , now to output the answer just output (product/nums[i]) this will be product all numbers execept that number . I guess youare intelligent enough to handle the zero case if more than one zero answer gonna be zero for all, if one zero handle it .\\nBut we are not allowed to use divide aah let us see what else \\nSo may be for each i let\\'s go iterate to the right and left and take product but my brotha it will be N2 , leetcode wont allow you to submit that :(\\nYes here comes memoization , prestore the product of say all number to left of i just like prefix multiplication may be , same do from back side then for each i multiply left[i]*right[i]."
                    }
                ]
            },
            {
                "id": 1978010,
                "content": [
                    {
                        "username": "wae57",
                        "content": "This is a very difficult question but has been tagged as medium. I have submitted several answers that was not accepted because of \"Time limit exceeded\". \n\nFinally got and answer. It took me a day to figure that out Loool"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "I created two helper functions to calculate the prefix and the suffix product.\nLeetcode isn't accepting this solution because of the time limit exceeded.\nbut the code that i used (as you would see) has a time complexity of O(n) since there's only a single pass through the array, and a space complexity of O(1) since I am not using any extra data structure. \n\nclass Solution:\n\n    def pre(self, i , nums):\n        if i == 0:\n            return 1\n        result = 1\n        for num in range(i):\n            result *= nums[num]\n        return result\n\n    def suf(self, i, nums):\n        if i == len(nums) - 1:\n            return 1\n        result = 1\n        for num in range(i + 1, len(nums)):\n            result *= nums[num]\n        return result\n\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        answer = []\n        for i in range(len(nums)):\n            ans = self.pre(i, nums) * self.suf(i, nums)\n            answer.append(ans)\n        return answer\n\n\n\nIn a real interview, this should be perfect right?"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "[@willq1](/willq1)  thanks mate."
                    },
                    {
                        "username": "willq1",
                        "content": "Your `pre` and `suf` methods iterate the entirety of `nums` length and your main loop calls that every single time. It's still O(N^2) unfortunately"
                    },
                    {
                        "username": "Rajan_Pandey",
                        "content": "Can you guys please let me know what is the problem in my code by dry run it should be working but instead of [ 24,12,8,6 ] I am getting [24,12,4,2];\\n\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            int pSum=1;\\n            for(int j=0;j<nums.size();j++){\\n                if(j==i){\\n                    nums[j]=1;\\n                }\\n                pSum = pSum * nums[j];\\n            }\\n            ans[i]= pSum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "What is the Constraints is 10^9 then this solution wont work ?"
                    },
                    {
                        "username": "ALmighty_25",
                        "content": "public class Solution {\\n    public int[] ProductExceptSelf(int[] nums) {\\n        \\n        int product = 1;\\n        int p= 1;\\n        bool zero = true;\\n        int[] res = new int[nums.Length];\\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n                res[i]=0;\\n            }\\n            else{\\n                zero=false;\\n            }\\n        }\\n        if(zero == true){\\n            return res;\\n        }\\n        for(int i=0;i<nums.Length;i++){\\n            product = product * nums[i]; \\n            if(nums[i]!=0){\\n                p = p* nums[i];\\n            }\\n        }\\n       \\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n              nums[i] = p;\\n                continue;\\n               \\n            }\\n            nums[i] = product / nums[i];\\n        }\\n        return nums;\\n    }\\n}\\n\\n\\nEasy to get but fail"
                    },
                    {
                        "username": "MicahSherry",
                        "content": "O(n)? am I missing something?\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s O(3N) but we drop the constant, so O(N)"
                    },
                    {
                        "username": "AnishJoshi13",
                        "content": "Try to look at the problem like this -- At any position of the array answer the value to be inserted is equal to product of numbers just before that number multiplied by the product of the numbers just after that. "
                    },
                    {
                        "username": "Radhika_20",
                        "content": "calculate the left product of all the elements in the array except for the current element, and stores it in an array, then multiplies the prefix (left product)product with the suffix product(right product) (obtained by traversing from back)to get the final answer."
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "First of all find the number of zeroes present in the array and store it in a count variable \\nand find the product of the array with zeroes and without zeroes .Take if conditions for count \\nwith that you can easily get the desired output.please do upvote if you like it"
                    },
                    {
                        "username": "oops_moment",
                        "content": "HOW TO THINK A QUESTION ?\\nSo when you first get this question , proceed with the brute force that is precalculate the product of all numbers , now to output the answer just output (product/nums[i]) this will be product all numbers execept that number . I guess youare intelligent enough to handle the zero case if more than one zero answer gonna be zero for all, if one zero handle it .\\nBut we are not allowed to use divide aah let us see what else \\nSo may be for each i let\\'s go iterate to the right and left and take product but my brotha it will be N2 , leetcode wont allow you to submit that :(\\nYes here comes memoization , prestore the product of say all number to left of i just like prefix multiplication may be , same do from back side then for each i multiply left[i]*right[i]."
                    }
                ]
            },
            {
                "id": 1974169,
                "content": [
                    {
                        "username": "wae57",
                        "content": "This is a very difficult question but has been tagged as medium. I have submitted several answers that was not accepted because of \"Time limit exceeded\". \n\nFinally got and answer. It took me a day to figure that out Loool"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "I created two helper functions to calculate the prefix and the suffix product.\nLeetcode isn't accepting this solution because of the time limit exceeded.\nbut the code that i used (as you would see) has a time complexity of O(n) since there's only a single pass through the array, and a space complexity of O(1) since I am not using any extra data structure. \n\nclass Solution:\n\n    def pre(self, i , nums):\n        if i == 0:\n            return 1\n        result = 1\n        for num in range(i):\n            result *= nums[num]\n        return result\n\n    def suf(self, i, nums):\n        if i == len(nums) - 1:\n            return 1\n        result = 1\n        for num in range(i + 1, len(nums)):\n            result *= nums[num]\n        return result\n\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        answer = []\n        for i in range(len(nums)):\n            ans = self.pre(i, nums) * self.suf(i, nums)\n            answer.append(ans)\n        return answer\n\n\n\nIn a real interview, this should be perfect right?"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "[@willq1](/willq1)  thanks mate."
                    },
                    {
                        "username": "willq1",
                        "content": "Your `pre` and `suf` methods iterate the entirety of `nums` length and your main loop calls that every single time. It's still O(N^2) unfortunately"
                    },
                    {
                        "username": "Rajan_Pandey",
                        "content": "Can you guys please let me know what is the problem in my code by dry run it should be working but instead of [ 24,12,8,6 ] I am getting [24,12,4,2];\\n\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            int pSum=1;\\n            for(int j=0;j<nums.size();j++){\\n                if(j==i){\\n                    nums[j]=1;\\n                }\\n                pSum = pSum * nums[j];\\n            }\\n            ans[i]= pSum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "What is the Constraints is 10^9 then this solution wont work ?"
                    },
                    {
                        "username": "ALmighty_25",
                        "content": "public class Solution {\\n    public int[] ProductExceptSelf(int[] nums) {\\n        \\n        int product = 1;\\n        int p= 1;\\n        bool zero = true;\\n        int[] res = new int[nums.Length];\\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n                res[i]=0;\\n            }\\n            else{\\n                zero=false;\\n            }\\n        }\\n        if(zero == true){\\n            return res;\\n        }\\n        for(int i=0;i<nums.Length;i++){\\n            product = product * nums[i]; \\n            if(nums[i]!=0){\\n                p = p* nums[i];\\n            }\\n        }\\n       \\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n              nums[i] = p;\\n                continue;\\n               \\n            }\\n            nums[i] = product / nums[i];\\n        }\\n        return nums;\\n    }\\n}\\n\\n\\nEasy to get but fail"
                    },
                    {
                        "username": "MicahSherry",
                        "content": "O(n)? am I missing something?\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s O(3N) but we drop the constant, so O(N)"
                    },
                    {
                        "username": "AnishJoshi13",
                        "content": "Try to look at the problem like this -- At any position of the array answer the value to be inserted is equal to product of numbers just before that number multiplied by the product of the numbers just after that. "
                    },
                    {
                        "username": "Radhika_20",
                        "content": "calculate the left product of all the elements in the array except for the current element, and stores it in an array, then multiplies the prefix (left product)product with the suffix product(right product) (obtained by traversing from back)to get the final answer."
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "First of all find the number of zeroes present in the array and store it in a count variable \\nand find the product of the array with zeroes and without zeroes .Take if conditions for count \\nwith that you can easily get the desired output.please do upvote if you like it"
                    },
                    {
                        "username": "oops_moment",
                        "content": "HOW TO THINK A QUESTION ?\\nSo when you first get this question , proceed with the brute force that is precalculate the product of all numbers , now to output the answer just output (product/nums[i]) this will be product all numbers execept that number . I guess youare intelligent enough to handle the zero case if more than one zero answer gonna be zero for all, if one zero handle it .\\nBut we are not allowed to use divide aah let us see what else \\nSo may be for each i let\\'s go iterate to the right and left and take product but my brotha it will be N2 , leetcode wont allow you to submit that :(\\nYes here comes memoization , prestore the product of say all number to left of i just like prefix multiplication may be , same do from back side then for each i multiply left[i]*right[i]."
                    }
                ]
            },
            {
                "id": 1967688,
                "content": [
                    {
                        "username": "wae57",
                        "content": "This is a very difficult question but has been tagged as medium. I have submitted several answers that was not accepted because of \"Time limit exceeded\". \n\nFinally got and answer. It took me a day to figure that out Loool"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "I created two helper functions to calculate the prefix and the suffix product.\nLeetcode isn't accepting this solution because of the time limit exceeded.\nbut the code that i used (as you would see) has a time complexity of O(n) since there's only a single pass through the array, and a space complexity of O(1) since I am not using any extra data structure. \n\nclass Solution:\n\n    def pre(self, i , nums):\n        if i == 0:\n            return 1\n        result = 1\n        for num in range(i):\n            result *= nums[num]\n        return result\n\n    def suf(self, i, nums):\n        if i == len(nums) - 1:\n            return 1\n        result = 1\n        for num in range(i + 1, len(nums)):\n            result *= nums[num]\n        return result\n\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        answer = []\n        for i in range(len(nums)):\n            ans = self.pre(i, nums) * self.suf(i, nums)\n            answer.append(ans)\n        return answer\n\n\n\nIn a real interview, this should be perfect right?"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "[@willq1](/willq1)  thanks mate."
                    },
                    {
                        "username": "willq1",
                        "content": "Your `pre` and `suf` methods iterate the entirety of `nums` length and your main loop calls that every single time. It's still O(N^2) unfortunately"
                    },
                    {
                        "username": "Rajan_Pandey",
                        "content": "Can you guys please let me know what is the problem in my code by dry run it should be working but instead of [ 24,12,8,6 ] I am getting [24,12,4,2];\\n\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            int pSum=1;\\n            for(int j=0;j<nums.size();j++){\\n                if(j==i){\\n                    nums[j]=1;\\n                }\\n                pSum = pSum * nums[j];\\n            }\\n            ans[i]= pSum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "What is the Constraints is 10^9 then this solution wont work ?"
                    },
                    {
                        "username": "ALmighty_25",
                        "content": "public class Solution {\\n    public int[] ProductExceptSelf(int[] nums) {\\n        \\n        int product = 1;\\n        int p= 1;\\n        bool zero = true;\\n        int[] res = new int[nums.Length];\\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n                res[i]=0;\\n            }\\n            else{\\n                zero=false;\\n            }\\n        }\\n        if(zero == true){\\n            return res;\\n        }\\n        for(int i=0;i<nums.Length;i++){\\n            product = product * nums[i]; \\n            if(nums[i]!=0){\\n                p = p* nums[i];\\n            }\\n        }\\n       \\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n              nums[i] = p;\\n                continue;\\n               \\n            }\\n            nums[i] = product / nums[i];\\n        }\\n        return nums;\\n    }\\n}\\n\\n\\nEasy to get but fail"
                    },
                    {
                        "username": "MicahSherry",
                        "content": "O(n)? am I missing something?\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s O(3N) but we drop the constant, so O(N)"
                    },
                    {
                        "username": "AnishJoshi13",
                        "content": "Try to look at the problem like this -- At any position of the array answer the value to be inserted is equal to product of numbers just before that number multiplied by the product of the numbers just after that. "
                    },
                    {
                        "username": "Radhika_20",
                        "content": "calculate the left product of all the elements in the array except for the current element, and stores it in an array, then multiplies the prefix (left product)product with the suffix product(right product) (obtained by traversing from back)to get the final answer."
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "First of all find the number of zeroes present in the array and store it in a count variable \\nand find the product of the array with zeroes and without zeroes .Take if conditions for count \\nwith that you can easily get the desired output.please do upvote if you like it"
                    },
                    {
                        "username": "oops_moment",
                        "content": "HOW TO THINK A QUESTION ?\\nSo when you first get this question , proceed with the brute force that is precalculate the product of all numbers , now to output the answer just output (product/nums[i]) this will be product all numbers execept that number . I guess youare intelligent enough to handle the zero case if more than one zero answer gonna be zero for all, if one zero handle it .\\nBut we are not allowed to use divide aah let us see what else \\nSo may be for each i let\\'s go iterate to the right and left and take product but my brotha it will be N2 , leetcode wont allow you to submit that :(\\nYes here comes memoization , prestore the product of say all number to left of i just like prefix multiplication may be , same do from back side then for each i multiply left[i]*right[i]."
                    }
                ]
            },
            {
                "id": 1965849,
                "content": [
                    {
                        "username": "wae57",
                        "content": "This is a very difficult question but has been tagged as medium. I have submitted several answers that was not accepted because of \"Time limit exceeded\". \n\nFinally got and answer. It took me a day to figure that out Loool"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "I created two helper functions to calculate the prefix and the suffix product.\nLeetcode isn't accepting this solution because of the time limit exceeded.\nbut the code that i used (as you would see) has a time complexity of O(n) since there's only a single pass through the array, and a space complexity of O(1) since I am not using any extra data structure. \n\nclass Solution:\n\n    def pre(self, i , nums):\n        if i == 0:\n            return 1\n        result = 1\n        for num in range(i):\n            result *= nums[num]\n        return result\n\n    def suf(self, i, nums):\n        if i == len(nums) - 1:\n            return 1\n        result = 1\n        for num in range(i + 1, len(nums)):\n            result *= nums[num]\n        return result\n\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        answer = []\n        for i in range(len(nums)):\n            ans = self.pre(i, nums) * self.suf(i, nums)\n            answer.append(ans)\n        return answer\n\n\n\nIn a real interview, this should be perfect right?"
                    },
                    {
                        "username": "abinvarghese90",
                        "content": "[@willq1](/willq1)  thanks mate."
                    },
                    {
                        "username": "willq1",
                        "content": "Your `pre` and `suf` methods iterate the entirety of `nums` length and your main loop calls that every single time. It's still O(N^2) unfortunately"
                    },
                    {
                        "username": "Rajan_Pandey",
                        "content": "Can you guys please let me know what is the problem in my code by dry run it should be working but instead of [ 24,12,8,6 ] I am getting [24,12,4,2];\\n\\nclass Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        for(int i=0;i<nums.size();i++){\\n            int pSum=1;\\n            for(int j=0;j<nums.size();j++){\\n                if(j==i){\\n                    nums[j]=1;\\n                }\\n                pSum = pSum * nums[j];\\n            }\\n            ans[i]= pSum;\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "walkytalkyshubham",
                        "content": "What is the Constraints is 10^9 then this solution wont work ?"
                    },
                    {
                        "username": "ALmighty_25",
                        "content": "public class Solution {\\n    public int[] ProductExceptSelf(int[] nums) {\\n        \\n        int product = 1;\\n        int p= 1;\\n        bool zero = true;\\n        int[] res = new int[nums.Length];\\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n                res[i]=0;\\n            }\\n            else{\\n                zero=false;\\n            }\\n        }\\n        if(zero == true){\\n            return res;\\n        }\\n        for(int i=0;i<nums.Length;i++){\\n            product = product * nums[i]; \\n            if(nums[i]!=0){\\n                p = p* nums[i];\\n            }\\n        }\\n       \\n        for(int i=0;i<nums.Length;i++){\\n            if(nums[i]==0){\\n              nums[i] = p;\\n                continue;\\n               \\n            }\\n            nums[i] = product / nums[i];\\n        }\\n        return nums;\\n    }\\n}\\n\\n\\nEasy to get but fail"
                    },
                    {
                        "username": "MicahSherry",
                        "content": "O(n)? am I missing something?\\n"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "It\\'s O(3N) but we drop the constant, so O(N)"
                    },
                    {
                        "username": "AnishJoshi13",
                        "content": "Try to look at the problem like this -- At any position of the array answer the value to be inserted is equal to product of numbers just before that number multiplied by the product of the numbers just after that. "
                    },
                    {
                        "username": "Radhika_20",
                        "content": "calculate the left product of all the elements in the array except for the current element, and stores it in an array, then multiplies the prefix (left product)product with the suffix product(right product) (obtained by traversing from back)to get the final answer."
                    },
                    {
                        "username": "Shashiala1234",
                        "content": "First of all find the number of zeroes present in the array and store it in a count variable \\nand find the product of the array with zeroes and without zeroes .Take if conditions for count \\nwith that you can easily get the desired output.please do upvote if you like it"
                    },
                    {
                        "username": "oops_moment",
                        "content": "HOW TO THINK A QUESTION ?\\nSo when you first get this question , proceed with the brute force that is precalculate the product of all numbers , now to output the answer just output (product/nums[i]) this will be product all numbers execept that number . I guess youare intelligent enough to handle the zero case if more than one zero answer gonna be zero for all, if one zero handle it .\\nBut we are not allowed to use divide aah let us see what else \\nSo may be for each i let\\'s go iterate to the right and left and take product but my brotha it will be N2 , leetcode wont allow you to submit that :(\\nYes here comes memoization , prestore the product of say all number to left of i just like prefix multiplication may be , same do from back side then for each i multiply left[i]*right[i]."
                    }
                ]
            },
            {
                "id": 1959382,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "If you find java solution, follow this: https://leetcode.com/problems/product-of-array-except-self/submissions/988226077"
                    },
                    {
                        "username": "govinda_P",
                        "content": "Hint: Use logs and exponent to divide the number without using division operator.\\nproduct = 24\\nlogProduct = log(24)\\nans = logProduct - log(1);\\noutput = pow(10, ans)"
                    },
                    {
                        "username": "void_8t",
                        "content": "HINTS:\n\n\n1. Multiply all non-zero nums[i] and keep count of zeroes.\n2. if there are no zeroes than ret[i]=productofallnon-zero/nums[i];(for all)\n3. if there is only a single zero, all indices will be zero except itself, it will be equal to the product.\n4. All elements will be zero if zeroes are more than one.\n\n\nHOPE U LIKED IT,PLS UPVOTE :)"
                    },
                    {
                        "username": "heidari_110",
                        "content": "One of the most easiest problems..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "How does the same code when run first gives me no error but run for the second time (literally no changes made, not a single space was changed) leads to this error\\n```\\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```\\nAnyone on C++ make sure to use proper space formatting for this solution!\\n"
                    },
                    {
                        "username": "kanshu422",
                        "content": "bro divide and product se bhi ho sakta h"
                    },
                    {
                        "username": "_solver",
                        "content": "what does this error means???\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "b_sh",
                        "content": "solve for case where array contain one \\'0\\' and rest will be easy question O(1) space "
                    },
                    {
                        "username": "KostayBagr",
                        "content": "nums = [1,2,3,4] - expected 6, not 4\\nbro y have a mistake!\\nit was confused me  \\n\\nOutput\\n[24,12,8,6]\\nExpected\\n[24,12,8,6]\\n\\n"
                    },
                    {
                        "username": "Vignesh_mudhiraj",
                        "content": "HINT:\\nThis problem can be categorized into 3 ways.\\n1.given array is non zero\\n2.given array contains only one zero.\\n3.given array contains multiple zeroes.\\nFirst and third case can be handled only with one condition. That is\\nfor first number -> multiply all the remaining number and store it in a variable.\\nnow from second number to last number , just divide the existing variable value( prev index product) with current element and multiply it with previous element.\\nBut for case 2 where only one zero is present ,every element in the array except the zero value element has a product of zero and for get ting the product of zero valued element multiply all the element which are infront and back.\\nTC-O(N)\\nSC-O(1)\\n\\nREFER MY CODE IF U STILL DIDN\\'T GET THE INTUTION:\\nhttps://leetcode.com/problems/product-of-array-except-self/solutions/3605738/easily-explained-tc-o-n-sc-o-1-c-best-solution/\\n\\nPLEASE UPVOTE IF U FIND IT HELPFUL."
                    }
                ]
            },
            {
                "id": 1953495,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "If you find java solution, follow this: https://leetcode.com/problems/product-of-array-except-self/submissions/988226077"
                    },
                    {
                        "username": "govinda_P",
                        "content": "Hint: Use logs and exponent to divide the number without using division operator.\\nproduct = 24\\nlogProduct = log(24)\\nans = logProduct - log(1);\\noutput = pow(10, ans)"
                    },
                    {
                        "username": "void_8t",
                        "content": "HINTS:\n\n\n1. Multiply all non-zero nums[i] and keep count of zeroes.\n2. if there are no zeroes than ret[i]=productofallnon-zero/nums[i];(for all)\n3. if there is only a single zero, all indices will be zero except itself, it will be equal to the product.\n4. All elements will be zero if zeroes are more than one.\n\n\nHOPE U LIKED IT,PLS UPVOTE :)"
                    },
                    {
                        "username": "heidari_110",
                        "content": "One of the most easiest problems..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "How does the same code when run first gives me no error but run for the second time (literally no changes made, not a single space was changed) leads to this error\\n```\\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```\\nAnyone on C++ make sure to use proper space formatting for this solution!\\n"
                    },
                    {
                        "username": "kanshu422",
                        "content": "bro divide and product se bhi ho sakta h"
                    },
                    {
                        "username": "_solver",
                        "content": "what does this error means???\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "b_sh",
                        "content": "solve for case where array contain one \\'0\\' and rest will be easy question O(1) space "
                    },
                    {
                        "username": "KostayBagr",
                        "content": "nums = [1,2,3,4] - expected 6, not 4\\nbro y have a mistake!\\nit was confused me  \\n\\nOutput\\n[24,12,8,6]\\nExpected\\n[24,12,8,6]\\n\\n"
                    },
                    {
                        "username": "Vignesh_mudhiraj",
                        "content": "HINT:\\nThis problem can be categorized into 3 ways.\\n1.given array is non zero\\n2.given array contains only one zero.\\n3.given array contains multiple zeroes.\\nFirst and third case can be handled only with one condition. That is\\nfor first number -> multiply all the remaining number and store it in a variable.\\nnow from second number to last number , just divide the existing variable value( prev index product) with current element and multiply it with previous element.\\nBut for case 2 where only one zero is present ,every element in the array except the zero value element has a product of zero and for get ting the product of zero valued element multiply all the element which are infront and back.\\nTC-O(N)\\nSC-O(1)\\n\\nREFER MY CODE IF U STILL DIDN\\'T GET THE INTUTION:\\nhttps://leetcode.com/problems/product-of-array-except-self/solutions/3605738/easily-explained-tc-o-n-sc-o-1-c-best-solution/\\n\\nPLEASE UPVOTE IF U FIND IT HELPFUL."
                    }
                ]
            },
            {
                "id": 1951767,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "If you find java solution, follow this: https://leetcode.com/problems/product-of-array-except-self/submissions/988226077"
                    },
                    {
                        "username": "govinda_P",
                        "content": "Hint: Use logs and exponent to divide the number without using division operator.\\nproduct = 24\\nlogProduct = log(24)\\nans = logProduct - log(1);\\noutput = pow(10, ans)"
                    },
                    {
                        "username": "void_8t",
                        "content": "HINTS:\n\n\n1. Multiply all non-zero nums[i] and keep count of zeroes.\n2. if there are no zeroes than ret[i]=productofallnon-zero/nums[i];(for all)\n3. if there is only a single zero, all indices will be zero except itself, it will be equal to the product.\n4. All elements will be zero if zeroes are more than one.\n\n\nHOPE U LIKED IT,PLS UPVOTE :)"
                    },
                    {
                        "username": "heidari_110",
                        "content": "One of the most easiest problems..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "How does the same code when run first gives me no error but run for the second time (literally no changes made, not a single space was changed) leads to this error\\n```\\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```\\nAnyone on C++ make sure to use proper space formatting for this solution!\\n"
                    },
                    {
                        "username": "kanshu422",
                        "content": "bro divide and product se bhi ho sakta h"
                    },
                    {
                        "username": "_solver",
                        "content": "what does this error means???\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "b_sh",
                        "content": "solve for case where array contain one \\'0\\' and rest will be easy question O(1) space "
                    },
                    {
                        "username": "KostayBagr",
                        "content": "nums = [1,2,3,4] - expected 6, not 4\\nbro y have a mistake!\\nit was confused me  \\n\\nOutput\\n[24,12,8,6]\\nExpected\\n[24,12,8,6]\\n\\n"
                    },
                    {
                        "username": "Vignesh_mudhiraj",
                        "content": "HINT:\\nThis problem can be categorized into 3 ways.\\n1.given array is non zero\\n2.given array contains only one zero.\\n3.given array contains multiple zeroes.\\nFirst and third case can be handled only with one condition. That is\\nfor first number -> multiply all the remaining number and store it in a variable.\\nnow from second number to last number , just divide the existing variable value( prev index product) with current element and multiply it with previous element.\\nBut for case 2 where only one zero is present ,every element in the array except the zero value element has a product of zero and for get ting the product of zero valued element multiply all the element which are infront and back.\\nTC-O(N)\\nSC-O(1)\\n\\nREFER MY CODE IF U STILL DIDN\\'T GET THE INTUTION:\\nhttps://leetcode.com/problems/product-of-array-except-self/solutions/3605738/easily-explained-tc-o-n-sc-o-1-c-best-solution/\\n\\nPLEASE UPVOTE IF U FIND IT HELPFUL."
                    }
                ]
            },
            {
                "id": 1935920,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "If you find java solution, follow this: https://leetcode.com/problems/product-of-array-except-self/submissions/988226077"
                    },
                    {
                        "username": "govinda_P",
                        "content": "Hint: Use logs and exponent to divide the number without using division operator.\\nproduct = 24\\nlogProduct = log(24)\\nans = logProduct - log(1);\\noutput = pow(10, ans)"
                    },
                    {
                        "username": "void_8t",
                        "content": "HINTS:\n\n\n1. Multiply all non-zero nums[i] and keep count of zeroes.\n2. if there are no zeroes than ret[i]=productofallnon-zero/nums[i];(for all)\n3. if there is only a single zero, all indices will be zero except itself, it will be equal to the product.\n4. All elements will be zero if zeroes are more than one.\n\n\nHOPE U LIKED IT,PLS UPVOTE :)"
                    },
                    {
                        "username": "heidari_110",
                        "content": "One of the most easiest problems..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "How does the same code when run first gives me no error but run for the second time (literally no changes made, not a single space was changed) leads to this error\\n```\\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```\\nAnyone on C++ make sure to use proper space formatting for this solution!\\n"
                    },
                    {
                        "username": "kanshu422",
                        "content": "bro divide and product se bhi ho sakta h"
                    },
                    {
                        "username": "_solver",
                        "content": "what does this error means???\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "b_sh",
                        "content": "solve for case where array contain one \\'0\\' and rest will be easy question O(1) space "
                    },
                    {
                        "username": "KostayBagr",
                        "content": "nums = [1,2,3,4] - expected 6, not 4\\nbro y have a mistake!\\nit was confused me  \\n\\nOutput\\n[24,12,8,6]\\nExpected\\n[24,12,8,6]\\n\\n"
                    },
                    {
                        "username": "Vignesh_mudhiraj",
                        "content": "HINT:\\nThis problem can be categorized into 3 ways.\\n1.given array is non zero\\n2.given array contains only one zero.\\n3.given array contains multiple zeroes.\\nFirst and third case can be handled only with one condition. That is\\nfor first number -> multiply all the remaining number and store it in a variable.\\nnow from second number to last number , just divide the existing variable value( prev index product) with current element and multiply it with previous element.\\nBut for case 2 where only one zero is present ,every element in the array except the zero value element has a product of zero and for get ting the product of zero valued element multiply all the element which are infront and back.\\nTC-O(N)\\nSC-O(1)\\n\\nREFER MY CODE IF U STILL DIDN\\'T GET THE INTUTION:\\nhttps://leetcode.com/problems/product-of-array-except-self/solutions/3605738/easily-explained-tc-o-n-sc-o-1-c-best-solution/\\n\\nPLEASE UPVOTE IF U FIND IT HELPFUL."
                    }
                ]
            },
            {
                "id": 1932383,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "If you find java solution, follow this: https://leetcode.com/problems/product-of-array-except-self/submissions/988226077"
                    },
                    {
                        "username": "govinda_P",
                        "content": "Hint: Use logs and exponent to divide the number without using division operator.\\nproduct = 24\\nlogProduct = log(24)\\nans = logProduct - log(1);\\noutput = pow(10, ans)"
                    },
                    {
                        "username": "void_8t",
                        "content": "HINTS:\n\n\n1. Multiply all non-zero nums[i] and keep count of zeroes.\n2. if there are no zeroes than ret[i]=productofallnon-zero/nums[i];(for all)\n3. if there is only a single zero, all indices will be zero except itself, it will be equal to the product.\n4. All elements will be zero if zeroes are more than one.\n\n\nHOPE U LIKED IT,PLS UPVOTE :)"
                    },
                    {
                        "username": "heidari_110",
                        "content": "One of the most easiest problems..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "How does the same code when run first gives me no error but run for the second time (literally no changes made, not a single space was changed) leads to this error\\n```\\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```\\nAnyone on C++ make sure to use proper space formatting for this solution!\\n"
                    },
                    {
                        "username": "kanshu422",
                        "content": "bro divide and product se bhi ho sakta h"
                    },
                    {
                        "username": "_solver",
                        "content": "what does this error means???\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "b_sh",
                        "content": "solve for case where array contain one \\'0\\' and rest will be easy question O(1) space "
                    },
                    {
                        "username": "KostayBagr",
                        "content": "nums = [1,2,3,4] - expected 6, not 4\\nbro y have a mistake!\\nit was confused me  \\n\\nOutput\\n[24,12,8,6]\\nExpected\\n[24,12,8,6]\\n\\n"
                    },
                    {
                        "username": "Vignesh_mudhiraj",
                        "content": "HINT:\\nThis problem can be categorized into 3 ways.\\n1.given array is non zero\\n2.given array contains only one zero.\\n3.given array contains multiple zeroes.\\nFirst and third case can be handled only with one condition. That is\\nfor first number -> multiply all the remaining number and store it in a variable.\\nnow from second number to last number , just divide the existing variable value( prev index product) with current element and multiply it with previous element.\\nBut for case 2 where only one zero is present ,every element in the array except the zero value element has a product of zero and for get ting the product of zero valued element multiply all the element which are infront and back.\\nTC-O(N)\\nSC-O(1)\\n\\nREFER MY CODE IF U STILL DIDN\\'T GET THE INTUTION:\\nhttps://leetcode.com/problems/product-of-array-except-self/solutions/3605738/easily-explained-tc-o-n-sc-o-1-c-best-solution/\\n\\nPLEASE UPVOTE IF U FIND IT HELPFUL."
                    }
                ]
            },
            {
                "id": 1932349,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "If you find java solution, follow this: https://leetcode.com/problems/product-of-array-except-self/submissions/988226077"
                    },
                    {
                        "username": "govinda_P",
                        "content": "Hint: Use logs and exponent to divide the number without using division operator.\\nproduct = 24\\nlogProduct = log(24)\\nans = logProduct - log(1);\\noutput = pow(10, ans)"
                    },
                    {
                        "username": "void_8t",
                        "content": "HINTS:\n\n\n1. Multiply all non-zero nums[i] and keep count of zeroes.\n2. if there are no zeroes than ret[i]=productofallnon-zero/nums[i];(for all)\n3. if there is only a single zero, all indices will be zero except itself, it will be equal to the product.\n4. All elements will be zero if zeroes are more than one.\n\n\nHOPE U LIKED IT,PLS UPVOTE :)"
                    },
                    {
                        "username": "heidari_110",
                        "content": "One of the most easiest problems..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "How does the same code when run first gives me no error but run for the second time (literally no changes made, not a single space was changed) leads to this error\\n```\\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```\\nAnyone on C++ make sure to use proper space formatting for this solution!\\n"
                    },
                    {
                        "username": "kanshu422",
                        "content": "bro divide and product se bhi ho sakta h"
                    },
                    {
                        "username": "_solver",
                        "content": "what does this error means???\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "b_sh",
                        "content": "solve for case where array contain one \\'0\\' and rest will be easy question O(1) space "
                    },
                    {
                        "username": "KostayBagr",
                        "content": "nums = [1,2,3,4] - expected 6, not 4\\nbro y have a mistake!\\nit was confused me  \\n\\nOutput\\n[24,12,8,6]\\nExpected\\n[24,12,8,6]\\n\\n"
                    },
                    {
                        "username": "Vignesh_mudhiraj",
                        "content": "HINT:\\nThis problem can be categorized into 3 ways.\\n1.given array is non zero\\n2.given array contains only one zero.\\n3.given array contains multiple zeroes.\\nFirst and third case can be handled only with one condition. That is\\nfor first number -> multiply all the remaining number and store it in a variable.\\nnow from second number to last number , just divide the existing variable value( prev index product) with current element and multiply it with previous element.\\nBut for case 2 where only one zero is present ,every element in the array except the zero value element has a product of zero and for get ting the product of zero valued element multiply all the element which are infront and back.\\nTC-O(N)\\nSC-O(1)\\n\\nREFER MY CODE IF U STILL DIDN\\'T GET THE INTUTION:\\nhttps://leetcode.com/problems/product-of-array-except-self/solutions/3605738/easily-explained-tc-o-n-sc-o-1-c-best-solution/\\n\\nPLEASE UPVOTE IF U FIND IT HELPFUL."
                    }
                ]
            },
            {
                "id": 1930936,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "If you find java solution, follow this: https://leetcode.com/problems/product-of-array-except-self/submissions/988226077"
                    },
                    {
                        "username": "govinda_P",
                        "content": "Hint: Use logs and exponent to divide the number without using division operator.\\nproduct = 24\\nlogProduct = log(24)\\nans = logProduct - log(1);\\noutput = pow(10, ans)"
                    },
                    {
                        "username": "void_8t",
                        "content": "HINTS:\n\n\n1. Multiply all non-zero nums[i] and keep count of zeroes.\n2. if there are no zeroes than ret[i]=productofallnon-zero/nums[i];(for all)\n3. if there is only a single zero, all indices will be zero except itself, it will be equal to the product.\n4. All elements will be zero if zeroes are more than one.\n\n\nHOPE U LIKED IT,PLS UPVOTE :)"
                    },
                    {
                        "username": "heidari_110",
                        "content": "One of the most easiest problems..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "How does the same code when run first gives me no error but run for the second time (literally no changes made, not a single space was changed) leads to this error\\n```\\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```\\nAnyone on C++ make sure to use proper space formatting for this solution!\\n"
                    },
                    {
                        "username": "kanshu422",
                        "content": "bro divide and product se bhi ho sakta h"
                    },
                    {
                        "username": "_solver",
                        "content": "what does this error means???\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "b_sh",
                        "content": "solve for case where array contain one \\'0\\' and rest will be easy question O(1) space "
                    },
                    {
                        "username": "KostayBagr",
                        "content": "nums = [1,2,3,4] - expected 6, not 4\\nbro y have a mistake!\\nit was confused me  \\n\\nOutput\\n[24,12,8,6]\\nExpected\\n[24,12,8,6]\\n\\n"
                    },
                    {
                        "username": "Vignesh_mudhiraj",
                        "content": "HINT:\\nThis problem can be categorized into 3 ways.\\n1.given array is non zero\\n2.given array contains only one zero.\\n3.given array contains multiple zeroes.\\nFirst and third case can be handled only with one condition. That is\\nfor first number -> multiply all the remaining number and store it in a variable.\\nnow from second number to last number , just divide the existing variable value( prev index product) with current element and multiply it with previous element.\\nBut for case 2 where only one zero is present ,every element in the array except the zero value element has a product of zero and for get ting the product of zero valued element multiply all the element which are infront and back.\\nTC-O(N)\\nSC-O(1)\\n\\nREFER MY CODE IF U STILL DIDN\\'T GET THE INTUTION:\\nhttps://leetcode.com/problems/product-of-array-except-self/solutions/3605738/easily-explained-tc-o-n-sc-o-1-c-best-solution/\\n\\nPLEASE UPVOTE IF U FIND IT HELPFUL."
                    }
                ]
            },
            {
                "id": 1926760,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "If you find java solution, follow this: https://leetcode.com/problems/product-of-array-except-self/submissions/988226077"
                    },
                    {
                        "username": "govinda_P",
                        "content": "Hint: Use logs and exponent to divide the number without using division operator.\\nproduct = 24\\nlogProduct = log(24)\\nans = logProduct - log(1);\\noutput = pow(10, ans)"
                    },
                    {
                        "username": "void_8t",
                        "content": "HINTS:\n\n\n1. Multiply all non-zero nums[i] and keep count of zeroes.\n2. if there are no zeroes than ret[i]=productofallnon-zero/nums[i];(for all)\n3. if there is only a single zero, all indices will be zero except itself, it will be equal to the product.\n4. All elements will be zero if zeroes are more than one.\n\n\nHOPE U LIKED IT,PLS UPVOTE :)"
                    },
                    {
                        "username": "heidari_110",
                        "content": "One of the most easiest problems..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "How does the same code when run first gives me no error but run for the second time (literally no changes made, not a single space was changed) leads to this error\\n```\\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```\\nAnyone on C++ make sure to use proper space formatting for this solution!\\n"
                    },
                    {
                        "username": "kanshu422",
                        "content": "bro divide and product se bhi ho sakta h"
                    },
                    {
                        "username": "_solver",
                        "content": "what does this error means???\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "b_sh",
                        "content": "solve for case where array contain one \\'0\\' and rest will be easy question O(1) space "
                    },
                    {
                        "username": "KostayBagr",
                        "content": "nums = [1,2,3,4] - expected 6, not 4\\nbro y have a mistake!\\nit was confused me  \\n\\nOutput\\n[24,12,8,6]\\nExpected\\n[24,12,8,6]\\n\\n"
                    },
                    {
                        "username": "Vignesh_mudhiraj",
                        "content": "HINT:\\nThis problem can be categorized into 3 ways.\\n1.given array is non zero\\n2.given array contains only one zero.\\n3.given array contains multiple zeroes.\\nFirst and third case can be handled only with one condition. That is\\nfor first number -> multiply all the remaining number and store it in a variable.\\nnow from second number to last number , just divide the existing variable value( prev index product) with current element and multiply it with previous element.\\nBut for case 2 where only one zero is present ,every element in the array except the zero value element has a product of zero and for get ting the product of zero valued element multiply all the element which are infront and back.\\nTC-O(N)\\nSC-O(1)\\n\\nREFER MY CODE IF U STILL DIDN\\'T GET THE INTUTION:\\nhttps://leetcode.com/problems/product-of-array-except-self/solutions/3605738/easily-explained-tc-o-n-sc-o-1-c-best-solution/\\n\\nPLEASE UPVOTE IF U FIND IT HELPFUL."
                    }
                ]
            },
            {
                "id": 1923850,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "If you find java solution, follow this: https://leetcode.com/problems/product-of-array-except-self/submissions/988226077"
                    },
                    {
                        "username": "govinda_P",
                        "content": "Hint: Use logs and exponent to divide the number without using division operator.\\nproduct = 24\\nlogProduct = log(24)\\nans = logProduct - log(1);\\noutput = pow(10, ans)"
                    },
                    {
                        "username": "void_8t",
                        "content": "HINTS:\n\n\n1. Multiply all non-zero nums[i] and keep count of zeroes.\n2. if there are no zeroes than ret[i]=productofallnon-zero/nums[i];(for all)\n3. if there is only a single zero, all indices will be zero except itself, it will be equal to the product.\n4. All elements will be zero if zeroes are more than one.\n\n\nHOPE U LIKED IT,PLS UPVOTE :)"
                    },
                    {
                        "username": "heidari_110",
                        "content": "One of the most easiest problems..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "How does the same code when run first gives me no error but run for the second time (literally no changes made, not a single space was changed) leads to this error\\n```\\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```\\nAnyone on C++ make sure to use proper space formatting for this solution!\\n"
                    },
                    {
                        "username": "kanshu422",
                        "content": "bro divide and product se bhi ho sakta h"
                    },
                    {
                        "username": "_solver",
                        "content": "what does this error means???\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "b_sh",
                        "content": "solve for case where array contain one \\'0\\' and rest will be easy question O(1) space "
                    },
                    {
                        "username": "KostayBagr",
                        "content": "nums = [1,2,3,4] - expected 6, not 4\\nbro y have a mistake!\\nit was confused me  \\n\\nOutput\\n[24,12,8,6]\\nExpected\\n[24,12,8,6]\\n\\n"
                    },
                    {
                        "username": "Vignesh_mudhiraj",
                        "content": "HINT:\\nThis problem can be categorized into 3 ways.\\n1.given array is non zero\\n2.given array contains only one zero.\\n3.given array contains multiple zeroes.\\nFirst and third case can be handled only with one condition. That is\\nfor first number -> multiply all the remaining number and store it in a variable.\\nnow from second number to last number , just divide the existing variable value( prev index product) with current element and multiply it with previous element.\\nBut for case 2 where only one zero is present ,every element in the array except the zero value element has a product of zero and for get ting the product of zero valued element multiply all the element which are infront and back.\\nTC-O(N)\\nSC-O(1)\\n\\nREFER MY CODE IF U STILL DIDN\\'T GET THE INTUTION:\\nhttps://leetcode.com/problems/product-of-array-except-self/solutions/3605738/easily-explained-tc-o-n-sc-o-1-c-best-solution/\\n\\nPLEASE UPVOTE IF U FIND IT HELPFUL."
                    }
                ]
            },
            {
                "id": 1919158,
                "content": [
                    {
                        "username": "minhphamduy",
                        "content": "If you find java solution, follow this: https://leetcode.com/problems/product-of-array-except-self/submissions/988226077"
                    },
                    {
                        "username": "govinda_P",
                        "content": "Hint: Use logs and exponent to divide the number without using division operator.\\nproduct = 24\\nlogProduct = log(24)\\nans = logProduct - log(1);\\noutput = pow(10, ans)"
                    },
                    {
                        "username": "void_8t",
                        "content": "HINTS:\n\n\n1. Multiply all non-zero nums[i] and keep count of zeroes.\n2. if there are no zeroes than ret[i]=productofallnon-zero/nums[i];(for all)\n3. if there is only a single zero, all indices will be zero except itself, it will be equal to the product.\n4. All elements will be zero if zeroes are more than one.\n\n\nHOPE U LIKED IT,PLS UPVOTE :)"
                    },
                    {
                        "username": "heidari_110",
                        "content": "One of the most easiest problems..."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "How does the same code when run first gives me no error but run for the second time (literally no changes made, not a single space was changed) leads to this error\\n```\\n==23==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12)\\n==23==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n```\\nAnyone on C++ make sure to use proper space formatting for this solution!\\n"
                    },
                    {
                        "username": "kanshu422",
                        "content": "bro divide and product se bhi ho sakta h"
                    },
                    {
                        "username": "_solver",
                        "content": "what does this error means???\\n\\n==22==ERROR: AddressSanitizer failed to allocate 0xdfff0001000 (15392894357504) bytes at address 2008fff7000 (errno: 12) ==22==ReserveShadowMemoryRange failed while trying to map 0xdfff0001000 bytes. Perhaps you\\'re using ulimit -v\\n"
                    },
                    {
                        "username": "b_sh",
                        "content": "solve for case where array contain one \\'0\\' and rest will be easy question O(1) space "
                    },
                    {
                        "username": "KostayBagr",
                        "content": "nums = [1,2,3,4] - expected 6, not 4\\nbro y have a mistake!\\nit was confused me  \\n\\nOutput\\n[24,12,8,6]\\nExpected\\n[24,12,8,6]\\n\\n"
                    },
                    {
                        "username": "Vignesh_mudhiraj",
                        "content": "HINT:\\nThis problem can be categorized into 3 ways.\\n1.given array is non zero\\n2.given array contains only one zero.\\n3.given array contains multiple zeroes.\\nFirst and third case can be handled only with one condition. That is\\nfor first number -> multiply all the remaining number and store it in a variable.\\nnow from second number to last number , just divide the existing variable value( prev index product) with current element and multiply it with previous element.\\nBut for case 2 where only one zero is present ,every element in the array except the zero value element has a product of zero and for get ting the product of zero valued element multiply all the element which are infront and back.\\nTC-O(N)\\nSC-O(1)\\n\\nREFER MY CODE IF U STILL DIDN\\'T GET THE INTUTION:\\nhttps://leetcode.com/problems/product-of-array-except-self/solutions/3605738/easily-explained-tc-o-n-sc-o-1-c-best-solution/\\n\\nPLEASE UPVOTE IF U FIND IT HELPFUL."
                    }
                ]
            },
            {
                "id": 1912654,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Apparently, this is no bueno (fails on testcase 18). Anyone seeing glaring issues? I just saw that there\\'s some postfix/prefix way of doing things that I never heard of, so I\\'ll look into that. First, I want to understand what\\'s wrong with this solution.\\n```python\\n   def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        if len(nums) == 2:\\n            return [nums[1], nums[0]]\\n        \\n        answer = []\\n\\n        for i in range(len(nums)):\\n            product = 1\\n            j = i + 1 \\n            if j == len(nums):\\n                j = 0\\n            while j != i:\\n                if j == len(nums):\\n                    j = 0\\n                else:\\n                    product *= nums[j] \\n                    j += 1\\n            answer.append(product)\\n        \\n        return answer\\n```"
                    },
                    {
                        "username": "SanyamVv",
                        "content": "if nums = [0,4,0] then correct answer is [0,0,0].\\nthen accordingly if nums = [1,0] then why is correct answer given as [0,1], shouldn\\'t it be [0,0] only?"
                    },
                    {
                        "username": "FWard",
                        "content": "If I have [1,1,0], then it will be [0, 0, 1]. There should be at least two zeroes for the array to be fully zero."
                    },
                    {
                        "username": "jebinvasanth",
                        "content": "whenever the element on which the pointer is \\'0\\' then we don\\'t divide it by \\'0\\'. so it won\\'t be 1/0, we would should multiply the rest of the element.\\n"
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": "class Solution:\\n    def productExceptSelf(self, a: List[int]) -> List[int]:\\n        prod = 1\\n        countZero = 0\\n\\n        for idx in range(len(a)):\\n            if a[idx] == 0:\\n                countZero+=1\\n                continue\\n            prod*=a[idx]\\n            \\n        if countZero == 0:\\n            for idx in range(len(a)):\\n                a[idx] = prod//a[idx]\\n                \\n        elif countZero == len(a):\\n            for idx in range(len(a)):\\n                a[idx] = 0\\n        else:\\n            for idx in range(len(a)):\\n                if a[idx] == 0:\\n                    a[idx] = prod\\n                else:\\n                    a[idx] = 0\\n\\n        return a\\n\\nHere, I am calculating the product of whole array, also skipping the 0s that might occur. By keeping the count of zeros occurred, I am traversing the array once again, and replacing the elements as follows\\n\\n1) If no zeros, the elements will be replaced as product of whole array divided by a[i]\\n2) If the zero count is equal to the length of array, then I will replace everything with zeros\\n3) Else I will replace zero element with array product and other non zero elements with zero.\\n\\nThis is failing for [0,4,0] in leetcode, but when I try the same in some other editor it works fine. Can anyone help? TC: O(2N), SC: O(1)"
                    },
                    {
                        "username": "user1133eL",
                        "content": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        import numpy\n        ans=[]\n        for i in nums:\n            lis=[]\n            lis.extend(nums)\n            lis.remove(i)\n            x=numpy.prod(lis)\n            ans.append(x)\n        return ans\nI am getting TLE help me out guys "
                    },
                    {
                        "username": "suspiciousRaccoon",
                        "content": "this doesnt work lol \\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        return [reduce(lambda x,y: x*y, nums[:i]+nums[i+1:]) for i in range(len(nums))]"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans;\\n        for(int i=0; i<n; i++){\\n            int product = 1;\\n            for(int j=0 ; j<n ; j++){\\n                if(i==j){\\n                    continue;\\n                }\\n                product *= nums[j];\\n            }\\n            ans.push_back(product);\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n\\nhow can i solve a time limit exceeded problem in this code \\n"
                    },
                    {
                        "username": "Belyua",
                        "content": "try 1 iteration\\n"
                    },
                    {
                        "username": "niazstat",
                        "content": "Time Limit Exceeded\\n22 / 22 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "#include<stdio.h>\\n\\nint main()\\n{\\n    int num[] = {-1,1,0,-3,3};\\n    int n = sizeof(num)/sizeof(num[0]);\\n    int ans[n];\\n    int sum = 1;\\n\\n    for(int i = 0 ; i< n ; i++)                                 // Time complexity = O(n*2)\\n    {\\n        sum = 1;\\n        for(int j = 0 ; j<n ; j++)\\n        {\\n            if(j!=i)\\n            {\\n                sum = sum*num[j];\\n            }\\n        }\\n        ans[i] = sum;\\n    }\\n    for(int k = 0 ; k<n ; k++)\\n    {\\n        printf(\"%d \",ans[k]);\\n    }\\n    printf(\"\\\\n\");\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n\\n\\nint[] ans = new int[nums.length];\\nint left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\nfor(int i = 0; i < nums.length; i++){\\nwhile(left < i){\\nvar1 = var1 * nums[left];\\nleft++;\\n}\\nwhile(right > i){\\nvar2 = var2 * nums[right];\\nright--;\\n}\\nans[i] = var1 * var2;\\n}\\nreturn ans;"
                    },
                    {
                        "username": "rananikhal2003",
                        "content": "re_initialize all the variable var1 ,var1, left ,right to their orginal values after each iteration.\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int var1=1,var2=1;\\n        int[] ans = new int[nums.length];\\n\\n        int left=0,right=nums.length-1;\\n        for (int i=0;i<nums.length;i++){\\n            while (left<i){\\n                var1=var1*nums[left];\\n                left++;\\n            }left=0;\\n            while (right>i){\\n                var2=var2*nums[right];\\n                right--;\\n            }right=nums.length-1;\\n            ans[i]=var1*var2;\\n            var1=1;\\n            var2=1;\\n\\n            \\n        }return ans;\\n        \\n    }\\n}\\nbut this isn\\'t an optimal approach as only 19 test cases have passed."
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error in my work???"
                    }
                ]
            },
            {
                "id": 1908736,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Apparently, this is no bueno (fails on testcase 18). Anyone seeing glaring issues? I just saw that there\\'s some postfix/prefix way of doing things that I never heard of, so I\\'ll look into that. First, I want to understand what\\'s wrong with this solution.\\n```python\\n   def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        if len(nums) == 2:\\n            return [nums[1], nums[0]]\\n        \\n        answer = []\\n\\n        for i in range(len(nums)):\\n            product = 1\\n            j = i + 1 \\n            if j == len(nums):\\n                j = 0\\n            while j != i:\\n                if j == len(nums):\\n                    j = 0\\n                else:\\n                    product *= nums[j] \\n                    j += 1\\n            answer.append(product)\\n        \\n        return answer\\n```"
                    },
                    {
                        "username": "SanyamVv",
                        "content": "if nums = [0,4,0] then correct answer is [0,0,0].\\nthen accordingly if nums = [1,0] then why is correct answer given as [0,1], shouldn\\'t it be [0,0] only?"
                    },
                    {
                        "username": "FWard",
                        "content": "If I have [1,1,0], then it will be [0, 0, 1]. There should be at least two zeroes for the array to be fully zero."
                    },
                    {
                        "username": "jebinvasanth",
                        "content": "whenever the element on which the pointer is \\'0\\' then we don\\'t divide it by \\'0\\'. so it won\\'t be 1/0, we would should multiply the rest of the element.\\n"
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": "class Solution:\\n    def productExceptSelf(self, a: List[int]) -> List[int]:\\n        prod = 1\\n        countZero = 0\\n\\n        for idx in range(len(a)):\\n            if a[idx] == 0:\\n                countZero+=1\\n                continue\\n            prod*=a[idx]\\n            \\n        if countZero == 0:\\n            for idx in range(len(a)):\\n                a[idx] = prod//a[idx]\\n                \\n        elif countZero == len(a):\\n            for idx in range(len(a)):\\n                a[idx] = 0\\n        else:\\n            for idx in range(len(a)):\\n                if a[idx] == 0:\\n                    a[idx] = prod\\n                else:\\n                    a[idx] = 0\\n\\n        return a\\n\\nHere, I am calculating the product of whole array, also skipping the 0s that might occur. By keeping the count of zeros occurred, I am traversing the array once again, and replacing the elements as follows\\n\\n1) If no zeros, the elements will be replaced as product of whole array divided by a[i]\\n2) If the zero count is equal to the length of array, then I will replace everything with zeros\\n3) Else I will replace zero element with array product and other non zero elements with zero.\\n\\nThis is failing for [0,4,0] in leetcode, but when I try the same in some other editor it works fine. Can anyone help? TC: O(2N), SC: O(1)"
                    },
                    {
                        "username": "user1133eL",
                        "content": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        import numpy\n        ans=[]\n        for i in nums:\n            lis=[]\n            lis.extend(nums)\n            lis.remove(i)\n            x=numpy.prod(lis)\n            ans.append(x)\n        return ans\nI am getting TLE help me out guys "
                    },
                    {
                        "username": "suspiciousRaccoon",
                        "content": "this doesnt work lol \\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        return [reduce(lambda x,y: x*y, nums[:i]+nums[i+1:]) for i in range(len(nums))]"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans;\\n        for(int i=0; i<n; i++){\\n            int product = 1;\\n            for(int j=0 ; j<n ; j++){\\n                if(i==j){\\n                    continue;\\n                }\\n                product *= nums[j];\\n            }\\n            ans.push_back(product);\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n\\nhow can i solve a time limit exceeded problem in this code \\n"
                    },
                    {
                        "username": "Belyua",
                        "content": "try 1 iteration\\n"
                    },
                    {
                        "username": "niazstat",
                        "content": "Time Limit Exceeded\\n22 / 22 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "#include<stdio.h>\\n\\nint main()\\n{\\n    int num[] = {-1,1,0,-3,3};\\n    int n = sizeof(num)/sizeof(num[0]);\\n    int ans[n];\\n    int sum = 1;\\n\\n    for(int i = 0 ; i< n ; i++)                                 // Time complexity = O(n*2)\\n    {\\n        sum = 1;\\n        for(int j = 0 ; j<n ; j++)\\n        {\\n            if(j!=i)\\n            {\\n                sum = sum*num[j];\\n            }\\n        }\\n        ans[i] = sum;\\n    }\\n    for(int k = 0 ; k<n ; k++)\\n    {\\n        printf(\"%d \",ans[k]);\\n    }\\n    printf(\"\\\\n\");\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n\\n\\nint[] ans = new int[nums.length];\\nint left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\nfor(int i = 0; i < nums.length; i++){\\nwhile(left < i){\\nvar1 = var1 * nums[left];\\nleft++;\\n}\\nwhile(right > i){\\nvar2 = var2 * nums[right];\\nright--;\\n}\\nans[i] = var1 * var2;\\n}\\nreturn ans;"
                    },
                    {
                        "username": "rananikhal2003",
                        "content": "re_initialize all the variable var1 ,var1, left ,right to their orginal values after each iteration.\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int var1=1,var2=1;\\n        int[] ans = new int[nums.length];\\n\\n        int left=0,right=nums.length-1;\\n        for (int i=0;i<nums.length;i++){\\n            while (left<i){\\n                var1=var1*nums[left];\\n                left++;\\n            }left=0;\\n            while (right>i){\\n                var2=var2*nums[right];\\n                right--;\\n            }right=nums.length-1;\\n            ans[i]=var1*var2;\\n            var1=1;\\n            var2=1;\\n\\n            \\n        }return ans;\\n        \\n    }\\n}\\nbut this isn\\'t an optimal approach as only 19 test cases have passed."
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error in my work???"
                    }
                ]
            },
            {
                "id": 1903809,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Apparently, this is no bueno (fails on testcase 18). Anyone seeing glaring issues? I just saw that there\\'s some postfix/prefix way of doing things that I never heard of, so I\\'ll look into that. First, I want to understand what\\'s wrong with this solution.\\n```python\\n   def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        if len(nums) == 2:\\n            return [nums[1], nums[0]]\\n        \\n        answer = []\\n\\n        for i in range(len(nums)):\\n            product = 1\\n            j = i + 1 \\n            if j == len(nums):\\n                j = 0\\n            while j != i:\\n                if j == len(nums):\\n                    j = 0\\n                else:\\n                    product *= nums[j] \\n                    j += 1\\n            answer.append(product)\\n        \\n        return answer\\n```"
                    },
                    {
                        "username": "SanyamVv",
                        "content": "if nums = [0,4,0] then correct answer is [0,0,0].\\nthen accordingly if nums = [1,0] then why is correct answer given as [0,1], shouldn\\'t it be [0,0] only?"
                    },
                    {
                        "username": "FWard",
                        "content": "If I have [1,1,0], then it will be [0, 0, 1]. There should be at least two zeroes for the array to be fully zero."
                    },
                    {
                        "username": "jebinvasanth",
                        "content": "whenever the element on which the pointer is \\'0\\' then we don\\'t divide it by \\'0\\'. so it won\\'t be 1/0, we would should multiply the rest of the element.\\n"
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": "class Solution:\\n    def productExceptSelf(self, a: List[int]) -> List[int]:\\n        prod = 1\\n        countZero = 0\\n\\n        for idx in range(len(a)):\\n            if a[idx] == 0:\\n                countZero+=1\\n                continue\\n            prod*=a[idx]\\n            \\n        if countZero == 0:\\n            for idx in range(len(a)):\\n                a[idx] = prod//a[idx]\\n                \\n        elif countZero == len(a):\\n            for idx in range(len(a)):\\n                a[idx] = 0\\n        else:\\n            for idx in range(len(a)):\\n                if a[idx] == 0:\\n                    a[idx] = prod\\n                else:\\n                    a[idx] = 0\\n\\n        return a\\n\\nHere, I am calculating the product of whole array, also skipping the 0s that might occur. By keeping the count of zeros occurred, I am traversing the array once again, and replacing the elements as follows\\n\\n1) If no zeros, the elements will be replaced as product of whole array divided by a[i]\\n2) If the zero count is equal to the length of array, then I will replace everything with zeros\\n3) Else I will replace zero element with array product and other non zero elements with zero.\\n\\nThis is failing for [0,4,0] in leetcode, but when I try the same in some other editor it works fine. Can anyone help? TC: O(2N), SC: O(1)"
                    },
                    {
                        "username": "user1133eL",
                        "content": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        import numpy\n        ans=[]\n        for i in nums:\n            lis=[]\n            lis.extend(nums)\n            lis.remove(i)\n            x=numpy.prod(lis)\n            ans.append(x)\n        return ans\nI am getting TLE help me out guys "
                    },
                    {
                        "username": "suspiciousRaccoon",
                        "content": "this doesnt work lol \\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        return [reduce(lambda x,y: x*y, nums[:i]+nums[i+1:]) for i in range(len(nums))]"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans;\\n        for(int i=0; i<n; i++){\\n            int product = 1;\\n            for(int j=0 ; j<n ; j++){\\n                if(i==j){\\n                    continue;\\n                }\\n                product *= nums[j];\\n            }\\n            ans.push_back(product);\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n\\nhow can i solve a time limit exceeded problem in this code \\n"
                    },
                    {
                        "username": "Belyua",
                        "content": "try 1 iteration\\n"
                    },
                    {
                        "username": "niazstat",
                        "content": "Time Limit Exceeded\\n22 / 22 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "#include<stdio.h>\\n\\nint main()\\n{\\n    int num[] = {-1,1,0,-3,3};\\n    int n = sizeof(num)/sizeof(num[0]);\\n    int ans[n];\\n    int sum = 1;\\n\\n    for(int i = 0 ; i< n ; i++)                                 // Time complexity = O(n*2)\\n    {\\n        sum = 1;\\n        for(int j = 0 ; j<n ; j++)\\n        {\\n            if(j!=i)\\n            {\\n                sum = sum*num[j];\\n            }\\n        }\\n        ans[i] = sum;\\n    }\\n    for(int k = 0 ; k<n ; k++)\\n    {\\n        printf(\"%d \",ans[k]);\\n    }\\n    printf(\"\\\\n\");\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n\\n\\nint[] ans = new int[nums.length];\\nint left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\nfor(int i = 0; i < nums.length; i++){\\nwhile(left < i){\\nvar1 = var1 * nums[left];\\nleft++;\\n}\\nwhile(right > i){\\nvar2 = var2 * nums[right];\\nright--;\\n}\\nans[i] = var1 * var2;\\n}\\nreturn ans;"
                    },
                    {
                        "username": "rananikhal2003",
                        "content": "re_initialize all the variable var1 ,var1, left ,right to their orginal values after each iteration.\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int var1=1,var2=1;\\n        int[] ans = new int[nums.length];\\n\\n        int left=0,right=nums.length-1;\\n        for (int i=0;i<nums.length;i++){\\n            while (left<i){\\n                var1=var1*nums[left];\\n                left++;\\n            }left=0;\\n            while (right>i){\\n                var2=var2*nums[right];\\n                right--;\\n            }right=nums.length-1;\\n            ans[i]=var1*var2;\\n            var1=1;\\n            var2=1;\\n\\n            \\n        }return ans;\\n        \\n    }\\n}\\nbut this isn\\'t an optimal approach as only 19 test cases have passed."
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error in my work???"
                    }
                ]
            },
            {
                "id": 1903032,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Apparently, this is no bueno (fails on testcase 18). Anyone seeing glaring issues? I just saw that there\\'s some postfix/prefix way of doing things that I never heard of, so I\\'ll look into that. First, I want to understand what\\'s wrong with this solution.\\n```python\\n   def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        if len(nums) == 2:\\n            return [nums[1], nums[0]]\\n        \\n        answer = []\\n\\n        for i in range(len(nums)):\\n            product = 1\\n            j = i + 1 \\n            if j == len(nums):\\n                j = 0\\n            while j != i:\\n                if j == len(nums):\\n                    j = 0\\n                else:\\n                    product *= nums[j] \\n                    j += 1\\n            answer.append(product)\\n        \\n        return answer\\n```"
                    },
                    {
                        "username": "SanyamVv",
                        "content": "if nums = [0,4,0] then correct answer is [0,0,0].\\nthen accordingly if nums = [1,0] then why is correct answer given as [0,1], shouldn\\'t it be [0,0] only?"
                    },
                    {
                        "username": "FWard",
                        "content": "If I have [1,1,0], then it will be [0, 0, 1]. There should be at least two zeroes for the array to be fully zero."
                    },
                    {
                        "username": "jebinvasanth",
                        "content": "whenever the element on which the pointer is \\'0\\' then we don\\'t divide it by \\'0\\'. so it won\\'t be 1/0, we would should multiply the rest of the element.\\n"
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": "class Solution:\\n    def productExceptSelf(self, a: List[int]) -> List[int]:\\n        prod = 1\\n        countZero = 0\\n\\n        for idx in range(len(a)):\\n            if a[idx] == 0:\\n                countZero+=1\\n                continue\\n            prod*=a[idx]\\n            \\n        if countZero == 0:\\n            for idx in range(len(a)):\\n                a[idx] = prod//a[idx]\\n                \\n        elif countZero == len(a):\\n            for idx in range(len(a)):\\n                a[idx] = 0\\n        else:\\n            for idx in range(len(a)):\\n                if a[idx] == 0:\\n                    a[idx] = prod\\n                else:\\n                    a[idx] = 0\\n\\n        return a\\n\\nHere, I am calculating the product of whole array, also skipping the 0s that might occur. By keeping the count of zeros occurred, I am traversing the array once again, and replacing the elements as follows\\n\\n1) If no zeros, the elements will be replaced as product of whole array divided by a[i]\\n2) If the zero count is equal to the length of array, then I will replace everything with zeros\\n3) Else I will replace zero element with array product and other non zero elements with zero.\\n\\nThis is failing for [0,4,0] in leetcode, but when I try the same in some other editor it works fine. Can anyone help? TC: O(2N), SC: O(1)"
                    },
                    {
                        "username": "user1133eL",
                        "content": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        import numpy\n        ans=[]\n        for i in nums:\n            lis=[]\n            lis.extend(nums)\n            lis.remove(i)\n            x=numpy.prod(lis)\n            ans.append(x)\n        return ans\nI am getting TLE help me out guys "
                    },
                    {
                        "username": "suspiciousRaccoon",
                        "content": "this doesnt work lol \\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        return [reduce(lambda x,y: x*y, nums[:i]+nums[i+1:]) for i in range(len(nums))]"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans;\\n        for(int i=0; i<n; i++){\\n            int product = 1;\\n            for(int j=0 ; j<n ; j++){\\n                if(i==j){\\n                    continue;\\n                }\\n                product *= nums[j];\\n            }\\n            ans.push_back(product);\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n\\nhow can i solve a time limit exceeded problem in this code \\n"
                    },
                    {
                        "username": "Belyua",
                        "content": "try 1 iteration\\n"
                    },
                    {
                        "username": "niazstat",
                        "content": "Time Limit Exceeded\\n22 / 22 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "#include<stdio.h>\\n\\nint main()\\n{\\n    int num[] = {-1,1,0,-3,3};\\n    int n = sizeof(num)/sizeof(num[0]);\\n    int ans[n];\\n    int sum = 1;\\n\\n    for(int i = 0 ; i< n ; i++)                                 // Time complexity = O(n*2)\\n    {\\n        sum = 1;\\n        for(int j = 0 ; j<n ; j++)\\n        {\\n            if(j!=i)\\n            {\\n                sum = sum*num[j];\\n            }\\n        }\\n        ans[i] = sum;\\n    }\\n    for(int k = 0 ; k<n ; k++)\\n    {\\n        printf(\"%d \",ans[k]);\\n    }\\n    printf(\"\\\\n\");\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n\\n\\nint[] ans = new int[nums.length];\\nint left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\nfor(int i = 0; i < nums.length; i++){\\nwhile(left < i){\\nvar1 = var1 * nums[left];\\nleft++;\\n}\\nwhile(right > i){\\nvar2 = var2 * nums[right];\\nright--;\\n}\\nans[i] = var1 * var2;\\n}\\nreturn ans;"
                    },
                    {
                        "username": "rananikhal2003",
                        "content": "re_initialize all the variable var1 ,var1, left ,right to their orginal values after each iteration.\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int var1=1,var2=1;\\n        int[] ans = new int[nums.length];\\n\\n        int left=0,right=nums.length-1;\\n        for (int i=0;i<nums.length;i++){\\n            while (left<i){\\n                var1=var1*nums[left];\\n                left++;\\n            }left=0;\\n            while (right>i){\\n                var2=var2*nums[right];\\n                right--;\\n            }right=nums.length-1;\\n            ans[i]=var1*var2;\\n            var1=1;\\n            var2=1;\\n\\n            \\n        }return ans;\\n        \\n    }\\n}\\nbut this isn\\'t an optimal approach as only 19 test cases have passed."
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error in my work???"
                    }
                ]
            },
            {
                "id": 1902552,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Apparently, this is no bueno (fails on testcase 18). Anyone seeing glaring issues? I just saw that there\\'s some postfix/prefix way of doing things that I never heard of, so I\\'ll look into that. First, I want to understand what\\'s wrong with this solution.\\n```python\\n   def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        if len(nums) == 2:\\n            return [nums[1], nums[0]]\\n        \\n        answer = []\\n\\n        for i in range(len(nums)):\\n            product = 1\\n            j = i + 1 \\n            if j == len(nums):\\n                j = 0\\n            while j != i:\\n                if j == len(nums):\\n                    j = 0\\n                else:\\n                    product *= nums[j] \\n                    j += 1\\n            answer.append(product)\\n        \\n        return answer\\n```"
                    },
                    {
                        "username": "SanyamVv",
                        "content": "if nums = [0,4,0] then correct answer is [0,0,0].\\nthen accordingly if nums = [1,0] then why is correct answer given as [0,1], shouldn\\'t it be [0,0] only?"
                    },
                    {
                        "username": "FWard",
                        "content": "If I have [1,1,0], then it will be [0, 0, 1]. There should be at least two zeroes for the array to be fully zero."
                    },
                    {
                        "username": "jebinvasanth",
                        "content": "whenever the element on which the pointer is \\'0\\' then we don\\'t divide it by \\'0\\'. so it won\\'t be 1/0, we would should multiply the rest of the element.\\n"
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": "class Solution:\\n    def productExceptSelf(self, a: List[int]) -> List[int]:\\n        prod = 1\\n        countZero = 0\\n\\n        for idx in range(len(a)):\\n            if a[idx] == 0:\\n                countZero+=1\\n                continue\\n            prod*=a[idx]\\n            \\n        if countZero == 0:\\n            for idx in range(len(a)):\\n                a[idx] = prod//a[idx]\\n                \\n        elif countZero == len(a):\\n            for idx in range(len(a)):\\n                a[idx] = 0\\n        else:\\n            for idx in range(len(a)):\\n                if a[idx] == 0:\\n                    a[idx] = prod\\n                else:\\n                    a[idx] = 0\\n\\n        return a\\n\\nHere, I am calculating the product of whole array, also skipping the 0s that might occur. By keeping the count of zeros occurred, I am traversing the array once again, and replacing the elements as follows\\n\\n1) If no zeros, the elements will be replaced as product of whole array divided by a[i]\\n2) If the zero count is equal to the length of array, then I will replace everything with zeros\\n3) Else I will replace zero element with array product and other non zero elements with zero.\\n\\nThis is failing for [0,4,0] in leetcode, but when I try the same in some other editor it works fine. Can anyone help? TC: O(2N), SC: O(1)"
                    },
                    {
                        "username": "user1133eL",
                        "content": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        import numpy\n        ans=[]\n        for i in nums:\n            lis=[]\n            lis.extend(nums)\n            lis.remove(i)\n            x=numpy.prod(lis)\n            ans.append(x)\n        return ans\nI am getting TLE help me out guys "
                    },
                    {
                        "username": "suspiciousRaccoon",
                        "content": "this doesnt work lol \\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        return [reduce(lambda x,y: x*y, nums[:i]+nums[i+1:]) for i in range(len(nums))]"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans;\\n        for(int i=0; i<n; i++){\\n            int product = 1;\\n            for(int j=0 ; j<n ; j++){\\n                if(i==j){\\n                    continue;\\n                }\\n                product *= nums[j];\\n            }\\n            ans.push_back(product);\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n\\nhow can i solve a time limit exceeded problem in this code \\n"
                    },
                    {
                        "username": "Belyua",
                        "content": "try 1 iteration\\n"
                    },
                    {
                        "username": "niazstat",
                        "content": "Time Limit Exceeded\\n22 / 22 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "#include<stdio.h>\\n\\nint main()\\n{\\n    int num[] = {-1,1,0,-3,3};\\n    int n = sizeof(num)/sizeof(num[0]);\\n    int ans[n];\\n    int sum = 1;\\n\\n    for(int i = 0 ; i< n ; i++)                                 // Time complexity = O(n*2)\\n    {\\n        sum = 1;\\n        for(int j = 0 ; j<n ; j++)\\n        {\\n            if(j!=i)\\n            {\\n                sum = sum*num[j];\\n            }\\n        }\\n        ans[i] = sum;\\n    }\\n    for(int k = 0 ; k<n ; k++)\\n    {\\n        printf(\"%d \",ans[k]);\\n    }\\n    printf(\"\\\\n\");\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n\\n\\nint[] ans = new int[nums.length];\\nint left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\nfor(int i = 0; i < nums.length; i++){\\nwhile(left < i){\\nvar1 = var1 * nums[left];\\nleft++;\\n}\\nwhile(right > i){\\nvar2 = var2 * nums[right];\\nright--;\\n}\\nans[i] = var1 * var2;\\n}\\nreturn ans;"
                    },
                    {
                        "username": "rananikhal2003",
                        "content": "re_initialize all the variable var1 ,var1, left ,right to their orginal values after each iteration.\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int var1=1,var2=1;\\n        int[] ans = new int[nums.length];\\n\\n        int left=0,right=nums.length-1;\\n        for (int i=0;i<nums.length;i++){\\n            while (left<i){\\n                var1=var1*nums[left];\\n                left++;\\n            }left=0;\\n            while (right>i){\\n                var2=var2*nums[right];\\n                right--;\\n            }right=nums.length-1;\\n            ans[i]=var1*var2;\\n            var1=1;\\n            var2=1;\\n\\n            \\n        }return ans;\\n        \\n    }\\n}\\nbut this isn\\'t an optimal approach as only 19 test cases have passed."
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error in my work???"
                    }
                ]
            },
            {
                "id": 1879752,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Apparently, this is no bueno (fails on testcase 18). Anyone seeing glaring issues? I just saw that there\\'s some postfix/prefix way of doing things that I never heard of, so I\\'ll look into that. First, I want to understand what\\'s wrong with this solution.\\n```python\\n   def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        if len(nums) == 2:\\n            return [nums[1], nums[0]]\\n        \\n        answer = []\\n\\n        for i in range(len(nums)):\\n            product = 1\\n            j = i + 1 \\n            if j == len(nums):\\n                j = 0\\n            while j != i:\\n                if j == len(nums):\\n                    j = 0\\n                else:\\n                    product *= nums[j] \\n                    j += 1\\n            answer.append(product)\\n        \\n        return answer\\n```"
                    },
                    {
                        "username": "SanyamVv",
                        "content": "if nums = [0,4,0] then correct answer is [0,0,0].\\nthen accordingly if nums = [1,0] then why is correct answer given as [0,1], shouldn\\'t it be [0,0] only?"
                    },
                    {
                        "username": "FWard",
                        "content": "If I have [1,1,0], then it will be [0, 0, 1]. There should be at least two zeroes for the array to be fully zero."
                    },
                    {
                        "username": "jebinvasanth",
                        "content": "whenever the element on which the pointer is \\'0\\' then we don\\'t divide it by \\'0\\'. so it won\\'t be 1/0, we would should multiply the rest of the element.\\n"
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": "class Solution:\\n    def productExceptSelf(self, a: List[int]) -> List[int]:\\n        prod = 1\\n        countZero = 0\\n\\n        for idx in range(len(a)):\\n            if a[idx] == 0:\\n                countZero+=1\\n                continue\\n            prod*=a[idx]\\n            \\n        if countZero == 0:\\n            for idx in range(len(a)):\\n                a[idx] = prod//a[idx]\\n                \\n        elif countZero == len(a):\\n            for idx in range(len(a)):\\n                a[idx] = 0\\n        else:\\n            for idx in range(len(a)):\\n                if a[idx] == 0:\\n                    a[idx] = prod\\n                else:\\n                    a[idx] = 0\\n\\n        return a\\n\\nHere, I am calculating the product of whole array, also skipping the 0s that might occur. By keeping the count of zeros occurred, I am traversing the array once again, and replacing the elements as follows\\n\\n1) If no zeros, the elements will be replaced as product of whole array divided by a[i]\\n2) If the zero count is equal to the length of array, then I will replace everything with zeros\\n3) Else I will replace zero element with array product and other non zero elements with zero.\\n\\nThis is failing for [0,4,0] in leetcode, but when I try the same in some other editor it works fine. Can anyone help? TC: O(2N), SC: O(1)"
                    },
                    {
                        "username": "user1133eL",
                        "content": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        import numpy\n        ans=[]\n        for i in nums:\n            lis=[]\n            lis.extend(nums)\n            lis.remove(i)\n            x=numpy.prod(lis)\n            ans.append(x)\n        return ans\nI am getting TLE help me out guys "
                    },
                    {
                        "username": "suspiciousRaccoon",
                        "content": "this doesnt work lol \\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        return [reduce(lambda x,y: x*y, nums[:i]+nums[i+1:]) for i in range(len(nums))]"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans;\\n        for(int i=0; i<n; i++){\\n            int product = 1;\\n            for(int j=0 ; j<n ; j++){\\n                if(i==j){\\n                    continue;\\n                }\\n                product *= nums[j];\\n            }\\n            ans.push_back(product);\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n\\nhow can i solve a time limit exceeded problem in this code \\n"
                    },
                    {
                        "username": "Belyua",
                        "content": "try 1 iteration\\n"
                    },
                    {
                        "username": "niazstat",
                        "content": "Time Limit Exceeded\\n22 / 22 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "#include<stdio.h>\\n\\nint main()\\n{\\n    int num[] = {-1,1,0,-3,3};\\n    int n = sizeof(num)/sizeof(num[0]);\\n    int ans[n];\\n    int sum = 1;\\n\\n    for(int i = 0 ; i< n ; i++)                                 // Time complexity = O(n*2)\\n    {\\n        sum = 1;\\n        for(int j = 0 ; j<n ; j++)\\n        {\\n            if(j!=i)\\n            {\\n                sum = sum*num[j];\\n            }\\n        }\\n        ans[i] = sum;\\n    }\\n    for(int k = 0 ; k<n ; k++)\\n    {\\n        printf(\"%d \",ans[k]);\\n    }\\n    printf(\"\\\\n\");\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n\\n\\nint[] ans = new int[nums.length];\\nint left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\nfor(int i = 0; i < nums.length; i++){\\nwhile(left < i){\\nvar1 = var1 * nums[left];\\nleft++;\\n}\\nwhile(right > i){\\nvar2 = var2 * nums[right];\\nright--;\\n}\\nans[i] = var1 * var2;\\n}\\nreturn ans;"
                    },
                    {
                        "username": "rananikhal2003",
                        "content": "re_initialize all the variable var1 ,var1, left ,right to their orginal values after each iteration.\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int var1=1,var2=1;\\n        int[] ans = new int[nums.length];\\n\\n        int left=0,right=nums.length-1;\\n        for (int i=0;i<nums.length;i++){\\n            while (left<i){\\n                var1=var1*nums[left];\\n                left++;\\n            }left=0;\\n            while (right>i){\\n                var2=var2*nums[right];\\n                right--;\\n            }right=nums.length-1;\\n            ans[i]=var1*var2;\\n            var1=1;\\n            var2=1;\\n\\n            \\n        }return ans;\\n        \\n    }\\n}\\nbut this isn\\'t an optimal approach as only 19 test cases have passed."
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error in my work???"
                    }
                ]
            },
            {
                "id": 1875243,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Apparently, this is no bueno (fails on testcase 18). Anyone seeing glaring issues? I just saw that there\\'s some postfix/prefix way of doing things that I never heard of, so I\\'ll look into that. First, I want to understand what\\'s wrong with this solution.\\n```python\\n   def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        if len(nums) == 2:\\n            return [nums[1], nums[0]]\\n        \\n        answer = []\\n\\n        for i in range(len(nums)):\\n            product = 1\\n            j = i + 1 \\n            if j == len(nums):\\n                j = 0\\n            while j != i:\\n                if j == len(nums):\\n                    j = 0\\n                else:\\n                    product *= nums[j] \\n                    j += 1\\n            answer.append(product)\\n        \\n        return answer\\n```"
                    },
                    {
                        "username": "SanyamVv",
                        "content": "if nums = [0,4,0] then correct answer is [0,0,0].\\nthen accordingly if nums = [1,0] then why is correct answer given as [0,1], shouldn\\'t it be [0,0] only?"
                    },
                    {
                        "username": "FWard",
                        "content": "If I have [1,1,0], then it will be [0, 0, 1]. There should be at least two zeroes for the array to be fully zero."
                    },
                    {
                        "username": "jebinvasanth",
                        "content": "whenever the element on which the pointer is \\'0\\' then we don\\'t divide it by \\'0\\'. so it won\\'t be 1/0, we would should multiply the rest of the element.\\n"
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": "class Solution:\\n    def productExceptSelf(self, a: List[int]) -> List[int]:\\n        prod = 1\\n        countZero = 0\\n\\n        for idx in range(len(a)):\\n            if a[idx] == 0:\\n                countZero+=1\\n                continue\\n            prod*=a[idx]\\n            \\n        if countZero == 0:\\n            for idx in range(len(a)):\\n                a[idx] = prod//a[idx]\\n                \\n        elif countZero == len(a):\\n            for idx in range(len(a)):\\n                a[idx] = 0\\n        else:\\n            for idx in range(len(a)):\\n                if a[idx] == 0:\\n                    a[idx] = prod\\n                else:\\n                    a[idx] = 0\\n\\n        return a\\n\\nHere, I am calculating the product of whole array, also skipping the 0s that might occur. By keeping the count of zeros occurred, I am traversing the array once again, and replacing the elements as follows\\n\\n1) If no zeros, the elements will be replaced as product of whole array divided by a[i]\\n2) If the zero count is equal to the length of array, then I will replace everything with zeros\\n3) Else I will replace zero element with array product and other non zero elements with zero.\\n\\nThis is failing for [0,4,0] in leetcode, but when I try the same in some other editor it works fine. Can anyone help? TC: O(2N), SC: O(1)"
                    },
                    {
                        "username": "user1133eL",
                        "content": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        import numpy\n        ans=[]\n        for i in nums:\n            lis=[]\n            lis.extend(nums)\n            lis.remove(i)\n            x=numpy.prod(lis)\n            ans.append(x)\n        return ans\nI am getting TLE help me out guys "
                    },
                    {
                        "username": "suspiciousRaccoon",
                        "content": "this doesnt work lol \\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        return [reduce(lambda x,y: x*y, nums[:i]+nums[i+1:]) for i in range(len(nums))]"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans;\\n        for(int i=0; i<n; i++){\\n            int product = 1;\\n            for(int j=0 ; j<n ; j++){\\n                if(i==j){\\n                    continue;\\n                }\\n                product *= nums[j];\\n            }\\n            ans.push_back(product);\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n\\nhow can i solve a time limit exceeded problem in this code \\n"
                    },
                    {
                        "username": "Belyua",
                        "content": "try 1 iteration\\n"
                    },
                    {
                        "username": "niazstat",
                        "content": "Time Limit Exceeded\\n22 / 22 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "#include<stdio.h>\\n\\nint main()\\n{\\n    int num[] = {-1,1,0,-3,3};\\n    int n = sizeof(num)/sizeof(num[0]);\\n    int ans[n];\\n    int sum = 1;\\n\\n    for(int i = 0 ; i< n ; i++)                                 // Time complexity = O(n*2)\\n    {\\n        sum = 1;\\n        for(int j = 0 ; j<n ; j++)\\n        {\\n            if(j!=i)\\n            {\\n                sum = sum*num[j];\\n            }\\n        }\\n        ans[i] = sum;\\n    }\\n    for(int k = 0 ; k<n ; k++)\\n    {\\n        printf(\"%d \",ans[k]);\\n    }\\n    printf(\"\\\\n\");\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n\\n\\nint[] ans = new int[nums.length];\\nint left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\nfor(int i = 0; i < nums.length; i++){\\nwhile(left < i){\\nvar1 = var1 * nums[left];\\nleft++;\\n}\\nwhile(right > i){\\nvar2 = var2 * nums[right];\\nright--;\\n}\\nans[i] = var1 * var2;\\n}\\nreturn ans;"
                    },
                    {
                        "username": "rananikhal2003",
                        "content": "re_initialize all the variable var1 ,var1, left ,right to their orginal values after each iteration.\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int var1=1,var2=1;\\n        int[] ans = new int[nums.length];\\n\\n        int left=0,right=nums.length-1;\\n        for (int i=0;i<nums.length;i++){\\n            while (left<i){\\n                var1=var1*nums[left];\\n                left++;\\n            }left=0;\\n            while (right>i){\\n                var2=var2*nums[right];\\n                right--;\\n            }right=nums.length-1;\\n            ans[i]=var1*var2;\\n            var1=1;\\n            var2=1;\\n\\n            \\n        }return ans;\\n        \\n    }\\n}\\nbut this isn\\'t an optimal approach as only 19 test cases have passed."
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error in my work???"
                    }
                ]
            },
            {
                "id": 1874623,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Apparently, this is no bueno (fails on testcase 18). Anyone seeing glaring issues? I just saw that there\\'s some postfix/prefix way of doing things that I never heard of, so I\\'ll look into that. First, I want to understand what\\'s wrong with this solution.\\n```python\\n   def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        if len(nums) == 2:\\n            return [nums[1], nums[0]]\\n        \\n        answer = []\\n\\n        for i in range(len(nums)):\\n            product = 1\\n            j = i + 1 \\n            if j == len(nums):\\n                j = 0\\n            while j != i:\\n                if j == len(nums):\\n                    j = 0\\n                else:\\n                    product *= nums[j] \\n                    j += 1\\n            answer.append(product)\\n        \\n        return answer\\n```"
                    },
                    {
                        "username": "SanyamVv",
                        "content": "if nums = [0,4,0] then correct answer is [0,0,0].\\nthen accordingly if nums = [1,0] then why is correct answer given as [0,1], shouldn\\'t it be [0,0] only?"
                    },
                    {
                        "username": "FWard",
                        "content": "If I have [1,1,0], then it will be [0, 0, 1]. There should be at least two zeroes for the array to be fully zero."
                    },
                    {
                        "username": "jebinvasanth",
                        "content": "whenever the element on which the pointer is \\'0\\' then we don\\'t divide it by \\'0\\'. so it won\\'t be 1/0, we would should multiply the rest of the element.\\n"
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": "class Solution:\\n    def productExceptSelf(self, a: List[int]) -> List[int]:\\n        prod = 1\\n        countZero = 0\\n\\n        for idx in range(len(a)):\\n            if a[idx] == 0:\\n                countZero+=1\\n                continue\\n            prod*=a[idx]\\n            \\n        if countZero == 0:\\n            for idx in range(len(a)):\\n                a[idx] = prod//a[idx]\\n                \\n        elif countZero == len(a):\\n            for idx in range(len(a)):\\n                a[idx] = 0\\n        else:\\n            for idx in range(len(a)):\\n                if a[idx] == 0:\\n                    a[idx] = prod\\n                else:\\n                    a[idx] = 0\\n\\n        return a\\n\\nHere, I am calculating the product of whole array, also skipping the 0s that might occur. By keeping the count of zeros occurred, I am traversing the array once again, and replacing the elements as follows\\n\\n1) If no zeros, the elements will be replaced as product of whole array divided by a[i]\\n2) If the zero count is equal to the length of array, then I will replace everything with zeros\\n3) Else I will replace zero element with array product and other non zero elements with zero.\\n\\nThis is failing for [0,4,0] in leetcode, but when I try the same in some other editor it works fine. Can anyone help? TC: O(2N), SC: O(1)"
                    },
                    {
                        "username": "user1133eL",
                        "content": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        import numpy\n        ans=[]\n        for i in nums:\n            lis=[]\n            lis.extend(nums)\n            lis.remove(i)\n            x=numpy.prod(lis)\n            ans.append(x)\n        return ans\nI am getting TLE help me out guys "
                    },
                    {
                        "username": "suspiciousRaccoon",
                        "content": "this doesnt work lol \\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        return [reduce(lambda x,y: x*y, nums[:i]+nums[i+1:]) for i in range(len(nums))]"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans;\\n        for(int i=0; i<n; i++){\\n            int product = 1;\\n            for(int j=0 ; j<n ; j++){\\n                if(i==j){\\n                    continue;\\n                }\\n                product *= nums[j];\\n            }\\n            ans.push_back(product);\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n\\nhow can i solve a time limit exceeded problem in this code \\n"
                    },
                    {
                        "username": "Belyua",
                        "content": "try 1 iteration\\n"
                    },
                    {
                        "username": "niazstat",
                        "content": "Time Limit Exceeded\\n22 / 22 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "#include<stdio.h>\\n\\nint main()\\n{\\n    int num[] = {-1,1,0,-3,3};\\n    int n = sizeof(num)/sizeof(num[0]);\\n    int ans[n];\\n    int sum = 1;\\n\\n    for(int i = 0 ; i< n ; i++)                                 // Time complexity = O(n*2)\\n    {\\n        sum = 1;\\n        for(int j = 0 ; j<n ; j++)\\n        {\\n            if(j!=i)\\n            {\\n                sum = sum*num[j];\\n            }\\n        }\\n        ans[i] = sum;\\n    }\\n    for(int k = 0 ; k<n ; k++)\\n    {\\n        printf(\"%d \",ans[k]);\\n    }\\n    printf(\"\\\\n\");\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n\\n\\nint[] ans = new int[nums.length];\\nint left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\nfor(int i = 0; i < nums.length; i++){\\nwhile(left < i){\\nvar1 = var1 * nums[left];\\nleft++;\\n}\\nwhile(right > i){\\nvar2 = var2 * nums[right];\\nright--;\\n}\\nans[i] = var1 * var2;\\n}\\nreturn ans;"
                    },
                    {
                        "username": "rananikhal2003",
                        "content": "re_initialize all the variable var1 ,var1, left ,right to their orginal values after each iteration.\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int var1=1,var2=1;\\n        int[] ans = new int[nums.length];\\n\\n        int left=0,right=nums.length-1;\\n        for (int i=0;i<nums.length;i++){\\n            while (left<i){\\n                var1=var1*nums[left];\\n                left++;\\n            }left=0;\\n            while (right>i){\\n                var2=var2*nums[right];\\n                right--;\\n            }right=nums.length-1;\\n            ans[i]=var1*var2;\\n            var1=1;\\n            var2=1;\\n\\n            \\n        }return ans;\\n        \\n    }\\n}\\nbut this isn\\'t an optimal approach as only 19 test cases have passed."
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error in my work???"
                    }
                ]
            },
            {
                "id": 1814507,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Apparently, this is no bueno (fails on testcase 18). Anyone seeing glaring issues? I just saw that there\\'s some postfix/prefix way of doing things that I never heard of, so I\\'ll look into that. First, I want to understand what\\'s wrong with this solution.\\n```python\\n   def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        if len(nums) == 2:\\n            return [nums[1], nums[0]]\\n        \\n        answer = []\\n\\n        for i in range(len(nums)):\\n            product = 1\\n            j = i + 1 \\n            if j == len(nums):\\n                j = 0\\n            while j != i:\\n                if j == len(nums):\\n                    j = 0\\n                else:\\n                    product *= nums[j] \\n                    j += 1\\n            answer.append(product)\\n        \\n        return answer\\n```"
                    },
                    {
                        "username": "SanyamVv",
                        "content": "if nums = [0,4,0] then correct answer is [0,0,0].\\nthen accordingly if nums = [1,0] then why is correct answer given as [0,1], shouldn\\'t it be [0,0] only?"
                    },
                    {
                        "username": "FWard",
                        "content": "If I have [1,1,0], then it will be [0, 0, 1]. There should be at least two zeroes for the array to be fully zero."
                    },
                    {
                        "username": "jebinvasanth",
                        "content": "whenever the element on which the pointer is \\'0\\' then we don\\'t divide it by \\'0\\'. so it won\\'t be 1/0, we would should multiply the rest of the element.\\n"
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": "class Solution:\\n    def productExceptSelf(self, a: List[int]) -> List[int]:\\n        prod = 1\\n        countZero = 0\\n\\n        for idx in range(len(a)):\\n            if a[idx] == 0:\\n                countZero+=1\\n                continue\\n            prod*=a[idx]\\n            \\n        if countZero == 0:\\n            for idx in range(len(a)):\\n                a[idx] = prod//a[idx]\\n                \\n        elif countZero == len(a):\\n            for idx in range(len(a)):\\n                a[idx] = 0\\n        else:\\n            for idx in range(len(a)):\\n                if a[idx] == 0:\\n                    a[idx] = prod\\n                else:\\n                    a[idx] = 0\\n\\n        return a\\n\\nHere, I am calculating the product of whole array, also skipping the 0s that might occur. By keeping the count of zeros occurred, I am traversing the array once again, and replacing the elements as follows\\n\\n1) If no zeros, the elements will be replaced as product of whole array divided by a[i]\\n2) If the zero count is equal to the length of array, then I will replace everything with zeros\\n3) Else I will replace zero element with array product and other non zero elements with zero.\\n\\nThis is failing for [0,4,0] in leetcode, but when I try the same in some other editor it works fine. Can anyone help? TC: O(2N), SC: O(1)"
                    },
                    {
                        "username": "user1133eL",
                        "content": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        import numpy\n        ans=[]\n        for i in nums:\n            lis=[]\n            lis.extend(nums)\n            lis.remove(i)\n            x=numpy.prod(lis)\n            ans.append(x)\n        return ans\nI am getting TLE help me out guys "
                    },
                    {
                        "username": "suspiciousRaccoon",
                        "content": "this doesnt work lol \\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        return [reduce(lambda x,y: x*y, nums[:i]+nums[i+1:]) for i in range(len(nums))]"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans;\\n        for(int i=0; i<n; i++){\\n            int product = 1;\\n            for(int j=0 ; j<n ; j++){\\n                if(i==j){\\n                    continue;\\n                }\\n                product *= nums[j];\\n            }\\n            ans.push_back(product);\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n\\nhow can i solve a time limit exceeded problem in this code \\n"
                    },
                    {
                        "username": "Belyua",
                        "content": "try 1 iteration\\n"
                    },
                    {
                        "username": "niazstat",
                        "content": "Time Limit Exceeded\\n22 / 22 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "#include<stdio.h>\\n\\nint main()\\n{\\n    int num[] = {-1,1,0,-3,3};\\n    int n = sizeof(num)/sizeof(num[0]);\\n    int ans[n];\\n    int sum = 1;\\n\\n    for(int i = 0 ; i< n ; i++)                                 // Time complexity = O(n*2)\\n    {\\n        sum = 1;\\n        for(int j = 0 ; j<n ; j++)\\n        {\\n            if(j!=i)\\n            {\\n                sum = sum*num[j];\\n            }\\n        }\\n        ans[i] = sum;\\n    }\\n    for(int k = 0 ; k<n ; k++)\\n    {\\n        printf(\"%d \",ans[k]);\\n    }\\n    printf(\"\\\\n\");\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n\\n\\nint[] ans = new int[nums.length];\\nint left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\nfor(int i = 0; i < nums.length; i++){\\nwhile(left < i){\\nvar1 = var1 * nums[left];\\nleft++;\\n}\\nwhile(right > i){\\nvar2 = var2 * nums[right];\\nright--;\\n}\\nans[i] = var1 * var2;\\n}\\nreturn ans;"
                    },
                    {
                        "username": "rananikhal2003",
                        "content": "re_initialize all the variable var1 ,var1, left ,right to their orginal values after each iteration.\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int var1=1,var2=1;\\n        int[] ans = new int[nums.length];\\n\\n        int left=0,right=nums.length-1;\\n        for (int i=0;i<nums.length;i++){\\n            while (left<i){\\n                var1=var1*nums[left];\\n                left++;\\n            }left=0;\\n            while (right>i){\\n                var2=var2*nums[right];\\n                right--;\\n            }right=nums.length-1;\\n            ans[i]=var1*var2;\\n            var1=1;\\n            var2=1;\\n\\n            \\n        }return ans;\\n        \\n    }\\n}\\nbut this isn\\'t an optimal approach as only 19 test cases have passed."
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error in my work???"
                    }
                ]
            },
            {
                "id": 1813649,
                "content": [
                    {
                        "username": "phllpmcphrsn",
                        "content": "Apparently, this is no bueno (fails on testcase 18). Anyone seeing glaring issues? I just saw that there\\'s some postfix/prefix way of doing things that I never heard of, so I\\'ll look into that. First, I want to understand what\\'s wrong with this solution.\\n```python\\n   def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        if len(nums) == 2:\\n            return [nums[1], nums[0]]\\n        \\n        answer = []\\n\\n        for i in range(len(nums)):\\n            product = 1\\n            j = i + 1 \\n            if j == len(nums):\\n                j = 0\\n            while j != i:\\n                if j == len(nums):\\n                    j = 0\\n                else:\\n                    product *= nums[j] \\n                    j += 1\\n            answer.append(product)\\n        \\n        return answer\\n```"
                    },
                    {
                        "username": "SanyamVv",
                        "content": "if nums = [0,4,0] then correct answer is [0,0,0].\\nthen accordingly if nums = [1,0] then why is correct answer given as [0,1], shouldn\\'t it be [0,0] only?"
                    },
                    {
                        "username": "FWard",
                        "content": "If I have [1,1,0], then it will be [0, 0, 1]. There should be at least two zeroes for the array to be fully zero."
                    },
                    {
                        "username": "jebinvasanth",
                        "content": "whenever the element on which the pointer is \\'0\\' then we don\\'t divide it by \\'0\\'. so it won\\'t be 1/0, we would should multiply the rest of the element.\\n"
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": "class Solution:\\n    def productExceptSelf(self, a: List[int]) -> List[int]:\\n        prod = 1\\n        countZero = 0\\n\\n        for idx in range(len(a)):\\n            if a[idx] == 0:\\n                countZero+=1\\n                continue\\n            prod*=a[idx]\\n            \\n        if countZero == 0:\\n            for idx in range(len(a)):\\n                a[idx] = prod//a[idx]\\n                \\n        elif countZero == len(a):\\n            for idx in range(len(a)):\\n                a[idx] = 0\\n        else:\\n            for idx in range(len(a)):\\n                if a[idx] == 0:\\n                    a[idx] = prod\\n                else:\\n                    a[idx] = 0\\n\\n        return a\\n\\nHere, I am calculating the product of whole array, also skipping the 0s that might occur. By keeping the count of zeros occurred, I am traversing the array once again, and replacing the elements as follows\\n\\n1) If no zeros, the elements will be replaced as product of whole array divided by a[i]\\n2) If the zero count is equal to the length of array, then I will replace everything with zeros\\n3) Else I will replace zero element with array product and other non zero elements with zero.\\n\\nThis is failing for [0,4,0] in leetcode, but when I try the same in some other editor it works fine. Can anyone help? TC: O(2N), SC: O(1)"
                    },
                    {
                        "username": "user1133eL",
                        "content": "class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        import numpy\n        ans=[]\n        for i in nums:\n            lis=[]\n            lis.extend(nums)\n            lis.remove(i)\n            x=numpy.prod(lis)\n            ans.append(x)\n        return ans\nI am getting TLE help me out guys "
                    },
                    {
                        "username": "suspiciousRaccoon",
                        "content": "this doesnt work lol \\nclass Solution:\\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\\n        return [reduce(lambda x,y: x*y, nums[:i]+nums[i+1:]) for i in range(len(nums))]"
                    },
                    {
                        "username": "shivam1750",
                        "content": "class Solution {\\npublic:\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int>ans;\\n        for(int i=0; i<n; i++){\\n            int product = 1;\\n            for(int j=0 ; j<n ; j++){\\n                if(i==j){\\n                    continue;\\n                }\\n                product *= nums[j];\\n            }\\n            ans.push_back(product);\\n        }\\n        return ans;\\n\\n    }\\n};\\n\\n\\nhow can i solve a time limit exceeded problem in this code \\n"
                    },
                    {
                        "username": "Belyua",
                        "content": "try 1 iteration\\n"
                    },
                    {
                        "username": "niazstat",
                        "content": "Time Limit Exceeded\\n22 / 22 testcases passed\\n\\nLast Executed Input\\nnums ="
                    },
                    {
                        "username": "Ankit_Hanotia",
                        "content": "#include<stdio.h>\\n\\nint main()\\n{\\n    int num[] = {-1,1,0,-3,3};\\n    int n = sizeof(num)/sizeof(num[0]);\\n    int ans[n];\\n    int sum = 1;\\n\\n    for(int i = 0 ; i< n ; i++)                                 // Time complexity = O(n*2)\\n    {\\n        sum = 1;\\n        for(int j = 0 ; j<n ; j++)\\n        {\\n            if(j!=i)\\n            {\\n                sum = sum*num[j];\\n            }\\n        }\\n        ans[i] = sum;\\n    }\\n    for(int k = 0 ; k<n ; k++)\\n    {\\n        printf(\"%d \",ans[k]);\\n    }\\n    printf(\"\\\\n\");\\n\\n    return 0;\\n}"
                    },
                    {
                        "username": "Harshalpatel_14",
                        "content": "help me with this code plz... what\\'s wrong here\\n\\n\\nint[] ans = new int[nums.length];\\nint left = 0, right = nums.length - 1, var1 = 1, var2 = 1;\\nfor(int i = 0; i < nums.length; i++){\\nwhile(left < i){\\nvar1 = var1 * nums[left];\\nleft++;\\n}\\nwhile(right > i){\\nvar2 = var2 * nums[right];\\nright--;\\n}\\nans[i] = var1 * var2;\\n}\\nreturn ans;"
                    },
                    {
                        "username": "rananikhal2003",
                        "content": "re_initialize all the variable var1 ,var1, left ,right to their orginal values after each iteration.\\nclass Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int var1=1,var2=1;\\n        int[] ans = new int[nums.length];\\n\\n        int left=0,right=nums.length-1;\\n        for (int i=0;i<nums.length;i++){\\n            while (left<i){\\n                var1=var1*nums[left];\\n                left++;\\n            }left=0;\\n            while (right>i){\\n                var2=var2*nums[right];\\n                right--;\\n            }right=nums.length-1;\\n            ans[i]=var1*var2;\\n            var1=1;\\n            var2=1;\\n\\n            \\n        }return ans;\\n        \\n    }\\n}\\nbut this isn\\'t an optimal approach as only 19 test cases have passed."
                    },
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error in my work???"
                    }
                ]
            },
            {
                "id": 1813648,
                "content": [
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error????"
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n      int n = nums.length;\\n      int mul=0;\\n      int count=0;\\n      int[] ans = new int[n];\\n      for(int i=0;i<n;i++){\\n          if(nums[i]!=0){\\n              if(mul==0){\\n                  mul = nums[i];\\n              }else{\\n                  mul = mul*nums[i];\\n              }\\n          }else{\\n              count++;\\n          }\\n      }\\n      if(count==0){\\n          for(int i=0;i<n;i++){\\n              ans[i]=mul/nums[i];\\n          }\\n          return ans;\\n      }\\n      else if(count==1){\\n          for(int i=0;i<n;i++){\\n              if(nums[i]==0){\\n                  ans[i]=mul;\\n              }\\n              else{\\n                  ans[i]=0;\\n              }\\n          }\\n          return ans;\\n      }\\n      else{\\n          for(int i=0;i<n;i++){\\n              ans[i]=0;\\n          }\\n          return ans;\\n      }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "KedarP5",
                        "content": "class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) \\n    {\\n        \\tint iArraySize = nums.size();\\n\\tvector<int> vResult(iArraySize);\\n\\n\\tvResult.at(0) = 1;\\n\\n\\tfor (int i = 1; i < iArraySize; i++)\\n\\t{\\n\\t\\tvResult.at(i) = vResult.at(i - 1)*nums.at(i - 1);\\n\\t}\\n\\n\\tint iLastVal = 1;\\n\\n\\tfor (int i = iArraySize - 1; i >= 0; i--)\\n\\t{\\n\\t\\tvResult.at(i) *=iLastVal;\\n\\t\\tiLastVal *= nums.at(i);\\n\\t}\\n\\n\\treturn vResult;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jeevananthan1712",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] answer = new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++){\\n                answer[i] = 1;\\n            if(i==0){\\n                for(int j=i+1;j<nums.length;j++){\\n                    answer[i] *= nums[j];\\n                    // System.out.println(answer[i]);              \\n                }\\n            }\\n            else{\\n                for(int j=i-1;j>=0;j--){\\n                     answer[i] *= nums[j];\\n                    // System.out.println(answer[i]+\"j\"); \\n                }\\n                    for(int k=i+1;k<nums.length;k++){\\n                        answer[i] *= nums[k];\\n                    // System.out.println(answer[i]+\"k\"); \\n                    }\\n            }\\n        }\\n    \\n        System.out.println(Arrays.toString(answer));\\n        return answer;\\n    }\\n}\\n\\n\\n......................................\\nI wrote this program and i think it is correct but for input lyk testCaseNo:18,it\\'s showing wrong...What did i do wrong??Any Suggestions??"
                    },
                    {
                        "username": "madfcat",
                        "content": "My idea is to calculate the product of the elements before the ith element and the product of all the elements after the ith element. And then to multiply these two products. But how can we get it for each `nums` element?\\n\\nMy approach:\\n\\n1. Loop through `nums` array from the beginning to the end creating 2 new arrays:\\n\\n   first array, where each element equals to the product of all the previous elements of `nums` before current index. Each current element is a multiplier of current `nums` element and one that you pushed to this \"first array: in the previous iteration. You can for example set `prev` variable to equal current in the end of the loop. And the use it in the next calculation of the current product in the next iteration.\\n\\n   second array should be the the products but going backwards from the last element of the `nums` array. So, it should be length of `nums` subtracting the current index. And you have to fill the second array starting from the very last element as well (its index is `nums` length minus 1). So, it\\'s like you have an empty array and fill it from the end going backwards.\\n\\n2. Then you just loop through two arrays in one loop multiplying the value before ith element and after ith element. The first multiplier should be, for example, (i-1) and the second multiplier should be (i+1). For the out of range cases for i-1 and i+1 you should set it equal to 1, so it does not affect the multiplication.\\n\\nI hope it helps and I managed to explain my solution.\\n"
                    },
                    {
                        "username": "ravi_dtu2020",
                        "content": " class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n       int n=nums.size();\n        vector<int>left(n,1);\n        vector<int>right(n,1);\n        vector<int>ans(n,1);\n        \n        int p=1;\n          for(int i=0;i<n;i++){\n            left[i]=p;\n              p=p*nums[i];\n          }\n           p=1;\n           for(int i=n-1;i>=0;i--){\n             right[i]=p;\n               p=p*nums[i];\n            }\n           for(int i=0;i<n;i++){\n               ans[i]=left[i]*right[i];\n           }\n\n      return ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Fantastic!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gauravsharma8234",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        //multiply left\\n        int[] left=new int[nums.length];\\n        int[] right=new int[nums.length];\\n        int[] answer=new int[nums.length]; \\n        left[0]=1;\\n        right[nums.length-1]=1;\\n        for(int i=1;i<=nums.length-1;i++){\\n            left[i]=left[i-1]*nums[i-1];\\n        }\\n        for(int j=nums.length-2;j>=0;j--){\\n            right[j]=right[j+1]*nums[j+1];\\n        } \\n        for(int a=0;a<=nums.length-1;a++){\\n            answer[a]=left[a]*right[a];\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "peterzengcc",
                        "content": "I doubt if there\\'s any point if we\\'re actually allocating O(n) for the answer, but treating it as O(1). "
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    }
                ]
            },
            {
                "id": 1812045,
                "content": [
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error????"
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n      int n = nums.length;\\n      int mul=0;\\n      int count=0;\\n      int[] ans = new int[n];\\n      for(int i=0;i<n;i++){\\n          if(nums[i]!=0){\\n              if(mul==0){\\n                  mul = nums[i];\\n              }else{\\n                  mul = mul*nums[i];\\n              }\\n          }else{\\n              count++;\\n          }\\n      }\\n      if(count==0){\\n          for(int i=0;i<n;i++){\\n              ans[i]=mul/nums[i];\\n          }\\n          return ans;\\n      }\\n      else if(count==1){\\n          for(int i=0;i<n;i++){\\n              if(nums[i]==0){\\n                  ans[i]=mul;\\n              }\\n              else{\\n                  ans[i]=0;\\n              }\\n          }\\n          return ans;\\n      }\\n      else{\\n          for(int i=0;i<n;i++){\\n              ans[i]=0;\\n          }\\n          return ans;\\n      }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "KedarP5",
                        "content": "class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) \\n    {\\n        \\tint iArraySize = nums.size();\\n\\tvector<int> vResult(iArraySize);\\n\\n\\tvResult.at(0) = 1;\\n\\n\\tfor (int i = 1; i < iArraySize; i++)\\n\\t{\\n\\t\\tvResult.at(i) = vResult.at(i - 1)*nums.at(i - 1);\\n\\t}\\n\\n\\tint iLastVal = 1;\\n\\n\\tfor (int i = iArraySize - 1; i >= 0; i--)\\n\\t{\\n\\t\\tvResult.at(i) *=iLastVal;\\n\\t\\tiLastVal *= nums.at(i);\\n\\t}\\n\\n\\treturn vResult;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jeevananthan1712",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] answer = new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++){\\n                answer[i] = 1;\\n            if(i==0){\\n                for(int j=i+1;j<nums.length;j++){\\n                    answer[i] *= nums[j];\\n                    // System.out.println(answer[i]);              \\n                }\\n            }\\n            else{\\n                for(int j=i-1;j>=0;j--){\\n                     answer[i] *= nums[j];\\n                    // System.out.println(answer[i]+\"j\"); \\n                }\\n                    for(int k=i+1;k<nums.length;k++){\\n                        answer[i] *= nums[k];\\n                    // System.out.println(answer[i]+\"k\"); \\n                    }\\n            }\\n        }\\n    \\n        System.out.println(Arrays.toString(answer));\\n        return answer;\\n    }\\n}\\n\\n\\n......................................\\nI wrote this program and i think it is correct but for input lyk testCaseNo:18,it\\'s showing wrong...What did i do wrong??Any Suggestions??"
                    },
                    {
                        "username": "madfcat",
                        "content": "My idea is to calculate the product of the elements before the ith element and the product of all the elements after the ith element. And then to multiply these two products. But how can we get it for each `nums` element?\\n\\nMy approach:\\n\\n1. Loop through `nums` array from the beginning to the end creating 2 new arrays:\\n\\n   first array, where each element equals to the product of all the previous elements of `nums` before current index. Each current element is a multiplier of current `nums` element and one that you pushed to this \"first array: in the previous iteration. You can for example set `prev` variable to equal current in the end of the loop. And the use it in the next calculation of the current product in the next iteration.\\n\\n   second array should be the the products but going backwards from the last element of the `nums` array. So, it should be length of `nums` subtracting the current index. And you have to fill the second array starting from the very last element as well (its index is `nums` length minus 1). So, it\\'s like you have an empty array and fill it from the end going backwards.\\n\\n2. Then you just loop through two arrays in one loop multiplying the value before ith element and after ith element. The first multiplier should be, for example, (i-1) and the second multiplier should be (i+1). For the out of range cases for i-1 and i+1 you should set it equal to 1, so it does not affect the multiplication.\\n\\nI hope it helps and I managed to explain my solution.\\n"
                    },
                    {
                        "username": "ravi_dtu2020",
                        "content": " class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n       int n=nums.size();\n        vector<int>left(n,1);\n        vector<int>right(n,1);\n        vector<int>ans(n,1);\n        \n        int p=1;\n          for(int i=0;i<n;i++){\n            left[i]=p;\n              p=p*nums[i];\n          }\n           p=1;\n           for(int i=n-1;i>=0;i--){\n             right[i]=p;\n               p=p*nums[i];\n            }\n           for(int i=0;i<n;i++){\n               ans[i]=left[i]*right[i];\n           }\n\n      return ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Fantastic!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gauravsharma8234",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        //multiply left\\n        int[] left=new int[nums.length];\\n        int[] right=new int[nums.length];\\n        int[] answer=new int[nums.length]; \\n        left[0]=1;\\n        right[nums.length-1]=1;\\n        for(int i=1;i<=nums.length-1;i++){\\n            left[i]=left[i-1]*nums[i-1];\\n        }\\n        for(int j=nums.length-2;j>=0;j--){\\n            right[j]=right[j+1]*nums[j+1];\\n        } \\n        for(int a=0;a<=nums.length-1;a++){\\n            answer[a]=left[a]*right[a];\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "peterzengcc",
                        "content": "I doubt if there\\'s any point if we\\'re actually allocating O(n) for the answer, but treating it as O(1). "
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    }
                ]
            },
            {
                "id": 1804216,
                "content": [
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error????"
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n      int n = nums.length;\\n      int mul=0;\\n      int count=0;\\n      int[] ans = new int[n];\\n      for(int i=0;i<n;i++){\\n          if(nums[i]!=0){\\n              if(mul==0){\\n                  mul = nums[i];\\n              }else{\\n                  mul = mul*nums[i];\\n              }\\n          }else{\\n              count++;\\n          }\\n      }\\n      if(count==0){\\n          for(int i=0;i<n;i++){\\n              ans[i]=mul/nums[i];\\n          }\\n          return ans;\\n      }\\n      else if(count==1){\\n          for(int i=0;i<n;i++){\\n              if(nums[i]==0){\\n                  ans[i]=mul;\\n              }\\n              else{\\n                  ans[i]=0;\\n              }\\n          }\\n          return ans;\\n      }\\n      else{\\n          for(int i=0;i<n;i++){\\n              ans[i]=0;\\n          }\\n          return ans;\\n      }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "KedarP5",
                        "content": "class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) \\n    {\\n        \\tint iArraySize = nums.size();\\n\\tvector<int> vResult(iArraySize);\\n\\n\\tvResult.at(0) = 1;\\n\\n\\tfor (int i = 1; i < iArraySize; i++)\\n\\t{\\n\\t\\tvResult.at(i) = vResult.at(i - 1)*nums.at(i - 1);\\n\\t}\\n\\n\\tint iLastVal = 1;\\n\\n\\tfor (int i = iArraySize - 1; i >= 0; i--)\\n\\t{\\n\\t\\tvResult.at(i) *=iLastVal;\\n\\t\\tiLastVal *= nums.at(i);\\n\\t}\\n\\n\\treturn vResult;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jeevananthan1712",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] answer = new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++){\\n                answer[i] = 1;\\n            if(i==0){\\n                for(int j=i+1;j<nums.length;j++){\\n                    answer[i] *= nums[j];\\n                    // System.out.println(answer[i]);              \\n                }\\n            }\\n            else{\\n                for(int j=i-1;j>=0;j--){\\n                     answer[i] *= nums[j];\\n                    // System.out.println(answer[i]+\"j\"); \\n                }\\n                    for(int k=i+1;k<nums.length;k++){\\n                        answer[i] *= nums[k];\\n                    // System.out.println(answer[i]+\"k\"); \\n                    }\\n            }\\n        }\\n    \\n        System.out.println(Arrays.toString(answer));\\n        return answer;\\n    }\\n}\\n\\n\\n......................................\\nI wrote this program and i think it is correct but for input lyk testCaseNo:18,it\\'s showing wrong...What did i do wrong??Any Suggestions??"
                    },
                    {
                        "username": "madfcat",
                        "content": "My idea is to calculate the product of the elements before the ith element and the product of all the elements after the ith element. And then to multiply these two products. But how can we get it for each `nums` element?\\n\\nMy approach:\\n\\n1. Loop through `nums` array from the beginning to the end creating 2 new arrays:\\n\\n   first array, where each element equals to the product of all the previous elements of `nums` before current index. Each current element is a multiplier of current `nums` element and one that you pushed to this \"first array: in the previous iteration. You can for example set `prev` variable to equal current in the end of the loop. And the use it in the next calculation of the current product in the next iteration.\\n\\n   second array should be the the products but going backwards from the last element of the `nums` array. So, it should be length of `nums` subtracting the current index. And you have to fill the second array starting from the very last element as well (its index is `nums` length minus 1). So, it\\'s like you have an empty array and fill it from the end going backwards.\\n\\n2. Then you just loop through two arrays in one loop multiplying the value before ith element and after ith element. The first multiplier should be, for example, (i-1) and the second multiplier should be (i+1). For the out of range cases for i-1 and i+1 you should set it equal to 1, so it does not affect the multiplication.\\n\\nI hope it helps and I managed to explain my solution.\\n"
                    },
                    {
                        "username": "ravi_dtu2020",
                        "content": " class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n       int n=nums.size();\n        vector<int>left(n,1);\n        vector<int>right(n,1);\n        vector<int>ans(n,1);\n        \n        int p=1;\n          for(int i=0;i<n;i++){\n            left[i]=p;\n              p=p*nums[i];\n          }\n           p=1;\n           for(int i=n-1;i>=0;i--){\n             right[i]=p;\n               p=p*nums[i];\n            }\n           for(int i=0;i<n;i++){\n               ans[i]=left[i]*right[i];\n           }\n\n      return ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Fantastic!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gauravsharma8234",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        //multiply left\\n        int[] left=new int[nums.length];\\n        int[] right=new int[nums.length];\\n        int[] answer=new int[nums.length]; \\n        left[0]=1;\\n        right[nums.length-1]=1;\\n        for(int i=1;i<=nums.length-1;i++){\\n            left[i]=left[i-1]*nums[i-1];\\n        }\\n        for(int j=nums.length-2;j>=0;j--){\\n            right[j]=right[j+1]*nums[j+1];\\n        } \\n        for(int a=0;a<=nums.length-1;a++){\\n            answer[a]=left[a]*right[a];\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "peterzengcc",
                        "content": "I doubt if there\\'s any point if we\\'re actually allocating O(n) for the answer, but treating it as O(1). "
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    }
                ]
            },
            {
                "id": 1798130,
                "content": [
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error????"
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n      int n = nums.length;\\n      int mul=0;\\n      int count=0;\\n      int[] ans = new int[n];\\n      for(int i=0;i<n;i++){\\n          if(nums[i]!=0){\\n              if(mul==0){\\n                  mul = nums[i];\\n              }else{\\n                  mul = mul*nums[i];\\n              }\\n          }else{\\n              count++;\\n          }\\n      }\\n      if(count==0){\\n          for(int i=0;i<n;i++){\\n              ans[i]=mul/nums[i];\\n          }\\n          return ans;\\n      }\\n      else if(count==1){\\n          for(int i=0;i<n;i++){\\n              if(nums[i]==0){\\n                  ans[i]=mul;\\n              }\\n              else{\\n                  ans[i]=0;\\n              }\\n          }\\n          return ans;\\n      }\\n      else{\\n          for(int i=0;i<n;i++){\\n              ans[i]=0;\\n          }\\n          return ans;\\n      }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "KedarP5",
                        "content": "class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) \\n    {\\n        \\tint iArraySize = nums.size();\\n\\tvector<int> vResult(iArraySize);\\n\\n\\tvResult.at(0) = 1;\\n\\n\\tfor (int i = 1; i < iArraySize; i++)\\n\\t{\\n\\t\\tvResult.at(i) = vResult.at(i - 1)*nums.at(i - 1);\\n\\t}\\n\\n\\tint iLastVal = 1;\\n\\n\\tfor (int i = iArraySize - 1; i >= 0; i--)\\n\\t{\\n\\t\\tvResult.at(i) *=iLastVal;\\n\\t\\tiLastVal *= nums.at(i);\\n\\t}\\n\\n\\treturn vResult;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jeevananthan1712",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] answer = new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++){\\n                answer[i] = 1;\\n            if(i==0){\\n                for(int j=i+1;j<nums.length;j++){\\n                    answer[i] *= nums[j];\\n                    // System.out.println(answer[i]);              \\n                }\\n            }\\n            else{\\n                for(int j=i-1;j>=0;j--){\\n                     answer[i] *= nums[j];\\n                    // System.out.println(answer[i]+\"j\"); \\n                }\\n                    for(int k=i+1;k<nums.length;k++){\\n                        answer[i] *= nums[k];\\n                    // System.out.println(answer[i]+\"k\"); \\n                    }\\n            }\\n        }\\n    \\n        System.out.println(Arrays.toString(answer));\\n        return answer;\\n    }\\n}\\n\\n\\n......................................\\nI wrote this program and i think it is correct but for input lyk testCaseNo:18,it\\'s showing wrong...What did i do wrong??Any Suggestions??"
                    },
                    {
                        "username": "madfcat",
                        "content": "My idea is to calculate the product of the elements before the ith element and the product of all the elements after the ith element. And then to multiply these two products. But how can we get it for each `nums` element?\\n\\nMy approach:\\n\\n1. Loop through `nums` array from the beginning to the end creating 2 new arrays:\\n\\n   first array, where each element equals to the product of all the previous elements of `nums` before current index. Each current element is a multiplier of current `nums` element and one that you pushed to this \"first array: in the previous iteration. You can for example set `prev` variable to equal current in the end of the loop. And the use it in the next calculation of the current product in the next iteration.\\n\\n   second array should be the the products but going backwards from the last element of the `nums` array. So, it should be length of `nums` subtracting the current index. And you have to fill the second array starting from the very last element as well (its index is `nums` length minus 1). So, it\\'s like you have an empty array and fill it from the end going backwards.\\n\\n2. Then you just loop through two arrays in one loop multiplying the value before ith element and after ith element. The first multiplier should be, for example, (i-1) and the second multiplier should be (i+1). For the out of range cases for i-1 and i+1 you should set it equal to 1, so it does not affect the multiplication.\\n\\nI hope it helps and I managed to explain my solution.\\n"
                    },
                    {
                        "username": "ravi_dtu2020",
                        "content": " class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n       int n=nums.size();\n        vector<int>left(n,1);\n        vector<int>right(n,1);\n        vector<int>ans(n,1);\n        \n        int p=1;\n          for(int i=0;i<n;i++){\n            left[i]=p;\n              p=p*nums[i];\n          }\n           p=1;\n           for(int i=n-1;i>=0;i--){\n             right[i]=p;\n               p=p*nums[i];\n            }\n           for(int i=0;i<n;i++){\n               ans[i]=left[i]*right[i];\n           }\n\n      return ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Fantastic!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gauravsharma8234",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        //multiply left\\n        int[] left=new int[nums.length];\\n        int[] right=new int[nums.length];\\n        int[] answer=new int[nums.length]; \\n        left[0]=1;\\n        right[nums.length-1]=1;\\n        for(int i=1;i<=nums.length-1;i++){\\n            left[i]=left[i-1]*nums[i-1];\\n        }\\n        for(int j=nums.length-2;j>=0;j--){\\n            right[j]=right[j+1]*nums[j+1];\\n        } \\n        for(int a=0;a<=nums.length-1;a++){\\n            answer[a]=left[a]*right[a];\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "peterzengcc",
                        "content": "I doubt if there\\'s any point if we\\'re actually allocating O(n) for the answer, but treating it as O(1). "
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    }
                ]
            },
            {
                "id": 1796136,
                "content": [
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error????"
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n      int n = nums.length;\\n      int mul=0;\\n      int count=0;\\n      int[] ans = new int[n];\\n      for(int i=0;i<n;i++){\\n          if(nums[i]!=0){\\n              if(mul==0){\\n                  mul = nums[i];\\n              }else{\\n                  mul = mul*nums[i];\\n              }\\n          }else{\\n              count++;\\n          }\\n      }\\n      if(count==0){\\n          for(int i=0;i<n;i++){\\n              ans[i]=mul/nums[i];\\n          }\\n          return ans;\\n      }\\n      else if(count==1){\\n          for(int i=0;i<n;i++){\\n              if(nums[i]==0){\\n                  ans[i]=mul;\\n              }\\n              else{\\n                  ans[i]=0;\\n              }\\n          }\\n          return ans;\\n      }\\n      else{\\n          for(int i=0;i<n;i++){\\n              ans[i]=0;\\n          }\\n          return ans;\\n      }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "KedarP5",
                        "content": "class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) \\n    {\\n        \\tint iArraySize = nums.size();\\n\\tvector<int> vResult(iArraySize);\\n\\n\\tvResult.at(0) = 1;\\n\\n\\tfor (int i = 1; i < iArraySize; i++)\\n\\t{\\n\\t\\tvResult.at(i) = vResult.at(i - 1)*nums.at(i - 1);\\n\\t}\\n\\n\\tint iLastVal = 1;\\n\\n\\tfor (int i = iArraySize - 1; i >= 0; i--)\\n\\t{\\n\\t\\tvResult.at(i) *=iLastVal;\\n\\t\\tiLastVal *= nums.at(i);\\n\\t}\\n\\n\\treturn vResult;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jeevananthan1712",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] answer = new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++){\\n                answer[i] = 1;\\n            if(i==0){\\n                for(int j=i+1;j<nums.length;j++){\\n                    answer[i] *= nums[j];\\n                    // System.out.println(answer[i]);              \\n                }\\n            }\\n            else{\\n                for(int j=i-1;j>=0;j--){\\n                     answer[i] *= nums[j];\\n                    // System.out.println(answer[i]+\"j\"); \\n                }\\n                    for(int k=i+1;k<nums.length;k++){\\n                        answer[i] *= nums[k];\\n                    // System.out.println(answer[i]+\"k\"); \\n                    }\\n            }\\n        }\\n    \\n        System.out.println(Arrays.toString(answer));\\n        return answer;\\n    }\\n}\\n\\n\\n......................................\\nI wrote this program and i think it is correct but for input lyk testCaseNo:18,it\\'s showing wrong...What did i do wrong??Any Suggestions??"
                    },
                    {
                        "username": "madfcat",
                        "content": "My idea is to calculate the product of the elements before the ith element and the product of all the elements after the ith element. And then to multiply these two products. But how can we get it for each `nums` element?\\n\\nMy approach:\\n\\n1. Loop through `nums` array from the beginning to the end creating 2 new arrays:\\n\\n   first array, where each element equals to the product of all the previous elements of `nums` before current index. Each current element is a multiplier of current `nums` element and one that you pushed to this \"first array: in the previous iteration. You can for example set `prev` variable to equal current in the end of the loop. And the use it in the next calculation of the current product in the next iteration.\\n\\n   second array should be the the products but going backwards from the last element of the `nums` array. So, it should be length of `nums` subtracting the current index. And you have to fill the second array starting from the very last element as well (its index is `nums` length minus 1). So, it\\'s like you have an empty array and fill it from the end going backwards.\\n\\n2. Then you just loop through two arrays in one loop multiplying the value before ith element and after ith element. The first multiplier should be, for example, (i-1) and the second multiplier should be (i+1). For the out of range cases for i-1 and i+1 you should set it equal to 1, so it does not affect the multiplication.\\n\\nI hope it helps and I managed to explain my solution.\\n"
                    },
                    {
                        "username": "ravi_dtu2020",
                        "content": " class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n       int n=nums.size();\n        vector<int>left(n,1);\n        vector<int>right(n,1);\n        vector<int>ans(n,1);\n        \n        int p=1;\n          for(int i=0;i<n;i++){\n            left[i]=p;\n              p=p*nums[i];\n          }\n           p=1;\n           for(int i=n-1;i>=0;i--){\n             right[i]=p;\n               p=p*nums[i];\n            }\n           for(int i=0;i<n;i++){\n               ans[i]=left[i]*right[i];\n           }\n\n      return ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Fantastic!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gauravsharma8234",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        //multiply left\\n        int[] left=new int[nums.length];\\n        int[] right=new int[nums.length];\\n        int[] answer=new int[nums.length]; \\n        left[0]=1;\\n        right[nums.length-1]=1;\\n        for(int i=1;i<=nums.length-1;i++){\\n            left[i]=left[i-1]*nums[i-1];\\n        }\\n        for(int j=nums.length-2;j>=0;j--){\\n            right[j]=right[j+1]*nums[j+1];\\n        } \\n        for(int a=0;a<=nums.length-1;a++){\\n            answer[a]=left[a]*right[a];\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "peterzengcc",
                        "content": "I doubt if there\\'s any point if we\\'re actually allocating O(n) for the answer, but treating it as O(1). "
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    }
                ]
            },
            {
                "id": 1794698,
                "content": [
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error????"
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n      int n = nums.length;\\n      int mul=0;\\n      int count=0;\\n      int[] ans = new int[n];\\n      for(int i=0;i<n;i++){\\n          if(nums[i]!=0){\\n              if(mul==0){\\n                  mul = nums[i];\\n              }else{\\n                  mul = mul*nums[i];\\n              }\\n          }else{\\n              count++;\\n          }\\n      }\\n      if(count==0){\\n          for(int i=0;i<n;i++){\\n              ans[i]=mul/nums[i];\\n          }\\n          return ans;\\n      }\\n      else if(count==1){\\n          for(int i=0;i<n;i++){\\n              if(nums[i]==0){\\n                  ans[i]=mul;\\n              }\\n              else{\\n                  ans[i]=0;\\n              }\\n          }\\n          return ans;\\n      }\\n      else{\\n          for(int i=0;i<n;i++){\\n              ans[i]=0;\\n          }\\n          return ans;\\n      }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "KedarP5",
                        "content": "class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) \\n    {\\n        \\tint iArraySize = nums.size();\\n\\tvector<int> vResult(iArraySize);\\n\\n\\tvResult.at(0) = 1;\\n\\n\\tfor (int i = 1; i < iArraySize; i++)\\n\\t{\\n\\t\\tvResult.at(i) = vResult.at(i - 1)*nums.at(i - 1);\\n\\t}\\n\\n\\tint iLastVal = 1;\\n\\n\\tfor (int i = iArraySize - 1; i >= 0; i--)\\n\\t{\\n\\t\\tvResult.at(i) *=iLastVal;\\n\\t\\tiLastVal *= nums.at(i);\\n\\t}\\n\\n\\treturn vResult;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jeevananthan1712",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] answer = new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++){\\n                answer[i] = 1;\\n            if(i==0){\\n                for(int j=i+1;j<nums.length;j++){\\n                    answer[i] *= nums[j];\\n                    // System.out.println(answer[i]);              \\n                }\\n            }\\n            else{\\n                for(int j=i-1;j>=0;j--){\\n                     answer[i] *= nums[j];\\n                    // System.out.println(answer[i]+\"j\"); \\n                }\\n                    for(int k=i+1;k<nums.length;k++){\\n                        answer[i] *= nums[k];\\n                    // System.out.println(answer[i]+\"k\"); \\n                    }\\n            }\\n        }\\n    \\n        System.out.println(Arrays.toString(answer));\\n        return answer;\\n    }\\n}\\n\\n\\n......................................\\nI wrote this program and i think it is correct but for input lyk testCaseNo:18,it\\'s showing wrong...What did i do wrong??Any Suggestions??"
                    },
                    {
                        "username": "madfcat",
                        "content": "My idea is to calculate the product of the elements before the ith element and the product of all the elements after the ith element. And then to multiply these two products. But how can we get it for each `nums` element?\\n\\nMy approach:\\n\\n1. Loop through `nums` array from the beginning to the end creating 2 new arrays:\\n\\n   first array, where each element equals to the product of all the previous elements of `nums` before current index. Each current element is a multiplier of current `nums` element and one that you pushed to this \"first array: in the previous iteration. You can for example set `prev` variable to equal current in the end of the loop. And the use it in the next calculation of the current product in the next iteration.\\n\\n   second array should be the the products but going backwards from the last element of the `nums` array. So, it should be length of `nums` subtracting the current index. And you have to fill the second array starting from the very last element as well (its index is `nums` length minus 1). So, it\\'s like you have an empty array and fill it from the end going backwards.\\n\\n2. Then you just loop through two arrays in one loop multiplying the value before ith element and after ith element. The first multiplier should be, for example, (i-1) and the second multiplier should be (i+1). For the out of range cases for i-1 and i+1 you should set it equal to 1, so it does not affect the multiplication.\\n\\nI hope it helps and I managed to explain my solution.\\n"
                    },
                    {
                        "username": "ravi_dtu2020",
                        "content": " class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n       int n=nums.size();\n        vector<int>left(n,1);\n        vector<int>right(n,1);\n        vector<int>ans(n,1);\n        \n        int p=1;\n          for(int i=0;i<n;i++){\n            left[i]=p;\n              p=p*nums[i];\n          }\n           p=1;\n           for(int i=n-1;i>=0;i--){\n             right[i]=p;\n               p=p*nums[i];\n            }\n           for(int i=0;i<n;i++){\n               ans[i]=left[i]*right[i];\n           }\n\n      return ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Fantastic!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gauravsharma8234",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        //multiply left\\n        int[] left=new int[nums.length];\\n        int[] right=new int[nums.length];\\n        int[] answer=new int[nums.length]; \\n        left[0]=1;\\n        right[nums.length-1]=1;\\n        for(int i=1;i<=nums.length-1;i++){\\n            left[i]=left[i-1]*nums[i-1];\\n        }\\n        for(int j=nums.length-2;j>=0;j--){\\n            right[j]=right[j+1]*nums[j+1];\\n        } \\n        for(int a=0;a<=nums.length-1;a++){\\n            answer[a]=left[a]*right[a];\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "peterzengcc",
                        "content": "I doubt if there\\'s any point if we\\'re actually allocating O(n) for the answer, but treating it as O(1). "
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    }
                ]
            },
            {
                "id": 1794121,
                "content": [
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error????"
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n      int n = nums.length;\\n      int mul=0;\\n      int count=0;\\n      int[] ans = new int[n];\\n      for(int i=0;i<n;i++){\\n          if(nums[i]!=0){\\n              if(mul==0){\\n                  mul = nums[i];\\n              }else{\\n                  mul = mul*nums[i];\\n              }\\n          }else{\\n              count++;\\n          }\\n      }\\n      if(count==0){\\n          for(int i=0;i<n;i++){\\n              ans[i]=mul/nums[i];\\n          }\\n          return ans;\\n      }\\n      else if(count==1){\\n          for(int i=0;i<n;i++){\\n              if(nums[i]==0){\\n                  ans[i]=mul;\\n              }\\n              else{\\n                  ans[i]=0;\\n              }\\n          }\\n          return ans;\\n      }\\n      else{\\n          for(int i=0;i<n;i++){\\n              ans[i]=0;\\n          }\\n          return ans;\\n      }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "KedarP5",
                        "content": "class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) \\n    {\\n        \\tint iArraySize = nums.size();\\n\\tvector<int> vResult(iArraySize);\\n\\n\\tvResult.at(0) = 1;\\n\\n\\tfor (int i = 1; i < iArraySize; i++)\\n\\t{\\n\\t\\tvResult.at(i) = vResult.at(i - 1)*nums.at(i - 1);\\n\\t}\\n\\n\\tint iLastVal = 1;\\n\\n\\tfor (int i = iArraySize - 1; i >= 0; i--)\\n\\t{\\n\\t\\tvResult.at(i) *=iLastVal;\\n\\t\\tiLastVal *= nums.at(i);\\n\\t}\\n\\n\\treturn vResult;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jeevananthan1712",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] answer = new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++){\\n                answer[i] = 1;\\n            if(i==0){\\n                for(int j=i+1;j<nums.length;j++){\\n                    answer[i] *= nums[j];\\n                    // System.out.println(answer[i]);              \\n                }\\n            }\\n            else{\\n                for(int j=i-1;j>=0;j--){\\n                     answer[i] *= nums[j];\\n                    // System.out.println(answer[i]+\"j\"); \\n                }\\n                    for(int k=i+1;k<nums.length;k++){\\n                        answer[i] *= nums[k];\\n                    // System.out.println(answer[i]+\"k\"); \\n                    }\\n            }\\n        }\\n    \\n        System.out.println(Arrays.toString(answer));\\n        return answer;\\n    }\\n}\\n\\n\\n......................................\\nI wrote this program and i think it is correct but for input lyk testCaseNo:18,it\\'s showing wrong...What did i do wrong??Any Suggestions??"
                    },
                    {
                        "username": "madfcat",
                        "content": "My idea is to calculate the product of the elements before the ith element and the product of all the elements after the ith element. And then to multiply these two products. But how can we get it for each `nums` element?\\n\\nMy approach:\\n\\n1. Loop through `nums` array from the beginning to the end creating 2 new arrays:\\n\\n   first array, where each element equals to the product of all the previous elements of `nums` before current index. Each current element is a multiplier of current `nums` element and one that you pushed to this \"first array: in the previous iteration. You can for example set `prev` variable to equal current in the end of the loop. And the use it in the next calculation of the current product in the next iteration.\\n\\n   second array should be the the products but going backwards from the last element of the `nums` array. So, it should be length of `nums` subtracting the current index. And you have to fill the second array starting from the very last element as well (its index is `nums` length minus 1). So, it\\'s like you have an empty array and fill it from the end going backwards.\\n\\n2. Then you just loop through two arrays in one loop multiplying the value before ith element and after ith element. The first multiplier should be, for example, (i-1) and the second multiplier should be (i+1). For the out of range cases for i-1 and i+1 you should set it equal to 1, so it does not affect the multiplication.\\n\\nI hope it helps and I managed to explain my solution.\\n"
                    },
                    {
                        "username": "ravi_dtu2020",
                        "content": " class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n       int n=nums.size();\n        vector<int>left(n,1);\n        vector<int>right(n,1);\n        vector<int>ans(n,1);\n        \n        int p=1;\n          for(int i=0;i<n;i++){\n            left[i]=p;\n              p=p*nums[i];\n          }\n           p=1;\n           for(int i=n-1;i>=0;i--){\n             right[i]=p;\n               p=p*nums[i];\n            }\n           for(int i=0;i<n;i++){\n               ans[i]=left[i]*right[i];\n           }\n\n      return ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Fantastic!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gauravsharma8234",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        //multiply left\\n        int[] left=new int[nums.length];\\n        int[] right=new int[nums.length];\\n        int[] answer=new int[nums.length]; \\n        left[0]=1;\\n        right[nums.length-1]=1;\\n        for(int i=1;i<=nums.length-1;i++){\\n            left[i]=left[i-1]*nums[i-1];\\n        }\\n        for(int j=nums.length-2;j>=0;j--){\\n            right[j]=right[j+1]*nums[j+1];\\n        } \\n        for(int a=0;a<=nums.length-1;a++){\\n            answer[a]=left[a]*right[a];\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "peterzengcc",
                        "content": "I doubt if there\\'s any point if we\\'re actually allocating O(n) for the answer, but treating it as O(1). "
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    }
                ]
            },
            {
                "id": 1793523,
                "content": [
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error????"
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n      int n = nums.length;\\n      int mul=0;\\n      int count=0;\\n      int[] ans = new int[n];\\n      for(int i=0;i<n;i++){\\n          if(nums[i]!=0){\\n              if(mul==0){\\n                  mul = nums[i];\\n              }else{\\n                  mul = mul*nums[i];\\n              }\\n          }else{\\n              count++;\\n          }\\n      }\\n      if(count==0){\\n          for(int i=0;i<n;i++){\\n              ans[i]=mul/nums[i];\\n          }\\n          return ans;\\n      }\\n      else if(count==1){\\n          for(int i=0;i<n;i++){\\n              if(nums[i]==0){\\n                  ans[i]=mul;\\n              }\\n              else{\\n                  ans[i]=0;\\n              }\\n          }\\n          return ans;\\n      }\\n      else{\\n          for(int i=0;i<n;i++){\\n              ans[i]=0;\\n          }\\n          return ans;\\n      }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "KedarP5",
                        "content": "class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) \\n    {\\n        \\tint iArraySize = nums.size();\\n\\tvector<int> vResult(iArraySize);\\n\\n\\tvResult.at(0) = 1;\\n\\n\\tfor (int i = 1; i < iArraySize; i++)\\n\\t{\\n\\t\\tvResult.at(i) = vResult.at(i - 1)*nums.at(i - 1);\\n\\t}\\n\\n\\tint iLastVal = 1;\\n\\n\\tfor (int i = iArraySize - 1; i >= 0; i--)\\n\\t{\\n\\t\\tvResult.at(i) *=iLastVal;\\n\\t\\tiLastVal *= nums.at(i);\\n\\t}\\n\\n\\treturn vResult;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jeevananthan1712",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] answer = new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++){\\n                answer[i] = 1;\\n            if(i==0){\\n                for(int j=i+1;j<nums.length;j++){\\n                    answer[i] *= nums[j];\\n                    // System.out.println(answer[i]);              \\n                }\\n            }\\n            else{\\n                for(int j=i-1;j>=0;j--){\\n                     answer[i] *= nums[j];\\n                    // System.out.println(answer[i]+\"j\"); \\n                }\\n                    for(int k=i+1;k<nums.length;k++){\\n                        answer[i] *= nums[k];\\n                    // System.out.println(answer[i]+\"k\"); \\n                    }\\n            }\\n        }\\n    \\n        System.out.println(Arrays.toString(answer));\\n        return answer;\\n    }\\n}\\n\\n\\n......................................\\nI wrote this program and i think it is correct but for input lyk testCaseNo:18,it\\'s showing wrong...What did i do wrong??Any Suggestions??"
                    },
                    {
                        "username": "madfcat",
                        "content": "My idea is to calculate the product of the elements before the ith element and the product of all the elements after the ith element. And then to multiply these two products. But how can we get it for each `nums` element?\\n\\nMy approach:\\n\\n1. Loop through `nums` array from the beginning to the end creating 2 new arrays:\\n\\n   first array, where each element equals to the product of all the previous elements of `nums` before current index. Each current element is a multiplier of current `nums` element and one that you pushed to this \"first array: in the previous iteration. You can for example set `prev` variable to equal current in the end of the loop. And the use it in the next calculation of the current product in the next iteration.\\n\\n   second array should be the the products but going backwards from the last element of the `nums` array. So, it should be length of `nums` subtracting the current index. And you have to fill the second array starting from the very last element as well (its index is `nums` length minus 1). So, it\\'s like you have an empty array and fill it from the end going backwards.\\n\\n2. Then you just loop through two arrays in one loop multiplying the value before ith element and after ith element. The first multiplier should be, for example, (i-1) and the second multiplier should be (i+1). For the out of range cases for i-1 and i+1 you should set it equal to 1, so it does not affect the multiplication.\\n\\nI hope it helps and I managed to explain my solution.\\n"
                    },
                    {
                        "username": "ravi_dtu2020",
                        "content": " class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n       int n=nums.size();\n        vector<int>left(n,1);\n        vector<int>right(n,1);\n        vector<int>ans(n,1);\n        \n        int p=1;\n          for(int i=0;i<n;i++){\n            left[i]=p;\n              p=p*nums[i];\n          }\n           p=1;\n           for(int i=n-1;i>=0;i--){\n             right[i]=p;\n               p=p*nums[i];\n            }\n           for(int i=0;i<n;i++){\n               ans[i]=left[i]*right[i];\n           }\n\n      return ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Fantastic!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gauravsharma8234",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        //multiply left\\n        int[] left=new int[nums.length];\\n        int[] right=new int[nums.length];\\n        int[] answer=new int[nums.length]; \\n        left[0]=1;\\n        right[nums.length-1]=1;\\n        for(int i=1;i<=nums.length-1;i++){\\n            left[i]=left[i-1]*nums[i-1];\\n        }\\n        for(int j=nums.length-2;j>=0;j--){\\n            right[j]=right[j+1]*nums[j+1];\\n        } \\n        for(int a=0;a<=nums.length-1;a++){\\n            answer[a]=left[a]*right[a];\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "peterzengcc",
                        "content": "I doubt if there\\'s any point if we\\'re actually allocating O(n) for the answer, but treating it as O(1). "
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    }
                ]
            },
            {
                "id": 1793514,
                "content": [
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error????"
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n      int n = nums.length;\\n      int mul=0;\\n      int count=0;\\n      int[] ans = new int[n];\\n      for(int i=0;i<n;i++){\\n          if(nums[i]!=0){\\n              if(mul==0){\\n                  mul = nums[i];\\n              }else{\\n                  mul = mul*nums[i];\\n              }\\n          }else{\\n              count++;\\n          }\\n      }\\n      if(count==0){\\n          for(int i=0;i<n;i++){\\n              ans[i]=mul/nums[i];\\n          }\\n          return ans;\\n      }\\n      else if(count==1){\\n          for(int i=0;i<n;i++){\\n              if(nums[i]==0){\\n                  ans[i]=mul;\\n              }\\n              else{\\n                  ans[i]=0;\\n              }\\n          }\\n          return ans;\\n      }\\n      else{\\n          for(int i=0;i<n;i++){\\n              ans[i]=0;\\n          }\\n          return ans;\\n      }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "KedarP5",
                        "content": "class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) \\n    {\\n        \\tint iArraySize = nums.size();\\n\\tvector<int> vResult(iArraySize);\\n\\n\\tvResult.at(0) = 1;\\n\\n\\tfor (int i = 1; i < iArraySize; i++)\\n\\t{\\n\\t\\tvResult.at(i) = vResult.at(i - 1)*nums.at(i - 1);\\n\\t}\\n\\n\\tint iLastVal = 1;\\n\\n\\tfor (int i = iArraySize - 1; i >= 0; i--)\\n\\t{\\n\\t\\tvResult.at(i) *=iLastVal;\\n\\t\\tiLastVal *= nums.at(i);\\n\\t}\\n\\n\\treturn vResult;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jeevananthan1712",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] answer = new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++){\\n                answer[i] = 1;\\n            if(i==0){\\n                for(int j=i+1;j<nums.length;j++){\\n                    answer[i] *= nums[j];\\n                    // System.out.println(answer[i]);              \\n                }\\n            }\\n            else{\\n                for(int j=i-1;j>=0;j--){\\n                     answer[i] *= nums[j];\\n                    // System.out.println(answer[i]+\"j\"); \\n                }\\n                    for(int k=i+1;k<nums.length;k++){\\n                        answer[i] *= nums[k];\\n                    // System.out.println(answer[i]+\"k\"); \\n                    }\\n            }\\n        }\\n    \\n        System.out.println(Arrays.toString(answer));\\n        return answer;\\n    }\\n}\\n\\n\\n......................................\\nI wrote this program and i think it is correct but for input lyk testCaseNo:18,it\\'s showing wrong...What did i do wrong??Any Suggestions??"
                    },
                    {
                        "username": "madfcat",
                        "content": "My idea is to calculate the product of the elements before the ith element and the product of all the elements after the ith element. And then to multiply these two products. But how can we get it for each `nums` element?\\n\\nMy approach:\\n\\n1. Loop through `nums` array from the beginning to the end creating 2 new arrays:\\n\\n   first array, where each element equals to the product of all the previous elements of `nums` before current index. Each current element is a multiplier of current `nums` element and one that you pushed to this \"first array: in the previous iteration. You can for example set `prev` variable to equal current in the end of the loop. And the use it in the next calculation of the current product in the next iteration.\\n\\n   second array should be the the products but going backwards from the last element of the `nums` array. So, it should be length of `nums` subtracting the current index. And you have to fill the second array starting from the very last element as well (its index is `nums` length minus 1). So, it\\'s like you have an empty array and fill it from the end going backwards.\\n\\n2. Then you just loop through two arrays in one loop multiplying the value before ith element and after ith element. The first multiplier should be, for example, (i-1) and the second multiplier should be (i+1). For the out of range cases for i-1 and i+1 you should set it equal to 1, so it does not affect the multiplication.\\n\\nI hope it helps and I managed to explain my solution.\\n"
                    },
                    {
                        "username": "ravi_dtu2020",
                        "content": " class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n       int n=nums.size();\n        vector<int>left(n,1);\n        vector<int>right(n,1);\n        vector<int>ans(n,1);\n        \n        int p=1;\n          for(int i=0;i<n;i++){\n            left[i]=p;\n              p=p*nums[i];\n          }\n           p=1;\n           for(int i=n-1;i>=0;i--){\n             right[i]=p;\n               p=p*nums[i];\n            }\n           for(int i=0;i<n;i++){\n               ans[i]=left[i]*right[i];\n           }\n\n      return ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Fantastic!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gauravsharma8234",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        //multiply left\\n        int[] left=new int[nums.length];\\n        int[] right=new int[nums.length];\\n        int[] answer=new int[nums.length]; \\n        left[0]=1;\\n        right[nums.length-1]=1;\\n        for(int i=1;i<=nums.length-1;i++){\\n            left[i]=left[i-1]*nums[i-1];\\n        }\\n        for(int j=nums.length-2;j>=0;j--){\\n            right[j]=right[j+1]*nums[j+1];\\n        } \\n        for(int a=0;a<=nums.length-1;a++){\\n            answer[a]=left[a]*right[a];\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "peterzengcc",
                        "content": "I doubt if there\\'s any point if we\\'re actually allocating O(n) for the answer, but treating it as O(1). "
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    }
                ]
            },
            {
                "id": 1793511,
                "content": [
                    {
                        "username": "asseralazarcoder",
                        "content": "why is there an error????"
                    },
                    {
                        "username": "Yash_kumbhawat",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n      int n = nums.length;\\n      int mul=0;\\n      int count=0;\\n      int[] ans = new int[n];\\n      for(int i=0;i<n;i++){\\n          if(nums[i]!=0){\\n              if(mul==0){\\n                  mul = nums[i];\\n              }else{\\n                  mul = mul*nums[i];\\n              }\\n          }else{\\n              count++;\\n          }\\n      }\\n      if(count==0){\\n          for(int i=0;i<n;i++){\\n              ans[i]=mul/nums[i];\\n          }\\n          return ans;\\n      }\\n      else if(count==1){\\n          for(int i=0;i<n;i++){\\n              if(nums[i]==0){\\n                  ans[i]=mul;\\n              }\\n              else{\\n                  ans[i]=0;\\n              }\\n          }\\n          return ans;\\n      }\\n      else{\\n          for(int i=0;i<n;i++){\\n              ans[i]=0;\\n          }\\n          return ans;\\n      }\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "KedarP5",
                        "content": "class Solution {\\npublic:\\n    vector<int> productExceptSelf(vector<int>& nums) \\n    {\\n        \\tint iArraySize = nums.size();\\n\\tvector<int> vResult(iArraySize);\\n\\n\\tvResult.at(0) = 1;\\n\\n\\tfor (int i = 1; i < iArraySize; i++)\\n\\t{\\n\\t\\tvResult.at(i) = vResult.at(i - 1)*nums.at(i - 1);\\n\\t}\\n\\n\\tint iLastVal = 1;\\n\\n\\tfor (int i = iArraySize - 1; i >= 0; i--)\\n\\t{\\n\\t\\tvResult.at(i) *=iLastVal;\\n\\t\\tiLastVal *= nums.at(i);\\n\\t}\\n\\n\\treturn vResult;\\n    }\\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Jeevananthan1712",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        int[] answer = new int[nums.length];\\n        \\n        for(int i=0;i<nums.length;i++){\\n                answer[i] = 1;\\n            if(i==0){\\n                for(int j=i+1;j<nums.length;j++){\\n                    answer[i] *= nums[j];\\n                    // System.out.println(answer[i]);              \\n                }\\n            }\\n            else{\\n                for(int j=i-1;j>=0;j--){\\n                     answer[i] *= nums[j];\\n                    // System.out.println(answer[i]+\"j\"); \\n                }\\n                    for(int k=i+1;k<nums.length;k++){\\n                        answer[i] *= nums[k];\\n                    // System.out.println(answer[i]+\"k\"); \\n                    }\\n            }\\n        }\\n    \\n        System.out.println(Arrays.toString(answer));\\n        return answer;\\n    }\\n}\\n\\n\\n......................................\\nI wrote this program and i think it is correct but for input lyk testCaseNo:18,it\\'s showing wrong...What did i do wrong??Any Suggestions??"
                    },
                    {
                        "username": "madfcat",
                        "content": "My idea is to calculate the product of the elements before the ith element and the product of all the elements after the ith element. And then to multiply these two products. But how can we get it for each `nums` element?\\n\\nMy approach:\\n\\n1. Loop through `nums` array from the beginning to the end creating 2 new arrays:\\n\\n   first array, where each element equals to the product of all the previous elements of `nums` before current index. Each current element is a multiplier of current `nums` element and one that you pushed to this \"first array: in the previous iteration. You can for example set `prev` variable to equal current in the end of the loop. And the use it in the next calculation of the current product in the next iteration.\\n\\n   second array should be the the products but going backwards from the last element of the `nums` array. So, it should be length of `nums` subtracting the current index. And you have to fill the second array starting from the very last element as well (its index is `nums` length minus 1). So, it\\'s like you have an empty array and fill it from the end going backwards.\\n\\n2. Then you just loop through two arrays in one loop multiplying the value before ith element and after ith element. The first multiplier should be, for example, (i-1) and the second multiplier should be (i+1). For the out of range cases for i-1 and i+1 you should set it equal to 1, so it does not affect the multiplication.\\n\\nI hope it helps and I managed to explain my solution.\\n"
                    },
                    {
                        "username": "ravi_dtu2020",
                        "content": " class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n       int n=nums.size();\n        vector<int>left(n,1);\n        vector<int>right(n,1);\n        vector<int>ans(n,1);\n        \n        int p=1;\n          for(int i=0;i<n;i++){\n            left[i]=p;\n              p=p*nums[i];\n          }\n           p=1;\n           for(int i=n-1;i>=0;i--){\n             right[i]=p;\n               p=p*nums[i];\n            }\n           for(int i=0;i<n;i++){\n               ans[i]=left[i]*right[i];\n           }\n\n      return ans;\n\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Fantastic!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "gauravsharma8234",
                        "content": "class Solution {\\n    public int[] productExceptSelf(int[] nums) {\\n        //multiply left\\n        int[] left=new int[nums.length];\\n        int[] right=new int[nums.length];\\n        int[] answer=new int[nums.length]; \\n        left[0]=1;\\n        right[nums.length-1]=1;\\n        for(int i=1;i<=nums.length-1;i++){\\n            left[i]=left[i-1]*nums[i-1];\\n        }\\n        for(int j=nums.length-2;j>=0;j--){\\n            right[j]=right[j+1]*nums[j+1];\\n        } \\n        for(int a=0;a<=nums.length-1;a++){\\n            answer[a]=left[a]*right[a];\\n        }\\n        return answer;\\n    }\\n}"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Amazing!\\nBut lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "peterzengcc",
                        "content": "I doubt if there\\'s any point if we\\'re actually allocating O(n) for the answer, but treating it as O(1). "
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "If you want to solve it in O(n) time and space complexity there is some tips: \\n1)  Create an array call prefixProduct and initialize it with 1. Why? because this prefixProduct array will contain the prefixProduct of all elements in the num array. For example, prefixProduct[i] is the product of all the prefix element of nums[i], 1 is the neutral element of  multplication so it doesnt change anything...\\n\\n2) Create an array call suffixProduct  with the same logic,  except that now is for suffix element\\n3) The answer array is just a multiplication element by element of the prefix and suffix array"
                    }
                ]
            },
            {
                "id": 1793258,
                "content": [
                    {
                        "username": "kamranmemon25",
                        "content": "I dont understand why this solution does not work. I am using two loops and no division still getting the error Time limit exceeded. can someone help?\n\n```var productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "SOMANATHmikali",
                        "content": "Bro if you are using two loops the time will be o(n^2) they asked about o(n)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "```const nums = [0,0];\nvar productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "emirkk",
                        "content": "Why I cant use pow function in this question? It gives me that error:\\nLine 13: Char 14: runtime error: -nan is outside the range of representable values of type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp"
                    },
                    {
                        "username": "CatalinDum",
                        "content": "C++ Solution, O(n)\\n\\nI get the total product of all nr > 0;\\nAnd since then multiply is commutative, I can just divide the intruder.\\nPay attention if:  \\n    - we have more than 2 zeros in the array \\n    - the intruder is Zero. \\n\\nEx:  nums = [2, 3, 4]  -> Total prod = 2 * 3 * 4 \\n\\nIntruder = 2 ->    res = 2 * 3 * 4 / 2 -> 3 * 4 = 12\\nIntruder = 3 ->    res = 2 * 3 * 4 / 3 -> 2* 4 = 8\\nIntruder = 4 ->    res = 2 * 3 * 4 / 4 -> 2* 3 = 6\\n\\n\\nEx:  nums = [0, 3, 4]  -> Total prod =  3 * 4 \\n\\nIntruder = 0 ->    res =  3 * 4 = 12\\nIntruder = 3 ->    res = 0\\nIntruder = 4 ->    res = 0\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> output;\\n        int prod_total = 0; \\n        int count_zeros = 0;\\n\\n        for (auto & elem: nums)\\n        {\\n            if (elem == 0) \\n            {                \\n                count_zeros++;\\n                continue;\\n            }\\n            else if (prod_total == 0 && elem != 0)\\n                prod_total = 1;            \\n\\n            prod_total  *= elem;\\n        }\\n\\n        if (count_zeros > 1) \\n        {\\n            vector<int> sol_all_zeros(nums.size(), 0); \\n            return sol_all_zeros;\\n        }\\n       \\n        for (auto & elem: nums)\\n        {\\n            if (count_zeros > 0 && elem != 0)\\n                output.push_back(0);            \\n            else\\n            {               \\n                if (elem == 0)\\n                    output.push_back(prod_total);\\n                else\\n                    output.push_back(prod_total / elem);           \\n            }                    \\n        }\\n        return output;\\n    }\\n"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "They wanted an algorithm without division, but you use it."
                    },
                    {
                        "username": "ozans",
                        "content": "The question will be clearer if the question states answer array can be used in  O(1) space complexity in the follow-up section. Thank you for preparing the questions :)"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "My code pass all the test cases there is the idea behind my solution (in Javascript): \\n1) I initialize an empty array call answer\\n2) I use a for loop to go over all the elements in the array\\n3) Inside the for loop i define a variable call value, which is equal to the chaining of a filter and a reduce.  I use the filter to remove the current loop element from the array ( e!= nums[i]) then i use the reduce method to the product of the element in the array (at this point the array don\\'t contain nums[i])\\n\\n4)  Inside the for loop i push the element into the empty array call answer\\n5) Finally i return answer\\n\\nPS: Sorry for the english, i am not a native english speaker...\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Ayushlnct",
                        "content": "COMMON APPRACH DISCUSSION\\n#What we are doing here\\nWe are create three arrays ie. Left, Right and Ans.\\nAfter that we intiallizing Right array by in the way that each element in right array is product element right of that array in the given array.\\nSimilarly we can initiallize left array in the way that each element in left array is product of element left of it.\\nFor boundary elements like the 0th element of left array or last element of right array we can put 1 at that place.\\n ## Why we are doing it\\n Since we have created left and right which consists of product of each element left and right of it repectively. So we can intiallize our ans array in hte way such that each element in ans array is product of left array and right array. By doing so we are actually getting product of all elemets left of it and right of it which solves our problem."
                    },
                    {
                        "username": "sudesh_pawar",
                        "content": "Hint: Try storing prefix products and postfix products for each element and see how you can use them to arrive at the answer.\\nHint 2 : Answer for i\\'th element is not dependent on i\\'th prefix or postfix product. "
                    },
                    {
                        "username": "dkvern01",
                        "content": "I really liked this problem. I thought it was gonna be easy, but the inclusion of 0\\'s made me rethink the entire problem."
                    }
                ]
            },
            {
                "id": 1793256,
                "content": [
                    {
                        "username": "kamranmemon25",
                        "content": "I dont understand why this solution does not work. I am using two loops and no division still getting the error Time limit exceeded. can someone help?\n\n```var productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "SOMANATHmikali",
                        "content": "Bro if you are using two loops the time will be o(n^2) they asked about o(n)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "```const nums = [0,0];\nvar productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "emirkk",
                        "content": "Why I cant use pow function in this question? It gives me that error:\\nLine 13: Char 14: runtime error: -nan is outside the range of representable values of type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp"
                    },
                    {
                        "username": "CatalinDum",
                        "content": "C++ Solution, O(n)\\n\\nI get the total product of all nr > 0;\\nAnd since then multiply is commutative, I can just divide the intruder.\\nPay attention if:  \\n    - we have more than 2 zeros in the array \\n    - the intruder is Zero. \\n\\nEx:  nums = [2, 3, 4]  -> Total prod = 2 * 3 * 4 \\n\\nIntruder = 2 ->    res = 2 * 3 * 4 / 2 -> 3 * 4 = 12\\nIntruder = 3 ->    res = 2 * 3 * 4 / 3 -> 2* 4 = 8\\nIntruder = 4 ->    res = 2 * 3 * 4 / 4 -> 2* 3 = 6\\n\\n\\nEx:  nums = [0, 3, 4]  -> Total prod =  3 * 4 \\n\\nIntruder = 0 ->    res =  3 * 4 = 12\\nIntruder = 3 ->    res = 0\\nIntruder = 4 ->    res = 0\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> output;\\n        int prod_total = 0; \\n        int count_zeros = 0;\\n\\n        for (auto & elem: nums)\\n        {\\n            if (elem == 0) \\n            {                \\n                count_zeros++;\\n                continue;\\n            }\\n            else if (prod_total == 0 && elem != 0)\\n                prod_total = 1;            \\n\\n            prod_total  *= elem;\\n        }\\n\\n        if (count_zeros > 1) \\n        {\\n            vector<int> sol_all_zeros(nums.size(), 0); \\n            return sol_all_zeros;\\n        }\\n       \\n        for (auto & elem: nums)\\n        {\\n            if (count_zeros > 0 && elem != 0)\\n                output.push_back(0);            \\n            else\\n            {               \\n                if (elem == 0)\\n                    output.push_back(prod_total);\\n                else\\n                    output.push_back(prod_total / elem);           \\n            }                    \\n        }\\n        return output;\\n    }\\n"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "They wanted an algorithm without division, but you use it."
                    },
                    {
                        "username": "ozans",
                        "content": "The question will be clearer if the question states answer array can be used in  O(1) space complexity in the follow-up section. Thank you for preparing the questions :)"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "My code pass all the test cases there is the idea behind my solution (in Javascript): \\n1) I initialize an empty array call answer\\n2) I use a for loop to go over all the elements in the array\\n3) Inside the for loop i define a variable call value, which is equal to the chaining of a filter and a reduce.  I use the filter to remove the current loop element from the array ( e!= nums[i]) then i use the reduce method to the product of the element in the array (at this point the array don\\'t contain nums[i])\\n\\n4)  Inside the for loop i push the element into the empty array call answer\\n5) Finally i return answer\\n\\nPS: Sorry for the english, i am not a native english speaker...\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Ayushlnct",
                        "content": "COMMON APPRACH DISCUSSION\\n#What we are doing here\\nWe are create three arrays ie. Left, Right and Ans.\\nAfter that we intiallizing Right array by in the way that each element in right array is product element right of that array in the given array.\\nSimilarly we can initiallize left array in the way that each element in left array is product of element left of it.\\nFor boundary elements like the 0th element of left array or last element of right array we can put 1 at that place.\\n ## Why we are doing it\\n Since we have created left and right which consists of product of each element left and right of it repectively. So we can intiallize our ans array in hte way such that each element in ans array is product of left array and right array. By doing so we are actually getting product of all elemets left of it and right of it which solves our problem."
                    },
                    {
                        "username": "sudesh_pawar",
                        "content": "Hint: Try storing prefix products and postfix products for each element and see how you can use them to arrive at the answer.\\nHint 2 : Answer for i\\'th element is not dependent on i\\'th prefix or postfix product. "
                    },
                    {
                        "username": "dkvern01",
                        "content": "I really liked this problem. I thought it was gonna be easy, but the inclusion of 0\\'s made me rethink the entire problem."
                    }
                ]
            },
            {
                "id": 1792444,
                "content": [
                    {
                        "username": "kamranmemon25",
                        "content": "I dont understand why this solution does not work. I am using two loops and no division still getting the error Time limit exceeded. can someone help?\n\n```var productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "SOMANATHmikali",
                        "content": "Bro if you are using two loops the time will be o(n^2) they asked about o(n)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "```const nums = [0,0];\nvar productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "emirkk",
                        "content": "Why I cant use pow function in this question? It gives me that error:\\nLine 13: Char 14: runtime error: -nan is outside the range of representable values of type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp"
                    },
                    {
                        "username": "CatalinDum",
                        "content": "C++ Solution, O(n)\\n\\nI get the total product of all nr > 0;\\nAnd since then multiply is commutative, I can just divide the intruder.\\nPay attention if:  \\n    - we have more than 2 zeros in the array \\n    - the intruder is Zero. \\n\\nEx:  nums = [2, 3, 4]  -> Total prod = 2 * 3 * 4 \\n\\nIntruder = 2 ->    res = 2 * 3 * 4 / 2 -> 3 * 4 = 12\\nIntruder = 3 ->    res = 2 * 3 * 4 / 3 -> 2* 4 = 8\\nIntruder = 4 ->    res = 2 * 3 * 4 / 4 -> 2* 3 = 6\\n\\n\\nEx:  nums = [0, 3, 4]  -> Total prod =  3 * 4 \\n\\nIntruder = 0 ->    res =  3 * 4 = 12\\nIntruder = 3 ->    res = 0\\nIntruder = 4 ->    res = 0\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> output;\\n        int prod_total = 0; \\n        int count_zeros = 0;\\n\\n        for (auto & elem: nums)\\n        {\\n            if (elem == 0) \\n            {                \\n                count_zeros++;\\n                continue;\\n            }\\n            else if (prod_total == 0 && elem != 0)\\n                prod_total = 1;            \\n\\n            prod_total  *= elem;\\n        }\\n\\n        if (count_zeros > 1) \\n        {\\n            vector<int> sol_all_zeros(nums.size(), 0); \\n            return sol_all_zeros;\\n        }\\n       \\n        for (auto & elem: nums)\\n        {\\n            if (count_zeros > 0 && elem != 0)\\n                output.push_back(0);            \\n            else\\n            {               \\n                if (elem == 0)\\n                    output.push_back(prod_total);\\n                else\\n                    output.push_back(prod_total / elem);           \\n            }                    \\n        }\\n        return output;\\n    }\\n"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "They wanted an algorithm without division, but you use it."
                    },
                    {
                        "username": "ozans",
                        "content": "The question will be clearer if the question states answer array can be used in  O(1) space complexity in the follow-up section. Thank you for preparing the questions :)"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "My code pass all the test cases there is the idea behind my solution (in Javascript): \\n1) I initialize an empty array call answer\\n2) I use a for loop to go over all the elements in the array\\n3) Inside the for loop i define a variable call value, which is equal to the chaining of a filter and a reduce.  I use the filter to remove the current loop element from the array ( e!= nums[i]) then i use the reduce method to the product of the element in the array (at this point the array don\\'t contain nums[i])\\n\\n4)  Inside the for loop i push the element into the empty array call answer\\n5) Finally i return answer\\n\\nPS: Sorry for the english, i am not a native english speaker...\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Ayushlnct",
                        "content": "COMMON APPRACH DISCUSSION\\n#What we are doing here\\nWe are create three arrays ie. Left, Right and Ans.\\nAfter that we intiallizing Right array by in the way that each element in right array is product element right of that array in the given array.\\nSimilarly we can initiallize left array in the way that each element in left array is product of element left of it.\\nFor boundary elements like the 0th element of left array or last element of right array we can put 1 at that place.\\n ## Why we are doing it\\n Since we have created left and right which consists of product of each element left and right of it repectively. So we can intiallize our ans array in hte way such that each element in ans array is product of left array and right array. By doing so we are actually getting product of all elemets left of it and right of it which solves our problem."
                    },
                    {
                        "username": "sudesh_pawar",
                        "content": "Hint: Try storing prefix products and postfix products for each element and see how you can use them to arrive at the answer.\\nHint 2 : Answer for i\\'th element is not dependent on i\\'th prefix or postfix product. "
                    },
                    {
                        "username": "dkvern01",
                        "content": "I really liked this problem. I thought it was gonna be easy, but the inclusion of 0\\'s made me rethink the entire problem."
                    }
                ]
            },
            {
                "id": 1791086,
                "content": [
                    {
                        "username": "kamranmemon25",
                        "content": "I dont understand why this solution does not work. I am using two loops and no division still getting the error Time limit exceeded. can someone help?\n\n```var productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "SOMANATHmikali",
                        "content": "Bro if you are using two loops the time will be o(n^2) they asked about o(n)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "```const nums = [0,0];\nvar productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "emirkk",
                        "content": "Why I cant use pow function in this question? It gives me that error:\\nLine 13: Char 14: runtime error: -nan is outside the range of representable values of type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp"
                    },
                    {
                        "username": "CatalinDum",
                        "content": "C++ Solution, O(n)\\n\\nI get the total product of all nr > 0;\\nAnd since then multiply is commutative, I can just divide the intruder.\\nPay attention if:  \\n    - we have more than 2 zeros in the array \\n    - the intruder is Zero. \\n\\nEx:  nums = [2, 3, 4]  -> Total prod = 2 * 3 * 4 \\n\\nIntruder = 2 ->    res = 2 * 3 * 4 / 2 -> 3 * 4 = 12\\nIntruder = 3 ->    res = 2 * 3 * 4 / 3 -> 2* 4 = 8\\nIntruder = 4 ->    res = 2 * 3 * 4 / 4 -> 2* 3 = 6\\n\\n\\nEx:  nums = [0, 3, 4]  -> Total prod =  3 * 4 \\n\\nIntruder = 0 ->    res =  3 * 4 = 12\\nIntruder = 3 ->    res = 0\\nIntruder = 4 ->    res = 0\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> output;\\n        int prod_total = 0; \\n        int count_zeros = 0;\\n\\n        for (auto & elem: nums)\\n        {\\n            if (elem == 0) \\n            {                \\n                count_zeros++;\\n                continue;\\n            }\\n            else if (prod_total == 0 && elem != 0)\\n                prod_total = 1;            \\n\\n            prod_total  *= elem;\\n        }\\n\\n        if (count_zeros > 1) \\n        {\\n            vector<int> sol_all_zeros(nums.size(), 0); \\n            return sol_all_zeros;\\n        }\\n       \\n        for (auto & elem: nums)\\n        {\\n            if (count_zeros > 0 && elem != 0)\\n                output.push_back(0);            \\n            else\\n            {               \\n                if (elem == 0)\\n                    output.push_back(prod_total);\\n                else\\n                    output.push_back(prod_total / elem);           \\n            }                    \\n        }\\n        return output;\\n    }\\n"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "They wanted an algorithm without division, but you use it."
                    },
                    {
                        "username": "ozans",
                        "content": "The question will be clearer if the question states answer array can be used in  O(1) space complexity in the follow-up section. Thank you for preparing the questions :)"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "My code pass all the test cases there is the idea behind my solution (in Javascript): \\n1) I initialize an empty array call answer\\n2) I use a for loop to go over all the elements in the array\\n3) Inside the for loop i define a variable call value, which is equal to the chaining of a filter and a reduce.  I use the filter to remove the current loop element from the array ( e!= nums[i]) then i use the reduce method to the product of the element in the array (at this point the array don\\'t contain nums[i])\\n\\n4)  Inside the for loop i push the element into the empty array call answer\\n5) Finally i return answer\\n\\nPS: Sorry for the english, i am not a native english speaker...\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Ayushlnct",
                        "content": "COMMON APPRACH DISCUSSION\\n#What we are doing here\\nWe are create three arrays ie. Left, Right and Ans.\\nAfter that we intiallizing Right array by in the way that each element in right array is product element right of that array in the given array.\\nSimilarly we can initiallize left array in the way that each element in left array is product of element left of it.\\nFor boundary elements like the 0th element of left array or last element of right array we can put 1 at that place.\\n ## Why we are doing it\\n Since we have created left and right which consists of product of each element left and right of it repectively. So we can intiallize our ans array in hte way such that each element in ans array is product of left array and right array. By doing so we are actually getting product of all elemets left of it and right of it which solves our problem."
                    },
                    {
                        "username": "sudesh_pawar",
                        "content": "Hint: Try storing prefix products and postfix products for each element and see how you can use them to arrive at the answer.\\nHint 2 : Answer for i\\'th element is not dependent on i\\'th prefix or postfix product. "
                    },
                    {
                        "username": "dkvern01",
                        "content": "I really liked this problem. I thought it was gonna be easy, but the inclusion of 0\\'s made me rethink the entire problem."
                    }
                ]
            },
            {
                "id": 1787958,
                "content": [
                    {
                        "username": "kamranmemon25",
                        "content": "I dont understand why this solution does not work. I am using two loops and no division still getting the error Time limit exceeded. can someone help?\n\n```var productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "SOMANATHmikali",
                        "content": "Bro if you are using two loops the time will be o(n^2) they asked about o(n)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "```const nums = [0,0];\nvar productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "emirkk",
                        "content": "Why I cant use pow function in this question? It gives me that error:\\nLine 13: Char 14: runtime error: -nan is outside the range of representable values of type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp"
                    },
                    {
                        "username": "CatalinDum",
                        "content": "C++ Solution, O(n)\\n\\nI get the total product of all nr > 0;\\nAnd since then multiply is commutative, I can just divide the intruder.\\nPay attention if:  \\n    - we have more than 2 zeros in the array \\n    - the intruder is Zero. \\n\\nEx:  nums = [2, 3, 4]  -> Total prod = 2 * 3 * 4 \\n\\nIntruder = 2 ->    res = 2 * 3 * 4 / 2 -> 3 * 4 = 12\\nIntruder = 3 ->    res = 2 * 3 * 4 / 3 -> 2* 4 = 8\\nIntruder = 4 ->    res = 2 * 3 * 4 / 4 -> 2* 3 = 6\\n\\n\\nEx:  nums = [0, 3, 4]  -> Total prod =  3 * 4 \\n\\nIntruder = 0 ->    res =  3 * 4 = 12\\nIntruder = 3 ->    res = 0\\nIntruder = 4 ->    res = 0\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> output;\\n        int prod_total = 0; \\n        int count_zeros = 0;\\n\\n        for (auto & elem: nums)\\n        {\\n            if (elem == 0) \\n            {                \\n                count_zeros++;\\n                continue;\\n            }\\n            else if (prod_total == 0 && elem != 0)\\n                prod_total = 1;            \\n\\n            prod_total  *= elem;\\n        }\\n\\n        if (count_zeros > 1) \\n        {\\n            vector<int> sol_all_zeros(nums.size(), 0); \\n            return sol_all_zeros;\\n        }\\n       \\n        for (auto & elem: nums)\\n        {\\n            if (count_zeros > 0 && elem != 0)\\n                output.push_back(0);            \\n            else\\n            {               \\n                if (elem == 0)\\n                    output.push_back(prod_total);\\n                else\\n                    output.push_back(prod_total / elem);           \\n            }                    \\n        }\\n        return output;\\n    }\\n"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "They wanted an algorithm without division, but you use it."
                    },
                    {
                        "username": "ozans",
                        "content": "The question will be clearer if the question states answer array can be used in  O(1) space complexity in the follow-up section. Thank you for preparing the questions :)"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "My code pass all the test cases there is the idea behind my solution (in Javascript): \\n1) I initialize an empty array call answer\\n2) I use a for loop to go over all the elements in the array\\n3) Inside the for loop i define a variable call value, which is equal to the chaining of a filter and a reduce.  I use the filter to remove the current loop element from the array ( e!= nums[i]) then i use the reduce method to the product of the element in the array (at this point the array don\\'t contain nums[i])\\n\\n4)  Inside the for loop i push the element into the empty array call answer\\n5) Finally i return answer\\n\\nPS: Sorry for the english, i am not a native english speaker...\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Ayushlnct",
                        "content": "COMMON APPRACH DISCUSSION\\n#What we are doing here\\nWe are create three arrays ie. Left, Right and Ans.\\nAfter that we intiallizing Right array by in the way that each element in right array is product element right of that array in the given array.\\nSimilarly we can initiallize left array in the way that each element in left array is product of element left of it.\\nFor boundary elements like the 0th element of left array or last element of right array we can put 1 at that place.\\n ## Why we are doing it\\n Since we have created left and right which consists of product of each element left and right of it repectively. So we can intiallize our ans array in hte way such that each element in ans array is product of left array and right array. By doing so we are actually getting product of all elemets left of it and right of it which solves our problem."
                    },
                    {
                        "username": "sudesh_pawar",
                        "content": "Hint: Try storing prefix products and postfix products for each element and see how you can use them to arrive at the answer.\\nHint 2 : Answer for i\\'th element is not dependent on i\\'th prefix or postfix product. "
                    },
                    {
                        "username": "dkvern01",
                        "content": "I really liked this problem. I thought it was gonna be easy, but the inclusion of 0\\'s made me rethink the entire problem."
                    }
                ]
            },
            {
                "id": 1787356,
                "content": [
                    {
                        "username": "kamranmemon25",
                        "content": "I dont understand why this solution does not work. I am using two loops and no division still getting the error Time limit exceeded. can someone help?\n\n```var productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "SOMANATHmikali",
                        "content": "Bro if you are using two loops the time will be o(n^2) they asked about o(n)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "```const nums = [0,0];\nvar productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "emirkk",
                        "content": "Why I cant use pow function in this question? It gives me that error:\\nLine 13: Char 14: runtime error: -nan is outside the range of representable values of type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp"
                    },
                    {
                        "username": "CatalinDum",
                        "content": "C++ Solution, O(n)\\n\\nI get the total product of all nr > 0;\\nAnd since then multiply is commutative, I can just divide the intruder.\\nPay attention if:  \\n    - we have more than 2 zeros in the array \\n    - the intruder is Zero. \\n\\nEx:  nums = [2, 3, 4]  -> Total prod = 2 * 3 * 4 \\n\\nIntruder = 2 ->    res = 2 * 3 * 4 / 2 -> 3 * 4 = 12\\nIntruder = 3 ->    res = 2 * 3 * 4 / 3 -> 2* 4 = 8\\nIntruder = 4 ->    res = 2 * 3 * 4 / 4 -> 2* 3 = 6\\n\\n\\nEx:  nums = [0, 3, 4]  -> Total prod =  3 * 4 \\n\\nIntruder = 0 ->    res =  3 * 4 = 12\\nIntruder = 3 ->    res = 0\\nIntruder = 4 ->    res = 0\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> output;\\n        int prod_total = 0; \\n        int count_zeros = 0;\\n\\n        for (auto & elem: nums)\\n        {\\n            if (elem == 0) \\n            {                \\n                count_zeros++;\\n                continue;\\n            }\\n            else if (prod_total == 0 && elem != 0)\\n                prod_total = 1;            \\n\\n            prod_total  *= elem;\\n        }\\n\\n        if (count_zeros > 1) \\n        {\\n            vector<int> sol_all_zeros(nums.size(), 0); \\n            return sol_all_zeros;\\n        }\\n       \\n        for (auto & elem: nums)\\n        {\\n            if (count_zeros > 0 && elem != 0)\\n                output.push_back(0);            \\n            else\\n            {               \\n                if (elem == 0)\\n                    output.push_back(prod_total);\\n                else\\n                    output.push_back(prod_total / elem);           \\n            }                    \\n        }\\n        return output;\\n    }\\n"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "They wanted an algorithm without division, but you use it."
                    },
                    {
                        "username": "ozans",
                        "content": "The question will be clearer if the question states answer array can be used in  O(1) space complexity in the follow-up section. Thank you for preparing the questions :)"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "My code pass all the test cases there is the idea behind my solution (in Javascript): \\n1) I initialize an empty array call answer\\n2) I use a for loop to go over all the elements in the array\\n3) Inside the for loop i define a variable call value, which is equal to the chaining of a filter and a reduce.  I use the filter to remove the current loop element from the array ( e!= nums[i]) then i use the reduce method to the product of the element in the array (at this point the array don\\'t contain nums[i])\\n\\n4)  Inside the for loop i push the element into the empty array call answer\\n5) Finally i return answer\\n\\nPS: Sorry for the english, i am not a native english speaker...\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Ayushlnct",
                        "content": "COMMON APPRACH DISCUSSION\\n#What we are doing here\\nWe are create three arrays ie. Left, Right and Ans.\\nAfter that we intiallizing Right array by in the way that each element in right array is product element right of that array in the given array.\\nSimilarly we can initiallize left array in the way that each element in left array is product of element left of it.\\nFor boundary elements like the 0th element of left array or last element of right array we can put 1 at that place.\\n ## Why we are doing it\\n Since we have created left and right which consists of product of each element left and right of it repectively. So we can intiallize our ans array in hte way such that each element in ans array is product of left array and right array. By doing so we are actually getting product of all elemets left of it and right of it which solves our problem."
                    },
                    {
                        "username": "sudesh_pawar",
                        "content": "Hint: Try storing prefix products and postfix products for each element and see how you can use them to arrive at the answer.\\nHint 2 : Answer for i\\'th element is not dependent on i\\'th prefix or postfix product. "
                    },
                    {
                        "username": "dkvern01",
                        "content": "I really liked this problem. I thought it was gonna be easy, but the inclusion of 0\\'s made me rethink the entire problem."
                    }
                ]
            },
            {
                "id": 1757548,
                "content": [
                    {
                        "username": "kamranmemon25",
                        "content": "I dont understand why this solution does not work. I am using two loops and no division still getting the error Time limit exceeded. can someone help?\n\n```var productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "SOMANATHmikali",
                        "content": "Bro if you are using two loops the time will be o(n^2) they asked about o(n)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "```const nums = [0,0];\nvar productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "emirkk",
                        "content": "Why I cant use pow function in this question? It gives me that error:\\nLine 13: Char 14: runtime error: -nan is outside the range of representable values of type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp"
                    },
                    {
                        "username": "CatalinDum",
                        "content": "C++ Solution, O(n)\\n\\nI get the total product of all nr > 0;\\nAnd since then multiply is commutative, I can just divide the intruder.\\nPay attention if:  \\n    - we have more than 2 zeros in the array \\n    - the intruder is Zero. \\n\\nEx:  nums = [2, 3, 4]  -> Total prod = 2 * 3 * 4 \\n\\nIntruder = 2 ->    res = 2 * 3 * 4 / 2 -> 3 * 4 = 12\\nIntruder = 3 ->    res = 2 * 3 * 4 / 3 -> 2* 4 = 8\\nIntruder = 4 ->    res = 2 * 3 * 4 / 4 -> 2* 3 = 6\\n\\n\\nEx:  nums = [0, 3, 4]  -> Total prod =  3 * 4 \\n\\nIntruder = 0 ->    res =  3 * 4 = 12\\nIntruder = 3 ->    res = 0\\nIntruder = 4 ->    res = 0\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> output;\\n        int prod_total = 0; \\n        int count_zeros = 0;\\n\\n        for (auto & elem: nums)\\n        {\\n            if (elem == 0) \\n            {                \\n                count_zeros++;\\n                continue;\\n            }\\n            else if (prod_total == 0 && elem != 0)\\n                prod_total = 1;            \\n\\n            prod_total  *= elem;\\n        }\\n\\n        if (count_zeros > 1) \\n        {\\n            vector<int> sol_all_zeros(nums.size(), 0); \\n            return sol_all_zeros;\\n        }\\n       \\n        for (auto & elem: nums)\\n        {\\n            if (count_zeros > 0 && elem != 0)\\n                output.push_back(0);            \\n            else\\n            {               \\n                if (elem == 0)\\n                    output.push_back(prod_total);\\n                else\\n                    output.push_back(prod_total / elem);           \\n            }                    \\n        }\\n        return output;\\n    }\\n"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "They wanted an algorithm without division, but you use it."
                    },
                    {
                        "username": "ozans",
                        "content": "The question will be clearer if the question states answer array can be used in  O(1) space complexity in the follow-up section. Thank you for preparing the questions :)"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "My code pass all the test cases there is the idea behind my solution (in Javascript): \\n1) I initialize an empty array call answer\\n2) I use a for loop to go over all the elements in the array\\n3) Inside the for loop i define a variable call value, which is equal to the chaining of a filter and a reduce.  I use the filter to remove the current loop element from the array ( e!= nums[i]) then i use the reduce method to the product of the element in the array (at this point the array don\\'t contain nums[i])\\n\\n4)  Inside the for loop i push the element into the empty array call answer\\n5) Finally i return answer\\n\\nPS: Sorry for the english, i am not a native english speaker...\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Ayushlnct",
                        "content": "COMMON APPRACH DISCUSSION\\n#What we are doing here\\nWe are create three arrays ie. Left, Right and Ans.\\nAfter that we intiallizing Right array by in the way that each element in right array is product element right of that array in the given array.\\nSimilarly we can initiallize left array in the way that each element in left array is product of element left of it.\\nFor boundary elements like the 0th element of left array or last element of right array we can put 1 at that place.\\n ## Why we are doing it\\n Since we have created left and right which consists of product of each element left and right of it repectively. So we can intiallize our ans array in hte way such that each element in ans array is product of left array and right array. By doing so we are actually getting product of all elemets left of it and right of it which solves our problem."
                    },
                    {
                        "username": "sudesh_pawar",
                        "content": "Hint: Try storing prefix products and postfix products for each element and see how you can use them to arrive at the answer.\\nHint 2 : Answer for i\\'th element is not dependent on i\\'th prefix or postfix product. "
                    },
                    {
                        "username": "dkvern01",
                        "content": "I really liked this problem. I thought it was gonna be easy, but the inclusion of 0\\'s made me rethink the entire problem."
                    }
                ]
            },
            {
                "id": 1757028,
                "content": [
                    {
                        "username": "kamranmemon25",
                        "content": "I dont understand why this solution does not work. I am using two loops and no division still getting the error Time limit exceeded. can someone help?\n\n```var productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "SOMANATHmikali",
                        "content": "Bro if you are using two loops the time will be o(n^2) they asked about o(n)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "```const nums = [0,0];\nvar productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "emirkk",
                        "content": "Why I cant use pow function in this question? It gives me that error:\\nLine 13: Char 14: runtime error: -nan is outside the range of representable values of type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp"
                    },
                    {
                        "username": "CatalinDum",
                        "content": "C++ Solution, O(n)\\n\\nI get the total product of all nr > 0;\\nAnd since then multiply is commutative, I can just divide the intruder.\\nPay attention if:  \\n    - we have more than 2 zeros in the array \\n    - the intruder is Zero. \\n\\nEx:  nums = [2, 3, 4]  -> Total prod = 2 * 3 * 4 \\n\\nIntruder = 2 ->    res = 2 * 3 * 4 / 2 -> 3 * 4 = 12\\nIntruder = 3 ->    res = 2 * 3 * 4 / 3 -> 2* 4 = 8\\nIntruder = 4 ->    res = 2 * 3 * 4 / 4 -> 2* 3 = 6\\n\\n\\nEx:  nums = [0, 3, 4]  -> Total prod =  3 * 4 \\n\\nIntruder = 0 ->    res =  3 * 4 = 12\\nIntruder = 3 ->    res = 0\\nIntruder = 4 ->    res = 0\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> output;\\n        int prod_total = 0; \\n        int count_zeros = 0;\\n\\n        for (auto & elem: nums)\\n        {\\n            if (elem == 0) \\n            {                \\n                count_zeros++;\\n                continue;\\n            }\\n            else if (prod_total == 0 && elem != 0)\\n                prod_total = 1;            \\n\\n            prod_total  *= elem;\\n        }\\n\\n        if (count_zeros > 1) \\n        {\\n            vector<int> sol_all_zeros(nums.size(), 0); \\n            return sol_all_zeros;\\n        }\\n       \\n        for (auto & elem: nums)\\n        {\\n            if (count_zeros > 0 && elem != 0)\\n                output.push_back(0);            \\n            else\\n            {               \\n                if (elem == 0)\\n                    output.push_back(prod_total);\\n                else\\n                    output.push_back(prod_total / elem);           \\n            }                    \\n        }\\n        return output;\\n    }\\n"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "They wanted an algorithm without division, but you use it."
                    },
                    {
                        "username": "ozans",
                        "content": "The question will be clearer if the question states answer array can be used in  O(1) space complexity in the follow-up section. Thank you for preparing the questions :)"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "My code pass all the test cases there is the idea behind my solution (in Javascript): \\n1) I initialize an empty array call answer\\n2) I use a for loop to go over all the elements in the array\\n3) Inside the for loop i define a variable call value, which is equal to the chaining of a filter and a reduce.  I use the filter to remove the current loop element from the array ( e!= nums[i]) then i use the reduce method to the product of the element in the array (at this point the array don\\'t contain nums[i])\\n\\n4)  Inside the for loop i push the element into the empty array call answer\\n5) Finally i return answer\\n\\nPS: Sorry for the english, i am not a native english speaker...\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Ayushlnct",
                        "content": "COMMON APPRACH DISCUSSION\\n#What we are doing here\\nWe are create three arrays ie. Left, Right and Ans.\\nAfter that we intiallizing Right array by in the way that each element in right array is product element right of that array in the given array.\\nSimilarly we can initiallize left array in the way that each element in left array is product of element left of it.\\nFor boundary elements like the 0th element of left array or last element of right array we can put 1 at that place.\\n ## Why we are doing it\\n Since we have created left and right which consists of product of each element left and right of it repectively. So we can intiallize our ans array in hte way such that each element in ans array is product of left array and right array. By doing so we are actually getting product of all elemets left of it and right of it which solves our problem."
                    },
                    {
                        "username": "sudesh_pawar",
                        "content": "Hint: Try storing prefix products and postfix products for each element and see how you can use them to arrive at the answer.\\nHint 2 : Answer for i\\'th element is not dependent on i\\'th prefix or postfix product. "
                    },
                    {
                        "username": "dkvern01",
                        "content": "I really liked this problem. I thought it was gonna be easy, but the inclusion of 0\\'s made me rethink the entire problem."
                    }
                ]
            },
            {
                "id": 1741045,
                "content": [
                    {
                        "username": "kamranmemon25",
                        "content": "I dont understand why this solution does not work. I am using two loops and no division still getting the error Time limit exceeded. can someone help?\n\n```var productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "SOMANATHmikali",
                        "content": "Bro if you are using two loops the time will be o(n^2) they asked about o(n)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "```const nums = [0,0];\nvar productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "emirkk",
                        "content": "Why I cant use pow function in this question? It gives me that error:\\nLine 13: Char 14: runtime error: -nan is outside the range of representable values of type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp"
                    },
                    {
                        "username": "CatalinDum",
                        "content": "C++ Solution, O(n)\\n\\nI get the total product of all nr > 0;\\nAnd since then multiply is commutative, I can just divide the intruder.\\nPay attention if:  \\n    - we have more than 2 zeros in the array \\n    - the intruder is Zero. \\n\\nEx:  nums = [2, 3, 4]  -> Total prod = 2 * 3 * 4 \\n\\nIntruder = 2 ->    res = 2 * 3 * 4 / 2 -> 3 * 4 = 12\\nIntruder = 3 ->    res = 2 * 3 * 4 / 3 -> 2* 4 = 8\\nIntruder = 4 ->    res = 2 * 3 * 4 / 4 -> 2* 3 = 6\\n\\n\\nEx:  nums = [0, 3, 4]  -> Total prod =  3 * 4 \\n\\nIntruder = 0 ->    res =  3 * 4 = 12\\nIntruder = 3 ->    res = 0\\nIntruder = 4 ->    res = 0\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> output;\\n        int prod_total = 0; \\n        int count_zeros = 0;\\n\\n        for (auto & elem: nums)\\n        {\\n            if (elem == 0) \\n            {                \\n                count_zeros++;\\n                continue;\\n            }\\n            else if (prod_total == 0 && elem != 0)\\n                prod_total = 1;            \\n\\n            prod_total  *= elem;\\n        }\\n\\n        if (count_zeros > 1) \\n        {\\n            vector<int> sol_all_zeros(nums.size(), 0); \\n            return sol_all_zeros;\\n        }\\n       \\n        for (auto & elem: nums)\\n        {\\n            if (count_zeros > 0 && elem != 0)\\n                output.push_back(0);            \\n            else\\n            {               \\n                if (elem == 0)\\n                    output.push_back(prod_total);\\n                else\\n                    output.push_back(prod_total / elem);           \\n            }                    \\n        }\\n        return output;\\n    }\\n"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "They wanted an algorithm without division, but you use it."
                    },
                    {
                        "username": "ozans",
                        "content": "The question will be clearer if the question states answer array can be used in  O(1) space complexity in the follow-up section. Thank you for preparing the questions :)"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "My code pass all the test cases there is the idea behind my solution (in Javascript): \\n1) I initialize an empty array call answer\\n2) I use a for loop to go over all the elements in the array\\n3) Inside the for loop i define a variable call value, which is equal to the chaining of a filter and a reduce.  I use the filter to remove the current loop element from the array ( e!= nums[i]) then i use the reduce method to the product of the element in the array (at this point the array don\\'t contain nums[i])\\n\\n4)  Inside the for loop i push the element into the empty array call answer\\n5) Finally i return answer\\n\\nPS: Sorry for the english, i am not a native english speaker...\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Ayushlnct",
                        "content": "COMMON APPRACH DISCUSSION\\n#What we are doing here\\nWe are create three arrays ie. Left, Right and Ans.\\nAfter that we intiallizing Right array by in the way that each element in right array is product element right of that array in the given array.\\nSimilarly we can initiallize left array in the way that each element in left array is product of element left of it.\\nFor boundary elements like the 0th element of left array or last element of right array we can put 1 at that place.\\n ## Why we are doing it\\n Since we have created left and right which consists of product of each element left and right of it repectively. So we can intiallize our ans array in hte way such that each element in ans array is product of left array and right array. By doing so we are actually getting product of all elemets left of it and right of it which solves our problem."
                    },
                    {
                        "username": "sudesh_pawar",
                        "content": "Hint: Try storing prefix products and postfix products for each element and see how you can use them to arrive at the answer.\\nHint 2 : Answer for i\\'th element is not dependent on i\\'th prefix or postfix product. "
                    },
                    {
                        "username": "dkvern01",
                        "content": "I really liked this problem. I thought it was gonna be easy, but the inclusion of 0\\'s made me rethink the entire problem."
                    }
                ]
            },
            {
                "id": 1719685,
                "content": [
                    {
                        "username": "kamranmemon25",
                        "content": "I dont understand why this solution does not work. I am using two loops and no division still getting the error Time limit exceeded. can someone help?\n\n```var productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "SOMANATHmikali",
                        "content": "Bro if you are using two loops the time will be o(n^2) they asked about o(n)"
                    },
                    {
                        "username": "kamranmemon25",
                        "content": "```const nums = [0,0];\nvar productExceptSelf = function(nums) {\n  let arr = [];\n  let index = 0;\n  while (index < nums.length) {\n    let last = null;\n    for(let i = 0; i< nums.length; i++) { \n      if(i === index) { \n        continue;\n      } \n      else { \n        if(last === null) { \n          last = nums[i];\n        } else { \n          last = last * nums[i];\n        }\n      }\n    }\n    \n    arr.push(last)\n    index++;\n  }\n  return arr;\n};\nproductExceptSelf(nums);```"
                    },
                    {
                        "username": "emirkk",
                        "content": "Why I cant use pow function in this question? It gives me that error:\\nLine 13: Char 14: runtime error: -nan is outside the range of representable values of type \\'int\\' (solution.cpp)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior prog_joined.cpp"
                    },
                    {
                        "username": "CatalinDum",
                        "content": "C++ Solution, O(n)\\n\\nI get the total product of all nr > 0;\\nAnd since then multiply is commutative, I can just divide the intruder.\\nPay attention if:  \\n    - we have more than 2 zeros in the array \\n    - the intruder is Zero. \\n\\nEx:  nums = [2, 3, 4]  -> Total prod = 2 * 3 * 4 \\n\\nIntruder = 2 ->    res = 2 * 3 * 4 / 2 -> 3 * 4 = 12\\nIntruder = 3 ->    res = 2 * 3 * 4 / 3 -> 2* 4 = 8\\nIntruder = 4 ->    res = 2 * 3 * 4 / 4 -> 2* 3 = 6\\n\\n\\nEx:  nums = [0, 3, 4]  -> Total prod =  3 * 4 \\n\\nIntruder = 0 ->    res =  3 * 4 = 12\\nIntruder = 3 ->    res = 0\\nIntruder = 4 ->    res = 0\\n\\n    vector<int> productExceptSelf(vector<int>& nums) {\\n        vector<int> output;\\n        int prod_total = 0; \\n        int count_zeros = 0;\\n\\n        for (auto & elem: nums)\\n        {\\n            if (elem == 0) \\n            {                \\n                count_zeros++;\\n                continue;\\n            }\\n            else if (prod_total == 0 && elem != 0)\\n                prod_total = 1;            \\n\\n            prod_total  *= elem;\\n        }\\n\\n        if (count_zeros > 1) \\n        {\\n            vector<int> sol_all_zeros(nums.size(), 0); \\n            return sol_all_zeros;\\n        }\\n       \\n        for (auto & elem: nums)\\n        {\\n            if (count_zeros > 0 && elem != 0)\\n                output.push_back(0);            \\n            else\\n            {               \\n                if (elem == 0)\\n                    output.push_back(prod_total);\\n                else\\n                    output.push_back(prod_total / elem);           \\n            }                    \\n        }\\n        return output;\\n    }\\n"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "They wanted an algorithm without division, but you use it."
                    },
                    {
                        "username": "ozans",
                        "content": "The question will be clearer if the question states answer array can be used in  O(1) space complexity in the follow-up section. Thank you for preparing the questions :)"
                    },
                    {
                        "username": "juniorbertrand761",
                        "content": "My code pass all the test cases there is the idea behind my solution (in Javascript): \\n1) I initialize an empty array call answer\\n2) I use a for loop to go over all the elements in the array\\n3) Inside the for loop i define a variable call value, which is equal to the chaining of a filter and a reduce.  I use the filter to remove the current loop element from the array ( e!= nums[i]) then i use the reduce method to the product of the element in the array (at this point the array don\\'t contain nums[i])\\n\\n4)  Inside the for loop i push the element into the empty array call answer\\n5) Finally i return answer\\n\\nPS: Sorry for the english, i am not a native english speaker...\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Ayushlnct",
                        "content": "COMMON APPRACH DISCUSSION\\n#What we are doing here\\nWe are create three arrays ie. Left, Right and Ans.\\nAfter that we intiallizing Right array by in the way that each element in right array is product element right of that array in the given array.\\nSimilarly we can initiallize left array in the way that each element in left array is product of element left of it.\\nFor boundary elements like the 0th element of left array or last element of right array we can put 1 at that place.\\n ## Why we are doing it\\n Since we have created left and right which consists of product of each element left and right of it repectively. So we can intiallize our ans array in hte way such that each element in ans array is product of left array and right array. By doing so we are actually getting product of all elemets left of it and right of it which solves our problem."
                    },
                    {
                        "username": "sudesh_pawar",
                        "content": "Hint: Try storing prefix products and postfix products for each element and see how you can use them to arrive at the answer.\\nHint 2 : Answer for i\\'th element is not dependent on i\\'th prefix or postfix product. "
                    },
                    {
                        "username": "dkvern01",
                        "content": "I really liked this problem. I thought it was gonna be easy, but the inclusion of 0\\'s made me rethink the entire problem."
                    }
                ]
            }
        ]
    }
]