[
    {
        "title": "Partition Array into Disjoint Intervals",
        "question_content": "Given an integer array nums, partition it into two (contiguous) subarrays left and right so that:\n\n\tEvery element in left is less than or equal to every element in right.\n\tleft and right are non-empty.\n\tleft has the smallest possible size.\n\nReturn the length of left after such a partitioning.\nTest cases are generated such that partitioning exists.\n&nbsp;\nExample 1:\n\nInput: nums = [5,0,3,8,6]\nOutput: 3\nExplanation: left = [5,0,3], right = [8,6]\n\nExample 2:\n\nInput: nums = [1,1,1,0,6,12]\nOutput: 4\nExplanation: left = [1,1,1,0], right = [6,12]\n\n&nbsp;\nConstraints:\n\n\t2 <= nums.length <= 105\n\t0 <= nums[i] <= 106\n\tThere is at least one valid answer for the given input.",
        "solutions": [
            {
                "id": 175945,
                "title": "java-one-pass-7-lines",
                "content": "```java\\npublic int partitionDisjoint(int[] a) {\\n        int localMax = a[0], partitionIdx = 0, max = localMax;\\n        for (int i = 1; i < a.length; i++)\\n            if (localMax > a[i]) {\\n                localMax = max;\\n                partitionIdx = i;\\n            } else max = Math.max(max, a[i]);\\n        return partitionIdx + 1;\\n    }",
                "solutionTags": [],
                "code": "```java\\npublic int partitionDisjoint(int[] a) {\\n        int localMax = a[0], partitionIdx = 0, max = localMax;\\n        for (int i = 1; i < a.length; i++)\\n            if (localMax > a[i]) {\\n                localMax = max;\\n                partitionIdx = i;\\n            } else max = Math.max(max, a[i]);\\n        return partitionIdx + 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 175904,
                "title": "explained-python-simple-o-n-time-o-1-space",
                "content": "Looping through each element  `A[i]` we will keep track of the `max_so_far` and `disjoint` index. If we see a value `A[i] < max_so_far` we know that value must be in the left partition, so we update the `disjoint` location and check if we have a new  `max_so_far` in the left partition. Once we go through the list, every element on the right side of `disjoint` is guarenteed to be larger than elements left of `disjoint`\n\n```  \ndef partitionDisjoint(self, A):\n        disjoint = 0\n        v = A[disjoint]\n        max_so_far = v\n        for i in range(len(A)):\n            max_so_far = max(max_so_far, A[i])\n            if A[i] < v: \n                disjoint = i\n                v = max_so_far\n        return disjoint + 1\n\t\t\t",
                "solutionTags": [],
                "code": "def partitionDisjoint(self, A):\n        disjoint = 0\n        v = A[disjoint]\n        max_so_far = v\n        for i in range(len(A)):\n            max_so_far = max(max_so_far, A[i])\n                disjoint = i\n                v = max_so_far",
                "codeTag": "Python3"
            },
            {
                "id": 1122368,
                "title": "java-2-solutions",
                "content": "**GOAL:** We have to find length of left array so basically have to find idx such that if we make a partition at that idx .All values in left array are less than from values of right array.\\n\\n**OBSERVATION:** If the maximum from left array is less than minimum from right array then we can make a split at that idx.\\n\\n**CODE:**\\n```\\npublic int partitionDisjoint(int[] A) {\\n        int[] lmax=new int[A.length]; //lmax :left maximum\\n        int[] rmin=new int[A.length]; //rmin : right minimum\\n        \\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<A.length;i++){\\n            max=Math.max(max,A[i]);\\n            lmax[i]=max;\\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        for(int i=A.length-1;i>=0;i--){\\n            min=Math.min(min,A[i]);\\n            rmin[i]=min;\\n        }\\n        \\n        for(int i=1;i<A.length;i++){\\n            if(lmax[i-1]<=rmin[i]) return i;\\n        }\\n        return A.length;\\n    }\\n```\\n\\n**Dry Run:**\\n arr  :     [5,0,3,8,6]\\nlmax: [5,5,**5**,8,8]\\nrMin: [0,0,3,**6**,6]\\nwe will make a split at after index 2 . i.e length of left array is 3. we are handling that thing through code.\\n\\n**Complexity :**\\n`Time : O(n) and Space:O(n)`\\n\\n**Follow UP:** `Can you Optimise Space?`\\n\\n**IDEA:**\\nwhile iterating if we keep comparing maximum from left to idx value . \\n-> we will make a answer initial at 0. assuming that till 0 left array exist.\\n-> then we will iterate and compare idx  value to maximum from left. \\n -> if value is less than maximum of left means this value belong to left array . \\n      So we need to make a next maximum variable also because now left array is till given idx at which we currently are. (value<leftmax) . So we need maximum of this new left array. which basically equal to nextMax. \\nCode will clear all your doubts.\\n\\n**CODE:**\\n```\\n public int partitionDisjoint(int[] A) {\\n        int cmax=A[0]; //cmax:current maximum\\n        int nmax=A[0];//nmax: next maximum\\n        int ans=0;\\n        \\n        for(int i=1;i<A.length;i++){\\n            int val=A[i];\\n          nmax=Math.max(val,nmax); //next max for case if i exist in left Part\\n            \\n            if(val<cmax){\\n                ans=i;         //now left Part is till here\\n                cmax=nmax; //maximum of left array is nmax(as we are maintaining maximum for split Part)\\n            }\\n        }\\n        return ans+1; // we have to return length not idx so ans+1.\\n    }\\n```\\t\\n\\n**COMPLEXITY:**\\n` TIME : O(N) and Space:O(1)`\\n\\nPlease **upvote** if found it helpful:)",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic int partitionDisjoint(int[] A) {\\n        int[] lmax=new int[A.length]; //lmax :left maximum\\n        int[] rmin=new int[A.length]; //rmin : right minimum\\n        \\n        int max=Integer.MIN_VALUE;\\n        for(int i=0;i<A.length;i++){\\n            max=Math.max(max,A[i]);\\n            lmax[i]=max;\\n        }\\n        \\n        int min=Integer.MAX_VALUE;\\n        for(int i=A.length-1;i>=0;i--){\\n            min=Math.min(min,A[i]);\\n            rmin[i]=min;\\n        }\\n        \\n        for(int i=1;i<A.length;i++){\\n            if(lmax[i-1]<=rmin[i]) return i;\\n        }\\n        return A.length;\\n    }\\n```\n```\\n public int partitionDisjoint(int[] A) {\\n        int cmax=A[0]; //cmax:current maximum\\n        int nmax=A[0];//nmax: next maximum\\n        int ans=0;\\n        \\n        for(int i=1;i<A.length;i++){\\n            int val=A[i];\\n          nmax=Math.max(val,nmax); //next max for case if i exist in left Part\\n            \\n            if(val<cmax){\\n                ans=i;         //now left Part is till here\\n                cmax=nmax; //maximum of left array is nmax(as we are maintaining maximum for split Part)\\n            }\\n        }\\n        return ans+1; // we have to return length not idx so ans+1.\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354458,
                "title": "python-two-accumulates-explained",
                "content": "Let us look more carefully at the phrase: `every element in left is less than or equal to every element in right`. Actually it means that maximum of the left part is less or equal than minimum of the right part. So, let us calculate the following arrays:\\n1. `t1` is accumulate maximum, starting from the left side.\\n2. `t2` is accumulate minimum, starting from the right side.\\n3. Iterate throught these two arrays and find the first `i`, where `t1[i-1] <= t2[i]`: it will mean that we found exaclty the correct place.\\n\\n#### Complexity\\nTime complexity is `O(n)`, space complexity is `O(n)` as well.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        t1 = list(accumulate(A, max)) \\n        t2 = list(accumulate(A[::-1], min))[::-1]\\n        for i in range(1, len(A)):\\n            if t1[i-1] <= t2[i]: return i\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        t1 = list(accumulate(A, max)) \\n        t2 = list(accumulate(A[::-1], min))[::-1]\\n        for i in range(1, len(A)):\\n            if t1[i-1] <= t2[i]: return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354687,
                "title": "c-easy-clean-solution",
                "content": "**Solution:**\\n\\n1. Establish the maximum `max_1` as `nums[0]`, i.e., the lowest element in the beginning.\\n2. If we find something lower than our current maximum `max_1`, that element must be included in the left partition.\\n3. Otherwise, if we find something greater than our overall maximum `curr` change its value.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        int max_1, curr, ans = 1;\\n        max_1 = curr = nums[0];\\n        for(int i = 1; i < n; i++){\\n            if(nums[i] < max_1){\\n                max_1 = curr;\\n                ans = i + 1;\\n            }\\n            else if(nums[i] > curr){\\n                curr = nums[i];                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**`Time Complexity`**: **`O(n)`**\\n**`Space Complexity`**: **`O(1)`**\\nwhere **n** is the size of array **nums**.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        int max_1, curr, ans = 1;\\n        max_1 = curr = nums[0];\\n        for(int i = 1; i < n; i++){\\n            if(nums[i] < max_1){\\n                max_1 = curr;\\n                ans = i + 1;\\n            }\\n            else if(nums[i] > curr){\\n                curr = nums[i];                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354396,
                "title": "python-from-o-n-space-to-o-1-space-picture-explained-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Build LeftMaxSoFar, RightMinSoFar**\\n- We need to partion `nums` into two subarrays `left` and `right` so that all elements in `left` subarray <= all elements in `right` subarray. It also mean we partition so that the maximum element in `left` subarray is always <= the minimum element in `right` subarray.\\n- We just need to build right min so far, let `minRight[i]` is the minimum element between elements `nums[i..n-1]`.\\n- Then we iterate `i` in range `[1..n]`, try to partion it into 2 subarrays: leftSubArr = `nums[0..i-1]`, rightSubArr = `nums[i..n-1]`. If `maxLeft <= minRight[i]` then we can partition, and now `i` is the smallest size of the left subarray, return `i` as the result.\\n```python\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        minRight = [0] * n\\n        minRight[n - 1] = nums[n - 1]\\n        for i in range(n - 2, -1, -1):\\n            minRight[i] = min(nums[i], minRight[i + 1])\\n\\n        maxLeft = nums[0]\\n        for i in range(1, n):\\n            if maxLeft <= minRight[i]:\\n                return i\\n            maxLeft = max(maxLeft, nums[i])\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 30000` is number of elements in array `nums`.\\n- Space: `O(N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: One passing**\\n- The process divide `nums` array into 3 parts:\\n\\t- Left part: `nums[0..partition]`, with the maximum number is `leftMax`.\\n\\t- Middle part: `nums[parition+1..i-1]`, where all elements are greater than or equal to elements in the left part.\\n\\t- The right part: `nums[i..n-1]`, where elements are to be processed.\\n- We keep `globalMax` as the maximum number from `nums[0...i-1]`.\\n- When iterating `i` from `[1...n-1]`, if `nums[i] < leftMax` then:\\n\\t- `nums[i]` can\\'t belong to the right subarray (because all elements in the right array must >=`maxLeft`), so `nums[i]` belong to the left subarray.\\n\\t- We re-partition, by set `partion = i`.\\n\\t- Update `leftMax = globalMax`.\\n- Finally, we return `parition + 1` as the smallest length of the left subarray which has all elements <= elements in the right subarray.\\n\\n![image](https://assets.leetcode.com/users/images/c5248a36-4521-403d-bdd9-31023d62db73_1626947567.8115952.png)\\n\\n\\n```python\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        leftMax = globalMax = nums[0]\\n        partition = 0\\n        for i in range(1, len(nums)):\\n            globalMax = max(globalMax, nums[i])\\n            if nums[i] < leftMax:  # If nums[i] < leftMax then nums[i] belong to left subarray, re-partition leftSubArr = nums[0..i]\\n                partition = i\\n                leftMax = globalMax\\n        return partition + 1\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 30000` is number of elements in array `nums`.\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        minRight = [0] * n\\n        minRight[n - 1] = nums[n - 1]\\n        for i in range(n - 2, -1, -1):\\n            minRight[i] = min(nums[i], minRight[i + 1])\\n\\n        maxLeft = nums[0]\\n        for i in range(1, n):\\n            if maxLeft <= minRight[i]:\\n                return i\\n            maxLeft = max(maxLeft, nums[i])\\n```\n```python\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        leftMax = globalMax = nums[0]\\n        partition = 0\\n        for i in range(1, len(nums)):\\n            globalMax = max(globalMax, nums[i])\\n            if nums[i] < leftMax:  # If nums[i] < leftMax then nums[i] belong to left subarray, re-partition leftSubArr = nums[0..i]\\n                partition = i\\n                leftMax = globalMax\\n        return partition + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197987,
                "title": "python-solutions-3-passes-2-passes-1-pass-straight-forward",
                "content": "**3 passes solution:**\\n first pass: use an array to keep the maximun of all left element,\\n second pass:  use an array to keep the minimun of all right element,\\n third pass: find where the maxleft <= minright:\\n ```\\n     def partitionDisjoint(self, A):\\n        maxleft = [A[0]]*len(A)\\n        for i in range(1,len(A)):\\n            maxleft[i] = max(maxleft[i-1], A[i])\\n            \\n        minright = [A[-1]]*len(A)\\n        for i in range(len(A)-2,-1,-1):\\n            minright[i] = min(minright[i+1], A[i]) \\n        \\n        for i in range(len(A)-1):\\n            if maxleft[i] <= minright[i+1]:\\n                return i+1\\n ```\\n \\n **2 passes solution:**\\n skip the first maxleft pass, keep only the minright array,  and use maxleft as a variable:\\n ```\\n     def partitionDisjoint(self, A):\\n        minright = [A[-1]]*len(A)\\n        for i in range(len(A)-2,-1,-1):\\n            minright[i] = min(minright[i+1], A[i]) \\n\\n        maxleft = -float(\\'inf\\')\\n        for i in range(len(A)-1):\\n            maxleft = max(maxleft, A[i])  \\n            if maxleft <= minright[i+1]:\\n                return i+1\\n```\\t\\t\\t\\t\\n \\n **1 pass solution:**\\n use one more variable leftmax to moniter:\\n ```\\n     def partitionDisjoint(self, A):\\n        disjoint = 0\\n        curmax = leftmax = A[0]\\n        for i,num in enumerate(A):\\n            curmax = max(curmax, num)\\n            if num < leftmax:\\n                leftmax = curmax\\n                disjoint = i\\n        return disjoint + 1 \\n ```",
                "solutionTags": [],
                "code": "```\\n     def partitionDisjoint(self, A):\\n        maxleft = [A[0]]*len(A)\\n        for i in range(1,len(A)):\\n            maxleft[i] = max(maxleft[i-1], A[i])\\n            \\n        minright = [A[-1]]*len(A)\\n        for i in range(len(A)-2,-1,-1):\\n            minright[i] = min(minright[i+1], A[i]) \\n        \\n        for i in range(len(A)-1):\\n            if maxleft[i] <= minright[i+1]:\\n                return i+1\\n ```\n```\\n     def partitionDisjoint(self, A):\\n        minright = [A[-1]]*len(A)\\n        for i in range(len(A)-2,-1,-1):\\n            minright[i] = min(minright[i+1], A[i]) \\n\\n        maxleft = -float(\\'inf\\')\\n        for i in range(len(A)-1):\\n            maxleft = max(maxleft, A[i])  \\n            if maxleft <= minright[i+1]:\\n                return i+1\\n```\n```\\n     def partitionDisjoint(self, A):\\n        disjoint = 0\\n        curmax = leftmax = A[0]\\n        for i,num in enumerate(A):\\n            curmax = max(curmax, num)\\n            if num < leftmax:\\n                leftmax = curmax\\n                disjoint = i\\n        return disjoint + 1 \\n ```",
                "codeTag": "Python3"
            },
            {
                "id": 1150150,
                "title": "c-solution-o-n-time-o-1-space-single-traversal",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n        int minNum=a[0],maxNum=a[0];\\n        int index=0;\\n        for(int i=1;i<a.size();i++){\\n            if(a[i]<minNum){\\n                index=i;\\n                minNum=maxNum;\\n            }\\n            maxNum=max(a[i],maxNum);\\n        }\\n        return index+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n        int minNum=a[0],maxNum=a[0];\\n        int index=0;\\n        for(int i=1;i<a.size();i++){\\n            if(a[i]<minNum){\\n                index=i;\\n                minNum=maxNum;\\n            }\\n            maxNum=max(a[i],maxNum);\\n        }\\n        return index+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355198,
                "title": "partition-array-into-disjoint-intervals-detailed-explaination-java",
                "content": "**Intuition**\\n* We need to divide the array into 2 parts such that max element on the left side is smaller or equal to every element on the right\\n* We can maintain a `maxLeft` to keep track of this.\\n* Now if we come across any number `num[i]` which is smaller than the `maxLeft`, this  number cannot be part of the right side.\\n* Thus we need to update the `maxLeft` and the index of our partition `p`\\n* Regarding updating our index, its straight forward to update to `i` since the ith element has to be part of left side.\\n* Now what would be the updated `maxLeft`. This has to simply be the value of the maximum element encountered so far since this element was present before ith index so has to be the `maxLeft` now.\\n* Thus we will keep track of a `max` and update `maxLeft` to this value whenever we encounter a smaller number than `maxLeft`\\n\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int maxLeft = nums[0];\\n        int max = nums[0];\\n        int p = 0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<maxLeft){\\n                maxLeft = max;\\n                p=i;\\n            } else if(max<nums[i]) {\\n                max=nums[i];\\n            }\\n        }\\n        \\n        return p+1;\\n    }\\n}\\n```\\nPlease upvote this solution if it helps you in understanding so it can reach others as well.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int maxLeft = nums[0];\\n        int max = nums[0];\\n        int p = 0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<maxLeft){\\n                maxLeft = max;\\n                p=i;\\n            } else if(max<nums[i]) {\\n                max=nums[i];\\n            }\\n        }\\n        \\n        return p+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724809,
                "title": "o-n-solution-with-explanation",
                "content": "I find that many people post similar solutions as below but without a clear explanation.\\nThe key point is that we maintain two max values: 1. the global max till current element. 2. the max value of the `left part`. Each time when we check a new element `A[i]`, if `A[i]` is smaller than the max value of the current left part (defined by [0, leftEnd]), A[i] should be included into the left part and therefore, i becomes the new `leftEnd`. For the same reason, the new max value of the left part is the current max value `max`. Furthermore, we update the global max value each time when we check a new element A[i].\\n\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] A) {\\n        int maxLeft = A[0], max = A[0], leftEnd = 0;    \\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] < maxLeft) {\\n                leftEnd = i;\\n                maxLeft = max;\\n            }\\n            max = Math.max(max, A[i]);\\n        }\\n        return leftEnd+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] A) {\\n        int maxLeft = A[0], max = A[0], leftEnd = 0;    \\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] < maxLeft) {\\n                leftEnd = i;\\n                maxLeft = max;\\n            }\\n            max = Math.max(max, A[i]);\\n        }\\n        return leftEnd+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175842,
                "title": "java-easiest-simplest",
                "content": "```\\n    public int partitionDisjoint(int[] A) {\\n        int num=A[0];\\n        int size=0;\\n        int max=num;\\n        for(int i=1;i<A.length;i++)\\n        {\\n            max=Math.max(max,A[i]);\\n            if(A[i]<num)\\n            {\\n                num=max;\\n                size=i;\\n            }\\n        }\\n        return size+1;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public int partitionDisjoint(int[] A) {\\n        int num=A[0];\\n        int size=0;\\n        int max=num;\\n        for(int i=1;i<A.length;i++)\\n        {\\n            max=Math.max(max,A[i]);\\n            if(A[i]<num)\\n            {\\n                num=max;\\n                size=i;\\n            }\\n        }\\n        return size+1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1354475,
                "title": "partition-array-into-disjoint-intervals-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        int mini = nums[0];\\n        int maxi = nums[0];\\n        int ptr =0;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]<mini){\\n                ptr = i;\\n                mini =maxi;\\n            }\\n            maxi =max(nums[i],maxi); \\n        }\\n        return ptr+1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        int mini = nums[0];\\n        int maxi = nums[0];\\n        int ptr =0;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]<mini){\\n                ptr = i;\\n                mini =maxi;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1359686,
                "title": "python-best-solution-yet-explained-with-comments-to-make-life-easier-o-n-o-1",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Intuition(logic) is to find two maximums.\\n        One maximum is for left array and other maximum is for right array.\\n        \\n        But the condition is that, the right maximum should be such that, \\n        no element after that right maximum should be less than the left maximum. \\n        \\n        If there is any element after right maximum which is less than left maximum,\\n        that means there is another right maximum possible and therefore in that case assign\\n        left maximum to right maximum and keep searching the array for correct right\\n        maximum till the end.\\n        \"\"\"\\n        #start with both left maximum and right maximum with first element.\\n        left_max = right_max = nums[0]\\n        # our current index\\n        partition_ind = 0\\n        # Iterate from 1 to end of the array\\n        for i in range(1,len(nums)):\\n            #update right_max always after comparing with each nums\\n            #in order to find our correct right maximum\\n            right_max = max(nums[i], right_max)\\n            \"\"\"\\n\\t\\t\\tif current element is less than left maximum, that means this \\n            element must belong to the left subarray. \\n              * so our partition index will be updated to current index \\n              * and left maximum will be updated to right maximum. \\n             Why left maximum updated to right maximum ?\\n              Because when we find any element less than left_maximum, that \\n              means the right maximum which we had till now is not valid and we have\\n              to find the valid right maximum again while iterating through the end of the loop.\\n\\t\\t\\t\"\"\"\\n            if nums[i] < left_max:\\n                left_max = right_max\\n                partition_ind = i\\n        \\n        return partition_ind+1\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        \"\"\"\\n        Intuition(logic) is to find two maximums.\\n        One maximum is for left array and other maximum is for right array.\\n        \\n        But the condition is that, the right maximum should be such that, \\n        no element after that right maximum should be less than the left maximum. \\n        \\n        If there is any element after right maximum which is less than left maximum,\\n        that means there is another right maximum possible and therefore in that case assign\\n        left maximum to right maximum and keep searching the array for correct right\\n        maximum till the end.\\n        \"\"\"\\n        #start with both left maximum and right maximum with first element.\\n        left_max = right_max = nums[0]\\n        # our current index\\n        partition_ind = 0\\n        # Iterate from 1 to end of the array\\n        for i in range(1,len(nums)):\\n            #update right_max always after comparing with each nums\\n            #in order to find our correct right maximum\\n            right_max = max(nums[i], right_max)\\n            \"\"\"\\n\\t\\t\\tif current element is less than left maximum, that means this \\n            element must belong to the left subarray. \\n              * so our partition index will be updated to current index \\n              * and left maximum will be updated to right maximum. \\n             Why left maximum updated to right maximum ?\\n              Because when we find any element less than left_maximum, that \\n              means the right maximum which we had till now is not valid and we have\\n              to find the valid right maximum again while iterating through the end of the loop.\\n\\t\\t\\t\"\"\"\\n            if nums[i] < left_max:\\n                left_max = right_max\\n                partition_ind = i\\n        \\n        return partition_ind+1\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354395,
                "title": "partition-array-into-disjoint-intervals-c-with-approach",
                "content": "# **APPROACH:**\\nSuppose we have an array A, we have to partition it into two subarrays left and right such that \\u2212\\n1. Every element in left subarray is `less than or equal` to every element in right subarray.\\n2. Left and right subarrays are `non-empty`.\\n3. Left subarray has the `smallest possible size`.\\n\\nWe have to find the `length of left` after such a partitioning. It is guaranteed that such a partitioning exists.\\n# TEST CASE\\n* If the input is like `[5,0,3,8,6]` \\n* The output will be 3\\n\\t* left array will be [5,0,3] \\n\\t* Right subarray will be [8,6].\\n# **ALGORITHM**\\nTo solve this, we will follow these steps \\u2212\\n* n := size of A, create an array mx of size n\\n* minVal := last element of A\\n* mx[0] := A[0]\\n* for i in range 1 to n \\u2013 1\\n\\t* mx[i] := max of A[i] and A[i \\u2013 1]\\n* ans := size of A \\u2013 1\\n* for i in range n \\u2013 1 down to 1\\n\\t* minVal := minimum of minVal and A[i]\\n\\t* if minVal >= mx[i \\u2013 1], then ans := i\\n* return ans\\n\\n# **SOLUTION:**\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size() ;\\n        vector <int> mx(n);\\n        int minVal = nums[n - 1] ;\\n        mx[0] = nums[0] ;\\n        for(int i = 1; i < n; i++)\\n        {\\n            mx[i] = max(nums[i], mx[i - 1]) ;\\n        }\\n        int ans = n - 1 ;\\n        for(int i = n - 1 ; i >= 1 ; i--)\\n        {\\n            minVal = min(minVal, nums[i]);\\n            if(minVal >= mx[i - 1])\\n            {\\n                ans = i ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```\\n**TIME COMPLEXITY: O(n)\\nSPACE COMPLEXITY: O(1)**\\nI\\'ll try different approaches too and update this.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size() ;\\n        vector <int> mx(n);\\n        int minVal = nums[n - 1] ;\\n        mx[0] = nums[0] ;\\n        for(int i = 1; i < n; i++)\\n        {\\n            mx[i] = max(nums[i], mx[i - 1]) ;\\n        }\\n        int ans = n - 1 ;\\n        for(int i = n - 1 ; i >= 1 ; i--)\\n        {\\n            minVal = min(minVal, nums[i]);\\n            if(minVal >= mx[i - 1])\\n            {\\n                ans = i ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535475,
                "title": "super-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        vector<int> mx(A.size()), mi(A.size());\\n        mx[0]=A[0]; mi[A.size()-1]=A.back();\\n        for(int i=1; i<A.size(); i++)\\n            mx[i]=max(A[i], mx[i-1]);\\n        for(int i=A.size()-2; i>=0; i--)\\n            mi[i]=min(A[i], mi[i+1]);\\n        int i;\\n        for(i=0; i<A.size()-1; i++)\\n            if(mx[i]<=mi[i+1])\\n                break;\\n        return i+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        vector<int> mx(A.size()), mi(A.size());\\n        mx[0]=A[0]; mi[A.size()-1]=A.back();\\n        for(int i=1; i<A.size(); i++)\\n            mx[i]=max(A[i], mx[i-1]);\\n        for(int i=A.size()-2; i>=0; i--)\\n            mi[i]=min(A[i], mi[i+1]);\\n        int i;\\n        for(i=0; i<A.size()-1; i++)\\n            if(mx[i]<=mi[i+1])\\n                break;\\n        return i+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120556,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach 1 : Using Two Extra arrays***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // store the maximum element from the left side till index i\\n        \\n        vector<int> left_max(n, 0);\\n        \\n        // store the minimum element from right side till index i\\n        \\n        vector<int> right_min(n, 0);\\n        \\n        // fill the left_max array\\n        \\n        left_max[0] = nums[0];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            left_max[i] = max(left_max[i - 1], nums[i]);\\n        }\\n        \\n        // fill the right_min array\\n        \\n        right_min[n - 1] = nums[n - 1];\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            right_min[i] = min(right_min[i + 1], nums[i]);\\n        }\\n        \\n        // count the size of left array\\n        \\n        int count = 1;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(left_max[i - 1] > right_min[i])\\n            {\\n                count++;\\n            }\\n            else\\n                break;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n* ***Approach 2 : Using Single Extra Array***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // store the minimum element from right side till index i\\n        \\n        vector<int> right_min(n, 0);\\n        \\n        // fill the right_min array\\n        \\n        right_min[n - 1] = nums[n - 1];\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            right_min[i] = min(right_min[i + 1], nums[i]);\\n        }\\n        \\n        // store the maximum element from the left side till index i\\n        \\n        int left_max = nums[0];\\n        \\n        // count the size of left array\\n        \\n        int count = 1;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(left_max > right_min[i])\\n            {\\n                count++;\\n                \\n                left_max = max(left_max, nums[i]);\\n            }\\n            else\\n                break;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n* ***Approach 3 : Without Using Any Extra Array***\\n\\n* ***Time Complexity : O(N)***\\n\\n* ***Space Complexity : O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int ans = 0;\\n        \\n        int curr_max = nums[0];\\n        \\n        int possible_max = nums[0];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] < curr_max)\\n            {\\n                ans = i;\\n                \\n                curr_max = possible_max;\\n            }\\n            else\\n            {\\n                possible_max = max(possible_max, nums[i]);\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // store the maximum element from the left side till index i\\n        \\n        vector<int> left_max(n, 0);\\n        \\n        // store the minimum element from right side till index i\\n        \\n        vector<int> right_min(n, 0);\\n        \\n        // fill the left_max array\\n        \\n        left_max[0] = nums[0];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            left_max[i] = max(left_max[i - 1], nums[i]);\\n        }\\n        \\n        // fill the right_min array\\n        \\n        right_min[n - 1] = nums[n - 1];\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            right_min[i] = min(right_min[i + 1], nums[i]);\\n        }\\n        \\n        // count the size of left array\\n        \\n        int count = 1;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(left_max[i - 1] > right_min[i])\\n            {\\n                count++;\\n            }\\n            else\\n                break;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        // store the minimum element from right side till index i\\n        \\n        vector<int> right_min(n, 0);\\n        \\n        // fill the right_min array\\n        \\n        right_min[n - 1] = nums[n - 1];\\n        \\n        for(int i = n - 2; i >= 0; i--)\\n        {\\n            right_min[i] = min(right_min[i + 1], nums[i]);\\n        }\\n        \\n        // store the maximum element from the left side till index i\\n        \\n        int left_max = nums[0];\\n        \\n        // count the size of left array\\n        \\n        int count = 1;\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(left_max > right_min[i])\\n            {\\n                count++;\\n                \\n                left_max = max(left_max, nums[i]);\\n            }\\n            else\\n                break;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int ans = 0;\\n        \\n        int curr_max = nums[0];\\n        \\n        int possible_max = nums[0];\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] < curr_max)\\n            {\\n                ans = i;\\n                \\n                curr_max = possible_max;\\n            }\\n            else\\n            {\\n                possible_max = max(possible_max, nums[i]);\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354844,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> maxl(n),minr(n);\\n        int maxll=-1;\\n        for(int i=0;i<n;i++){\\n            maxll=max(maxll,nums[i]);\\n            maxl[i]=maxll;\\n        }\\n        int minrr = INT_MAX;\\n        for(int i=n-1;i>=0;i--){\\n            minrr=min(minrr,nums[i]);\\n            minr[i]=minrr;\\n        }\\n        for(int i=0;i+1<n;i++){\\n            if(maxl[i]<=minr[i+1]){\\n                return (i+1);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> maxl(n),minr(n);\\n        int maxll=-1;\\n        for(int i=0;i<n;i++){\\n            maxll=max(maxll,nums[i]);\\n            maxl[i]=maxll;\\n        }\\n        int minrr = INT_MAX;\\n        for(int i=n-1;i>=0;i--){\\n            minrr=min(minrr,nums[i]);\\n            minr[i]=minrr;\\n        }\\n        for(int i=0;i+1<n;i++){\\n            if(maxl[i]<=minr[i+1]){\\n                return (i+1);\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354704,
                "title": "partition-array-into-disjoint-intervals-brute-force-thinking-commented-c",
                "content": "```\\nint partitionDisjoint(vector<int>& nums) {\\n        int n = size(nums);\\n        //let\\'s intialsise ans = n , and minele in right subarray which is empty right now to be INF.\\n        int ans = n ,i = n-1,j =n-1,minele = 10000000;\\n        \\n        //will try reduce left array up to size 1\\n        while(i > 0){\\n            //reduce size of left array by 1 and now ith ele will be part of right\\n            // update minele\\n            minele = min(nums[i],minele);\\n            \\n            //now traverse and check the condition\\n            int tempele = minele , rc =-1,rcmin; j = i-1;\\n            \\n            while(j >= 0){\\n                //if found some ele greater we need to reduce left subarray up to that, so rc the index\\n                if(nums[j] > minele){\\n                    rc = j;\\n                    minele = tempele;\\n                }\\n                tempele = min(nums[j--],tempele);\\n            }\\n            \\n            //if condition satisfied dec ans by 1 and continue\\n            if(rc == -1){\\n                ans--;\\n                i--;\\n                continue;\\n            }\\n            //if left array reduce to zero break\\n            else if(rc == 0){\\n                break;\\n            }\\n            //o.w. include the array in right up to recorded index \\n            ans = ans-(i-rc);\\n            i = rc;\\n        }\\n        return ans;\\n    }\\n```\\n\\n\\n**Update(optimized approach)**\\nInstead of traversing from back reducing the size, actually we can start from very left and , \\nas we would getting first the minimum size we don\\'t need to worry about any other possible \\nmin size, just we need to check the condition and update the ans.\\n\\n\\n```\\nint partitionDisjoint(vector<int>& nums) {\\n        int n = size(nums) , ans = 1;\\n        \\n        //let\\'s have a maxm which store left array max element\\n        // and tempmax which will store curr max of traversing array.\\n        int tempMax = nums[0];\\n        int maxm = tempMax;\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            //if someone is less than maxm , means we need to include in our left subarray\\n            //let\\'s include and update the ans\\n            if(maxm > nums[i]){\\n                maxm = tempMax;\\n                ans = i+1;\\n            }\\n            //update curr max;\\n            tempMax = max(tempMax, nums[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint partitionDisjoint(vector<int>& nums) {\\n        int n = size(nums);\\n        //let\\'s intialsise ans = n , and minele in right subarray which is empty right now to be INF.\\n        int ans = n ,i = n-1,j =n-1,minele = 10000000;\\n        \\n        //will try reduce left array up to size 1\\n        while(i > 0){\\n            //reduce size of left array by 1 and now ith ele will be part of right\\n            // update minele\\n            minele = min(nums[i],minele);\\n            \\n            //now traverse and check the condition\\n            int tempele = minele , rc =-1,rcmin; j = i-1;\\n            \\n            while(j >= 0){\\n                //if found some ele greater we need to reduce left subarray up to that, so rc the index\\n                if(nums[j] > minele){\\n                    rc = j;\\n                    minele = tempele;\\n                }\\n                tempele = min(nums[j--],tempele);\\n            }\\n            \\n            //if condition satisfied dec ans by 1 and continue\\n            if(rc == -1){\\n                ans--;\\n                i--;\\n                continue;\\n            }\\n            //if left array reduce to zero break\\n            else if(rc == 0){\\n                break;\\n            }\\n            //o.w. include the array in right up to recorded index \\n            ans = ans-(i-rc);\\n            i = rc;\\n        }\\n        return ans;\\n    }\\n```\n```\\nint partitionDisjoint(vector<int>& nums) {\\n        int n = size(nums) , ans = 1;\\n        \\n        //let\\'s have a maxm which store left array max element\\n        // and tempmax which will store curr max of traversing array.\\n        int tempMax = nums[0];\\n        int maxm = tempMax;\\n        \\n        for(int i=1;i<n;i++){\\n            \\n            //if someone is less than maxm , means we need to include in our left subarray\\n            //let\\'s include and update the ans\\n            if(maxm > nums[i]){\\n                maxm = tempMax;\\n                ans = i+1;\\n            }\\n            //update curr max;\\n            tempMax = max(tempMax, nums[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 833302,
                "title": "python-short-and-simple-explained-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        min_ = A.index(min(A))\\n        # min of list is first - we can leave only it in the left\\n        if min_ == 0:\\n            return 1\\n        \\n        # find minimum index to end first partition\\n        max_before_min = A.index(max(A[:min_]))\\n        while len(A[min_+1:])>0 and min(A[min_+1:]) < A[max_before_min]:\\n            min_ = len(A) - A[::-1].index( min(A[min_+1:])) - 1\\n            max_before_min = A.index(max(A[:min_]))\\n\\n        # get right index to return\\n        i = len(A)-1\\n        while i >= max_before_min and A[i] >= A[max_before_min]:\\n            i-=1\\n        \\n        return i+1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        min_ = A.index(min(A))\\n        # min of list is first - we can leave only it in the left\\n        if min_ == 0:\\n            return 1\\n        \\n        # find minimum index to end first partition\\n        max_before_min = A.index(max(A[:min_]))\\n        while len(A[min_+1:])>0 and min(A[min_+1:]) < A[max_before_min]:\\n            min_ = len(A) - A[::-1].index( min(A[min_+1:])) - 1\\n            max_before_min = A.index(max(A[:min_]))\\n\\n        # get right index to return\\n        i = len(A)-1\\n        while i >= max_before_min and A[i] >= A[max_before_min]:\\n            i-=1\\n        \\n        return i+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2341951,
                "title": "really-a-medium-level-simple-code-c",
                "content": "```\\n int partitionDisjoint(vector<int>& nums) {\\n        \\n        int n=nums.size(),left[n],right[n];\\n        \\n// Step 1 left se maximum nikalo .left[i]=max from left till i\\n        left[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            left[i]=max(left[i-1],nums[i]);\\n        \\n// Step 2 right se min nikalo .right[i]=min from end to ith index   \\n        right[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            right[i]=min(right[i+1],nums[i]);\\n     \\n// Step 3 kaunsa i esa jaha tk ka max chota hai (i+1) wale minimum se vo hi answer hai \\n        for(int i=0;i<n-1;i++)\\n            if(left[i]<=right[i+1])\\n                return i+1;\\n        \\n        return -1;  //this never gets executed as partition is guaranteed\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n int partitionDisjoint(vector<int>& nums) {\\n        \\n        int n=nums.size(),left[n],right[n];\\n        \\n// Step 1 left se maximum nikalo .left[i]=max from left till i\\n        left[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            left[i]=max(left[i-1],nums[i]);\\n        \\n// Step 2 right se min nikalo .right[i]=min from end to ith index   \\n        right[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            right[i]=min(right[i+1],nums[i]);\\n     \\n// Step 3 kaunsa i esa jaha tk ka max chota hai (i+1) wale minimum se vo hi answer hai \\n        for(int i=0;i<n-1;i++)\\n            if(left[i]<=right[i+1])\\n                return i+1;\\n        \\n        return -1;  //this never gets executed as partition is guaranteed\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1356198,
                "title": "c-easy-solution-s-c-o-1-t-c-o-n",
                "content": "```\\nclass Solution { \\n\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int leftSize = 1, n=nums.size();\\n        int maxLeft = nums[0], mx = nums[0];\\n        \\n        for(int i=1; i<n-1; i++){\\n            if(nums[i] < maxLeft){\\n                leftSize = i+1;\\n                maxLeft = mx;\\n            }\\n              mx = max(mx,nums[i]);\\n        }\\n        return leftSize;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution { \\n\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int leftSize = 1, n=nums.size();\\n        int maxLeft = nums[0], mx = nums[0];\\n        \\n        for(int i=1; i<n-1; i++){\\n            if(nums[i] < maxLeft){\\n                leftSize = i+1;\\n                maxLeft = mx;\\n            }\\n              mx = max(mx,nums[i]);\\n        }\\n        return leftSize;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354779,
                "title": "partition-array-into-disjoint-intervals-java-solution-o-n",
                "content": "```\\npublic static int partitionDisjoint(int[] nums) {\\n\\t\\tint comparisonItem = nums[0];\\n\\t\\t// within this variable we will keep track of the largest number we found so far\\n\\t\\tint localMax = comparisonItem;\\n\\t\\t// result index\\n\\t\\tint partitionIdx = 0;\\n\\t\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\t\\t// when we find lower item in an array we update partitionIdx to reflect it\\n\\t\\t\\t// and also set out comparisonItem to the highest item we found prior to this item\\n\\t\\t\\tif (nums[i] < comparisonItem) {\\n\\t\\t\\t\\tpartitionIdx = i;\\n\\t\\t\\t\\tcomparisonItem = localMax;\\n\\t\\t\\t}\\n\\t\\t\\t// keep track of the largest item we seen so far\\n\\t\\t\\telse localMax = Math.max(localMax, nums[i]);\\n\\t\\t}\\n\\t\\t// as we are storing an index of the last item that belongs to the partition\\n\\t\\t// and arrays are indexed from 0 we need to increment the value\\n\\t\\treturn partitionIdx + 1;\\n\\t}\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic static int partitionDisjoint(int[] nums) {\\n\\t\\tint comparisonItem = nums[0];\\n\\t\\t// within this variable we will keep track of the largest number we found so far\\n\\t\\tint localMax = comparisonItem;\\n\\t\\t// result index\\n\\t\\tint partitionIdx = 0;\\n\\t\\tfor (int i = 1; i < nums.length; i++) {\\n\\t\\t\\t// when we find lower item in an array we update partitionIdx to reflect it\\n\\t\\t\\t// and also set out comparisonItem to the highest item we found prior to this item\\n\\t\\t\\tif (nums[i] < comparisonItem) {\\n\\t\\t\\t\\tpartitionIdx = i;\\n\\t\\t\\t\\tcomparisonItem = localMax;\\n\\t\\t\\t}\\n\\t\\t\\t// keep track of the largest item we seen so far\\n\\t\\t\\telse localMax = Math.max(localMax, nums[i]);\\n\\t\\t}\\n\\t\\t// as we are storing an index of the last item that belongs to the partition\\n\\t\\t// and arrays are indexed from 0 we need to increment the value\\n\\t\\treturn partitionIdx + 1;\\n\\t}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354707,
                "title": "c-solutions-using-fenwick-trees-and-greedy",
                "content": "**Method 1**\\n**Intuition and Approach:** We have to find the index where maximum element of the left half has to be less than or equal the minimum element of the right half. Basically, for current maximal element of the left half `curr`, if there exist elements greater than or equal to `curr` and the the count of these elements is equal to the size of the right half, the index you are at will always be the last element of the left half. Thus, simply return this index+1.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> fenw;\\n    int sum(int ind) {\\n        int sum=0;\\n        while(ind>0) {\\n            sum+=fenw[ind];\\n            ind-=ind&(-ind);\\n        }\\n        return sum;\\n    }\\n    void upd(int ind, int val) {\\n        while(ind<fenw.size()) {\\n            fenw[ind]+=val;\\n            ind+=ind&(-ind);\\n        }\\n    }\\n    int partitionDisjoint(vector<int>& nums) {\\n        fenw=vector<int>(1000007,0);\\n        int n=nums.size();\\n                \\n        int ref=-1;\\n        \\n        for(int i=0;i<n;i++) upd(nums[i]+1,1);\\n        \\n        int curr=0;\\n        for(int i=0;i<n;i++) {\\n            curr=max(curr,nums[i]);\\n            \\n            upd(nums[i]+1,-1);\\n            \\n            int ref=sum(1000006)-sum(curr);\\n            if(ref==n-i-1) return i+1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Time Complexity:** O(NLogN)\\n**Space Complexity:** O(N)\\n\\n**Method 2**\\n**Intuition and Approach:** We have to find the index where maximum element of the left half has to be less than or equal the minimum element of the right half. So this can be done greedily.\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> mn(n);\\n        \\n        mn.back()=nums.back();\\n        \\n        for(int i=n-2;i>=0;i--) {\\n            mn[i]=min(mn[i+1], nums[i]);\\n        }\\n        \\n        int curr=0;    \\n        for(int i=0;i<n-1;i++) {\\n            curr=max(curr,nums[i]);\\n            if(curr<=mn[i+1]) return i+1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Time Complexity:** O(N)\\n**Space Complexity:** O(N)\\n\\n**Ask your queries in the comment section.**\\n**Upvote if you liked!!**",
                "solutionTags": [
                    "Greedy",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> fenw;\\n    int sum(int ind) {\\n        int sum=0;\\n        while(ind>0) {\\n            sum+=fenw[ind];\\n            ind-=ind&(-ind);\\n        }\\n        return sum;\\n    }\\n    void upd(int ind, int val) {\\n        while(ind<fenw.size()) {\\n            fenw[ind]+=val;\\n            ind+=ind&(-ind);\\n        }\\n    }\\n    int partitionDisjoint(vector<int>& nums) {\\n        fenw=vector<int>(1000007,0);\\n        int n=nums.size();\\n                \\n        int ref=-1;\\n        \\n        for(int i=0;i<n;i++) upd(nums[i]+1,1);\\n        \\n        int curr=0;\\n        for(int i=0;i<n;i++) {\\n            curr=max(curr,nums[i]);\\n            \\n            upd(nums[i]+1,-1);\\n            \\n            int ref=sum(1000006)-sum(curr);\\n            if(ref==n-i-1) return i+1;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> mn(n);\\n        \\n        mn.back()=nums.back();\\n        \\n        for(int i=n-2;i>=0;i--) {\\n            mn[i]=min(mn[i+1], nums[i]);\\n        }\\n        \\n        int curr=0;    \\n        for(int i=0;i<n-1;i++) {\\n            curr=max(curr,nums[i]);\\n            if(curr<=mn[i+1]) return i+1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354639,
                "title": "java-solution-explained-with-comments",
                "content": "Basically the approach is to find the first position in the array such that the maximum element in the array to its left should be greater than or equal to the minimum element in the array to its right.\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int n = nums.length;\\n        int[] arr = new int[n]; //this array is used to maintain the maximum till now from left and minimum till now from right while traversing from left and right respectively\\n        arr[n-1] = nums[n-1];\\n        for (int i = n-2; i >= 0; i--) { //finding the minimum till this position from right\\n            arr[i] = (nums[i] < arr[i+1]) ? nums[i] : arr[i+1]; \\n        }\\n        arr[0] = nums[0];\\n        int res = 0;\\n        for(int i = 1; i < n; i++) {            \\n            if(arr[i] >= arr[i-1]) { //checking whether the maximum to i\\'s left is greater than or equal to minimum to i\\'s right\\n                res = i; \\n                break; //break if found since we need to find the smallest partition possible\\n            }\\n            arr[i] = (nums[i] > arr[i-1]) ? nums[i] : arr[i-1]; //update the maximum till this position from left\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n\\t\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int n = nums.length;\\n        int[] arr = new int[n]; //this array is used to maintain the maximum till now from left and minimum till now from right while traversing from left and right respectively\\n        arr[n-1] = nums[n-1];\\n        for (int i = n-2; i >= 0; i--) { //finding the minimum till this position from right\\n            arr[i] = (nums[i] < arr[i+1]) ? nums[i] : arr[i+1]; \\n        }\\n        arr[0] = nums[0];\\n        int res = 0;\\n        for(int i = 1; i < n; i++) {            \\n            if(arr[i] >= arr[i-1]) { //checking whether the maximum to i\\'s left is greater than or equal to minimum to i\\'s right\\n                res = i; \\n                break; //break if found since we need to find the smallest partition possible\\n            }\\n            arr[i] = (nums[i] > arr[i-1]) ? nums[i] : arr[i-1]; //update the maximum till this position from left\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 800421,
                "title": "c-solution-three-pass-two-pass-one-pass",
                "content": "three pass\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        int len = A.size();\\n        vector<int> from_left_max(len, A[0]);\\n        vector<int> from_right_min(len, A[len-1]);\\n        for (int i = 1; i < len; i++) {\\n            from_left_max[i] = max(from_left_max[i-1], A[i]);\\n        }\\n        for (int i = len-2; i >= 0; i--) {\\n            from_right_min[i] = min(from_right_min[i+1], A[i]);\\n        }\\n        for (int i = 0; i < len; i++) {\\n            if (from_left_max[i] <= from_right_min[i+1]) {\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\ntwo pass\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        int len = A.size();\\n        vector<int> from_left_max(len, A[0]);\\n        for (int i = 1; i < len; i++) {\\n            from_left_max[i] = max(from_left_max[i-1], A[i]);\\n        }\\n       int right_min = A[len-1];\\n        int res = -1;\\n        for (int i = len-1; i > 0; i--) {\\n            right_min = min(right_min, A[i]);\\n            res = from_left_max[i-1]<=right_min ? i : res;\\n        }\\n        return res;\\n    }\\n};\\n```\\none pass\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        int local_max = A[0], global_max = A[0];\\n        int partition = 0;\\n        for (int i = 1; i < A.size(); i++) {\\n            if (A[i] < local_max) {\\n                partition = i;\\n                local_max = global_max;\\n            } else {\\n                global_max = max(global_max, A[i]);\\n            }\\n        }\\n        return partition+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        int len = A.size();\\n        vector<int> from_left_max(len, A[0]);\\n        vector<int> from_right_min(len, A[len-1]);\\n        for (int i = 1; i < len; i++) {\\n            from_left_max[i] = max(from_left_max[i-1], A[i]);\\n        }\\n        for (int i = len-2; i >= 0; i--) {\\n            from_right_min[i] = min(from_right_min[i+1], A[i]);\\n        }\\n        for (int i = 0; i < len; i++) {\\n            if (from_left_max[i] <= from_right_min[i+1]) {\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        int len = A.size();\\n        vector<int> from_left_max(len, A[0]);\\n        for (int i = 1; i < len; i++) {\\n            from_left_max[i] = max(from_left_max[i-1], A[i]);\\n        }\\n       int right_min = A[len-1];\\n        int res = -1;\\n        for (int i = len-1; i > 0; i--) {\\n            right_min = min(right_min, A[i]);\\n            res = from_left_max[i-1]<=right_min ? i : res;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        int local_max = A[0], global_max = A[0];\\n        int partition = 0;\\n        for (int i = 1; i < A.size(); i++) {\\n            if (A[i] < local_max) {\\n                partition = i;\\n                local_max = global_max;\\n            } else {\\n                global_max = max(global_max, A[i]);\\n            }\\n        }\\n        return partition+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424357,
                "title": "c-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int PartitionDisjoint(int[] nums) \\n    {\\n        int splitIndex = 0, maxAtSplitIndex = nums[0], maxSoFar = nums[0];    \\n        for (int i=0; i<nums.Length; i++) \\n        {\\n            if (nums[i] < maxAtSplitIndex) \\n            {   \\n                splitIndex = i;    \\n                maxAtSplitIndex = maxSoFar; \\n            } \\n            \\n            maxSoFar = Math.Max(maxSoFar, nums[i]);\\n        }\\n        \\n        return splitIndex + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution \\n{\\n    public int PartitionDisjoint(int[] nums) \\n    {\\n        int splitIndex = 0, maxAtSplitIndex = nums[0], maxSoFar = nums[0];    \\n        for (int i=0; i<nums.Length; i++) \\n        {\\n            if (nums[i] < maxAtSplitIndex) \\n            {   \\n                splitIndex = i;    \\n                maxAtSplitIndex = maxSoFar; \\n            } \\n            \\n            maxSoFar = Math.Max(maxSoFar, nums[i]);\\n        }\\n        \\n        return splitIndex + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175907,
                "title": "o-n-one-pass-solution",
                "content": "endIndex is the leftmost index of left part\\nmaxIndex is max number\\'s we encountered so far\\nmaxCurrIndex is the max number\\'s index in the left part\\n\\n```\\npublic class Solution {\\n    public int PartitionDisjoint(int[] A) {\\n        \\n        int maxCurrIndex = 0;\\n        int maxIndex = 0;\\n        int endIndex = 0;\\n        \\n        \\n        for(int i=1;i<A.Length;i++){\\n            \\n            if(A[i] < A[maxCurrIndex]){\\n                maxCurrIndex = maxIndex;\\n                endIndex = i;\\n            }else if(A[i] > A[maxIndex]){\\n                maxIndex = i;\\n            }\\n            \\n        }\\n        return endIndex+1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int PartitionDisjoint(int[] A) {\\n        \\n        int maxCurrIndex = 0;\\n        int maxIndex = 0;\\n        int endIndex = 0;\\n        \\n        \\n        for(int i=1;i<A.Length;i++){\\n            \\n            if(A[i] < A[maxCurrIndex]){\\n                maxCurrIndex = maxIndex;\\n                endIndex = i;\\n            }else if(A[i] > A[maxIndex]){\\n                maxIndex = i;\\n            }\\n            \\n        }\\n        return endIndex+1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3705193,
                "title": "easy-c-solution-beginner-friendly-approach-o-n-time-complexity",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n        int minNum=a[0],maxNum=a[0], index=0;\\n        for(int i=1;i<a.size();i++){\\n            if(a[i]<minNum){ \\n                index=i;\\n                minNum=maxNum;  \\n            }\\n            maxNum=max(a[i],maxNum);\\n        }\\n        return index+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n        int minNum=a[0],maxNum=a[0], index=0;\\n        for(int i=1;i<a.size();i++){\\n            if(a[i]<minNum){ \\n                index=i;\\n                minNum=maxNum;  \\n            }\\n            maxNum=max(a[i],maxNum);\\n        }\\n        return index+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700023,
                "title": "very-simple-c",
                "content": "\\n# if it Helps You. Please Upvote Me...\\uD83E\\uDDE1\\uD83E\\uDD0D\\uD83D\\uDC9A\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the **suffix array with the minimum value** and count the number of indexes from the left side **while maximum(0 to ind) > suffix minimum at ind**.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& arr) {\\n\\n        int n = arr.size(),mx = INT_MIN,mn = INT_MAX;\\n        vector<int> suffmin(n);\\n        for(int i = n-1;i>=0;i--)\\n        {\\n             suffmin[i] = mn;\\n             mn = min(mn,arr[i]);\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            mx = max(mx,arr[i]);\\n            if(mx<=suffmin[i]) return i+1;\\n        }\\n        return n;   \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/69735656-2a4f-4ead-95a7-b0ad3739a7d1_1688120016.445156.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& arr) {\\n\\n        int n = arr.size(),mx = INT_MIN,mn = INT_MAX;\\n        vector<int> suffmin(n);\\n        for(int i = n-1;i>=0;i--)\\n        {\\n             suffmin[i] = mn;\\n             mn = min(mn,arr[i]);\\n        }\\n        for(int i = 0;i<n;i++)\\n        {\\n            mx = max(mx,arr[i]);\\n            if(mx<=suffmin[i]) return i+1;\\n        }\\n        return n;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496228,
                "title": "java-tc-o-n-sc-o-1-with-comments-on-every-line",
                "content": "Ok, this problem was harder than I expected it to be! (or maybe I\\'m dumb)\\nAdded lots of comments so anyone can read it and understand it in one go.\\n\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftmax=nums[0]; //max value in left part of the array\\n        int max=nums[0]; //absolute max value in the already traversed part of the array\\n        int length=1; //minimum length is 1\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<leftmax){ //if current element is less than the max value in left part of the array\\n                length=i+1; //increase length by 1 ie extend left array to index i\\n                leftmax=max; //assign the absolute max value to left max because we may have already traversed past a value greater than leftmax but assumed it was in the right part!! luckily we are storing it in the max variable\\n            } else {\\n                max = Math.max(nums[i],max); //update absolute max & stop left there\\n            }\\n        }\\n        return length; //don\\'t add 1 here as it\\'s possible it will never get updated in the for loop and will return a value of 2 instead of expected 1!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftmax=nums[0]; //max value in left part of the array\\n        int max=nums[0]; //absolute max value in the already traversed part of the array\\n        int length=1; //minimum length is 1\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<leftmax){ //if current element is less than the max value in left part of the array\\n                length=i+1; //increase length by 1 ie extend left array to index i\\n                leftmax=max; //assign the absolute max value to left max because we may have already traversed past a value greater than leftmax but assumed it was in the right part!! luckily we are storing it in the max variable\\n            } else {\\n                max = Math.max(nums[i],max); //update absolute max & stop left there\\n            }\\n        }\\n        return length; //don\\'t add 1 here as it\\'s possible it will never get updated in the for loop and will return a value of 2 instead of expected 1!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1408556,
                "title": "java-linear-traversal-solution-o-n-time-and-space-in-1ms",
                "content": "```\\nclass Solution {\\n    int max, size;\\n    int[] nums;\\n    public int partitionDisjoint(int[] nums) {\\n        int partition = 1;\\n        size = nums.length;\\n        this.nums = nums;\\n        max = nums[0];\\n        int index = findGreaterIndex(max, 0), i = index;\\n        while(i < size) {\\n            if(rightPartitionCheck(i)) \\n                return i;\\n            max = nums[i];\\n            i = findGreaterIndex(max, i);\\n        }\\n        return 1;\\n    }\\n    // Check if right partition contains some smaller elements than the max value in left partition.\\n    public boolean rightPartitionCheck(int partition) {\\n        for(int i = partition; i<size; i++) {\\n            if(nums[i] < max) \\n                return false;\\n        }\\n        return true;\\n    }\\n    // Find the next greater integer than current value starting from index.\\n    public int findGreaterIndex(int val, int index) {\\n        for(int i = index+1; i<size; i++) {\\n            if(nums[i] >= val)\\n                return i;\\n        }\\n        return index+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max, size;\\n    int[] nums;\\n    public int partitionDisjoint(int[] nums) {\\n        int partition = 1;\\n        size = nums.length;\\n        this.nums = nums;\\n        max = nums[0];\\n        int index = findGreaterIndex(max, 0), i = index;\\n        while(i < size) {\\n            if(rightPartitionCheck(i)) \\n                return i;\\n            max = nums[i];\\n            i = findGreaterIndex(max, i);\\n        }\\n        return 1;\\n    }\\n    // Check if right partition contains some smaller elements than the max value in left partition.\\n    public boolean rightPartitionCheck(int partition) {\\n        for(int i = partition; i<size; i++) {\\n            if(nums[i] < max) \\n                return false;\\n        }\\n        return true;\\n    }\\n    // Find the next greater integer than current value starting from index.\\n    public int findGreaterIndex(int val, int index) {\\n        for(int i = index+1; i<size; i++) {\\n            if(nums[i] >= val)\\n                return i;\\n        }\\n        return index+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363481,
                "title": "python-easy-solution-with-o-n-time-complexity",
                "content": "**Code**:\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        left_max = nums[0]\\n        overall_max = nums[0]\\n        pivot = 0\\n        for i,n in enumerate(nums):\\n            if n<left_max:\\n                pivot = i\\n                left_max = overall_max\\n            elif n>overall_max:\\n                overall_max = n\\n        return pivot+1\\n```\\n\\nHere, I will explain all three variables.\\nleft_max: It is the maximum number of the left array.\\noverall_max: It is the maximum number of input array.\\npivot: It indicates the rightmost index of left array.\\n\\nIf you do not understand anything then comment below.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        left_max = nums[0]\\n        overall_max = nums[0]\\n        pivot = 0\\n        for i,n in enumerate(nums):\\n            if n<left_max:\\n                pivot = i\\n                left_max = overall_max\\n            elif n>overall_max:\\n                overall_max = n\\n        return pivot+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355933,
                "title": "python-o-n-o-1-short-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        leftMax = nums[0]\\n        curMax = nums[0]\\n        ans = 1\\n        for i, num in enumerate(nums):\\n\\t\\t\\t# If current number is smaller than left maximum, the answer is no longer valid.\\n\\t\\t\\t# Now the current index is the last index of left and the maximum is now left maximum.\\n            if num < leftMax:\\n                ans = i+1  \\n                leftMax = curMax\\n\\t\\t\\t# Update the current maximum\\n            curMax = max(curMax, num)\\n\\n        return ans\\n```\\nTime complexity O(n)\\nSpace compexity O(1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        leftMax = nums[0]\\n        curMax = nums[0]\\n        ans = 1\\n        for i, num in enumerate(nums):\\n\\t\\t\\t# If current number is smaller than left maximum, the answer is no longer valid.\\n\\t\\t\\t# Now the current index is the last index of left and the maximum is now left maximum.\\n            if num < leftMax:\\n                ans = i+1  \\n                leftMax = curMax\\n\\t\\t\\t# Update the current maximum\\n            curMax = max(curMax, num)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355922,
                "title": "c-o-n-faster-than-99-74",
                "content": "```\\nint partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n\\t\\t//minr[i] will contain minimum element from i to n\\n        vector<int> minr(n);\\n        int MIN=INT_MAX;\\n        minr[n-1]=nums[n-1];\\n\\t\\t// To calculate minr values\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(MIN>nums[i]) MIN=nums[i];\\n            minr[i]=MIN;\\n        }\\n        int flag=0,count=0;\\n        int MAX=INT_MIN;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(flag!=0) break;\\n            if(MAX<nums[i]) MAX=nums[i];\\n            if(MAX<=minr[i+1]) flag=1;\\n            count++;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n\\t\\t//minr[i] will contain minimum element from i to n\\n        vector<int> minr(n);\\n        int MIN=INT_MAX;\\n        minr[n-1]=nums[n-1];\\n\\t\\t// To calculate minr values\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(MIN>nums[i]) MIN=nums[i];\\n            minr[i]=MIN;\\n        }\\n        int flag=0,count=0;\\n        int MAX=INT_MIN;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(flag!=0) break;\\n            if(MAX<nums[i]) MAX=nums[i];\\n            if(MAX<=minr[i+1]) flag=1;\\n            count++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1355501,
                "title": "java-easy-to-read-o-n-faster-than-100",
                "content": "We will take two variable - one to track left array maximum(**maxToUpdateIfAnsIndexUpdates**) and one for partion of left and right subarray(**maxToPartition**)\\n\\nconsidering 0th element as current maximum number and iterating as we encounter number less than that we will partition at that element(i index) and update current maximum(maxToPartition) to maximum till now(maxToUpdateIfAnsIndexUpdates)\\n\\nwe will continue above step till end of the array\\n\\nwe will store partion index in ansIndex and return partion index + 1 as answer (as index starts from 0)\\n \\n Hope this helps, please comment if you have any doubt or can improve my solution. Have a nice day!\\n\\n```\\n    public int partitionDisjoint(int[] nums) {\\n        int n = nums.length; \\n        int ansIndex = 0;\\n\\n        int maxToPartition = nums[0];\\n        int maxToUpdateIfAnsIndexUpdates = nums[0];\\n        \\n        for(int i=0;i<n;i++){\\n\\t\\t\\n            maxToUpdateIfAnsIndexUpdates = Math.max(maxToUpdateIfAnsIndexUpdates,nums[i]);\\n            \\n            if(nums[i]<maxToPartition){\\n                ansIndex = i;\\n                maxToPartition = maxToUpdateIfAnsIndexUpdates;\\n            }\\n        }\\n         \\n        return ansIndex + 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int partitionDisjoint(int[] nums) {\\n        int n = nums.length; \\n        int ansIndex = 0;\\n\\n        int maxToPartition = nums[0];\\n        int maxToUpdateIfAnsIndexUpdates = nums[0];\\n        \\n        for(int i=0;i<n;i++){\\n\\t\\t\\n            maxToUpdateIfAnsIndexUpdates = Math.max(maxToUpdateIfAnsIndexUpdates,nums[i]);\\n            \\n            if(nums[i]<maxToPartition){\\n                ansIndex = i;\\n                maxToPartition = maxToUpdateIfAnsIndexUpdates;\\n            }\\n        }\\n         \\n        return ansIndex + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1355372,
                "title": "c-3-approaches-brute-force-to-optimal-to-one-iteration-using-similar-concept-of-leetcode-768",
                "content": "```\\n/*\\n    If you notice Approach-2 below , it\\'s Similar to Qn (Leetcode 768 - Max Chunks To Make Sorted II)\\n    Link : https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Arrays/Max%20Chunks%20To%20Make%20Sorted%20II.cpp\\n*/\\n\\n//Approach-1 (Brute Force : O(n^2) time)\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int maxE = nums[0];\\n        \\n        for(int i = 0; i<n; i++) {\\n            maxE = max(maxE, nums[i]);\\n            int j = i+1;\\n            for(; j<n; j++) {\\n                if(nums[j] < maxE)\\n                    break;\\n            }\\n            if(j == n)\\n                return i+1;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Using a very popular concept min-max track from left and right)\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        /*\\n            When the maximum of left-partition is less than minimum of right-partition,\\n            that\\'s the point where we draw the line of partition\\n            Similar to Leetcode-768 (Max Chunks To Make Sorted II)\\n        */\\n        \\n        //So calculate minimum from right;\\n        vector<int> minRight(n);\\n        minRight[n-1] = nums[n-1];\\n        for(int i = n-2; i>=0; i--) {\\n            minRight[i] = min(minRight[i+1], nums[i]);\\n        }\\n        \\n        int maxLeft = nums[0];\\n        for(int i = 0; i<n-1; i++) {\\n            maxLeft = max(maxLeft, nums[i]);\\n            \\n            if(maxLeft <= minRight[i+1])\\n                return i+1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n\\n```\\n//Approach-3 (One loop solution with explained comments)\\n/*\\n\\tI noticed many people posting this solution with no elaborated comments.\\n\\tSo I have tried to put comments on lines which are really confusing.\\n*/\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int leftMax  = nums[0];\\n        int currMax  = nums[0];\\n        int len      = 1; //Qn says it is gauranteed that a partitioning exists\\n        \\n        for(int i = 1; i<n; i++) {\\n            if(nums[i] < leftMax) {\\n                /*\\n                    If nums[i] is less than maximum to left, it must go to left partition\\n                    so, increase the length of partition\\n                */\\n                len = i+1;\\n                \\n                leftMax = currMax;\\n                /*\\n                    why this ?\\n                    Exampel : {5, 0, 3, 8, 6, 0, 10}\\n                    Until i = 2, leftMax is 5\\n                    Now, when we reach i = 3, we see that it\\'s not less than leftMax (i.e. 8 > 5)\\n                    So, we don\\'t need to partition BUT we update our currMax = 8\\n                    Now, we go to i = 4, our leftMax is still 5 and currMax = 8\\n                    Now, we reach to i = 5, leftMax is still 5 and nums[i] is less than leftMax i.e. (0 < 5)\\n                    so, we need to update our the partition length to (i+1)\\n                    BUT, here\\'s the catch, After i  = 5, we need to have the leftMax as 8 and not 5 anymore.\\n                    That\\'s why we update leftMax to currMax\\n                    i.e. leftMax = currMax;\\n                */\\n            } else {\\n                currMax = max(currMax, nums[i]); //Explained in above comment\\n            }\\n        }\\n        \\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    If you notice Approach-2 below , it\\'s Similar to Qn (Leetcode 768 - Max Chunks To Make Sorted II)\\n    Link : https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Arrays/Max%20Chunks%20To%20Make%20Sorted%20II.cpp\\n*/\\n\\n//Approach-1 (Brute Force : O(n^2) time)\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int maxE = nums[0];\\n        \\n        for(int i = 0; i<n; i++) {\\n            maxE = max(maxE, nums[i]);\\n            int j = i+1;\\n            for(; j<n; j++) {\\n                if(nums[j] < maxE)\\n                    break;\\n            }\\n            if(j == n)\\n                return i+1;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\n```\\n//Approach-2 (Using a very popular concept min-max track from left and right)\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        /*\\n            When the maximum of left-partition is less than minimum of right-partition,\\n            that\\'s the point where we draw the line of partition\\n            Similar to Leetcode-768 (Max Chunks To Make Sorted II)\\n        */\\n        \\n        //So calculate minimum from right;\\n        vector<int> minRight(n);\\n        minRight[n-1] = nums[n-1];\\n        for(int i = n-2; i>=0; i--) {\\n            minRight[i] = min(minRight[i+1], nums[i]);\\n        }\\n        \\n        int maxLeft = nums[0];\\n        for(int i = 0; i<n-1; i++) {\\n            maxLeft = max(maxLeft, nums[i]);\\n            \\n            if(maxLeft <= minRight[i+1])\\n                return i+1;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\n//Approach-3 (One loop solution with explained comments)\\n/*\\n\\tI noticed many people posting this solution with no elaborated comments.\\n\\tSo I have tried to put comments on lines which are really confusing.\\n*/\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        int leftMax  = nums[0];\\n        int currMax  = nums[0];\\n        int len      = 1; //Qn says it is gauranteed that a partitioning exists\\n        \\n        for(int i = 1; i<n; i++) {\\n            if(nums[i] < leftMax) {\\n                /*\\n                    If nums[i] is less than maximum to left, it must go to left partition\\n                    so, increase the length of partition\\n                */\\n                len = i+1;\\n                \\n                leftMax = currMax;\\n                /*\\n                    why this ?\\n                    Exampel : {5, 0, 3, 8, 6, 0, 10}\\n                    Until i = 2, leftMax is 5\\n                    Now, when we reach i = 3, we see that it\\'s not less than leftMax (i.e. 8 > 5)\\n                    So, we don\\'t need to partition BUT we update our currMax = 8\\n                    Now, we go to i = 4, our leftMax is still 5 and currMax = 8\\n                    Now, we reach to i = 5, leftMax is still 5 and nums[i] is less than leftMax i.e. (0 < 5)\\n                    so, we need to update our the partition length to (i+1)\\n                    BUT, here\\'s the catch, After i  = 5, we need to have the leftMax as 8 and not 5 anymore.\\n                    That\\'s why we update leftMax to currMax\\n                    i.e. leftMax = currMax;\\n                */\\n            } else {\\n                currMax = max(currMax, nums[i]); //Explained in above comment\\n            }\\n        }\\n        \\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355086,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        ans=0\\n        maxo=nums[0]\\n        maxtn=nums[0]\\n        for i in range(len(nums)):\\n            if nums[i]>=maxtn:\\n                pass\\n            else:\\n                ans=i\\n                maxtn=max(maxtn,nums[i],maxo)\\n            maxo=max(nums[i],maxo)\\n        return ans+1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        ans=0\\n        maxo=nums[0]\\n        maxtn=nums[0]\\n        for i in range(len(nums)):\\n            if nums[i]>=maxtn:\\n                pass\\n            else:\\n                ans=i\\n                maxtn=max(maxtn,nums[i],maxo)\\n            maxo=max(nums[i],maxo)\\n        return ans+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354990,
                "title": "python3-easy-explanation-96-faster",
                "content": "First move from right to left and make a note of all the positions where there is a chance of finding our partition, then apply the condition at those noted down indexes (reverse the list first) from left to right so, the first time the conditon is satisfied, that is the smallest possible size for \\'left\\'.\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        index = -1\\n        mini = 1000001\\n        l = len(nums)\\n        if l == 2:\\n            return 1\\n        temp = list()\\n        for i in range(l-1, -1, -1):\\n            if nums[i] < mini:\\n                mini = nums[i]\\n                index = i+1\\n                temp.append(i+1)\\n        temp.reverse()\\n        for i in temp:\\n            if max(nums[:i]) <= min(nums[i:]):\\n                return i\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        index = -1\\n        mini = 1000001\\n        l = len(nums)\\n        if l == 2:\\n            return 1\\n        temp = list()\\n        for i in range(l-1, -1, -1):\\n            if nums[i] < mini:\\n                mini = nums[i]\\n                index = i+1\\n                temp.append(i+1)\\n        temp.reverse()\\n        for i in temp:\\n            if max(nums[:i]) <= min(nums[i:]):\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354745,
                "title": "scala-functional-620-ms-59-1-mb",
                "content": "The most straightforward solution is to map every array element to the pair consisting of\\n1. the maximum value to its left (including itself), and\\n2. the minimum value to its right (including itself)\\n\\nThen, all we need to do is getting the index of the first element where the maximum to its left is less than or equal to the maximum element to its right.\\n\\n```\\nobject Solution {\\n    def partitionDisjoint(nums: Array[Int]): Int = {\\n        nums.scanLeft(Int.MinValue)(_ max _)\\n            .zip(nums.scanRight(Int.MaxValue)(_ min _))\\n            .zipWithIndex\\n            .tail\\n            .filter(x => x._1._1 <= x._1._2)\\n            .head._2\\n    }\\n}\\n```\\n\\nThe runtime is O(5`n`) = O(`n`): `scanLeft`, `scanRight`, `zip`, `zipWithIndex`, and `filter` all take O(`n`) time.\\nThis solution is most likely not optimal, as of now there is not enough scala submissions to get runtime & memory use charts.",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def partitionDisjoint(nums: Array[Int]): Int = {\\n        nums.scanLeft(Int.MinValue)(_ max _)\\n            .zip(nums.scanRight(Int.MaxValue)(_ min _))\\n            .zipWithIndex\\n            .tail\\n            .filter(x => x._1._1 <= x._1._2)\\n            .head._2\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1354488,
                "title": "98-memory-efficient-in-python",
                "content": "left=[]\\n        left.append(nums[0])\\n        for i in range(1,len(nums)):\\n            m=max(left)\\n            if(m<=nums[i] and min(nums[i:])>=m):\\n                return len(left)\\n            else:\\n                left.append(nums[i])\\n        return len(left)",
                "solutionTags": [],
                "code": "left=[]\\n        left.append(nums[0])\\n        for i in range(1,len(nums)):\\n            m=max(left)\\n            if(m<=nums[i] and min(nums[i:])>=m):\\n                return len(left)\\n            else:\\n                left.append(nums[i])\\n        return len(left)",
                "codeTag": "Unknown"
            },
            {
                "id": 1296394,
                "title": "python-o-n-time-o-1-space-fastest-with-explanation",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, A: list):\\n        left_max = A[0]\\n        next_max = 0\\n        res = 0\\n        \\n        for i in range(1, len(A)):\\n            \\n            # Always update to get the largest we see\\n            if A[i] > next_max:\\n                next_max = A[i]\\n            \\n            # Anything that is smaller than the largest in left part\\n            if A[i] < left_max:\\n                res = i\\n                \\n                # Update the largest in left part\\n                # Why are we able to do this?\\n                # Because question guarantees that there is always a valid partitioning\\n                left_max = max(left_max, next_max)\\n                    \\n        return res + 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, A: list):\\n        left_max = A[0]\\n        next_max = 0\\n        res = 0\\n        \\n        for i in range(1, len(A)):\\n            \\n            # Always update to get the largest we see\\n            if A[i] > next_max:\\n                next_max = A[i]\\n            \\n            # Anything that is smaller than the largest in left part\\n            if A[i] < left_max:\\n                res = i\\n                \\n                # Update the largest in left part\\n                # Why are we able to do this?\\n                # Because question guarantees that there is always a valid partitioning\\n                left_max = max(left_max, next_max)\\n                    \\n        return res + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1202731,
                "title": "c-simple-o-n-o-1-solution-with-full-explanation",
                "content": "Concept is pretty easy to understand if we take two auxillary arrays of length of the array.\\narray 1 stores the max number encountered upto that point\\narray 2 stores the min number encounter upto that point from reverse.\\n\\teg: \\n\\t\\t5 0 3 8 6\\na1:   5 5 5 8 8\\na2:   0 0 3 6 6\\n\\nnow we iterate in both loops while a1[i]<a2[j]. This is the length required. \\n\\nNow, we try to do this in the array itself WITHOUT USING ANY EXTRA ARRAY. \\nWe start from the end and change every number to min encountered upto that point until we reach a point which is lower than the first element of array (i.e max  until that point). \\nNow, we start from the beginnig of array and go up to the point such that either i<j or the max encountered is greater than the min of the traversal we were doing from right. \\nIn case of max>min, we simply go right in the traversal from the back(j++) , since min upto that point is stored in each array, we simply iterate it till we reach a point where max<min. \\nThen we again increase the i.\\nwe break the loop only when i>=j and max<min, i.e a partition is achieved.\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& arr) {\\n        int n=arr.size();\\n        \\n        int max=arr[0];//to store the max element in the left subpart\\n        int min=arr[n-1];//to store the min element in the right subpart\\n        int i, j;\\n        for(i=0,j=n-2; i<j||max>min;)\\n        {\\n            if(max>min)\\n            {\\n                j++;\\n                min=arr[j];//this will give us just next big min in the right subpart\\n            }\\n            else if(arr[j]>=max)\\n            {\\n                if(arr[j]<min)\\n                    min=arr[j];\\n                arr[j]=min;//store the min upto that part from right\\n                j--;\\n            }\\n            else\\n            {\\n               if(arr[i]>max)\\n                    max=arr[i];\\n                arr[i]=max;//store max encountered upto this point\\n                i++; \\n            }\\n        }\\n        return i+1;//since i is index and we need length, i+1\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& arr) {\\n        int n=arr.size();\\n        \\n        int max=arr[0];//to store the max element in the left subpart\\n        int min=arr[n-1];//to store the min element in the right subpart\\n        int i, j;\\n        for(i=0,j=n-2; i<j||max>min;)\\n        {\\n            if(max>min)\\n            {\\n                j++;\\n                min=arr[j];//this will give us just next big min in the right subpart\\n            }\\n            else if(arr[j]>=max)\\n            {\\n                if(arr[j]<min)\\n                    min=arr[j];\\n                arr[j]=min;//store the min upto that part from right\\n                j--;\\n            }\\n            else\\n            {\\n               if(arr[i]>max)\\n                    max=arr[i];\\n                arr[i]=max;//store max encountered upto this point\\n                i++; \\n            }\\n        }\\n        return i+1;//since i is index and we need length, i+1\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1131928,
                "title": "java-solution-beat-100",
                "content": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] A) {\\n        int leftLength = 1;\\n        int leftMax = A[0], max = A[0];\\n        \\n        for (int i = 1; i < A.length; ++i) {\\n            if (leftMax > A[i]) {\\n                leftLength = i + 1;\\n                leftMax = max;\\n            } else {\\n                max = max > A[i] ? max : A[i];\\n            }\\n        }\\n        \\n        return leftLength;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] A) {\\n        int leftLength = 1;\\n        int leftMax = A[0], max = A[0];\\n        \\n        for (int i = 1; i < A.length; ++i) {\\n            if (leftMax > A[i]) {\\n                leftLength = i + 1;\\n                leftMax = max;\\n            } else {\\n                max = max > A[i] ? max : A[i];\\n            }\\n        }\\n        \\n        return leftLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551609,
                "title": "simple-ruby-solution",
                "content": "```\\ndef partition_disjoint(a)\\n  left = []\\n    loop do\\n\\t  left << a[0]\\n      a.shift(1)\\n      break if a.min >= left.max\\n    end\\n  left.length\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef partition_disjoint(a)\\n  left = []\\n    loop do\\n\\t  left << a[0]\\n      a.shift(1)\\n      break if a.min >= left.max\\n    end\\n  left.length\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 526349,
                "title": "o-n-solution-simple-and-clear-explanation-with-example-and-code-beats-100-in-space-complexity",
                "content": "**Intuition:** We have to divide array into two blocks Left and Right such that picking any element from left and right blocks will give *A[left]<=A[right]*\\n\\n1. So, basically if we are at position i, then `max element till i` should be less than `min element from last element till i`\\n\\nSo, we track min element from right in one array **Rmin**\\nAnd track max element from left in another array **LMax**\\n\\n```\\nIndex    0   1   2    3   4    \\nRmin     0   0   3    6   6\\narr      5   0   3    8   6\\nLMax     5   5   5    8   8\\n```\\n\\n\\nAfter then we, traverse the from i=0 to see at which position my` LMax[i] <= Rmin[i+1]` \\nhere, `at index 2 we 5<=3 is true`\\nAnd once this condition is true, we get required position as we reached at place where above point 1. is correct. That is, now The maximum element till that position is less than min from right elements.\\n\\nTo verify correctness, if we move ahead if the position that we got let say `i` , then we may get element maximum than a[i] but we\\'ll never get element less than a[i] because we already calculated the min element from right side that means, once we are at pos `i` we have min till a[i] from right to i and max from 0 to i.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n\\n        int n=a.size();\\n        \\n         \\n        if(is_sorted(a.begin(),a.end()))\\n            return 1;\\n           \\n           \\n        \\n        vector<int> Rmin(n,0),Lmax(n,0);\\n        \\n        Lmax[0]=a[0];\\n        \\n        for(int i=1;i<n;i++)\\n            Lmax[i]=max(Lmax[i-1],a[i]);\\n        \\n        Rmin[n-1]=a[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            Rmin[i]=min(Rmin[i+1],a[i]);\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(Lmax[i]<=Rmin[i+1])\\n                return i+1;\\n        }\\n        \\n        return n;\\n        \\n    }\\n};      \\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nIndex    0   1   2    3   4    \\nRmin     0   0   3    6   6\\narr      5   0   3    8   6\\nLMax     5   5   5    8   8\\n```\n```\\n\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n\\n        int n=a.size();\\n        \\n         \\n        if(is_sorted(a.begin(),a.end()))\\n            return 1;\\n           \\n           \\n        \\n        vector<int> Rmin(n,0),Lmax(n,0);\\n        \\n        Lmax[0]=a[0];\\n        \\n        for(int i=1;i<n;i++)\\n            Lmax[i]=max(Lmax[i-1],a[i]);\\n        \\n        Rmin[n-1]=a[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            Rmin[i]=min(Rmin[i+1],a[i]);\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(Lmax[i]<=Rmin[i+1])\\n                return i+1;\\n        }\\n        \\n        return n;\\n        \\n    }\\n};      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 397127,
                "title": "python-easy-o-n-solution-faster-than-97",
                "content": "max_now: current maximum of left\\ncandidate: next max_now if a smaller number occurs\\n```python\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        max_now = candidate = A[0]\\n        _len = 1\\n        for i in range(1, len(A)):\\n            if A[i] < max_now:\\n                _len = i + 1\\n                max_now = candidate\\n            else:\\n                if A[i] > candidate:\\n                    candidate = A[i]\\n        return _len\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        max_now = candidate = A[0]\\n        _len = 1\\n        for i in range(1, len(A)):\\n            if A[i] < max_now:\\n                _len = i + 1\\n                max_now = candidate\\n            else:\\n                if A[i] > candidate:\\n                    candidate = A[i]\\n        return _len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 201785,
                "title": "java-single-pass-o-n-beats-96",
                "content": "I saw this as a variation on questions like SumSubarrayMins and so started with a `LinkedList` to act as a stack (or `Deque`) of the index of previous max values so that when we find we need to move the splice location to the right we can immediately find the new max of the now larger left-hand-side sub-array.\\n\\nThe code itself showed me this simplification as there was never a need to `pop()` from the stack and so saw that it could be replaced with a single variable, `lastMax` in the below. \\n\\n    // Initially coded this using a Deque (aka, a stack), but then realized I was only ever peeking at the topmost\\n    // entry, so replaced the stack with the lastMax variable.  Resulting in a 2x speed improvement.\\n    public int partitionDisjoint(int[] A) {\\n      int max = A[0];      // Size of A is given as at least 1.\\n      int lastMax = max;   // This is the max that may have been encountered after the current split choice.\\n      int splitdex = 0;    // location of the split (index of last element in the left-side)\\n      for (int i=1; i<A.length; ++i) {\\n        if (A[i] < max) {   // less than the left-hand-side\\'s max?\\n          splitdex = i;     // new split location\\n          max = lastMax;    // and we may (also) have a new max\\n        } else if (A[i] > lastMax) {\\n          lastMax = A[i];   // Right-hand side max, which becomes the new nax if we move the split to the right.\\n        }\\n      }\\n\\n      return splitdex + 1;\\n    }\\n",
                "solutionTags": [],
                "code": "I saw this as a variation on questions like SumSubarrayMins and so started with a `LinkedList` to act as a stack (or `Deque`) of the index of previous max values so that when we find we need to move the splice location to the right we can immediately find the new max of the now larger left-hand-side sub-array.\\n\\nThe code itself showed me this simplification as there was never a need to `pop()` from the stack and so saw that it could be replaced with a single variable, `lastMax` in the below. \\n\\n    // Initially coded this using a Deque (aka, a stack), but then realized I was only ever peeking at the topmost\\n    // entry, so replaced the stack with the lastMax variable.  Resulting in a 2x speed improvement.\\n    public int partitionDisjoint(int[] A) {\\n      int max = A[0];      // Size of A is given as at least 1.\\n      int lastMax = max;   // This is the max that may have been encountered after the current split choice.\\n      int splitdex = 0;    // location of the split (index of last element in the left-side)\\n      for (int i=1; i<A.length; ++i) {\\n        if (A[i] < max) {   // less than the left-hand-side\\'s max?\\n          splitdex = i;     // new split location\\n          max = lastMax;    // and we may (also) have a new max\\n        } else if (A[i] > lastMax) {\\n          lastMax = A[i];   // Right-hand side max, which becomes the new nax if we move the split to the right.\\n        }\\n      }\\n\\n      return splitdex + 1;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 193178,
                "title": "java-easy-to-understand-solution",
                "content": "Idea is to find the position, whose left\\'s(includ this position) max should be less than whose right\\'s min\\n```\\n public int partitionDisjoint(int[] A) {\\n        int n = A.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        int max = -1;\\n        int min = (int)Math.pow(10,6);\\n        for(int i = 0; i < n; i++){\\n           if(max < A[i]) {\\n               max = A[i];\\n           }\\n            left[i] = max;\\n        }\\n        \\n        for(int i = n-1; i >= 0; i--){\\n            if(min > A[i] ){\\n                min = A[i];\\n            }\\n            right[i] = min;\\n        }\\n        for(int i = 0; i < n-1; i++){\\n            if(left[i] <= right[i+1]){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n        \\n    }```",
                "solutionTags": [],
                "code": "```\\n public int partitionDisjoint(int[] A) {\\n        int n = A.length;\\n        int[] left = new int[n];\\n        int[] right = new int[n];\\n        int max = -1;\\n        int min = (int)Math.pow(10,6);\\n        for(int i = 0; i < n; i++){\\n           if(max < A[i]) {\\n               max = A[i];\\n           }\\n            left[i] = max;\\n        }\\n        \\n        for(int i = n-1; i >= 0; i--){\\n            if(min > A[i] ){\\n                min = A[i];\\n            }\\n            right[i] = min;\\n        }\\n        for(int i = 0; i < n-1; i++){\\n            if(left[i] <= right[i+1]){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n        \\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 177339,
                "title": "java-simple-solution-o-n-time-and-o-1-space-by-maintaining-two-variables-prevmax-curmax",
                "content": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] A) {\\n        int prevMax = A[0];\\n        int curMax = A[0];\\n        int prevMaxIndex = 0;\\n        \\n        for(int i=1;i<A.length;i++)\\n        {\\n            if(A[i] > curMax)\\n            {\\n               curMax =  A[i];\\n            }\\n            else if(A[i] < prevMax)\\n            {\\n                prevMax = curMax;\\n                prevMaxIndex = i;\\n            }\\n        }\\n        return prevMaxIndex+1; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] A) {\\n        int prevMax = A[0];\\n        int curMax = A[0];\\n        int prevMaxIndex = 0;\\n        \\n        for(int i=1;i<A.length;i++)\\n        {\\n            if(A[i] > curMax)\\n            {\\n               curMax =  A[i];\\n            }\\n            else if(A[i] < prevMax)\\n            {\\n                prevMax = curMax;\\n                prevMaxIndex = i;\\n            }\\n        }\\n        return prevMaxIndex+1; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175843,
                "title": "modern-c-solution-with-2-multisets-o-nlogn",
                "content": "Idea:\n1. Split values into 2 multisets (left & right) based on the first occurence of minimum element\n2. While greatest value in left is > than smallest value in right, pop that value from right and put it in left\n3. Once done, return the size of left \n```\nint partitionDisjoint(vector<int>& A) {\n    auto mi = min_element(A.begin (), A.end());\n    multiset<int> left (A.begin(), mi + 1);\n    multiset<int> right (mi + 1, A.end()); \n    for (int i = distance(A.begin (), mi + 1); *--left.end() > *right.begin(); ++i) {\n        right.erase(right.find(A[i]));\n        left.insert(A[i]);\n    }\n    return left.size ();\n}",
                "solutionTags": [],
                "code": "1. Split values into 2 multisets (left & right) based on the first occurence of minimum element\nint partitionDisjoint(vector<int>& A) {\n    auto mi = min_element(A.begin (), A.end());\n    multiset<int> left (A.begin(), mi + 1);\n    multiset<int> right (mi + 1, A.end()); \n    for (int i = distance(A.begin (), mi + 1); *--left.end() > *right.begin(); ++i) {\n        right.erase(right.find(A[i]));\n        left.insert(A[i]);\n    }\n    return left.size ();\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 4073199,
                "title": "here-is-my-solution-o-n-for-java",
                "content": "# Intuition\\nProblem is easy because we are sure a partition exisits.\\n\\n# Approach\\nAssume the first parition is after 0th index (Between 0th and 1st index). Intialize the LeftMax as arr[0] and RightMax as arr[1].\\n\\nWe have 2 cases here, either leftMax is smaller than rightMax or rightMax is smaller than leftMax. \\n\\nIf rightMax is smaller, we need to traverse the array until we find a value which is larger than leftMax and increase the parition index meaning we are expanding the left array until we come across a value which is larger than all values in left arr.\\n\\nIf leftMax is smaller than we can traverse the array and keep updating RightMax. While traversing we might find a value which is smaller than leftMax. This means we have to expand the left parition till that point and find another value of RightMax. We set leftMax = rightMax as our left array has now expanded to this point and find another value for rightMax. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        \\n        int partition = 0;\\n        int leftMax = nums[0];\\n        int rightMax = nums[1];\\n        for(int x = 2;x< nums.length;x++){\\n            while(!(leftMax <= rightMax)){ //move forward until we find a larger value than leftMax\\n                   partition++;\\n                   rightMax = nums[x];\\n                   x++;\\n            }\\n\\n            if(x<nums.length && nums[x] < leftMax){ //expand left arr till this point\\n                leftMax = rightMax;\\n                rightMax = -1;\\n                partition = x-1;\\n            }\\n            else if(x < nums.length && nums[x] > rightMax){ //update rightMax\\n                rightMax = nums[x];\\n            }\\n        }\\n\\n\\n        return ++partition; //we are tracking last index of left arr so we have to increment for correct size return\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        \\n        int partition = 0;\\n        int leftMax = nums[0];\\n        int rightMax = nums[1];\\n        for(int x = 2;x< nums.length;x++){\\n            while(!(leftMax <= rightMax)){ //move forward until we find a larger value than leftMax\\n                   partition++;\\n                   rightMax = nums[x];\\n                   x++;\\n            }\\n\\n            if(x<nums.length && nums[x] < leftMax){ //expand left arr till this point\\n                leftMax = rightMax;\\n                rightMax = -1;\\n                partition = x-1;\\n            }\\n            else if(x < nums.length && nums[x] > rightMax){ //update rightMax\\n                rightMax = nums[x];\\n            }\\n        }\\n\\n\\n        return ++partition; //we are tracking last index of left arr so we have to increment for correct size return\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3514724,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        int minNum=a[0],maxNum=a[0];\\n        int ans=0;\\n        for(int i=1;i<a.size();i++){\\n            if(a[i]<minNum){\\n                ans=i;\\n                minNum=maxNum;\\n            }\\n            maxNum=max(a[i],maxNum);\\n        }\\n        return ans+1;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        ret = 1\\n        cur_max = max_ = nums[0]\\n        for i, n in enumerate(nums):\\n            if n < cur_max:\\n                cur_max = max_\\n                ret = i + 1\\n            if n > max_:\\n                max_ = n\\n        return ret\\n```\\n\\n```Java []\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftmax=nums[0];\\n        int max=nums[0];\\n        int length=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<leftmax){\\n                length=i+1;\\n                leftmax=max;\\n            } else {\\n                max = Math.max(nums[i],max);\\n            }\\n        }\\n        return length;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        int minNum=a[0],maxNum=a[0];\\n        int ans=0;\\n        for(int i=1;i<a.size();i++){\\n            if(a[i]<minNum){\\n                ans=i;\\n                minNum=maxNum;\\n            }\\n            maxNum=max(a[i],maxNum);\\n        }\\n        return ans+1;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        ret = 1\\n        cur_max = max_ = nums[0]\\n        for i, n in enumerate(nums):\\n            if n < cur_max:\\n                cur_max = max_\\n                ret = i + 1\\n            if n > max_:\\n                max_ = n\\n        return ret\\n```\n```Java []\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftmax=nums[0];\\n        int max=nums[0];\\n        int length=1;\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<leftmax){\\n                length=i+1;\\n                leftmax=max;\\n            } else {\\n                max = Math.max(nums[i],max);\\n            }\\n        }\\n        return length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3379450,
                "title": "c-o-n-solution-using-prefix-suffix-array",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        // 5 5 5 8 8\\n        // 0 0 3 6 6\\n        int n=nums.size();\\n        vector<int> pref(n,0);//largest possible element in left\\n        vector<int> suff(n,0);//smallest possible element in right\\n        pref[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            pref[i]=max(pref[i-1],nums[i]);\\n        suff[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            suff[i]=min(nums[i],suff[i+1]);\\n        int ind=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(pref[i]<=suff[i+1])\\n            {\\n                ind=i;\\n                break;\\n            }\\n        }\\n        return ind+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        // 5 5 5 8 8\\n        // 0 0 3 6 6\\n        int n=nums.size();\\n        vector<int> pref(n,0);//largest possible element in left\\n        vector<int> suff(n,0);//smallest possible element in right\\n        pref[0]=nums[0];\\n        for(int i=1;i<n;i++)\\n            pref[i]=max(pref[i-1],nums[i]);\\n        suff[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n            suff[i]=min(nums[i],suff[i+1]);\\n        int ind=0;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            if(pref[i]<=suff[i+1])\\n            {\\n                ind=i;\\n                break;\\n            }\\n        }\\n        return ind+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374894,
                "title": "c-best-solution-one-pass-prefix-sum",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n\\n        int  n = nums.size();\\n        vector<int> pre(n,-1);\\n        vector<int> post(n,-1);\\n        int currMax = nums[0] , currMin = nums[n-1];\\n        for(int i=0;i<n;i++){\\n            currMax = max(currMax,nums[i]);\\n            currMin = min(currMin,nums[n-1-i]);\\n            post[n-1-i] = currMin;\\n            pre[i] = currMax;\\n        }\\n        cout<<n;\\n        int ans = INT_MAX;\\n        for(int i=0;i<n-1;i++){\\n            if(pre[i] <= post[i+1]){\\n                return min(ans,i+1);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n\\n        int  n = nums.size();\\n        vector<int> pre(n,-1);\\n        vector<int> post(n,-1);\\n        int currMax = nums[0] , currMin = nums[n-1];\\n        for(int i=0;i<n;i++){\\n            currMax = max(currMax,nums[i]);\\n            currMin = min(currMin,nums[n-1-i]);\\n            post[n-1-i] = currMin;\\n            pre[i] = currMax;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3241893,
                "title": "java-easy-solution-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/922e4b9e-26f0-42f7-a5e2-c1668638a1bd_1677636638.9514394.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftmax=nums[0]; //max value in left part of the array\\n        int max=nums[0]; //absolute max value in the already traversed part of the array\\n        int length=1; //minimum length is 1\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<leftmax){ //if current element is less than the max value in left part of the array\\n                length=i+1; //increase length by 1 ie extend left array to index i\\n                leftmax=max; //assign the absolute max value to left max because we may have already traversed past a value greater than leftmax but assumed it was in the right part!! luckily we are storing it in the max variable\\n            } else {\\n                max = Math.max(nums[i],max); //update absolute max & stop left there\\n            }\\n        }\\n        return length; //don\\'t add 1 here as it\\'s possible it will never get updated in the for loop and will return a value of 2 instead of expected 1!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftmax=nums[0]; //max value in left part of the array\\n        int max=nums[0]; //absolute max value in the already traversed part of the array\\n        int length=1; //minimum length is 1\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]<leftmax){ //if current element is less than the max value in left part of the array\\n                length=i+1; //increase length by 1 ie extend left array to index i\\n                leftmax=max; //assign the absolute max value to left max because we may have already traversed past a value greater than leftmax but assumed it was in the right part!! luckily we are storing it in the max variable\\n            } else {\\n                max = Math.max(nums[i],max); //update absolute max & stop left there\\n            }\\n        }\\n        return length; //don\\'t add 1 here as it\\'s possible it will never get updated in the for loop and will return a value of 2 instead of expected 1!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215164,
                "title": "c-solution-simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> pre(n),post(n);\\n        for(int i=0,j=n-1;i<n;i++,j--){\\n            if(!i){\\n                pre[i] = nums[i];\\n                post[j] = nums[j];\\n                continue;\\n            }\\n            pre[i] = max(pre[i-1],nums[i]);\\n            post[j] = min(post[j+1],nums[j]);\\n        }\\n        int ans = 1;\\n        for(int j=1,i=0;j<n;i++,j++){\\n            if(pre[i]<=post[j]) return j;\\n        }\\n        return ans;\\n    }\\n};\\n//5 5 5 8 8\\n//0 0 3 6 6\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> pre(n),post(n);\\n        for(int i=0,j=n-1;i<n;i++,j--){\\n            if(!i){\\n                pre[i] = nums[i];\\n                post[j] = nums[j];\\n                continue;\\n            }\\n            pre[i] = max(pre[i-1],nums[i]);\\n            post[j] = min(post[j+1],nums[j]);\\n        }\\n        int ans = 1;\\n        for(int j=1,i=0;j<n;i++,j++){\\n            if(pre[i]<=post[j]) return j;\\n        }\\n        return ans;\\n    }\\n};\\n//5 5 5 8 8\\n//0 0 3 6 6\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848678,
                "title": "weird-but-working-2-pointer-code-o-n-time-o-1-space",
                "content": "2 pointer solution, we greedily decide when start the splitting point ---\\'index\\', where cur_max represent the left possible max once the internal while loop starts running. The internal while loop also check for condition and initiating another possible largest sum of the \\'potential right subarray\\', if it is violated, it becomes left array and we replace cur_max with second_max, and repeat, the pointer jump to the end of internal while loop, therefore O(n)\\nclass Solution:\\n\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        cur_max = nums[0]\\n        second_max = 0\\n        index = 0\\n        i = 1\\n        while i <= len(nums)-1:\\n            \\n            if nums[i] >= cur_max:\\n                index = i\\n                \\n                j = i\\n                while j <= len(nums)-1:\\n                    \\n                    second_max = max(second_max,nums[j])\\n                    if nums[j] < cur_max:\\n                        cur_max = second_max \\n                        second_max = 0\\n                        i = j+1\\n                        break \\n                    elif j == len(nums)-1:\\n                        \\n                        return index \\n                    j += 1\\n            else:\\n                cur_max = max(cur_max,nums[i])\\n                i += 1\\n        return index",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "2 pointer solution, we greedily decide when start the splitting point ---\\'index\\', where cur_max represent the left possible max once the internal while loop starts running. The internal while loop also check for condition and initiating another possible largest sum of the \\'potential right subarray\\', if it is violated, it becomes left array and we replace cur_max with second_max, and repeat, the pointer jump to the end of internal while loop, therefore O(n)\\nclass Solution:\\n\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        cur_max = nums[0]\\n        second_max = 0\\n        index = 0\\n        i = 1\\n        while i <= len(nums)-1:\\n            \\n            if nums[i] >= cur_max:\\n                index = i\\n                \\n                j = i\\n                while j <= len(nums)-1:\\n                    \\n                    second_max = max(second_max,nums[j])\\n                    if nums[j] < cur_max:\\n                        cur_max = second_max \\n                        second_max = 0\\n                        i = j+1\\n                        break \\n                    elif j == len(nums)-1:\\n                        \\n                        return index \\n                    j += 1\\n            else:\\n                cur_max = max(cur_max,nums[i])\\n                i += 1\\n        return index",
                "codeTag": "Java"
            },
            {
                "id": 2710408,
                "title": "suffix-array-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        vector<int> sf(nums.size(), nums.back());\\n        for(int i=nums.size()-2; i>=0; i--) sf[i] = min(nums[i], sf[i + 1]);\\n        \\n        int mx = INT_MIN;\\n        for(int i=0; i<nums.size()-1; i++) {\\n            mx = max(mx, nums[i]);\\n            if(mx <= sf[i + 1]) return i + 1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        vector<int> sf(nums.size(), nums.back());\\n        for(int i=nums.size()-2; i>=0; i--) sf[i] = min(nums[i], sf[i + 1]);\\n        \\n        int mx = INT_MIN;\\n        for(int i=0; i<nums.size()-1; i++) {\\n            mx = max(mx, nums[i]);\\n            if(mx <= sf[i + 1]) return i + 1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345496,
                "title": "simple-java-solution-tc-o-n-sc-o-1",
                "content": "Runtime : 2 ms, faster than 100.00%\\nMemory Usage : 52 MB, less than 92.76%\\n\\nPlease upvote, if you find it useful :)\\n\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int mts = nums[0]; // max till scan\\n        int mtp = nums[0]; // max till partition\\n        int idx = 0;\\n        \\n        for(int i=1; i<nums.length; i++) {\\n            int val = nums[i];\\n            if(val < mtp) {\\n                idx = i;\\n                mtp = mts;\\n            }\\n            \\n            mts = Math.max(mts, val);\\n        }\\n        \\n        return idx + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int mts = nums[0]; // max till scan\\n        int mtp = nums[0]; // max till partition\\n        int idx = 0;\\n        \\n        for(int i=1; i<nums.length; i++) {\\n            int val = nums[i];\\n            if(val < mtp) {\\n                idx = i;\\n                mtp = mts;\\n            }\\n            \\n            mts = Math.max(mts, val);\\n        }\\n        \\n        return idx + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200540,
                "title": "c-3-approaches-clean-code-simple-partition",
                "content": "**Approach 1 : \\nUsing Two Extra arrays\\nTime Complexity : O(N)\\nSpace Complexity : O(N)**\\n```\\n\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        //LeftMax vector\\n        vector<int>leftMax(n+1);\\n        leftMax[0]=nums[0];\\n        \\n        for(int i=1 ; i<nums.size() ; i++)\\n            leftMax[i]=max(leftMax[i-1],nums[i]);\\n        leftMax[n] = leftMax[n-1];\\n        \\n        //RightMin vector\\n        vector<int>rightMin(n+1);\\n        rightMin[n]=INT_MAX;\\n        \\n        for(int i=n-1;i>=0;i--)\\n            rightMin[i]=min(rightMin[i+1],nums[i]);\\n        \\n        //For checking leftMax and rightMin vectors\\n        // for(auto i : leftMax)cout << i << \" \";\\n        // cout << endl;\\n        // for(auto i : rightMin)cout << i << \" \";\\n        \\n        int k = 0;\\n        for(; k < nums.size() ; k++){\\n            if(leftMax[k] <= rightMin[k+1]){\\n                break;\\n          }  \\n        }\\n        \\n        return k + 1;\\n    }\\n};\\n\\n```\\n\\n\\n**Approach 2 : Using Single Extra Array\\nTime Complexity : O(N)\\nSpace Complexity : O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n    \\n        //RightMin vector\\n        vector<int>rightMin(n+1);\\n        rightMin[n]=INT_MAX;\\n        \\n        for(int i=n-1;i>=0;i--)\\n            rightMin[i]=min(rightMin[i+1],nums[i]);\\n        \\n        \\n        // for(auto i : leftMax)cout << i << \" \";\\n        // cout << endl;\\n        // for(auto i : rightMin)cout << i << \" \";\\n        int leftMax = INT_MIN;\\n        int k = 0;\\n        for(; k < nums.size() ; k++){\\n            leftMax = max(leftMax, nums[k]);\\n            if(leftMax <= rightMin[k+1]){\\n                break;\\n          }  \\n        }\\n        \\n        return k + 1;\\n    }\\n};\\n\\n\\n```\\n\\n**Approach 3 : Without Using Any Extra Array\\nTime Complexity : O(N)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        int leftMax = nums[0];\\n        //leftMax -> Keeps the track of greatest left element and gets updated if any element wants to come to the left side \\n        int greater = 0;  \\n        //greater -> Keeps the tracks of greatest element till i\\n        int ans = 0;\\n        //7 3 9 5 10 1 15 16 19 14 30\\n        // i \\n        //leftMax = 7 7 9 10 \\n        //greater = 7 9 10 15 16 19 30a\\n        //ans = 0 1 3 5\\n    \\n        \\n        for(int i = 0 ; i < nums.size() ; i++){\\n            greater = max(greater, nums[i]);\\n            if(nums[i] < leftMax){\\n                ans = i;\\n                leftMax = greater;\\n            }\\n        }\\n        return ans + 1;\\n    }\\n};\\n\\n```\\n\\n**Please do upvote if this helped you !!!**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        //LeftMax vector\\n        vector<int>leftMax(n+1);\\n        leftMax[0]=nums[0];\\n        \\n        for(int i=1 ; i<nums.size() ; i++)\\n            leftMax[i]=max(leftMax[i-1],nums[i]);\\n        leftMax[n] = leftMax[n-1];\\n        \\n        //RightMin vector\\n        vector<int>rightMin(n+1);\\n        rightMin[n]=INT_MAX;\\n        \\n        for(int i=n-1;i>=0;i--)\\n            rightMin[i]=min(rightMin[i+1],nums[i]);\\n        \\n        //For checking leftMax and rightMin vectors\\n        // for(auto i : leftMax)cout << i << \" \";\\n        // cout << endl;\\n        // for(auto i : rightMin)cout << i << \" \";\\n        \\n        int k = 0;\\n        for(; k < nums.size() ; k++){\\n            if(leftMax[k] <= rightMin[k+1]){\\n                break;\\n          }  \\n        }\\n        \\n        return k + 1;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n    \\n        //RightMin vector\\n        vector<int>rightMin(n+1);\\n        rightMin[n]=INT_MAX;\\n        \\n        for(int i=n-1;i>=0;i--)\\n            rightMin[i]=min(rightMin[i+1],nums[i]);\\n        \\n        \\n        // for(auto i : leftMax)cout << i << \" \";\\n        // cout << endl;\\n        // for(auto i : rightMin)cout << i << \" \";\\n        int leftMax = INT_MIN;\\n        int k = 0;\\n        for(; k < nums.size() ; k++){\\n            leftMax = max(leftMax, nums[k]);\\n            if(leftMax <= rightMin[k+1]){\\n                break;\\n          }  \\n        }\\n        \\n        return k + 1;\\n    }\\n};\\n\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        int leftMax = nums[0];\\n        //leftMax -> Keeps the track of greatest left element and gets updated if any element wants to come to the left side \\n        int greater = 0;  \\n        //greater -> Keeps the tracks of greatest element till i\\n        int ans = 0;\\n        //7 3 9 5 10 1 15 16 19 14 30\\n        // i \\n        //leftMax = 7 7 9 10 \\n        //greater = 7 9 10 15 16 19 30a\\n        //ans = 0 1 3 5\\n    \\n        \\n        for(int i = 0 ; i < nums.size() ; i++){\\n            greater = max(greater, nums[i]);\\n            if(nums[i] < leftMax){\\n                ans = i;\\n                leftMax = greater;\\n            }\\n        }\\n        return ans + 1;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2005280,
                "title": "java-easy-fastest-o-n-space",
                "content": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftmax = nums[0], greater = nums[0], n = nums.length, ans = 0;\\n        for(int i=1;i<n;i++){\\n            if(nums[i] > greater){\\n                greater = nums[i];\\n            }\\n            if(nums[i] < leftmax){\\n                ans = i;\\n                leftmax = greater;\\n            }\\n        }\\n        return ans+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftmax = nums[0], greater = nums[0], n = nums.length, ans = 0;\\n        for(int i=1;i<n;i++){\\n            if(nums[i] > greater){\\n                greater = nums[i];\\n            }\\n            if(nums[i] < leftmax){\\n                ans = i;\\n                leftmax = greater;\\n            }\\n        }\\n        return ans+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791817,
                "title": "java-3ms-o-n-time-o-1-space-solution",
                "content": "# public int partitionDisjoint(int[] nums) {\\n        int res = 0;\\n        int leftMax = nums[0];\\n        int greater = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            if (greater <= nums[i]) {\\n                greater = nums[i];\\n            } else if (nums[i] < leftMax) {\\n                res = i;\\n                leftMax = greater;\\n            }\\n        }\\n        return res + 1;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "# public int partitionDisjoint(int[] nums) {\\n        int res = 0;\\n        int leftMax = nums[0];\\n        int greater = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            if (greater <= nums[i]) {\\n                greater = nums[i];\\n            } else if (nums[i] < leftMax) {\\n                res = i;\\n                leftMax = greater;\\n            }\\n        }\\n        return res + 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1607880,
                "title": "java-o-1-space-and-o-n-time-easy-and-short-code",
                "content": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftMax=0;\\n        int greater=0;\\n        int ans=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[greater]<nums[i]){\\n                greater=i;\\n            }\\n            if(nums[i]<nums[leftMax]){\\n                ans=i;\\n                leftMax=greater;\\n            }\\n        }\\n        return ans+1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int leftMax=0;\\n        int greater=0;\\n        int ans=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[greater]<nums[i]){\\n                greater=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1580950,
                "title": "c-o-n",
                "content": "*The purpose of my post is to improve my ability to express the key idea of the problem in English, which can be helpful for my interviews. Please let me know if there is anything wrong.*\\n\\nThe maximum element of the left side will be less than or equal to the minimum element of the right side. So We iterate the array from both sides to get the maximum from left and the minimum element from right for each element. \\n\\nSince we need to get the smallest possible left length, we iterate from left, and check if the left max is less than or equal to the right min. If it is, then we find a partition.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n       int lmax[nums.size()];\\n        int rmin[nums.size()];\\n        int max_num = 0;\\n        for (int i = 0; i < nums.size() - 1; i++) {\\n            max_num = max(max_num, nums[i]);\\n            lmax[i] = max_num;\\n        }\\n        int min_num = INT_MAX;\\n        for (int i = nums.size() - 2; i >= 0; i--) {\\n            min_num = min(min_num, nums[i + 1]);\\n            rmin[i] = min_num;\\n        }\\n        \\n        for (int i = 0; i < nums.size() - 1; i++) {\\n            if (lmax[i] <= rmin[i]) {\\n                return i + 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n       int lmax[nums.size()];\\n        int rmin[nums.size()];\\n        int max_num = 0;\\n        for (int i = 0; i < nums.size() - 1; i++) {\\n            max_num = max(max_num, nums[i]);\\n            lmax[i] = max_num;\\n        }\\n        int min_num = INT_MAX;\\n        for (int i = nums.size() - 2; i >= 0; i--) {\\n            min_num = min(min_num, nums[i + 1]);\\n            rmin[i] = min_num;\\n        }\\n        \\n        for (int i = 0; i < nums.size() - 1; i++) {\\n            if (lmax[i] <= rmin[i]) {\\n                return i + 1;\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580575,
                "title": "java-single-pass-o-n-time-o-1-space",
                "content": "```java\\npublic int partitionDisjoint(int[] nums) {\\n\\tint leftMax = nums[0], max = nums[0], partitionIndex = 0;\\n\\tfor (int i=1; i<nums.length; i++) {\\n\\t\\tif (nums[i] < leftMax) {\\n\\t\\t\\tleftMax = max;\\n\\t\\t\\tpartitionIndex = i;\\n\\t\\t}\\n\\t\\tmax = Math.max(max, nums[i]);\\n\\t}    \\n\\treturn partitionIndex + 1;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int partitionDisjoint(int[] nums) {\\n\\tint leftMax = nums[0], max = nums[0], partitionIndex = 0;\\n\\tfor (int i=1; i<nums.length; i++) {\\n\\t\\tif (nums[i] < leftMax) {\\n\\t\\t\\tleftMax = max;\\n\\t\\t\\tpartitionIndex = i;\\n\\t\\t}\\n\\t\\tmax = Math.max(max, nums[i]);\\n\\t}    \\n\\treturn partitionIndex + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1361819,
                "title": "java-o-1-space",
                "content": "```\\npublic static int partitionDisjointNewAttempt(int[] nums) {\\n        var maxElementOnLeftSife = nums[0];\\n        var greaterAfterMax = nums[0];\\n        var possibleBorder = 0;\\n\\n        for(var i = 1; i < nums.length; i++) {\\n            // if some element is greater then current maximum on left side\\n            // we need to save it to consider after expanding left partion as it will be max element after it\\n            if(nums[i] > greaterAfterMax) {\\n                greaterAfterMax = nums[i];\\n            } else if(nums[i] < maxElementOnLeftSife) {\\n                maxElementOnLeftSife = greaterAfterMax;\\n                possibleBorder = i;\\n            }\\n        }\\n\\n        // count elements, that + 1, because array start from 0\\n        return possibleBorder + 1;\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\npublic static int partitionDisjointNewAttempt(int[] nums) {\\n        var maxElementOnLeftSife = nums[0];\\n        var greaterAfterMax = nums[0];\\n        var possibleBorder = 0;\\n\\n        for(var i = 1; i < nums.length; i++) {\\n            // if some element is greater then current maximum on left side\\n            // we need to save it to consider after expanding left partion as it will be max element after it\\n            if(nums[i] > greaterAfterMax) {\\n                greaterAfterMax = nums[i];\\n            } else if(nums[i] < maxElementOnLeftSife) {\\n                maxElementOnLeftSife = greaterAfterMax;\\n                possibleBorder = i;\\n            }\\n        }\\n\\n        // count elements, that + 1, because array start from 0\\n        return possibleBorder + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1359525,
                "title": "partition-array-into-disjoint-intervals",
                "content": "Here is my approach using maps in C++.\\n\\'\\'\\'\\n\\n    void sorting(map<int, int> & list){\\n        int n = list.size();\\n\\n        vector<pair<int, int>> sample;\\n        auto itr = list.begin();\\n\\n        for(auto& itr : list){\\n            sample.push_back(itr);\\n        }\\n\\n        sort(sample.begin(), sample.end());\\n    }\\n\\n    \\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        map<int, int> list;\\n        \\n        for(int i =0; i<n; i++) ++list[nums[i]];\\n        \\n        int maxim = nums[0], i;\\n        sorting(list);\\n    \\n        for(i =0; i<n ; i++){\\n            maxim = max(maxim, nums[i]);\\n\\n            if(list.count(nums[i])) {\\n                --list[nums[i]];\\n                if(list[nums[i]] == 0) {\\n                    list.erase(nums[i]);\\n                }\\n            }\\n\\n            if(maxim <= list.begin()->first) break;\\n        }\\n        \\n        return i+1;\\n    }\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "Here is my approach using maps in C++.\\n\\'\\'\\'\\n\\n    void sorting(map<int, int> & list){\\n        int n = list.size();\\n\\n        vector<pair<int, int>> sample;\\n        auto itr = list.begin();\\n\\n        for(auto& itr : list){\\n            sample.push_back(itr);\\n        }\\n\\n        sort(sample.begin(), sample.end());\\n    }\\n\\n    \\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        map<int, int> list;\\n        \\n        for(int i =0; i<n; i++) ++list[nums[i]];\\n        \\n        int maxim = nums[0], i;\\n        sorting(list);\\n    \\n        for(i =0; i<n ; i++){\\n            maxim = max(maxim, nums[i]);\\n\\n            if(list.count(nums[i])) {\\n                --list[nums[i]];\\n                if(list[nums[i]] == 0) {\\n                    list.erase(nums[i]);\\n                }\\n            }\\n\\n            if(maxim <= list.begin()->first) break;\\n        }\\n        \\n        return i+1;\\n    }\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1358452,
                "title": "java-solution-faster-than-100-using-min-array",
                "content": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int[] min = new int[nums.length];\\n        min[nums.length-1] = nums[nums.length-1];\\n        \\n        int minVal = nums[nums.length-1];\\n        for(int i = nums.length-2;i>=0;i--)\\n        {\\n            minVal = Math.min(minVal, nums[i]);\\n            min[i] = minVal;\\n        }\\n        \\n        int maxVal = nums[0];\\n        for(int i = 0;i<nums.length-1;i++)\\n        {\\n            maxVal = Math.max(maxVal, nums[i]);\\n            if(maxVal <= min[i+1])\\n                return i+1;\\n        }\\n        return 0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int[] min = new int[nums.length];\\n        min[nums.length-1] = nums[nums.length-1];\\n        \\n        int minVal = nums[nums.length-1];\\n        for(int i = nums.length-2;i>=0;i--)\\n        {\\n            minVal = Math.min(minVal, nums[i]);\\n            min[i] = minVal;\\n        }\\n        \\n        int maxVal = nums[0];\\n        for(int i = 0;i<nums.length-1;i++)\\n        {\\n            maxVal = Math.max(maxVal, nums[i]);\\n            if(maxVal <= min[i+1])\\n                return i+1;\\n        }\\n        return 0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357213,
                "title": "915-return-i-1-when-if-prefixmax-i-suffixmin-i",
                "content": "---\\n\\nIt looks simple, but a difficult question :)\\n\\n---\\n\\n**Algo**\\n- Move from left to right in the given array\\n  - Find max.. till now..\\n    - Save it another array called `prefixMax`\\n- Now move from right to left\\n  - Find min.. till now..\\n    - Save it another array called `suffixMin`\\n- Now we have both arrays\\n  - Can we get the answer required?\\n   - Yes\\n   - Now come from left to right again\\n     - But this time, dont look into the given array\\n\\t   - But look into `prefixMax` & `suffixMin` arrays, which are of same length of given array\\n\\t   - The key is if `prefixMax` is less than or equal to `suffixMin` we return that as answer\\n  \\t     - Why did we do `+1` below?\\n\\t\\t   - Because it was an index, and we needed length, `length will be index+1`\\n\\nHope it is simple to understand.\\n\\n---\\n\\n```\\nvar partitionDisjoint = function (A) {\\n    let n = A.length;\\n\\n    let prefixMax = [...A];\\n    for (let i = 1; i < n; i++) {\\n        prefixMax[i] = Math.max(A[i], prefixMax[i - 1]);\\n    }\\n\\n    let suffixMin = [...A];\\n    for (let i = n - 2; i >= 0; i--) {\\n        suffixMin[i] = Math.min(A[i], suffixMin[i + 1]);\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        if (prefixMax[i] <= suffixMin[i + 1]) {\\n            return i + 1;\\n        }\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e5b7d41a-f9dc-4c05-8daf-89510d6e4307_1627043377.2498617.png)\\n\\n----------\\n\\nProblem explanation:\\n----------\\n```\\nExample:\\n\\nDivide below \\n[5,0,3,8,6,10] \\ninto 2 sub arrays \\nwith at least one element \\n\\n[5,0,3,8,6,10] \\nbecomes \\n. left subarray and right subarray \\nas \\n. [5] and [0,3,8,6,10] \\n. [5,0] and [3,8,6,10] \\n. [5,0,3] and [8,6,10] \\n. [5,0,3,8] and [6,10] \\n. [5,0,3,8,6] and [10] \\n\\nwhile doing above \\nmake sure \\nall elements on left subarray \\nare less than \\nall elements on right subarray \\n\\n. all elements of [5] are less than all of [0,3,8,6,10]? - No, because 5 in left array < 0 in right array is false \\n. all elements of [5,0] are less than all of [3,8,6,10]? - No, because 5 in left array < 3 in right array is false \\n. all elements of [5,0,3] are less than all of [8,6,10]? - Yes, because 5,0&3 in left array are < all (8,6,10) in right array <------ A \\n. all elements of [5,0,3,8] are less than all of [6,10]? - No, because 8 in left array < 6 in right array is false \\n. all elements of [5,0,3,8,6] are less than all of [10]? - Yes, because 5,0,3,8&6 in left array are < all (10) in right array <------ B \\n\\nIn cases, both A & B (see above, on right)\\nare Yes \\ncomparing both left side subarray: \\n. [5,0,3] and \\n. [5,0,3,8,6] \\n\\nWe would need smallest of above two \\nit is \\n. [5,0,3] \\n\\nthe length of above is 3 \\nso, the answer is 3 \\n```\\n----------\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar partitionDisjoint = function (A) {\\n    let n = A.length;\\n\\n    let prefixMax = [...A];\\n    for (let i = 1; i < n; i++) {\\n        prefixMax[i] = Math.max(A[i], prefixMax[i - 1]);\\n    }\\n\\n    let suffixMin = [...A];\\n    for (let i = n - 2; i >= 0; i--) {\\n        suffixMin[i] = Math.min(A[i], suffixMin[i + 1]);\\n    }\\n\\n    for (let i = 0; i < n; i++) {\\n        if (prefixMax[i] <= suffixMin[i + 1]) {\\n            return i + 1;\\n        }\\n    }\\n};\\n```\n```\\nExample:\\n\\nDivide below \\n[5,0,3,8,6,10] \\ninto 2 sub arrays \\nwith at least one element \\n\\n[5,0,3,8,6,10] \\nbecomes \\n. left subarray and right subarray \\nas \\n. [5] and [0,3,8,6,10] \\n. [5,0] and [3,8,6,10] \\n. [5,0,3] and [8,6,10] \\n. [5,0,3,8] and [6,10] \\n. [5,0,3,8,6] and [10] \\n\\nwhile doing above \\nmake sure \\nall elements on left subarray \\nare less than \\nall elements on right subarray \\n\\n. all elements of [5] are less than all of [0,3,8,6,10]? - No, because 5 in left array < 0 in right array is false \\n. all elements of [5,0] are less than all of [3,8,6,10]? - No, because 5 in left array < 3 in right array is false \\n. all elements of [5,0,3] are less than all of [8,6,10]? - Yes, because 5,0&3 in left array are < all (8,6,10) in right array <------ A \\n. all elements of [5,0,3,8] are less than all of [6,10]? - No, because 8 in left array < 6 in right array is false \\n. all elements of [5,0,3,8,6] are less than all of [10]? - Yes, because 5,0,3,8&6 in left array are < all (10) in right array <------ B \\n\\nIn cases, both A & B (see above, on right)\\nare Yes \\ncomparing both left side subarray: \\n. [5,0,3] and \\n. [5,0,3,8,6] \\n\\nWe would need smallest of above two \\nit is \\n. [5,0,3] \\n\\nthe length of above is 3 \\nso, the answer is 3 \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1356608,
                "title": "python-o-n-time-o-1-space-solution",
                "content": "So, we have two buckets left bucket and right bucket\\n\\nIf current ```ele``` happens to be less than the maximum in the left bucket, we have no choice but to add all elements till ele in the left bucket. While updating the size of the left bucket, we update the maximum in the left_bucket as well. \\n\\nThe above logic can be implemented using  ```left_max```, ```current_max``` and ```left_size```. \\n\\nHere\\'s the code. Feel free to comment, if you need any help understanding it. \\n\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        left_max=nums[0]\\n        current_max=nums[0]\\n        left_size=1\\n        for i in range(1,n):\\n            ele=nums[i]\\n            if(ele<left_max):\\n                #ele has to be in left! \\n                left_size=i+1\\n                left_max=current_max\\n            current_max=max(current_max,ele)\\n        return left_size\\n        \\n```",
                "solutionTags": [],
                "code": "```ele```\n```left_max```\n```current_max```\n```left_size```\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        n=len(nums)\\n        left_max=nums[0]\\n        current_max=nums[0]\\n        left_size=1\\n        for i in range(1,n):\\n            ele=nums[i]\\n            if(ele<left_max):\\n                #ele has to be in left! \\n                left_size=i+1\\n                left_max=current_max\\n            current_max=max(current_max,ele)\\n        return left_size\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356401,
                "title": "c-o-1-space",
                "content": "```\\n//O(1) space solution algorithm is intresting \\n\\n\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n        \\n        int i,n=a.size(),partition=0;\\n        \\n        int left_max=a[0] , global_max=a[0];\\n        \\n        for(i=1;i<n;i++){\\n            global_max = max(global_max, a[i]);\\n            \\n            if(left_max>a[i]){\\n                // then this \\'i\\' qualifies for partition bcz\\n                // we are expecting elements from i+1 to n should be greater than left_max\\n                \\n                left_max = global_max; // global max till now is new left_max incase we got a future \\'i\\' qualifying as potential partition\\n                \\n                partition = i;\\n                \\n            }\\n        }\\n        \\n        return partition+1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//O(1) space solution algorithm is intresting \\n\\n\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& a) {\\n        \\n        int i,n=a.size(),partition=0;\\n        \\n        int left_max=a[0] , global_max=a[0];\\n        \\n        for(i=1;i<n;i++){\\n            global_max = max(global_max, a[i]);\\n            \\n            if(left_max>a[i]){\\n                // then this \\'i\\' qualifies for partition bcz\\n                // we are expecting elements from i+1 to n should be greater than left_max\\n                \\n                left_max = global_max; // global max till now is new left_max incase we got a future \\'i\\' qualifying as potential partition\\n                \\n                partition = i;\\n                \\n            }\\n        }\\n        \\n        return partition+1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356399,
                "title": "c-easy-clean-solution-o-n-time-complexity",
                "content": "**Use comment section if you dont understand the code, try to traverse it**\\n**Upvote this post if you like it**\\n\\n```\\n       int min1=nums[0],len=nums.size(),j=0,max1=nums[0];\\n        for(int i=1;i<len;i++)\\n        {\\n            if(min1<=nums[i])\\n            {\\n                max1=max1<nums[i]?nums[i]:max1;\\n            }\\n            else\\n            {\\n                j=i;\\n                min1=max1;\\n               \\n            }\\n        }\\n        return j+1;  \\n```\\nTime complexity - **O(n)** , Space complexity - **O(1)**\\n\\t\\t",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n       int min1=nums[0],len=nums.size(),j=0,max1=nums[0];\\n        for(int i=1;i<len;i++)\\n        {\\n            if(min1<=nums[i])\\n            {\\n                max1=max1<nums[i]?nums[i]:max1;\\n            }\\n            else\\n            {\\n                j=i;\\n                min1=max1;\\n               \\n            }\\n        }\\n        return j+1;  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1356159,
                "title": "easy-solution",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n\\n        max_num = nums[0]\\n        res = 0\\n        max_seen_so_far = nums[0]\\n        \\n        i = 1\\n        while i < len(nums):\\n            \\n            if nums[i] > max_seen_so_far:\\n                max_seen_so_far = nums[i]\\n            \\n            elif nums[i] < max_num:\\n                res = i\\n                max_num = max_seen_so_far\\n            \\n            i += 1\\n        return res + 1\\n        \\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n\\n        max_num = nums[0]\\n        res = 0\\n        max_seen_so_far = nums[0]\\n        \\n        i = 1\\n        while i < len(nums):\\n            \\n            if nums[i] > max_seen_so_far:\\n                max_seen_so_far = nums[i]\\n            \\n            elif nums[i] < max_num:\\n                res = i\\n                max_num = max_seen_so_far\\n            \\n            i += 1\\n        return res + 1\\n        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355579,
                "title": "c-cpp-java-javascript-easy-solution-fast100-o-n",
                "content": "**CPP**\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int m=nums[0],count=1,max_ele=nums[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(m>nums[i]){\\n                count=i+1;\\n            m=max(max_ele,m);\\n            }   \\n            else\\n                max_ele=max(max_ele,nums[i]);\\n        }\\n        return count;\\n    }\\n};\\n```\\n**JAVA**\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n      int m=nums[0],count=1,max_ele=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(m>nums[i]){\\n                count=i+1;\\n            m=Math.max(max_ele,m);\\n            }   \\n            else\\n                max_ele=Math.max(max_ele,nums[i]);\\n        }\\n        return count;  \\n    }\\n}\\n```\\n**JAVASCRIPT**\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar partitionDisjoint = function(nums) {\\n    let m=nums[0],count=1,max_ele=nums[0];\\n        for(let i=0;i<nums.length;i++)\\n        {\\n            if(m>nums[i]){\\n                count=i+1;\\n            m=Math.max(max_ele,m);\\n            }   \\n            else\\n                max_ele=Math.max(max_ele,nums[i]);\\n        }\\n        return count; \\n};\\n```\\n**C**\\n```\\n\\n\\nint partitionDisjoint(int* nums, int numsSize){\\n    int max(int a,int b)\\n    {\\n        if(a>b)\\n            return a;\\n    return b;\\n    }\\nint m=nums[0],count=1,max_ele=nums[0];\\n        for(int i=0;i<numsSize;i++)\\n        {\\n            if(m>nums[i]){\\n                count=i+1;\\n                \\n            m=max(max_ele,m);\\n            }   \\n            else\\n                max_ele=max(max_ele,nums[i]);\\n        }\\n        return count;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int m=nums[0],count=1,max_ele=nums[0];\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(m>nums[i]){\\n                count=i+1;\\n            m=max(max_ele,m);\\n            }   \\n            else\\n                max_ele=max(max_ele,nums[i]);\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n      int m=nums[0],count=1,max_ele=nums[0];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(m>nums[i]){\\n                count=i+1;\\n            m=Math.max(max_ele,m);\\n            }   \\n            else\\n                max_ele=Math.max(max_ele,nums[i]);\\n        }\\n        return count;  \\n    }\\n}\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar partitionDisjoint = function(nums) {\\n    let m=nums[0],count=1,max_ele=nums[0];\\n        for(let i=0;i<nums.length;i++)\\n        {\\n            if(m>nums[i]){\\n                count=i+1;\\n            m=Math.max(max_ele,m);\\n            }   \\n            else\\n                max_ele=Math.max(max_ele,nums[i]);\\n        }\\n        return count; \\n};\\n```\n```\\n\\n\\nint partitionDisjoint(int* nums, int numsSize){\\n    int max(int a,int b)\\n    {\\n        if(a>b)\\n            return a;\\n    return b;\\n    }\\nint m=nums[0],count=1,max_ele=nums[0];\\n        for(int i=0;i<numsSize;i++)\\n        {\\n            if(m>nums[i]){\\n                count=i+1;\\n                \\n            m=max(max_ele,m);\\n            }   \\n            else\\n                max_ele=max(max_ele,nums[i]);\\n        }\\n        return count;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1355422,
                "title": "easy-solution-python-o-n-time",
                "content": "```\\ndef partitionDisjoint(self, nums: List[int]) -> int:\\n        left_max = nums[0]\\n        next_max = 0\\n        ans = 0\\n        for i in range(1, len(nums)):\\n            if nums[i] > next_max:\\n                next_max = nums[i]\\n                \\n            if nums[i] < left_max:\\n                ans = i\\n                if next_max > left_max:\\n                    left_max = next_max\\n        return ans + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Combinatorics"
                ],
                "code": "```\\ndef partitionDisjoint(self, nums: List[int]) -> int:\\n        left_max = nums[0]\\n        next_max = 0\\n        ans = 0\\n        for i in range(1, len(nums)):\\n            if nums[i] > next_max:\\n                next_max = nums[i]\\n                \\n            if nums[i] < left_max:\\n                ans = i\\n                if next_max > left_max:\\n                    left_max = next_max\\n        return ans + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1355410,
                "title": "simple-o-n-python-beats-98-27-speed-and-92-1-space",
                "content": "\\n        \\nAlgorithm: We pick the first elemet of the list and put it in the left partition (we must have at least one element in left partition). Then we define two variables to solve the question: ```maxleft =``` maximum number that is on the left partition and ```maxtotal =``` maximum number that we have seen until now in the array. \\n        \\n We parse the array and keep track of the ```maxleft``` and ```maxtotal```. If we reach to a number that is smaller than maxleft, we need to add all elements up to that index (inclusive) into the left partition and update the ```maxleft``` with ```maxtotal```. Also we need to increase the ans. \\n        \\nExample: [4, 3, 0, 7, 1 , 8]\\nstart iterating:\\nstep1: left = [4] , maxleft = 4, maxtotal = 4, ans = 1\\nstep2: 3 is smaller than 4 so we have left = [4, 3], maxleft = 4 , maxtotal = 4, ans = 2\\nstep3: left = [4, 3, 0], maxleft = 4, maxtotal = 4, ans = 3\\nstep4: left = [4, 3, 0], maxleft = 4, maxtotal = 7, ans = 3\\nstep5: 1 is less than maxleft so-> left = [4, 3, 0, 7, 1], maxleft = 7, maxtotal = 7, ans = 5\\nstep6: 8 is greater than 7 so we are done. left = [4, 3, 0, 7, 1], right = [8]\\n        \\n\\n        \\n        \\n        \\n```\\n   class Solution:\\n\\t   def partitionDisjoint(self, nums: List[int]) -> int:\\n\\t\\t\\tans = 1 \\n\\t\\t\\tmaxleft = nums[0] \\n\\n\\t\\t\\tmaxtotal = nums[0] \\n\\n\\t\\t\\tfor n in range(1, len(nums)):\\n\\t\\t\\t\\tif nums[n] > maxtotal:\\n\\t\\t\\t\\t\\tmaxtotal = nums[n]\\n\\t\\t\\t\\telif nums[n] < maxleft:\\n\\t\\t\\t\\t\\tans = n + 1\\n\\t\\t\\t\\t\\tmaxleft = maxtotal\\n\\t\\t\\treturn ans\\n\\n\\n",
                "solutionTags": [],
                "code": "```maxleft =```\n```maxtotal =```\n```maxleft```\n```maxtotal```\n```maxleft```\n```maxtotal```",
                "codeTag": "Unknown"
            },
            {
                "id": 1355377,
                "title": "python3-the-easiest-way-to-solve-this-problem-in-my-opinion",
                "content": "I think this is the most straightforward way to understand this problem:\\nUsing \\'maxx\\' to store the maximum of left array and \\'minn\\' to store the minimum of right array. In the for loop, checking if the minimum of right array needs to be updated and updating the maximum of left array. Once the minn is greater than maxx, return i + 1 as the length of left array.\\n\\t\\n\\tclass Solution:\\n\\t\\tdef partitionDisjoint(self, nums: List[int]) -> int:\\n\\t\\t\\tlng = len(nums)\\n\\t\\t\\tmaxx, minn = nums[0], min(nums[1:])\\n        \\n\\t\\t\\tfor i in range(lng):\\n\\t\\t\\t\\tmaxx = max(maxx, nums[i])\\n\\t\\t\\t\\tif minn == nums[i]: minn = min(nums[i + 1:])\\n\\t\\t\\t\\tif maxx <= minn: return i + 1\\n\\nThis might not be the best solution, please leave comments and let me know if there\\u2019s blind spot exist and how to improve.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "I think this is the most straightforward way to understand this problem:\\nUsing \\'maxx\\' to store the maximum of left array and \\'minn\\' to store the minimum of right array. In the for loop, checking if the minimum of right array needs to be updated and updating the maximum of left array. Once the minn is greater than maxx, return i + 1 as the length of left array.\\n\\t\\n\\tclass Solution:\\n\\t\\tdef partitionDisjoint(self, nums: List[int]) -> int:\\n\\t\\t\\tlng = len(nums)\\n\\t\\t\\tmaxx, minn = nums[0], min(nums[1:])\\n        \\n\\t\\t\\tfor i in range(lng):\\n\\t\\t\\t\\tmaxx = max(maxx, nums[i])\\n\\t\\t\\t\\tif minn == nums[i]: minn = min(nums[i + 1:])\\n\\t\\t\\t\\tif maxx <= minn: return i + 1\\n\\nThis might not be the best solution, please leave comments and let me know if there\\u2019s blind spot exist and how to improve.",
                "codeTag": "Java"
            },
            {
                "id": 1355147,
                "title": "c-easy-to-understand-time-o-n-space-o-1",
                "content": "\\n1. lets assume we have only one element(i.e arr[0]) in left subarray.\\n\\n2. max element of left arry (lmax) for now is arr[0] and partition is at 1.\\n\\n3. Traverse all the elements from 1 to n-1.\\n\\n    - if element is smaller than lmax, increase partition by 1;\\n    \\n    - else if element is greater than lmax, take all the element ahead as a right subarray part untill its\\n        reaches the end while doing that also store the max element of right subarray (rmax).\\n        \\n        - if we get a element which is smaller than lmax then, new partitoion is index of smaller element + 1 and max element of new left subarray is max of the right subarray we calculated. \\n\\n```\\n/*\\n1. lets assume we have only one element(i.e arr[0]) in left subarray.\\n2. max element of left arry (lmax) for now is arr[0] and partition is at 1.\\n3. Traverse all the elements from 1 to n-1.\\n    - if element is smaller than lmax, increase partition by 1;\\n    - else if element is greater than lmax, take all the element ahead as a right subarray part untill its\\n        reaches the end while doing that also store the max element of right subarray (rmax).\\n        \\n        - if we get a element which is smaller than lmax then, new partitoion is index of smaller element + 1\\n            and max element of new left subarray is max of the right subarray we calculated. \\n\\n*/\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& arr) {\\n        int lmax = arr[0]; \\n        int partition = 1;\\n        for(int i=1;i<arr.size();){\\n            if(arr[i] < lmax){\\n                partition++;\\n                i++;\\n            }else{\\n                int j=i;\\n                int rmax = 0;\\n                while(j<arr.size()){\\n                    if(arr[j] < lmax){\\n                        lmax = rmax;\\n                        partition = j + 1;\\n                        break;\\n                    }else{\\n                        rmax = max(rmax,arr[j]);\\n                    }\\n                    j++;\\n                }\\n                i = j+1;\\n            }\\n        }\\n        return partition;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\n1. lets assume we have only one element(i.e arr[0]) in left subarray.\\n2. max element of left arry (lmax) for now is arr[0] and partition is at 1.\\n3. Traverse all the elements from 1 to n-1.\\n    - if element is smaller than lmax, increase partition by 1;\\n    - else if element is greater than lmax, take all the element ahead as a right subarray part untill its\\n        reaches the end while doing that also store the max element of right subarray (rmax).\\n        \\n        - if we get a element which is smaller than lmax then, new partitoion is index of smaller element + 1\\n            and max element of new left subarray is max of the right subarray we calculated. \\n\\n*/\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& arr) {\\n        int lmax = arr[0]; \\n        int partition = 1;\\n        for(int i=1;i<arr.size();){\\n            if(arr[i] < lmax){\\n                partition++;\\n                i++;\\n            }else{\\n                int j=i;\\n                int rmax = 0;\\n                while(j<arr.size()){\\n                    if(arr[j] < lmax){\\n                        lmax = rmax;\\n                        partition = j + 1;\\n                        break;\\n                    }else{\\n                        rmax = max(rmax,arr[j]);\\n                    }\\n                    j++;\\n                }\\n                i = j+1;\\n            }\\n        }\\n        return partition;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354875,
                "title": "simple-c-one-pass-solution-o-n-time-o-1-space",
                "content": "There are 2 cases where we want to update the left subarray:\\n1. We found a number in the right subarray smaller than the minimum of the left subarray.\\n2. We found a number in the right subarray not less than the minimum but it\\'s less than the maximum of the left subarray.\\nIn both cases the end of the left subarray would be the current index -> partition index is current index + 1\\n\\nWe assume that the left subarray consists of the first index only and loop over the array from 1 to array size - 2 since both left and right subarrays can\\'t be empty.\\n* We update the `maximum` with each loop\\n* Whenever we find a new minimum we update the `minimum`, the `partition` index, and the `newMax` which is the maximum of the left subarray. \\n* Whenever we find a number > `minimum` and < `newMax` we update the `partition` index and the `newMax`\\n```\\nint partitionDisjoint(vector<int>& nums) {\\n        int partition = 1;\\n        int minimum = nums[0], maximum = nums[0], newMax = nums[0];\\n        for (int i = 1; i < nums.size() - 1; i++) {\\n            maximum = max(maximum, nums[i]);\\n            if (nums[i] <= minimum) {\\n                minimum = nums[i];\\n                newMax = maximum;\\n                partition = i + 1;\\n            } else if (nums[i] > minimum && nums[i] < newMax) {\\n                partition = i + 1;\\n                newMax = maximum;\\n            }\\n        }\\n        \\n        return partition;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint partitionDisjoint(vector<int>& nums) {\\n        int partition = 1;\\n        int minimum = nums[0], maximum = nums[0], newMax = nums[0];\\n        for (int i = 1; i < nums.size() - 1; i++) {\\n            maximum = max(maximum, nums[i]);\\n            if (nums[i] <= minimum) {\\n                minimum = nums[i];\\n                newMax = maximum;\\n                partition = i + 1;\\n            } else if (nums[i] > minimum && nums[i] < newMax) {\\n                partition = i + 1;\\n                newMax = maximum;\\n            }\\n        }\\n        \\n        return partition;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354731,
                "title": "java-o-n-simple-clear",
                "content": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int n = nums.length;\\n        int[] maxLeft = new int[n], minRight = new int[n];\\n        maxLeft[0] = nums[0];\\n        for(int i = 1; i < n; i++)\\n            maxLeft[i] = Math.max(nums[i], maxLeft[i - 1]);\\n        minRight[n - 1] = nums[n - 1];\\n        for(int i = n - 2; i >= 0; i--)\\n            minRight[i] = Math.min(nums[i], minRight[i + 1]);\\n        for(int i = 1; i < n; i++)\\n            if(maxLeft[i - 1] <= minRight[i])\\n                return i;\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int n = nums.length;\\n        int[] maxLeft = new int[n], minRight = new int[n];\\n        maxLeft[0] = nums[0];\\n        for(int i = 1; i < n; i++)\\n            maxLeft[i] = Math.max(nums[i], maxLeft[i - 1]);\\n        minRight[n - 1] = nums[n - 1];\\n        for(int i = n - 2; i >= 0; i--)\\n            minRight[i] = Math.min(nums[i], minRight[i + 1]);\\n        for(int i = 1; i < n; i++)\\n            if(maxLeft[i - 1] <= minRight[i])\\n                return i;\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354729,
                "title": "easy-c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n];\\n        dp[n-1] = nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            dp[i] = min(dp[i+1],nums[i]);\\n        }\\n        int len = 1;\\n        int m = -1;\\n        m = nums[0];\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(dp[i]>=m)\\n                break;\\n            else{\\n                m=max(nums[i],m);\\n                len++;}\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size();\\n        int dp[n];\\n        dp[n-1] = nums[n-1];\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            dp[i] = min(dp[i+1],nums[i]);\\n        }\\n        int len = 1;\\n        int m = -1;\\n        m = nums[0];\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(dp[i]>=m)\\n                break;\\n            else{\\n                m=max(nums[i],m);\\n                len++;}\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354625,
                "title": "easy-and-fast-solution-linear-time-and-constant-space",
                "content": "we will simply maintain the maximum number in the left interval and a running maximum and when ever we found a number less then the maximum in left we move our left to that number and make our left maximum to running maximum.\\n\\nfor eg:\\n\\t\\t\\t5, 4, 8, 6, 4, 9, 7 is the array so we start from 4 here rm(running maximum ) and lm(left maximum) is 4 so we shift our left interval to 4 similarly when we reach at next 4 our left interval is 2 and rm is 8 and lm is 5 now since 5 is greater than 4 so we move our left interval to 5 and now left maximum is 8.\\n\\t\\t\\t\\nhope you understant the logic which i used to solve this quesion.\\n\\n```\\nint partitionDisjoint(vector<int>& nums) {\\n        int m=nums[0],rm=nums[0],res=1;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            rm=max(nums[i],rm);\\n            if(nums[i]<m)\\n            {\\n                res=i+1;\\n                m=rm;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint partitionDisjoint(vector<int>& nums) {\\n        int m=nums[0],rm=nums[0],res=1;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            rm=max(nums[i],rm);\\n            if(nums[i]<m)\\n            {\\n                res=i+1;\\n                m=rm;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354597,
                "title": "partition-array-into-disjoint-intervals-solution-java-o-n",
                "content": "```\\npublic int partitionDisjoint(int[] nums) {\\n        int[] maxLeftArr = new int[nums.length];\\n        int[] minRightArr = new int[nums.length];\\n        int maxLeft = Integer.MIN_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            maxLeft = Math.max(maxLeft, nums[i]);\\n            maxLeftArr[i] = maxLeft;\\n        }\\n\\n        int minRight = Integer.MAX_VALUE;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            minRight = Math.min(minRight, nums[i]);\\n            minRightArr[i] = minRight;\\n        }\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (maxLeftArr[i] <= minRightArr[i + 1])\\n                return i + 1;\\n        }\\n\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int partitionDisjoint(int[] nums) {\\n        int[] maxLeftArr = new int[nums.length];\\n        int[] minRightArr = new int[nums.length];\\n        int maxLeft = Integer.MIN_VALUE;\\n        for (int i = 0; i < nums.length; i++) {\\n            maxLeft = Math.max(maxLeft, nums[i]);\\n            maxLeftArr[i] = maxLeft;\\n        }\\n\\n        int minRight = Integer.MAX_VALUE;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            minRight = Math.min(minRight, nums[i]);\\n            minRightArr[i] = minRight;\\n        }\\n\\n        for (int i = 0; i < nums.length - 1; i++) {\\n            if (maxLeftArr[i] <= minRightArr[i + 1])\\n                return i + 1;\\n        }\\n\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354593,
                "title": "java-solution-1ms-100-faster-easy",
                "content": "public int partitionDisjoint(int[] nums) {\\n        int max=nums[0];\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            int flag=1;\\n            if(nums[i]>max)\\n                max=nums[i];\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[j]<max)\\n                {\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n            if(flag==1)\\n                return i+1;\\n        }\\n        return 0;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public int partitionDisjoint(int[] nums) {\\n        int max=nums[0];\\n        for(int i=0;i<nums.length-1;i++)\\n        {\\n            int flag=1;\\n            if(nums[i]>max)\\n                max=nums[i];\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                if(nums[j]<max)\\n                {\\n                    flag=0;\\n                    break;\\n                }\\n            }\\n            if(flag==1)\\n                return i+1;\\n        }\\n        return 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1354566,
                "title": "python-one-pass-simple-solution-beats-100",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        leftmax = nums[0]\\n        currmax = nums[0]\\n        p = 0\\n        for i,n in enumerate(nums):\\n            currmax = max(currmax,n)\\n            if n < leftmax:\\n                leftmax = currmax\\n                p = i\\n        return p+1\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        leftmax = nums[0]\\n        currmax = nums[0]\\n        p = 0\\n        for i,n in enumerate(nums):\\n            currmax = max(currmax,n)\\n            if n < leftmax:\\n                leftmax = currmax\\n                p = i\\n        return p+1\\n",
                "codeTag": "Java"
            },
            {
                "id": 1354528,
                "title": "c-simple-o-n-time-and-o-1-space-solution",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint partitionDisjoint(vector<int>& nums) {\\n\\t\\t\\tint mx1=nums[0],mx2=nums[0],ans=0;\\n\\n\\t\\t\\tfor(int i=1;i<nums.size();i++) {\\n\\t\\t\\t\\tmx2=max(mx2,nums[i]);\\n\\t\\t\\t\\tif(mx1>nums[i]) {\\n\\t\\t\\t\\t\\tmx1=mx2; ans=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans+1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint partitionDisjoint(vector<int>& nums) {\\n\\t\\t\\tint mx1=nums[0],mx2=nums[0],ans=0;\\n\\n\\t\\t\\tfor(int i=1;i<nums.size();i++) {\\n\\t\\t\\t\\tmx2=max(mx2,nums[i]);\\n\\t\\t\\t\\tif(mx1>nums[i]) {\\n\\t\\t\\t\\t\\tmx1=mx2; ans=i;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1354489,
                "title": "partition-array-into-disjoint-intervals-python-easy-solution",
                "content": "# upvote if useful\\n![image](https://assets.leetcode.com/users/images/8b116f05-3166-48e8-8b9f-bf284f519ecf_1626941026.614562.png)\\n\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        a = list(accumulate(nums, max)) \\n        b = list(accumulate(nums[::-1], min))[::-1]\\n        for i in range(1, len(nums)):\\n            if a[i-1] <= b[i]: \\n                return i\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        a = list(accumulate(nums, max)) \\n        b = list(accumulate(nums[::-1], min))[::-1]\\n        for i in range(1, len(nums)):\\n            if a[i-1] <= b[i]: \\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354456,
                "title": "o-n-c-very-easy-approach-with-brief-explanation",
                "content": "**If you don\\'t like my solution please comment ,, do not downvote**\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        //here we need to find a left subarray where maximum among them is less than the minimum among the right subarray \\n\\t\\t//so we will keep track of min and max elements for each poiny\\n        int min_dp[30001];//keep a count of minimum from end of the array\\n        \\n        int max_dp[30001];//keep a count on the maximum element from the start\\n        \\n        max_dp[0] = nums[0];\\n        int ind =0;\\n       // int ind_2 = 0;\\n        for(int i=1;i<nums.size();i++){\\n            \\n            if(nums[i]>=max_dp[i-1]){\\n                max_dp[i] = nums[i];\\n              //  ind_2 =i;\\n            }\\n            else{\\n                max_dp[i] = max_dp[i-1];\\n                \\n            }\\n            \\n        }\\n        \\n        min_dp[nums.size()-1] = nums[nums.size()-1];\\n        \\n        for(int i=nums.size()-2;i>=0;i--){\\n            \\n            if(nums[i]<=min_dp[i+1]){\\n                min_dp[i] = nums[i];\\n            }\\n            else{\\n                min_dp[i] = min_dp[i+1];\\n            }\\n            \\n        }\\n        \\n        \\n        //we have to select the minimum length of left subarray so we will break at the first matching of conditions\\n        for(int i=1;i<nums.size();i++){\\n            //if max of o...to i-1 is <= to min of i to n then we found our point of intersection\\n            if(max_dp[i-1]<=min_dp[i]){\\n                ind = i;\\n                break;\\n            }\\n            \\n        }\\n      \\n        return ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        //here we need to find a left subarray where maximum among them is less than the minimum among the right subarray \\n\\t\\t//so we will keep track of min and max elements for each poiny\\n        int min_dp[30001];//keep a count of minimum from end of the array\\n        \\n        int max_dp[30001];//keep a count on the maximum element from the start\\n        \\n        max_dp[0] = nums[0];\\n        int ind =0;\\n       // int ind_2 = 0;\\n        for(int i=1;i<nums.size();i++){\\n            \\n            if(nums[i]>=max_dp[i-1]){\\n                max_dp[i] = nums[i];\\n              //  ind_2 =i;\\n            }\\n            else{\\n                max_dp[i] = max_dp[i-1];\\n                \\n            }\\n            \\n        }\\n        \\n        min_dp[nums.size()-1] = nums[nums.size()-1];\\n        \\n        for(int i=nums.size()-2;i>=0;i--){\\n            \\n            if(nums[i]<=min_dp[i+1]){\\n                min_dp[i] = nums[i];\\n            }\\n            else{\\n                min_dp[i] = min_dp[i+1];\\n            }\\n            \\n        }\\n        \\n        \\n        //we have to select the minimum length of left subarray so we will break at the first matching of conditions\\n        for(int i=1;i<nums.size();i++){\\n            //if max of o...to i-1 is <= to min of i to n then we found our point of intersection\\n            if(max_dp[i-1]<=min_dp[i]){\\n                ind = i;\\n                break;\\n            }\\n            \\n        }\\n      \\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354450,
                "title": "partition-array-into-disjoint-intervals-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        left_length = 1 \\n        left_max = curr_max = nums[0] \\n        for i in range(1, n-1): \\n            if nums[i] < left_max:\\n                left_length = i+1\\n                left_max = curr_max\\n            else:\\n                curr_max = max(curr_max, nums[i])\\n        return left_length\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        left_length = 1 \\n        left_max = curr_max = nums[0] \\n        for i in range(1, n-1): \\n            if nums[i] < left_max:\\n                left_length = i+1\\n                left_max = curr_max\\n            else:\\n                curr_max = max(curr_max, nums[i])\\n        return left_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1354435,
                "title": "python-fast-easy-with-explanation-o-n-152ms-80",
                "content": "**left_max** is the largest number in left subarray.\\n\\n**tmp_max** is the the largest number before idx i.\\n\\nOnly when nums[i] < left_max, which means we should add nums[i] into left subarray, we update left_max with tmp_max. (This is when we actually add number into left subarray.)\\n\\n**ans** mean the idx of the cut, so we return **(ans+1)** as the length of left subarray.\\n\\n```\\nclass Solution(object):\\n    def partitionDisjoint(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        N = len(nums)\\n        \\n        ans = 0\\n        left_max = nums[0]\\n        tmp_max = 0\\n        \\n        for i in range(N):\\n            tmp_max = max(tmp_max, nums[i])\\n            if nums[i] < left_max:\\n                ans = i\\n                left_max = tmp_max\\n                \\n        return ans+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def partitionDisjoint(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        N = len(nums)\\n        \\n        ans = 0\\n        left_max = nums[0]\\n        tmp_max = 0\\n        \\n        for i in range(N):\\n            tmp_max = max(tmp_max, nums[i])\\n            if nums[i] < left_max:\\n                ans = i\\n                left_max = tmp_max\\n                \\n        return ans+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337414,
                "title": "c-implementation-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        stack<int> s;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            if(s.empty())\\n            {\\n                s.push(nums[i]);\\n                continue;\\n            }\\n            s.push(min(s.top(),nums[i]));\\n        }\\n        int mx=INT_MIN;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            s.pop();\\n            mx=max(mx,nums[i]);\\n            if(s.top()>=mx)\\n            {\\n                return i+1;\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        stack<int> s;\\n        for(int i=nums.size()-1;i>=0;i--)\\n        {\\n            if(s.empty())\\n            {\\n                s.push(nums[i]);\\n                continue;\\n            }\\n            s.push(min(s.top(),nums[i]));\\n        }\\n        int mx=INT_MIN;\\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            s.pop();\\n            mx=max(mx,nums[i]);\\n            if(s.top()>=mx)\\n            {\\n                return i+1;\\n            }\\n        }\\n        return s.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335683,
                "title": "java-solution-100-faster-o-1-space-single-iteration",
                "content": "Things to check\\n1. If a number is part of the left partition, all numbers in right partition should be greater than it.\\n\\n\\nIf we find a number which is smaller than the max value in left partition, we include this number in our left partition and also need  to change the max of the left partition. \\n\\nVariables \\n- test : the current max in the left partition\\n- mark : the end index of the left partition\\n- max : the max of all the elements processed till now, we need this max to change our test in case a number smaller than test shows up. We have to include that number in our left partition and thus `test` is not the max value in left partition.\\n\\n\\nReturn `mark` at the end.\\n\\n```\\nclass Solution {\\n    // linear traversal required\\n    public int partitionDisjoint(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        \\n        int test = nums[0];\\n        int max = nums[0];\\n        int mark = 0;\\n        \\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i] < test){\\n                mark = i;\\n                test = max;\\n            }else{\\n                max = nums[i]>max?nums[i]:max;\\n            }\\n        }\\n        return mark+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // linear traversal required\\n    public int partitionDisjoint(int[] nums) {\\n        if(nums == null || nums.length == 0) return 0;\\n        \\n        int test = nums[0];\\n        int max = nums[0];\\n        int mark = 0;\\n        \\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i] < test){\\n                mark = i;\\n                test = max;\\n            }else{\\n                max = nums[i]>max?nums[i]:max;\\n            }\\n        }\\n        return mark+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195402,
                "title": "java-dp-100-faster",
                "content": "```\\n\\tpublic int partitionDisjoint(int[] A) {\\n        int[] maxFromLeft= new int[A.length];\\n        int max= Integer.MIN_VALUE;\\n        int min= Integer.MAX_VALUE;\\n        for(int i=0; i<A.length; i++){\\n            if(A[i] > max) max= A[i];\\n            maxFromLeft[i]= max;\\n        }\\n        int index= A.length-1;\\n        for(int i= A.length-1; i>0; i--){\\n            if(min > A[i]) min= A[i];\\n            if(min >= maxFromLeft[i-1]) index= i;\\n        }\\n        return index;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int partitionDisjoint(int[] A) {\\n        int[] maxFromLeft= new int[A.length];\\n        int max= Integer.MIN_VALUE;\\n        int min= Integer.MAX_VALUE;\\n        for(int i=0; i<A.length; i++){\\n            if(A[i] > max) max= A[i];\\n            maxFromLeft[i]= max;\\n        }\\n        int index= A.length-1;\\n        for(int i= A.length-1; i>0; i--){\\n            if(min > A[i]) min= A[i];\\n            if(min >= maxFromLeft[i-1]) index= i;\\n        }\\n        return index;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1162142,
                "title": "c-o-n-short-explanation",
                "content": "* Index i satisfies the condition if the largest element from 0:i <= the smallest element from i+1:end.\\nSo we calculate the largest number at each index i from 0:end, and then calculate the minimum number at each index i from end:0. Once we find an index i such that largest_num[i] <= smallest_num[i+1], we are done.\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        int pos, size = A.size(), smallest = A[size - 1];\\n        vector<int> largest(size, A[0]);\\n        for (int i = 1; i < size; ++i)\\n        {\\n            largest[i] = max(largest[i - 1], A[i]);\\n        }\\n        \\n        for (int i = size - 2; i >= 0; --i)\\n        {\\n            if (largest[i] <= smallest)\\n            {\\n                pos = i;\\n            }\\n            \\n            smallest = min(smallest, A[i]);\\n        }\\n        \\n        return pos + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n        int pos, size = A.size(), smallest = A[size - 1];\\n        vector<int> largest(size, A[0]);\\n        for (int i = 1; i < size; ++i)\\n        {\\n            largest[i] = max(largest[i - 1], A[i]);\\n        }\\n        \\n        for (int i = size - 2; i >= 0; --i)\\n        {\\n            if (largest[i] <= smallest)\\n            {\\n                pos = i;\\n            }\\n            \\n            smallest = min(smallest, A[i]);\\n        }\\n        \\n        return pos + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1152238,
                "title": "java-o-n-100",
                "content": "```\\npublic int partitionDisjoint(int[] A) {\\n        int len = A.length;\\n        int[] mins = new int[len];\\n        int min = Integer.MAX_VALUE;\\n        for (int i = len - 1; i >= 0; i--) {\\n            min = Math.min(min, A[i]);\\n            mins[i] = min;\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < len - 1; i++) {\\n            max = Math.max(max, A[i]);\\n            if (max <= mins[i + 1]) return i + 1;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int partitionDisjoint(int[] A) {\\n        int len = A.length;\\n        int[] mins = new int[len];\\n        int min = Integer.MAX_VALUE;\\n        for (int i = len - 1; i >= 0; i--) {\\n            min = Math.min(min, A[i]);\\n            mins[i] = min;\\n        }\\n        \\n        int max = Integer.MIN_VALUE;\\n        for (int i = 0; i < len - 1; i++) {\\n            max = Math.max(max, A[i]);\\n            if (max <= mins[i + 1]) return i + 1;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1110452,
                "title": "100-faster-100-efficient-time-o-n-space-o-1",
                "content": "![image](https://assets.leetcode.com/users/images/65e3de30-f760-4c14-a0a4-599f9c4822fd_1615792253.5822365.png)\\n```\\npublic class Solution {\\n    // Time O(n) || Space O(1)\\n    public int PartitionDisjoint(int[] A) {\\n        int leftMax = A[0], max=A[0], leftLen = 0;\\n        for(int i=1;i<A.Length;i++)\\n        {\\n            if(A[i]<leftMax)\\n            {\\n                leftLen = i;\\n                leftMax = Math.Max(leftMax,max);\\n            }\\n            max = Math.Max(max,A[i]);\\n        }\\n        return leftLen+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // Time O(n) || Space O(1)\\n    public int PartitionDisjoint(int[] A) {\\n        int leftMax = A[0], max=A[0], leftLen = 0;\\n        for(int i=1;i<A.Length;i++)\\n        {\\n            if(A[i]<leftMax)\\n            {\\n                leftLen = i;\\n                leftMax = Math.Max(leftMax,max);\\n            }\\n            max = Math.Max(max,A[i]);\\n        }\\n        return leftLen+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079099,
                "title": "java-o-n-time-and-o-1-space-solution-using-2-pointers",
                "content": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] a) {\\n        if (a.length == 0) return 0;\\n        int lo = 0;\\n        int hi = 1;\\n        int max = a[lo];\\n        \\n        while (hi < a.length) {\\n            while (lo != hi && a[hi] < max) {\\n                max = Math.max(a[lo++], max);\\n            }\\n            ++hi;\\n        }\\n        \\n        return lo+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] a) {\\n        if (a.length == 0) return 0;\\n        int lo = 0;\\n        int hi = 1;\\n        int max = a[lo];\\n        \\n        while (hi < a.length) {\\n            while (lo != hi && a[hi] < max) {\\n                max = Math.max(a[lo++], max);\\n            }\\n            ++hi;\\n        }\\n        \\n        return lo+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011039,
                "title": "python-3-two-pass",
                "content": "In first pass, record the leftmax for each number with index in range [1,n-1] inclusive.\\n\\nIn second pass, start from rightmost number, each time record the minimum number on the right including current number, if the minimum of the right is still no less than leftmost of this number, we take it as a valid count.\\n\\nReturn the length of total array minus maximum length of right hand array in each valid count.\\n```\\ndef partitionDisjoint(A):\\n\\tn=len(A)\\n\\tif n==2:\\n\\t\\treturn 1\\n\\tres,cur=[],A[0]\\n\\tfor idx in range(1,n-1):\\n\\t\\tcur=max(cur,A[idx-1])\\n\\t\\tres.append(cur)\\n\\trmin,ans=A[-1],1\\n\\tfor x in reversed(range(len(res))):\\n\\t\\trmin=min(rmin,A[x+1])\\n\\t\\tif rmin>=res[x]:\\n\\t\\t\\tans=max(ans,n-x-1)\\n\\treturn n-ans\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\ndef partitionDisjoint(A):\\n\\tn=len(A)\\n\\tif n==2:\\n\\t\\treturn 1\\n\\tres,cur=[],A[0]\\n\\tfor idx in range(1,n-1):\\n\\t\\tcur=max(cur,A[idx-1])\\n\\t\\tres.append(cur)\\n\\trmin,ans=A[-1],1\\n\\tfor x in reversed(range(len(res))):\\n\\t\\trmin=min(rmin,A[x+1])\\n\\t\\tif rmin>=res[x]:\\n\\t\\t\\tans=max(ans,n-x-1)\\n\\treturn n-ans\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 880661,
                "title": "python-98-intuitive-solution",
                "content": "We start with two arrays, a and b.\\na stores the maximum element encountered so far.\\nb stores the minimum element encountered so far on the reversed original array.\\nWe then find the least index i for which a[i]<=b[i+1]\\n\\nWe use the \\'accumulate\\' method from the itertools module.\\nUpvote if you found it useful. :))\\n\\n\\tclass Solution:\\n\\t\\tdef partitionDisjoint(self, A: List[int]) -> int:\\n\\t\\t\\tfrom itertools import accumulate\\n\\n\\t\\t\\ta = accumulate(A,func=max)\\n\\t\\t\\ta = list(a)\\n\\t\\t\\tA.reverse()\\n\\t\\t\\tb = accumulate(A,func=min)\\n\\t\\t\\tb = list(b)\\n\\t\\t\\tb.reverse()\\n\\t\\t\\tfor i in range(len(A)):\\n\\t\\t\\t\\tif a[i]<=b[i+1]:\\n\\t\\t\\t\\t\\treturn i+1",
                "solutionTags": [],
                "code": "We start with two arrays, a and b.\\na stores the maximum element encountered so far.\\nb stores the minimum element encountered so far on the reversed original array.\\nWe then find the least index i for which a[i]<=b[i+1]\\n\\nWe use the \\'accumulate\\' method from the itertools module.\\nUpvote if you found it useful. :))\\n\\n\\tclass Solution:\\n\\t\\tdef partitionDisjoint(self, A: List[int]) -> int:\\n\\t\\t\\tfrom itertools import accumulate\\n\\n\\t\\t\\ta = accumulate(A,func=max)\\n\\t\\t\\ta = list(a)\\n\\t\\t\\tA.reverse()\\n\\t\\t\\tb = accumulate(A,func=min)\\n\\t\\t\\tb = list(b)\\n\\t\\t\\tb.reverse()\\n\\t\\t\\tfor i in range(len(A)):\\n\\t\\t\\t\\tif a[i]<=b[i+1]:\\n\\t\\t\\t\\t\\treturn i+1",
                "codeTag": "Java"
            },
            {
                "id": 871377,
                "title": "python-beats-99",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        ans = 1\\n        mx = A[0]\\n        possible = 0\\n        possible_mx = mx\\n        for i in range(1, len(A)):\\n            if A[i] < mx:\\n                ans += 1\\n                ans += possible\\n                possible = 0\\n                mx = max(possible_mx, mx)\\n            else:\\n                possible += 1\\n                possible_mx = max(possible_mx, A[i])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, A: List[int]) -> int:\\n        ans = 1\\n        mx = A[0]\\n        possible = 0\\n        possible_mx = mx\\n        for i in range(1, len(A)):\\n            if A[i] < mx:\\n                ans += 1\\n                ans += possible\\n                possible = 0\\n                mx = max(possible_mx, mx)\\n            else:\\n                possible += 1\\n                possible_mx = max(possible_mx, A[i])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790514,
                "title": "java-solution-beats-100",
                "content": "```java\\npublic int partitionDisjoint(int[] A) {\\n        // greedy\\n        int curMax = A[0];\\n        int globalMax = A[0];\\n        int j = 0;\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] < curMax) {\\n                j = i;\\n                curMax = globalMax;\\n            }\\n            globalMax = Math.max(globalMax, A[i]);\\n        }\\n        return j + 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int partitionDisjoint(int[] A) {\\n        // greedy\\n        int curMax = A[0];\\n        int globalMax = A[0];\\n        int j = 0;\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] < curMax) {\\n                j = i;\\n                curMax = globalMax;\\n            }\\n            globalMax = Math.max(globalMax, A[i]);\\n        }\\n        return j + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739772,
                "title": "javascript-solution",
                "content": "```\\nconst partitionDisjoint = (A) => {\\n    let res;\\n    for (let i = 1; i < A.length; i++) {\\n        let left = A.slice(0, i);\\n        let right = A.slice(i, A.length);\\n        if (Math.max.apply(Math, left) <= Math.min.apply(Math, right)) {\\n            res = i;\\n            break;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst partitionDisjoint = (A) => {\\n    let res;\\n    for (let i = 1; i < A.length; i++) {\\n        let left = A.slice(0, i);\\n        let right = A.slice(i, A.length);\\n        if (Math.max.apply(Math, left) <= Math.min.apply(Math, right)) {\\n            res = i;\\n            break;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 727188,
                "title": "c-concise-o-n-solution",
                "content": "Maximum of left window will be <= Minimum in right window \\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n     int n=A.size();\\n     vector<int>max_left(n);\\n     vector<int>min_right(n);\\n     max_left[0]=A[0];min_right[n-1]=A[n-1];\\n     for(int i=1;i<n;i++) max_left[i]=max(max_left[i-1],A[i]);\\n     for(int i=n-2;i>=0;i--) min_right[i]=min(min_right[i+1],A[i]);\\n     for(int i=0;i<n-1;i++)\\n     {\\n         if(max_left[i]<=min_right[i+1]) return i+1;\\n     }\\n     return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& A) {\\n     int n=A.size();\\n     vector<int>max_left(n);\\n     vector<int>min_right(n);\\n     max_left[0]=A[0];min_right[n-1]=A[n-1];\\n     for(int i=1;i<n;i++) max_left[i]=max(max_left[i-1],A[i]);\\n     for(int i=n-2;i>=0;i--) min_right[i]=min(min_right[i+1],A[i]);\\n     for(int i=0;i<n-1;i++)\\n     {\\n         if(max_left[i]<=min_right[i+1]) return i+1;\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 652570,
                "title": "rust-simple-solution-with-explanation-0ms-10-lines",
                "content": "\\nThis problem is actually asking us to find the minimum index `i` such that the **maximum** element of the sub-array `a[:i]` (not including `a[i]`) is less than or equal to the **minimum** element of the right part `a[i:]`. \\n\\nGiven this, we can find the answer in one pass with the help of two auxiliary variables, (1) `pre_max`: the maximum value of `a[:pos]` for an index `pos`, and (2) `total_max`: the current maximum value as we loop over the array.\\n\\nDuring the iteration, when we find the current value `n` is smaller than `pre_max`, we know `pos` can NOT be the answer, since `max(a[:pos] = pre_max > n`. We have to update our index `pos` to current index `i` and `pre_max` to the maximum value of `a[:i]`, which is exactly `total_max`. \\n\\nSince it is guaranteed there is at least one way to partition A as described. We do not need to worry about corner cases where we find no such valid index.\\n\\n### Rust solution\\n\\n```rust\\nimpl Solution {\\n    pub fn partition_disjoint(a: Vec<i32>) -> i32 {\\n        let mut pre_max = a[0]; \\n        let mut total_max = a[0];\\n        let mut pos = 0; \\n        for (i, n) in a.iter().enumerate() {\\n            if pre_max > *n {\\n                pre_max = total_max; \\n                pos = i; \\n            } else if total_max < *n {\\n                total_max = *n ;\\n            }\\n        }\\n        1 + pos as i32 \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn partition_disjoint(a: Vec<i32>) -> i32 {\\n        let mut pre_max = a[0]; \\n        let mut total_max = a[0];\\n        let mut pos = 0; \\n        for (i, n) in a.iter().enumerate() {\\n            if pre_max > *n {\\n                pre_max = total_max; \\n                pos = i; \\n            } else if total_max < *n {\\n                total_max = *n ;\\n            }\\n        }\\n        1 + pos as i32 \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 584223,
                "title": "o-n-time-o-1-space-intuitive-easy-idea-to-follow-explained",
                "content": "**What matters in this problem?**\\n* We keep a maximum number which is largest in left, because that is the number that matters when traversing across the array. All items in the right partition must be equal or greater than all numbers in the left partition.\\n* If any number is smaller than this maximum number, it has to go in the left partition.\\n* With this, it makes sense that if the number is smaller, just keep moving right. Example: [5,0,3,6,7]. The maximum number is 5 so the partition point cannot possibly be 0 or 3 because they are smaller than 5. It has to be 6 or 7.\\n\\nSet the max number to the first number of the array. This makes sense because think of [1,2,3,4,5]. 1 is the first potential max, and it actually is the answer to this problem: [1] and [2,3,4,5]. Because 1 is the max, 2 would be a potential partition point. (It is the correct one.)\\n\\nThere are 2 cases when we find a potential: it is the right one, or it is the wrong one:\\n\\n1. CORRECT CASE: If we encounter a number that is the same or larger, this is a potential partition. When we do, we need to scan from that number to the end of the array. If all numbers after are larger than our current max, then we have found the partition point, so just return end (which marks the size of the array). Example:  [5,0,3,5,6,7]. Max 5. We scan until we hit 5. Because 5 >= max (5) we can consider this the partition point. Scan until end. 5 is equal. (Equal is valid! think of a case like [1,1].) 6 is larger. 7 is larger. And we\\'ve hit the end of the array. Return end.\\n \\n1. INCORRECT CASE: The other case to consider is that this is a false partition point. Think of a case like: [5,0,3,6,7,2,10,11]. 6 is a potential point of partition but it is not correct. The answer is [5,0,3,6,7,2], [10,11]. If we encounter this case what can we do? We need to restart our search for the next candidate. However there can be numbers in our loop that are the new maximums (6, 7) that we are now calling part of our left partition, so in our searching loop we need to update the new maximum. The next candidate must be equal to or larger than 7.\\n\\nRepeat until end of the loop. If we have not found anything yet, the left partition is the entire array, so return the length of A.\\n\\nO(n) time because we never backtrack on our pointer. In the for loop, if we have the wrong partition point, we move end up to where the loop was scanning. If we have the right one we return the answer.\\nO(1) space just using a max variable and pointer.\\n\\nNot the cleanest solution, but I think with the thought process/code explained it is easy to follow or come up with alone.\\n\\n```\\n    public int partitionDisjoint(int[] A) {\\n        if (A.length <= 1) return A.length;\\n\\n        int max = A[0];\\n        int end = 1;\\n\\n        while (end < A.length) {\\n            if (A[end] >= max) { /* we have reached a potential partition point here*/\\n                boolean correct = true; /* end is the correct point unless we find a number in right smaller than max*/\\n                int newMax = max; /*temp variable to find the new max, if exists*/\\n                for (int i = end; i < A.length; ++i) { /*loop through the rest of the array and see if this is the correct partition point or not*/\\n                    newMax = Math.max(newMax, A[i]); /*update new max, if exists */\\n                    if (A[i] < max) { /*there is a smaller number in right of end so this point is not the answer. update end, max and keep scanning.*/\\n                        end = i; /* move end up to the number we just found smaller than max, the next num is the next valid point to check */\\n                        max = newMax; /*new maximum number in left array */\\n                        correct = false; /* there is a smaller number in right, we have not found the correct point */\\n                        break;\\n                    }\\n                }\\n                if (correct) { /*we have reached here without finding any smaller numbers (entering the above for loop), all numbers are larger than max in left. Return end.*/\\n                    return end;\\n                }\\n            }\\n            end++;\\n        }\\n        return A.length;\\n    }",
                "solutionTags": [],
                "code": "**What matters in this problem?**\\n* We keep a maximum number which is largest in left, because that is the number that matters when traversing across the array. All items in the right partition must be equal or greater than all numbers in the left partition.\\n* If any number is smaller than this maximum number, it has to go in the left partition.\\n* With this, it makes sense that if the number is smaller, just keep moving right. Example: [5,0,3,6,7]. The maximum number is 5 so the partition point cannot possibly be 0 or 3 because they are smaller than 5. It has to be 6 or 7.\\n\\nSet the max number to the first number of the array. This makes sense because think of [1,2,3,4,5]. 1 is the first potential max, and it actually is the answer to this problem: [1] and [2,3,4,5]. Because 1 is the max, 2 would be a potential partition point. (It is the correct one.)\\n\\nThere are 2 cases when we find a potential: it is the right one, or it is the wrong one:\\n\\n1. CORRECT CASE: If we encounter a number that is the same or larger, this is a potential partition. When we do, we need to scan from that number to the end of the array. If all numbers after are larger than our current max, then we have found the partition point, so just return end (which marks the size of the array). Example:  [5,0,3,5,6,7]. Max 5. We scan until we hit 5. Because 5 >= max (5) we can consider this the partition point. Scan until end. 5 is equal. (Equal is valid! think of a case like [1,1].) 6 is larger. 7 is larger. And we\\'ve hit the end of the array. Return end.\\n \\n1. INCORRECT CASE: The other case to consider is that this is a false partition point. Think of a case like: [5,0,3,6,7,2,10,11]. 6 is a potential point of partition but it is not correct. The answer is [5,0,3,6,7,2], [10,11]. If we encounter this case what can we do? We need to restart our search for the next candidate. However there can be numbers in our loop that are the new maximums (6, 7) that we are now calling part of our left partition, so in our searching loop we need to update the new maximum. The next candidate must be equal to or larger than 7.\\n\\nRepeat until end of the loop. If we have not found anything yet, the left partition is the entire array, so return the length of A.\\n\\nO(n) time because we never backtrack on our pointer. In the for loop, if we have the wrong partition point, we move end up to where the loop was scanning. If we have the right one we return the answer.\\nO(1) space just using a max variable and pointer.\\n\\nNot the cleanest solution, but I think with the thought process/code explained it is easy to follow or come up with alone.\\n\\n```\\n    public int partitionDisjoint(int[] A) {\\n        if (A.length <= 1) return A.length;\\n\\n        int max = A[0];\\n        int end = 1;\\n\\n        while (end < A.length) {\\n            if (A[end] >= max) { /* we have reached a potential partition point here*/\\n                boolean correct = true; /* end is the correct point unless we find a number in right smaller than max*/\\n                int newMax = max; /*temp variable to find the new max, if exists*/\\n                for (int i = end; i < A.length; ++i) { /*loop through the rest of the array and see if this is the correct partition point or not*/\\n                    newMax = Math.max(newMax, A[i]); /*update new max, if exists */\\n                    if (A[i] < max) { /*there is a smaller number in right of end so this point is not the answer. update end, max and keep scanning.*/\\n                        end = i; /* move end up to the number we just found smaller than max, the next num is the next valid point to check */\\n                        max = newMax; /*new maximum number in left array */\\n                        correct = false; /* there is a smaller number in right, we have not found the correct point */\\n                        break;\\n                    }\\n                }\\n                if (correct) { /*we have reached here without finding any smaller numbers (entering the above for loop), all numbers are larger than max in left. Return end.*/\\n                    return end;\\n                }\\n            }\\n            end++;\\n        }\\n        return A.length;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 435454,
                "title": "easy-to-understand-solution-with-explanation",
                "content": "**Explanation**\\n\\nThe idea is to grow the solution from left to right. The left partition starts with a partition of size 1. To grow the partition, we just need to iterate through all the items & check if the current item should be inserted into the left partition. It is important to note that the left partition is not necessarily be `n - 1` (if the current index is `n`). In the code below, the left partition index is stored as `ans`.\\n\\n`dp` is needed here for a fast lookup of the largest value for given left partition. Given a left partition with its right-most index being `n`, `dp[n]` equals the largest value of the partition that ends at index `n`.\\n\\nThe _boxes_ in the diagram below are drawn everytime we update the size of the left partition. Notice that in _eg 2_, we skip two items (denoted with the _x_) before doing the final partition of length `4`. In _eg 2_, when deciding to grow the partition the second time, we compare the largest value of the first _box_ (with one item in it).\\n\\n![image](https://assets.leetcode.com/users/cglotr/image_1574476397.png)\\n\\n**Code**\\n\\n```Java\\nclass Solution {\\n    \\n    public int partitionDisjoint(int[] A) {\\n        int m = A.length;\\n        \\n\\t\\t// if i want to know what is the largest value of\\n\\t\\t// the left partition that ends with index 3, dp[3]\\n\\t\\t// will give me the answer to that\\n        int[] dp = new int[m];\\n        dp[0] = A[0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i] = Math.max(dp[i - 1], A[i]);\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 1; i < m; i++) {\\n            if (A[i] < dp[ans]) {\\n                ans = i;\\n            }\\n        }\\n        return ans + 1;\\n    }\\n    \\n}\\n\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```Java\\nclass Solution {\\n    \\n    public int partitionDisjoint(int[] A) {\\n        int m = A.length;\\n        \\n\\t\\t// if i want to know what is the largest value of\\n\\t\\t// the left partition that ends with index 3, dp[3]\\n\\t\\t// will give me the answer to that\\n        int[] dp = new int[m];\\n        dp[0] = A[0];\\n        for (int i = 1; i < m; i++) {\\n            dp[i] = Math.max(dp[i - 1], A[i]);\\n        }\\n        \\n        int ans = 0;\\n        for (int i = 1; i < m; i++) {\\n            if (A[i] < dp[ans]) {\\n                ans = i;\\n            }\\n        }\\n        return ans + 1;\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395196,
                "title": "intuitive-java-solution",
                "content": "```\\npublic int partitionDisjoint(int[] a) {\\n        int n = a.length;\\n        int[] maxFromLeft = new int[n], minFromRight = new int[n];\\n        maxFromLeft[0] = a[0];\\n        for(int i=1; i < n; i++)\\n            maxFromLeft[i] = Math.max(a[i], maxFromLeft[i-1]);\\n        minFromRight[n-1] = a[n-1];\\n        for(int i=n-2; i >= 0; i--)\\n            minFromRight[i] = Math.min(a[i], minFromRight[i+1]);\\n        for(int i=0; i < n-1; i++)\\n            if(maxFromLeft[i] <= minFromRight[i+1])\\n                return i+1;\\n        return 0;\\n    }\\n```\\n**PS** It is not hard to implement the same logic without `maxFromLeft` array completely.\\n",
                "solutionTags": [],
                "code": "```\\npublic int partitionDisjoint(int[] a) {\\n        int n = a.length;\\n        int[] maxFromLeft = new int[n], minFromRight = new int[n];\\n        maxFromLeft[0] = a[0];\\n        for(int i=1; i < n; i++)\\n            maxFromLeft[i] = Math.max(a[i], maxFromLeft[i-1]);\\n        minFromRight[n-1] = a[n-1];\\n        for(int i=n-2; i >= 0; i--)\\n            minFromRight[i] = Math.min(a[i], minFromRight[i+1]);\\n        for(int i=0; i < n-1; i++)\\n            if(maxFromLeft[i] <= minFromRight[i+1])\\n                return i+1;\\n        return 0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 378529,
                "title": "python-3-solution-beats-97-time-o-n-space-o-1",
                "content": "\\n```\\ndef partitionDisjoint(A: list):\\n    left_max = A[0]\\n    next_max = 0\\n    res = 0\\n    for i in range(1, len(A)):\\n        if A[i] > next_max:\\n            next_max = A[i]\\n        if A[i] < left_max:\\n            res = i\\n            if next_max > left_max:\\n                left_max = next_max\\n    return res + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef partitionDisjoint(A: list):\\n    left_max = A[0]\\n    next_max = 0\\n    res = 0\\n    for i in range(1, len(A)):\\n        if A[i] > next_max:\\n            next_max = A[i]\\n        if A[i] < left_max:\\n            res = i\\n            if next_max > left_max:\\n                left_max = next_max\\n    return res + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 273269,
                "title": "java-two-solutions-with-explanation",
                "content": "* scan from left to right and right to left\\n* we just need to make sure the `max` of left part is smaller or equal to `min` of right part\\n\\n```\\npublic int partitionDisjoint(int[] A) {\\n        int n = A.length, ltr[] = new int[n], rtl[] = new int[n], max = -1, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(max, A[i]);\\n            ltr[i] = max;\\n            min = Math.min(min, A[n - 1 - i]);\\n            rtl[n - 1 - i] = min;\\n        }\\n        for (int i = 0; i < n - 1; i++) {\\n            if (ltr[i] <= rtl[i + 1]) return i + 1;\\n        }\\n        return -1;\\n    }\\n```\\n\\n\\n * optimization:\\n * keep track of cur/left max\\n * keep track of the position/index of partition\\n * scan through the array:\\n   *   if max value is larger then cur max, that is good\\n   *   if after that max value, there is an element smaller then cur max, then we should update the cur max as max\\n   *   and that is the reason, we also need to keep track of `max` which means the maximum value of all previous element\\n\\n```\\n    public int partitionDisjoint1(int[] A) {\\n        int curMax = A[0], pos = 0, max = A[0];\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] < curMax) {\\n                pos = i;\\n                curMax = max;\\n            } else if (A[i] > max) {\\n                max = A[i];\\n            }\\n        }\\n        return pos + 1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int partitionDisjoint(int[] A) {\\n        int n = A.length, ltr[] = new int[n], rtl[] = new int[n], max = -1, min = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            max = Math.max(max, A[i]);\\n            ltr[i] = max;\\n            min = Math.min(min, A[n - 1 - i]);\\n            rtl[n - 1 - i] = min;\\n        }\\n        for (int i = 0; i < n - 1; i++) {\\n            if (ltr[i] <= rtl[i + 1]) return i + 1;\\n        }\\n        return -1;\\n    }\\n```\n```\\n    public int partitionDisjoint1(int[] A) {\\n        int curMax = A[0], pos = 0, max = A[0];\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] < curMax) {\\n                pos = i;\\n                curMax = max;\\n            } else if (A[i] > max) {\\n                max = A[i];\\n            }\\n        }\\n        return pos + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 251736,
                "title": "python-solution-o-n-runtime-o-1-space",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        prevbest = A[0]\\n        best = A[0]\\n        n = len(A)\\n\\n        ans = 0\\n        for i in range(1, n - 1):\\n            best = max(best, A[i])\\n            if A[i] < prevbest:\\n                prevbest = best\\n                ans = i\\n\\n        return ans + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        prevbest = A[0]\\n        best = A[0]\\n        n = len(A)\\n\\n        ans = 0\\n        for i in range(1, n - 1):\\n            best = max(best, A[i])\\n            if A[i] < prevbest:\\n                prevbest = best\\n                ans = i\\n\\n        return ans + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187610,
                "title": "javascript-one-pass-solution-explanation-with-example",
                "content": "Explanation with example [1,1,1,0,6,0,5,7,12]\\n1: Initial partition >> [1],[1,1,0,6,0,5,7,12] && leftMaxValue=1\\n2: Once you find a smaller value(0), repartition >> [1,1,1,0], [6,0,5,7,12] && leftMaxValue=1\\n3: Find a smaller value(0), repartition >> [1,1,1,,0,6,0],[5,7,12] && leftMaxValue=6\\n4: Find a smaller value(0), repartition >> [1,1,1,0,6,0],[5,7,12] && leftMaxValue=6 \\n5: Find a smaller value(5), repartition >>  [1,1,1,,0,6,0,5],[7,12] && leftMaxValue=6 \\n6: Final >> left count = 7\\n```\\nvar partitionDisjoint = function(array) {\\n  var lLast = 0, lMaxValue = array[0];\\n  var rMaxValue= null;\\n  for(var i=1; i<array.length; i++) {\\n    var value = array[i];\\n    if(value >= lMaxValue) {\\n      rMaxValue = Math.max(rMaxValue||-Number.MAX_VALUE, value);\\n    } else {\\n      lLast=i;\\n      lMaxValue = Math.max(lMaxValue, rMaxValue||-Number.MAX_VALUE);\\n    }\\n  }\\n  return lLast+1;\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvar partitionDisjoint = function(array) {\\n  var lLast = 0, lMaxValue = array[0];\\n  var rMaxValue= null;\\n  for(var i=1; i<array.length; i++) {\\n    var value = array[i];\\n    if(value >= lMaxValue) {\\n      rMaxValue = Math.max(rMaxValue||-Number.MAX_VALUE, value);\\n    } else {\\n      lLast=i;\\n      lMaxValue = Math.max(lMaxValue, rMaxValue||-Number.MAX_VALUE);\\n    }\\n  }\\n  return lLast+1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 178330,
                "title": "simple-java-solution-time-o-n-one-pass-space-o-1",
                "content": "```\\nclass Solution {\\n public int partitionDisjoint(int[] A) {\\n  int globalMax = A[0];\\n  int localMax = A[0];\\n  int left = 1;\\n  for (int i = 1; i < A.length; i++) {\\n   if (A[i] < globalMax) {\\n    left = i + 1;\\n    globalMax = localMax;\\n   } else if (A[i] > localMax) {\\n    localMax = A[i];\\n   }\\n  }\\n  return left;\\n }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public int partitionDisjoint(int[] A) {\\n  int globalMax = A[0];\\n  int localMax = A[0];\\n  int left = 1;\\n  for (int i = 1; i < A.length; i++) {\\n   if (A[i] < globalMax) {\\n    left = i + 1;\\n    globalMax = localMax;\\n   } else if (A[i] > localMax) {\\n    localMax = A[i];\\n   }\\n  }\\n  return left;\\n }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 177399,
                "title": "python3-solution-o-n-time-o-1-space-with-explanation",
                "content": "The whole logic is to keep track of possible left set. The way to do is to keep track of the current known left set\\'s ending index and update it as needed. When it needs to get updated is when currently examined number is less than the current possible left set\\'s end or current possible left set\\'s maximum number is greater than the currently examined number. In those cases, possible left set\\'s end index needs to be set as the currently examined number and possible left set\\'s local max needs to be updated with currently known global max. Global max is the max number that is known up to and including the currently examined number.\\n1. Loop through all numbers\\n2. Update global max number if currrent number is greater. \\n3. If number in index is less than the current candidate number where left set ends or number at index is less than the max number of current potential left set, then update current as current index. Also update current local max with global max.\\n4. Return current candidate index + 1. The reason for +1 is to make up for array indices starting from 0.\\n\\n```\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        current = (A[0],0)\\n        localMax,globalMax = A[0],A[0]         \\n        \\n        for i in range(1,len(A)):            \\n            value,index = current\\n            if A[i] > globalMax:\\n                globalMax = A[i]            \\n            if A[i] < value or localMax > A[i]:\\n                current = (A[i],i)    \\n                localMax = globalMax\\n                                                     \\n        return current[1] + 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        current = (A[0],0)\\n        localMax,globalMax = A[0],A[0]         \\n        \\n        for i in range(1,len(A)):            \\n            value,index = current\\n            if A[i] > globalMax:\\n                globalMax = A[i]            \\n            if A[i] < value or localMax > A[i]:\\n                current = (A[i],i)    \\n                localMax = globalMax\\n                                                     \\n        return current[1] + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 176131,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def partitionDisjoint(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        rmin = [0]*len(A)\\n        currmin = float(\\'inf\\')\\n        for i in range(len(A)-1, -1, -1):\\n            currmin = min(currmin, A[i])\\n            rmin[i] = currmin\\n            \\n        lmax = -float(\\'inf\\')\\n        for i in range(len(A)-1):\\n            lmax = max(A[i], lmax)\\n            if lmax <= rmin[i+1]:\\n                return i+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def partitionDisjoint(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        rmin = [0]*len(A)\\n        currmin = float(\\'inf\\')\\n        for i in range(len(A)-1, -1, -1):\\n            currmin = min(currmin, A[i])\\n            rmin[i] = currmin\\n            \\n        lmax = -float(\\'inf\\')\\n        for i in range(len(A)-1):\\n            lmax = max(A[i], lmax)\\n            if lmax <= rmin[i+1]:\\n                return i+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175985,
                "title": "different-thinking-intuitive-explanation",
                "content": "This is not a one-pass solution and surely with a higher complexity. However, did not find this approach in other solution and though to mention it in the Discuss. \\n\\nAlgorithm : \\n1. Find an element that will always be in the partition and call it `val`\\n2. Mark all the elements in the array that are `less` than the above `val` \\n3. Repeat the process until we have `no gaps` in the partition. \\n\\nObservation 1 : The left most element of the array is always going to be a part of the partition. \\nReasons : It is guaranteed there is at least one way to partition A as described.\\n`Conclusion : The left most element sets as val for our first iteration.`\\n\\nFor e.g. : \\n![image](https://assets.leetcode.com/users/shreyansh94/image_1538291154.png)\\n\\nThus, return `5`, the length of the marked region. \\n\\nCode : \\n\\n```\\nclass Solution {\\n    public int findVal(boolean[] see, int[] A){\\n        for(int i = 0; i<A.length; ++i){\\n            if(!see[i])\\n                return i; \\n        }\\n        return -1; \\n    }\\n    public int partitionDisjoint(int[] A) {\\n        boolean[] see = new boolean[A.length]; \\n        boolean gap = true;  \\n        while(gap){\\n            gap = false; \\n            int ind = findVal(see, A);\\n            if(ind == -1)\\n                break; \\n            int val=A[ind]; \\n            see[ind]=true; \\n            for(int i = 0; i < A.length; ++i){\\n                if(A[i] < val){\\n                    see[i] = true; \\n                    if(i!=0 && see[i-1] == false)gap=true; \\n                }\\n            }\\n        }\\n        int count = 0; \\n        for(int i = 0 ; i < A.length; ++i){\\n            if(see[i])count++; \\n        }\\n        return count; \\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int findVal(boolean[] see, int[] A){\\n        for(int i = 0; i<A.length; ++i){\\n            if(!see[i])\\n                return i; \\n        }\\n        return -1; \\n    }\\n    public int partitionDisjoint(int[] A) {\\n        boolean[] see = new boolean[A.length]; \\n        boolean gap = true;  \\n        while(gap){\\n            gap = false; \\n            int ind = findVal(see, A);\\n            if(ind == -1)\\n                break; \\n            int val=A[ind]; \\n            see[ind]=true; \\n            for(int i = 0; i < A.length; ++i){\\n                if(A[i] < val){\\n                    see[i] = true; \\n                    if(i!=0 && see[i-1] == false)gap=true; \\n                }\\n            }\\n        }\\n        int count = 0; \\n        for(int i = 0 ; i < A.length; ++i){\\n            if(see[i])count++; \\n        }\\n        return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175846,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        i = 1\\n        while True:\\n            left = A[:i]\\n            right = A[i:]\\n            if max(left) > min(right):\\n                i += right.index(min(right)) + 1\\n            else:\\n                return i\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        i = 1\\n        while True:\\n            left = A[:i]\\n            right = A[i:]\\n            if max(left) > min(right):\\n                i += right.index(min(right)) + 1\\n            else:\\n                return i\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4087480,
                "title": "intuitive-2-pointer-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        c_h, c_l, min_greater, max_smaller=0, 1, math.inf, nums[0]\\n        max_greater= -math.inf\\n        for i, num in enumerate(nums[1:]):\\n            if num<min_greater and num<max_smaller:\\n                c_l+=c_h+1\\n                if c_h:\\n                    max_smaller = max(max_smaller, max_greater)\\n                    c_h =0\\n                    min_greater = max_greater\\n                max_smaller = max(max_smaller, num)\\n            else:\\n                c_h +=1\\n                max_greater= max(max_greater, num)\\n                min_greater = min(min_greater, num)                \\n        return c_l\\n\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        c_h, c_l, min_greater, max_smaller=0, 1, math.inf, nums[0]\\n        max_greater= -math.inf\\n        for i, num in enumerate(nums[1:]):\\n            if num<min_greater and num<max_smaller:\\n                c_l+=c_h+1\\n                if c_h:\\n                    max_smaller = max(max_smaller, max_greater)\\n                    c_h =0\\n                    min_greater = max_greater\\n                max_smaller = max(max_smaller, num)\\n            else:\\n                c_h +=1\\n                max_greater= max(max_greater, num)\\n                min_greater = min(min_greater, num)                \\n        return c_l\\n\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056615,
                "title": "easiest-solution-c-for-sure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int prevelement=nums[0];\\n        int  ans=1;\\n        int maxi=prevelement;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<prevelement)\\n            {\\n                ans=i+1;\\n                prevelement=maxi;\\n            }\\n            maxi=max(maxi,nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int prevelement=nums[0];\\n        int  ans=1;\\n        int maxi=prevelement;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<prevelement)\\n            {\\n                ans=i+1;\\n                prevelement=maxi;\\n            }\\n            maxi=max(maxi,nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015746,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int[] rightMin=new int[nums.length+1];\\n        rightMin[nums.length]=Integer.MAX_VALUE;\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            rightMin[i]=Math.min(rightMin[i+1],nums[i]);\\n        }\\n        int leftMax=Integer.MIN_VALUE;\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            leftMax=Math.max(leftMax,nums[i]);\\n            if(leftMax<=rightMin[i+1])\\n            {\\n                ans=i;\\n                break;\\n            }\\n\\n        }\\n        return ans+1;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int[] rightMin=new int[nums.length+1];\\n        rightMin[nums.length]=Integer.MAX_VALUE;\\n        for(int i=nums.length-1;i>=0;i--)\\n        {\\n            rightMin[i]=Math.min(rightMin[i+1],nums[i]);\\n        }\\n        int leftMax=Integer.MIN_VALUE;\\n        int ans=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            leftMax=Math.max(leftMax,nums[i]);\\n            if(leftMax<=rightMin[i+1])\\n            {\\n                ans=i;\\n                break;\\n            }\\n\\n        }\\n        return ans+1;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905267,
                "title": "simplest-method-only-by-using-one-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nlook for the min value .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst compare the lower value then the first value. Then update the max value we get upto that minimum value and now search for the next minimum value and continue the same thing .\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=0;\\n        int b=nums[0];\\n        int m=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(m<nums[i]){\\n                m=nums[i];\\n            }\\n            if(b>nums[i]){\\n                a=i;\\n                b=m;\\n               \\n            }\\n        }\\n        return a+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        int a=0;\\n        int b=nums[0];\\n        int m=nums[0];\\n        for(int i=1;i<n;i++){\\n            if(m<nums[i]){\\n                m=nums[i];\\n            }\\n            if(b>nums[i]){\\n                a=i;\\n                b=m;\\n               \\n            }\\n        }\\n        return a+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881278,
                "title": "cpp-solution-fast-in-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int mini = min_element(nums.begin(),nums.end()) - nums.begin();\\n        int i = mini + 1;\\n        int ind = mini;\\n        vector<int> v(nums.size(),nums[0]);\\n        for(int j=1;j<nums.size();j++)\\n        {\\n            if(v[j-1] < nums[j])\\n                v[j] = nums[j];\\n            else\\n                v[j] = v[j-1];\\n        }\\n        int maxi = v[mini];\\n        for(;i<nums.size()-1;i++)\\n        {\\n            if(nums[i] < maxi)\\n            {\\n                ind = i;\\n                maxi = v[i];\\n            }\\n        }\\n        return ind+1;\\n    }\\n};\\n// 2 1 4 0 10 3 9 7 11 \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int mini = min_element(nums.begin(),nums.end()) - nums.begin();\\n        int i = mini + 1;\\n        int ind = mini;\\n        vector<int> v(nums.size(),nums[0]);\\n        for(int j=1;j<nums.size();j++)\\n        {\\n            if(v[j-1] < nums[j])\\n                v[j] = nums[j];\\n            else\\n                v[j] = v[j-1];\\n        }\\n        int maxi = v[mini];\\n        for(;i<nums.size()-1;i++)\\n        {\\n            if(nums[i] < maxi)\\n            {\\n                ind = i;\\n                maxi = v[i];\\n            }\\n        }\\n        return ind+1;\\n    }\\n};\\n// 2 1 4 0 10 3 9 7 11 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3866792,
                "title": "partition-array-into-disjoint-intervals",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- BRUTE-FORCE- use chaining method intuition , use extra space as array , storing right min ie from back minimum and left max ,storing max from starting i respective array using chaining method . and then traverse array, and check left max value if found <= its next index right min value then that indx is the partition.\\nT-n S-n\\nOPTIMAL- USE 2  var greater and leftmax, greater storing max value during traversing and left max storing that greater vale when parrtitions found, during traversing , if any value found less than leftmax, it indicates that number is also a part of partition and that indx makes the partition. and replace value with greater to find more partition. T-n S-1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- BRUTE-FORCE- use chaining method intuition , use extra space as array , storing right min ie from back minimum and left max ,storing max from starting i respective array using chaining method . and then traverse array, and check left max value if found <= its next index right min value then that indx is the partition.\\nT-n S-n\\nOPTIMAL- USE 2  var greater and leftmax, greater storing max value during traversing and left max storing that greater vale when parrtitions found, during traversing , if any value found less than leftmax, it indicates that number is also a part of partition and that indx makes the partition. and replace value with greater to find more partition. T-n S-1\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- 1\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n\\n        int greater=nums[0];//will store the max value while traversing\\n        int leftmax=nums[0];//will store the value greater when we found a partition , ie num<leftmax, ie we have to add it in partition and , that num index is the partition\\n\\n        int ans=0;\\n\\n        for(int i=1;i<nums.size();i++)//we traverse the array\\n        {\\n            if(nums[i]<leftmax)//if found number less than leftmax ie number should be included in partition ,\\n            //                      then that number indx will be assigned to ans , and greater value to new leftmax\\n            {\\n                leftmax=greater;\\n                ans=i;\\n            }\\n            if(nums[i]>greater)//if found no >greater than assign that value to greater\\n            {\\n                greater=nums[i];\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n\\n// class Solution {                         //using extra space ie S-n using to store right minimum using CHAINING method, \\n//                                            for left max and right min\\n// public:\\n//     int partitionDisjoint(vector<int>& nums) {\\n\\n//         int n=nums.size();\\n//         vector<int>rmn(n+1);\\n       \\n//         rmn[n]=INT_MAX;\\n//         for(int i=n-1;i>=0;i--)\\n//         {\\n//             rmn[i]=min(nums[i],rmn[i+1]);\\n//         }\\n\\n//         int lmx=INT_MIN;\\n//         int ans=0;\\n//         for(int i=0;i<n-1;i++)\\n//         {\\n//             lmx=max(nums[i],lmx);\\n//             if(lmx<=rmn[i+1])\\n//             {\\n//                 ans=i;\\n//                 break;\\n//             }\\n//         }\\n\\n//         return ans+1;\\n//     }\\n// };\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n\\n        int greater=nums[0];//will store the max value while traversing\\n        int leftmax=nums[0];//will store the value greater when we found a partition , ie num<leftmax, ie we have to add it in partition and , that num index is the partition\\n\\n        int ans=0;\\n\\n        for(int i=1;i<nums.size();i++)//we traverse the array\\n        {\\n            if(nums[i]<leftmax)//if found number less than leftmax ie number should be included in partition ,\\n            //                      then that number indx will be assigned to ans , and greater value to new leftmax\\n            {\\n                leftmax=greater;\\n                ans=i;\\n            }\\n            if(nums[i]>greater)//if found no >greater than assign that value to greater\\n            {\\n                greater=nums[i];\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n\\n// class Solution {                         //using extra space ie S-n using to store right minimum using CHAINING method, \\n//                                            for left max and right min\\n// public:\\n//     int partitionDisjoint(vector<int>& nums) {\\n\\n//         int n=nums.size();\\n//         vector<int>rmn(n+1);\\n       \\n//         rmn[n]=INT_MAX;\\n//         for(int i=n-1;i>=0;i--)\\n//         {\\n//             rmn[i]=min(nums[i],rmn[i+1]);\\n//         }\\n\\n//         int lmx=INT_MIN;\\n//         int ans=0;\\n//         for(int i=0;i<n-1;i++)\\n//         {\\n//             lmx=max(nums[i],lmx);\\n//             if(lmx<=rmn[i+1])\\n//             {\\n//                 ans=i;\\n//                 break;\\n//             }\\n//         }\\n\\n//         return ans+1;\\n//     }\\n// };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3855653,
                "title": "o-n-solution-using-prefix-and-suffix-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n\\n\\n        # max(0 to i) > min(i + 1 :) \\n        n = len(nums)\\n\\n        prefix_max = [nums[i] for i in range(n)]\\n\\n        for i in range(1, n):\\n\\n            if nums[i] > prefix_max[i - 1]:\\n                prefix_max[i] = nums[i] \\n            else:\\n                prefix_max[i] = prefix_max[i - 1] \\n\\n        suffix_min = [nums[i] for i in range(n)] \\n\\n        for i in range(n - 2, -1, -1):\\n\\n            if nums[i] < suffix_min[i + 1]:\\n                suffix_min[i] = nums[i] \\n            else:\\n                suffix_min[i] = suffix_min[i + 1]\\n\\n        for i in range(n - 1):\\n\\n            if prefix_max[i] <= suffix_min[i + 1]:\\n                return i + 1\\n\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n\\n\\n        # max(0 to i) > min(i + 1 :) \\n        n = len(nums)\\n\\n        prefix_max = [nums[i] for i in range(n)]\\n\\n        for i in range(1, n):\\n\\n            if nums[i] > prefix_max[i - 1]:\\n                prefix_max[i] = nums[i] \\n            else:\\n                prefix_max[i] = prefix_max[i - 1] \\n\\n        suffix_min = [nums[i] for i in range(n)] \\n\\n        for i in range(n - 2, -1, -1):\\n\\n            if nums[i] < suffix_min[i + 1]:\\n                suffix_min[i] = nums[i] \\n            else:\\n                suffix_min[i] = suffix_min[i + 1]\\n\\n        for i in range(n - 1):\\n\\n            if prefix_max[i] <= suffix_min[i + 1]:\\n                return i + 1\\n\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773538,
                "title": "very-easy-c-solution-prefix-suffix-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStore the maximum of the array from left to right in the prefix array and minimum of the array from right to left. \\nNow at any position of prefix[i] < suffix[i+1] then return (i+1) index as answer.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> pre(n),suf(n);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=max(pre[i-1],nums[i]);\\n        }\\n        // for(auto it:pre) cout<<it<<\" \";cout<<endl;\\n\\n        suf[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            suf[i]=min(suf[i+1],nums[i]);\\n        }\\n        // for(auto it:suf) cout<<it<<\" \";cout<<endl;\\n\\n        for(int i=0;i<n-1;i++){\\n            if(pre[i]<=suf[i+1]){\\n                return i+1;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> pre(n),suf(n);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=max(pre[i-1],nums[i]);\\n        }\\n        // for(auto it:pre) cout<<it<<\" \";cout<<endl;\\n\\n        suf[n-1]=nums[n-1];\\n        for(int i=n-2;i>=0;i--){\\n            suf[i]=min(suf[i+1],nums[i]);\\n        }\\n        // for(auto it:suf) cout<<it<<\" \";cout<<endl;\\n\\n        for(int i=0;i<n-1;i++){\\n            if(pre[i]<=suf[i+1]){\\n                return i+1;\\n            }\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3755112,
                "title": "interesting-possibilities-for-bayesians-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis one jumps out at me as it is an interesting use case for Bayesians. If we consider the values on the left as those that are of minimal confidence from a set of possible confidences, and we consider the list passed in repeated one shot evaluations without updates and random drops, we can actually utilize this to get a confidence measure of the valuations done at a drop out layer. \\n\\nAs for how the problem works, consider the values in order of nums as a time series of valuations. \\n\\nWe want to get the left hand side, the lesser valuations, to be of minimal size, these corresponding to those that are not currently generating greatest output. (in a more complex version, if we had a mapping of what network composition led to the lesser and greaters that could be used for tuning) \\n\\nTo do this, we keep track of the current maximum valuation, the possible maximum valuation, the left and right array size and a confidence measure. Not all of these are needed for the problem, and will be pointed out in the approach. \\n\\nIf we track the current max and the possible max we can find the valuations where the left and right split at throughout the time series. This let\\'s us partition in one shot in time N. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDuring initializations set up fields for current max, possible max, and left array size (others are outside problem scope) \\n\\nDuring partition of disjoint \\n- set current max to nums at 0 \\n- set possible max to nums at 0 \\n- set left array size to 1 \\n- set nL to length of nums \\n- for nums index n_i in range 1 to nL \\n    - if nums[n_i] lt current max \\n        - left array size is n_i + 1 \\n        - current max is possible max \\n    - otherwise \\n        - possible max is max of self and nums at n_i \\n- at the end return left array size      \\n\\n# Complexity\\n- Time complexity : O(N) \\n\\n- Space complexity : O(1)\\n\\n# Code\\n```\\nclass Solution :\\n    def __init__(self) : \\n        self.current_max = 0 \\n        self.possible_max = 0 \\n        self.left_array_size = 0 \\n        self.right_array_size = 0 \\n        self.confidence = 0 \\n\\n    def partitionDisjoint(self, nums : List[ int ]) -> int :\\n        # init process \\n        self.current_max = nums[0]\\n        self.possible_max = nums[0]\\n        self.left_array_size = 1 \\n        nL = len(nums)\\n\\n        for n_i in range(1, nL) :\\n            if nums[n_i] < self.current_max : \\n                self.left_array_size = n_i + 1 \\n                self.current_max = self.possible_max\\n            else : \\n                self.possible_max = max(self.possible_max, nums[n_i])\\n        self.right_array_size = nL - self.left_array_size\\n        self.confidence = self.right_array_size / nL \\n        return self.left_array_size\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution :\\n    def __init__(self) : \\n        self.current_max = 0 \\n        self.possible_max = 0 \\n        self.left_array_size = 0 \\n        self.right_array_size = 0 \\n        self.confidence = 0 \\n\\n    def partitionDisjoint(self, nums : List[ int ]) -> int :\\n        # init process \\n        self.current_max = nums[0]\\n        self.possible_max = nums[0]\\n        self.left_array_size = 1 \\n        nL = len(nums)\\n\\n        for n_i in range(1, nL) :\\n            if nums[n_i] < self.current_max : \\n                self.left_array_size = n_i + 1 \\n                self.current_max = self.possible_max\\n            else : \\n                self.possible_max = max(self.possible_max, nums[n_i])\\n        self.right_array_size = nL - self.left_array_size\\n        self.confidence = self.right_array_size / nL \\n        return self.left_array_size\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3693524,
                "title": "easy-to-understand-solution-in-java-using-greedy-approach-beats-100",
                "content": "\\n# Approach\\nWe know that \\n1. Every element in left is less than or equal to every element in right.\\n2. left and right are non-empty.\\n3. left has the smallest possible size.\\n\\nto meet the condition 1 we need to introduce leftMax so that whichever element is less than the leftMax it becomes a part of the left array.\\n\\nThe leftMax variable should be updated lets take an example:\\n\\n2 , 5 , 6 , 0 , 4 , 3 , 8 , 9\\nans = 6  \\nThe ans is not 4 because every element in left is less than or equal to every element in right. so if the elements 4 and 3  becomes a part of the right array it violates the condition. Hence we need tp update the leftMax.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int l=0;\\n        int r=0;\\n        int LeftMaxCumulative= 0;\\n        int localLeftMaxInsideRange= nums[0];\\n        int ans =1;\\n        int n = nums.length;\\n\\n        while(r<n)\\n        {\\n            if(localLeftMaxInsideRange>nums[r])\\n            {\\n                ans = r+1;\\n//updating left max \\n                localLeftMaxInsideRange = LeftMaxCumulative;\\n            }\\n\\n            if(nums[r]>LeftMaxCumulative)\\n                LeftMaxCumulative =nums[r];\\n\\n            r++;\\n        }\\n//atleast 1 element in left and right should be present.\\n        if(ans == n) return n-1;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int l=0;\\n        int r=0;\\n        int LeftMaxCumulative= 0;\\n        int localLeftMaxInsideRange= nums[0];\\n        int ans =1;\\n        int n = nums.length;\\n\\n        while(r<n)\\n        {\\n            if(localLeftMaxInsideRange>nums[r])\\n            {\\n                ans = r+1;\\n//updating left max \\n                localLeftMaxInsideRange = LeftMaxCumulative;\\n            }\\n\\n            if(nums[r]>LeftMaxCumulative)\\n                LeftMaxCumulative =nums[r];\\n\\n            r++;\\n        }\\n//atleast 1 element in left and right should be present.\\n        if(ans == n) return n-1;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655688,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int i;\\n        int n=nums.length;\\n        \\n        // finding the minimum element and its index bcs we have to take that much ele in left side\\n        int min=100001;\\n        int pos=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(min>=nums[i])\\n            {\\n                min=nums[i];\\n                pos=i;\\n            }\\n        }\\n        // it means if array is same 1 1 1 1 or 2 2 2\\n        if(pos==n-1)\\n            return 1;\\n        \\n        // finding the max ele from 0 to min idx \\n        int max=0;\\n        for(i=0;i<pos;i++)\\n        {\\n            max=Math.max(nums[i],max);\\n        }\\n        // now comparing the max ele with next indexes of min ele and updating pos1 \\n        int pos1=0;\\n        int max1=0;\\n        for(i=pos+1;i<n;i++)\\n        {\\n            if(max>nums[i])\\n            {\\n                pos1=i;\\n            }\\n        }\\n        // but what if array is like this\\n        // [29,33,6,4,42,0,10,22,62,16,46,75,100,67,70,74,87,69,73,88]\\n        // here pos1 is at 16 ele and max is 62 but we can see we can take 46 also\\n        // finding another maximum from 0 to pos1 index\\n        for(i=0;i<pos1;i++)\\n        {\\n            max1=Math.max(max1,nums[i]);\\n        }\\n        // now after comparing to rest of element after pos1\\n        int ans=pos1;\\n        for(i=pos1+1;i<n;i++)\\n        {\\n            if(max1>nums[i])\\n            {\\n                ans=i;\\n            }\\n        }\\n        // this means there is no element smaller than maxa\\n        if(pos1==0)\\n            return pos+1;\\n        return ans+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int i;\\n        int n=nums.length;\\n        \\n        // finding the minimum element and its index bcs we have to take that much ele in left side\\n        int min=100001;\\n        int pos=0;\\n        for(i=0;i<n;i++)\\n        {\\n            if(min>=nums[i])\\n            {\\n                min=nums[i];\\n                pos=i;\\n            }\\n        }\\n        // it means if array is same 1 1 1 1 or 2 2 2\\n        if(pos==n-1)\\n            return 1;\\n        \\n        // finding the max ele from 0 to min idx \\n        int max=0;\\n        for(i=0;i<pos;i++)\\n        {\\n            max=Math.max(nums[i],max);\\n        }\\n        // now comparing the max ele with next indexes of min ele and updating pos1 \\n        int pos1=0;\\n        int max1=0;\\n        for(i=pos+1;i<n;i++)\\n        {\\n            if(max>nums[i])\\n            {\\n                pos1=i;\\n            }\\n        }\\n        // but what if array is like this\\n        // [29,33,6,4,42,0,10,22,62,16,46,75,100,67,70,74,87,69,73,88]\\n        // here pos1 is at 16 ele and max is 62 but we can see we can take 46 also\\n        // finding another maximum from 0 to pos1 index\\n        for(i=0;i<pos1;i++)\\n        {\\n            max1=Math.max(max1,nums[i]);\\n        }\\n        // now after comparing to rest of element after pos1\\n        int ans=pos1;\\n        for(i=pos1+1;i<n;i++)\\n        {\\n            if(max1>nums[i])\\n            {\\n                ans=i;\\n            }\\n        }\\n        // this means there is no element smaller than maxa\\n        if(pos1==0)\\n            return pos+1;\\n        return ans+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631776,
                "title": "simple-c-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\nI have taken maxi to store greatest element in left subarray till now keeping in mind we need to keep it as small as possible.\\nI have taken maxi1 to store greatest till now and we replace with maxi whenever we get smaller element then maxi in an array.  \\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n\\n        int maxi=nums[0];\\n        int index=0;\\n        int maxi1=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]<maxi)\\n            {\\n                index=i;\\n                maxi=maxi1;\\n            }\\n            if(nums[i]>maxi)\\n            {\\n                maxi1=max(maxi1,nums[i]);\\n            }\\n        }\\n\\n        return index+1;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n\\n        int maxi=nums[0];\\n        int index=0;\\n        int maxi1=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]<maxi)\\n            {\\n                index=i;\\n                maxi=maxi1;\\n            }\\n            if(nums[i]>maxi)\\n            {\\n                maxi1=max(maxi1,nums[i]);\\n            }\\n        }\\n\\n        return index+1;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3600991,
                "title": "python-explained",
                "content": "**Solution**\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        left, right = 1, 0\\n        cur_low = next_low = nums[0]\\n        for val in nums[1:]:\\n            if val >= cur_low:\\n                right += 1\\n                next_low = max(next_low, val)\\n            else:\\n                left += right + 1\\n                right = 0\\n                cur_low = next_low\\n        return left\\n```\\n\\n**Explanation**\\n\\n1. The variables `left` and `right` represent the lengths of the left and right subarrays, respectively. `left` is initially set to 1 because it includes the first element of the array.\\n\\n2. The variables `cur_low` and `next_low` represent the lowest value found in the current subarray and the lowest value found in the next potential subarray, respectively. They are initialized with the first element of the array.\\n\\n3. The loop iterates over the remaining elements in the `nums` array, starting from the second element. For each element `val`, it checks if `val` is greater than or equal to the current lowest value (`cur_low`).\\n\\n4. If `val` is greater than or equal to `cur_low`, it means the element can be included in the right subarray. Therefore, `right` is incremented by 1, and `next_low` is updated to the maximum of its current value and `val` (to keep track of the lowest value in the potential next subarray).\\n\\n5. If `val` is less than `cur_low`, it means a partition needs to be made. The left subarray is extended by the length of the right subarray (`left += right`), and `right` is reset to 0. Additionally, `left` is incremented by 1 to account for the current element, and `cur_low` is updated to `next_low` to reflect the lowest value in the left subarray.\\n\\n6. Finally, the function returns the length of the left subarray (`left`).",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        left, right = 1, 0\\n        cur_low = next_low = nums[0]\\n        for val in nums[1:]:\\n            if val >= cur_low:\\n                right += 1\\n                next_low = max(next_low, val)\\n            else:\\n                left += right + 1\\n                right = 0\\n                cur_low = next_low\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558616,
                "title": "partition-array-into-disjoint-intervals",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n\\n        int mxl = nums[0], i = 1, mx = nums[0];\\n        for(int j = 1; j < nums.size(); j++) {\\n            mx = max(mx, nums[j]);\\n            if(nums[j] < mxl) {\\n                i = j + 1;\\n                mxl = mx;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n\\n        int mxl = nums[0], i = 1, mx = nums[0];\\n        for(int j = 1; j < nums.size(); j++) {\\n            mx = max(mx, nums[j]);\\n            if(nums[j] < mxl) {\\n                i = j + 1;\\n                mxl = mx;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554218,
                "title": "python3-solution-using-itertools-accumulate",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        prefix_max= list(accumulate(nums, max)) \\n        suffix_min = list(accumulate(nums[::-1], min))[::-1]\\n\\n        for i in range(n):\\n            if prefix_max[i]<=suffix_min[i+1]:\\n                return i+1\\n            \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        prefix_max= list(accumulate(nums, max)) \\n        suffix_min = list(accumulate(nums[::-1], min))[::-1]\\n\\n        for i in range(n):\\n            if prefix_max[i]<=suffix_min[i+1]:\\n                return i+1\\n            \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3554207,
                "title": "python3-clean-suffix-min-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        \\n        suffix=[nums[-1]]\\n        \\n        for i in range(n-2,-1,-1):\\n            mn=min(nums[i],suffix[-1])\\n            suffix.append(mn)\\n        \\n        suffix.reverse()\\n        \\n        mx=-inf\\n        for i in range(n):\\n            mx=max(mx,nums[i])\\n            if mx<=suffix[i+1]:\\n                return i+1\\n        \\n            \\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        \\n        n=len(nums)\\n        \\n        suffix=[nums[-1]]\\n        \\n        for i in range(n-2,-1,-1):\\n            mn=min(nums[i],suffix[-1])\\n            suffix.append(mn)\\n        \\n        suffix.reverse()\\n        \\n        mx=-inf\\n        for i in range(n):\\n            mx=max(mx,nums[i])\\n            if mx<=suffix[i+1]:\\n                return i+1\\n        \\n            \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550475,
                "title": "with-priorityqueue",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int PartitionDisjoint(int[] nums) \\n    {\\n        var min = nums.Min();\\n        int j=0,i=0,max=-1;\\n        for(i=0;i<nums.Length;i++)\\n        {\\n            if(nums[i]==min) break;\\n            max = Math.Max(max,nums[i]);\\n        }\\n        return Find(nums,i,j,max)+1;\\n    }\\n    \\n    public int Find(int[] nums,int i,int j,int max)\\n    {\\n        var pq = new PriorityQueue<int,int>(Comparer<int>.Create((x,y)=>y-x));\\n        \\n        for(i=i;i<nums.Length;i++)\\n        {\\n            var assign =false;\\n            if(nums[i]<max) \\n            {\\n                j=i; \\n                assign =true;\\n            }\\n            pq.Enqueue(nums[i],nums[i]);\\n            if(assign) max =Math.Max(max,pq.Peek());\\n        }\\n        \\n        return j;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int PartitionDisjoint(int[] nums) \\n    {\\n        var min = nums.Min();\\n        int j=0,i=0,max=-1;\\n        for(i=0;i<nums.Length;i++)\\n        {\\n            if(nums[i]==min) break;\\n            max = Math.Max(max,nums[i]);\\n        }\\n        return Find(nums,i,j,max)+1;\\n    }\\n    \\n    public int Find(int[] nums,int i,int j,int max)\\n    {\\n        var pq = new PriorityQueue<int,int>(Comparer<int>.Create((x,y)=>y-x));\\n        \\n        for(i=i;i<nums.Length;i++)\\n        {\\n            var assign =false;\\n            if(nums[i]<max) \\n            {\\n                j=i; \\n                assign =true;\\n            }\\n            pq.Enqueue(nums[i],nums[i]);\\n            if(assign) max =Math.Max(max,pq.Peek());\\n        }\\n        \\n        return j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538574,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int n = nums.length;\\n        int max[] = new int[n];\\n        int min[] = new int[n];\\n        int a = nums[0],b=nums[n-1];\\n        for(int i =0 ;i< n;i++){\\n            a=Math.max(a,nums[i]);\\n            max[i]=a;\\n        }\\n        for(int i= n-1;i>=0;i--){\\n            b=Math.min(b,nums[i]);\\n            min[i]=b;\\n        }\\n        for(int i=1;i<n;i++){\\n            if(max[i-1]<=min[i])\\n                return i;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Suffix Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int n = nums.length;\\n        int max[] = new int[n];\\n        int min[] = new int[n];\\n        int a = nums[0],b=nums[n-1];\\n        for(int i =0 ;i< n;i++){\\n            a=Math.max(a,nums[i]);\\n            max[i]=a;\\n        }\\n        for(int i= n-1;i>=0;i--){\\n            b=Math.min(b,nums[i]);\\n            min[i]=b;\\n        }\\n        for(int i=1;i<n;i++){\\n            if(max[i-1]<=min[i])\\n                return i;\\n        }\\n        return 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516543,
                "title": "optimal-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        int local_max=nums[0];\\n        int greater_max=nums[0];\\n        int ans=1;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]<local_max){\\n                ans=i+1;\\n                local_max=greater_max;\\n            }\\n            else{\\n                greater_max=max(nums[i],greater_max);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        int local_max=nums[0];\\n        int greater_max=nums[0];\\n        int ans=1;\\n        for(int i=1;i<n;i++){\\n            if(nums[i]<local_max){\\n                ans=i+1;\\n                local_max=greater_max;\\n            }\\n            else{\\n                greater_max=max(nums[i],greater_max);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3515379,
                "title": "brute-force-one-array-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Brute Force\\n    //using one array\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==2) return 1;\\n        vector<int>right(n,0);\\n        int maxi=INT_MIN,mini=INT_MAX;\\n        for(int i=n-1;i>=0;i--){\\n            right[i]=mini;\\n            mini=min(mini,nums[i]);\\n        }\\n        for(int i=0;i<n-1;i++){\\n            maxi=max(nums[i],maxi);\\n            if(maxi<=right[i]){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Brute Force\\n    //using one array\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==2) return 1;\\n        vector<int>right(n,0);\\n        int maxi=INT_MIN,mini=INT_MAX;\\n        for(int i=n-1;i>=0;i--){\\n            right[i]=mini;\\n            mini=min(mini,nums[i]);\\n        }\\n        for(int i=0;i<n-1;i++){\\n            maxi=max(nums[i],maxi);\\n            if(maxi<=right[i]){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513709,
                "title": "brute-force-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Brute Force\\n    //using two arrays\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==2) return 1;\\n        vector<int> left(n,0);\\n        vector<int>right(n,0);\\n        int maxi=INT_MIN,mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            maxi=max(nums[i],maxi);\\n            left[i]=maxi;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            right[i]=mini;\\n            mini=min(mini,nums[i]);\\n        }\\n        for(int i=0;i<n-1;i++){\\n            if(left[i]<=right[i]){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Brute Force\\n    //using two arrays\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n=nums.size();\\n        if(n==2) return 1;\\n        vector<int> left(n,0);\\n        vector<int>right(n,0);\\n        int maxi=INT_MIN,mini=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            maxi=max(nums[i],maxi);\\n            left[i]=maxi;\\n        }\\n        for(int i=n-1;i>=0;i--){\\n            right[i]=mini;\\n            mini=min(mini,nums[i]);\\n        }\\n        for(int i=0;i<n-1;i++){\\n            if(left[i]<=right[i]){\\n                return i+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488447,
                "title": "java-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int max1=nums[0],max2=nums[0],pos=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<max1){\\n                max1=max2;\\n                pos=i;\\n            }\\n            else{\\n                max2=Math.max(max2,nums[i]);\\n            }\\n        }\\n        return pos+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionDisjoint(int[] nums) {\\n        int max1=nums[0],max2=nums[0],pos=0;\\n        for(int i=1;i<nums.length;i++){\\n            if(nums[i]<max1){\\n                max1=max2;\\n                pos=i;\\n            }\\n            else{\\n                max2=Math.max(max2,nums[i]);\\n            }\\n        }\\n        return pos+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484645,
                "title": "beats-96-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\nint check(vector<int>&nums,int maxi,int k)\\n{   int mini=nums[k+1];\\n    for(int i=k+2;i<nums.size();i++)\\n    {\\n      \\n     if(nums[i]<mini)\\n      mini=nums[i];\\n    }\\n    for(int i=0;i<k;i++)\\n    {\\n        if(nums[i]>mini)\\n         return 0;\\n    }\\n    return 1;\\n}\\n    int partitionDisjoint(vector<int>& nums) {\\n        int maxi=nums[0];\\n        int k;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n         if(maxi<=nums[i])\\n         {\\n          maxi=nums[i];\\n          if(i>=nums.size()-1)\\n           return i;\\n          if(check(nums,maxi,i))\\n            return i;\\n         }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint check(vector<int>&nums,int maxi,int k)\\n{   int mini=nums[k+1];\\n    for(int i=k+2;i<nums.size();i++)\\n    {\\n      \\n     if(nums[i]<mini)\\n      mini=nums[i];\\n    }\\n    for(int i=0;i<k;i++)\\n    {\\n        if(nums[i]>mini)\\n         return 0;\\n    }\\n    return 1;\\n}\\n    int partitionDisjoint(vector<int>& nums) {\\n        int maxi=nums[0];\\n        int k;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n         if(maxi<=nums[i])\\n         {\\n          maxi=nums[i];\\n          if(i>=nums.size()-1)\\n           return i;\\n          if(check(nums,maxi,i))\\n            return i;\\n         }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418864,
                "title": "space-complexity-o-1-python-one-pass-solution",
                "content": "\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        last_left=0\\n        maxi=nums[0]\\n        large=0\\n        for i in range(len(nums)):\\n            if nums[i]<maxi:\\n                if large:\\n                    maxi=large\\n                last_left=i\\n                \\n            elif nums[i]>maxi:\\n                large=max(large,nums[i])\\n        return last_left+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        last_left=0\\n        maxi=nums[0]\\n        large=0\\n        for i in range(len(nums)):\\n            if nums[i]<maxi:\\n                if large:\\n                    maxi=large\\n                last_left=i\\n                \\n            elif nums[i]>maxi:\\n                large=max(large,nums[i])\\n        return last_left+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3392675,
                "title": "cpp-solution-using-a-max-array-prefix-sum-kind-of-technique-self-explanatory-code",
                "content": "\\n\\n# Approach\\nKeep a max array such that mx[i] contains the maximum element of the array in [0-i]\\nEstablish the minimum min_right as nums[0], i.e., the lowest element in the beginning.\\nIf we find something greater than our current minimum min_right, that element must be included in the right partition.\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\nHere, N = number of elements present in the given array.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n        vector<int> mx(n);\\n\\n        int min_right = nums[n-1];\\n        mx[0] = nums[0];\\n\\n        for(int i=1;i<n;i++) {\\n            mx[i] = max(nums[i], mx[i-1]);\\n        }\\n        for(int i=n-1;i>=1;i--) {\\n            min_right = min(min_right, nums[i]);\\n            if(min_right >= mx[i-1]) {\\n                ans = i;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int ans = 0;\\n        int n = nums.size();\\n        vector<int> mx(n);\\n\\n        int min_right = nums[n-1];\\n        mx[0] = nums[0];\\n\\n        for(int i=1;i<n;i++) {\\n            mx[i] = max(nums[i], mx[i-1]);\\n        }\\n        for(int i=n-1;i>=1;i--) {\\n            min_right = min(min_right, nums[i]);\\n            if(min_right >= mx[i-1]) {\\n                ans = i;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3389299,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int Ans=0,Max=nums[0];\\n        int minmax=Max;\\n        bool yes=true;\\n        for(int i=1; i<nums.size(); i++) {\\n            minmax=max(nums[i],minmax);\\n            if(nums[i]>=Max && yes) {\\n                Ans=i;\\n                yes=false;\\n            }\\n            if(nums[i]<Max) {\\n                Max=minmax;\\n                yes=true;\\n            }\\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int Ans=0,Max=nums[0];\\n        int minmax=Max;\\n        bool yes=true;\\n        for(int i=1; i<nums.size(); i++) {\\n            minmax=max(nums[i],minmax);\\n            if(nums[i]>=Max && yes) {\\n                Ans=i;\\n                yes=false;\\n            }\\n            if(nums[i]<Max) {\\n                Max=minmax;\\n                yes=true;\\n            }\\n        }\\n        return Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378628,
                "title": "simple-o-n-traversal-cpp",
                "content": "# Intuition and Approach\\n* initiallize the ans variable with 0, it will keep track of last element of out subarray.\\n* initiallize the maxi variable with nums[0],it will keep track of maximum element present in our sub array.\\n* now whlile traversing check wheather the current element is smaller then our maxi or not:\\n* * if smaller then ans=current index; maxi=maximum of all elements till now.\\n* * else continue.\\n* while traversing store the maximum of all the elements traversed till now including current one to the current position of array.\\n* at the end return ans+1.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int maxi=nums[0];\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<maxi){\\n                ans=i;\\n                maxi=max(nums[i],nums[i-1]);\\n            }\\n            nums[i]=max(nums[i-1],nums[i]);\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int maxi=nums[0];\\n        int ans=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]<maxi){\\n                ans=i;\\n                maxi=max(nums[i],nums[i-1]);\\n            }\\n            nums[i]=max(nums[i-1],nums[i]);\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378366,
                "title": "python3-clean",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        x=len(nums)\\n        lst1=[0]*x\\n        lst2=[0]*x\\n\\n        lst1[0]=nums[0]\\n        for i in range(1,x):\\n            lst1[i]=max(lst1[i-1],nums[i])\\n\\n        lst2[x-1]=nums[x-1]\\n        for i in range(x-2,-1,-1):\\n            lst2[i]=min(lst2[i+1],nums[i])\\n\\n        for i in range(1,x):\\n            if lst1[i-1] <= lst2[i]:\\n                return i\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        x=len(nums)\\n        lst1=[0]*x\\n        lst2=[0]*x\\n\\n        lst1[0]=nums[0]\\n        for i in range(1,x):\\n            lst1[i]=max(lst1[i-1],nums[i])\\n\\n        lst2[x-1]=nums[x-1]\\n        for i in range(x-2,-1,-1):\\n            lst2[i]=min(lst2[i+1],nums[i])\\n\\n        for i in range(1,x):\\n            if lst1[i-1] <= lst2[i]:\\n                return i\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378303,
                "title": "c-t-c-o-n-s-c-o-1-well-commented-code",
                "content": "# Intuition\\nThe smallest element in the right subarray has to be greater than or equal to the largest element in the left subarray\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums)\\n    {\\n        int L_Max=nums[0];//denotes the max element in the left subarray\\n        int l=0;//denotes the boundary of the left subarray\\n        int Max=nums[0];//denotes the max element till now(Index which we currently are on)\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            Max=max(Max,nums[i]);\\n            if(nums[i]<L_Max)//If the element is smaller than the max element in the left subarray then it can\\'t be in the right subarray\\n            {\\n                l=i;\\n                L_Max=Max;//The max element till now becomes the max element of left subarray\\n            }\\n        }\\n\\n        return l+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums)\\n    {\\n        int L_Max=nums[0];//denotes the max element in the left subarray\\n        int l=0;//denotes the boundary of the left subarray\\n        int Max=nums[0];//denotes the max element till now(Index which we currently are on)\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            Max=max(Max,nums[i]);\\n            if(nums[i]<L_Max)//If the element is smaller than the max element in the left subarray then it can\\'t be in the right subarray\\n            {\\n                l=i;\\n                L_Max=Max;//The max element till now becomes the max element of left subarray\\n            }\\n        }\\n\\n        return l+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3378255,
                "title": "c-o-n-o-1-space",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int minInd = -1,maxInd = -1;\\n        int minEle = INT_MAX,maxEle = INT_MIN;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(minEle>nums[i])\\n            {\\n                minEle = nums[i];\\n                minInd = i;\\n            }\\n            if(maxEle<nums[i])\\n            {\\n                maxEle = nums[i];\\n                maxInd = i;\\n            }\\n        }\\n\\n        int fInd = -1;\\n        maxEle = INT_MIN;\\n        for(int i=0;i<=minInd;i++)\\n        {\\n            maxEle = max(maxEle,nums[i]);\\n        }\\n        for(int i=minInd+1;i<maxInd;i++)\\n        {\\n            if(nums[i]<maxEle)\\n            {\\n                fInd = i;\\n            }\\n        }\\n        for(int i=minInd+1;i<=fInd;i++)\\n        {\\n            maxEle = max(maxEle,nums[i]);\\n        }\\n        for(int i=fInd+1;i<maxInd;i++)\\n        {\\n            if(nums[i]<maxEle)\\n            {\\n                fInd = i;\\n            }\\n        }\\n        if(fInd!=-1)\\n        return fInd+1;\\n        return minInd+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int minInd = -1,maxInd = -1;\\n        int minEle = INT_MAX,maxEle = INT_MIN;\\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(minEle>nums[i])\\n            {\\n                minEle = nums[i];\\n                minInd = i;\\n            }\\n            if(maxEle<nums[i])\\n            {\\n                maxEle = nums[i];\\n                maxInd = i;\\n            }\\n        }\\n\\n        int fInd = -1;\\n        maxEle = INT_MIN;\\n        for(int i=0;i<=minInd;i++)\\n        {\\n            maxEle = max(maxEle,nums[i]);\\n        }\\n        for(int i=minInd+1;i<maxInd;i++)\\n        {\\n            if(nums[i]<maxEle)\\n            {\\n                fInd = i;\\n            }\\n        }\\n        for(int i=minInd+1;i<=fInd;i++)\\n        {\\n            maxEle = max(maxEle,nums[i]);\\n        }\\n        for(int i=fInd+1;i<maxInd;i++)\\n        {\\n            if(nums[i]<maxEle)\\n            {\\n                fInd = i;\\n            }\\n        }\\n        if(fInd!=-1)\\n        return fInd+1;\\n        return minInd+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377981,
                "title": "easy-approach-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int ans=0;\\n        int x=nums[0],m=nums[0];\\n        for(int i=0;i<nums.size();i++){\\n             if(nums[i]<x){\\n                 ans=i;\\n                 x=m;\\n             }\\n             m=max(nums[i],m);\\n\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int ans=0;\\n        int x=nums[0],m=nums[0];\\n        for(int i=0;i<nums.size();i++){\\n             if(nums[i]<x){\\n                 ans=i;\\n                 x=m;\\n             }\\n             m=max(nums[i],m);\\n\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3377690,
                "title": "o-n-c-easy-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n    vector<int> l, s;\\n    int mn = INT_MAX, mx = INT_MIN, n = nums.size();\\n    s.push_back(0);\\n    for (int i = 0; i < nums.size(); i++){\\n            mx = max(mx, nums[i]);\\n            l.push_back(mx);\\n            mn = min(mn, nums[n - i - 1]);\\n            s.push_back(mn);\\n    }\\n    s.pop_back();\\n    reverse(s.begin(), s.end());\\n    int ind;\\n    for (int i = 0; i < nums.size()-1; i++){\\n        if( l[i]<= s[i])\\n        {\\n            ind = i;\\n        break;\\n        }\\n            \\n    }\\n    // cout << ind << endl;\\n    // for( auto x : l)\\n    //     cout << x << \" \";\\n\\n    return ind+1;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n    vector<int> l, s;\\n    int mn = INT_MAX, mx = INT_MIN, n = nums.size();\\n    s.push_back(0);\\n    for (int i = 0; i < nums.size(); i++){\\n            mx = max(mx, nums[i]);\\n            l.push_back(mx);\\n            mn = min(mn, nums[n - i - 1]);\\n            s.push_back(mn);\\n    }\\n    s.pop_back();\\n    reverse(s.begin(), s.end());\\n    int ind;\\n    for (int i = 0; i < nums.size()-1; i++){\\n        if( l[i]<= s[i])\\n        {\\n            ind = i;\\n        break;\\n        }\\n            \\n    }\\n    // cout << ind << endl;\\n    // for( auto x : l)\\n    //     cout << x << \" \";\\n\\n    return ind+1;\\n}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3376652,
                "title": "easy-c-solution-using-max-and-min-idea",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size() ;\\n        vector <int> mx(n); // max array\\n        int minVal = nums[n - 1] ;\\n        mx[0] = nums[0] ;\\n        for(int i = 1; i < n; i++)\\n        {\\n            mx[i] = max(nums[i], mx[i - 1]) ;\\n        }\\n        int ans;\\n        // max value of left side must be lesser than min value of right side\\n        for(int i = n - 1 ; i >= 1 ; i--)\\n        {\\n            minVal = min(minVal, nums[i]);\\n            if(minVal >= mx[i - 1])\\n            {\\n                ans = i ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int n = nums.size() ;\\n        vector <int> mx(n); // max array\\n        int minVal = nums[n - 1] ;\\n        mx[0] = nums[0] ;\\n        for(int i = 1; i < n; i++)\\n        {\\n            mx[i] = max(nums[i], mx[i - 1]) ;\\n        }\\n        int ans;\\n        // max value of left side must be lesser than min value of right side\\n        for(int i = n - 1 ; i >= 1 ; i--)\\n        {\\n            minVal = min(minVal, nums[i]);\\n            if(minVal >= mx[i - 1])\\n            {\\n                ans = i ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363144,
                "title": "top-85-speed-top-95-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        current = -1\\n        current_in = nums[0]\\n        ans = 1\\n        for i in range(len(nums)-1):\\n            if current < nums[i]:\\n                current = nums[i]\\n            if current_in > nums[i]:\\n                current_in = current\\n                ans = i + 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionDisjoint(self, nums: List[int]) -> int:\\n        current = -1\\n        current_in = nums[0]\\n        ans = 1\\n        for i in range(len(nums)-1):\\n            if current < nums[i]:\\n                current = nums[i]\\n            if current_in > nums[i]:\\n                current_in = current\\n                ans = i + 1\\n        return ans\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569573,
                "content": [
                    {
                        "username": "nithatech",
                        "content": "Example 2:\\n\\nInput: [1,1,1,0,6,12]\\nOutput: 4\\nExplanation: left = [1,1,1,0], right = [6,12]\\n\\n============\\n\\nHere, the output could be [0], [1,1,1,6,12] or [0,1],[1,1,6,12] and few other possibilities, isn\\'t it?"
                    },
                    {
                        "username": "mini_bong",
                        "content": "No, we have to do partition in two contiguous subarray."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "I guess you\\'re not allowed to change the order of the elements"
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, left needs to have the smallest possible size"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "its not  medium level ques. \\nits damm tough!!"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "what is the answer for this case {29, 33, 6, 4, 42, 0, 10, 22, 62, 16, 46, 75, 100, 67, 70, 74, 87, 69, 73, 88} ? my code gave 10 why it is wrong ? this is a 63/68 case I am providing my code:\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int minValue = INT_MAX;\\n        int left = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (minValue > nums[i]) {\\n                minValue = nums[i];\\n                left = i;\\n            }\\n        }\\n        \\n        int maxValue = INT_MIN;\\n        for (int j = 0; j <= left; j++) {\\n            if (maxValue < nums[j]) {\\n                maxValue = nums[j];\\n            }\\n        }\\n        \\n        int ans = left;\\n        for (int k = left + 1; k < nums.size(); k++) {\\n            if (nums[k] < maxValue) {\\n                ans = k;\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "[@abdK007](/abdK007) \n1. temporarily left partition up to the minimum value in the array->>26\n2. find a max element in the left subarray i.e. [26] so the max is 26 \n3. find an element in the right subarray [51,40,58,42,76,30,48,79,91] that is less than the max element in the left array if the condition is valid make the partition up to that element\n run the loop up to the last element in the right subarray.\nbut the same logic is not valid for all the cases.\nthe correct solution is :\nclass Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int n = nums.size();\n        int maxLeft = nums[0];\n        int currMax = nums[0];\n        int partitionIndex = 0;\n        \n        for (int i = 1; i < n; i++) {\n            currMax = max(currMax, nums[i]);\n            \n            if (nums[i] < maxLeft) {\n                maxLeft = currMax;\n                partitionIndex = i;\n            }\n        }\n        \n        return partitionIndex + 1;\n    }\n};\n"
                    },
                    {
                        "username": "abdK007",
                        "content": "hey can you explain this test case :- [26,51,40,58,42,76,30,48,79,91]\\nhow left --> [26,51,40,58,42,76,30,48,]  and right --> [79,91] are incorrect"
                    },
                    {
                        "username": "sb26",
                        "content": "Input: [5,0,3,8,6]\\nOutput: 3\\nExplanation: left = [5,0,3], right = [8,6]\\n\\nThis can be further partioned as [5,0,3,6] and [8]\\nStill holds true\\n\\nAlso [0,3] holds true too"
                    },
                    {
                        "username": "mini_bong",
                        "content": "The size of left subarray should be minimum and both subarray should be contiguous."
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, the left and right need to be contiguous"
                    },
                    {
                        "username": "palak-agg",
                        "content": "If I am right, the first element of the right array should be greater than the max element of the left array."
                    },
                    {
                        "username": "zhhackk",
                        "content": "not the first element, but the minimum of right array"
                    },
                    {
                        "username": "abdK007",
                        "content": "Can someone help me out with this testCase  no 34:-   @\\nInput --> [26,51,40,58,42,76,30,48,79,91]\\n output -->  8 \\nExpected --> 1\\nhere the partition can be [26,51,40,58,42,76,30,48]     [79,91]"
                    },
                    {
                        "username": "Pkmaurya88_",
                        "content": "yes it can be but we have to find minimum possible in left that\\'s why answer is 1"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "When you are at one element, think whether you can put this element in second part....you will definitely arrive at the one-pass solution"
                    }
                ]
            },
            {
                "id": 1725380,
                "content": [
                    {
                        "username": "nithatech",
                        "content": "Example 2:\\n\\nInput: [1,1,1,0,6,12]\\nOutput: 4\\nExplanation: left = [1,1,1,0], right = [6,12]\\n\\n============\\n\\nHere, the output could be [0], [1,1,1,6,12] or [0,1],[1,1,6,12] and few other possibilities, isn\\'t it?"
                    },
                    {
                        "username": "mini_bong",
                        "content": "No, we have to do partition in two contiguous subarray."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "I guess you\\'re not allowed to change the order of the elements"
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, left needs to have the smallest possible size"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "its not  medium level ques. \\nits damm tough!!"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "what is the answer for this case {29, 33, 6, 4, 42, 0, 10, 22, 62, 16, 46, 75, 100, 67, 70, 74, 87, 69, 73, 88} ? my code gave 10 why it is wrong ? this is a 63/68 case I am providing my code:\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int minValue = INT_MAX;\\n        int left = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (minValue > nums[i]) {\\n                minValue = nums[i];\\n                left = i;\\n            }\\n        }\\n        \\n        int maxValue = INT_MIN;\\n        for (int j = 0; j <= left; j++) {\\n            if (maxValue < nums[j]) {\\n                maxValue = nums[j];\\n            }\\n        }\\n        \\n        int ans = left;\\n        for (int k = left + 1; k < nums.size(); k++) {\\n            if (nums[k] < maxValue) {\\n                ans = k;\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "[@abdK007](/abdK007) \n1. temporarily left partition up to the minimum value in the array->>26\n2. find a max element in the left subarray i.e. [26] so the max is 26 \n3. find an element in the right subarray [51,40,58,42,76,30,48,79,91] that is less than the max element in the left array if the condition is valid make the partition up to that element\n run the loop up to the last element in the right subarray.\nbut the same logic is not valid for all the cases.\nthe correct solution is :\nclass Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int n = nums.size();\n        int maxLeft = nums[0];\n        int currMax = nums[0];\n        int partitionIndex = 0;\n        \n        for (int i = 1; i < n; i++) {\n            currMax = max(currMax, nums[i]);\n            \n            if (nums[i] < maxLeft) {\n                maxLeft = currMax;\n                partitionIndex = i;\n            }\n        }\n        \n        return partitionIndex + 1;\n    }\n};\n"
                    },
                    {
                        "username": "abdK007",
                        "content": "hey can you explain this test case :- [26,51,40,58,42,76,30,48,79,91]\\nhow left --> [26,51,40,58,42,76,30,48,]  and right --> [79,91] are incorrect"
                    },
                    {
                        "username": "sb26",
                        "content": "Input: [5,0,3,8,6]\\nOutput: 3\\nExplanation: left = [5,0,3], right = [8,6]\\n\\nThis can be further partioned as [5,0,3,6] and [8]\\nStill holds true\\n\\nAlso [0,3] holds true too"
                    },
                    {
                        "username": "mini_bong",
                        "content": "The size of left subarray should be minimum and both subarray should be contiguous."
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, the left and right need to be contiguous"
                    },
                    {
                        "username": "palak-agg",
                        "content": "If I am right, the first element of the right array should be greater than the max element of the left array."
                    },
                    {
                        "username": "zhhackk",
                        "content": "not the first element, but the minimum of right array"
                    },
                    {
                        "username": "abdK007",
                        "content": "Can someone help me out with this testCase  no 34:-   @\\nInput --> [26,51,40,58,42,76,30,48,79,91]\\n output -->  8 \\nExpected --> 1\\nhere the partition can be [26,51,40,58,42,76,30,48]     [79,91]"
                    },
                    {
                        "username": "Pkmaurya88_",
                        "content": "yes it can be but we have to find minimum possible in left that\\'s why answer is 1"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "When you are at one element, think whether you can put this element in second part....you will definitely arrive at the one-pass solution"
                    }
                ]
            },
            {
                "id": 1947561,
                "content": [
                    {
                        "username": "nithatech",
                        "content": "Example 2:\\n\\nInput: [1,1,1,0,6,12]\\nOutput: 4\\nExplanation: left = [1,1,1,0], right = [6,12]\\n\\n============\\n\\nHere, the output could be [0], [1,1,1,6,12] or [0,1],[1,1,6,12] and few other possibilities, isn\\'t it?"
                    },
                    {
                        "username": "mini_bong",
                        "content": "No, we have to do partition in two contiguous subarray."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "I guess you\\'re not allowed to change the order of the elements"
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, left needs to have the smallest possible size"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "its not  medium level ques. \\nits damm tough!!"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "what is the answer for this case {29, 33, 6, 4, 42, 0, 10, 22, 62, 16, 46, 75, 100, 67, 70, 74, 87, 69, 73, 88} ? my code gave 10 why it is wrong ? this is a 63/68 case I am providing my code:\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int minValue = INT_MAX;\\n        int left = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (minValue > nums[i]) {\\n                minValue = nums[i];\\n                left = i;\\n            }\\n        }\\n        \\n        int maxValue = INT_MIN;\\n        for (int j = 0; j <= left; j++) {\\n            if (maxValue < nums[j]) {\\n                maxValue = nums[j];\\n            }\\n        }\\n        \\n        int ans = left;\\n        for (int k = left + 1; k < nums.size(); k++) {\\n            if (nums[k] < maxValue) {\\n                ans = k;\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "[@abdK007](/abdK007) \n1. temporarily left partition up to the minimum value in the array->>26\n2. find a max element in the left subarray i.e. [26] so the max is 26 \n3. find an element in the right subarray [51,40,58,42,76,30,48,79,91] that is less than the max element in the left array if the condition is valid make the partition up to that element\n run the loop up to the last element in the right subarray.\nbut the same logic is not valid for all the cases.\nthe correct solution is :\nclass Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int n = nums.size();\n        int maxLeft = nums[0];\n        int currMax = nums[0];\n        int partitionIndex = 0;\n        \n        for (int i = 1; i < n; i++) {\n            currMax = max(currMax, nums[i]);\n            \n            if (nums[i] < maxLeft) {\n                maxLeft = currMax;\n                partitionIndex = i;\n            }\n        }\n        \n        return partitionIndex + 1;\n    }\n};\n"
                    },
                    {
                        "username": "abdK007",
                        "content": "hey can you explain this test case :- [26,51,40,58,42,76,30,48,79,91]\\nhow left --> [26,51,40,58,42,76,30,48,]  and right --> [79,91] are incorrect"
                    },
                    {
                        "username": "sb26",
                        "content": "Input: [5,0,3,8,6]\\nOutput: 3\\nExplanation: left = [5,0,3], right = [8,6]\\n\\nThis can be further partioned as [5,0,3,6] and [8]\\nStill holds true\\n\\nAlso [0,3] holds true too"
                    },
                    {
                        "username": "mini_bong",
                        "content": "The size of left subarray should be minimum and both subarray should be contiguous."
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, the left and right need to be contiguous"
                    },
                    {
                        "username": "palak-agg",
                        "content": "If I am right, the first element of the right array should be greater than the max element of the left array."
                    },
                    {
                        "username": "zhhackk",
                        "content": "not the first element, but the minimum of right array"
                    },
                    {
                        "username": "abdK007",
                        "content": "Can someone help me out with this testCase  no 34:-   @\\nInput --> [26,51,40,58,42,76,30,48,79,91]\\n output -->  8 \\nExpected --> 1\\nhere the partition can be [26,51,40,58,42,76,30,48]     [79,91]"
                    },
                    {
                        "username": "Pkmaurya88_",
                        "content": "yes it can be but we have to find minimum possible in left that\\'s why answer is 1"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "When you are at one element, think whether you can put this element in second part....you will definitely arrive at the one-pass solution"
                    }
                ]
            },
            {
                "id": 1573351,
                "content": [
                    {
                        "username": "nithatech",
                        "content": "Example 2:\\n\\nInput: [1,1,1,0,6,12]\\nOutput: 4\\nExplanation: left = [1,1,1,0], right = [6,12]\\n\\n============\\n\\nHere, the output could be [0], [1,1,1,6,12] or [0,1],[1,1,6,12] and few other possibilities, isn\\'t it?"
                    },
                    {
                        "username": "mini_bong",
                        "content": "No, we have to do partition in two contiguous subarray."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "I guess you\\'re not allowed to change the order of the elements"
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, left needs to have the smallest possible size"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "its not  medium level ques. \\nits damm tough!!"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "what is the answer for this case {29, 33, 6, 4, 42, 0, 10, 22, 62, 16, 46, 75, 100, 67, 70, 74, 87, 69, 73, 88} ? my code gave 10 why it is wrong ? this is a 63/68 case I am providing my code:\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int minValue = INT_MAX;\\n        int left = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (minValue > nums[i]) {\\n                minValue = nums[i];\\n                left = i;\\n            }\\n        }\\n        \\n        int maxValue = INT_MIN;\\n        for (int j = 0; j <= left; j++) {\\n            if (maxValue < nums[j]) {\\n                maxValue = nums[j];\\n            }\\n        }\\n        \\n        int ans = left;\\n        for (int k = left + 1; k < nums.size(); k++) {\\n            if (nums[k] < maxValue) {\\n                ans = k;\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "[@abdK007](/abdK007) \n1. temporarily left partition up to the minimum value in the array->>26\n2. find a max element in the left subarray i.e. [26] so the max is 26 \n3. find an element in the right subarray [51,40,58,42,76,30,48,79,91] that is less than the max element in the left array if the condition is valid make the partition up to that element\n run the loop up to the last element in the right subarray.\nbut the same logic is not valid for all the cases.\nthe correct solution is :\nclass Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int n = nums.size();\n        int maxLeft = nums[0];\n        int currMax = nums[0];\n        int partitionIndex = 0;\n        \n        for (int i = 1; i < n; i++) {\n            currMax = max(currMax, nums[i]);\n            \n            if (nums[i] < maxLeft) {\n                maxLeft = currMax;\n                partitionIndex = i;\n            }\n        }\n        \n        return partitionIndex + 1;\n    }\n};\n"
                    },
                    {
                        "username": "abdK007",
                        "content": "hey can you explain this test case :- [26,51,40,58,42,76,30,48,79,91]\\nhow left --> [26,51,40,58,42,76,30,48,]  and right --> [79,91] are incorrect"
                    },
                    {
                        "username": "sb26",
                        "content": "Input: [5,0,3,8,6]\\nOutput: 3\\nExplanation: left = [5,0,3], right = [8,6]\\n\\nThis can be further partioned as [5,0,3,6] and [8]\\nStill holds true\\n\\nAlso [0,3] holds true too"
                    },
                    {
                        "username": "mini_bong",
                        "content": "The size of left subarray should be minimum and both subarray should be contiguous."
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, the left and right need to be contiguous"
                    },
                    {
                        "username": "palak-agg",
                        "content": "If I am right, the first element of the right array should be greater than the max element of the left array."
                    },
                    {
                        "username": "zhhackk",
                        "content": "not the first element, but the minimum of right array"
                    },
                    {
                        "username": "abdK007",
                        "content": "Can someone help me out with this testCase  no 34:-   @\\nInput --> [26,51,40,58,42,76,30,48,79,91]\\n output -->  8 \\nExpected --> 1\\nhere the partition can be [26,51,40,58,42,76,30,48]     [79,91]"
                    },
                    {
                        "username": "Pkmaurya88_",
                        "content": "yes it can be but we have to find minimum possible in left that\\'s why answer is 1"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "When you are at one element, think whether you can put this element in second part....you will definitely arrive at the one-pass solution"
                    }
                ]
            },
            {
                "id": 1975690,
                "content": [
                    {
                        "username": "nithatech",
                        "content": "Example 2:\\n\\nInput: [1,1,1,0,6,12]\\nOutput: 4\\nExplanation: left = [1,1,1,0], right = [6,12]\\n\\n============\\n\\nHere, the output could be [0], [1,1,1,6,12] or [0,1],[1,1,6,12] and few other possibilities, isn\\'t it?"
                    },
                    {
                        "username": "mini_bong",
                        "content": "No, we have to do partition in two contiguous subarray."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "I guess you\\'re not allowed to change the order of the elements"
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, left needs to have the smallest possible size"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "its not  medium level ques. \\nits damm tough!!"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "what is the answer for this case {29, 33, 6, 4, 42, 0, 10, 22, 62, 16, 46, 75, 100, 67, 70, 74, 87, 69, 73, 88} ? my code gave 10 why it is wrong ? this is a 63/68 case I am providing my code:\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int minValue = INT_MAX;\\n        int left = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (minValue > nums[i]) {\\n                minValue = nums[i];\\n                left = i;\\n            }\\n        }\\n        \\n        int maxValue = INT_MIN;\\n        for (int j = 0; j <= left; j++) {\\n            if (maxValue < nums[j]) {\\n                maxValue = nums[j];\\n            }\\n        }\\n        \\n        int ans = left;\\n        for (int k = left + 1; k < nums.size(); k++) {\\n            if (nums[k] < maxValue) {\\n                ans = k;\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "[@abdK007](/abdK007) \n1. temporarily left partition up to the minimum value in the array->>26\n2. find a max element in the left subarray i.e. [26] so the max is 26 \n3. find an element in the right subarray [51,40,58,42,76,30,48,79,91] that is less than the max element in the left array if the condition is valid make the partition up to that element\n run the loop up to the last element in the right subarray.\nbut the same logic is not valid for all the cases.\nthe correct solution is :\nclass Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int n = nums.size();\n        int maxLeft = nums[0];\n        int currMax = nums[0];\n        int partitionIndex = 0;\n        \n        for (int i = 1; i < n; i++) {\n            currMax = max(currMax, nums[i]);\n            \n            if (nums[i] < maxLeft) {\n                maxLeft = currMax;\n                partitionIndex = i;\n            }\n        }\n        \n        return partitionIndex + 1;\n    }\n};\n"
                    },
                    {
                        "username": "abdK007",
                        "content": "hey can you explain this test case :- [26,51,40,58,42,76,30,48,79,91]\\nhow left --> [26,51,40,58,42,76,30,48,]  and right --> [79,91] are incorrect"
                    },
                    {
                        "username": "sb26",
                        "content": "Input: [5,0,3,8,6]\\nOutput: 3\\nExplanation: left = [5,0,3], right = [8,6]\\n\\nThis can be further partioned as [5,0,3,6] and [8]\\nStill holds true\\n\\nAlso [0,3] holds true too"
                    },
                    {
                        "username": "mini_bong",
                        "content": "The size of left subarray should be minimum and both subarray should be contiguous."
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, the left and right need to be contiguous"
                    },
                    {
                        "username": "palak-agg",
                        "content": "If I am right, the first element of the right array should be greater than the max element of the left array."
                    },
                    {
                        "username": "zhhackk",
                        "content": "not the first element, but the minimum of right array"
                    },
                    {
                        "username": "abdK007",
                        "content": "Can someone help me out with this testCase  no 34:-   @\\nInput --> [26,51,40,58,42,76,30,48,79,91]\\n output -->  8 \\nExpected --> 1\\nhere the partition can be [26,51,40,58,42,76,30,48]     [79,91]"
                    },
                    {
                        "username": "Pkmaurya88_",
                        "content": "yes it can be but we have to find minimum possible in left that\\'s why answer is 1"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "When you are at one element, think whether you can put this element in second part....you will definitely arrive at the one-pass solution"
                    }
                ]
            },
            {
                "id": 1958859,
                "content": [
                    {
                        "username": "nithatech",
                        "content": "Example 2:\\n\\nInput: [1,1,1,0,6,12]\\nOutput: 4\\nExplanation: left = [1,1,1,0], right = [6,12]\\n\\n============\\n\\nHere, the output could be [0], [1,1,1,6,12] or [0,1],[1,1,6,12] and few other possibilities, isn\\'t it?"
                    },
                    {
                        "username": "mini_bong",
                        "content": "No, we have to do partition in two contiguous subarray."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "I guess you\\'re not allowed to change the order of the elements"
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, left needs to have the smallest possible size"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "its not  medium level ques. \\nits damm tough!!"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "what is the answer for this case {29, 33, 6, 4, 42, 0, 10, 22, 62, 16, 46, 75, 100, 67, 70, 74, 87, 69, 73, 88} ? my code gave 10 why it is wrong ? this is a 63/68 case I am providing my code:\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int minValue = INT_MAX;\\n        int left = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (minValue > nums[i]) {\\n                minValue = nums[i];\\n                left = i;\\n            }\\n        }\\n        \\n        int maxValue = INT_MIN;\\n        for (int j = 0; j <= left; j++) {\\n            if (maxValue < nums[j]) {\\n                maxValue = nums[j];\\n            }\\n        }\\n        \\n        int ans = left;\\n        for (int k = left + 1; k < nums.size(); k++) {\\n            if (nums[k] < maxValue) {\\n                ans = k;\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "[@abdK007](/abdK007) \n1. temporarily left partition up to the minimum value in the array->>26\n2. find a max element in the left subarray i.e. [26] so the max is 26 \n3. find an element in the right subarray [51,40,58,42,76,30,48,79,91] that is less than the max element in the left array if the condition is valid make the partition up to that element\n run the loop up to the last element in the right subarray.\nbut the same logic is not valid for all the cases.\nthe correct solution is :\nclass Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int n = nums.size();\n        int maxLeft = nums[0];\n        int currMax = nums[0];\n        int partitionIndex = 0;\n        \n        for (int i = 1; i < n; i++) {\n            currMax = max(currMax, nums[i]);\n            \n            if (nums[i] < maxLeft) {\n                maxLeft = currMax;\n                partitionIndex = i;\n            }\n        }\n        \n        return partitionIndex + 1;\n    }\n};\n"
                    },
                    {
                        "username": "abdK007",
                        "content": "hey can you explain this test case :- [26,51,40,58,42,76,30,48,79,91]\\nhow left --> [26,51,40,58,42,76,30,48,]  and right --> [79,91] are incorrect"
                    },
                    {
                        "username": "sb26",
                        "content": "Input: [5,0,3,8,6]\\nOutput: 3\\nExplanation: left = [5,0,3], right = [8,6]\\n\\nThis can be further partioned as [5,0,3,6] and [8]\\nStill holds true\\n\\nAlso [0,3] holds true too"
                    },
                    {
                        "username": "mini_bong",
                        "content": "The size of left subarray should be minimum and both subarray should be contiguous."
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, the left and right need to be contiguous"
                    },
                    {
                        "username": "palak-agg",
                        "content": "If I am right, the first element of the right array should be greater than the max element of the left array."
                    },
                    {
                        "username": "zhhackk",
                        "content": "not the first element, but the minimum of right array"
                    },
                    {
                        "username": "abdK007",
                        "content": "Can someone help me out with this testCase  no 34:-   @\\nInput --> [26,51,40,58,42,76,30,48,79,91]\\n output -->  8 \\nExpected --> 1\\nhere the partition can be [26,51,40,58,42,76,30,48]     [79,91]"
                    },
                    {
                        "username": "Pkmaurya88_",
                        "content": "yes it can be but we have to find minimum possible in left that\\'s why answer is 1"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "When you are at one element, think whether you can put this element in second part....you will definitely arrive at the one-pass solution"
                    }
                ]
            },
            {
                "id": 1904320,
                "content": [
                    {
                        "username": "nithatech",
                        "content": "Example 2:\\n\\nInput: [1,1,1,0,6,12]\\nOutput: 4\\nExplanation: left = [1,1,1,0], right = [6,12]\\n\\n============\\n\\nHere, the output could be [0], [1,1,1,6,12] or [0,1],[1,1,6,12] and few other possibilities, isn\\'t it?"
                    },
                    {
                        "username": "mini_bong",
                        "content": "No, we have to do partition in two contiguous subarray."
                    },
                    {
                        "username": "alwaysaditi",
                        "content": "I guess you\\'re not allowed to change the order of the elements"
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, left needs to have the smallest possible size"
                    },
                    {
                        "username": "ajbil3112",
                        "content": "its not  medium level ques. \\nits damm tough!!"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "what is the answer for this case {29, 33, 6, 4, 42, 0, 10, 22, 62, 16, 46, 75, 100, 67, 70, 74, 87, 69, 73, 88} ? my code gave 10 why it is wrong ? this is a 63/68 case I am providing my code:\\nclass Solution {\\npublic:\\n    int partitionDisjoint(vector<int>& nums) {\\n        int minValue = INT_MAX;\\n        int left = 0;\\n        \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (minValue > nums[i]) {\\n                minValue = nums[i];\\n                left = i;\\n            }\\n        }\\n        \\n        int maxValue = INT_MIN;\\n        for (int j = 0; j <= left; j++) {\\n            if (maxValue < nums[j]) {\\n                maxValue = nums[j];\\n            }\\n        }\\n        \\n        int ans = left;\\n        for (int k = left + 1; k < nums.size(); k++) {\\n            if (nums[k] < maxValue) {\\n                ans = k;\\n            }\\n        }\\n        \\n        return ans + 1;\\n    }\\n};\\n"
                    },
                    {
                        "username": "surendra_melam",
                        "content": "[@abdK007](/abdK007) \n1. temporarily left partition up to the minimum value in the array->>26\n2. find a max element in the left subarray i.e. [26] so the max is 26 \n3. find an element in the right subarray [51,40,58,42,76,30,48,79,91] that is less than the max element in the left array if the condition is valid make the partition up to that element\n run the loop up to the last element in the right subarray.\nbut the same logic is not valid for all the cases.\nthe correct solution is :\nclass Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int n = nums.size();\n        int maxLeft = nums[0];\n        int currMax = nums[0];\n        int partitionIndex = 0;\n        \n        for (int i = 1; i < n; i++) {\n            currMax = max(currMax, nums[i]);\n            \n            if (nums[i] < maxLeft) {\n                maxLeft = currMax;\n                partitionIndex = i;\n            }\n        }\n        \n        return partitionIndex + 1;\n    }\n};\n"
                    },
                    {
                        "username": "abdK007",
                        "content": "hey can you explain this test case :- [26,51,40,58,42,76,30,48,79,91]\\nhow left --> [26,51,40,58,42,76,30,48,]  and right --> [79,91] are incorrect"
                    },
                    {
                        "username": "sb26",
                        "content": "Input: [5,0,3,8,6]\\nOutput: 3\\nExplanation: left = [5,0,3], right = [8,6]\\n\\nThis can be further partioned as [5,0,3,6] and [8]\\nStill holds true\\n\\nAlso [0,3] holds true too"
                    },
                    {
                        "username": "mini_bong",
                        "content": "The size of left subarray should be minimum and both subarray should be contiguous."
                    },
                    {
                        "username": "kmp1084",
                        "content": "no, the left and right need to be contiguous"
                    },
                    {
                        "username": "palak-agg",
                        "content": "If I am right, the first element of the right array should be greater than the max element of the left array."
                    },
                    {
                        "username": "zhhackk",
                        "content": "not the first element, but the minimum of right array"
                    },
                    {
                        "username": "abdK007",
                        "content": "Can someone help me out with this testCase  no 34:-   @\\nInput --> [26,51,40,58,42,76,30,48,79,91]\\n output -->  8 \\nExpected --> 1\\nhere the partition can be [26,51,40,58,42,76,30,48]     [79,91]"
                    },
                    {
                        "username": "Pkmaurya88_",
                        "content": "yes it can be but we have to find minimum possible in left that\\'s why answer is 1"
                    },
                    {
                        "username": "saijayavinoth",
                        "content": "When you are at one element, think whether you can put this element in second part....you will definitely arrive at the one-pass solution"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sort the Matrix Diagonally",
        "question_content": "<p>A <strong>matrix diagonal</strong> is a diagonal line of cells starting from some cell in either the topmost row or leftmost column and going in the bottom-right direction until reaching the matrix&#39;s end. For example, the <strong>matrix diagonal</strong> starting from <code>mat[2][0]</code>, where <code>mat</code> is a <code>6 x 3</code> matrix, includes cells <code>mat[2][0]</code>, <code>mat[3][1]</code>, and <code>mat[4][2]</code>.</p>\n\n<p>Given an <code>m x n</code> matrix <code>mat</code> of integers, sort each <strong>matrix diagonal</strong> in ascending order and return <em>the resulting matrix</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/21/1482_example_1_2.png\" style=\"width: 500px; height: 198px;\" />\n<pre>\n<strong>Input:</strong> mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]\n<strong>Output:</strong> [[1,1,1,1],[1,2,2,2],[1,2,3,3]]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> mat = [[11,25,66,1,69,7],[23,55,17,45,15,52],[75,31,36,44,58,8],[22,27,33,25,68,4],[84,28,14,11,5,50]]\n<strong>Output:</strong> [[5,17,4,1,52,7],[11,11,25,45,8,69],[14,23,25,44,58,15],[22,27,31,36,50,66],[84,28,75,33,55,68]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == mat.length</code></li>\n\t<li><code>n == mat[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 100</code></li>\n\t<li><code>1 &lt;= mat[i][j] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 489749,
                "title": "java-python-straight-forward",
                "content": "## **Explanation**\\n`A[i][j]` on the same diagonal have same value of `i - j`\\nFor each diagonal,\\nput its elements together, sort, and set them back.\\n<br>\\n\\n## **Complexity**\\nTime `O(MNlogD)`, where `D` is the length of diagonal with `D = min(M,N)`.\\nSpace `O(MN)`\\n<br>\\n\\n**Java**\\nBy @hiepit\\n```java\\n    public int[][] diagonalSort(int[][] A) {\\n        int m = A.length, n = A[0].length;\\n        HashMap<Integer, PriorityQueue<Integer>> d = new HashMap<>();\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                d.putIfAbsent(i - j, new PriorityQueue<>());\\n                d.get(i - j).add(A[i][j]);\\n            }\\n        }\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                A[i][j] = d.get(i - j).poll();\\n        return A;\\n    }\\n```\\n**C++**\\nBy @chepson\\n```cpp\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size();\\n        // all elements on same diagonal have same i-j result.\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> map; // min priority queue\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                map[i - j].push(mat[i][j]);\\n            }\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                mat[i][j] = map[i - j].top(); map[i - j].pop();\\n            }\\n        }\\n        return mat;\\n    }\\n```\\n**Python:**\\n```python\\n    def diagonalSort(self, A):\\n        n, m = len(A), len(A[0])\\n        d = collections.defaultdict(list)\\n        for i in xrange(n):\\n            for j in xrange(m):\\n                d[i - j].append(A[i][j])\\n        for k in d:\\n            d[k].sort(reverse=1)\\n        for i in xrange(n):\\n            for j in xrange(m):\\n                A[i][j] = d[i - j].pop()\\n        return A\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int[][] diagonalSort(int[][] A) {\\n        int m = A.length, n = A[0].length;\\n        HashMap<Integer, PriorityQueue<Integer>> d = new HashMap<>();\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                d.putIfAbsent(i - j, new PriorityQueue<>());\\n                d.get(i - j).add(A[i][j]);\\n            }\\n        }\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                A[i][j] = d.get(i - j).poll();\\n        return A;\\n    }\\n```\n```cpp\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m = mat.size(), n = mat[0].size();\\n        // all elements on same diagonal have same i-j result.\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> map; // min priority queue\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                map[i - j].push(mat[i][j]);\\n            }\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                mat[i][j] = map[i - j].top(); map[i - j].pop();\\n            }\\n        }\\n        return mat;\\n    }\\n```\n```python\\n    def diagonalSort(self, A):\\n        n, m = len(A), len(A[0])\\n        d = collections.defaultdict(list)\\n        for i in xrange(n):\\n            for j in xrange(m):\\n                d[i - j].append(A[i][j])\\n        for k in d:\\n            d[k].sort(reverse=1)\\n        for i in xrange(n):\\n            for j in xrange(m):\\n                A[i][j] = d[i - j].pop()\\n        return A\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2659828,
                "title": "easy-solution-with",
                "content": "**Visualization**\\n![image](https://assets.leetcode.com/users/images/d7a81a95-2c5b-40c4-855f-9af357a61fb7_1665244489.6516232.png)\\n\\n**Code**\\n```\\nfrom collections import defaultdict\\n\\n    def diagonalSort(self, mat):\\n\\n        # n is number of columns (\\u2551\\u2551\\u2551\\u2551)\\n        n = len(mat)\\n\\n        # m is number of rows    (\\u2550\\u2550\\u2550\\u2550)\\n        m = len(mat[0])\\n\\n        # create a diagonal map where\\n        #      key is diagonal index\\n        #      value is list of elements in that diagonal\\n        # We find the diagonal index by subtracting the ith and jth column which map each element to the diagonal to which the element belongs.\\n        # Result:\\n\\t\\t# \\u2554\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2557             \\u2554\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2557\\n        # \\u2551 3 \\u2551 3 \\u2551 1 \\u2551 1 \\u2551 [-3]        \\u2551 Diagonal Index \\u2551 Diaognal Elements \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2563             \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551 2 \\u2551 2 \\u2551 1 \\u2551 2 \\u2551 [-2]   =>   \\u2551        2       \\u2551         1         \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2563             \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551 1 \\u2551 1 \\u2551 1 \\u2551 2 \\u2551 [-1]        \\u2551        1       \\u2551        2,1        \\u2551\\n        # \\u255A\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u255D             \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        #  [2] [1] [0]                  \\u2551        0       \\u2551       3,2,1       \\u2551\\n        #                               \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        #                               \\u2551       -1       \\u2551       3,1,2       \\u2551\\n        #                               \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        #                               \\u2551       -2       \\u2551        1,2        \\u2551\\n        #                               \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        #                               \\u2551       -3       \\u2551         1         \\u2551\\n        #                               \\u255A\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255D\\n        map = defaultdict(list)\\n        for i in range(n):\\n            for j in range(m):\\n                diagonal_index = i-j\\n                element = mat[i][j]\\n                map[diagonal_index].append(element)\\n\\n        # sort every diagonal elements in descending order\\n        # Result:\\n        # \\u2554\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2557        \\u2554\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2557\\n        # \\u2551 Diagonal Index \\u2551 Diaognal Elements \\u2551        \\u2551 Diagonal Index \\u2551 Diaognal Elements \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563        \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551        2       \\u2551         1         \\u2551        \\u2551        2       \\u2551         1         \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563        \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551        1       \\u2551        2,1        \\u2551        \\u2551        1       \\u2551        2,1        \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563        \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551        0       \\u2551       3,2,1       \\u2551   =>   \\u2551        0       \\u2551       3,2,1       \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563        \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551       -1       \\u2551       3,1,2       \\u2551        \\u2551       -1       \\u2551       3,2,1       \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563        \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551       -2       \\u2551        1,2        \\u2551        \\u2551       -2       \\u2551        2,1        \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563        \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551       -3       \\u2551         1         \\u2551        \\u2551       -3       \\u2551         1         \\u2551\\n        # \\u255A\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255D        \\u255A\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255D\\n        for key in map:\\n            map[key].sort(reverse=True)\\n\\n        # Put values back in matrix\\n        # Result:\\n        # \\u2554\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2557        \\u2554\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2557\\n        # \\u2551 Diagonal Index \\u2551 Diaognal Elements \\u2551        \\u2551 1 \\u2551 1 \\u2551 1 \\u2551 1 \\u2551 [-3]\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563        \\u2560\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551        2       \\u2551         1         \\u2551   =>   \\u2551 1 \\u2551 2 \\u2551 2 \\u2551 2 \\u2551 [-2]\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563        \\u2560\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551        1       \\u2551        2,1        \\u2551        \\u2551 1 \\u2551 2 \\u2551 3 \\u2551 3 \\u2551 [-1]\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563        \\u255A\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u255D\\n        # \\u2551        0       \\u2551       3,2,1       \\u2551         [2] [1] [0]\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551       -1       \\u2551       3,2,1       \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551       -2       \\u2551        2,1        \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551       -3       \\u2551         1         \\u2551\\n        # \\u255A\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255D\\n            for j in range(m):\\n                diagonal_index = i-j\\n                # pop will make sure elements are put in ascending order are set\\n                element = map[diagonal_index].pop()\\n                mat[i][j] = element\\n\\n        # Return the result :) \\uD83D\\uDE0A\\n        return mat\\n```\\n\\n\\uD83D\\uDE4F Thanks to tablesgenerator.com for tables \\uD83D\\uDE4F\\n\\uD83C\\uDDEE\\uD83C\\uDDF3 Vande Mataram \\uD83C\\uDDEE\\uD83C\\uDDF3\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\n    def diagonalSort(self, mat):\\n\\n        # n is number of columns (\\u2551\\u2551\\u2551\\u2551)\\n        n = len(mat)\\n\\n        # m is number of rows    (\\u2550\\u2550\\u2550\\u2550)\\n        m = len(mat[0])\\n\\n        # create a diagonal map where\\n        #      key is diagonal index\\n        #      value is list of elements in that diagonal\\n        # We find the diagonal index by subtracting the ith and jth column which map each element to the diagonal to which the element belongs.\\n        # Result:\\n\\t\\t# \\u2554\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2557             \\u2554\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2557\\n        # \\u2551 3 \\u2551 3 \\u2551 1 \\u2551 1 \\u2551 [-3]        \\u2551 Diagonal Index \\u2551 Diaognal Elements \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2563             \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551 2 \\u2551 2 \\u2551 1 \\u2551 2 \\u2551 [-2]   =>   \\u2551        2       \\u2551         1         \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2563             \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551 1 \\u2551 1 \\u2551 1 \\u2551 2 \\u2551 [-1]        \\u2551        1       \\u2551        2,1        \\u2551\\n        # \\u255A\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u255D             \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        #  [2] [1] [0]                  \\u2551        0       \\u2551       3,2,1       \\u2551\\n        #                               \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        #                               \\u2551       -1       \\u2551       3,1,2       \\u2551\\n        #                               \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        #                               \\u2551       -2       \\u2551        1,2        \\u2551\\n        #                               \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        #                               \\u2551       -3       \\u2551         1         \\u2551\\n        #                               \\u255A\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255D\\n        map = defaultdict(list)\\n        for i in range(n):\\n            for j in range(m):\\n                diagonal_index = i-j\\n                element = mat[i][j]\\n                map[diagonal_index].append(element)\\n\\n        # sort every diagonal elements in descending order\\n        # Result:\\n        # \\u2554\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2557        \\u2554\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2557\\n        # \\u2551 Diagonal Index \\u2551 Diaognal Elements \\u2551        \\u2551 Diagonal Index \\u2551 Diaognal Elements \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563        \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551        2       \\u2551         1         \\u2551        \\u2551        2       \\u2551         1         \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563        \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551        1       \\u2551        2,1        \\u2551        \\u2551        1       \\u2551        2,1        \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563        \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551        0       \\u2551       3,2,1       \\u2551   =>   \\u2551        0       \\u2551       3,2,1       \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563        \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551       -1       \\u2551       3,1,2       \\u2551        \\u2551       -1       \\u2551       3,2,1       \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563        \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551       -2       \\u2551        1,2        \\u2551        \\u2551       -2       \\u2551        2,1        \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563        \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551       -3       \\u2551         1         \\u2551        \\u2551       -3       \\u2551         1         \\u2551\\n        # \\u255A\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255D        \\u255A\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255D\\n        for key in map:\\n            map[key].sort(reverse=True)\\n\\n        # Put values back in matrix\\n        # Result:\\n        # \\u2554\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2557        \\u2554\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2566\\u2550\\u2550\\u2550\\u2557\\n        # \\u2551 Diagonal Index \\u2551 Diaognal Elements \\u2551        \\u2551 1 \\u2551 1 \\u2551 1 \\u2551 1 \\u2551 [-3]\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563        \\u2560\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551        2       \\u2551         1         \\u2551   =>   \\u2551 1 \\u2551 2 \\u2551 2 \\u2551 2 \\u2551 [-2]\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563        \\u2560\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551        1       \\u2551        2,1        \\u2551        \\u2551 1 \\u2551 2 \\u2551 3 \\u2551 3 \\u2551 [-1]\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563        \\u255A\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u255D\\n        # \\u2551        0       \\u2551       3,2,1       \\u2551         [2] [1] [0]\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551       -1       \\u2551       3,2,1       \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551       -2       \\u2551        2,1        \\u2551\\n        # \\u2560\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u256C\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2563\\n        # \\u2551       -3       \\u2551         1         \\u2551\\n        # \\u255A\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2569\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255D\\n            for j in range(m):\\n                diagonal_index = i-j\\n                # pop will make sure elements are put in ascending order are set\\n                element = map[diagonal_index].pop()\\n                mat[i][j] = element\\n\\n        # Return the result :) \\uD83D\\uDE0A\\n        return mat\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 489775,
                "title": "c-elegant-map-solution-easy-to-understand",
                "content": "\\n    unordered_map<int, vector<int>> mp;\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                mp[i-j].push_back(mat[i][j]);\\n            }\\n        }\\n        \\n        for(int k=-(n-1);k<m;k++) {\\n            sort(mp[k].begin(),mp[k].end());\\n        }\\n        \\n        for(int i=m-1;i>=0;i--) {\\n            for(int j=n-1;j>=0;j--) {\\n                mat[i][j]=mp[i-j].back();\\n                mp[i-j].pop_back();\\n            }\\n        }\\n        return mat;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n    unordered_map<int, vector<int>> mp;\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                mp[i-j].push_back(mat[i][j]);\\n            }\\n        }\\n        \\n        for(int k=-(n-1);k<m;k++) {\\n            sort(mp[k].begin(),mp[k].end());\\n        }\\n        \\n        for(int i=m-1;i>=0;i--) {\\n            for(int j=n-1;j>=0;j--) {\\n                mat[i][j]=mp[i-j].back();\\n                mp[i-j].pop_back();\\n            }\\n        }\\n        return mat;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2493662,
                "title": "python-c-easiest-approach-detailed-explanation-beginner-friendly-easy-understand",
                "content": "**Easy idea:**\\n1. We store values in the same diagonal into same list.\\n2. Sort the list.\\n3. Put values back\\n\\nHere\\'s an example to show how the code works:\\n![image](https://assets.leetcode.com/users/images/57f70f87-d538-4da7-b043-d62c23936646_1661665093.9748018.png)\\n\\n**Code:**\\n<iframe src=\"https://leetcode.com/playground/gze25rVK/shared\" frameBorder=\"0\" width=\"1000\" height=\"500\"></iframe>\\n\\n**Please UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "**Easy idea:**\\n1. We store values in the same diagonal into same list.\\n2. Sort the list.\\n3. Put values back\\n\\nHere\\'s an example to show how the code works:\\n![image](https://assets.leetcode.com/users/images/57f70f87-d538-4da7-b043-d62c23936646_1661665093.9748018.png)\\n\\n**Code:**\\n<iframe src=\"https://leetcode.com/playground/gze25rVK/shared\" frameBorder=\"0\" width=\"1000\" height=\"500\"></iframe>\\n\\n**Please UPVOTE if you LIKE!!**",
                "codeTag": "Unknown"
            },
            {
                "id": 2492679,
                "title": "c-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n**TIME :** O ( N * LOG N ) -> sort\\n\\t\\t\\t\\t  O ( N ) -> number of diagonals\\n\\t\\t\\t\\t  *TOTAL* -> **O ( N * N * LOG N )**\\n\\n**SPACE : O ( N )**  -> Only on extra vector used\\n\\nCreate a vector ```k``` in which we will store the elements for a particular diagional.\\nWe simply sort the vector and change the elements of that diagonal with elements of **sorted** vector.\\n\\n**APPROACH**\\n\\nFirst traverse all diagonals that start from left side.\\n* Diagonals with first element as ```mat[ 0 ] [ j ]```\\n\\nThen traverse diaonals that start from the top.\\n* Diagonals with first element as ```mat[ i ] [ 0 ]```\\n\\nSort the elements by any means that seems best and then replace those elements.\\n\\n\\n**UPVOTE IF HELPFuuL**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        vector<int> k;\\n        int m = mat.size() , n = mat[0].size();\\n        for (int r=0; r<m; r++)        // r-> row\\n        {\\n            k.clear();\\n            for (int j=0,i=r; j<n && i<m ; j++,i++) k.push_back(mat[i][j]);    // add to vector\\n            sort(k.begin(),k.end());\\n            for (int j=0,i=r; j<n && i<m ; j++,i++) mat[i][j]=k[j];            // replace\\n        }\\n        for (int c=1; c<n; c++)       // c->column\\n        {\\n            k.clear();\\n            for (int i=0, j=c; j<n && i<m; i++, j++) k.push_back(mat[i][j]);   // add to vector\\n            sort(k.begin(),k.end());\\n            for (int i=0, j=c; j<n && i<m; i++, j++) mat[i][j] = k[i];         //replace\\n        }\\n        return mat;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/25970b8f-27ef-49aa-ad17-231a1b304f91_1661658541.014562.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```k```\n```mat[ 0 ] [ j ]```\n```mat[ i ] [ 0 ]```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        vector<int> k;\\n        int m = mat.size() , n = mat[0].size();\\n        for (int r=0; r<m; r++)        // r-> row\\n        {\\n            k.clear();\\n            for (int j=0,i=r; j<n && i<m ; j++,i++) k.push_back(mat[i][j]);    // add to vector\\n            sort(k.begin(),k.end());\\n            for (int j=0,i=r; j<n && i<m ; j++,i++) mat[i][j]=k[j];            // replace\\n        }\\n        for (int c=1; c<n; c++)       // c->column\\n        {\\n            k.clear();\\n            for (int i=0, j=c; j<n && i<m; i++, j++) k.push_back(mat[i][j]);   // add to vector\\n            sort(k.begin(),k.end());\\n            for (int i=0, j=c; j<n && i<m; i++, j++) mat[i][j] = k[i];         //replace\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489846,
                "title": "several-python-solutions",
                "content": "**Time complexity** for all is O(mn log(min(m,n)), as each of the mn elements is involved in a sort of at most min(m,n) elements. Not sure it\\'s a tight bound, as there are diagonals with fewer than min(m,n) elements.\\n\\n**Solution 1**\\n\\nFor each left cell and each top cell, sort the diagonal starting there. For each diagonal, first compute the list of its index pairs `ij`. Then use that list both for *reading* the values and for *writing* them back (after having sorted them).\\n\\nTime: See top\\nSpace: O(min(m,n))\\n```\\ndef diagonalSort(self, A):\\n    m, n = len(A), len(A[0])\\n    def sort(i, j):\\n        ij = zip(range(i, m), range(j, n))\\n        vals = iter(sorted(A[i][j] for i, j in ij))\\n        for i, j in ij:\\n            A[i][j] = next(vals)\\n    for i in range(m): sort(i, 0)\\n    for j in range(n): sort(0, j)\\n    return A\\n```\\nOptimized version, where I don\\'t zip `i`-indexes and `j`-indexes but *rows* and `j`-indexes (still O(min(m,n)) space, as `A[i:]` only copies *references* to the rows, not their contents):\\n```\\ndef diagonalSort(self, A):\\n    m, n = len(A), len(A[0])\\n    def sort(i, j):\\n        rj = zip(A[i:], range(j, n))\\n        vals = iter(sorted(r[j] for r, j in rj))\\n        for r, j in rj:\\n            r[j] = next(vals)\\n    for i in range(m): sort(i, 0)\\n    for j in range(n): sort(0, j)\\n    return A\\n```\\nAnd with nested loops and no helper function (like I came up with for my [&rarr;C++/Java version](https://leetcode.com/problems/sort-the-matrix-diagonally/discuss/489965/JavaC++-sort-one-diagonal-at-a-time)). Note about that `j`-loop: In the first row, `j` goes through the whole row, but in lower rows it only goes on the the first cell.\\n```\\ndef diagonalSort(self, A):\\n    m, n = len(A), len(A[0])\\n    for i in range(m):\\n        for j in range(1 if i else n):\\n            rj = zip(A[i:], range(j, n))\\n            vals = iter(sorted(r[j] for r, j in rj))\\n            for r, j in rj:\\n                r[j] = next(vals)\\n    return A\\n```\\n\\n**Solution 2**\\n\\nCollect all diagonals, sort them, then write them back. By sorting each diagonal in *reverse*, we can use `pop` to get the next value in O(1) time.\\n\\nTime: See top\\nSpace: O(mn)\\n```\\ndef diagonalSort(self, A):\\n    diags = collections.defaultdict(list)\\n    for i, row in enumerate(A):\\n        for j, a in enumerate(row):\\n            diags[i-j].append(a)\\n    for diag in diags.values():\\n        diag.sort(reverse=True)\\n    for i, row in enumerate(A):\\n        for j, _ in enumerate(row):\\n            A[i][j] = diags[i-j].pop()\\n    return A\\n```\\n\\n**Solution 3**\\n\\nLike solution 1, but more basic, so probably easier to port to other languages. Note how writing the sorted values backwards has two advantages: (1) I don\\'t need to reset `i` and `j` and (2) I don\\'t have to sort in reverse and `pop` takes only O(1) time.\\n\\nTime: See top\\nSpace: O(min(m,n))\\n```\\ndef diagonalSort(self, A):\\n    m, n = len(A), len(A[0])\\n    def sort(i, j):\\n        vals = []\\n        while i < m and j < n:\\n            vals.append(A[i][j])\\n            i += 1\\n            j += 1\\n        vals.sort()\\n        while i and j:\\n            j -= 1\\n            i -= 1\\n            A[i][j] = vals.pop()\\n    for i in range(m): sort(i, 0)\\n    for j in range(n): sort(0, j)\\n    return A\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef diagonalSort(self, A):\\n    m, n = len(A), len(A[0])\\n    def sort(i, j):\\n        ij = zip(range(i, m), range(j, n))\\n        vals = iter(sorted(A[i][j] for i, j in ij))\\n        for i, j in ij:\\n            A[i][j] = next(vals)\\n    for i in range(m): sort(i, 0)\\n    for j in range(n): sort(0, j)\\n    return A\\n```\n```\\ndef diagonalSort(self, A):\\n    m, n = len(A), len(A[0])\\n    def sort(i, j):\\n        rj = zip(A[i:], range(j, n))\\n        vals = iter(sorted(r[j] for r, j in rj))\\n        for r, j in rj:\\n            r[j] = next(vals)\\n    for i in range(m): sort(i, 0)\\n    for j in range(n): sort(0, j)\\n    return A\\n```\n```\\ndef diagonalSort(self, A):\\n    m, n = len(A), len(A[0])\\n    for i in range(m):\\n        for j in range(1 if i else n):\\n            rj = zip(A[i:], range(j, n))\\n            vals = iter(sorted(r[j] for r, j in rj))\\n            for r, j in rj:\\n                r[j] = next(vals)\\n    return A\\n```\n```\\ndef diagonalSort(self, A):\\n    diags = collections.defaultdict(list)\\n    for i, row in enumerate(A):\\n        for j, a in enumerate(row):\\n            diags[i-j].append(a)\\n    for diag in diags.values():\\n        diag.sort(reverse=True)\\n    for i, row in enumerate(A):\\n        for j, _ in enumerate(row):\\n            A[i][j] = diags[i-j].pop()\\n    return A\\n```\n```\\ndef diagonalSort(self, A):\\n    m, n = len(A), len(A[0])\\n    def sort(i, j):\\n        vals = []\\n        while i < m and j < n:\\n            vals.append(A[i][j])\\n            i += 1\\n            j += 1\\n        vals.sort()\\n        while i and j:\\n            j -= 1\\n            i -= 1\\n            A[i][j] = vals.pop()\\n    for i in range(m): sort(i, 0)\\n    for j in range(n): sort(0, j)\\n    return A\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 489737,
                "title": "c-bubble-sort-clean-clear-and-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) \\n    {\\n        for(int k = 0; k + 1 < mat.size(); k++)\\n             for(int i = 0; i + 1 < mat.size(); i++)\\n                for(int j = 0; j + 1 < mat[i].size(); j++)\\n                    if(mat[i][j] > mat[i + 1][j + 1])\\n                        swap(mat[i][j], mat[i + 1][j + 1]);   \\n        return mat;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) \\n    {\\n        for(int k = 0; k + 1 < mat.size(); k++)\\n             for(int i = 0; i + 1 < mat.size(); i++)\\n                for(int j = 0; j + 1 < mat[i].size(); j++)\\n                    if(mat[i][j] > mat[i + 1][j + 1])\\n                        swap(mat[i][j], mat[i + 1][j + 1]);   \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493821,
                "title": "python-easily-understood-faster-than-93-less-than-99",
                "content": "**Appreciate if you could upvote this solution**\\n\\nSolution: `math`\\n\\nIn order to solve this question, we need to:\\n1) extract each diagonal one by one (except the first and last diagonal -> no need to sort as only one value)\\n2) sort the diagonal\\n3) replace the original values in diagonal one by one\\n\\nFor example, in a `4x4` matrix, the coordinates of all the should be :\\n```\\n0,0     0,1     0,2     0,3\\n1,0     1,1     1,2     1,3\\n2,0     2,1     2,2     2,3\\n3,0     3,1     3,2     3,3\\n```\\nThe starting row and col for each diagonal should be \\n`[2, 0], [1, 0], [0, 0], [0, 1], [0, 2]`\\n\\nWe can use the follow code to get the starting coordinates:\\n```\\nfor i in range(1, row + col - 2):\\n\\t\\tif i < row:\\n\\t\\t\\tstart_row, start_col = row - i - 1, 0\\n\\t\\telse:\\n\\t\\t\\tstart_row, start_col = 0, i - row + 1\\n```\\n\\nThen, we can extract the other values for each diagonal one by one until reaching the boundary.\\nAfter sorting, replace the value one by one~ DONE!\\n\\nCode:\\n```\\ndef diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n\\trow, col = len(mat), len(mat[0])\\n\\ttotal_num = row * col\\n\\n\\tfor i in range(1, row + col - 2):\\n\\t\\tif i < row:\\n\\t\\t\\tstart_row, start_col = row - i - 1, 0\\n\\t\\telse:\\n\\t\\t\\tstart_row, start_col = 0, i - row + 1\\n\\n\\t\\tdiag = []\\n\\t\\twhile start_row < row and start_col < col:\\n\\t\\t\\tdiag.append(mat[start_row][start_col])\\n\\t\\t\\tstart_row += 1\\n\\t\\t\\tstart_col += 1\\n\\n\\t\\tdiag.sort()\\n\\t\\tstart_row -= 1\\n\\t\\tstart_col -= 1\\n\\t\\twhile start_row >= 0 and start_col >= 0:\\n\\t\\t\\tmat[start_row][start_col] = diag.pop()\\n\\t\\t\\tstart_row -= 1\\n\\t\\t\\tstart_col -= 1\\n\\n\\treturn(mat)\\n```\\n\\n\\nFeel free to correct me if the complexity is wrong :)\\n**Time Complexity**: `O((n+m) * min(n, m) * log(min(n ,m))`\\n**Space Complexity**: `O(min(n, m))`\\n\\n<br />",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n0,0     0,1     0,2     0,3\\n1,0     1,1     1,2     1,3\\n2,0     2,1     2,2     2,3\\n3,0     3,1     3,2     3,3\\n```\n```\\nfor i in range(1, row + col - 2):\\n\\t\\tif i < row:\\n\\t\\t\\tstart_row, start_col = row - i - 1, 0\\n\\t\\telse:\\n\\t\\t\\tstart_row, start_col = 0, i - row + 1\\n```\n```\\ndef diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n\\trow, col = len(mat), len(mat[0])\\n\\ttotal_num = row * col\\n\\n\\tfor i in range(1, row + col - 2):\\n\\t\\tif i < row:\\n\\t\\t\\tstart_row, start_col = row - i - 1, 0\\n\\t\\telse:\\n\\t\\t\\tstart_row, start_col = 0, i - row + 1\\n\\n\\t\\tdiag = []\\n\\t\\twhile start_row < row and start_col < col:\\n\\t\\t\\tdiag.append(mat[start_row][start_col])\\n\\t\\t\\tstart_row += 1\\n\\t\\t\\tstart_col += 1\\n\\n\\t\\tdiag.sort()\\n\\t\\tstart_row -= 1\\n\\t\\tstart_col -= 1\\n\\t\\twhile start_row >= 0 and start_col >= 0:\\n\\t\\t\\tmat[start_row][start_col] = diag.pop()\\n\\t\\t\\tstart_row -= 1\\n\\t\\t\\tstart_col -= 1\\n\\n\\treturn(mat)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 489738,
                "title": "java-straight-forward-concise-clean",
                "content": "![image](https://assets.leetcode.com/users/hiepit/image_1579973509.png)\\n\\n```java\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        for (int r = m - 1, c = 0; r >= 0; r--) fillMatrix(mat, m, n, r, c);\\n        for (int r = 0, c = 1; c < n - 1; c++) fillMatrix(mat, m, n, r, c);\\n        return mat;\\n    }\\n    private void fillMatrix(int[][] mat, int m, int n, int r, int c) {\\n        List<Integer> arr = new ArrayList<>();\\n        for (int i = 0; r + i < m && c + i < n; i++) arr.add(mat[r + i][c + i]);\\n        Collections.sort(arr);\\n        for (int i = 0; r + i < m && c + i < n; i++) mat[r + i][c + i] = arr.get(i);\\n    }\\n}\\n```\\nComplexity:\\n- Time:` O(M*N*log(N)`, where `N = diagonal = min(M, N)`\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        int m = mat.length, n = mat[0].length;\\n        for (int r = m - 1, c = 0; r >= 0; r--) fillMatrix(mat, m, n, r, c);\\n        for (int r = 0, c = 1; c < n - 1; c++) fillMatrix(mat, m, n, r, c);\\n        return mat;\\n    }\\n    private void fillMatrix(int[][] mat, int m, int n, int r, int c) {\\n        List<Integer> arr = new ArrayList<>();\\n        for (int i = 0; r + i < m && c + i < n; i++) arr.add(mat[r + i][c + i]);\\n        Collections.sort(arr);\\n        for (int i = 0; r + i < m && c + i < n; i++) mat[r + i][c + i] = arr.get(i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493594,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int n = mat.size(), p = mat[0].size();\\n        map<int, priority_queue<int, vector<int>, greater<int>>> diag;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < p; j++) {\\n                diag[i - j].push(mat[i][j]);\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < p; j++) {\\n                mat[i][j] = diag[i - j].top();\\n                diag[i - j].pop();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int n = mat.size(), p = mat[0].size();\\n        map<int, priority_queue<int, vector<int>, greater<int>>> diag;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < p; j++) {\\n                diag[i - j].push(mat[i][j]);\\n            }\\n        }\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < p; j++) {\\n                mat[i][j] = diag[i - j].top();\\n                diag[i - j].pop();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030707,
                "title": "python-solution-using-defautdict-explained",
                "content": "In this problem we are asked to sort each diagonal, so it is good idea to traverse all matrix and create defaultdict `d`: numbers on each diagonal. Note, that inside each diagonal `j - i` is the same, so it can be used as key for our defaultdict. There will be two stages:\\n\\n1. Traverse over all matrix and put `mat[i][j]` to the end of `d[j  - i]`.\\n2. Sort each diagonal and put values back to matrix `mat`. There is a small trick: imagine that `k` is value of `j - i` on diagonal, than `j = i + k`, so we need to update cell with cooridinates `(i, i + k)`. However we need to be careful here: we can have negative indexes, so if `k` is negative, we need to start not from `k`, but from `0`, that is add `-k`. In general indexes can be written as `([i + max(-k, 0), k + i + max(-k, 0))`: for positive `k` it is just `(i, k + i)` and for negative it is `(i - k, i)`.\\n\\n**Complexity**: time complexity is `O(mn*log(min(m,n))`, because we have `O(m+n)` diagonals on each no more than `min(m,n)` elements we need to sort. Space complexity is `O(mn)`.\\n\\n```\\nclass Solution:\\n    def diagonalSort(self, mat):\\n        m, n, d = len(mat), len(mat[0]), defaultdict(list)\\n        for i in range(m):\\n            for j in range(n):\\n                d[j - i].append(mat[i][j])\\n                \\n        for k in d:\\n            for i, num in enumerate(sorted(d[k])):\\n                mat[i + max(-k, 0)][k + i + max(-k, 0)] = num\\n                \\n        return mat\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def diagonalSort(self, mat):\\n        m, n, d = len(mat), len(mat[0]), defaultdict(list)\\n        for i in range(m):\\n            for j in range(n):\\n                d[j - i].append(mat[i][j])\\n                \\n        for k in d:\\n            for i, num in enumerate(sorted(d[k])):\\n                mat[i + max(-k, 0)][k + i + max(-k, 0)] = num\\n                \\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489965,
                "title": "java-c-sort-one-diagonal-at-a-time",
                "content": "Java/C++ versions of one of [&rarr;my Python solutions](https://leetcode.com/problems/sort-the-matrix-diagonally/discuss/489846/Several-Python-solutions).\\n\\nFrom each cell in the top row (i=0) and in the leftmost column (j=0), collect the values on the diagonal, sort them, and put them back in proper order.\\n\\nTime: `O(mn log(min(m,n))` (see note at the top [&rarr;here](https://leetcode.com/problems/sort-the-matrix-diagonally/discuss/489846/3-Python-solutions))\\nSpace: `O(min(m,n))`\\n\\n**Java**\\nNot sure sorting a stack of k values is O(k log k), as I\\'m not a Java guy. Please let me know if it\\'s not, preferably with an alternative that is :-)\\n```\\npublic int[][] diagonalSort(int[][] A) {\\n    int m = A.length, n = A[0].length;\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < (i>0?1:n); j++) {\\n            Stack<Integer> vals = new Stack<>();\\n            while (i<m && j<n)\\n                vals.add(A[i++][j++]);\\n            Collections.sort(vals);\\n            while (i > 0 && j > 0)\\n                A[--i][--j] = vals.pop();\\n        }\\n    }\\n    return A;\\n}\\n```\\n\\n**C++**\\n```\\nvector<vector<int>> diagonalSort(vector<vector<int>>& A) {\\n    int m = A.size(), n = A[0].size();\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < (i?1:n); j++) {\\n            vector<int> vals;\\n            while (i<m && j<n)\\n                vals.push_back(A[i++][j++]);\\n            sort(vals.begin(), vals.end());\\n            while (i && j) {\\n                A[--i][--j] = vals.back();\\n                vals.pop_back();\\n            }\\n        }\\n    }\\n    return A;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[][] diagonalSort(int[][] A) {\\n    int m = A.length, n = A[0].length;\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < (i>0?1:n); j++) {\\n            Stack<Integer> vals = new Stack<>();\\n            while (i<m && j<n)\\n                vals.add(A[i++][j++]);\\n            Collections.sort(vals);\\n            while (i > 0 && j > 0)\\n                A[--i][--j] = vals.pop();\\n        }\\n    }\\n    return A;\\n}\\n```\n```\\nvector<vector<int>> diagonalSort(vector<vector<int>>& A) {\\n    int m = A.size(), n = A[0].size();\\n    for (int i = 0; i < m; i++) {\\n        for (int j = 0; j < (i?1:n); j++) {\\n            vector<int> vals;\\n            while (i<m && j<n)\\n                vals.push_back(A[i++][j++]);\\n            sort(vals.begin(), vals.end());\\n            while (i && j) {\\n                A[--i][--j] = vals.back();\\n                vals.pop_back();\\n            }\\n        }\\n    }\\n    return A;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 498135,
                "title": "c-copy-and-sort",
                "content": "Go through `m + m - 1` starting points `p` of diagonals. Collect diagonal values in a vector, sort, and put them back.\\n\\n```CPP\\nvector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n    int m = mat.size(), n = mat[0].size();\\n    for (int p = 0; p < n + m; ++p) {\\n        vector<int> v;\\n        int pi = p < m ? p : 0, pj = max(0, p - m + 1);\\n        for (int i = pi, j = pj; i < m && j < n; ++i, ++j)\\n            v.push_back(mat[i][j]);\\n        sort(begin(v), end(v));\\n        for (int i = pi, j = pj, vp = 0; i < m && j < n; ++i, ++j, ++vp)\\n            mat[i][j] = v[vp];        \\n    }\\n    return mat;\\n}\\n```",
                "solutionTags": [],
                "code": "```CPP\\nvector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n    int m = mat.size(), n = mat[0].size();\\n    for (int p = 0; p < n + m; ++p) {\\n        vector<int> v;\\n        int pi = p < m ? p : 0, pj = max(0, p - m + 1);\\n        for (int i = pi, j = pj; i < m && j < n; ++i, ++j)\\n            v.push_back(mat[i][j]);\\n        sort(begin(v), end(v));\\n        for (int i = pi, j = pj, vp = 0; i < m && j < n; ++i, ++j, ++vp)\\n            mat[i][j] = v[vp];        \\n    }\\n    return mat;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2492597,
                "title": "java-easy-solution-using-priority-queue-90-faster-code",
                "content": "\\tPLEASE UPVOTE IF YOY LIKE.\\n```\\nclass Solution {\\n    \\n    PriorityQueue<Integer> pQ = new PriorityQueue<>();\\n    \\n    public int[][] diagonalSort(int[][] mat) {\\n        \\n        int[][] seen = new int[mat.length][mat[0].length];\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                if(seen[i][j] != 1) {\\n                    loadQueue(mat, i, j);\\n                    loadDiagonal(mat, seen, i, j);\\n                }\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n    \\n    \\n    public void loadQueue(int[][] mat, int i, int j) {\\n        if(i >= mat.length || j >= mat[0].length || i < 0 || j < 0) {\\n            return;\\n        }\\n        \\n        pQ.add(mat[i][j]);\\n        loadQueue(mat, i + 1, j + 1);\\n    }\\n    \\n    public void loadDiagonal(int[][] mat, int[][] seen,  int i, int j) {\\n        if(i >= mat.length || j > mat[0].length || i < 0 || j < 0 || pQ.isEmpty()) {\\n            return;\\n        }\\n        \\n        mat[i][j] = pQ.poll();\\n        seen[i][j] = 1;\\n        loadDiagonal(mat, seen, i + 1, j + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    \\n    PriorityQueue<Integer> pQ = new PriorityQueue<>();\\n    \\n    public int[][] diagonalSort(int[][] mat) {\\n        \\n        int[][] seen = new int[mat.length][mat[0].length];\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                if(seen[i][j] != 1) {\\n                    loadQueue(mat, i, j);\\n                    loadDiagonal(mat, seen, i, j);\\n                }\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n    \\n    \\n    public void loadQueue(int[][] mat, int i, int j) {\\n        if(i >= mat.length || j >= mat[0].length || i < 0 || j < 0) {\\n            return;\\n        }\\n        \\n        pQ.add(mat[i][j]);\\n        loadQueue(mat, i + 1, j + 1);\\n    }\\n    \\n    public void loadDiagonal(int[][] mat, int[][] seen,  int i, int j) {\\n        if(i >= mat.length || j > mat[0].length || i < 0 || j < 0 || pQ.isEmpty()) {\\n            return;\\n        }\\n        \\n        mat[i][j] = pQ.poll();\\n        seen[i][j] = 1;\\n        loadDiagonal(mat, seen, i + 1, j + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494118,
                "title": "java-faster-than-96-easy-fully-explained",
                "content": "\\n\\nHERE I HAVE PASSED ALL THE STARTING INDICES OF ALL THE DIAGONAL ELEMENTS OF THE MATRIX TO A HELPER FUNCTION pass( ). IN THE PASS FUNCTION I HAVE CREATED A FREQUENCY ARRAY OF SIZE 101 AND STORED ALL THE ELEMENT\\'S-FREQUENCY OF EVERY DIAGONAL .. THEN I HAVE SORTED THE INITIAL MATRIX DIAGONAL with help of frequency array (ARR) THERE ..  \\u21C4 PROCESS REPEATED FOR ALL DIAGONALS..\\n![image](https://assets.leetcode.com/users/images/c3a9bd28-7ff1-4d9c-afb8-94d308a82bd8_1661670322.2289155.jpeg)\\n\\n\\n\\n```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n      int n=mat.length;\\n        int count=0;//this keeps the count of elements in frst row & 1st col\\n        int m=mat[0].length;\\n        int i=0,k=0;\\n//this while loop will be sending all the starting element-index of the diagonal\\n         while(count<m+n){\\n             if(i==n-1&&k<m){++k;}\\n             if(i!=n-1){i++;}\\n             \\n             pass(mat,n-1-i,k,n,m);count++;\\n         }\\n        return mat;\\n    }\\n    public void pass(int [][]a,int row,int col,int n,int m){\\n \\n        //here we perform COUNT SORT IN EVERY DIAGONAL     \\n       \\n        int []arr=new int [101]; //Frequency Array\\n        int i=row,j=col;\\n        while(row<n&&col<m){\\n            arr[a[row++][col++]]++;\\n        }\\n//SORTING ELEMENTS IN ORIGINAL ARAY DIAGONAL        \\n       for(int k=0;k<101;k++){\\n           if(arr[k]>0){\\n               while(arr[k]!=0){\\n               a[i++][j++]=k;\\n                   --arr[k];\\n           }\\n           }\\n       } \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n      int n=mat.length;\\n        int count=0;//this keeps the count of elements in frst row & 1st col\\n        int m=mat[0].length;\\n        int i=0,k=0;\\n//this while loop will be sending all the starting element-index of the diagonal\\n         while(count<m+n){\\n             if(i==n-1&&k<m){++k;}\\n             if(i!=n-1){i++;}\\n             \\n             pass(mat,n-1-i,k,n,m);count++;\\n         }\\n        return mat;\\n    }\\n    public void pass(int [][]a,int row,int col,int n,int m){\\n \\n        //here we perform COUNT SORT IN EVERY DIAGONAL     \\n       \\n        int []arr=new int [101]; //Frequency Array\\n        int i=row,j=col;\\n        while(row<n&&col<m){\\n            arr[a[row++][col++]]++;\\n        }\\n//SORTING ELEMENTS IN ORIGINAL ARAY DIAGONAL        \\n       for(int k=0;k<101;k++){\\n           if(arr[k]>0){\\n               while(arr[k]!=0){\\n               a[i++][j++]=k;\\n                   --arr[k];\\n           }\\n           }\\n       } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490049,
                "title": "numpy-solution",
                "content": "This time using NumPy not for its speed but for its functionality.\\n```\\nimport numpy as np\\n\\nclass Solution(object):\\n\\n    def diagonalSort(self, A):\\n        A = np.array(A)\\n        for i in range(-99, 100):\\n            np.fill_diagonal(\\n                A[max(-i, 0):, max(i, 0):],\\n                sorted(A.diagonal(i)))\\n        return A\\n```\\nStrictly speaking I should return `A.tolist()`, but LeetCode accepts the above as well.",
                "solutionTags": [],
                "code": "```\\nimport numpy as np\\n\\nclass Solution(object):\\n\\n    def diagonalSort(self, A):\\n        A = np.array(A)\\n        for i in range(-99, 100):\\n            np.fill_diagonal(\\n                A[max(-i, 0):, max(i, 0):],\\n                sorted(A.diagonal(i)))\\n        return A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030741,
                "title": "sort-the-matrix-diagonally-simple-solution-w-explanation",
                "content": "***Idea:***\\n\\nThe easy solution here is to read each diagonal row, then sort it, then write it back again. To read the diagonal line, it can be best to think of the rows as extending out to the left and right.\\n\\n![image](https://assets.leetcode.com/users/images/b9f08eb1-9414-4956-af4e-bd3ef5edcf59_1611396909.7399392.png)\\n\\nFor a matrix (**M**) of height **y** and width **x**, in order to get all the diagonal rows, we would need to extend out the **i** values to the left by **y - 1**. But in this case, we can ignore the first and last diagonal rows, as they only contain one cell each and thus don\\'t need to be sorted. That means that the range of **i** should be **0 - (y - 2) <= i <= x - 1**, or **2 - y <= i <= x - 1**.\\n\\nThen we can just iterate through these diagonals and store the valid cell values in an array (**diag**). After sorting **diag**, we can then iterate back through the diagonal and replace the valid cells with the appropriate sorted value.\\n\\n` `\\n***Javascript Code:***\\n```\\nvar diagonalSort = function(M) {\\n    let y = M.length, x = M[0].length - 1\\n\\tfor (let i = 2 - y; i < x; i++) {              // Start far enough to the left to get\\n        let diag = new Array(y), k = 0             // all non-singleton diagonals\\n        for (let j = 0; j < y; j++)\\n            if (M[j][i+j]) diag[k++] = M[j][i+j]   // Only store valid cell values in the array\\n        diag.sort((a,b) => a - b), k = 0           // Sort the diagonal and reset its index\\n        for (let j = 0; j < y; j++)\\n            if (M[j][i+j]) M[j][i+j] = diag[k++]   // Replace the diagonal cells in sorted order\\n    }\\n    return M\\n};\\n\\n```\\n***Python Code:***\\n```\\nclass Solution(object):\\n    def diagonalSort(self, M):\\n        y, x = len(M), len(M[0])\\n        for i in range(2-y, x-1):\\n            valid = range(max(0,0-i), min(y,x-i))\\n            diag = sorted([M[j][i+j] for j in valid])\\n            for k in valid:\\n                M[k][i+k] = diag.pop(0)\\n        return M\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nvar diagonalSort = function(M) {\\n    let y = M.length, x = M[0].length - 1\\n\\tfor (let i = 2 - y; i < x; i++) {              // Start far enough to the left to get\\n        let diag = new Array(y), k = 0             // all non-singleton diagonals\\n        for (let j = 0; j < y; j++)\\n            if (M[j][i+j]) diag[k++] = M[j][i+j]   // Only store valid cell values in the array\\n        diag.sort((a,b) => a - b), k = 0           // Sort the diagonal and reset its index\\n        for (let j = 0; j < y; j++)\\n            if (M[j][i+j]) M[j][i+j] = diag[k++]   // Replace the diagonal cells in sorted order\\n    }\\n    return M\\n};\\n\\n```\n```\\nclass Solution(object):\\n    def diagonalSort(self, M):\\n        y, x = len(M), len(M[0])\\n        for i in range(2-y, x-1):\\n            valid = range(max(0,0-i), min(y,x-i))\\n            diag = sorted([M[j][i+j] for j in valid])\\n            for k in valid:\\n                M[k][i+k] = diag.pop(0)\\n        return M\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889570,
                "title": "python-faster-than-94-solution",
                "content": "```\\n   def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        d = {}\\n        \\n        rows = len(mat)\\n        cols = len(mat[0])\\n\\n        for i in range(rows):\\n            for j in range(cols):\\n                if i-j in d:\\n                    d[i-j].append(mat[i][j])\\n                else:\\n                    d[i-j] = [mat[i][j]]\\n                    \\n        for k in d.keys():\\n            d[k].sort()\\n            \\n        for i in range(rows):\\n            for j in range(cols):\\n                mat[i][j] = d[i-j].pop(0)\\n                \\n        return mat\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n   def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        d = {}\\n        \\n        rows = len(mat)\\n        cols = len(mat[0])\\n\\n        for i in range(rows):\\n            for j in range(cols):\\n                if i-j in d:\\n                    d[i-j].append(mat[i][j])\\n                else:\\n                    d[i-j] = [mat[i][j]]\\n                    \\n        for k in d.keys():\\n            d[k].sort()\\n            \\n        for i in range(rows):\\n            for j in range(cols):\\n                mat[i][j] = d[i-j].pop(0)\\n                \\n        return mat\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 497060,
                "title": "java-simple-and-organized-solution-beats-100-in-time",
                "content": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        // sort diagonals that are starting at top row\\n        for (int j = 0; j < mat[0].length; j++) {\\n            fillMat(mat, countDiagonal(mat, 0, j), 0, j);\\n        }\\n        \\n        // diagonals starting at first column\\n        for (int i = 1; i < mat.length; i++) {\\n            fillMat(mat, countDiagonal(mat, i, 0), i, 0);\\n        }\\n        \\n        return mat;\\n    }\\n    \\n    private int[] countDiagonal(int[][] mat, int i, int j) {\\n        // since the constraint specifys mat[i][j] is between 1 and 100, we can use a bucket\\n        int[] count = new int[101];\\n        while (i < mat.length && j < mat[0].length)\\n            count[mat[i++][j++]] ++;\\n        return count;\\n    }\\n    \\n    private void fillMat(int[][] mat, int[] count, int i, int j) {\\n        // fill diagonal start with the lowest value in the bucket\\n        int start = 1;\\n        while (i < mat.length && j < mat[0].length && start < 101) {\\n            while (count[start] == 0)\\n                start ++;\\n            mat[i++][j++] = start;\\n            count[start] --;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        // sort diagonals that are starting at top row\\n        for (int j = 0; j < mat[0].length; j++) {\\n            fillMat(mat, countDiagonal(mat, 0, j), 0, j);\\n        }\\n        \\n        // diagonals starting at first column\\n        for (int i = 1; i < mat.length; i++) {\\n            fillMat(mat, countDiagonal(mat, i, 0), i, 0);\\n        }\\n        \\n        return mat;\\n    }\\n    \\n    private int[] countDiagonal(int[][] mat, int i, int j) {\\n        // since the constraint specifys mat[i][j] is between 1 and 100, we can use a bucket\\n        int[] count = new int[101];\\n        while (i < mat.length && j < mat[0].length)\\n            count[mat[i++][j++]] ++;\\n        return count;\\n    }\\n    \\n    private void fillMat(int[][] mat, int[] count, int i, int j) {\\n        // fill diagonal start with the lowest value in the bucket\\n        int start = 1;\\n        while (i < mat.length && j < mat[0].length && start < 101) {\\n            while (count[start] == 0)\\n                start ++;\\n            mat[i++][j++] = start;\\n            count[start] --;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492657,
                "title": "leetcode-the-hard-way-priority-queue-with-explanation",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        // observation:\\n        // for each cell mat[i][j] in the same diagonal,\\n        // they will have the same value i - j\\n        \\n        // if the diagonal line is pointing to upper right direction, \\n        // then they will have the same value i + j (see https://leetcode.com/problems/diagonal-traverse/)\\n        \\n        // the idea is to use priority queue for each diagonal\\n        // as priority queue could sort it internally when a value is pushed / popped\\n        // we use greater<int> as we want the smallest go first\\n        map<int, priority_queue<int, vector<int>, greater<int>>> diag;\\n        // iterate each row\\n        for (int i = 0; i < n; i++) {\\n            // iterate each col\\n            for (int j = 0; j < m; j++) {\\n                // for each mat[i][j] \\n                // add it to corresponding priority queue\\n                diag[i - j].push(mat[i][j]);\\n            }\\n        }\\n        // iterate each row\\n        for (int i = 0; i < n; i++) {\\n            // iterate each col\\n            for (int j = 0; j < m; j++) {\\n                // diag[i - j].top() would return the smallest number in the current queue\\n                // we can just perform in-place replacement here\\n                mat[i][j] = diag[i - j].top();\\n                // since we don\\'t need this value anymore, pop it out\\n                // so that next cell would get the smallest value\\n                diag[i - j].pop();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        // observation:\\n        // for each cell mat[i][j] in the same diagonal,\\n        // they will have the same value i - j\\n        \\n        // if the diagonal line is pointing to upper right direction, \\n        // then they will have the same value i + j (see https://leetcode.com/problems/diagonal-traverse/)\\n        \\n        // the idea is to use priority queue for each diagonal\\n        // as priority queue could sort it internally when a value is pushed / popped\\n        // we use greater<int> as we want the smallest go first\\n        map<int, priority_queue<int, vector<int>, greater<int>>> diag;\\n        // iterate each row\\n        for (int i = 0; i < n; i++) {\\n            // iterate each col\\n            for (int j = 0; j < m; j++) {\\n                // for each mat[i][j] \\n                // add it to corresponding priority queue\\n                diag[i - j].push(mat[i][j]);\\n            }\\n        }\\n        // iterate each row\\n        for (int i = 0; i < n; i++) {\\n            // iterate each col\\n            for (int j = 0; j < m; j++) {\\n                // diag[i - j].top() would return the smallest number in the current queue\\n                // we can just perform in-place replacement here\\n                mat[i][j] = diag[i - j].top();\\n                // since we don\\'t need this value anymore, pop it out\\n                // so that next cell would get the smallest value\\n                diag[i - j].pop();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1036100,
                "title": "c-simple-with-explanation",
                "content": "Its a simple sorting question.This is not optimal solution but a simple one.\\n\\nHere we are traversing through 1st row and 1st column to get all the diagnol elements , seperately. I wrote a SOLVE function where it takes the matrix, and stores all the diagonal elements in a vector and sort it seperately.And changes the matrix!!!!!!!!!\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(int i,int j,vector<vector<int>>& mat)\\n    {\\n        vector<int> hey;\\n        int ti=i,tj=j;\\n        while(ti<mat.size()&&tj<mat[0].size())\\n        {\\n            hey.push_back(mat[ti][tj]);ti++;tj++;\\n        }\\n        sort(hey.begin(),hey.end());\\n        for(auto x : hey)\\n        {\\n            mat[i][j]=x;i++;j++;\\n        }\\n    }\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        if(mat.size()==1||mat[0].size()==1) return mat;\\n        for(int i=0;i<mat[0].size();i++)\\n        {\\n            solve(0,i,mat);\\n        }\\n        for(int i=1;i<mat.size();i++)\\n        {\\n            solve(i,0,mat);\\n        }\\n        return mat;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void solve(int i,int j,vector<vector<int>>& mat)\\n    {\\n        vector<int> hey;\\n        int ti=i,tj=j;\\n        while(ti<mat.size()&&tj<mat[0].size())\\n        {\\n            hey.push_back(mat[ti][tj]);ti++;tj++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2494830,
                "title": "java-faster-than-100",
                "content": "```\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Sort the Matrix Diagonally.\\nMemory Usage: 48.4 MB, less than 30.56% of Java online submissions for Sort the Matrix Diagonally.\\n```\\nThis Approach uses the **Counting Sort** Algorithm to sort every diagonals in the matrix.\\n\\nFirst, let us pick the index of the bottom-left element of the matrix and store it as `(a,b)`.\\n```\\nint a = mat.length-1;\\nint b = 0;\\n```\\n<img src=\"https://assets.leetcode.com/users/images/275c6f24-8e78-4db2-8c96-60b2418a3cb7_1661675963.408419.png\" width=\"300\">\\n\\n\\\\\\nFrom that cell, we\\'ll move towards the top and then right to reach the top-right element of the matrix.\\n<img src=\"https://assets.leetcode.com/users/images/79a31cb5-42cf-4fc6-8a26-ccacefa109ae_1661676385.7083142.png\" width=\"300\">\\nWhile traversing through this path, we\\'ll call our sort function with the indexes of those elements in the path.\\n```\\nwhile(b < mat[0].length) {\\n\\tsort(mat, result, a, b);\\n\\tif (a < 1) {\\n\\t\\tb++;\\n\\t} else {\\n\\t\\ta--;\\n\\t}\\n}\\n```\\n\\nThe sort() function performs Counting sort on the diagonals\\nThe `count` array is used to hold the number of occurences of elements\\n```\\nint[] count = new int[101];\\nint i = a, j = b;\\n```\\nThe counts of the elements present along the diagonal starting from index i & j are stored in `count`.\\n<img src=\"https://assets.leetcode.com/users/images/c0802bfb-0383-419f-8ee4-094c8c5055dc_1661677217.6274393.png\" width=\"300\">\\n```\\nwhile(i < mat.length && j < mat[0].length) {\\n\\tcount[mat[i][j]]++;\\n\\ti++; \\n\\tj++;\\n}\\nsum(count);\\n```\\n\\nThe sum() function accumulates the sum value of previous elems in `count` array. Please look at the example below.\\n<img src=\"https://assets.leetcode.com/users/images/270ccd78-ea79-41a2-be87-890af2daaa7e_1661677752.4656022.png\" width=\"300\">\\n```\\npublic void sum(int[] count) {\\n\\tfor(int i = 1; i < count.length; i++) {\\n\\t\\tcount[i] = count[i] + count[i-1];\\n\\t}\\n}\\n```\\nFor Each Element in the diagonal, the value `inx` is accessed from the `count` using the element of `mat`. The `inx` is then decremented. This `inx` is added with the starting indices of the diagonal `(a,b)`, which is then used to insert the element into the `result` matrix\\n```\\n\\ti = a; j = b;\\n\\twhile(i < mat.length && j < mat[0].length) {\\n\\t\\tint inx = --count[mat[i][j]] ;\\n\\t\\tresult[a+inx][b+inx] = mat[i][j];\\n\\t\\ti++; j++;\\n\\t}\\n}\\n```\\n\\n\\n**The Complete code is here**\\u2728 \\n```\\nclass Solution {\\n    public void sum(int[] count) {\\n        for(int i = 1; i < count.length; i++) {\\n            count[i] = count[i] + count[i-1];\\n        }\\n    }\\n    \\n    public void sort(int[][] mat, int[][] res, int a, int b) {\\n        int[] count = new int[101];\\n        int i = a, j = b;\\n        while(i < mat.length && j < mat[0].length) {\\n            count[mat[i][j]]++;\\n            i++; j++;\\n        }\\n        sum(count);\\n        i = a; j = b;\\n        while(i < mat.length && j < mat[0].length) {\\n            int inx = --count[mat[i][j]] ;\\n            res[a+inx][b+inx] = mat[i][j];\\n            i++; j++;\\n        }\\n    }\\n    \\n    public int[][] diagonalSort(int[][] mat) {\\n        int[][] res = new int[mat.length][mat[0].length];\\n        \\n        int a = mat.length-1;\\n        int b = 0;\\n        while(b < mat[0].length) {\\n            sort(mat, res, a, b);\\n            if (a < 1) {\\n                b++;\\n            } else {\\n                a--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\nPlease do upvote if you find this helpful!\\nThank you! Have a great day! \\u2728\\n\\n<img src=\"https://c.tenor.com/nE7CE32ElmMAAAAC/leonardo-di-caprio-cheers.gif\" width=\"200\">",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nRuntime: 1 ms, faster than 100.00% of Java online submissions for Sort the Matrix Diagonally.\\nMemory Usage: 48.4 MB, less than 30.56% of Java online submissions for Sort the Matrix Diagonally.\\n```\n```\\nint a = mat.length-1;\\nint b = 0;\\n```\n```\\nwhile(b < mat[0].length) {\\n\\tsort(mat, result, a, b);\\n\\tif (a < 1) {\\n\\t\\tb++;\\n\\t} else {\\n\\t\\ta--;\\n\\t}\\n}\\n```\n```\\nint[] count = new int[101];\\nint i = a, j = b;\\n```\n```\\nwhile(i < mat.length && j < mat[0].length) {\\n\\tcount[mat[i][j]]++;\\n\\ti++; \\n\\tj++;\\n}\\nsum(count);\\n```\n```\\npublic void sum(int[] count) {\\n\\tfor(int i = 1; i < count.length; i++) {\\n\\t\\tcount[i] = count[i] + count[i-1];\\n\\t}\\n}\\n```\n```\\n\\ti = a; j = b;\\n\\twhile(i < mat.length && j < mat[0].length) {\\n\\t\\tint inx = --count[mat[i][j]] ;\\n\\t\\tresult[a+inx][b+inx] = mat[i][j];\\n\\t\\ti++; j++;\\n\\t}\\n}\\n```\n```\\nclass Solution {\\n    public void sum(int[] count) {\\n        for(int i = 1; i < count.length; i++) {\\n            count[i] = count[i] + count[i-1];\\n        }\\n    }\\n    \\n    public void sort(int[][] mat, int[][] res, int a, int b) {\\n        int[] count = new int[101];\\n        int i = a, j = b;\\n        while(i < mat.length && j < mat[0].length) {\\n            count[mat[i][j]]++;\\n            i++; j++;\\n        }\\n        sum(count);\\n        i = a; j = b;\\n        while(i < mat.length && j < mat[0].length) {\\n            int inx = --count[mat[i][j]] ;\\n            res[a+inx][b+inx] = mat[i][j];\\n            i++; j++;\\n        }\\n    }\\n    \\n    public int[][] diagonalSort(int[][] mat) {\\n        int[][] res = new int[mat.length][mat[0].length];\\n        \\n        int a = mat.length-1;\\n        int b = 0;\\n        while(b < mat[0].length) {\\n            sort(mat, res, a, b);\\n            if (a < 1) {\\n                b++;\\n            } else {\\n                a--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138063,
                "title": "java-simple-and-intuitive-priorityqueue-and-hashmap-sol-o-n-m-log-m",
                "content": "This Solution also works if it was not sorted at all\\n```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        HashMap<Integer, PriorityQueue<Integer>> hm = new HashMap<>();\\n        for(int i = 0; i<mat.length; i++) {\\n            for(int j=0; j<mat[0].length; j++) {\\n                PriorityQueue<Integer> pq = hm.getOrDefault(i-j, new PriorityQueue<>());\\n                pq.add(mat[i][j]);\\n                hm.put(i-j, pq);\\n            }\\n        }\\n        \\n        for(int i=0; i<mat.length; i++) {\\n            for(int j=0; j<mat[0].length; j++) {\\n                mat[i][j] = hm.get(i-j).poll();\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        HashMap<Integer, PriorityQueue<Integer>> hm = new HashMap<>();\\n        for(int i = 0; i<mat.length; i++) {\\n            for(int j=0; j<mat[0].length; j++) {\\n                PriorityQueue<Integer> pq = hm.getOrDefault(i-j, new PriorityQueue<>());\\n                pq.add(mat[i][j]);\\n                hm.put(i-j, pq);\\n            }\\n        }\\n        \\n        for(int i=0; i<mat.length; i++) {\\n            for(int j=0; j<mat[0].length; j++) {\\n                mat[i][j] = hm.get(i-j).poll();\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 920657,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        \\n        \\n        d = defaultdict(list)\\n        \\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                d[i-j].append(mat[i][j])\\n        \\n        for k in d.keys():\\n            d[k].sort()\\n        \\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                mat[i][j] = d[i-j].pop(0)\\n        return mat\\n",
                "solutionTags": [
                    "Python3",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        \\n        \\n        d = defaultdict(list)\\n        \\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                d[i-j].append(mat[i][j])\\n        \\n        for k in d.keys():\\n            d[k].sort()\\n        \\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                mat[i][j] = d[i-j].pop(0)\\n        return mat\\n",
                "codeTag": "Java"
            },
            {
                "id": 2213752,
                "title": "c-using-array-o-mn",
                "content": "***C++ Code***\\n\\n\\n\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int j, m=mat.size(), n=mat[0].size(), k, temp;\\n        vector<int>v; int l=1;\\n        for(int i=0; i<m; i++)\\n        {\\n            j=0; temp=i;\\n            while(i<m && j<n) v.push_back(mat[i++][j++]);\\n            sort(begin(v), end(v));\\n            k=0; i=temp; j=0;\\n            while(i<m && j<n)  mat[i++][j++]=v[k++];\\n            v.clear(); i=temp;\\n        }\\n        for(int i=1; i<n; i++)\\n        {\\n            j=0; temp=i;\\n            while(i<n && j<m) v.push_back(mat[j++][i++]);\\n            sort(begin(v), end(v));\\n            k=0; i=temp; j=0;\\n            while(i<n && j<m)  mat[j++][i++]=v[k++];\\n            v.clear(); i=temp;\\n        }\\n        return mat;\\n    }\\n\\t\\n\\t\\n\\t//Please upvote it       #happycoding",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "***C++ Code***\\n\\n\\n\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int j, m=mat.size(), n=mat[0].size(), k, temp;\\n        vector<int>v; int l=1;\\n        for(int i=0; i<m; i++)\\n        {\\n            j=0; temp=i;\\n            while(i<m && j<n) v.push_back(mat[i++][j++]);\\n            sort(begin(v), end(v));\\n            k=0; i=temp; j=0;\\n            while(i<m && j<n)  mat[i++][j++]=v[k++];\\n            v.clear(); i=temp;\\n        }\\n        for(int i=1; i<n; i++)\\n        {\\n            j=0; temp=i;\\n            while(i<n && j<m) v.push_back(mat[j++][i++]);\\n            sort(begin(v), end(v));\\n            k=0; i=temp; j=0;\\n            while(i<n && j<m)  mat[j++][i++]=v[k++];\\n            v.clear(); i=temp;\\n        }\\n        return mat;\\n    }\\n\\t\\n\\t\\n\\t//Please upvote it       #happycoding",
                "codeTag": "Unknown"
            },
            {
                "id": 2493947,
                "title": "sort-each-diagonal",
                "content": "Elements of the same diagonal have the same difference between row and column numbers, so you can easily make a list of diagonals. \\nAnd in order for the elements in these lists to be sorted, you can use a priority queue. \\nAfter compiling the list of diagonals, it remains to fill the matrix with sorted elements from the priority queues\\n\\n##### *Java*\\n```java\\npublic int[][] diagonalSort(int[][] mat) {\\n        Map<Integer, PriorityQueue<Integer>> diagonals = sortedDiagonals(mat);\\n\\n        for (int i = 0; i < mat.length; ++i)\\n            for (int j = 0; j < mat[0].length; ++j)\\n                mat[i][j] = diagonals.get(i - j).poll();\\n\\n        return mat;\\n    }\\n\\n    private Map<Integer, PriorityQueue<Integer>> sortedDiagonals(int[][] mat) {\\n        Map<Integer, PriorityQueue<Integer>> diagonals = new HashMap<>();\\n\\n        for (int i = 0; i < mat.length; ++i)\\n            for (int j = 0; j < mat[0].length; ++j)\\n                diagonals.computeIfAbsent(i - j, param -> new PriorityQueue<>()).add(mat[i][j]);\\n\\n        return diagonals;\\n    }\\n```\\n##### *C++*\\n```c++\\n\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> diagonals = sortedDiagonals(mat);\\n\\n        for (int i = 0; i < mat.size(); ++i)\\n            for (int j = 0; j < mat[0].size(); ++j) {\\n                mat[i][j] = diagonals[i - j].top(); \\n                diagonals[i - j].pop();\\n            }\\n\\n        return mat;\\n    }\\n        \\n\\nprivate:\\n    unordered_map<int, priority_queue<int, vector<int>, greater<int>>> sortedDiagonals(vector<vector<int>>& mat) {\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> diagonals;\\n\\n        for (int i = 0; i < mat.size(); ++i)\\n            for (int j = 0; j < mat[0].size(); ++j)\\n                diagonals[i - j].push(mat[i][j]);\\n\\n        return diagonals;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int[][] diagonalSort(int[][] mat) {\\n        Map<Integer, PriorityQueue<Integer>> diagonals = sortedDiagonals(mat);\\n\\n        for (int i = 0; i < mat.length; ++i)\\n            for (int j = 0; j < mat[0].length; ++j)\\n                mat[i][j] = diagonals.get(i - j).poll();\\n\\n        return mat;\\n    }\\n\\n    private Map<Integer, PriorityQueue<Integer>> sortedDiagonals(int[][] mat) {\\n        Map<Integer, PriorityQueue<Integer>> diagonals = new HashMap<>();\\n\\n        for (int i = 0; i < mat.length; ++i)\\n            for (int j = 0; j < mat[0].length; ++j)\\n                diagonals.computeIfAbsent(i - j, param -> new PriorityQueue<>()).add(mat[i][j]);\\n\\n        return diagonals;\\n    }\\n```\n```c++\\n\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> diagonals = sortedDiagonals(mat);\\n\\n        for (int i = 0; i < mat.size(); ++i)\\n            for (int j = 0; j < mat[0].size(); ++j) {\\n                mat[i][j] = diagonals[i - j].top(); \\n                diagonals[i - j].pop();\\n            }\\n\\n        return mat;\\n    }\\n        \\n\\nprivate:\\n    unordered_map<int, priority_queue<int, vector<int>, greater<int>>> sortedDiagonals(vector<vector<int>>& mat) {\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> diagonals;\\n\\n        for (int i = 0; i < mat.size(); ++i)\\n            for (int j = 0; j < mat[0].size(); ++j)\\n                diagonals[i - j].push(mat[i][j]);\\n\\n        return diagonals;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2493834,
                "title": "c-best-easy-explanation-using-priority-queue-8ms-95-faster",
                "content": "# Observation\\n\\nThe first observation here is that -: \\n* Every diagonal has it\\'s has it\\'s own id and that id = difference of indices of elements present on that diagonal.\\nsuppose\\n\\n![image](https://assets.leetcode.com/users/images/e9158b2d-4f62-4170-9843-86bc83543f94_1661665275.535894.png)\\n\\n* For the lower left most diagonal starting from the cell [2,0] the difference **i-j is 2**  for elements at ***[2,0]***\\n* similarly for the topmost and the principal diaognal starting from [0,0] the difference is constant ie. **i-j =0** for elements at ***[0,0], [1,1], [2,2]***\\n\\n# Implementation\\nNow the things become more easy  as all you need to do is that -: \\n\\n* Make a unordered_map, in which the **keys** will be the **id of the particular diagonal** and the  **map_value** will be a **min-priority queue** of the elements present on that diagonal.\\n* Traverse the whole matrix push the value of elements of particular id in the **min-priority queue.**\\n\\nThe easiest way to do that is \\n```\\nmap[i-j].push(matrix[i][j]) \\n```\\nThe above line takes care of everything as the element with the particular diagonal id goes in the min-priority queue.\\n\\nNow for placing the elements back again on their required position-:\\n* you again need to traverse the matrix and for the particular [i][j] pop the element from the priority queue present at the map position i\\n``` \\nmatrix[i][j]=map[i-j].top();  // storing the minimum-element at the particular index in the matrix \\nmap[i-j].pop();  // popping out the minimum element from the priority queue after above operation\\n```\\n# Time Complexity\\nThe ***time complexity*** of the above approach will **O ( M * N * log(D) )**\\nWhere \\nM= Number of Rows,\\nN= Number of Columns,\\nD = length of the particular Diagonal as every diagonal has different number of elements present in it\\n\\nThe ***space complexity*** will be **O ( M * N )** as we are making a map to store every element in their respective priority queue.\\n# Code\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat)\\n    {\\n        int row=mat.size();\\n        int col=mat[0].size();\\n        unordered_map<int,priority_queue<int,vector<int>,greater<int>>>mp;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                mp[i-j].push(mat[i][j]);\\n            }\\n        }\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                mat[i][j]=mp[i-j].top();\\n                mp[i-j].pop();\\n            }\\n        }\\n        return mat ;     \\n    }\\n};\\n```\\n\\nPlease upvote and share.",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nmap[i-j].push(matrix[i][j]) \\n```\n``` \\nmatrix[i][j]=map[i-j].top();  // storing the minimum-element at the particular index in the matrix \\nmap[i-j].pop();  // popping out the minimum element from the priority queue after above operation\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat)\\n    {\\n        int row=mat.size();\\n        int col=mat[0].size();\\n        unordered_map<int,priority_queue<int,vector<int>,greater<int>>>mp;\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                mp[i-j].push(mat[i][j]);\\n            }\\n        }\\n        for(int i=0;i<row;i++)\\n        {\\n            for(int j=0;j<col;j++)\\n            {\\n                mat[i][j]=mp[i-j].top();\\n                mp[i-j].pop();\\n            }\\n        }\\n        return mat ;     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493747,
                "title": "c-beautiful-code-and-easy-understanding-solution",
                "content": "**Intiution:**\\nWe can take out each diagonal one by one copy all the contents of the diagonal elements inside a vector and then after sorting it we can put it back in original places.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int r = mat.size();\\n        int c = mat[0].size();\\n        int rowIndex = 0; // row Index for diagonal\\n        int colIndex; // col Index for diagonal\\n        int numberOfDiagonals = r+c-1;\\n            \\n        for(int i=1;i<=numberOfDiagonals;++i){\\n            vector<int> diagonal; // vector for storing diagonal elements\\n            \\n            /*\\n              All the first c diagonals have common starting rowIndex = 0 \\n              Only colIndex changes\\n            */\\n            if(i<=c){\\n                colIndex = c-i;\\n            }\\n            // After that starting colIndex is constant and rowIndex changes\\n            else{\\n                rowIndex++;\\n                colIndex = 0;\\n            }\\n            \\n            for(int i=rowIndex,j=colIndex;i<r && j<c;++i,++j){\\n                diagonal.push_back(mat[i][j]);\\n            }\\n            \\n            sort(diagonal.begin(),diagonal.end());\\n            \\n            for(int i=rowIndex,j=colIndex,k=0;i<r && j<c;++i,++j,++k){\\n                mat[i][j] = diagonal[k];\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```\\n\\n**Time Complexity = O((D)ClogC)** *where D = R+C-1(Number of Diagonals), C = Columns and R = Rows in a matrix*\\n**Space Complexity = O(RC)** *we are storing all the elements of matrix once*\\n\\n**Do Upvote if it helps**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int r = mat.size();\\n        int c = mat[0].size();\\n        int rowIndex = 0; // row Index for diagonal\\n        int colIndex; // col Index for diagonal\\n        int numberOfDiagonals = r+c-1;\\n            \\n        for(int i=1;i<=numberOfDiagonals;++i){\\n            vector<int> diagonal; // vector for storing diagonal elements\\n            \\n            /*\\n              All the first c diagonals have common starting rowIndex = 0 \\n              Only colIndex changes\\n            */\\n            if(i<=c){\\n                colIndex = c-i;\\n            }\\n            // After that starting colIndex is constant and rowIndex changes\\n            else{\\n                rowIndex++;\\n                colIndex = 0;\\n            }\\n            \\n            for(int i=rowIndex,j=colIndex;i<r && j<c;++i,++j){\\n                diagonal.push_back(mat[i][j]);\\n            }\\n            \\n            sort(diagonal.begin(),diagonal.end());\\n            \\n            for(int i=rowIndex,j=colIndex,k=0;i<r && j<c;++i,++j,++k){\\n                mat[i][j] = diagonal[k];\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499481,
                "title": "short-easy-explanation-2-approaches-c-beginner-friendly",
                "content": "![image](https://assets.leetcode.com/users/images/81f84218-e89d-4a4d-b254-d623fba3b14a_1633199103.9997878.png)\\n\\n**Using min priority queue\\nTime:O(MNlog(N), where N = diagonal = min(M, N)\\nSpace: O(MN)**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        //Each element in a diagonal has the same i-j difference. Store it in a map{i-j , all elements}.\\n\\t\\t//store elements in a  min priority queue so they get sorted.\\n        unordered_map<int,priority_queue<int,vector<int>,greater<int>>> map;\\n        int m=mat.size(),n=mat[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                map[i-j].push(mat[i][j]);\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n\\t\\t\\t    //adding values from the map into the matrix, and removing them from map.\\n                mat[i][j]=map[i-j].top();\\n                map[i-j].pop();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```\\n**copy the elements and sort them\\nTime:O(M*N*log(N), where N = diagonal = min(M, N)\\nSpace: O(N)**\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>>& mat,int row,int col){\\n        vector<int> vec;\\n        int r=row,c=col;\\n\\t\\t//storing the diagonal elements in vec\\n        while(r < mat.size() && c < mat[0].size()){\\n            vec.push_back(mat[r++][c++]);\\n        }\\n\\t\\t//sorting the diagonal elements\\n        sort(vec.begin(),vec.end());\\n\\t\\t//storing back into the matrix\\n        int i=0;\\n        while(row < mat.size() && col < mat[0].size()){\\n            mat[row++][col++]=vec[i++];\\n        }\\n    }\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size();\\n\\t\\t//Traversing diagonals of the matrix which starts from row 0 \\n        for(int col=0;col<n;col++){\\n            helper(mat,0,col);\\n        }\\n\\t\\t//Traversing diagonals of the matrix which starts from col 0 \\n        for(int row=1;row<m;row++){\\n            helper(mat,row,0);\\n        }\\n        return mat;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote** and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        //Each element in a diagonal has the same i-j difference. Store it in a map{i-j , all elements}.\\n\\t\\t//store elements in a  min priority queue so they get sorted.\\n        unordered_map<int,priority_queue<int,vector<int>,greater<int>>> map;\\n        int m=mat.size(),n=mat[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                map[i-j].push(mat[i][j]);\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n\\t\\t\\t    //adding values from the map into the matrix, and removing them from map.\\n                mat[i][j]=map[i-j].top();\\n                map[i-j].pop();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>>& mat,int row,int col){\\n        vector<int> vec;\\n        int r=row,c=col;\\n\\t\\t//storing the diagonal elements in vec\\n        while(r < mat.size() && c < mat[0].size()){\\n            vec.push_back(mat[r++][c++]);\\n        }\\n\\t\\t//sorting the diagonal elements\\n        sort(vec.begin(),vec.end());\\n\\t\\t//storing back into the matrix\\n        int i=0;\\n        while(row < mat.size() && col < mat[0].size()){\\n            mat[row++][col++]=vec[i++];\\n        }\\n    }\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size();\\n\\t\\t//Traversing diagonals of the matrix which starts from row 0 \\n        for(int col=0;col<n;col++){\\n            helper(mat,0,col);\\n        }\\n\\t\\t//Traversing diagonals of the matrix which starts from col 0 \\n        for(int row=1;row<m;row++){\\n            helper(mat,row,0);\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494052,
                "title": "python-elegant-short-two-solutions-hashmap-generators",
                "content": "```\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n*m*log(max(n,m))\\n\\tMemory: O(n*m)\\n\\t\"\"\"\\n\\n\\tdef diagonalSort(self, matrix: List[List[int]]) -> List[List[int]]:\\n\\t\\tn, m = len(matrix), len(matrix[0])\\n\\t\\tdiags = defaultdict(list)\\n\\n\\t\\tfor i in range(n):\\n\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\tdiags[i - j].append(matrix[i][j])\\n\\n\\t\\tfor k in diags:\\n\\t\\t\\tdiags[k].sort(reverse=True)\\n\\n\\t\\tfor i in range(n):\\n\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\tmatrix[i][j] = diags[i - j].pop()\\n\\n\\t\\treturn matrix\\n```\\n\\n```\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n*m*log(max(n,m))\\n\\tMemory: O(n + m)\\n\\t\"\"\"\\n\\n\\tdef diagonalSort(self, matrix: List[List[int]]) -> List[List[int]]:\\n\\t\\tn, m = len(matrix), len(matrix[0])\\n\\t\\tdiagonals = [(i, 0) for i in range(n - 1, 0, -1)] + [(0, j) for j in range(m)]\\n\\n\\t\\tfor row, col in diagonals:\\n\\t\\t\\tfor val in sorted(self._diagonal_generator(row, col, matrix)):\\n\\t\\t\\t\\tmatrix[row][col] = val\\n\\t\\t\\t\\trow += 1\\n\\t\\t\\t\\tcol += 1\\n\\n\\t\\treturn matrix\\n\\n\\t@staticmethod\\n\\tdef _diagonal_generator(r: int, c: int, matrix: List[List[int]]):\\n\\t\\twhile r < len(matrix) and c < len(matrix[0]):\\n\\t\\t\\tyield matrix[r][c]\\n\\t\\t\\tr += 1\\n\\t\\t\\tc += 1\\n```\\n\\nIf you like this solutions remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n*m*log(max(n,m))\\n\\tMemory: O(n*m)\\n\\t\"\"\"\\n\\n\\tdef diagonalSort(self, matrix: List[List[int]]) -> List[List[int]]:\\n\\t\\tn, m = len(matrix), len(matrix[0])\\n\\t\\tdiags = defaultdict(list)\\n\\n\\t\\tfor i in range(n):\\n\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\tdiags[i - j].append(matrix[i][j])\\n\\n\\t\\tfor k in diags:\\n\\t\\t\\tdiags[k].sort(reverse=True)\\n\\n\\t\\tfor i in range(n):\\n\\t\\t\\tfor j in range(m):\\n\\t\\t\\t\\tmatrix[i][j] = diags[i - j].pop()\\n\\n\\t\\treturn matrix\\n```\n```\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n*m*log(max(n,m))\\n\\tMemory: O(n + m)\\n\\t\"\"\"\\n\\n\\tdef diagonalSort(self, matrix: List[List[int]]) -> List[List[int]]:\\n\\t\\tn, m = len(matrix), len(matrix[0])\\n\\t\\tdiagonals = [(i, 0) for i in range(n - 1, 0, -1)] + [(0, j) for j in range(m)]\\n\\n\\t\\tfor row, col in diagonals:\\n\\t\\t\\tfor val in sorted(self._diagonal_generator(row, col, matrix)):\\n\\t\\t\\t\\tmatrix[row][col] = val\\n\\t\\t\\t\\trow += 1\\n\\t\\t\\t\\tcol += 1\\n\\n\\t\\treturn matrix\\n\\n\\t@staticmethod\\n\\tdef _diagonal_generator(r: int, c: int, matrix: List[List[int]]):\\n\\t\\twhile r < len(matrix) and c < len(matrix[0]):\\n\\t\\t\\tyield matrix[r][c]\\n\\t\\t\\tr += 1\\n\\t\\t\\tc += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492321,
                "title": "daily-leetcoding-challenge-august-day-28",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sort-the-matrix-diagonally/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Hash Table of Heaps\n\n  \n**Approach 2:** Sort Diagonals One by One Using Heap\n\n  \n**Approach 3:** Sort Diagonals One by One Using Counting Sort\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/sort-the-matrix-diagonally/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1488654,
                "title": "java-0ms-solution-using-countsort-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        \\n        for(int i=0;i<mat[0].length;i++)\\n            countSort(mat,0,i);\\n        \\n        for(int i=1;i<mat.length;i++)\\n            countSort(mat,i,0);\\n        \\n        return mat;\\n        \\n    }\\n    void countSort(int[][] mat,int r,int c)\\n    {\\n        int[] map = new int[101];\\n        int rows = mat.length,cols=mat[0].length;\\n        int i=r,j=c;\\n        \\n        while(i<rows && j<cols)\\n        {\\n            map[mat[i][j]]++;\\n            i++;j++;\\n        }\\n        i=r;j=c;\\n        for(int k=1;k<101;k++)\\n        {\\n            while(map[k] > 0)\\n            {\\n                mat[i][j] = k;\\n                map[k]--;\\n                i++;j++;\\n            }\\n        }\\n        \\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        \\n        for(int i=0;i<mat[0].length;i++)\\n            countSort(mat,0,i);\\n        \\n        for(int i=1;i<mat.length;i++)\\n            countSort(mat,i,0);\\n        \\n        return mat;\\n        \\n    }\\n    void countSort(int[][] mat,int r,int c)\\n    {\\n        int[] map = new int[101];\\n        int rows = mat.length,cols=mat[0].length;\\n        int i=r,j=c;\\n        \\n        while(i<rows && j<cols)\\n        {\\n            map[mat[i][j]]++;\\n            i++;j++;\\n        }\\n        i=r;j=c;\\n        for(int k=1;k<101;k++)\\n        {\\n            while(map[k] > 0)\\n            {\\n                mat[i][j] = k;\\n                map[k]--;\\n                i++;j++;\\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030825,
                "title": "python-straightforward-create-diagonal-function",
                "content": "**Simple and easy python3 solution**\\n```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        def diagonal(i, j):\\n            order, temp = [], []\\n            while i < len(mat) and j < len(mat[0]):\\n                order.append((i, j))\\n                temp.append(mat[i][j])\\n                i += 1\\n                j += 1\\n            temp.sort()\\n            for i, o in enumerate(order):\\n                mat[o[0]][o[1]] = temp[i]\\n        for i in range(len(mat)):\\n            diagonal(i, 0)\\n        for i in range(1, len(mat[0])):\\n            diagonal(0, i)\\n        return mat\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        def diagonal(i, j):\\n            order, temp = [], []\\n            while i < len(mat) and j < len(mat[0]):\\n                order.append((i, j))\\n                temp.append(mat[i][j])\\n                i += 1\\n                j += 1\\n            temp.sort()\\n            for i, o in enumerate(order):\\n                mat[o[0]][o[1]] = temp[i]\\n        for i in range(len(mat)):\\n            diagonal(i, 0)\\n        for i in range(1, len(mat[0])):\\n            diagonal(0, i)\\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565583,
                "title": "python-detailed-explanation-basic-python",
                "content": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        \\n        xl, yl = len(mat), len(mat[0])\\n        t = [ [] for i in range( xl+yl ) ]\\n        \\n        for i in range(xl):\\n            for j in range(yl):\\n                t[i - j].append(mat[i][j])\\n                \\n        for l in t:\\n            l.sort(reverse=True)\\n\\n        for i in range(xl):\\n            for j in range(yl):\\n                mat[i][j] = t[i-j].pop()\\n                \\n        return mat\\n```\\n\\nThis code is probably neither the most efficient nor most elegant, but it\\'s using basic python and easy to follow. You can use it as a baseline and add more tuning on top.\\n\\nOk, step by step.\\n\\nFirst, we determine dimentions of the matrix:\\n```\\n        xl, yl = len(mat), len(mat[0])\\n```\\n\\nThe next step - we want to store all diagonal lines into a new temp array `t`. For now, we just create a placeholder array. Let\\'s say our matrix is `2x3`. The number of diagonal lines will be `2+3-1`. More generally it will be `xl+yl-1`.  (basically we need a line for each row and each column, but the line starting at (0,0) will be counted twice - for row 0 and for column 0, that\\'s why we need to subtract 1 to address that double counting). Since `range()` skips the last element, we can use:\\n\\n```\\n        t = [ [] for i in range( xl+yl ) ]\\n```\\n\\nOk, now we actually populate `t`. We scan the original matrix `mat` and use `i-j` to decide which diagonal line it should belong too. This is one of the hints - for all elements on each diagonal line `i-j` is the same value unique for each diagonal.\\n\\n```\\n        for i in range(xl):\\n            for j in range(yl):\\n                t[i - j].append(mat[i][j])\\n```\\n\\nThen we sort each diagonal ine:\\n\\n```\\n        for l in t:\\n            l.sort(reverse=True)\\n```\\n\\nWhy do we need `reverse=True`? this is a common trick actually ... at some point will need to take elements from each line one by one from low to high. If we do it from the beginning of the list, we would need to use some pointer to keep track of what the current element is. Managing all those pointers is a hassle, so we can avoid it by sorting in reverse and then simply using `pop()` to get the last element without using pointers.\\n\\nOk, now we do effectively the first loop in reverse and put the sorted elements back into the original `mat`:\\n\\n```\\n        for i in range(xl):\\n            for j in range(yl):\\n                mat[i][j] = t[i-j].pop()\\n```\\n\\nAnd, finally, return the result:\\n\\n```\\n        return mat\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        \\n        xl, yl = len(mat), len(mat[0])\\n        t = [ [] for i in range( xl+yl ) ]\\n        \\n        for i in range(xl):\\n            for j in range(yl):\\n                t[i - j].append(mat[i][j])\\n                \\n        for l in t:\\n            l.sort(reverse=True)\\n\\n        for i in range(xl):\\n            for j in range(yl):\\n                mat[i][j] = t[i-j].pop()\\n                \\n        return mat\\n```\n```\\n        xl, yl = len(mat), len(mat[0])\\n```\n```\\n        t = [ [] for i in range( xl+yl ) ]\\n```\n```\\n        for i in range(xl):\\n            for j in range(yl):\\n                t[i - j].append(mat[i][j])\\n```\n```\\n        for l in t:\\n            l.sort(reverse=True)\\n```\n```\\n        for i in range(xl):\\n            for j in range(yl):\\n                mat[i][j] = t[i-j].pop()\\n```\n```\\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495735,
                "title": "simple-fast-beginners-friendly",
                "content": "![image](https://assets.leetcode.com/users/images/e20ffa6b-ef67-4a9e-a2bc-9ca14bfb96fa_1661691310.050163.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        \\n        int rows = mat.size(); // Will give us the no. of rows in matrix\\n        int cols = mat[0].size(); // Will give the no. of columns in matrix\\n    \\n            \\n        // The Matrix can be divided into two halves along the diagonal\\n        // The Upper right half and the Lower left half\\n         \\n        // For traversing each element in upper right half\\n        for(int i=0; i<cols; i++){\\n            \\n            int tempRow = 0; // The tempRow will start at 0 in every iteration\\n            int tempCol = i; // The tempCol will start at i in every iteration\\n            \\n            vector<int> temp; // Create a temporary vector to store diagonal values\\n            \\n            // Starting at (0,0) to move to next diagonal element we have to\\n            // increment both tempRow and tempCol by 1\\n            \\n            while(tempRow<rows && tempCol<cols){\\n                \\n                temp.push_back(mat[tempRow][tempCol]); // Storing that diagonal element in temp vector.\\n                \\n                tempRow++;\\n                tempCol++;\\n            }\\n            \\n            sort(temp.begin(), temp.end()); // Sorting that diagonal\\n            \\n            // Now we will store the sorted elements at new postions in mat matrix\\n            \\n            tempRow = 0;\\n            tempCol = i;\\n            \\n            for(int j=0; j<temp.size(); j++){\\n                \\n                mat[tempRow][tempCol] = temp[j]; //Storing the sorted element \\n                    \\n                tempRow++;\\n                tempCol++;\\n            }\\n        }\\n        \\n        // Upper Right half is now sorted\\n        \\n        // For traversing each element in lower left half\\n        for(int i=1; i<rows; i++){\\n            \\n            int tempRow = i; // The tempRow will start at i in every iteration\\n            int tempCol = 0; // The tempCol will start at 0 in every iteration\\n            \\n            vector<int>temp; // Create a temporary vector to store diagonal values\\n            \\n            // Starting at (1,0) to move to next diagonal element we have to\\n            // increment both tempRow and tempCol by 1\\n            \\n            while(tempRow<rows && tempCol<cols){\\n                \\n                temp.push_back(mat[tempRow][tempCol]); // Storing that diagonal element in temp vector.\\n                \\n                tempRow++;\\n                tempCol++;\\n            }\\n            \\n            sort(temp.begin(), temp.end()); // Sorting that diagonal\\n            \\n            // Now we will store the sorted elements at new postions in mat Matrix\\n            \\n            tempRow = i;\\n            tempCol = 0;\\n            \\n            for(int j=0; j<temp.size(); j++){\\n                \\n                mat[tempRow][tempCol] = temp[j]; // Storing the sorted element\\n                    \\n                tempRow++;\\n                tempCol++;\\n            }\\n        }\\n        \\n        return mat; // Returning the sorted matrix! Congratulations!\\n        \\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/b86bb491-10ef-4492-8b40-fe74bcc35b1d_1661690250.4648864.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        \\n        int rows = mat.size(); // Will give us the no. of rows in matrix\\n        int cols = mat[0].size(); // Will give the no. of columns in matrix\\n    \\n            \\n        // The Matrix can be divided into two halves along the diagonal\\n        // The Upper right half and the Lower left half\\n         \\n        // For traversing each element in upper right half\\n        for(int i=0; i<cols; i++){\\n            \\n            int tempRow = 0; // The tempRow will start at 0 in every iteration\\n            int tempCol = i; // The tempCol will start at i in every iteration\\n            \\n            vector<int> temp; // Create a temporary vector to store diagonal values\\n            \\n            // Starting at (0,0) to move to next diagonal element we have to\\n            // increment both tempRow and tempCol by 1\\n            \\n            while(tempRow<rows && tempCol<cols){\\n                \\n                temp.push_back(mat[tempRow][tempCol]); // Storing that diagonal element in temp vector.\\n                \\n                tempRow++;\\n                tempCol++;\\n            }\\n            \\n            sort(temp.begin(), temp.end()); // Sorting that diagonal\\n            \\n            // Now we will store the sorted elements at new postions in mat matrix\\n            \\n            tempRow = 0;\\n            tempCol = i;\\n            \\n            for(int j=0; j<temp.size(); j++){\\n                \\n                mat[tempRow][tempCol] = temp[j]; //Storing the sorted element \\n                    \\n                tempRow++;\\n                tempCol++;\\n            }\\n        }\\n        \\n        // Upper Right half is now sorted\\n        \\n        // For traversing each element in lower left half\\n        for(int i=1; i<rows; i++){\\n            \\n            int tempRow = i; // The tempRow will start at i in every iteration\\n            int tempCol = 0; // The tempCol will start at 0 in every iteration\\n            \\n            vector<int>temp; // Create a temporary vector to store diagonal values\\n            \\n            // Starting at (1,0) to move to next diagonal element we have to\\n            // increment both tempRow and tempCol by 1\\n            \\n            while(tempRow<rows && tempCol<cols){\\n                \\n                temp.push_back(mat[tempRow][tempCol]); // Storing that diagonal element in temp vector.\\n                \\n                tempRow++;\\n                tempCol++;\\n            }\\n            \\n            sort(temp.begin(), temp.end()); // Sorting that diagonal\\n            \\n            // Now we will store the sorted elements at new postions in mat Matrix\\n            \\n            tempRow = i;\\n            tempCol = 0;\\n            \\n            for(int j=0; j<temp.size(); j++){\\n                \\n                mat[tempRow][tempCol] = temp[j]; // Storing the sorted element\\n                    \\n                tempRow++;\\n                tempCol++;\\n            }\\n        }\\n        \\n        return mat; // Returning the sorted matrix! Congratulations!\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493779,
                "title": "c-easy-vector-98",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {    \\n        int i,j,n,m,k,l;\\n        n = mat.size();\\n        m=mat[0].size();\\n        j=n-1,i=0;\\n        for(j=m-1;j>=0;j--)\\n        {\\n            vector<int> a;\\n            k=i; l=j;\\n            while(k<n && l<m)\\n            { \\n               a.push_back(mat[k][l]); \\n                l++;k++;}\\n            sort(a.begin(),a.end());\\n            k=i;l=j;\\n            int o=0;\\n            while(k<n &&l<m && o<a.size())\\n            { mat[k][l] = a[o++]; l++;k++;}\\n        }\\n        j=0;\\n         for(i=1;i<n;i++)\\n        {\\n            vector<int> a;\\n            k=i; l=j;\\n            while(k<n && l<m)\\n            { \\n               a.push_back(mat[k][l]); \\n                l++;k++;}\\n            sort(a.begin(),a.end());\\n            k=i;l=j;\\n            int o=0;\\n            while(k<n &&l<m && o<a.size())\\n            { mat[k][l] = a[o++]; l++;k++;}\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {    \\n        int i,j,n,m,k,l;\\n        n = mat.size();\\n        m=mat[0].size();\\n        j=n-1,i=0;\\n        for(j=m-1;j>=0;j--)\\n        {\\n            vector<int> a;\\n            k=i; l=j;\\n            while(k<n && l<m)\\n            { \\n               a.push_back(mat[k][l]); \\n                l++;k++;}\\n            sort(a.begin(),a.end());\\n            k=i;l=j;\\n            int o=0;\\n            while(k<n &&l<m && o<a.size())\\n            { mat[k][l] = a[o++]; l++;k++;}\\n        }\\n        j=0;\\n         for(i=1;i<n;i++)\\n        {\\n            vector<int> a;\\n            k=i; l=j;\\n            while(k<n && l<m)\\n            { \\n               a.push_back(mat[k][l]); \\n                l++;k++;}\\n            sort(a.begin(),a.end());\\n            k=i;l=j;\\n            int o=0;\\n            while(k<n &&l<m && o<a.size())\\n            { mat[k][l] = a[o++]; l++;k++;}\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031456,
                "title": "sort-and-priorityqueue-solution",
                "content": "class Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n\\t\\t        Map<Integer, PriorityQueue<Integer>> map = new HashMap<Integer, PriorityQueue<Integer>>();\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(!map.containsKey(i-j)) map.put(i-j, new PriorityQueue<Integer>()); \\n                map.get(i-j).add(mat[i][j]);\\n            }\\n        }\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                mat[i][j] = map.get(i-j).poll();\\n            }\\n        }        \\n        return mat;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n\\t\\t        Map<Integer, PriorityQueue<Integer>> map = new HashMap<Integer, PriorityQueue<Integer>>();\\n        \\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(!map.containsKey(i-j)) map.put(i-j, new PriorityQueue<Integer>()); \\n                map.get(i-j).add(mat[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1031280,
                "title": "c-concise-4ms",
                "content": "Code for Diagonal traversal.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int x = n;\\n        int y = 0;\\n        int flag = true;\\n        while(x != 0 || y != m-1){\\n            int i = x > 0 ? --x : x;\\n            int j = i == 0 && !flag ? ++y : 0;\\n            while(i < n && j < m){\\n                cout<<mat[j++][i++];\\n            }\\n            flag = x > 0 ? true : false;\\n            cout<<endl;\\n        }\\n        return {};\\n    }\\n};\\n```\\nBuilding up on diagonal traversal:\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int x = n;\\n        int y = 0;\\n        int flag = true;\\n        while(x != 0 || y != m-1){\\n            int i = x > 0 ? --x : x;\\n            int j = i == 0 && !flag ? ++y : 0;\\n            vector<int> dum; //vector to store diagonal elements\\n            int d1 = i;\\n            int d2 = j;\\n            while(i < n && j < m){\\n                dum.push_back(mat[j++][i++]);\\n            }\\n            sort(dum.begin(), dum.end());\\n            int c = 0;\\n            while(d1 < n && d2 < m){\\n                mat[d2++][d1++] = dum[c++];\\n            }\\n            flag = x > 0 ? true : false;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int x = n;\\n        int y = 0;\\n        int flag = true;\\n        while(x != 0 || y != m-1){\\n            int i = x > 0 ? --x : x;\\n            int j = i == 0 && !flag ? ++y : 0;\\n            while(i < n && j < m){\\n                cout<<mat[j++][i++];\\n            }\\n            flag = x > 0 ? true : false;\\n            cout<<endl;\\n        }\\n        return {};\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int x = n;\\n        int y = 0;\\n        int flag = true;\\n        while(x != 0 || y != m-1){\\n            int i = x > 0 ? --x : x;\\n            int j = i == 0 && !flag ? ++y : 0;\\n            vector<int> dum; //vector to store diagonal elements\\n            int d1 = i;\\n            int d2 = j;\\n            while(i < n && j < m){\\n                dum.push_back(mat[j++][i++]);\\n            }\\n            sort(dum.begin(), dum.end());\\n            int c = 0;\\n            while(d1 < n && d2 < m){\\n                mat[d2++][d1++] = dum[c++];\\n            }\\n            flag = x > 0 ? true : false;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 945353,
                "title": "java-fast-easy-solution",
                "content": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        for(int k = n-1; k >= 0; k--){\\n            List<Integer> list = new ArrayList<Integer>();\\n            int j = k;\\n            for(int i = 0; i <= m-1; i++){\\n                list.add(mat[i][j]);\\n                j++;\\n                if(j > n-1){\\n                    break;\\n                }\\n            }\\n            Collections.sort(list);\\n            int i = 0;\\n            j = k;\\n            for(Integer listItem: list){\\n                mat[i][j] = listItem;\\n                i++;\\n                j++;\\n                if(i > m-1 || j > n-1){\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        for(int k = 0; k <= m-1; k++){\\n            List<Integer> list = new ArrayList<Integer>();\\n            int i = k;\\n            for(int j = 0; j <= n-1; j++){\\n                list.add(mat[i][j]);\\n                i++;\\n                if(i > m-1){\\n                    break;\\n                }\\n            }\\n            Collections.sort(list);\\n            i = k;\\n            int j = 0;\\n            for(Integer listItem: list){\\n                mat[i][j] = listItem;\\n                i++;\\n                j++;\\n                if(i > m-1 || j > n-1){\\n                    break;\\n                }\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        \\n        for(int k = n-1; k >= 0; k--){\\n            List<Integer> list = new ArrayList<Integer>();\\n            int j = k;\\n            for(int i = 0; i <= m-1; i++){\\n                list.add(mat[i][j]);\\n                j++;\\n                if(j > n-1){\\n                    break;\\n                }\\n            }\\n            Collections.sort(list);\\n            int i = 0;\\n            j = k;\\n            for(Integer listItem: list){\\n                mat[i][j] = listItem;\\n                i++;\\n                j++;\\n                if(i > m-1 || j > n-1){\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        for(int k = 0; k <= m-1; k++){\\n            List<Integer> list = new ArrayList<Integer>();\\n            int i = k;\\n            for(int j = 0; j <= n-1; j++){\\n                list.add(mat[i][j]);\\n                i++;\\n                if(i > m-1){\\n                    break;\\n                }\\n            }\\n            Collections.sort(list);\\n            i = k;\\n            int j = 0;\\n            for(Integer listItem: list){\\n                mat[i][j] = listItem;\\n                i++;\\n                j++;\\n                if(i > m-1 || j > n-1){\\n                    break;\\n                }\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 530124,
                "title": "golang-inplace",
                "content": "```\\nimport \"sort\"\\n\\nfunc diagonalSort(mat [][]int) [][]int {\\n    for r:=0; r<len(mat); r++ {\\n        sort.Sort(&diag{mat, r,0})\\n    }\\n    for c:=1; c< len(mat[0]); c++{\\n        sort.Sort(&diag{mat, 0,c})\\n    }\\n    return mat\\n}\\n\\n// diagonal starting at r,c\\ntype diag struct {\\n    a [][]int\\n    r,c int\\n}\\n\\nfunc (d *diag)Less(i,j int)bool {\\n    return d.a[d.r+i][d.c+i] < d.a[d.r+j][d.c+j]\\n}\\n\\nfunc (d *diag)Swap(i,j int) {\\n    d.a[d.r+i][d.c+i], d.a[d.r+j][d.c+j] = d.a[d.r+j][d.c+j], d.a[d.r+i][d.c+i]\\n}\\n\\nfunc (d *diag)Len()int{\\n    dr := len(d.a) - d.r\\n    dc := len(d.a[0]) - d.c\\n    if dr<dc {\\n        return dr\\n    }\\n    return dc\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport \"sort\"\\n\\nfunc diagonalSort(mat [][]int) [][]int {\\n    for r:=0; r<len(mat); r++ {\\n        sort.Sort(&diag{mat, r,0})\\n    }\\n    for c:=1; c< len(mat[0]); c++{\\n        sort.Sort(&diag{mat, 0,c})\\n    }\\n    return mat\\n}\\n\\n// diagonal starting at r,c\\ntype diag struct {\\n    a [][]int\\n    r,c int\\n}\\n\\nfunc (d *diag)Less(i,j int)bool {\\n    return d.a[d.r+i][d.c+i] < d.a[d.r+j][d.c+j]\\n}\\n\\nfunc (d *diag)Swap(i,j int) {\\n    d.a[d.r+i][d.c+i], d.a[d.r+j][d.c+j] = d.a[d.r+j][d.c+j], d.a[d.r+i][d.c+i]\\n}\\n\\nfunc (d *diag)Len()int{\\n    dr := len(d.a) - d.r\\n    dc := len(d.a[0]) - d.c\\n    if dr<dc {\\n        return dr\\n    }\\n    return dc\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2519637,
                "title": "easy-python-solution-brute-force-easy-approach-intutive-video-explanation",
                "content": "# Solution\\n\\n```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])  # m is number of rows and n is number of columns\\n        di = defaultdict(list) # Creating default dictionary with default value as list so that it become easy to add value while iterating\\n        \\n        for x in range(m): # Iterate over every row\\n            for y in range(n): # Iterate over each column value for particular row\\n                di[x - y].append(mat[x][y]) # Add value to its diagonal key\\n                \\n        for key, val in di.items():\\n            val.sort(reverse = True) # Sort diagonal values in reverse order so that removing them becomes easy\\n            \\n        for x in range(m): \\n            for y in range(n):\\n                mat[x][y] = di[x - y].pop() # Put value from dictionary into matrix\\n        return mat \\n```\\n\\nYou can get solution with video explanation on [**this**](https://www.youtube.com/watch?v=0gqWFJZ2UJI&list=PLCzjSL3T_UnQhb2WuEwtB6DH4Vqs4sl-7&index=3)\\nLeetcode playlist can be found [**here**](https://www.youtube.com/playlist?list=PLCzjSL3T_UnQhb2WuEwtB6DH4Vqs4sl-7)\\n\\nLike this post if this helps you.\\nLike and Subscribe to channel for more content.",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])  # m is number of rows and n is number of columns\\n        di = defaultdict(list) # Creating default dictionary with default value as list so that it become easy to add value while iterating\\n        \\n        for x in range(m): # Iterate over every row\\n            for y in range(n): # Iterate over each column value for particular row\\n                di[x - y].append(mat[x][y]) # Add value to its diagonal key\\n                \\n        for key, val in di.items():\\n            val.sort(reverse = True) # Sort diagonal values in reverse order so that removing them becomes easy\\n            \\n        for x in range(m): \\n            for y in range(n):\\n                mat[x][y] = di[x - y].pop() # Put value from dictionary into matrix\\n        return mat \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494890,
                "title": "simple-java-sorting-with-explanation-my-first-solution",
                "content": "The idea is to pick diagonals one by one and sort them using any technique (ex- merge sort, quick sort)\\nChallenges-\\n1. How to pick elements diagonally ?\\n2. How to avoid picking duplicate elements ?\\n\\n\\n**How to pick elements diagonally ?**\\n\\n* All elements of first row contribute to different diagonals.\\n* Base case will be to pick all elements of first row i.e. [0 0] [0 1] [0 3] ... [0 n-1]\\n* Leaving the last element here as it will have only one element, so its already in sorted form :)\\n* Once we have sorted these elements, now we are supposed to pick first element of each row as the starting element of any diagonal except the last row i.e. [1 0] [2 0] [3 0] .... [n-1 0]\\n* We will leave the last row as it will have only one element (optional optimization)\\n\\n**How to avoid picking duplicate elements ?**\\n* oops ! I already discussed in previous heading, but let me revisit\\n* Once we have sorted these elements, now we are supposed to pick first element of each row as the starting element of any diagonal except the last row i.e. [1 0] [2 0] [3 0] .... [n-1 0]\\n* In this way no element will be accessed more than once\\n\\n**Now what is the complexity of this solution ?**\\n1. Iternation part (m+n)\\n2. Max length of the diagonal array will be Max(m,n)\\n3. Sorting takes log(n) with n extra space\\n\\n***So, time complexity will be ***\\n* (m+n) log (m) for m>n\\n* (m+n) log (n) for m<n\\n* (n) log (n) for m=n, i.e. square matrix\\n\\n***Space Complexity ***\\n* O(m) for m>n\\n* O(n) for m<n\\n* O(n) for square matrix\\n\\n\\n\\n```\\npublic int[][] diagonalSort(int[][] mat) {\\n        int rows = mat.length;\\n        int cols = mat[0].length;\\n        //Sorting diagonals of first row completely\\n        for(int i = 0;i<cols;i++){\\n            sortDiagonal(mat,0,i);\\n        }\\n        for(int i = 1;i<rows-1;i++){\\n            sortDiagonal(mat,i,0);\\n        }\\n        return mat;\\n    }\\n\\n    private void sortDiagonal(int[][] mat , int i , int j){\\n        List<Integer> a = new ArrayList<>();\\n        int x = i,y=j;\\n        while (i<mat.length && j<mat[0].length){\\n            a.add(mat[i][j]);\\n            i++;\\n            j++;\\n        }\\n        Collections.sort(a);\\n        int count = 0;\\n        while (x< mat.length && y<mat[0].length){\\n            mat[x][y]=a.get(count);\\n            count++;\\n            x++;\\n            y++;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\npublic int[][] diagonalSort(int[][] mat) {\\n        int rows = mat.length;\\n        int cols = mat[0].length;\\n        //Sorting diagonals of first row completely\\n        for(int i = 0;i<cols;i++){\\n            sortDiagonal(mat,0,i);\\n        }\\n        for(int i = 1;i<rows-1;i++){\\n            sortDiagonal(mat,i,0);\\n        }\\n        return mat;\\n    }\\n\\n    private void sortDiagonal(int[][] mat , int i , int j){\\n        List<Integer> a = new ArrayList<>();\\n        int x = i,y=j;\\n        while (i<mat.length && j<mat[0].length){\\n            a.add(mat[i][j]);\\n            i++;\\n            j++;\\n        }\\n        Collections.sort(a);\\n        int count = 0;\\n        while (x< mat.length && y<mat[0].length){\\n            mat[x][y]=a.get(count);\\n            count++;\\n            x++;\\n            y++;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2493850,
                "title": "c-sorting-vector-simple-approach-easy-to-understand",
                "content": "#### Sorting and Vector Approach!!\\n**Time Complexity:- O((m+n)*k*logk)**\\n**Space Complexity:- O(k)**\\n    \\n**NOTE:-**\\n\\n```\\n--> Just need to implement sorting technique digonally.\\n--> It can also be solved by using \"Count Sort\" which reduces the Time Complexity to O((m+n)*k).\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n  \\n    void sort_fun(vector<vector<int>>& mat,int m,int n,int r,int c){\\n        vector<int> v;\\n        int rw=r;\\n        int cl=c;\\n        while(rw<m && cl<n){\\n            v.push_back(mat[rw][cl]);\\n            rw++;\\n            cl++;\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        int id=0;\\n        while(r<m && c<n){\\n            mat[r][c]=v[id];\\n            id++;\\n            r++;\\n            c++;\\n        }\\n    }\\n    \\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        \\n        // Applying sorting row wise\\n        for(int i=0;i<m;i++){\\n            sort_fun(mat,m,n,i,0);\\n        }\\n        \\n        // Applying sorting column wise\\n        for(int i=1;i<n;i++){\\n            sort_fun(mat,m,n,0,i);\\n        }\\n        \\n        return mat;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Matrix"
                ],
                "code": "```\\n--> Just need to implement sorting technique digonally.\\n--> It can also be solved by using \"Count Sort\" which reduces the Time Complexity to O((m+n)*k).\\n```\n```\\nclass Solution {\\npublic:\\n  \\n    void sort_fun(vector<vector<int>>& mat,int m,int n,int r,int c){\\n        vector<int> v;\\n        int rw=r;\\n        int cl=c;\\n        while(rw<m && cl<n){\\n            v.push_back(mat[rw][cl]);\\n            rw++;\\n            cl++;\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        int id=0;\\n        while(r<m && c<n){\\n            mat[r][c]=v[id];\\n            id++;\\n            r++;\\n            c++;\\n        }\\n    }\\n    \\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        \\n        // Applying sorting row wise\\n        for(int i=0;i<m;i++){\\n            sort_fun(mat,m,n,i,0);\\n        }\\n        \\n        // Applying sorting column wise\\n        for(int i=1;i<n;i++){\\n            sort_fun(mat,m,n,0,i);\\n        }\\n        \\n        return mat;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322941,
                "title": "easy-c-solution-clean-concise-93-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        \\n        //store the diagonal elements in a vector and sort it and change the \\n        //elements in place\\n        vector<int> curr;\\n        //the first col\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int row;\\n        int col;\\n        int k;\\n        for(int i=m-1;i>=0;i--)\\n        {\\n            //get the diagonal elements starting from mat[i][0]\\n             row=i;\\n             col=0;\\n            while(row<m && col<n)\\n            {\\n                curr.push_back(mat[row++][col++]);\\n            }\\n            sort(curr.begin(),curr.end());\\n            row=i;\\n            col=0;\\n             k=0;\\n            while(row<m && col<n)\\n            {\\n                mat[row++][col++]=curr[k++];\\n            }\\n            curr.clear();\\n        }\\n        \\n        \\n        for(int j=1;j<n;j++)\\n        {\\n            //get the diagoanl starting from mat[0][j] and sort it\\n             col=j;\\n             row=0;\\n            col=j;\\n            while(row<m && col<n)\\n            {\\n                curr.push_back(mat[row++][col++]);\\n            }\\n            sort(curr.begin(),curr.end());\\n            k=0;\\n            col=j;\\n            row=0;\\n            while(row<m && col<n)\\n            {\\n                mat[row++][col++]=curr[k++];\\n            }\\n            curr.clear();\\n        }\\n        return mat;\\n    }\\n};\\n```\\n**Upvote if this helps you:)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        \\n        //store the diagonal elements in a vector and sort it and change the \\n        //elements in place\\n        vector<int> curr;\\n        //the first col\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int row;\\n        int col;\\n        int k;\\n        for(int i=m-1;i>=0;i--)\\n        {\\n            //get the diagonal elements starting from mat[i][0]\\n             row=i;\\n             col=0;\\n            while(row<m && col<n)\\n            {\\n                curr.push_back(mat[row++][col++]);\\n            }\\n            sort(curr.begin(),curr.end());\\n            row=i;\\n            col=0;\\n             k=0;\\n            while(row<m && col<n)\\n            {\\n                mat[row++][col++]=curr[k++];\\n            }\\n            curr.clear();\\n        }\\n        \\n        \\n        for(int j=1;j<n;j++)\\n        {\\n            //get the diagoanl starting from mat[0][j] and sort it\\n             col=j;\\n             row=0;\\n            col=j;\\n            while(row<m && col<n)\\n            {\\n                curr.push_back(mat[row++][col++]);\\n            }\\n            sort(curr.begin(),curr.end());\\n            k=0;\\n            col=j;\\n            row=0;\\n            while(row<m && col<n)\\n            {\\n                mat[row++][col++]=curr[k++];\\n            }\\n            curr.clear();\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280322,
                "title": "c-time-better-then-99-55-space-better-then-95-15-easy-approach",
                "content": "```\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int row=mat.size(),col=mat[0].size();\\n        int s=max(row,col);\\n        int track[s];\\n        \\n        for(int i=0;i<col-1;i++){\\n            int itr1=0,itr2=0,itr3=i;\\n            while(itr2<row && itr3<col){\\n                track[itr1++]=mat[itr2++][itr3++];\\n            }\\n            sort(track,track+itr1);\\n            itr1=0,itr2=0,itr3=i;\\n             while(itr2<row && itr3<col){\\n                mat[itr2++][itr3++]=track[itr1++];\\n            }\\n        }\\n        for(int i=1;i<row-1;i++){\\n            int itr1=0,itr2=i,itr3=0;\\n            while(itr2<row && itr3<col){\\n                track[itr1++]=mat[itr2++][itr3++];\\n            }\\n            sort(track,track+itr1);\\n            itr1=0,itr2=i,itr3=0;\\n             while(itr2<row && itr3<col){\\n                mat[itr2++][itr3++]=track[itr1++];\\n            } \\n        }\\n        return mat;\\n    }\\n\\t```\\n\\t\\n\\t",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int row=mat.size(),col=mat[0].size();\\n        int s=max(row,col);\\n        int track[s];\\n        \\n        for(int i=0;i<col-1;i++){\\n            int itr1=0,itr2=0,itr3=i;\\n            while(itr2<row && itr3<col){\\n                track[itr1++]=mat[itr2++][itr3++];\\n            }\\n            sort(track,track+itr1);\\n            itr1=0,itr2=0,itr3=i;\\n             while(itr2<row && itr3<col){\\n                mat[itr2++][itr3++]=track[itr1++];\\n            }\\n        }\\n        for(int i=1;i<row-1;i++){\\n            int itr1=0,itr2=i,itr3=0;\\n            while(itr2<row && itr3<col){\\n                track[itr1++]=mat[itr2++][itr3++];\\n            }\\n            sort(track,track+itr1);\\n            itr1=0,itr2=i,itr3=0;\\n             while(itr2<row && itr3<col){\\n                mat[itr2++][itr3++]=track[itr1++];\\n            } \\n        }\\n        return mat;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1165253,
                "title": "java-reuse-array-buffer-99",
                "content": "In case this isn\\'t already posted in some form here.... my idea was to use a buffer (simple int array) to store the diagonal. Since the max size of a diagonal is the min of row & col lengths you can easily size the buffer to this value & then sort only the portion of the buffer used for any particular diagonal. I think there are similar solutions presented but for some reason they use more complex collections & array probably performs better.\\n```\\nclass Solution {\\n    int R;\\n    int C;\\n    int[] buffer;\\n    \\n    public int[][] diagonalSort(int[][] mat) {\\n        R = mat.length;\\n        C = mat[0].length;\\n        \\n        buffer = new int[Math.min(R,C)];\\n        \\n        for (int r = 0; r < R; r++) {\\n            sortDiagonal(r, 0, mat);\\n        }\\n        \\n        for (int c = 1; c < C; c++) {\\n            sortDiagonal(0, c, mat);\\n        }\\n        \\n        return mat;\\n    }\\n        \\n    private void sortDiagonal(int startR, int startC, int[][] mat) {\\n        int r = startR;\\n        int c = startC;\\n        int bPtr = 0;\\n        while (r < R && c < C) {\\n            buffer[bPtr++] = mat[r++][c++];\\n        }\\n        Arrays.sort(buffer, 0, bPtr);\\n        for (int i = 0; i < bPtr; i++) {\\n            mat[startR+i][startC+i] = buffer[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    int R;\\n    int C;\\n    int[] buffer;\\n    \\n    public int[][] diagonalSort(int[][] mat) {\\n        R = mat.length;\\n        C = mat[0].length;\\n        \\n        buffer = new int[Math.min(R,C)];\\n        \\n        for (int r = 0; r < R; r++) {\\n            sortDiagonal(r, 0, mat);\\n        }\\n        \\n        for (int c = 1; c < C; c++) {\\n            sortDiagonal(0, c, mat);\\n        }\\n        \\n        return mat;\\n    }\\n        \\n    private void sortDiagonal(int startR, int startC, int[][] mat) {\\n        int r = startR;\\n        int c = startC;\\n        int bPtr = 0;\\n        while (r < R && c < C) {\\n            buffer[bPtr++] = mat[r++][c++];\\n        }\\n        Arrays.sort(buffer, 0, bPtr);\\n        for (int i = 0; i < bPtr; i++) {\\n            mat[startR+i][startC+i] = buffer[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1041704,
                "title": "python-3-simplified",
                "content": "I saw an approach in this forum and decided it to simplify a bit. Hope it helps. Credit to the original approach poster.\\n```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        d = defaultdict(list)\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                d[i-j].append(mat[i][j])\\n\\n        for k in d:\\n            for i,num in enumerate(sorted(d[k])):\\n                mat[i+max(0,k)][i+max(0,-k)] = num\\n        return mat",
                "solutionTags": [],
                "code": "I saw an approach in this forum and decided it to simplify a bit. Hope it helps. Credit to the original approach poster.\\n```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        d = defaultdict(list)\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                d[i-j].append(mat[i][j])\\n\\n        for k in d:\\n            for i,num in enumerate(sorted(d[k])):\\n                mat[i+max(0,k)][i+max(0,-k)] = num\\n        return mat",
                "codeTag": "Java"
            },
            {
                "id": 1034499,
                "title": "simple-countarray-solution-time-o-n-m-space-o-1",
                "content": "__Steps:__\\n- Chose all the outer most index of the matrix\\n- Execute counter sort on the diagonal\\n- Return the matrix\\n\\n__Time Complexity:__ (O(N) (choosing all the rowIndexes) + O(M) (choosing all the rowIndexes)) * O(100) (sorting the matrix elements) = 100 * O(N+M) = __O(N+M)__\\n__Space Complexity__ O(101) (for the temp array) + no space required for sorting as we perform inplace sorting = __O(1)__\\n\\n```\\nclass Solution {\\n    \\n    private int[] temp = new int[101];\\n    \\n    public int[][] diagonalSort(int[][] mat) {\\n        int rows = mat.length, \\n            columns = mat[0].length;\\n        \\n        // All the left most indexes in the matrix\\n        while(rows > 0)\\n            countingSortFromIndex(mat, --rows, 0);\\n        \\n        // All the top most indexes in the matrix (except [0,0] which is included in the left most indexes)\\n        while(columns > 1)\\n            countingSortFromIndex(mat, 0, --columns);\\n        \\n        return mat;\\n    }\\n    \\n    private void countingSortFromIndex(int[][] mat, int rowIndex, int columnIndex) {\\n        \\n        // Create a count array\\n        for(int i=0; (i+rowIndex)<mat.length && (i+columnIndex)<mat[0].length; ++i) {\\n            int num = mat[i+rowIndex][i+columnIndex];\\n            ++temp[num];\\n        }\\n        \\n        // Get the value from count array to fill the matrix\\n        int itr = 1;\\n        for(int i=0; (i+rowIndex)<mat.length && (i+columnIndex)<mat[0].length; ++i) {\\n            while(temp[itr] == 0)\\n                ++itr;\\n            mat[i+rowIndex][i+columnIndex] = itr;\\n            --temp[itr];\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private int[] temp = new int[101];\\n    \\n    public int[][] diagonalSort(int[][] mat) {\\n        int rows = mat.length, \\n            columns = mat[0].length;\\n        \\n        // All the left most indexes in the matrix\\n        while(rows > 0)\\n            countingSortFromIndex(mat, --rows, 0);\\n        \\n        // All the top most indexes in the matrix (except [0,0] which is included in the left most indexes)\\n        while(columns > 1)\\n            countingSortFromIndex(mat, 0, --columns);\\n        \\n        return mat;\\n    }\\n    \\n    private void countingSortFromIndex(int[][] mat, int rowIndex, int columnIndex) {\\n        \\n        // Create a count array\\n        for(int i=0; (i+rowIndex)<mat.length && (i+columnIndex)<mat[0].length; ++i) {\\n            int num = mat[i+rowIndex][i+columnIndex];\\n            ++temp[num];\\n        }\\n        \\n        // Get the value from count array to fill the matrix\\n        int itr = 1;\\n        for(int i=0; (i+rowIndex)<mat.length && (i+columnIndex)<mat[0].length; ++i) {\\n            while(temp[itr] == 0)\\n                ++itr;\\n            mat[i+rowIndex][i+columnIndex] = itr;\\n            --temp[itr];\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031633,
                "title": "c-simple-solution-faster-than-99",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        unordered_map<int, vector<int> > tmp;\\n        int m = mat.size(), n = mat[0].size();\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                tmp[i-j].push_back(mat[i][j]);\\n            }\\n        }\\n        \\n        for(int i = 1-n; i < m; i++) {\\n            sort(tmp[i].begin(),tmp[i].end());\\n        }\\n\\n        for(int i = m-1; i >= 0; i--) {\\n            for(int j = n-1; j >= 0; j--) {\\n                mat[i][j] = tmp[i-j].back();\\n                tmp[i-j].pop_back();\\n            }\\n        }\\n\\n        return mat;\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        unordered_map<int, vector<int> > tmp;\\n        int m = mat.size(), n = mat[0].size();\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                tmp[i-j].push_back(mat[i][j]);\\n            }\\n        }\\n        \\n        for(int i = 1-n; i < m; i++) {\\n            sort(tmp[i].begin(),tmp[i].end());\\n        }\\n\\n        for(int i = m-1; i >= 0; i--) {\\n            for(int j = n-1; j >= 0; j--) {\\n                mat[i][j] = tmp[i-j].back();\\n                tmp[i-j].pop_back();\\n            }\\n        }\\n\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888310,
                "title": "swift-beautiful",
                "content": "O(m * n log(min(m,n)))\\n```\\nfunc diagonalSort(_ mat: [[Int]]) -> [[Int]] {\\n\\tlet height = mat.count\\n\\tlet width  = mat[0].count\\n\\tvar result = Array(repeating: Array(repeating: 0, count: width), count: height)\\n\\tvar groupDict = [Int: [Int]]()\\n\\n\\tfor row in 0..<height {\\n\\t\\tfor col in 0..<width {\\n\\t\\t\\tlet key = row - col\\n\\t\\t\\tif groupDict[key] == nil {\\n\\t\\t\\t\\tgroupDict[key] = [Int]()\\n\\t\\t\\t}\\n\\t\\t\\tgroupDict[key]!.append(mat[row][col])\\n\\t\\t}\\n\\t}\\n\\n\\tfor key in groupDict.keys {\\n\\t\\tgroupDict[key]!.sort(by: >)\\n\\t}\\n\\n\\tfor row in 0..<height {\\n\\t\\tfor col in 0..<width {\\n\\t\\t\\tresult[row][col] = groupDict[row - col]!.removeLast()\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc diagonalSort(_ mat: [[Int]]) -> [[Int]] {\\n\\tlet height = mat.count\\n\\tlet width  = mat[0].count\\n\\tvar result = Array(repeating: Array(repeating: 0, count: width), count: height)\\n\\tvar groupDict = [Int: [Int]]()\\n\\n\\tfor row in 0..<height {\\n\\t\\tfor col in 0..<width {\\n\\t\\t\\tlet key = row - col\\n\\t\\t\\tif groupDict[key] == nil {\\n\\t\\t\\t\\tgroupDict[key] = [Int]()\\n\\t\\t\\t}\\n\\t\\t\\tgroupDict[key]!.append(mat[row][col])\\n\\t\\t}\\n\\t}\\n\\n\\tfor key in groupDict.keys {\\n\\t\\tgroupDict[key]!.sort(by: >)\\n\\t}\\n\\n\\tfor row in 0..<height {\\n\\t\\tfor col in 0..<width {\\n\\t\\t\\tresult[row][col] = groupDict[row - col]!.removeLast()\\n\\t\\t}\\n\\t}\\n\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774402,
                "title": "easy-and-understandable-python-solution-that-beats-98",
                "content": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        n = len(mat)\\n        m = len(mat[0])\\n        t = n+m\\n        store = [[] for _ in range(t)] # Store is basically to store the elements diagonally.\\n        \\n        for i in range(n):\\n            for j in range(m):\\n                x = i-j # diffrence between the indexes will be same for all diagonal element \\n                if x>=0: \\n                    store[x].append(mat[i][j]) # if positive store in same x index\\n                else:\\n                    store[t+x].append(mat[i][j]) # if negative store in t+x(total-that index)\\n        \\n        for i in store:\\n            i.sort()  # sort the diagonal elements\\n            \\n        for i in range(n):\\n            for j in range(m):\\n                x = i-j\\n                if x>=0:\\n                    mat[i][j] = store[x].pop(0)   #put back the 0th value in that position\\n                else:\\n                    mat[i][j] = store[t+x].pop(0)\\n        return mat\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        n = len(mat)\\n        m = len(mat[0])\\n        t = n+m\\n        store = [[] for _ in range(t)] # Store is basically to store the elements diagonally.\\n        \\n        for i in range(n):\\n            for j in range(m):\\n                x = i-j # diffrence between the indexes will be same for all diagonal element \\n                if x>=0: \\n                    store[x].append(mat[i][j]) # if positive store in same x index\\n                else:\\n                    store[t+x].append(mat[i][j]) # if negative store in t+x(total-that index)\\n        \\n        for i in store:\\n            i.sort()  # sort the diagonal elements\\n            \\n        for i in range(n):\\n            for j in range(m):\\n                x = i-j\\n                if x>=0:\\n                    mat[i][j] = store[x].pop(0)   #put back the 0th value in that position\\n                else:\\n                    mat[i][j] = store[t+x].pop(0)\\n        return mat\\n",
                "codeTag": "Java"
            },
            {
                "id": 679085,
                "title": "javascript-map",
                "content": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number[][]}\\n */\\nvar diagonalSort = function(mat) {\\n    let map = {}\\n    for(let i=0;i<mat.length;i++){\\n        for(let j=0;j<mat[0].length;j++){\\n            let d = i-j\\n            if(!map[d]){\\n                map[d]=[]\\n            }\\n            map[d].push(mat[i][j])\\n        }\\n    }\\n    for(let key in map){\\n        map[key].sort((a,b)=>{return a-b})\\n    }\\n    for(let i=0;i<mat.length;i++){\\n        for(let j=0;j<mat[0].length;j++){\\n            let d = i-j\\n            mat[i][j] = map[d].shift()\\n        }\\n    }\\n    return mat\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number[][]}\\n */\\nvar diagonalSort = function(mat) {\\n    let map = {}\\n    for(let i=0;i<mat.length;i++){\\n        for(let j=0;j<mat[0].length;j++){\\n            let d = i-j\\n            if(!map[d]){\\n                map[d]=[]\\n            }\\n            map[d].push(mat[i][j])\\n        }\\n    }\\n    for(let key in map){\\n        map[key].sort((a,b)=>{return a-b})\\n    }\\n    for(let i=0;i<mat.length;i++){\\n        for(let j=0;j<mat[0].length;j++){\\n            let d = i-j\\n            mat[i][j] = map[d].shift()\\n        }\\n    }\\n    return mat\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 618325,
                "title": "python3-easy-solution",
                "content": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        r, c = len(mat), len(mat[0])\\n        d = collections.defaultdict(list)\\n        \\n        for i in range(r):\\n            for j in range(c):\\n                d[j-i].append(mat[i][j])\\n                \\n        for k in d.keys():\\n            d[k] = sorted(d[k])\\n            \\n        for i in range(r):\\n            for j in range(c):\\n                mat[i][j] = d[j-i].pop(0)\\n                \\n        return mat\\n```\\nR = Rows\\nC = Columns\\nD = min(R,C), length of the longest diagonal\\n\\nTime complexity: O(RClog(D))\\nSpace comlexity: O(RC)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        r, c = len(mat), len(mat[0])\\n        d = collections.defaultdict(list)\\n        \\n        for i in range(r):\\n            for j in range(c):\\n                d[j-i].append(mat[i][j])\\n                \\n        for k in d.keys():\\n            d[k] = sorted(d[k])\\n            \\n        for i in range(r):\\n            for j in range(c):\\n                mat[i][j] = d[j-i].pop(0)\\n                \\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575550,
                "title": "c-map-and-multiset-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) \\n    {\\n        if(mat.empty())\\n            return mat;\\n        int m = (int)mat.size(), n = int(mat[0].size());\\n        unordered_map<int, multiset<int>> map;\\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j)\\n                map[i - j].insert(mat[i][j]);\\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j)\\n                mat[i][j] = *map[i - j].begin(), map[i - j].erase(map[i - j].begin());\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) \\n    {\\n        if(mat.empty())\\n            return mat;\\n        int m = (int)mat.size(), n = int(mat[0].size());\\n        unordered_map<int, multiset<int>> map;\\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j)\\n                map[i - j].insert(mat[i][j]);\\n        for(int i = 0; i < m; ++i)\\n            for(int j = 0; j < n; ++j)\\n                mat[i][j] = *map[i - j].begin(), map[i - j].erase(map[i - j].begin());\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526884,
                "title": "java-priorityqueue-beats-84-runtime-100-memory",
                "content": "```\\nclass Solution {\\n    \\n    PriorityQueue<Integer> pQ = new PriorityQueue<>();\\n    \\n    public int[][] diagonalSort(int[][] mat) {\\n        \\n        int[][] seen = new int[mat.length][mat[0].length];\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                if(seen[i][j] != 1) {\\n                    loadQueue(mat, i, j);\\n                    loadDiagonal(mat, seen, i, j);\\n                }\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n    \\n    \\n    public void loadQueue(int[][] mat, int i, int j) {\\n        if(i >= mat.length || j >= mat[0].length || i < 0 || j < 0) {\\n            return;\\n        }\\n        \\n        pQ.add(mat[i][j]);\\n        loadQueue(mat, i + 1, j + 1);\\n    }\\n    \\n    public void loadDiagonal(int[][] mat, int[][] seen,  int i, int j) {\\n        if(i >= mat.length || j > mat[0].length || i < 0 || j < 0 || pQ.isEmpty()) {\\n            return;\\n        }\\n        \\n        mat[i][j] = pQ.poll();\\n        seen[i][j] = 1;\\n        loadDiagonal(mat, seen, i + 1, j + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    PriorityQueue<Integer> pQ = new PriorityQueue<>();\\n    \\n    public int[][] diagonalSort(int[][] mat) {\\n        \\n        int[][] seen = new int[mat.length][mat[0].length];\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                if(seen[i][j] != 1) {\\n                    loadQueue(mat, i, j);\\n                    loadDiagonal(mat, seen, i, j);\\n                }\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n    \\n    \\n    public void loadQueue(int[][] mat, int i, int j) {\\n        if(i >= mat.length || j >= mat[0].length || i < 0 || j < 0) {\\n            return;\\n        }\\n        \\n        pQ.add(mat[i][j]);\\n        loadQueue(mat, i + 1, j + 1);\\n    }\\n    \\n    public void loadDiagonal(int[][] mat, int[][] seen,  int i, int j) {\\n        if(i >= mat.length || j > mat[0].length || i < 0 || j < 0 || pQ.isEmpty()) {\\n            return;\\n        }\\n        \\n        mat[i][j] = pQ.poll();\\n        seen[i][j] = 1;\\n        loadDiagonal(mat, seen, i + 1, j + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489751,
                "title": "o-mn-time-o-1-space-complexity-java-solution",
                "content": "Note that limits for mat[i][j] are between 1 and 100, so instead of using O(nlogn) sorts like quick sort or merge sort, counting sort/ fast sort can be used to sort the diagonal elements in Linear time.\\n\\nSince we read the value of each element once and write to each element of mat once the time complexity is O(mn).\\nThe additional space we are using is array arr which has constant space of 100 elements so space complexity is O(1).\\n\\n If the solution or its explanation is not clear to you, you are free to ask.\\n\\n\\'\\'\\'\\n\\n    public int[][] diagonalSort(int[][] mat) {\\t\\n        int m = mat.length;\\t\\t\\n        int n = mat[0].length;\\t\\t\\n\\t\\t\\n\\t\\t//start from top right to top left and sort each diagonal\\n        for(int i = n-1;i>=0;i--){\\n            sort(0,i,m,n,mat);\\n        }\\n        \\n\\t\\t//then start from top left to bottom left and sort each diagonal\\n        for(int i = 1;i<m;i++){\\n            sort(i,0,m,n,mat);\\n        }\\n        \\n        return mat;\\n    }\\n    \\n    void sort(int x, int y, int rows, int cols, int[][] mat){\\n\\t\\n\\t\\t//count sort implementation\\n        int[] arr = new int[101];\\n\\t\\t\\n        int s= x,e= y;\\n\\t\\t\\n\\t\\t//store the value of each diagonal element in arr\\n        while(x < rows && y < cols){\\n            arr[mat[x][y]]++;\\n            x++;\\n            y++;\\n        }\\n        \\n        //write sorted value to each diagonal element\\n        for(int i = 0;i<arr.length;){\\n            if(arr[i] <= 0){\\n                i++;\\n                continue;\\n            }\\n            \\n            if(arr[i] > 1){\\n                mat[s++][e++] = i;      \\n                arr[i]--;\\n            }\\n            else{\\n                mat[s++][e++] = i++;\\n            }\\n            \\n        }\\n        \\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Counting Sort"
                ],
                "code": "Note that limits for mat[i][j] are between 1 and 100, so instead of using O(nlogn) sorts like quick sort or merge sort, counting sort/ fast sort can be used to sort the diagonal elements in Linear time.\\n\\nSince we read the value of each element once and write to each element of mat once the time complexity is O(mn).\\nThe additional space we are using is array arr which has constant space of 100 elements so space complexity is O(1).\\n\\n If the solution or its explanation is not clear to you, you are free to ask.\\n\\n\\'\\'\\'\\n\\n    public int[][] diagonalSort(int[][] mat) {\\t\\n        int m = mat.length;\\t\\t\\n        int n = mat[0].length;\\t\\t\\n\\t\\t\\n\\t\\t//start from top right to top left and sort each diagonal\\n        for(int i = n-1;i>=0;i--){\\n            sort(0,i,m,n,mat);\\n        }\\n        \\n\\t\\t//then start from top left to bottom left and sort each diagonal\\n        for(int i = 1;i<m;i++){\\n            sort(i,0,m,n,mat);\\n        }\\n        \\n        return mat;\\n    }\\n    \\n    void sort(int x, int y, int rows, int cols, int[][] mat){\\n\\t\\n\\t\\t//count sort implementation\\n        int[] arr = new int[101];\\n\\t\\t\\n        int s= x,e= y;\\n\\t\\t\\n\\t\\t//store the value of each diagonal element in arr\\n        while(x < rows && y < cols){\\n            arr[mat[x][y]]++;\\n            x++;\\n            y++;\\n        }\\n        \\n        //write sorted value to each diagonal element\\n        for(int i = 0;i<arr.length;){\\n            if(arr[i] <= 0){\\n                i++;\\n                continue;\\n            }\\n            \\n            if(arr[i] > 1){\\n                mat[s++][e++] = i;      \\n                arr[i]--;\\n            }\\n            else{\\n                mat[s++][e++] = i++;\\n            }\\n            \\n        }\\n        \\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 489725,
                "title": "java-simple-java-solution-first-columnwise-then-rowwise",
                "content": "```\\n    public int[][] diagonalSort(int[][] mat) {\\n        \\n        int row = mat.length;\\n        int col = mat[0].length;\\n        for(int j=0; j<col; j++) {\\n            List<Integer> arr = new ArrayList();\\n            int k=j;\\n            for(int i=0; i<row&&k<col; i++) {\\n                arr.add(mat[i][k++]);\\n            }\\n            Collections.sort(arr);\\n            k=j;\\n            int l=0;\\n            for(int i=0; i<row&&k<col; i++) {\\n                mat[i][k++] = arr.get(l);\\n                l++;\\n            }\\n        }\\n        \\n        for(int i=1; i<row; i++) {\\n            List<Integer> arr = new ArrayList();\\n            int k=i;\\n            for(int j=0; j<col && k<row; j++) {\\n                arr.add(mat[k++][j]);\\n            }\\n            Collections.sort(arr);\\n            k=i;\\n            int l=0;\\n            for(int j=0; j<col && k<row; j++) {\\n                mat[k++][j] = arr.get(l);\\n                l++;\\n            }\\n            \\n        }\\n        \\n        return mat;\\n        \\n    }",
                "solutionTags": [],
                "code": "```\\n    public int[][] diagonalSort(int[][] mat) {\\n        \\n        int row = mat.length;\\n        int col = mat[0].length;\\n        for(int j=0; j<col; j++) {\\n            List<Integer> arr = new ArrayList();\\n            int k=j;\\n            for(int i=0; i<row&&k<col; i++) {\\n                arr.add(mat[i][k++]);\\n            }\\n            Collections.sort(arr);\\n            k=j;\\n            int l=0;\\n            for(int i=0; i<row&&k<col; i++) {\\n                mat[i][k++] = arr.get(l);\\n                l++;\\n            }\\n        }\\n        \\n        for(int i=1; i<row; i++) {\\n            List<Integer> arr = new ArrayList();\\n            int k=i;\\n            for(int j=0; j<col && k<row; j++) {\\n                arr.add(mat[k++][j]);\\n            }\\n            Collections.sort(arr);\\n            k=i;\\n            int l=0;\\n            for(int j=0; j<col && k<row; j++) {\\n                mat[k++][j] = arr.get(l);\\n                l++;\\n            }\\n            \\n        }\\n        \\n        return mat;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 489697,
                "title": "simple-python-counting-sort",
                "content": "Since the numbers are in the range 1 to 100. We can do a counting sort on each diagonal.\\n\\n```\\ndef diagonalSort(self, a: List[List[int]]) -> List[List[int]]:\\n        def msort(i , j):\\n            counts = [0] * 101\\n            x, y = i, j\\n            while True:\\n                counts[a[x][y]] += 1\\n                x, y = x+1, y+1\\n                if not (0 <= x < m and 0 <= y < n): break\\n            x, y = i, j\\n            while True:\\n                for i in range(1, 101):\\n                    if counts[i] > 0:\\n                        a[x][y] = i\\n                        counts[i] -= 1\\n                        break\\n                x, y = x+1, y+1\\n                if not (0 <= x < m and 0 <= y < n): break\\n                \\n        m,n = len(a), len(a[0])\\n        for i in range(m):\\n            msort(i, 0)\\n        for i in range(n):\\n            msort(0, i)\\n        return a\\n```",
                "solutionTags": [],
                "code": "```\\ndef diagonalSort(self, a: List[List[int]]) -> List[List[int]]:\\n        def msort(i , j):\\n            counts = [0] * 101\\n            x, y = i, j\\n            while True:\\n                counts[a[x][y]] += 1\\n                x, y = x+1, y+1\\n                if not (0 <= x < m and 0 <= y < n): break\\n            x, y = i, j\\n            while True:\\n                for i in range(1, 101):\\n                    if counts[i] > 0:\\n                        a[x][y] = i\\n                        counts[i] -= 1\\n                        break\\n                x, y = x+1, y+1\\n                if not (0 <= x < m and 0 <= y < n): break\\n                \\n        m,n = len(a), len(a[0])\\n        for i in range(m):\\n            msort(i, 0)\\n        for i in range(n):\\n            msort(0, i)\\n        return a\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3073057,
                "title": "c-easy-simple-tc-o-m-n-klogk-sc-o-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O((m+n)*klogk)   \\n-Where m is the size of row\\n-n is the size of col\\n-k is the size of diagonal\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k)\\n    -where k is the length of diagonal\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size();\\n        //first row\\n        for(int i=0;i<n;i++){\\n            int row=0,col=i;\\n            vector<int>temp;\\n            while(row<m && col<n){\\n                temp.push_back(mat[row][col]);\\n                row++;\\n                col++;\\n            }\\n            sort(temp.begin(),temp.end());\\n            row=0;\\n            col=i;\\n            int ind=0;\\n            while(row<m && col<n){\\n                mat[row][col]=temp[ind];\\n                row++;\\n                col++;\\n                ind++;    \\n            }\\n    }\\n        //first col\\n        for(int j=1;j<m;j++){\\n            int row=j,col=0;\\n            vector<int>temp;\\n            while(row<m && col<n){\\n                    temp.push_back(mat[row][col]);\\n                    row++;\\n                    col++;\\n                }\\n            sort(temp.begin(),temp.end());\\n            row=j;\\n            col=0;\\n            int ind=0;\\n            while(row<m && col<n){\\n                    mat[row][col]=temp[ind];\\n                    row++;\\n                    col++;\\n                    ind++;    \\n            }\\n        }\\n    return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m=mat.size(),n=mat[0].size();\\n        //first row\\n        for(int i=0;i<n;i++){\\n            int row=0,col=i;\\n            vector<int>temp;\\n            while(row<m && col<n){\\n                temp.push_back(mat[row][col]);\\n                row++;\\n                col++;\\n            }\\n            sort(temp.begin(),temp.end());\\n            row=0;\\n            col=i;\\n            int ind=0;\\n            while(row<m && col<n){\\n                mat[row][col]=temp[ind];\\n                row++;\\n                col++;\\n                ind++;    \\n            }\\n    }\\n        //first col\\n        for(int j=1;j<m;j++){\\n            int row=j,col=0;\\n            vector<int>temp;\\n            while(row<m && col<n){\\n                    temp.push_back(mat[row][col]);\\n                    row++;\\n                    col++;\\n                }\\n            sort(temp.begin(),temp.end());\\n            row=j;\\n            col=0;\\n            int ind=0;\\n            while(row<m && col<n){\\n                    mat[row][col]=temp[ind];\\n                    row++;\\n                    col++;\\n                    ind++;    \\n            }\\n        }\\n    return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3064361,
                "title": "c-using-map-and-priority-queue",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& vec) {\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> ump; // min heap\\n        for(int i=0;i<vec.size();i++)\\n            for(int j=0;j<vec[0].size();j++) ump[i - j].push(vec[i][j]);\\n        \\n        for(int i=0;i<vec.size();i++)\\n            for(int j=0;j<vec[0].size();j++) {\\n                vec[i][j] = ump[i - j].top();\\n                ump[i - j].pop();\\n            }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& vec) {\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> ump; // min heap\\n        for(int i=0;i<vec.size();i++)\\n            for(int j=0;j<vec[0].size();j++) ump[i - j].push(vec[i][j]);\\n        \\n        for(int i=0;i<vec.size();i++)\\n            for(int j=0;j<vec[0].size();j++) {\\n                vec[i][j] = ump[i - j].top();\\n                ump[i - j].pop();\\n            }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496700,
                "title": "1329-sort-the-matrix-diagonally-o-m-n",
                "content": "```\\n class Solution {\\npublic:\\n\\n\\t//using bucket sort and reduce time to O(M*N).\\n\\n\\tvoid solve_to_sort(int x, int y, vector<vector<int>>& g)\\n\\t{\\n\\t\\tint m = g.size();\\n\\t\\tint n = g[0].size();\\n\\t\\t//taking array\\n\\t\\tvector<int> v(101);\\n\\t\\t//logic apply\\n\\t\\t//pointer\\n\\t\\t//bucket sort\\n\\t\\tfor (int i = x, j = y; i < m && j < n; i++, j++)\\n\\t\\t{\\n\\t\\t\\tv[g[i][j]]++;\\n\\t\\t}\\n\\t\\t//loop upto constraints given\\n\\t\\tfor (int i = 0; i < 101; i++)\\n\\t\\t{\\n\\t\\t\\twhile (v[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tg[x++][y++] = i;\\n\\t\\t\\t\\tv[i]--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvector<vector<int>> diagonalSort(vector<vector<int>>& g)\\n\\t{\\n\\t\\tint m = g.size();\\n\\t\\tint n = g[0].size();\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t{\\n\\n\\t\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (i == 0 || j == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsolve_to_sort(i, j, g);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn g;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Bucket Sort"
                ],
                "code": "```\\n class Solution {\\npublic:\\n\\n\\t//using bucket sort and reduce time to O(M*N).\\n\\n\\tvoid solve_to_sort(int x, int y, vector<vector<int>>& g)\\n\\t{\\n\\t\\tint m = g.size();\\n\\t\\tint n = g[0].size();\\n\\t\\t//taking array\\n\\t\\tvector<int> v(101);\\n\\t\\t//logic apply\\n\\t\\t//pointer\\n\\t\\t//bucket sort\\n\\t\\tfor (int i = x, j = y; i < m && j < n; i++, j++)\\n\\t\\t{\\n\\t\\t\\tv[g[i][j]]++;\\n\\t\\t}\\n\\t\\t//loop upto constraints given\\n\\t\\tfor (int i = 0; i < 101; i++)\\n\\t\\t{\\n\\t\\t\\twhile (v[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tg[x++][y++] = i;\\n\\t\\t\\t\\tv[i]--;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tvector<vector<int>> diagonalSort(vector<vector<int>>& g)\\n\\t{\\n\\t\\tint m = g.size();\\n\\t\\tint n = g[0].size();\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t{\\n\\n\\t\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (i == 0 || j == 0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tsolve_to_sort(i, j, g);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn g;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495749,
                "title": "python-simple-solution-and-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/89a96933-cc55-4f1b-9db6-19d1b9959ff2_1661690851.439555.png)\\n\\nFrom the above figure we can see for a certain matrix diagonal, the difference between row and column indices remains constant.\\n\\nThe only thing you need to know for solving this problem is, for any matrix diagonal the difference between the row and column indices remains constant. \\n\\nCODE:\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        d1=defaultdict(lambda:[])\\n        \\n\\t\\t#first for loop\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                d1[(i-j)].append(mat[i][j])\\n\\t\\t\\n\\t\\t#Second for loop\\n        for x in d1:\\n            d1[x].sort(reverse=True)\\n        \\n\\t\\t#Third for loop\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                mat[i][j]=d1[(i-j)].pop()\\n        return mat\\n\\t```\\n\\tso lets understand code:\\n\\tFirstly we have created a dictionary with name D1.\\n\\t\\n\\tIn First for loop\\n\\twe are storing each Diagonal Matrix values in our Dictionary D1\\n\\tour dictionry will look like, d1= {0: [3, 2, 1], -1: [3, 1, 2], -2: [1, 2], -3: [1], 1: [2, 1], 2: [1]})\\n\\t\\n\\tSecond for Loop:\\n\\tHere we are sorting the value list of our dictionary.\\n\\tdictionary will look like d1={0: [3, 2, 1], -1: [3, 2, 1], -2: [2, 1], -3: [1], 1: [2, 1], 2: [1]})\\n\\tYou can see our values list is sorted(in decending order).\\n\\t\\n\\tThird for loop:\\n\\tStoring this values in our original matrix(mat) and poping elements from d1 in parallel.\\n\\td1={0: [], -1: [], -2: [], -3: [], 1: [], 2: []}\\n\\n\\n\\n\\t",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        d1=defaultdict(lambda:[])\\n        \\n\\t\\t#first for loop\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                d1[(i-j)].append(mat[i][j])\\n\\t\\t\\n\\t\\t#Second for loop\\n        for x in d1:\\n            d1[x].sort(reverse=True)\\n        \\n\\t\\t#Third for loop\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                mat[i][j]=d1[(i-j)].pop()\\n        return mat\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2495121,
                "title": "rust-bucket-sort-with-comments",
                "content": "The \"algorithm\" is very straight-forward. Sort the diagonals, that\\'s it. But for Rust, I use the nice possibility to chain together iterators for the coordinates of the first elements of each diagonal that needs sorting (the corners are only one element => no sorting necessary). For each such coordinate, we step along the diagonal and collect the items in buckets for bucket sorting, so that the time complexity per diagonal  becomes O(min(m,n)) (instead of O(min(m,n) * log(min(m,n))) with \"normal\" sorting). And then we do another pass over the diagonal to populate it with the sorted result from the bucket sorting. A nice by-product of the bucket sorting is that the buckets are cleared as part of the process when we extract the sorted diagonal, to it\\'s ready to go for the next round without additional clearing.\\n\\n```\\nimpl Solution {\\n    pub fn diagonal_sort(mut mat: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut buckets = [0; 101];\\n        let (m, n) = (mat.len(), mat[0].len());\\n\\n\\t\\t// Chain together iterators for first element coordinates of all relevant diagonals\\n        (1..m-1).map(|i| (i, 0)).chain((0..n-1).map(|j| (0, j))).for_each(|(i0, j0)| {\\n            let (mut i, mut j) = (i0, j0);\\n            let (mut min, mut max) = (i32::MAX, i32::MIN);\\n\\t\\t\\t// Populate buckets for bucket sorting\\n            while i < m && j < n {\\n                let element = mat[i][j];\\n                min = min.min(element);\\n                max = max.max(element);\\n                buckets[element as usize] += 1;\\n                i += 1;\\n                j += 1;\\n            }\\n\\t\\t\\t// Populate matrix with result of bucket sorting\\n            let (mut i, mut j) = (i0, j0);\\n            let mut k = min as usize;\\n            while i < m && j < n {\\n                while buckets[k] == 0 {\\n                    k += 1;\\n                }\\n                mat[i][j] = k as i32;\\n                buckets[k] -= 1;\\n                i += 1;\\n                j += 1;\\n            }\\n        });\\n        mat\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn diagonal_sort(mut mat: Vec<Vec<i32>>) -> Vec<Vec<i32>> {\\n        let mut buckets = [0; 101];\\n        let (m, n) = (mat.len(), mat[0].len());\\n\\n\\t\\t// Chain together iterators for first element coordinates of all relevant diagonals\\n        (1..m-1).map(|i| (i, 0)).chain((0..n-1).map(|j| (0, j))).for_each(|(i0, j0)| {\\n            let (mut i, mut j) = (i0, j0);\\n            let (mut min, mut max) = (i32::MAX, i32::MIN);\\n\\t\\t\\t// Populate buckets for bucket sorting\\n            while i < m && j < n {\\n                let element = mat[i][j];\\n                min = min.min(element);\\n                max = max.max(element);\\n                buckets[element as usize] += 1;\\n                i += 1;\\n                j += 1;\\n            }\\n\\t\\t\\t// Populate matrix with result of bucket sorting\\n            let (mut i, mut j) = (i0, j0);\\n            let mut k = min as usize;\\n            while i < m && j < n {\\n                while buckets[k] == 0 {\\n                    k += 1;\\n                }\\n                mat[i][j] = k as i32;\\n                buckets[k] -= 1;\\n                i += 1;\\n                j += 1;\\n            }\\n        });\\n        mat\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2495096,
                "title": "c-easy-using-map",
                "content": "Here the key is that every diag has i-j has a constant value\\nSo we club all the indexes with same i-j together sort them and insert them back\\n\\nHere we can use map of priority queue which will help us to club them together and sort them.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    /*\\n        For every diagnol i-j is constant\\n        \\n        \\n        1,5\\n            2,6\\n                3,7\\n                    4,8\\n                    \\n        diff = -4\\n        \\n    */    \\n    \\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> mp;\\n        for(int i = 0; i < n; i++) for(int j = 0; j < m; j++) mp[i-j].push(mat[i][j]);\\n        for(int i = 0; i < n; i++) for(int j = 0; j < m; j++) mat[i][j] = mp[i-j].top(), mp[i-j].pop();\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n        For every diagnol i-j is constant\\n        \\n        \\n        1,5\\n            2,6\\n                3,7\\n                    4,8\\n                    \\n        diff = -4\\n        \\n    */    \\n    \\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> mp;\\n        for(int i = 0; i < n; i++) for(int j = 0; j < m; j++) mp[i-j].push(mat[i][j]);\\n        for(int i = 0; i < n; i++) for(int j = 0; j < m; j++) mat[i][j] = mp[i-j].top(), mp[i-j].pop();\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494017,
                "title": "a-different-approach-simulation-fully-explained",
                "content": "Hi all, hope you are having a fantastic weekend :)\\n\\n<hr />\\n\\n# Simulation - Sorting diagonals one by one\\nWe are given a matrix and are required to return a matrix that has all its diagonal values sorted.\\n\\nThe question doesn\\'t talk only about the main diagonal that starts from `(0,0)` and continues `(1,1), (2,2)...`, but about all the diagonals we can start from any arbitrary position.\\n\\nWe have diagonals starting from any row in the **left-most** column, or any column in the **top-most** row.\\nSo one example of a left-most column diagonal is: `(3,0), (4,1), (5,2), ...`\\nAnd an example of a top-most diagonal will be: `(0, 4), (1,5), (2,6), ...`\\n\\nLet\\'s see a visual example:\\n![image](https://assets.leetcode.com/users/images/1da17b0a-f214-4d89-898d-e73b75050627_1661668070.9276383.png)\\n\\nBecause we have diagonals starting from any position in the first row and the first column, then we have `m + n - 1` diagonals. \\n`m` = number of rows\\n`n` = number of columns\\n`-1` = we double count the diagonal on (0,0) so we subtract 1\\n\\n## Sorting\\nUnderstanding we have `m-n-1` diagonals, every diagonal is a vector/array of numbers.\\n\\nWe can traverse all the diagonals one by one, store the values in each diagional in an array and then sort that array to represent the diagonal values in a sorted order.\\n\\nAfter sorting the values of the diagonal, we will push that sorted array to `diagonals` matrix which will be a matrix representing all the diagonals in the sorted order. `diagonals[0]` is the first diagonal array in a sorted order, and so on...\\n\\nAfter having the `diagonals`, we will traverse the matrix again by going over the diagonals one by one, and reassign the values in the sorted order with the help of the diagonals matrix we created.\\n\\nOnce you read the code, it will all make sense.\\n\\n`iterate_diagonal` - is a helper function that receives a row, col and iterates the diagonal starting from that position.\\n\\n```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        diagonals = []\\n        \\n        row, col = m-1, 0\\n        for _ in range(m + n - 1):\\n            diagonal = []\\n            self.iterate_diagonal(\\n                mat,\\n                row,\\n                col,\\n                lambda r, c, _: diagonal.append(mat[r][c])\\n            )\\n            diagonals.append(sorted(diagonal))\\n            \\n            if row != 0:\\n                row -= 1\\n            else:\\n                col += 1\\n    \\n    \\n        def assign_value(row, col, value):\\n            mat[row][col] = value\\n            \\n        row, col = m-1, 0\\n\\t\\t\\n\\t\\t# Reassign values\\n        for i in range(m + n - 1):\\n            self.iterate_diagonal(\\n                mat,\\n                row,\\n                col,\\n                lambda r, c, j: assign_value(r, c, diagonals[i][j])\\n            )\\n            if row != 0:\\n                row -= 1\\n            else:\\n                col += 1\\n        \\n        return mat\\n        \\n        \\n    def iterate_diagonal(self, mat, row, col, callback):\\n        m, n = len(mat), len(mat[0])\\n        r = row\\n        c = col\\n        i = 0\\n        \\n        while r < m and c < n:\\n            callback(r, c, i)\\n            r += 1\\n            c += 1\\n            i += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        diagonals = []\\n        \\n        row, col = m-1, 0\\n        for _ in range(m + n - 1):\\n            diagonal = []\\n            self.iterate_diagonal(\\n                mat,\\n                row,\\n                col,\\n                lambda r, c, _: diagonal.append(mat[r][c])\\n            )\\n            diagonals.append(sorted(diagonal))\\n            \\n            if row != 0:\\n                row -= 1\\n            else:\\n                col += 1\\n    \\n    \\n        def assign_value(row, col, value):\\n            mat[row][col] = value\\n            \\n        row, col = m-1, 0\\n\\t\\t\\n\\t\\t# Reassign values\\n        for i in range(m + n - 1):\\n            self.iterate_diagonal(\\n                mat,\\n                row,\\n                col,\\n                lambda r, c, j: assign_value(r, c, diagonals[i][j])\\n            )\\n            if row != 0:\\n                row -= 1\\n            else:\\n                col += 1\\n        \\n        return mat\\n        \\n        \\n    def iterate_diagonal(self, mat, row, col, callback):\\n        m, n = len(mat), len(mat[0])\\n        r = row\\n        c = col\\n        i = 0\\n        \\n        while r < m and c < n:\\n            callback(r, c, i)\\n            r += 1\\n            c += 1\\n            i += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493533,
                "title": "c-simple-solution-using-only-vectors",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int row=mat.size(),col=mat[0].size();\\n        int ch=0;\\n        int i=col-1,store=0;\\n        // starting from i=col-1 and then diagoally traversing \\n        while(ch<row){\\n            vector<int> v1;\\n            int k=ch;\\n            v1.push_back(mat[k][i]);\\n            k++;\\n            store=k;// to store the value of k as we will change  the matrix in this loop only \\n            for(int j=i+1;j<col && k<row;j++,k++){\\n                v1.push_back(mat[k][j]);\\n            }\\n            sort(v1.begin(),v1.end());\\n            k=store;\\n            int ind=1;\\n            mat[k-1][i]=v1[0];\\n            for(int j=i+1;j<col && k<row;j++,k++){\\n                mat[k][j]=v1[ind];\\n                ind++;\\n            }\\n            // if i reaches to zero than start going downwards by increasing ch \\n            if(i==0){\\n                ch++;\\n                continue;\\n            }\\n            i--;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int row=mat.size(),col=mat[0].size();\\n        int ch=0;\\n        int i=col-1,store=0;\\n        // starting from i=col-1 and then diagoally traversing \\n        while(ch<row){\\n            vector<int> v1;\\n            int k=ch;\\n            v1.push_back(mat[k][i]);\\n            k++;\\n            store=k;// to store the value of k as we will change  the matrix in this loop only \\n            for(int j=i+1;j<col && k<row;j++,k++){\\n                v1.push_back(mat[k][j]);\\n            }\\n            sort(v1.begin(),v1.end());\\n            k=store;\\n            int ind=1;\\n            mat[k-1][i]=v1[0];\\n            for(int j=i+1;j<col && k<row;j++,k++){\\n                mat[k][j]=v1[ind];\\n                ind++;\\n            }\\n            // if i reaches to zero than start going downwards by increasing ch \\n            if(i==0){\\n                ch++;\\n                continue;\\n            }\\n            i--;\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492690,
                "title": "go-map",
                "content": "```\\nfunc diagonalSort(mat [][]int) [][]int {\\n    diagonalMap := make(map[int][]int)\\n    \\n    for i := 0 ; i<len(mat) ; i++{\\n        for j:= 0 ; j<len(mat[i]) ; j++{\\n            diagonalMap[i-j] = append(diagonalMap[i-j] , mat[i][j])\\n        }\\n    }\\n    \\n    for _,val := range diagonalMap{\\n        sort.Ints(val)\\n    }\\n    for i:= 0 ;i<len(mat) ; i++{\\n        for j := 0 ; j<len(mat[i]);j++{\\n            mat[i][j] = diagonalMap[i-j][0]\\n            diagonalMap[i-j] = diagonalMap[i-j][1:]\\n        }\\n    }\\n    \\n\\n    return mat\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc diagonalSort(mat [][]int) [][]int {\\n    diagonalMap := make(map[int][]int)\\n    \\n    for i := 0 ; i<len(mat) ; i++{\\n        for j:= 0 ; j<len(mat[i]) ; j++{\\n            diagonalMap[i-j] = append(diagonalMap[i-j] , mat[i][j])\\n        }\\n    }\\n    \\n    for _,val := range diagonalMap{\\n        sort.Ints(val)\\n    }\\n    for i:= 0 ;i<len(mat) ; i++{\\n        for j := 0 ; j<len(mat[i]);j++{\\n            mat[i][j] = diagonalMap[i-j][0]\\n            diagonalMap[i-j] = diagonalMap[i-j][1:]\\n        }\\n    }\\n    \\n\\n    return mat\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2492338,
                "title": "java-simple-sorting-85-faster",
                "content": "```\\nclass Solution {\\n\\n    public int[][] diagonalSort(int[][] mat) {\\n        final int totalRows = mat.length;\\n        final int totalCols = mat[0].length;\\n\\n        List<Integer> diagonalElements;\\n        for (int r = 0; r < totalRows; r++) {\\n            int i = r;\\n            int j = 0;\\n\\n            diagonalElements = new ArrayList<>();\\n            while (i < totalRows && j < totalCols) diagonalElements.add(mat[i++][j++]);\\n            Collections.sort(diagonalElements);\\n\\n            i = r;\\n            j = 0;\\n            int k = 0;\\n\\n            while (i < totalRows && j < totalCols) mat[i++][j++] = diagonalElements.get(k++);\\n        }\\n\\n        for (int c = 0; c < totalCols; c++) {\\n            int i = 0;\\n            int j = c;\\n\\n            diagonalElements = new ArrayList<>();\\n            while (i < totalRows && j < totalCols) diagonalElements.add(mat[i++][j++]);\\n            Collections.sort(diagonalElements);\\n\\n            i = 0;\\n            j = c;\\n            int k = 0;\\n\\n            while (i < totalRows && j < totalCols) mat[i++][j++] = diagonalElements.get(k++);\\n        }\\n\\n        return mat;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[][] diagonalSort(int[][] mat) {\\n        final int totalRows = mat.length;\\n        final int totalCols = mat[0].length;\\n\\n        List<Integer> diagonalElements;\\n        for (int r = 0; r < totalRows; r++) {\\n            int i = r;\\n            int j = 0;\\n\\n            diagonalElements = new ArrayList<>();\\n            while (i < totalRows && j < totalCols) diagonalElements.add(mat[i++][j++]);\\n            Collections.sort(diagonalElements);\\n\\n            i = r;\\n            j = 0;\\n            int k = 0;\\n\\n            while (i < totalRows && j < totalCols) mat[i++][j++] = diagonalElements.get(k++);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2433648,
                "title": "easily-and-visualy-explained-with-a-simple-example",
                "content": "```\\n/*\\nQ.:- What we have to do is that we have to sort the matrix diagnally .\\n\\nAns.:- The idea is to divide the array into a single array and the input we will take into the 1-D array is based on the diagonals and we will give every 1d array a unique id so that after sorting the array we can retrive the element s from that array.\\n\\n\\nso for achiving this what we will take here is a unordered map and a min heap(  priority_queue <int, vector<int>, greater<int> > pq) \\n\\nmap   =       -----------------------------------------------------\\n              |            |                                      |\\n              |  int ,     |    min heap(in this min              |\\n              |            |      value be always on the top)     |\\n              |            |                                      |\\n              -----------------------------------------------------\\n               \\n\\ninput :- [[9,8,7],[6,5,4],[3,2,1]]\\n\\n \\n \\n\\nDRY Run:-\\n\\n\\n          for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[i].size();j+=1)\\n            {\\n                mp[i-j].push(mat[i][j]);\\n            }\\n        }\\n\\n          ----------------------------------------------------------------------------------|\\n          |                       |             |----------|                                |\\n          |          -2           |             |     7    |                                |\\n          |                       |             |----------|                                |\\n          |-----------------------|---------------------------------------------------------|\\n          |                       |              |    4    |                                |\\n          |          -1           |              |---------|                                |\\n          |                       |              |    8    |                                |\\n          |                       |               ----------                                |\\n          |-----------------------|---------------------------------------------------------|\\n          |                       |              |----------|                               |\\n          |                       |              |    1     |                               |\\n          |           0           |              |----------|                               |\\n          |                       |              |    5     |                               |\\n          |                       |              |----------|                               |\\n          |                       |              |    9     |                               |\\n          |                       |              -------------                              |\\n          |-----------------------|---------------------------------------------------------|\\n          |                       |             |     2     |                               |\\n          |                       |             |-----------|                               |\\n          |           1           |             |     6     |                               |\\n          |                       |             |-----------|                               |\\n          |-----------------------|---------------------------------------------------------|\\n          |                       |             |-----------|                               |\\n          |           2           |             |     3     |                               |\\n          |                       |             |           |                               |\\n          |                       |             |-----------|                               |\\n          |                       |                                                         |\\n          -----------------------------------------------------------------------------------\\n          \\n          \\n          \\n          \\n    this is how it will work\\n\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n          unordered_map<int,priority_queue <int, vector<int>, greater<int>>>mp;\\n        \\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[i].size();j+=1)\\n            {\\n                mp[i-j].push(mat[i][j]);\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[i].size();j+=1)\\n            {\\n                mat[i][j] =  mp[i-j].top();\\n                mp[i-j].pop();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```\\n\\n**PUT SO MUCH EFFORT TO EXPLAIN THIS PLEASE DO UPVOTE AND SUGGESTIONS ARE MOST WELCOME**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n/*\\nQ.:- What we have to do is that we have to sort the matrix diagnally .\\n\\nAns.:- The idea is to divide the array into a single array and the input we will take into the 1-D array is based on the diagonals and we will give every 1d array a unique id so that after sorting the array we can retrive the element s from that array.\\n\\n\\nso for achiving this what we will take here is a unordered map and a min heap(  priority_queue <int, vector<int>, greater<int> > pq) \\n\\nmap   =       -----------------------------------------------------\\n              |            |                                      |\\n              |  int ,     |    min heap(in this min              |\\n              |            |      value be always on the top)     |\\n              |            |                                      |\\n              -----------------------------------------------------\\n               \\n\\ninput :- [[9,8,7],[6,5,4],[3,2,1]]\\n\\n \\n \\n\\nDRY Run:-\\n\\n\\n          for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[i].size();j+=1)\\n            {\\n                mp[i-j].push(mat[i][j]);\\n            }\\n        }\\n\\n          ----------------------------------------------------------------------------------|\\n          |                       |             |----------|                                |\\n          |          -2           |             |     7    |                                |\\n          |                       |             |----------|                                |\\n          |-----------------------|---------------------------------------------------------|\\n          |                       |              |    4    |                                |\\n          |          -1           |              |---------|                                |\\n          |                       |              |    8    |                                |\\n          |                       |               ----------                                |\\n          |-----------------------|---------------------------------------------------------|\\n          |                       |              |----------|                               |\\n          |                       |              |    1     |                               |\\n          |           0           |              |----------|                               |\\n          |                       |              |    5     |                               |\\n          |                       |              |----------|                               |\\n          |                       |              |    9     |                               |\\n          |                       |              -------------                              |\\n          |-----------------------|---------------------------------------------------------|\\n          |                       |             |     2     |                               |\\n          |                       |             |-----------|                               |\\n          |           1           |             |     6     |                               |\\n          |                       |             |-----------|                               |\\n          |-----------------------|---------------------------------------------------------|\\n          |                       |             |-----------|                               |\\n          |           2           |             |     3     |                               |\\n          |                       |             |           |                               |\\n          |                       |             |-----------|                               |\\n          |                       |                                                         |\\n          -----------------------------------------------------------------------------------\\n          \\n          \\n          \\n          \\n    this is how it will work\\n\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n          unordered_map<int,priority_queue <int, vector<int>, greater<int>>>mp;\\n        \\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[i].size();j+=1)\\n            {\\n                mp[i-j].push(mat[i][j]);\\n            }\\n        }\\n        \\n        \\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[i].size();j+=1)\\n            {\\n                mat[i][j] =  mp[i-j].top();\\n                mp[i-j].pop();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737743,
                "title": "c-easy-to-understand-100-faster-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int idx=0;\\n        for(int i=m-1;i>=0;i--)\\n        {\\n            int j=i,k=0;\\n            vector<int> temp;\\n            while(j<m&&k<n)\\n            {\\n                temp.push_back(mat[k][j]);\\n                k++;\\n                j++;\\n            }\\n            sort(temp.begin(),temp.end());\\n            j=i;\\n            k=0;\\n            idx=0;\\n            while(j<m&&k<n)\\n            {\\n                mat[k][j]=temp[idx++];\\n                k++;\\n                j++;\\n            }\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            int j=0;\\n            int k=i;\\n            vector<int> temp;\\n            while(k<n&&j<m)\\n            {\\n                temp.push_back(mat[k][j]);\\n                k++;\\n                j++;\\n            }\\n            sort(temp.begin(),temp.end());\\n            k=i;\\n            j=0;\\n            idx=0;\\n            while(k<n&&j<m)\\n            {\\n                mat[k][j]=temp[idx++];\\n                k++;\\n                j++;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        int idx=0;\\n        for(int i=m-1;i>=0;i--)\\n        {\\n            int j=i,k=0;\\n            vector<int> temp;\\n            while(j<m&&k<n)\\n            {\\n                temp.push_back(mat[k][j]);\\n                k++;\\n                j++;\\n            }\\n            sort(temp.begin(),temp.end());\\n            j=i;\\n            k=0;\\n            idx=0;\\n            while(j<m&&k<n)\\n            {\\n                mat[k][j]=temp[idx++];\\n                k++;\\n                j++;\\n            }\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            int j=0;\\n            int k=i;\\n            vector<int> temp;\\n            while(k<n&&j<m)\\n            {\\n                temp.push_back(mat[k][j]);\\n                k++;\\n                j++;\\n            }\\n            sort(temp.begin(),temp.end());\\n            k=i;\\n            j=0;\\n            idx=0;\\n            while(k<n&&j<m)\\n            {\\n                mat[k][j]=temp[idx++];\\n                k++;\\n                j++;\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735898,
                "title": "beginner-friendly-java-javascript-python-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        HashMap<Integer, PriorityQueue<Integer>> map = new HashMap<>();\\n        for(int i=0; i<mat.length; i++){\\n            for(int j=0; j<mat[0].length; j++){\\n                map.putIfAbsent(i-j, new PriorityQueue<>());\\n                map.get(i-j).add(mat[i][j]);\\n            }\\n        }\\n        for(int i=0; i<mat.length; i++){\\n            for(int j=0; j<mat[0].length; j++){\\n                mat[i][j] = map.get(i-j).poll();\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar diagonalSort = function(mat) {\\n    let map = {};\\n    for(let i=0; i<mat.length; i++){\\n        for(let j=0; j<mat[0].length; j++){\\n            if(!map[i-j])    map[i-j] = [];\\n            map[i-j].push(mat[i][j]);\\n        }\\n    }\\n    for(let key in map){\\n        map[key].sort((a,b)=>{return a-b})\\n    }\\n    for(let i=0; i<mat.length; i++){\\n        for(let j=0; j<mat[0].length; j++){\\n            mat[i][j] = map[i-j].shift();\\n        }\\n    }\\n    return mat;\\n};\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def diagonalSort(self, mat):\\n        mymap = collections.defaultdict(list)\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                mymap[i-j].append(mat[i][j])\\n        for lst in mymap:\\n            mymap[lst].sort(reverse=1)\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                mat[i][j] = mymap[i-j].pop()\\n        return mat\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        HashMap<Integer, PriorityQueue<Integer>> map = new HashMap<>();\\n        for(int i=0; i<mat.length; i++){\\n            for(int j=0; j<mat[0].length; j++){\\n                map.putIfAbsent(i-j, new PriorityQueue<>());\\n                map.get(i-j).add(mat[i][j]);\\n            }\\n        }\\n        for(int i=0; i<mat.length; i++){\\n            for(int j=0; j<mat[0].length; j++){\\n                mat[i][j] = map.get(i-j).poll();\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```\n```\\nvar diagonalSort = function(mat) {\\n    let map = {};\\n    for(let i=0; i<mat.length; i++){\\n        for(let j=0; j<mat[0].length; j++){\\n            if(!map[i-j])    map[i-j] = [];\\n            map[i-j].push(mat[i][j]);\\n        }\\n    }\\n    for(let key in map){\\n        map[key].sort((a,b)=>{return a-b})\\n    }\\n    for(let i=0; i<mat.length; i++){\\n        for(let j=0; j<mat[0].length; j++){\\n            mat[i][j] = map[i-j].shift();\\n        }\\n    }\\n    return mat;\\n};\\n```\n```\\nclass Solution(object):\\n    def diagonalSort(self, mat):\\n        mymap = collections.defaultdict(list)\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                mymap[i-j].append(mat[i][j])\\n        for lst in mymap:\\n            mymap[lst].sort(reverse=1)\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                mat[i][j] = mymap[i-j].pop()\\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343341,
                "title": "easy-c-4ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        vector<int> v;\\n        int n=mat.size(),m=mat[0].size();\\n        for(int k=0;k<m;k++){\\n            int i=0,j=k;\\n            \\n            while(i<n && j<m){\\n                v.push_back(mat[i][j]);\\n                i++;\\n                j++;\\n            }\\n            sort(v.begin(),v.end());\\n            \\n            i=0,j=k;\\n            \\n            while(i<n && j<m){\\n                mat[i][j]=v[i];\\n                i++;\\n                j++;\\n            }\\n            v.clear();\\n            \\n        }\\n        for(int k=1;k<n;k++){\\n            int i=k,j=0;\\n            while(i<n && j<m){\\n                v.push_back(mat[i][j]);\\n                i++;\\n                j++;\\n            }\\n            sort(v.begin(),v.end());\\n            \\n            i=k,j=0;\\n            int p=0;\\n            \\n            while(i<n && j<m){\\n                mat[i][j]=v[p];\\n                p++;\\n                i++;\\n                j++;\\n            }\\n            v.clear();\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        vector<int> v;\\n        int n=mat.size(),m=mat[0].size();\\n        for(int k=0;k<m;k++){\\n            int i=0,j=k;\\n            \\n            while(i<n && j<m){\\n                v.push_back(mat[i][j]);\\n                i++;\\n                j++;\\n            }\\n            sort(v.begin(),v.end());\\n            \\n            i=0,j=k;\\n            \\n            while(i<n && j<m){\\n                mat[i][j]=v[i];\\n                i++;\\n                j++;\\n            }\\n            v.clear();\\n            \\n        }\\n        for(int k=1;k<n;k++){\\n            int i=k,j=0;\\n            while(i<n && j<m){\\n                v.push_back(mat[i][j]);\\n                i++;\\n                j++;\\n            }\\n            sort(v.begin(),v.end());\\n            \\n            i=k,j=0;\\n            int p=0;\\n            \\n            while(i<n && j<m){\\n                mat[i][j]=v[p];\\n                p++;\\n                i++;\\n                j++;\\n            }\\n            v.clear();\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1196190,
                "title": "super-easy-python-solution",
                "content": "```\\n def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        \\n        def sort_diag(r, c):\\n            d = []\\n            r1, c1 = r, c\\n            while r < len(mat) and c < len(mat[0]):\\n                d.append(mat[r][c])\\n                r += 1\\n                c += 1\\n            \\n            for n in sorted(d):\\n                mat[r1][c1] = n\\n                r1 += 1\\n                c1 += 1\\n        \\n        for i in range(len(mat[0])): sort_diag(0, i)\\n        for i in range(1, len(mat)): sort_diag(i, 0)\\n\\n        return mat\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        \\n        def sort_diag(r, c):\\n            d = []\\n            r1, c1 = r, c\\n            while r < len(mat) and c < len(mat[0]):\\n                d.append(mat[r][c])\\n                r += 1\\n                c += 1\\n            \\n            for n in sorted(d):\\n                mat[r1][c1] = n\\n                r1 += 1\\n                c1 += 1\\n        \\n        for i in range(len(mat[0])): sort_diag(0, i)\\n        for i in range(1, len(mat)): sort_diag(i, 0)\\n\\n        return mat\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1148034,
                "title": "c-fastest-map-solution-explained",
                "content": "![image](https://assets.leetcode.com/users/images/3a173216-f8a9-488b-abc0-778e87dcb101_1617858832.6890733.png)\\n\\nMake a map which stores elements according to the index (i-j) .\\nsort them and append elements in mat matrix.\\n\\n\\n\\n```\\nunordered_map<int, vector<int>> mp;\\nvector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n    int m=mat.size();\\n    int n=mat[0].size();\\n    \\n    for(int i=0;i<m;i++) {\\n        for(int j=0;j<n;j++) {\\n            mp[i-j].push_back(mat[i][j]);\\n        }\\n    }\\n    \\n    for(int k=-(n-1);k<m;k++) {\\n        sort(mp[k].begin(),mp[k].end());\\n    }\\n    \\n    for(int i=m-1;i>=0;i--) {\\n        for(int j=n-1;j>=0;j--) {\\n            mat[i][j]=mp[i-j].back();\\n            mp[i-j].pop_back();\\n        }\\n    }\\n    return mat;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nunordered_map<int, vector<int>> mp;\\nvector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n    int m=mat.size();\\n    int n=mat[0].size();\\n    \\n    for(int i=0;i<m;i++) {\\n        for(int j=0;j<n;j++) {\\n            mp[i-j].push_back(mat[i][j]);\\n        }\\n    }\\n    \\n    for(int k=-(n-1);k<m;k++) {\\n        sort(mp[k].begin(),mp[k].end());\\n    }\\n    \\n    for(int i=m-1;i>=0;i--) {\\n        for(int j=n-1;j>=0;j--) {\\n            mat[i][j]=mp[i-j].back();\\n            mp[i-j].pop_back();\\n        }\\n    }\\n    return mat;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1079847,
                "title": "python-3-collect-and-sort-diagonally",
                "content": "Start from Bottom Left to Top Right of the matrix, the difference between index i and j is changing from ```m - 1``` to ```1 - n```, each difference stands for a \"diagonal\".\\nCollect each number in that diagonal and sort, then traverse again to reassign the values.\\n\\n```\\ndef diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        for diff in range(m - 1, -n, -1):\\n\\t\\t#collect and sort\\n            i, j, cur = max(diff, 0), max(diff, 0), []\\n            while i < m and j < n:\\n                cur.append(mat[i][j])\\n                i += 1\\n                j += 1\\n            cur.sort()\\n\\t\\t#re-assign\\n            i, j, idx = max(diff, 0), max(diff, 0), 0\\n            while i < m and j < n:\\n                mat[i][j] = cur[idx]\\n                idx += 1\\n                i += 1\\n                j += 1\\n        return mat\\n```",
                "solutionTags": [],
                "code": "```m - 1```\n```1 - n```\n```\\ndef diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        m, n = len(mat), len(mat[0])\\n        for diff in range(m - 1, -n, -1):\\n\\t\\t#collect and sort\\n            i, j, cur = max(diff, 0), max(diff, 0), []\\n            while i < m and j < n:\\n                cur.append(mat[i][j])\\n                i += 1\\n                j += 1\\n            cur.sort()\\n\\t\\t#re-assign\\n            i, j, idx = max(diff, 0), max(diff, 0), 0\\n            while i < m and j < n:\\n                mat[i][j] = cur[idx]\\n                idx += 1\\n                i += 1\\n                j += 1\\n        return mat\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1030930,
                "title": "sort-the-matrix-diagonally-c-solution",
                "content": "1. For all the elements from a diagonal, the value of row-col will be same.\\n2. Store all elements by row-col as key in a map\\n3. sort all the elements from the map\\n4. Fill the matrix again using sorted elements from the map\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        unordered_map<int, vector<int>> umap;\\n        for (int i = 0; i < mat.size(); i++) {\\n            for (int j = 0; j < mat[0].size(); j++) {\\n                umap[i-j].push_back(mat[i][j]);\\n            }\\n        }\\n        for (auto &it: umap) {\\n            sort(it.second.begin(), it.second.end());\\n        }\\n        for (int i = 0; i < mat.size(); i++) {\\n            for (int j = 0; j < mat[0].size(); j++) {\\n                mat[i][j] = umap[i-j][0];\\n                umap[i-j].erase(umap[i-j].begin());\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        unordered_map<int, vector<int>> umap;\\n        for (int i = 0; i < mat.size(); i++) {\\n            for (int j = 0; j < mat[0].size(); j++) {\\n                umap[i-j].push_back(mat[i][j]);\\n            }\\n        }\\n        for (auto &it: umap) {\\n            sort(it.second.begin(), it.second.end());\\n        }\\n        for (int i = 0; i < mat.size(); i++) {\\n            for (int j = 0; j < mat[0].size(); j++) {\\n                mat[i][j] = umap[i-j][0];\\n                umap[i-j].erase(umap[i-j].begin());\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030650,
                "title": "c-solution-faster-than-99",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        \\n        int i,j=0,k=0;\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        \\n        //First Do for upper triangular part\\n        for(i=0;j<m;j++)\\n        {\\n            vector<int> v;\\n            k=0;\\n            while(i+k<n && j+k<m)       // first store the diagonal part in a vector\\n            {\\n                v.push_back(mat[i+k][j+k]);      \\n                k++;\\n            }\\n            sort(v.begin(),v.end());            // secondly sort the vector\\n\\n            k=0;\\n            while(k<v.size())           // and after sorting, push back the sorted\\n            {                           // vector in the matrix\\n                mat[i+k][j+k]=v[k];\\n                k++;\\n            }\\n        }\\n        i=1;\\n        //for lower triangular part\\n        for(j=0;i<n;i++)\\n        {\\n            vector<int> v;\\n            k=0;\\n            while(i+k<n && j+k<m)\\n            {\\n                v.push_back(mat[i+k][j+k]);\\n                k++;\\n            }\\n            sort(v.begin(),v.end());\\n\\n            k=0;\\n            while(k<v.size())\\n            {\\n                mat[i+k][j+k]=v[k];\\n                k++;\\n            }\\n        }\\n        \\n        \\n        return mat;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        \\n        int i,j=0,k=0;\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        \\n        //First Do for upper triangular part\\n        for(i=0;j<m;j++)\\n        {\\n            vector<int> v;\\n            k=0;\\n            while(i+k<n && j+k<m)       // first store the diagonal part in a vector\\n            {\\n                v.push_back(mat[i+k][j+k]);      \\n                k++;\\n            }\\n            sort(v.begin(),v.end());            // secondly sort the vector\\n\\n            k=0;\\n            while(k<v.size())           // and after sorting, push back the sorted\\n            {                           // vector in the matrix\\n                mat[i+k][j+k]=v[k];\\n                k++;\\n            }\\n        }\\n        i=1;\\n        //for lower triangular part\\n        for(j=0;i<n;i++)\\n        {\\n            vector<int> v;\\n            k=0;\\n            while(i+k<n && j+k<m)\\n            {\\n                v.push_back(mat[i+k][j+k]);\\n                k++;\\n            }\\n            sort(v.begin(),v.end());\\n\\n            k=0;\\n            while(k<v.size())\\n            {\\n                mat[i+k][j+k]=v[k];\\n                k++;\\n            }\\n        }\\n        \\n        \\n        return mat;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 951000,
                "title": "c-easiest-solution-using-maps-and-deque-with-good-explanation",
                "content": "```\\n/*\\nEach element ina a diagonal has the same i-j difference. Store it in a map{i-j , all elements}\\nstore elements in a deque for convenience.For each i-j sort all elements in the corresponding deque;\\nnow store the elements in the result 2dvector.\\n*/\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m = mat.size() , n =mat[0].size();\\n        if(m==0 || n==0) return {};\\n        unordered_map<int , deque<int>> diag ; \\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) \\n            {\\n                diag[i-j].push_back(mat[i][j]);\\n            }\\n        }\\n    for(auto &[key,val] : diag) {\\n        sort(val.begin(),val.end());\\n    }\\n    vector<vector<int>> result(m,vector<int>(n));\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                auto &v = diag[i-j];\\n                result[i][j] = v.front();\\n                v.pop_front();\\n            }\\n        }\\n         \\n    return result;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\n/*\\nEach element ina a diagonal has the same i-j difference. Store it in a map{i-j , all elements}\\nstore elements in a deque for convenience.For each i-j sort all elements in the corresponding deque;\\nnow store the elements in the result 2dvector.\\n*/\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m = mat.size() , n =mat[0].size();\\n        if(m==0 || n==0) return {};\\n        unordered_map<int , deque<int>> diag ; \\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) \\n            {\\n                diag[i-j].push_back(mat[i][j]);\\n            }\\n        }\\n    for(auto &[key,val] : diag) {\\n        sort(val.begin(),val.end());\\n    }\\n    vector<vector<int>> result(m,vector<int>(n));\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                auto &v = diag[i-j];\\n                result[i][j] = v.front();\\n                v.pop_front();\\n            }\\n        }\\n         \\n    return result;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872544,
                "title": "c-start-from-corners-10-lines-beats-all",
                "content": "```\\nclass Solution {\\n    vector<int> t;\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        for(int i=n-1; i>-1; i--,t.clear()) {\\n            for(int ii=i,j=0; ii<n&&j<m; ii++,j++) t.push_back(mat[ii][j]);\\n            sort(t.begin(),t.end());\\n            for(int ii=i,j=0; ii<n&&j<m; ii++,j++) mat[ii][j] = t[j];\\n        }\\n        for(int i=m-1; i>-1; i--,t.clear()) {\\n            for(int ii=i,j=0; ii<m&&j<n; ii++,j++) t.push_back(mat[j][ii]);\\n            sort(t.begin(),t.end());\\n            for(int ii=i,j=0; ii<m&&j<n; ii++,j++) mat[j][ii] = t[j];\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> t;\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        for(int i=n-1; i>-1; i--,t.clear()) {\\n            for(int ii=i,j=0; ii<n&&j<m; ii++,j++) t.push_back(mat[ii][j]);\\n            sort(t.begin(),t.end());\\n            for(int ii=i,j=0; ii<n&&j<m; ii++,j++) mat[ii][j] = t[j];\\n        }\\n        for(int i=m-1; i>-1; i--,t.clear()) {\\n            for(int ii=i,j=0; ii<m&&j<n; ii++,j++) t.push_back(mat[j][ii]);\\n            sort(t.begin(),t.end());\\n            for(int ii=i,j=0; ii<m&&j<n; ii++,j++) mat[j][ii] = t[j];\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 838892,
                "title": "java-very-easy-to-understand-98",
                "content": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        \\n        final Map<Integer, Queue<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                final int key = i - j;\\n                \\n                if(map.containsKey(key)) {\\n                    map.get(key).add(mat[i][j]);\\n                } else {\\n                    final Queue<Integer> queue = new PriorityQueue<>();\\n                    queue.add(mat[i][j]);\\n                    map.put(key, queue);\\n                }\\n                \\n                mat[i][j] = key;\\n            }\\n        }\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                final int key = mat[i][j];\\n                \\n                mat[i][j] = map.get(key).poll();\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        \\n        final Map<Integer, Queue<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                final int key = i - j;\\n                \\n                if(map.containsKey(key)) {\\n                    map.get(key).add(mat[i][j]);\\n                } else {\\n                    final Queue<Integer> queue = new PriorityQueue<>();\\n                    queue.add(mat[i][j]);\\n                    map.put(key, queue);\\n                }\\n                \\n                mat[i][j] = key;\\n            }\\n        }\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n            for(int j = 0; j < mat[0].length; j++) {\\n                final int key = mat[i][j];\\n                \\n                mat[i][j] = map.get(key).poll();\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 591701,
                "title": "c-speed-mem-83-98-100-with-o-mn-video",
                "content": "https://www.youtube.com/watch?v=PrAEHUR3IzU\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        \\n        int col = 0;\\n        int row = 0;\\n        vector<int> tmp;\\n        \\n        \\n        \\n        // cover every diagonal in col 0 (every row)\\n        for(int i=0; i < mat.size(); i++){\\n            row = i;\\n            col = 0;\\n            \\n            // store each val in diagonal\\n            while(row != mat.size() && col != mat[0].size() )\\n                tmp.push_back(mat[row++][col++]);\\n                                 \\n            sort(tmp.begin(),tmp.end(),less<int>());\\n            row = i;\\n            col = 0;\\n            \\n            // assign sorted val to diagonal\\n            for(int x=0; x < tmp.size(); x++)\\n                mat[row++][col++] = tmp[x];\\n            \\n            tmp.clear();\\n                        \\n        }\\n        \\n        // cover every diagonal in row 0 (every col) \\n        // starting from col 1 position\\n        for(int j=1; j < mat[0].size(); j++){\\n            row = 0;\\n            col = j;\\n            \\n            // store each val in diagonal\\n            while(row != mat.size() && col != mat[0].size() )\\n                tmp.push_back(mat[row++][col++]);\\n            \\n            sort(tmp.begin(),tmp.end(),less<int>());\\n            row = 0;\\n            col = j;\\n            \\n            // assign sorted val to diagonal\\n            for(int x=0; x < tmp.size(); x++)\\n                mat[row++][col++] = tmp[x];\\n                        \\n            tmp.clear();            \\n            \\n        }\\n        \\n        return  mat;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        \\n        int col = 0;\\n        int row = 0;\\n        vector<int> tmp;\\n        \\n        \\n        \\n        // cover every diagonal in col 0 (every row)\\n        for(int i=0; i < mat.size(); i++){\\n            row = i;\\n            col = 0;\\n            \\n            // store each val in diagonal\\n            while(row != mat.size() && col != mat[0].size() )\\n                tmp.push_back(mat[row++][col++]);\\n                                 \\n            sort(tmp.begin(),tmp.end(),less<int>());\\n            row = i;\\n            col = 0;\\n            \\n            // assign sorted val to diagonal\\n            for(int x=0; x < tmp.size(); x++)\\n                mat[row++][col++] = tmp[x];\\n            \\n            tmp.clear();\\n                        \\n        }\\n        \\n        // cover every diagonal in row 0 (every col) \\n        // starting from col 1 position\\n        for(int j=1; j < mat[0].size(); j++){\\n            row = 0;\\n            col = j;\\n            \\n            // store each val in diagonal\\n            while(row != mat.size() && col != mat[0].size() )\\n                tmp.push_back(mat[row++][col++]);\\n            \\n            sort(tmp.begin(),tmp.end(),less<int>());\\n            row = 0;\\n            col = j;\\n            \\n            // assign sorted val to diagonal\\n            for(int x=0; x < tmp.size(); x++)\\n                mat[row++][col++] = tmp[x];\\n                        \\n            tmp.clear();            \\n            \\n        }\\n        \\n        return  mat;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 541470,
                "title": "naive-c-solution-99-3-cpu-100-ram",
                "content": "```\\npublic class Solution {\\n    public int[][] DiagonalSort(int[][] mat) {\\n        int rows = mat.Length;\\n        int cols = mat[0].Length;\\n        \\n        for(int row = 0; row < rows; row++) {\\n            var diagonal = ReadDiagonal(mat, row, 0, rows, cols);\\n            diagonal.Sort();\\n            ReplaceDiagonal(mat, diagonal, row, 0);\\n        }\\n        \\n        for(int col = 1; col < cols; col++) {\\n            var diagonal = ReadDiagonal(mat, 0, col, rows, cols);\\n            diagonal.Sort();\\n            ReplaceDiagonal(mat, diagonal, 0, col);\\n        }\\n        \\n        return mat;\\n    }\\n    \\n    private List<int> ReadDiagonal(int[][]mat, int row, int col, int maxRow, int maxCol) {\\n        List<int> result = new List<int>();\\n        \\n        while(row < maxRow && col < maxCol) {\\n            result.Add(mat[row++][col++]);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void ReplaceDiagonal(int[][] mat, IEnumerable<int> newDiag, int startRow, int startCol) {\\n        foreach(var val in newDiag) {\\n            mat[startRow++][startCol++] = val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] DiagonalSort(int[][] mat) {\\n        int rows = mat.Length;\\n        int cols = mat[0].Length;\\n        \\n        for(int row = 0; row < rows; row++) {\\n            var diagonal = ReadDiagonal(mat, row, 0, rows, cols);\\n            diagonal.Sort();\\n            ReplaceDiagonal(mat, diagonal, row, 0);\\n        }\\n        \\n        for(int col = 1; col < cols; col++) {\\n            var diagonal = ReadDiagonal(mat, 0, col, rows, cols);\\n            diagonal.Sort();\\n            ReplaceDiagonal(mat, diagonal, 0, col);\\n        }\\n        \\n        return mat;\\n    }\\n    \\n    private List<int> ReadDiagonal(int[][]mat, int row, int col, int maxRow, int maxCol) {\\n        List<int> result = new List<int>();\\n        \\n        while(row < maxRow && col < maxCol) {\\n            result.Add(mat[row++][col++]);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void ReplaceDiagonal(int[][] mat, IEnumerable<int> newDiag, int startRow, int startCol) {\\n        foreach(var val in newDiag) {\\n            mat[startRow++][startCol++] = val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 530636,
                "title": "javascript-using-map-to-set-arrays-with-sorted-diagonals",
                "content": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number[][]}\\n */\\nvar diagonalSort = function(mat) {\\n\\n    /*to store values from diagonal*/\\n    let diagonals = new Map();\\n    \\n    for(let i = 0; i < mat.length; i++) {\\n        for(let j = 0; j < mat[i].length; j++) {\\n\\t\\t\\n\\t\\t  /*every value on diagonal has same i-j  result*/\\n          if (diagonals.has(i-j)) {\\n\\t\\t  \\n\\t\\t      /*push value to coresponding array in Map*/\\n              diagonals.get(i-j).push(mat[i][j])\\n          } else {\\n\\t\\t  \\n\\t\\t      /*if Map does not contain key with i-j, set new and assing array to value*/\\n              diagonals.set(i-j, new Array);\\n\\t\\t\\t  \\n\\t\\t\\t  /*and push value to array*/\\n              diagonals.get(i-j).push(mat[i][j]);\\n          }\\n        }\\n    }\\n    \\n\\t/*sort values in diagonals in place*/\\n    diagonals.forEach(e => e = e.sort((a,b) => a-b));\\n     \\n\\t/*reassign values of diagonals with sorted values*/\\n    for(let i = 0; i < mat.length; i++) {\\n        for(let j = 0; j < mat[i].length; j++) {\\n          mat[i][j] = diagonals.get(i-j).shift();\\n        }\\n    }\\n    \\n    return mat;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number[][]}\\n */\\nvar diagonalSort = function(mat) {\\n\\n    /*to store values from diagonal*/\\n    let diagonals = new Map();\\n    \\n    for(let i = 0; i < mat.length; i++) {\\n        for(let j = 0; j < mat[i].length; j++) {\\n\\t\\t\\n\\t\\t  /*every value on diagonal has same i-j  result*/\\n          if (diagonals.has(i-j)) {\\n\\t\\t  \\n\\t\\t      /*push value to coresponding array in Map*/\\n              diagonals.get(i-j).push(mat[i][j])\\n          } else {\\n\\t\\t  \\n\\t\\t      /*if Map does not contain key with i-j, set new and assing array to value*/\\n              diagonals.set(i-j, new Array);\\n\\t\\t\\t  \\n\\t\\t\\t  /*and push value to array*/\\n              diagonals.get(i-j).push(mat[i][j]);\\n          }\\n        }\\n    }\\n    \\n\\t/*sort values in diagonals in place*/\\n    diagonals.forEach(e => e = e.sort((a,b) => a-b));\\n     \\n\\t/*reassign values of diagonals with sorted values*/\\n    for(let i = 0; i < mat.length; i++) {\\n        for(let j = 0; j < mat[i].length; j++) {\\n          mat[i][j] = diagonals.get(i-j).shift();\\n        }\\n    }\\n    \\n    return mat;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 490405,
                "title": "python-simple-human-readable-code-explained-achieved-100-100",
                "content": "This question is more about travering the elements diagonally.\\nOnce we know how to traverse, we can simply follow the steps- \\nSteps - \\n1. Traverse each diagonal\\n2. Get elements\\n3. Sort the elements\\n4. Put them back in the diagonal\\n\\n```\\nclass Solution(object):\\n    def diagonalSort(self, mat):\\n        \\n        rows = len(mat)\\n        cols = len(mat[0])\\n        \\n        # looing over the top\\n        for diagonal in range(cols):\\n            \\n            # getting the diagonal elements in a list\\n            l = []\\n            i = 0\\n            j = diagonal\\n            while i < rows and j < cols:\\n                l.append(mat[i][j])\\n                i += 1\\n                j += 1\\n            \\n            # sorting and putting back the elements\\n            l.sort()\\n            i = k = 0\\n            j = diagonal\\n            while i < rows and j < cols:\\n                mat[i][j] = l[k]\\n                i += 1\\n                j += 1\\n                k += 1\\n                        \\n        # looing over the right side\\n        for diagonal in range(rows):\\n            \\n            # getting the diagonal elements in a list\\n            l = []\\n            i = diagonal\\n            j = 0\\n            while i < rows and j < cols:\\n                l.append(mat[i][j])\\n                i += 1\\n                j += 1\\n            \\n            # sorting and putting back the elements\\n            l.sort()\\n            j = k = 0\\n            i = diagonal\\n            while i < rows and j < cols:\\n                mat[i][j] = l[k]\\n                i += 1\\n                j += 1\\n                k += 1\\n                        \\n        return mat\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def diagonalSort(self, mat):\\n        \\n        rows = len(mat)\\n        cols = len(mat[0])\\n        \\n        # looing over the top\\n        for diagonal in range(cols):\\n            \\n            # getting the diagonal elements in a list\\n            l = []\\n            i = 0\\n            j = diagonal\\n            while i < rows and j < cols:\\n                l.append(mat[i][j])\\n                i += 1\\n                j += 1\\n            \\n            # sorting and putting back the elements\\n            l.sort()\\n            i = k = 0\\n            j = diagonal\\n            while i < rows and j < cols:\\n                mat[i][j] = l[k]\\n                i += 1\\n                j += 1\\n                k += 1\\n                        \\n        # looing over the right side\\n        for diagonal in range(rows):\\n            \\n            # getting the diagonal elements in a list\\n            l = []\\n            i = diagonal\\n            j = 0\\n            while i < rows and j < cols:\\n                l.append(mat[i][j])\\n                i += 1\\n                j += 1\\n            \\n            # sorting and putting back the elements\\n            l.sort()\\n            j = k = 0\\n            i = diagonal\\n            while i < rows and j < cols:\\n                mat[i][j] = l[k]\\n                i += 1\\n                j += 1\\n                k += 1\\n                        \\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 490089,
                "title": "dew-it-sort-each-diagonal-only-primitives",
                "content": "The largest diagonal has the length X, where X is min(M, N)\\nTime Complexity = MNlog(X) | Extra Space = X\\n\\n```\\nclass Solution {\\n    int m, n;\\n    int[] arr;\\n    int[][] grid;\\n    \\n    public int[][] diagonalSort(int[][] mat) {\\n        m = mat.length;\\n        n = mat[0].length;\\n        arr = new int[Math.min(m, n)];\\n        this.grid = mat;\\n        dew(0, 0);\\n        for(int i=1; i<m; ++i) dew(i, 0);\\n        for(int j=1; j<n; ++j) dew(0, j);\\n        return mat;\\n    }\\n    \\n    private void dew(int i, int j) {\\n        int count = 0, a = i, b = j;\\n        while(i < m && j < n) {\\n            arr[count++] = grid[i][j];\\n            ++i;\\n            ++j;\\n        }\\n        Arrays.sort(arr, 0, count);\\n        count = 0;\\n        while(a < m && b < n) {\\n            grid[a][b] = arr[count++];\\n            ++a;\\n            ++b;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int m, n;\\n    int[] arr;\\n    int[][] grid;\\n    \\n    public int[][] diagonalSort(int[][] mat) {\\n        m = mat.length;\\n        n = mat[0].length;\\n        arr = new int[Math.min(m, n)];\\n        this.grid = mat;\\n        dew(0, 0);\\n        for(int i=1; i<m; ++i) dew(i, 0);\\n        for(int j=1; j<n; ++j) dew(0, j);\\n        return mat;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3922197,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Hashmap\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:94.27%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:86.07%\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        d=defaultdict(list)\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                d[i-j].append(mat[i][j])\\n        for i in d.values():\\n            i.sort()\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                v=d[i-j].pop(0)\\n                mat[i][j]=v\\n        return mat\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        d=defaultdict(list)\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                d[i-j].append(mat[i][j])\\n        for i in d.values():\\n            i.sort()\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                v=d[i-j].pop(0)\\n                mat[i][j]=v\\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526647,
                "title": "efficient-and-simple-solution-with-best-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The idea is fairly simple, we pick up every diagonal, sort it and place it back.\\n- The approach I took for this problem brushes up your sorting skills and matrix traversal.\\n- This solution contains inplace mergeSort code with heavy comments.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1.   The \\'**diagonalSort**\\' method takes a 2D array (mat) as input and returns a sorted version of the array.\\n2.  The first for loop iterates over the columns of the matrix (mat) starting from the first column.\\n3.  Inside the loop, it finds the diagonal elements starting from the top row (si = 0) and the current column (sj = j).\\n4.  The \\'**findDiag**\\' method is called to retrieve the diagonal elements of the matrix and store them in an array (d).\\n5. The \\'**mergeSort**\\' method is called to sort the diagonal elements in ascending order.\\n6.  The \\'**fillDiag**\\' method is called to fill the sorted diagonal elements back into the matrix.\\n7.  The second for loop iterates over the rows of the matrix starting from the second row.\\n8.  Inside the loop, it finds the diagonal elements starting from the current row (si = i) and the first column (sj = 0).\\n9.  Steps 6-8 are repeated for this diagonal as well.\\n10. Finally, the sorted matrix (mat) is returned.\\n11. The \\'**fillDiag**\\' method fills the sorted diagonal elements (d) back into the matrix starting from the specified row and column indices (i and j).\\n12. The \\'**findDiag**\\' method retrieves the diagonal elements of the matrix starting from the specified row and column indices (si and sj) and returns them in an array (d).\\n13. The \\'**mergeSort**\\' method sorts the given array (a) using the merge sort algorithm recursively.\\n14. The \\'**mergeSorted**\\' method merges two sorted subarrays (a[s1:e1] and a[s2:e2]) into a single sorted array.\\n15. It uses a temporary array (ans) to store the merged elements and then copies them back to the original array (a) starting from the specified index (s1).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(max(n,m) * dlog(d)) ;  where d is maximum length of any diagonal.\\n\\nd = min(m,n)\\n\\n**O(n * m * log(m))** //n>m\\n**O(n * m * log(n))** //n<m\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n The sorting done in this code is inplace without need of extra arrays for merging.\\n Only extra space needed is to store a diagonal for its processing.\\n \\n **O(max(m,n))**\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        //Every diagonal starts either at 0th row or 0th column\\n\\n        // looping for diagonals that start at 0th row\\n        for(int j = 0;j<mat[0].length;j++){\\n            int si = 0,sj = j;//starting point of diagonal\\n            int d[] = findDiag(mat,si,sj);//array containing diagonal elements\\n            mergeSort(d,0,d.length-1);//sort this diagonal\\n            fillDiag(mat,d,si,sj);//place it back in the matrix at its original place\\n        }\\n\\n        //repeat for diagonals at 0th column, skip the one starting at 0,0 as its already processed\\n        for(int i = 1;i<mat.length;i++){\\n            int si = i,sj = 0;\\n            int d[] = findDiag(mat,si,sj);\\n            mergeSort(d,0,d.length-1);\\n            fillDiag(mat,d,si,sj);\\n        }\\n        return mat;\\n    }\\n\\n    //utility function to place the sorted diagonal elements back into matrix\\n    public void fillDiag(int [][]mat,int []d,int i,int j){\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        int len = Math.min(n-i,m-j);//length of this diagonal \\n        int k = 0;\\n        while(i<n && j<m){ //traversing diagonally\\n            mat[i++][j++] = d[k++];\\n        }\\n    }\\n    // function to pick up a diagonal starting at (si,sj)\\n    public int[] findDiag(int[][] mat,int si,int sj){\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        int len = Math.min(n-si,m-sj);\\n        int d[] = new int[len];//array to store this diagonal\\n        int k =0;\\n        while(si<n && sj<m){\\n            d[k++] = mat[si][sj];\\n            si = si+1;sj = sj+1;\\n        }\\n        return d;\\n    }\\n\\n    public void mergeSort(int a[],int s,int e){\\n        if(s>=e){ //empty array or array with one element(already sorted)\\n            return;\\n        }\\n        int m = s + (e-s)/2;//find middle element\\n        mergeSort(a,s,m); //sort first half\\n        mergeSort(a,m+1,e); //sort second half\\n        mergeSorted(a,s,m,m+1,e); //merge both sorted halves\\n    //note: we alter the length of the array virtually using indices without making copies \\n    }\\n\\n    //inplace merging of sorted halves\\n    public void mergeSorted(int []a,int s1,int e1,int s2,int e2){\\n        int i = s1,j = s2,k=0;\\n        int len = e1-s1 +1 + (e2-s2+1);\\n        int ans[]  = new int[len];\\n        while(i<=e1 && j<=e2){\\n            if(a[i]<a[j]){\\n                ans[k++]= a[i];\\n                i++;\\n            }\\n            else{\\n                ans[k++]= a[j];\\n                j++;\\n            }\\n        }\\n        while(i<=e1){\\n            ans[k++]= a[i];\\n            i++;\\n        }\\n        while(j<=e2){\\n            ans[k++]= a[j];\\n            j++;\\n        }\\n\\n        for(i = 0;i<len;i++){\\n            a[s1++] = ans[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting",
                    "Merge Sort",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        //Every diagonal starts either at 0th row or 0th column\\n\\n        // looping for diagonals that start at 0th row\\n        for(int j = 0;j<mat[0].length;j++){\\n            int si = 0,sj = j;//starting point of diagonal\\n            int d[] = findDiag(mat,si,sj);//array containing diagonal elements\\n            mergeSort(d,0,d.length-1);//sort this diagonal\\n            fillDiag(mat,d,si,sj);//place it back in the matrix at its original place\\n        }\\n\\n        //repeat for diagonals at 0th column, skip the one starting at 0,0 as its already processed\\n        for(int i = 1;i<mat.length;i++){\\n            int si = i,sj = 0;\\n            int d[] = findDiag(mat,si,sj);\\n            mergeSort(d,0,d.length-1);\\n            fillDiag(mat,d,si,sj);\\n        }\\n        return mat;\\n    }\\n\\n    //utility function to place the sorted diagonal elements back into matrix\\n    public void fillDiag(int [][]mat,int []d,int i,int j){\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        int len = Math.min(n-i,m-j);//length of this diagonal \\n        int k = 0;\\n        while(i<n && j<m){ //traversing diagonally\\n            mat[i++][j++] = d[k++];\\n        }\\n    }\\n    // function to pick up a diagonal starting at (si,sj)\\n    public int[] findDiag(int[][] mat,int si,int sj){\\n        int n = mat.length;\\n        int m = mat[0].length;\\n        int len = Math.min(n-si,m-sj);\\n        int d[] = new int[len];//array to store this diagonal\\n        int k =0;\\n        while(si<n && sj<m){\\n            d[k++] = mat[si][sj];\\n            si = si+1;sj = sj+1;\\n        }\\n        return d;\\n    }\\n\\n    public void mergeSort(int a[],int s,int e){\\n        if(s>=e){ //empty array or array with one element(already sorted)\\n            return;\\n        }\\n        int m = s + (e-s)/2;//find middle element\\n        mergeSort(a,s,m); //sort first half\\n        mergeSort(a,m+1,e); //sort second half\\n        mergeSorted(a,s,m,m+1,e); //merge both sorted halves\\n    //note: we alter the length of the array virtually using indices without making copies \\n    }\\n\\n    //inplace merging of sorted halves\\n    public void mergeSorted(int []a,int s1,int e1,int s2,int e2){\\n        int i = s1,j = s2,k=0;\\n        int len = e1-s1 +1 + (e2-s2+1);\\n        int ans[]  = new int[len];\\n        while(i<=e1 && j<=e2){\\n            if(a[i]<a[j]){\\n                ans[k++]= a[i];\\n                i++;\\n            }\\n            else{\\n                ans[k++]= a[j];\\n                j++;\\n            }\\n        }\\n        while(i<=e1){\\n            ans[k++]= a[i];\\n            i++;\\n        }\\n        while(j<=e2){\\n            ans[k++]= a[j];\\n            j++;\\n        }\\n\\n        for(i = 0;i<len;i++){\\n            a[s1++] = ans[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3489512,
                "title": "min-heap-c-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) \\n    {\\n        int n = mat.size(),m =mat[0].size();\\n        \\n         \\n        unordered_map<int,priority_queue<int,vector<int>,greater<>>> mp ;\\n        for(int i = 0 ; i<n;i++)\\n        for(int j = 0; j<m;j++)\\n        mp[i-j].push(mat[i][j]); // store diagonal elements on basis of i-j \\n// all diagonal have unique i-j\\n// we are not taking abs(i-j)\\n\\n        for(int i = 0 ; i<n;i++)\\n        for(int j = 0; j<m;j++)\\n        {\\n             \\n            mat[i][j] = mp[i-j].top();// for each diagonal we are taking min element \\n            mp[i-j].pop(); // deleting the min element\\n\\n        }\\n        return mat;\\n        \\n\\n\\n\\n\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) \\n    {\\n        int n = mat.size(),m =mat[0].size();\\n        \\n         \\n        unordered_map<int,priority_queue<int,vector<int>,greater<>>> mp ;\\n        for(int i = 0 ; i<n;i++)\\n        for(int j = 0; j<m;j++)\\n        mp[i-j].push(mat[i][j]); // store diagonal elements on basis of i-j \\n// all diagonal have unique i-j\\n// we are not taking abs(i-j)\\n\\n        for(int i = 0 ; i<n;i++)\\n        for(int j = 0; j<m;j++)\\n        {\\n             \\n            mat[i][j] = mp[i-j].top();// for each diagonal we are taking min element \\n            mp[i-j].pop(); // deleting the min element\\n\\n        }\\n        return mat;\\n        \\n\\n\\n\\n\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3405352,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse all the diagonals in matrix and put the sorted value in those diagonals.\\n\\n# Approach\\nWhile traversing all the diagonals make an ArrayList to store the elements, sort the ArrayList the reassign the values in the original matrix.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*m*log(n)) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport static java.util.Collections.*;\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        int n = mat.length, m = mat[0].length;\\n        for(int i = 0; i<m; i++) {\\n            int x = 0, y = i;\\n            List<Integer> temp = new ArrayList<>();\\n            while(x < n && y < m) temp.add(mat[x++][y++]);\\n            sort(temp);\\n            x = 0;\\n            y = i;\\n            for(int j : temp) mat[x++][y++] = j;\\n        }\\n        for(int i = 1; i<n; i++) {\\n            int x = i, y = 0;\\n            List<Integer> temp = new ArrayList<>();\\n            while(x < n && y < m) temp.add(mat[x++][y++]);\\n            sort(temp);\\n            x = i;\\n            y = 0;\\n            for(int j : temp) mat[x++][y++] = j;\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport static java.util.Collections.*;\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        int n = mat.length, m = mat[0].length;\\n        for(int i = 0; i<m; i++) {\\n            int x = 0, y = i;\\n            List<Integer> temp = new ArrayList<>();\\n            while(x < n && y < m) temp.add(mat[x++][y++]);\\n            sort(temp);\\n            x = 0;\\n            y = i;\\n            for(int j : temp) mat[x++][y++] = j;\\n        }\\n        for(int i = 1; i<n; i++) {\\n            int x = i, y = 0;\\n            List<Integer> temp = new ArrayList<>();\\n            while(x < n && y < m) temp.add(mat[x++][y++]);\\n            sort(temp);\\n            x = i;\\n            y = 0;\\n            for(int j : temp) mat[x++][y++] = j;\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255015,
                "title": "6-lines-of-code-using-heapq-and-2d-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ndiff of i,j is equal for all the cell in diagonal\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake 2D list of empty lists of ``` len(mat)*len(mat[0]) ``` traverse the matrix and push elements at ``` i-j ``` index in 2D array using heappush \\n\\nafter again traverse the matrix and pop at the positions ```mat[i][j]=heappop(d[i-j])```\\n\\n# NOTE \\n``` for C++ ,java and Others use Map instead of 2D array```\\n# Code\\n```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        d=[[] for i in range(len(mat)*len(mat[0]))] \\n        for i in range(len(mat)):\\n            for j in range(len(mat[i])):heapq.heappush(d[i-j],mat[i][j])\\n        for i in range(len(mat)):\\n            for j in range(len(mat[i])):mat[i][j]=heapq.heappop(d[i-j])\\n        return mat\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Heap (Priority Queue)",
                    "Matrix"
                ],
                "code": "``` len(mat)*len(mat[0]) ```\n``` i-j ```\n```mat[i][j]=heappop(d[i-j])```\n``` for C++ ,java and Others use Map instead of 2D array```\n```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        d=[[] for i in range(len(mat)*len(mat[0]))] \\n        for i in range(len(mat)):\\n            for j in range(len(mat[i])):heapq.heappush(d[i-j],mat[i][j])\\n        for i in range(len(mat)):\\n            for j in range(len(mat[i])):mat[i][j]=heapq.heappop(d[i-j])\\n        return mat\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3205191,
                "title": "check-for-i-j-to-be-in-diagonal-i-j-has-to-be-same",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& a) {\\n        unordered_map<int, priority_queue<int,vector<int>,greater<int>>> mp;\\n        \\n        \\n        int n=a.size();\\n        int m = a[0].size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                mp[i-j].push(a[i][j]);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                a[i][j] = mp[i-j].top();\\n                mp[i-j].pop();\\n            }\\n        }\\n        \\n        return a;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& a) {\\n        unordered_map<int, priority_queue<int,vector<int>,greater<int>>> mp;\\n        \\n        \\n        int n=a.size();\\n        int m = a[0].size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                mp[i-j].push(a[i][j]);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                a[i][j] = mp[i-j].top();\\n                mp[i-j].pop();\\n            }\\n        }\\n        \\n        return a;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081765,
                "title": "easy-java-solution-36-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int r = 0;\\n        for(int i = 0; i < n; i++){\\n            sortdia(mat, 0, i, m, n);\\n        }\\n        for(int i = 1; i < m; i++){\\n            sortdia(mat, i, 0, m , n);\\n        }\\n        return mat;\\n    }\\n    public void sortdia(int[][] mat, int row, int col, int m, int n){\\n        ArrayList<Integer> al = new ArrayList<>();\\n        int temp = 0;\\n        int r = row;\\n        int c = col;\\n        while(r < m && c < n){\\n            al.add(mat[r][c]);\\n            r++;\\n            c++;\\n        }\\n        r = row;\\n        c = col;\\n        Collections.sort(al);\\n        while(r < m && c < n){\\n            mat[r][c] = al.get(temp++);\\n            r++;\\n            c++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int r = 0;\\n        for(int i = 0; i < n; i++){\\n            sortdia(mat, 0, i, m, n);\\n        }\\n        for(int i = 1; i < m; i++){\\n            sortdia(mat, i, 0, m , n);\\n        }\\n        return mat;\\n    }\\n    public void sortdia(int[][] mat, int row, int col, int m, int n){\\n        ArrayList<Integer> al = new ArrayList<>();\\n        int temp = 0;\\n        int r = row;\\n        int c = col;\\n        while(r < m && c < n){\\n            al.add(mat[r][c]);\\n            r++;\\n            c++;\\n        }\\n        r = row;\\n        c = col;\\n        Collections.sort(al);\\n        while(r < m && c < n){\\n            mat[r][c] = al.get(temp++);\\n            r++;\\n            c++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054400,
                "title": "beginner-friendly-c-solution-simple-sorting-algorithm",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortDiagonal(vector<vector<int>>&mat,int i,int j,int r,int c){\\n        vector<int>temp;\\n        int p=i,q=j;\\n        while(p<r && q<c){\\n            temp.push_back(mat[p][q]);\\n            p++;\\n            q++;\\n        }\\n        sort(temp.begin(),temp.end());\\n        int k=0;\\n        while(i<r && j<c){\\n            mat[i][j]=temp[k];\\n            i++;\\n            j++;\\n            k++;\\n        }\\n    }\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int rows=mat.size(),cols=mat[0].size();\\n        if(rows==1||cols==1)return mat;\\n        for(int i=0;i<cols;i++){\\n            sortDiagonal(mat,0,i,rows,cols);\\n        }\\n        for(int i=1;i<rows;i++){\\n            sortDiagonal(mat,i,0,rows,cols);\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortDiagonal(vector<vector<int>>&mat,int i,int j,int r,int c){\\n        vector<int>temp;\\n        int p=i,q=j;\\n        while(p<r && q<c){\\n            temp.push_back(mat[p][q]);\\n            p++;\\n            q++;\\n        }\\n        sort(temp.begin(),temp.end());\\n        int k=0;\\n        while(i<r && j<c){\\n            mat[i][j]=temp[k];\\n            i++;\\n            j++;\\n            k++;\\n        }\\n    }\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int rows=mat.size(),cols=mat[0].size();\\n        if(rows==1||cols==1)return mat;\\n        for(int i=0;i<cols;i++){\\n            sortDiagonal(mat,0,i,rows,cols);\\n        }\\n        for(int i=1;i<rows;i++){\\n            sortDiagonal(mat,i,0,rows,cols);\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703872,
                "title": "python3-solution",
                "content": "Ask if you have question - upvote if you like the solution.\\n\\n# Code\\n```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        r_len = len(mat)\\n        c_len = len(mat[0])\\n        positions = [(i,0) for i in range(r_len-1, -1, -1)] + [(0,i) for i in range(1,c_len)]\\n        ans = []\\n        for p in positions:\\n            x = []\\n            i = 0\\n            while i+p[0] < r_len and i+p[1] < c_len:\\n                x.append(mat[p[0]+i][p[1]+i])\\n                i += 1\\n            ans = ans + sorted(x)\\n\\n        for p in positions:\\n            i = 0\\n            while i+p[0] < r_len and i+p[1] < c_len:\\n                mat[p[0]+i][p[1]+i] = ans.pop(0)\\n                i += 1\\n        return mat\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        r_len = len(mat)\\n        c_len = len(mat[0])\\n        positions = [(i,0) for i in range(r_len-1, -1, -1)] + [(0,i) for i in range(1,c_len)]\\n        ans = []\\n        for p in positions:\\n            x = []\\n            i = 0\\n            while i+p[0] < r_len and i+p[1] < c_len:\\n                x.append(mat[p[0]+i][p[1]+i])\\n                i += 1\\n            ans = ans + sorted(x)\\n\\n        for p in positions:\\n            i = 0\\n            while i+p[0] < r_len and i+p[1] < c_len:\\n                mat[p[0]+i][p[1]+i] = ans.pop(0)\\n                i += 1\\n        return mat\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517534,
                "title": "biggnerfriendly-very-easy-and-simple-javascript-solution",
                "content": "```\\n\\n/**\\n * @param {number[][]} a\\n * @return {number[][]}\\n // as the diagonal elements will be having same difference i.e row - col for all diagonal elements is same\\n */\\nvar diagonalSort = function (a) {\\n  let diagonalMatrix = {};\\n  // this is the way for iteration and collecting all the diagonal elements\\n  for (let i = 0; i < a.length; i++) {\\n    for (let j = 0; j < a[i].length; j++) {\\n      let diag = i - j; \\n      diagonalMatrix[diag]\\n        ? diagonalMatrix[diag].push(a[i][j])\\n        : (diagonalMatrix[diag] = [a[i][j]]);\\n    }\\n  }\\n\\n  // sorting the diagonal diagonalMatrix\\n  for (let i of Object.keys(diagonalMatrix)) {\\n    diagonalMatrix[i] = diagonalMatrix[i].sort((a, b) => a - b);\\n  }\\n\\n  //reassigning the diagonal values\\n  for (let i = 0; i < a.length; i++) {\\n    for (let j = 0; j < a[0].length; j++) {\\n      let diag = i - j;\\n      if (diagonalMatrix[diag]) {\\n        a[i][j] = diagonalMatrix[diag].shift();\\n      }\\n    }\\n  }\\n\\n  return a;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/**\\n * @param {number[][]} a\\n * @return {number[][]}\\n // as the diagonal elements will be having same difference i.e row - col for all diagonal elements is same\\n */\\nvar diagonalSort = function (a) {\\n  let diagonalMatrix = {};\\n  // this is the way for iteration and collecting all the diagonal elements\\n  for (let i = 0; i < a.length; i++) {\\n    for (let j = 0; j < a[i].length; j++) {\\n      let diag = i - j; \\n      diagonalMatrix[diag]\\n        ? diagonalMatrix[diag].push(a[i][j])\\n        : (diagonalMatrix[diag] = [a[i][j]]);\\n    }\\n  }\\n\\n  // sorting the diagonal diagonalMatrix\\n  for (let i of Object.keys(diagonalMatrix)) {\\n    diagonalMatrix[i] = diagonalMatrix[i].sort((a, b) => a - b);\\n  }\\n\\n  //reassigning the diagonal values\\n  for (let i = 0; i < a.length; i++) {\\n    for (let j = 0; j < a[0].length; j++) {\\n      let diag = i - j;\\n      if (diagonalMatrix[diag]) {\\n        a[i][j] = diagonalMatrix[diag].shift();\\n      }\\n    }\\n  }\\n\\n  return a;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2504611,
                "title": "java-solution-hashap-and-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] A) {\\n        int m = A.length, n = A[0].length;\\n        HashMap<Integer, PriorityQueue<Integer>> d = new HashMap<>();\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                d.putIfAbsent(i - j, new PriorityQueue<>());\\n                d.get(i - j).add(A[i][j]);\\n            }\\n        }\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                A[i][j] = d.get(i - j).poll();\\n        return A;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] A) {\\n        int m = A.length, n = A[0].length;\\n        HashMap<Integer, PriorityQueue<Integer>> d = new HashMap<>();\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                d.putIfAbsent(i - j, new PriorityQueue<>());\\n                d.get(i - j).add(A[i][j]);\\n            }\\n        }\\n        for (int i = 0; i < m; ++i)\\n            for (int j = 0; j < n; ++j)\\n                A[i][j] = d.get(i - j).poll();\\n        return A;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496994,
                "title": "c-using-custom-diagonal-iterator",
                "content": "Just a bit of additional effort may alleviate the need for copying the diagonals into a separate vector. Here I create a rough iterator over diagonal elements, and pass it to the `std::sort`.\\n\\n```\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nusing VecT = std::vector<int>;\\nusing MatT = std::vector<VecT>;\\n\\nclass Iter\\n{\\npublic:\\n    MatT *m;\\n    int r, c;\\n\\n    Iter(MatT &m, int r, int c)\\n        : m{&m}, r{r}, c{c}\\n    {\\n    }\\n\\n    Iter& operator=(const Iter &o) = default;\\n\\n    //auto operator<=>(const Iter &o) const = default;\\n    bool operator==(const Iter &o) const { return r == o.r; }\\n    bool operator!=(const Iter &o) const { return r != o.r; }\\n    bool operator<(const Iter &o) const { return r < o.r; }\\n\\n    Iter& operator++() { ++r; ++c; return *this; }\\n    Iter& operator--() { --r; --c; return *this; }\\n\\n    Iter operator+(int b) { return {*m, r + b, c + b}; }\\n    Iter operator-(int b) { return {*m, r - b, c - b}; }\\n\\n    int operator-(const Iter &o) const { return r - o.r; }\\n\\n    int& operator*() { return (*m)[r][c]; }\\n\\n    typedef random_access_iterator_tag iterator_category;\\n    typedef int value_type;\\n    typedef int difference_type;\\n    typedef int* pointer;\\n    typedef int& reference;\\n};\\n\\nclass Solution\\n{\\npublic:\\n    MatT& diagonalSort(MatT& mat) {\\n        int H = mat.size();\\n        int W = mat[0].size();\\n\\n        auto getCount = [&](int r, int c) {\\n            return std::min(W - c, H - r);\\n        };\\n\\n        auto sortDiag = [&](int r, int c) {\\n            auto count = getCount(r, c);\\n            Iter b{mat, r, c};\\n            Iter e{mat, r + count, c + count};\\n            std::sort(b, e);\\n        };\\n\\n        for (int r = 0; r < H; ++r)\\n            sortDiag(r, 0);\\n\\n        for (int c = 1; c < W; ++c)\\n            sortDiag(0, c);\\n\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n#include <vector>\\n#include <algorithm>\\n\\nusing namespace std;\\n\\nusing VecT = std::vector<int>;\\nusing MatT = std::vector<VecT>;\\n\\nclass Iter\\n{\\npublic:\\n    MatT *m;\\n    int r, c;\\n\\n    Iter(MatT &m, int r, int c)\\n        : m{&m}, r{r}, c{c}\\n    {\\n    }\\n\\n    Iter& operator=(const Iter &o) = default;\\n\\n    //auto operator<=>(const Iter &o) const = default;\\n    bool operator==(const Iter &o) const { return r == o.r; }\\n    bool operator!=(const Iter &o) const { return r != o.r; }\\n    bool operator<(const Iter &o) const { return r < o.r; }\\n\\n    Iter& operator++() { ++r; ++c; return *this; }\\n    Iter& operator--() { --r; --c; return *this; }\\n\\n    Iter operator+(int b) { return {*m, r + b, c + b}; }\\n    Iter operator-(int b) { return {*m, r - b, c - b}; }\\n\\n    int operator-(const Iter &o) const { return r - o.r; }\\n\\n    int& operator*() { return (*m)[r][c]; }\\n\\n    typedef random_access_iterator_tag iterator_category;\\n    typedef int value_type;\\n    typedef int difference_type;\\n    typedef int* pointer;\\n    typedef int& reference;\\n};\\n\\nclass Solution\\n{\\npublic:\\n    MatT& diagonalSort(MatT& mat) {\\n        int H = mat.size();\\n        int W = mat[0].size();\\n\\n        auto getCount = [&](int r, int c) {\\n            return std::min(W - c, H - r);\\n        };\\n\\n        auto sortDiag = [&](int r, int c) {\\n            auto count = getCount(r, c);\\n            Iter b{mat, r, c};\\n            Iter e{mat, r + count, c + count};\\n            std::sort(b, e);\\n        };\\n\\n        for (int r = 0; r < H; ++r)\\n            sortDiag(r, 0);\\n\\n        for (int c = 1; c < W; ++c)\\n            sortDiag(0, c);\\n\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2496616,
                "title": "easy-approach-hashmap",
                "content": "class Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        unordered_map<int,vector<int>> mp;\\n        int r=mat.size();\\n        int c=mat[0].size();\\n            vector<vector<int>> ans(r,vector<int>(c));\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                mp[i-j].push_back(mat[i][j]);\\n            }\\n        }\\n        for(auto &it:mp)\\n            sort(it.second.begin(),it.second.end());\\n         for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {   vector<int> temp=mp[i-j];\\n                ans[i][j]=temp[0];\\n                mp[i-j].erase(mp[i-j].begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        unordered_map<int,vector<int>> mp;\\n        int r=mat.size();\\n        int c=mat[0].size();\\n            vector<vector<int>> ans(r,vector<int>(c));\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                mp[i-j].push_back(mat[i][j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2496174,
                "title": "java-straight-forward-clean-code-easy-explanation",
                "content": "* Observing carefully, we can notice that all the diagonals can be obtained from 1st column and 1 row. \\n* Starting from each element of 1st row and 1st column, we can move all the way down diagonally (`i+1, j+1`)\\n* While moving diagonally, keep a check of bounds (`i<rows && j<columns`)\\n\\nHere, in this solution, I have created two methods -\\n`formDiagonal() :`  This method takes the starting number\\'s index and returns a list cotaining diagonal elements in sorted manner. (Keeping the bounds in mind)\\n\\n`fillDiagonal() : ` This method simply copies the sorted elements from that returned list to the actual matrix (Since we have taken care of bounds in the previous method during sorting, no need add bounds check here)\\n\\n```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        \\n        int r = mat.length;\\n        int c = mat[0].length;\\n        \\n        // taking 1st row diagonals \\n        int i=0;\\n        for(int j=0; j<c; j++){\\n            List<Integer> d = formDiagonal(i, j, r, c, mat);\\n            fillDiagonal(d, i, j, r, c, mat);\\n        }\\n        \\n        // taking 1st Col\\n        int j=0;\\n        for(i=1; i<r; i++){\\n            List<Integer> d = formDiagonal(i, j, r, c, mat);\\n            fillDiagonal(d, i, j, r, c, mat);\\n        }\\n        return mat;\\n    }\\n    \\n    public void fillDiagonal(List<Integer> dig, int i, int j, int r, int c, int[][] arr ){\\n        for(int num  : dig){\\n            arr[i++][j++] = num;\\n        }\\n    }\\n    \\n    public List<Integer> formDiagonal(int i, int j, int r, int c, int[][] arr){\\n        List<Integer> list = new ArrayList<>();\\n        while(i<r && j<c){\\n            list.add(arr[i][j]);\\n            i++;\\n            j++;\\n        }\\n//System.out.println(list);\\n        Collections.sort(list);\\n        return list;\\n    }\\n}\\n```\\n\\nPlease upvote if u like !! :)",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        \\n        int r = mat.length;\\n        int c = mat[0].length;\\n        \\n        // taking 1st row diagonals \\n        int i=0;\\n        for(int j=0; j<c; j++){\\n            List<Integer> d = formDiagonal(i, j, r, c, mat);\\n            fillDiagonal(d, i, j, r, c, mat);\\n        }\\n        \\n        // taking 1st Col\\n        int j=0;\\n        for(i=1; i<r; i++){\\n            List<Integer> d = formDiagonal(i, j, r, c, mat);\\n            fillDiagonal(d, i, j, r, c, mat);\\n        }\\n        return mat;\\n    }\\n    \\n    public void fillDiagonal(List<Integer> dig, int i, int j, int r, int c, int[][] arr ){\\n        for(int num  : dig){\\n            arr[i++][j++] = num;\\n        }\\n    }\\n    \\n    public List<Integer> formDiagonal(int i, int j, int r, int c, int[][] arr){\\n        List<Integer> list = new ArrayList<>();\\n        while(i<r && j<c){\\n            list.add(arr[i][j]);\\n            i++;\\n            j++;\\n        }\\n//System.out.println(list);\\n        Collections.sort(list);\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495852,
                "title": "java-easy-solution-1ms-99",
                "content": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n       \\n        int y = 0;\\n        int x = 0;\\n\\n        for (int i = 0; i < mat[0].length; i++) {\\n\\n            int[] row1 = new int[Math.min(mat[0].length - i, mat.length)];\\n            x = i;\\n            y = 0;\\n            for (int j = 0; j < row1.length; j++) {\\n                int x1 = mat[y++][x++];\\n\\n                row1[j] = x1;\\n            }\\n            Arrays.sort(row1);\\n\\n            x = i;\\n            y = 0;\\n\\n            for (int j = 0; j < row1.length; j++) {\\n                mat[y][x]=row1[j];\\n                x++;\\n                y++;\\n            }\\n        }\\n\\n        for (int i = 1; i < mat.length; i++) {\\n\\n            int[] row1 = new int[Math.min(mat.length - i, mat[0].length)];\\n\\n            x = i;\\n            y = 0;\\n            for (int j = 0; j < row1.length; j++) {\\n                int x1 = mat[x++][y++];\\n                row1[j] = x1;\\n            }\\n            Arrays.sort(row1);\\n\\n            x = i;\\n            y = 0;\\n\\n            for (int j = 0; j < row1.length; j++) {\\n                mat[x][y]=row1[j];\\n                x++;\\n                y++;\\n            }\\n        }\\n\\n        return mat; \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n       \\n        int y = 0;\\n        int x = 0;\\n\\n        for (int i = 0; i < mat[0].length; i++) {\\n\\n            int[] row1 = new int[Math.min(mat[0].length - i, mat.length)];\\n            x = i;\\n            y = 0;\\n            for (int j = 0; j < row1.length; j++) {\\n                int x1 = mat[y++][x++];\\n\\n                row1[j] = x1;\\n            }\\n            Arrays.sort(row1);\\n\\n            x = i;\\n            y = 0;\\n\\n            for (int j = 0; j < row1.length; j++) {\\n                mat[y][x]=row1[j];\\n                x++;\\n                y++;\\n            }\\n        }\\n\\n        for (int i = 1; i < mat.length; i++) {\\n\\n            int[] row1 = new int[Math.min(mat.length - i, mat[0].length)];\\n\\n            x = i;\\n            y = 0;\\n            for (int j = 0; j < row1.length; j++) {\\n                int x1 = mat[x++][y++];\\n                row1[j] = x1;\\n            }\\n            Arrays.sort(row1);\\n\\n            x = i;\\n            y = 0;\\n\\n            for (int j = 0; j < row1.length; j++) {\\n                mat[x][y]=row1[j];\\n                x++;\\n                y++;\\n            }\\n        }\\n\\n        return mat; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495061,
                "title": "c-priority-queue-simple-solution",
                "content": "* \\'i-j\\' value is unique for each diagonal, hence use it as a key in a map\\n* use an unordered map with a priority queue \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        \\n    int m = mat.size(), n = mat[0].size(); \\n\\n\\t\\n\\tunordered_map<int, priority_queue<int, vector<int>, greater<int>>> map;\\n\\n\\t\\n\\tfor (int i = 0; i < m; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\n\\t\\t\\tmap[i - j].push(mat[i][j]);\\n\\t\\t}\\n\\t}\\n\\n\\t\\n\\tfor (int i = 0; i < m; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\n\\t\\t\\tmat[i][j] = map[i - j].top();\\n\\t\\t\\t\\n\\t\\t\\tmap[i - j].pop();\\n\\t\\t}\\n\\t}\\n\\n\\treturn mat;\\n        \\n        \\n        \\n    }\\n    \\n  \\n* };\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        \\n    int m = mat.size(), n = mat[0].size(); \\n\\n\\t\\n\\tunordered_map<int, priority_queue<int, vector<int>, greater<int>>> map;\\n\\n\\t\\n\\tfor (int i = 0; i < m; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\n\\t\\t\\tmap[i - j].push(mat[i][j]);\\n\\t\\t}\\n\\t}\\n\\n\\t\\n\\tfor (int i = 0; i < m; i++)\\n\\t{\\n\\t\\tfor (int j = 0; j < n; j++)\\n\\t\\t{\\n\\t\\t\\n\\t\\t\\tmat[i][j] = map[i - j].top();\\n\\t\\t\\t\\n\\t\\t\\tmap[i - j].pop();\\n\\t\\t}\\n\\t}\\n\\n\\treturn mat;\\n        \\n        \\n        \\n    }\\n    \\n  \\n* };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495042,
                "title": "c-o-m-n-in-place-pretty-fast-solution-using-count-sort",
                "content": "First of all I thought about is to write simple sorting solution or something like that.\\nBut then I saw the constraints, and the possible values in matrix are in range from 1 to 100. \\nIt is perfect example for count sort, where you count how many times each number is met. \\nAlgorithm works this way: we create an array which contains 100 elements. 0th index would contain the value which represents how many times 1 is met in array, \\n1st index -> how many times 2 is met,\\n2nd index-> how many times 3 is met, etc.\\nwe can fill this array in 0(n) time.\\nWhen we want to sort, we traverse from the smallest index to the largets, and if value is greater than zero, it means we have met this number \"value\" (value of current index) amount of times. \\nBasically sorting is done in 0(n).\\nIt only works, when contrains for values are small like from 1 to 100, if they are from -2^31 to 2^31-1 or something, it is not right approach, because you would need to allocate tons of memory for that.\\nFor some optimizations, we can create array for sorting only once at the beginning, and update values in-place.\\n\\n```\\nclass Solution {\\npublic:\\n    int rows;\\n    int cols;\\n    vector<int> count;\\n    \\n    void resetVec(vector<int>& vec) {\\n        for (int i = 0; i < vec.size(); ++i) {\\n            vec[i] = 0;\\n        }\\n    }\\n    \\n    int firstNonZeroValue(vector<int>& count, int lastIndex) {\\n        for (int i = lastIndex; i < count.size(); ++i) {\\n            if (count[i] != 0) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    void sortDiagonal(vector<vector<int>>& mat, int startRow, int startCol) {\\n        resetVec(count);\\n        int lastIndex = 0;\\n        for (int currentRow = startRow, currentCol = startCol; currentRow < rows && currentCol < cols; ++currentRow, ++currentCol) {\\n            count[mat[currentRow][currentCol]]++;\\n        }\\n        for (int currentRow = startRow, currentCol = startCol; currentRow < rows && currentCol < cols; ++currentRow, ++currentCol) {\\n            mat[currentRow][currentCol] = firstNonZeroValue(count, lastIndex);\\n            count[mat[currentRow][currentCol]]--;\\n            lastIndex = mat[currentRow][currentCol];\\n        }\\n    }\\n    \\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        rows = mat.size();\\n        cols = mat[0].size();\\n        count.resize(101, 0);\\n        \\n        for (int i = 0; i < rows; ++i) {\\n            sortDiagonal(mat, i, 0);\\n        }\\n        \\n        for (int i = 1; i < cols; ++i) {\\n            sortDiagonal(mat, 0, i);\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int rows;\\n    int cols;\\n    vector<int> count;\\n    \\n    void resetVec(vector<int>& vec) {\\n        for (int i = 0; i < vec.size(); ++i) {\\n            vec[i] = 0;\\n        }\\n    }\\n    \\n    int firstNonZeroValue(vector<int>& count, int lastIndex) {\\n        for (int i = lastIndex; i < count.size(); ++i) {\\n            if (count[i] != 0) {\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    void sortDiagonal(vector<vector<int>>& mat, int startRow, int startCol) {\\n        resetVec(count);\\n        int lastIndex = 0;\\n        for (int currentRow = startRow, currentCol = startCol; currentRow < rows && currentCol < cols; ++currentRow, ++currentCol) {\\n            count[mat[currentRow][currentCol]]++;\\n        }\\n        for (int currentRow = startRow, currentCol = startCol; currentRow < rows && currentCol < cols; ++currentRow, ++currentCol) {\\n            mat[currentRow][currentCol] = firstNonZeroValue(count, lastIndex);\\n            count[mat[currentRow][currentCol]]--;\\n            lastIndex = mat[currentRow][currentCol];\\n        }\\n    }\\n    \\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        rows = mat.size();\\n        cols = mat[0].size();\\n        count.resize(101, 0);\\n        \\n        for (int i = 0; i < rows; ++i) {\\n            sortDiagonal(mat, i, 0);\\n        }\\n        \\n        for (int i = 1; i < cols; ++i) {\\n            sortDiagonal(mat, 0, i);\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495035,
                "title": "c-long-code-but-easy-implementation-using-sorting",
                "content": "### Please Upvote If Helpful\\n#### Open to any discussions or chats about the code.\\n\\n**Approach:**\\n* Traversing the matrix diagonal wise as shown in the problem starting from upper right corner element then moving towards bottom left corner element and storing these diagonal elements.\\n* Sorting these diagonal elements and storing them in a vector.\\n* Now assigning these sorted diagonals in the correct place of a vector and returning.\\n\\n**Traversing the diagonal elements Observation:**\\n* Diagonal elements are starting from upper right corner with 0th row and last col then the diagonal indices are incremented by 1 both the row index and the col index until row index is < totalRowSize and col index is < totalColSize.\\nfor eg: In this sample testcase- ```[[3,3,1,1],[2,2,1,2],[1,1,1,2]]```\\n1st diagonal traversal: 0 3 [row index, col index]\\n2nd traversal: 0 2 , 1 3\\n3rd traversal: 0 1, 1 2, 2 3\\n4th traversal: 0 0, 1 1, 2 2\\n5th traversal: 1 0, 2 1\\n6th traversal: 2 0\\n* Traversal is from last col to 0th col then the row under 1st element till last row as shown in the diagram from 1 to 7\\n\\t( Please ignore my bad drawing\\uD83D\\uDE01) \\n![image](https://assets.leetcode.com/users/images/0256edec-a4db-481a-b88b-6cc36b10b5ac_1661681178.0935829.jpeg)\\n\\n```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>> &mat)\\n    {\\n        vector<vector<int>> sortedDiagonalElements;\\n        int totalRows = mat.size();\\n        int totalCols = mat[0].size();\\n\\n        // sorting\\n        int col = totalCols - 1;\\n        vector<int> oneDiagonalElements;\\n        while (col >= 0) // loop from last col to 0th col\\n        {\\n            oneDiagonalElements.clear();\\n            for (int i = 0, j = col; i < totalRows && j < totalCols; i++, j++)\\n                oneDiagonalElements.push_back(mat[i][j]);                 // storing diagonal elements in a vector\\n            sort(oneDiagonalElements.begin(), oneDiagonalElements.end()); // sorting each diagonal\\n            sortedDiagonalElements.push_back(oneDiagonalElements);\\n            col--;\\n        }\\n\\n        int row = 1; // loop from 1st row to last row\\n        while (row <= totalRows - 1)\\n        {\\n            oneDiagonalElements.clear();\\n            for (int i = row, j = 0; i < totalRows && j < totalCols; i++, j++)\\n                oneDiagonalElements.push_back(mat[i][j]);\\n            sort(oneDiagonalElements.begin(), oneDiagonalElements.end());\\n            sortedDiagonalElements.push_back(oneDiagonalElements);\\n            row++;\\n        }\\n\\n        // storing\\n        vector<vector<int>> ans(totalRows, vector<int>(totalCols));\\n        col = totalCols - 1;\\n        int diagonalRow = 0;\\n        while (col >= 0) // same traversal as above\\n        {\\n            int diagonalCol = 0;\\n            for (int i = 0, j = col; i < totalRows && j < totalCols; i++, j++)\\n                ans[i][j] = sortedDiagonalElements[diagonalRow][diagonalCol++];\\n            diagonalRow++; // now will store next diagonal row\\n            col--;\\n        }\\n\\n        row = 1;\\n        while (row <= totalRows - 1)\\n        {\\n            int diagonalCol = 0;\\n            for (int i = row, j = 0; i < totalRows && j < totalCols; i++, j++)\\n                ans[i][j] = sortedDiagonalElements[diagonalRow][diagonalCol++];\\n            diagonalRow++;\\n            row++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```[[3,3,1,1],[2,2,1,2],[1,1,1,2]]```\n```\\nclass Solution\\n{\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>> &mat)\\n    {\\n        vector<vector<int>> sortedDiagonalElements;\\n        int totalRows = mat.size();\\n        int totalCols = mat[0].size();\\n\\n        // sorting\\n        int col = totalCols - 1;\\n        vector<int> oneDiagonalElements;\\n        while (col >= 0) // loop from last col to 0th col\\n        {\\n            oneDiagonalElements.clear();\\n            for (int i = 0, j = col; i < totalRows && j < totalCols; i++, j++)\\n                oneDiagonalElements.push_back(mat[i][j]);                 // storing diagonal elements in a vector\\n            sort(oneDiagonalElements.begin(), oneDiagonalElements.end()); // sorting each diagonal\\n            sortedDiagonalElements.push_back(oneDiagonalElements);\\n            col--;\\n        }\\n\\n        int row = 1; // loop from 1st row to last row\\n        while (row <= totalRows - 1)\\n        {\\n            oneDiagonalElements.clear();\\n            for (int i = row, j = 0; i < totalRows && j < totalCols; i++, j++)\\n                oneDiagonalElements.push_back(mat[i][j]);\\n            sort(oneDiagonalElements.begin(), oneDiagonalElements.end());\\n            sortedDiagonalElements.push_back(oneDiagonalElements);\\n            row++;\\n        }\\n\\n        // storing\\n        vector<vector<int>> ans(totalRows, vector<int>(totalCols));\\n        col = totalCols - 1;\\n        int diagonalRow = 0;\\n        while (col >= 0) // same traversal as above\\n        {\\n            int diagonalCol = 0;\\n            for (int i = 0, j = col; i < totalRows && j < totalCols; i++, j++)\\n                ans[i][j] = sortedDiagonalElements[diagonalRow][diagonalCol++];\\n            diagonalRow++; // now will store next diagonal row\\n            col--;\\n        }\\n\\n        row = 1;\\n        while (row <= totalRows - 1)\\n        {\\n            int diagonalCol = 0;\\n            for (int i = row, j = 0; i < totalRows && j < totalCols; i++, j++)\\n                ans[i][j] = sortedDiagonalElements[diagonalRow][diagonalCol++];\\n            diagonalRow++;\\n            row++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494199,
                "title": "c-two-different-approaches-with-optimal-solution",
                "content": "```\\n//1.  Brute Force Approach using Multi Set\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        \\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int s = (m*n);\\n        \\n        unordered_map<int, multiset<int>> mp;\\n        \\n        for(int i = 0 ; i<m ; i++)\\n        {\\n            for(int j = 0; j<n ; j++)\\n            {\\n                mp[s-(i-j)].insert(mat[i][j]);\\n            }\\n        }\\n        \\n        for(int i = 0 ; i<m ; i++)\\n        {\\n            for(int j = 0; j<n ; j++)\\n            {\\n               mat[i][j] = *mp[s-(i-j)].begin();\\n               mp[s-(i-j)].erase(mp[s-(i-j)].begin());\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n\\n\\n//2.  Optimal Method TC :  O(nLog(n)) where n = row+col  and Space Complexity : O(max(row,col) \\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        \\n        int row = mat.size();\\n        int col = mat[0].size();\\n        \\n        vector<int> temp;\\n        \\n        \\n        \\n        for(int i = 0 ; i<col ; i++)\\n        {\\n            int x = 0, y = i;\\n            \\n            while(x<row && y <col)\\n                temp.push_back(mat[x++][y++]);\\n            \\n            sort(temp.begin(), temp.end());\\n           \\n             x = 0, y = i;\\n            int k = 0;\\n            while(x<row && y <col)\\n            {\\n                mat[x++][y++] = temp[k++];\\n            }           \\n            \\n            temp.clear();\\n        }\\n        \\n        for(int i = 1 ; i<row; i++)\\n        {\\n            int x = i, y = 0;\\n            \\n            while(x<row && y <col)\\n                temp.push_back(mat[x++][y++]);\\n            \\n            sort(temp.begin(), temp.end());\\n            \\n              x = i , y = 0;\\n            int k = 0;\\n            while(x<row && y <col)\\n            {\\n                mat[x++][y++] = temp[k++];\\n            }           \\n            \\n            temp.clear();\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//1.  Brute Force Approach using Multi Set\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        \\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int s = (m*n);\\n        \\n        unordered_map<int, multiset<int>> mp;\\n        \\n        for(int i = 0 ; i<m ; i++)\\n        {\\n            for(int j = 0; j<n ; j++)\\n            {\\n                mp[s-(i-j)].insert(mat[i][j]);\\n            }\\n        }\\n        \\n        for(int i = 0 ; i<m ; i++)\\n        {\\n            for(int j = 0; j<n ; j++)\\n            {\\n               mat[i][j] = *mp[s-(i-j)].begin();\\n               mp[s-(i-j)].erase(mp[s-(i-j)].begin());\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n\\n\\n//2.  Optimal Method TC :  O(nLog(n)) where n = row+col  and Space Complexity : O(max(row,col) \\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        \\n        int row = mat.size();\\n        int col = mat[0].size();\\n        \\n        vector<int> temp;\\n        \\n        \\n        \\n        for(int i = 0 ; i<col ; i++)\\n        {\\n            int x = 0, y = i;\\n            \\n            while(x<row && y <col)\\n                temp.push_back(mat[x++][y++]);\\n            \\n            sort(temp.begin(), temp.end());\\n           \\n             x = 0, y = i;\\n            int k = 0;\\n            while(x<row && y <col)\\n            {\\n                mat[x++][y++] = temp[k++];\\n            }           \\n            \\n            temp.clear();\\n        }\\n        \\n        for(int i = 1 ; i<row; i++)\\n        {\\n            int x = i, y = 0;\\n            \\n            while(x<row && y <col)\\n                temp.push_back(mat[x++][y++]);\\n            \\n            sort(temp.begin(), temp.end());\\n            \\n              x = i , y = 0;\\n            int k = 0;\\n            while(x<row && y <col)\\n            {\\n                mat[x++][y++] = temp[k++];\\n            }           \\n            \\n            temp.clear();\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493762,
                "title": "c-solution-brute-force-enumeration-very-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        // make rows as x-axis, and cols as y-axis, considering functions like y = x + b (b is intercept in the x-y graph) \\n\\t\\t// enumerate intercept b in the x-y graph, increment both x and y by 1 every iteration based on the line function y = x + b \\n        for (int b = -(n - 1); b < m; ++ b) {\\n            vector<int> diag;\\n            for (int x = 0, y = b; x < n && y < m; ++ x, ++ y)\\n                if (y >= 0) diag.emplace_back(mat[x][y]);\\n            sort(diag.begin(), diag.end());\\n            for (int x = 0, y = b, k = 0; x < n && y < m; ++ x, ++ y)\\n                if (y >= 0) mat[x][y] = diag[k ++];\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Enumeration"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        // make rows as x-axis, and cols as y-axis, considering functions like y = x + b (b is intercept in the x-y graph) \\n\\t\\t// enumerate intercept b in the x-y graph, increment both x and y by 1 every iteration based on the line function y = x + b \\n        for (int b = -(n - 1); b < m; ++ b) {\\n            vector<int> diag;\\n            for (int x = 0, y = b; x < n && y < m; ++ x, ++ y)\\n                if (y >= 0) diag.emplace_back(mat[x][y]);\\n            sort(diag.begin(), diag.end());\\n            for (int x = 0, y = b, k = 0; x < n && y < m; ++ x, ++ y)\\n                if (y >= 0) mat[x][y] = diag[k ++];\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493679,
                "title": "c-python-simple-fastest-solution-with-explanation",
                "content": "**Idea:**\\nIn this solution, I \\'m sending the start index (i.e. i and j) of every diagonal in a matrix to the get function.\\nIn the get function I\\'m taking all the diagonal element into a new array (vector / list) and sorting it. And then storing it to the answer matrix with same diagonal index.\\n\\n**C++ Code:**\\nThe best result for the code below is 7ms / 9.6MB (beats 98.13% / 16.11%).\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    void get(int x, int y, int n, int m, vector<vector<int>>& mat) {\\n        vector<int> A;\\n        int i = x, j = y;\\n        while (i < n && j < m) {\\n            A.push_back(mat[i++][j++]);\\n        }\\n        sort(A.begin(), A.end());\\n        i = x;\\n        j = y;\\n        for (auto it : A) {\\n            ans[i++][j++] = it;\\n        }\\n    }\\n    \\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        for (int i = 0; i < n; i++) {\\n            vector<int> A(m, 0);\\n            ans.push_back(A);\\n        }\\n        for (int x = 0; x < m; x++) get(0, x, n, m, mat);\\n        for (int x = 1; x < n; x++) get(x, 0, n, m, mat);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Python Code:**\\nThe best result for the code below is 88ms / 14.1MB (beats 92.42% / 95.10%).\\n\\n```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        n, m = len(mat), len(mat[0])\\n        ans = [[0 for i in range(m)] for j in range(n)]\\n        \\n        def get(x, y):\\n            i, j = x, y\\n            A = []\\n            while i < n and j < m:\\n                A.append(mat[i][j])\\n                i += 1\\n                j += 1\\n            A.sort()\\n            i, j = x, y\\n            for it in A:\\n                ans[i][j] = it\\n                i += 1\\n                j += 1\\n        \\n        for x in range(m): get(0, x)\\n        for x in range(1, n): get(x, 0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    void get(int x, int y, int n, int m, vector<vector<int>>& mat) {\\n        vector<int> A;\\n        int i = x, j = y;\\n        while (i < n && j < m) {\\n            A.push_back(mat[i++][j++]);\\n        }\\n        sort(A.begin(), A.end());\\n        i = x;\\n        j = y;\\n        for (auto it : A) {\\n            ans[i++][j++] = it;\\n        }\\n    }\\n    \\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int n = mat.size(), m = mat[0].size();\\n        for (int i = 0; i < n; i++) {\\n            vector<int> A(m, 0);\\n            ans.push_back(A);\\n        }\\n        for (int x = 0; x < m; x++) get(0, x, n, m, mat);\\n        for (int x = 1; x < n; x++) get(x, 0, n, m, mat);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        n, m = len(mat), len(mat[0])\\n        ans = [[0 for i in range(m)] for j in range(n)]\\n        \\n        def get(x, y):\\n            i, j = x, y\\n            A = []\\n            while i < n and j < m:\\n                A.append(mat[i][j])\\n                i += 1\\n                j += 1\\n            A.sort()\\n            i, j = x, y\\n            for it in A:\\n                ans[i][j] = it\\n                i += 1\\n                j += 1\\n        \\n        for x in range(m): get(0, x)\\n        for x in range(1, n): get(x, 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493644,
                "title": "python3-easy-understanding-explained-sort",
                "content": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        lst = []\\n        n, m = len(mat), len(mat[0])\\n        \\n        # leftmost column\\n        for i in range(n):\\n            lst.append([i, 0])\\n        \\n        # rightmost row\\n        for i in range(m):\\n            lst.append([0, i])\\n        \\n        lst.pop(0)\\n        \\n        for x, y in lst:\\n            arr = []\\n            i, j = x, y\\n            \\n            # getting the diagonal elements\\n            while i < n and j < m:\\n                arr.append(mat[i][j])\\n                i, j = i+1, j+1\\n            \\n            arr.sort()  # sort the elements\\n            \\n            i, j = x, y\\n            # setting the element in sorted order\\n            while i < n and j < m:\\n                mat[i][j] = arr.pop(0)\\n                i, j = i+1, j+1\\n        \\n        return mat\\n```",
                "solutionTags": [
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        lst = []\\n        n, m = len(mat), len(mat[0])\\n        \\n        # leftmost column\\n        for i in range(n):\\n            lst.append([i, 0])\\n        \\n        # rightmost row\\n        for i in range(m):\\n            lst.append([0, i])\\n        \\n        lst.pop(0)\\n        \\n        for x, y in lst:\\n            arr = []\\n            i, j = x, y\\n            \\n            # getting the diagonal elements\\n            while i < n and j < m:\\n                arr.append(mat[i][j])\\n                i, j = i+1, j+1\\n            \\n            arr.sort()  # sort the elements\\n            \\n            i, j = x, y\\n            # setting the element in sorted order\\n            while i < n and j < m:\\n                mat[i][j] = arr.pop(0)\\n                i, j = i+1, j+1\\n        \\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493621,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void help(vector<vector<int>>& mat,int i,int j){\\n        vector<int>v;\\n        int p = i, q = j;\\n        while(i<mat.size() && j<mat[0].size()){\\n            v.push_back(mat[i][j]);\\n            i++,j++;\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++){\\n            mat[p][q] = v[i];\\n            p++,q++;\\n        }\\n        \\n    }\\n    \\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int i=0;\\n        for(int j=0;j<mat[0].size();j++){\\n            help(mat,i,j);\\n        }\\n        \\n        int j = 0;\\n        for(int i=0;i<mat.size();i++){\\n            help(mat,i,j);\\n        }\\n        \\n        return mat;\\n    }\\n};\\n\\n```\\n\\nUpvote if you get it ..",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void help(vector<vector<int>>& mat,int i,int j){\\n        vector<int>v;\\n        int p = i, q = j;\\n        while(i<mat.size() && j<mat[0].size()){\\n            v.push_back(mat[i][j]);\\n            i++,j++;\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++){\\n            mat[p][q] = v[i];\\n            p++,q++;\\n        }\\n        \\n    }\\n    \\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int i=0;\\n        for(int j=0;j<mat[0].size();j++){\\n            help(mat,i,j);\\n        }\\n        \\n        int j = 0;\\n        for(int i=0;i<mat.size();i++){\\n            help(mat,i,j);\\n        }\\n        \\n        return mat;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493515,
                "title": "python-sorting-one-diag-at-a-time-o-min-m-n-space-explained",
                "content": "zip takes two lists A and B and turns them into a 2d list\\nA = [1,2,3]\\nB = [0,0,0]\\nzip(A,B) will be [ (1,0), (2,0), (3,0) ]\\n\\nfor m=2 and n = 3\\nstarting points will be [  (0,1),  (1,0),  (0,1), (0,2) ] \\nwe use this zip function to make a list having starting rows and columns of all diagonals\\nwe get the rest of the diagonal by incrementing both current row and current column\\n\\n```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        r,c = len(mat), len(mat[0])\\n                 \\n        for sr,sc in list(zip(range(r-1,-1,-1),[0 for _ in range(r)])) + list(zip([0 for _ in range(c-1)],range(1,c))):   \\n            diag = []\\n            i,j = sr, sc\\n            while j<c and i<r:\\n                bruh.append(mat[i][j])\\n                i+=1\\n                j+=1\\n            diag.sort()\\n            i,j = sr, sc\\n            count = 0\\n            while j<c and i<r:\\n                mat[i][j] = diag[count]\\n                count+=1\\n                i+=1\\n                j+=1\\n\\n        return mat\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        r,c = len(mat), len(mat[0])\\n                 \\n        for sr,sc in list(zip(range(r-1,-1,-1),[0 for _ in range(r)])) + list(zip([0 for _ in range(c-1)],range(1,c))):   \\n            diag = []\\n            i,j = sr, sc\\n            while j<c and i<r:\\n                bruh.append(mat[i][j])\\n                i+=1\\n                j+=1\\n            diag.sort()\\n            i,j = sr, sc\\n            count = 0\\n            while j<c and i<r:\\n                mat[i][j] = diag[count]\\n                count+=1\\n                i+=1\\n                j+=1\\n\\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493484,
                "title": "java-easy-to-understand-simple-solution",
                "content": "You can even use PriorityQueue but the time complexity will be same insertion in priority queue take logn for insertion and for n element it take O(nlogn). For list it takes O(1) insertion and O(nlogn) for sorting. n is the number of diagonal elements\\n```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        int m = mat.length;//no:of rows\\n        int n = mat[0].length;//no:of columns\\n\\t\\t//sorting diagonals whose starting element is in 1st column\\n\\t\\t/** \\n\\t\\t-> **1** 2 3 4\\n\\t\\t-> **1** **2** 3 4\\n\\t\\t->** 1 ****2** **3** 4\\n\\t\\t// sorting these diagonals\\n\\t\\t*/\\n        for (int i = 0; i < m; i++) {\\n            int temp = i;\\n            int j = 0;\\n            ArrayList<Integer> l = new ArrayList<>();\\n\\t\\t\\t//adding diagnal elements to a list\\n            while (temp < m &&  j < n){\\n                l.add(mat[temp++][j++]);\\n            }\\n\\t\\t\\t//sorting the list\\n            l.sort(null);\\n            temp = i;\\n            j = 0;\\n\\t\\t\\t//replacing them  in the sorted order in matrix\\n           for (int k = 0; k < l.size(); k++){\\n                mat[temp++][j++] = l.get(k);\\n            }\\n        }\\n\\t\\t//sorting diagonals whose starting element is in 1st row\\n\\t\\t/** \\n\\t\\t\\t|     |   |\\n\\t\\t\\tV     V   V\\n\\t\\t1\\t2     3   4\\n\\t\\t1   2     3   4\\n\\t\\t1   2     3   4\\n\\t\\t*/\\n        for (int i = 1; i < n; i++) {\\n            int temp = i;\\n            int j = 0;\\n\\t\\t\\t//adding diagnal elements to a list\\n            ArrayList<Integer> l = new ArrayList<>();\\n            while (temp < n &&  j < m){\\n                l.add(mat[j++][temp++]);\\n            }\\n\\t\\t\\t//sorting the list\\n            l.sort(null);\\n            temp = i;\\n            j = 0;\\n\\t\\t\\t//replacing them  in the sorted order in matrix\\n           for (int k = 0; k < l.size(); k++){\\n                mat[j++][temp++] = l.get(k);\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        int m = mat.length;//no:of rows\\n        int n = mat[0].length;//no:of columns\\n\\t\\t//sorting diagonals whose starting element is in 1st column\\n\\t\\t/** \\n\\t\\t-> **1** 2 3 4\\n\\t\\t-> **1** **2** 3 4\\n\\t\\t->** 1 ****2** **3** 4\\n\\t\\t// sorting these diagonals\\n\\t\\t*/\\n        for (int i = 0; i < m; i++) {\\n            int temp = i;\\n            int j = 0;\\n            ArrayList<Integer> l = new ArrayList<>();\\n\\t\\t\\t//adding diagnal elements to a list\\n            while (temp < m &&  j < n){\\n                l.add(mat[temp++][j++]);\\n            }\\n\\t\\t\\t//sorting the list\\n            l.sort(null);\\n            temp = i;\\n            j = 0;\\n\\t\\t\\t//replacing them  in the sorted order in matrix\\n           for (int k = 0; k < l.size(); k++){\\n                mat[temp++][j++] = l.get(k);\\n            }\\n        }\\n\\t\\t//sorting diagonals whose starting element is in 1st row\\n\\t\\t/** \\n\\t\\t\\t|     |   |\\n\\t\\t\\tV     V   V\\n\\t\\t1\\t2     3   4\\n\\t\\t1   2     3   4\\n\\t\\t1   2     3   4\\n\\t\\t*/\\n        for (int i = 1; i < n; i++) {\\n            int temp = i;\\n            int j = 0;\\n\\t\\t\\t//adding diagnal elements to a list\\n            ArrayList<Integer> l = new ArrayList<>();\\n            while (temp < n &&  j < m){\\n                l.add(mat[j++][temp++]);\\n            }\\n\\t\\t\\t//sorting the list\\n            l.sort(null);\\n            temp = i;\\n            j = 0;\\n\\t\\t\\t//replacing them  in the sorted order in matrix\\n           for (int k = 0; k < l.size(); k++){\\n                mat[j++][temp++] = l.get(k);\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493172,
                "title": "java-simplest-solution-using-countsort",
                "content": "```\\n\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        //using countsort\\n        \\n        int m=mat.length;\\n        int n=mat[0].length;\\n        \\n        for(int i=0;i<m;i++){\\n            countsort(mat,i,0);\\n        }\\n        \\n        for(int j=1;j<n;j++){\\n            countsort(mat,0,j);\\n        }\\n        \\n        return mat;\\n    }\\n    \\n    public void countsort(int [][]mat, int i, int j){\\n        int []map=new int[101];\\n        int r=i;\\n        int c=j;\\n        \\n        int m=mat.length;\\n        int n=mat[0].length;\\n        \\n        while(r<m && c<n){\\n            map[mat[r][c]]++;\\n            r++;\\n            c++;\\n        }\\n        \\n        r=i;\\n        c=j;\\n        \\n        for(int k=1;k<101;k++){\\n            while(map[k]>0){\\n                mat[r][c]=k;\\n                map[k]--;\\n                r++;\\n                c++;\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        //using countsort\\n        \\n        int m=mat.length;\\n        int n=mat[0].length;\\n        \\n        for(int i=0;i<m;i++){\\n            countsort(mat,i,0);\\n        }\\n        \\n        for(int j=1;j<n;j++){\\n            countsort(mat,0,j);\\n        }\\n        \\n        return mat;\\n    }\\n    \\n    public void countsort(int [][]mat, int i, int j){\\n        int []map=new int[101];\\n        int r=i;\\n        int c=j;\\n        \\n        int m=mat.length;\\n        int n=mat[0].length;\\n        \\n        while(r<m && c<n){\\n            map[mat[r][c]]++;\\n            r++;\\n            c++;\\n        }\\n        \\n        r=i;\\n        c=j;\\n        \\n        for(int k=1;k<101;k++){\\n            while(map[k]>0){\\n                mat[r][c]=k;\\n                map[k]--;\\n                r++;\\n                c++;\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492470,
                "title": "python-solution-for-beginners-short-and-simple-bubble-sort",
                "content": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        num_cols = len(mat[0])\\n        num_rows = len(mat)\\n        unsorted = True\\n        \\n        while unsorted:\\n            unsorted = False\\n            for row in range(num_rows - 1):\\n                for col in range(num_cols - 1):\\n                    if mat[row][col] > mat[row+1][col+1]:\\n                        unsorted = True\\n                        mat[row][col], mat[row+1][col+1] = mat[row+1][col+1], mat[row][col]\\n        \\n        return mat\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        num_cols = len(mat[0])\\n        num_rows = len(mat)\\n        unsorted = True\\n        \\n        while unsorted:\\n            unsorted = False\\n            for row in range(num_rows - 1):\\n                for col in range(num_cols - 1):\\n                    if mat[row][col] > mat[row+1][col+1]:\\n                        unsorted = True\\n                        mat[row][col], mat[row+1][col+1] = mat[row+1][col+1], mat[row][col]\\n        \\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492432,
                "title": "daily-leetcode-solution-t-c-o-n-2log-n-no-extra-space-used",
                "content": "![image](https://assets.leetcode.com/users/images/db973a91-4240-4de3-9b67-9be96a4c7264_1661649083.603435.png)\\n![image](https://assets.leetcode.com/users/images/7b3b1252-2f01-41d4-86b5-9d847febdd61_1661649141.6519446.png)\\n",
                "solutionTags": [
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/db973a91-4240-4de3-9b67-9be96a4c7264_1661649083.603435.png)\\n![image](https://assets.leetcode.com/users/images/7b3b1252-2f01-41d4-86b5-9d847febdd61_1661649141.6519446.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2492357,
                "title": "python-very-easy-solution",
                "content": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        m = len(mat)\\n        n = len(mat[0])\\n        \\n        for i in range(m):\\n          j = i\\n          k=0\\n          li =[]\\n          \\n          while(j<m and k<n):\\n            li.append(mat[j][k])\\n            j+=1\\n            k+=1\\n          li.sort();\\n          \\n          j=i\\n          k=0\\n          l=0\\n          while(j<m and k<n):\\n            mat[j][k]=li[l]\\n            j+=1\\n            k+=1\\n            l+=1\\n          \\n        \\n        for i in range(1,n):\\n          j=0\\n          k=i\\n          li =[]\\n          \\n          while(j<m and k<n):\\n            li.append(mat[j][k])\\n            j+=1\\n            k+=1\\n          li.sort();\\n          \\n          j=0\\n          k=i\\n          l=0\\n          while(j<m and k<n):\\n            mat[j][k]=li[l]\\n            j+=1\\n            k+=1\\n            l+=1\\n            \\n        return mat\\n          \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        m = len(mat)\\n        n = len(mat[0])\\n        \\n        for i in range(m):\\n          j = i\\n          k=0\\n          li =[]\\n          \\n          while(j<m and k<n):\\n            li.append(mat[j][k])\\n            j+=1\\n            k+=1\\n          li.sort();\\n          \\n          j=i\\n          k=0\\n          l=0\\n          while(j<m and k<n):\\n            mat[j][k]=li[l]\\n            j+=1\\n            k+=1\\n            l+=1\\n          \\n        \\n        for i in range(1,n):\\n          j=0\\n          k=i\\n          li =[]\\n          \\n          while(j<m and k<n):\\n            li.append(mat[j][k])\\n            j+=1\\n            k+=1\\n          li.sort();\\n          \\n          j=0\\n          k=i\\n          l=0\\n          while(j<m and k<n):\\n            mat[j][k]=li[l]\\n            j+=1\\n            k+=1\\n            l+=1\\n            \\n        return mat\\n          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2329617,
                "title": "simple-sol-faster-than-98-68-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void help(vector<vector<int>>& mat,int i,int j,int r,int c){\\n        vector<int> v;\\n        int tempi=i,tempj=j;\\n        while(tempi<r && tempj<c){\\n            v.push_back(mat[tempi++][tempj++]);\\n        }\\n        sort(v.begin(),v.end());\\n        int k=0;\\n        while(i<r && j<c){\\n            mat[i++][j++]=v[k++];\\n        }\\n    }\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int c=mat[0].size(),r=mat.size();\\n        for(int i=0, j=0;i<r;i++){\\n                if(i==0){\\n                    for(int k=0;k<c;k++){\\n                    help(mat,i,k,r,c);\\n                    }\\n                }\\n                else help(mat,i,j,r,c);\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void help(vector<vector<int>>& mat,int i,int j,int r,int c){\\n        vector<int> v;\\n        int tempi=i,tempj=j;\\n        while(tempi<r && tempj<c){\\n            v.push_back(mat[tempi++][tempj++]);\\n        }\\n        sort(v.begin(),v.end());\\n        int k=0;\\n        while(i<r && j<c){\\n            mat[i++][j++]=v[k++];\\n        }\\n    }\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int c=mat[0].size(),r=mat.size();\\n        for(int i=0, j=0;i<r;i++){\\n                if(i==0){\\n                    for(int k=0;k<c;k++){\\n                    help(mat,i,k,r,c);\\n                    }\\n                }\\n                else help(mat,i,j,r,c);\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321661,
                "title": "concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        unordered_map<int, multiset<int>> m;\\n        vector<vector<int>> ans(mat.size(), vector<int>(mat[0].size()));\\n        \\n        for(int i=0; i<mat.size(); i++)\\n            for(int j=0; j<mat[i].size(); j++) m[i - j].insert(mat[i][j]);\\n        \\n        for(int i=0; i<ans.size(); i++) {\\n            for(int j=0; j<ans[i].size(); j++) {\\n                ans[i][j] = *m[i - j].begin();\\n                m[i - j].erase(m[i - j].begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        unordered_map<int, multiset<int>> m;\\n        vector<vector<int>> ans(mat.size(), vector<int>(mat[0].size()));\\n        \\n        for(int i=0; i<mat.size(); i++)\\n            for(int j=0; j<mat[i].size(); j++) m[i - j].insert(mat[i][j]);\\n        \\n        for(int i=0; i<ans.size(); i++) {\\n            for(int j=0; j<ans[i].size(); j++) {\\n                ans[i][j] = *m[i - j].begin();\\n                m[i - j].erase(m[i - j].begin());\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226169,
                "title": "c-simple-priority-queue-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        unordered_map<int, priority_queue<int,vector<int>,greater<int>>> mp;\\n        int n= mat.size(), m = mat[0].size();\\n        \\n        for(int i=0;i<n;i++) \\n            for(int j=0;j<m ;j++) \\n                mp[i-j].push(mat[i][j]);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                mat[i][j]= mp[i-j].top();\\n                mp[i-j].pop();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        unordered_map<int, priority_queue<int,vector<int>,greater<int>>> mp;\\n        int n= mat.size(), m = mat[0].size();\\n        \\n        for(int i=0;i<n;i++) \\n            for(int j=0;j<m ;j++) \\n                mp[i-j].push(mat[i][j]);\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                mat[i][j]= mp[i-j].top();\\n                mp[i-j].pop();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066772,
                "title": "cpp-easy-code-simple-and-sweet",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n         // to solve this we will use the the priority queue + indexing i - j\\n        \\n        /*\\n                        index                   list         sorted list\\n            3 3 1 1     i-j = 1 - 4 = -3        1            1\\n            2 2 1 2     -2                      1 2          1 2\\n            1 1 1 2     -1                      3 1 2        1 2 3\\n                         0                      3 2 1        1 2 3 \\n                         1                      2 1          1 2\\n                         2                      1            1\\n                         \\n        */\\n        \\n        unordered_map< int , priority_queue<int , vector<int> , greater<int>>> mp;\\n        \\n        // first making the list for adjacent indexes \\n        int n = mat.size() , m = mat[0].size();\\n        \\n        for( int i= 0 ; i < n ; i ++){\\n            for( int j = 0 ; j < m ; j ++){\\n                mp[i-j].push(mat[i][j]);\\n            }\\n        }\\n        \\n        // so now we have the hash map of the matrix now we will again assign the values to mat\\n        for( int i = 0 ;i < n ; i ++){\\n            for( int j = 0 ; j < m ; j ++){\\n                mat[i][j] = mp[i-j].top();\\n                \\n                mp[i-j].pop();\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n         // to solve this we will use the the priority queue + indexing i - j\\n        \\n        /*\\n                        index                   list         sorted list\\n            3 3 1 1     i-j = 1 - 4 = -3        1            1\\n            2 2 1 2     -2                      1 2          1 2\\n            1 1 1 2     -1                      3 1 2        1 2 3\\n                         0                      3 2 1        1 2 3 \\n                         1                      2 1          1 2\\n                         2                      1            1\\n                         \\n        */\\n        \\n        unordered_map< int , priority_queue<int , vector<int> , greater<int>>> mp;\\n        \\n        // first making the list for adjacent indexes \\n        int n = mat.size() , m = mat[0].size();\\n        \\n        for( int i= 0 ; i < n ; i ++){\\n            for( int j = 0 ; j < m ; j ++){\\n                mp[i-j].push(mat[i][j]);\\n            }\\n        }\\n        \\n        // so now we have the hash map of the matrix now we will again assign the values to mat\\n        for( int i = 0 ;i < n ; i ++){\\n            for( int j = 0 ; j < m ; j ++){\\n                mat[i][j] = mp[i-j].top();\\n                \\n                mp[i-j].pop();\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961556,
                "title": "c-easy-fast",
                "content": "class Solution {\\npublic:\\n```\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int row=mat.size();\\n        int col=mat[0].size();\\n        \\n        for(int i=0;i<row;i++)\\n        {\\n            vector<int>temp;\\n            int j=0,k=i;\\n            \\n            while(k<row && j<col)\\n            {\\n                temp.push_back(mat[k][j]);\\n                j++;\\n                k++;\\n            }\\n            sort(temp.begin(),temp.end());\\n            \\n            k=i;\\n            j=0;\\n            int a=0;\\n            while(k<row && j<col)\\n            {\\n                mat[k][j]=temp[a];\\n                a++;;\\n                j++;\\n                k++;\\n            }\\n        }\\n            \\n            for(int i=1;i<col;i++)\\n        {\\n            vector<int>temp;\\n            int j=0,k=i;\\n            \\n            while(k<col && j<row)\\n            {\\n                temp.push_back(mat[j][k]);\\n                j++;\\n                k++;\\n            }\\n            sort(temp.begin(),temp.end());\\n            \\n            k=i;\\n            j=0;\\n            int a=0;\\n            while(k<col && j<row)\\n            {\\n                mat[j][k]=temp[a];\\n                a++;;\\n                j++;\\n                k++;\\n            }\\n              \\n        }\\n            return mat;\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n```\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int row=mat.size();\\n        int col=mat[0].size();\\n        \\n        for(int i=0;i<row;i++)\\n        {\\n            vector<int>temp;\\n            int j=0,k=i;\\n            \\n            while(k<row && j<col)\\n            {\\n                temp.push_back(mat[k][j]);\\n                j++;\\n                k++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1938005,
                "title": "scala",
                "content": "```\\nobject Solution {\\n  def diagonalSort(mat: Array[Array[Int]]): Array[Array[Int]] = {\\n    val m = mat.length\\n    val n = mat.headOption.map(_.length).getOrElse(0)\\n    \\n    Iterator\\n      .tabulate(m)(_ -> 0)\\n      .concat(Iterator.range(1, n).map(0 -> _))\\n      .map { case (i, j) => (0 until math.min(m - i, n - j)).view.map(k => (i + k, j + k)) }\\n      .foreach { diagonal =>\\n        diagonal\\n          .zip {\\n            diagonal\\n              .map { case (i, j) => mat(i)(j) }\\n              .sorted\\n          }\\n          .foreach { case ((i, j), value) => mat(i)(j) = value }\\n      }\\n    \\n    mat\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def diagonalSort(mat: Array[Array[Int]]): Array[Array[Int]] = {\\n    val m = mat.length\\n    val n = mat.headOption.map(_.length).getOrElse(0)\\n    \\n    Iterator\\n      .tabulate(m)(_ -> 0)\\n      .concat(Iterator.range(1, n).map(0 -> _))\\n      .map { case (i, j) => (0 until math.min(m - i, n - j)).view.map(k => (i + k, j + k)) }\\n      .foreach { diagonal =>\\n        diagonal\\n          .zip {\\n            diagonal\\n              .map { case (i, j) => mat(i)(j) }\\n              .sorted\\n          }\\n          .foreach { case ((i, j), value) => mat(i)(j) = value }\\n      }\\n    \\n    mat\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1820742,
                "title": "java-easy-solution-using-hashmap-and-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        \\n        HashMap<Integer,PriorityQueue<Integer>> map = new HashMap<Integer,PriorityQueue<Integer>>();\\n        \\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[i].length;j++){\\n                map.putIfAbsent(i-j,new PriorityQueue<Integer>());\\n                map.get(i-j).add(mat[i][j]);\\n            }\\n        }\\n        \\n        int[][] ans=new int[mat.length][mat[0].length];\\n        \\n        for(int i=0;i<ans.length;i++){\\n            for(int j=0;j<ans[i].length;j++){\\n                ans[i][j]=map.get(i-j).poll();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        \\n        HashMap<Integer,PriorityQueue<Integer>> map = new HashMap<Integer,PriorityQueue<Integer>>();\\n        \\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[i].length;j++){\\n                map.putIfAbsent(i-j,new PriorityQueue<Integer>());\\n                map.get(i-j).add(mat[i][j]);\\n            }\\n        }\\n        \\n        int[][] ans=new int[mat.length][mat[0].length];\\n        \\n        for(int i=0;i<ans.length;i++){\\n            for(int j=0;j<ans[i].length;j++){\\n                ans[i][j]=map.get(i-j).poll();\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795896,
                "title": "java-easy-and-concise-solution-using-hashmap-and-priority-queue",
                "content": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        HashMap<Integer, PriorityQueue<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < mat.length; i++){\\n            for(int j = 0; j < mat[0].length; j++){\\n                int val = i - j;\\n                map.putIfAbsent(val, new PriorityQueue<>());\\n                map.get(val).add(mat[i][j]);\\n            }\\n        }\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n        \\tfor(int j = 0; j < mat[0].length; j++) {\\n        \\t\\tint val = i - j;\\n        \\t\\tint toput = map.get(val).remove();\\n        \\t\\tmat[i][j] = toput;\\n        \\t}\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        HashMap<Integer, PriorityQueue<Integer>> map = new HashMap<>();\\n        for(int i = 0; i < mat.length; i++){\\n            for(int j = 0; j < mat[0].length; j++){\\n                int val = i - j;\\n                map.putIfAbsent(val, new PriorityQueue<>());\\n                map.get(val).add(mat[i][j]);\\n            }\\n        }\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n        \\tfor(int j = 0; j < mat[0].length; j++) {\\n        \\t\\tint val = i - j;\\n        \\t\\tint toput = map.get(val).remove();\\n        \\t\\tmat[i][j] = toput;\\n        \\t}\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673236,
                "title": "easy-to-understand-javascript-typescript",
                "content": "Start with each column in the top row to get and sort each of those diagonals.\\nThen go down the first (leftmost) row to get and sort each of those columns. \\n\\nAfter you get and sort each column, set the sorted diagonals in the same way we got them. To traverse on diagonal we just increase row + 1 and column + 1 until we reach the end.\\n\\n```\\nfunction diagonalSort(mat: number[][]): number[][] {\\n    \\n    const sortedMat = Array(mat.length).fill(0).map(a => []);\\n    \\n    function getDiag(r, c) {\\n        const out = [];\\n        while (r < mat.length && c < mat[0].length) {\\n            out.push(mat[r++][c++]);\\n        }\\n        return out;\\n    }\\n    \\n    function setDiag(r, c, cells) {\\n        while (r < mat.length && c < mat[0].length) {\\n            sortedMat[r++][c++] = cells.shift();\\n        }\\n    }\\n    \\n    for (let c = 0; c < mat[0].length; c++) {\\n        const diag = getDiag(0, c);\\n        setDiag(0, c, diag.sort((a,b) => a - b));\\n    }\\n    \\n    for (let r = 0; r < mat.length; r++) {\\n        const diag = getDiag(r, 0);\\n        setDiag(r, 0, diag.sort((a,b) => a - b));\\n    }\\n    \\n    return sortedMat;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction diagonalSort(mat: number[][]): number[][] {\\n    \\n    const sortedMat = Array(mat.length).fill(0).map(a => []);\\n    \\n    function getDiag(r, c) {\\n        const out = [];\\n        while (r < mat.length && c < mat[0].length) {\\n            out.push(mat[r++][c++]);\\n        }\\n        return out;\\n    }\\n    \\n    function setDiag(r, c, cells) {\\n        while (r < mat.length && c < mat[0].length) {\\n            sortedMat[r++][c++] = cells.shift();\\n        }\\n    }\\n    \\n    for (let c = 0; c < mat[0].length; c++) {\\n        const diag = getDiag(0, c);\\n        setDiag(0, c, diag.sort((a,b) => a - b));\\n    }\\n    \\n    for (let r = 0; r < mat.length; r++) {\\n        const diag = getDiag(r, 0);\\n        setDiag(r, 0, diag.sort((a,b) => a - b));\\n    }\\n    \\n    return sortedMat;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1652082,
                "title": "c-hashing-set-solution-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n\\t\\t\\t  int r=mat.size(),c=mat[0].size();\\n\\t\\t\\tif(r==1)\\n\\t\\t\\t\\t return mat;\\n\\t\\t\\t//storing element corresponding to one diagonal\\n\\t\\t\\t  unordered_map<int,multiset<int>> mp;\\n\\t\\t\\t//O(r*c)\\n\\t\\t\\t for(int i=0;i<r;i++){\\n\\t\\t\\t\\t for(int j=0;j<c;j++){\\n\\t\\t\\t\\t\\t mp[i-j].insert(mat[i][j]);\\n\\t\\t\\t\\t }\\n\\t\\t\\t }\\n\\n\\t\\t\\t//start filling element in increasing order\\n\\t\\t\\t//row fixed to 0\\n\\t\\t\\tfor(int j=0;j<c;j++){\\n\\t\\t\\t\\tint row=0,col=j;\\n\\t\\t\\t\\t\\tfor(auto it: mp[row-col]){\\n\\t\\t\\t\\t\\t\\t mat[row][col]=it;\\n\\t\\t\\t\\t\\t\\t row++;\\n\\t\\t\\t\\t\\t\\tcol++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t//column fixed to 0\\n\\t\\t\\tfor(int i=1;i<r;i++){\\n\\t\\t\\t\\tint row=i,col=0;\\n\\t\\t\\t\\t\\tfor(auto it: mp[row-col]){\\n\\t\\t\\t\\t\\t\\t mat[row][col]=it;\\n\\t\\t\\t\\t\\t\\t row++;\\n\\t\\t\\t\\t\\t\\tcol++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn mat;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n\\t\\t\\t  int r=mat.size(),c=mat[0].size();\\n\\t\\t\\tif(r==1)\\n\\t\\t\\t\\t return mat;\\n\\t\\t\\t//storing element corresponding to one diagonal\\n\\t\\t\\t  unordered_map<int,multiset<int>> mp;\\n\\t\\t\\t//O(r*c)\\n\\t\\t\\t for(int i=0;i<r;i++){\\n\\t\\t\\t\\t for(int j=0;j<c;j++){\\n\\t\\t\\t\\t\\t mp[i-j].insert(mat[i][j]);\\n\\t\\t\\t\\t }",
                "codeTag": "Java"
            },
            {
                "id": 1610342,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func diagonalSort(_ mat: [[Int]]) -> [[Int]] {\\n        // Build diagonals dictionary\\n        var diagonals: [Int: [Int]] = [:]\\n        for i in 0..<mat.count {\\n            for j in 0..<mat[i].count {\\n                diagonals[i-j, default: []] += [mat[i][j]]\\n            }\\n        }\\n        // Sort each array in the dictionary\\n        for key in diagonals.keys {\\n            diagonals[key] = diagonals[key, default: []].sorted()\\n        }\\n        // Fill the output matrix with the sorted values\\n        var output = mat\\n        for i in 0..<mat.count {\\n            for j in 0..<mat[i].count {\\n                output[i][j] = diagonals[i-j]!.removeFirst()\\n            }\\n        }\\n        return output\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func diagonalSort(_ mat: [[Int]]) -> [[Int]] {\\n        // Build diagonals dictionary\\n        var diagonals: [Int: [Int]] = [:]\\n        for i in 0..<mat.count {\\n            for j in 0..<mat[i].count {\\n                diagonals[i-j, default: []] += [mat[i][j]]\\n            }\\n        }\\n        // Sort each array in the dictionary\\n        for key in diagonals.keys {\\n            diagonals[key] = diagonals[key, default: []].sorted()\\n        }\\n        // Fill the output matrix with the sorted values\\n        var output = mat\\n        for i in 0..<mat.count {\\n            for j in 0..<mat[i].count {\\n                output[i][j] = diagonals[i-j]!.removeFirst()\\n            }\\n        }\\n        return output\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604108,
                "title": "c-priority-queue-one-diagonal-at-a-time-99-time-98-memory",
                "content": "First I go through all the diagonals that start on the left side of the matrix (for example, [0, 0], [1, 0], ..., [n-2,0], [n-1, 0]) and insert all of the elements in the diagonal to the priority queue. then I go again through the diagonal and insert the top of the queue to the matrix.\\nThen I go throught all the diagonals that start on the top of the matrix ([0, 1], [0, 2], ..., [0, m-1]) and go through the same proccess.\\nthe priority queue will pop the elements in ascending order.\\nNote that I do not actually need to do it for the \"tips\" of the matrix ([n-1, 0] and [0, m-1]) as they only contain one element and thus already sorted.\\nThis is not the most elegent solution but it is conservative in space compared to creating a map of priority queues and holds the same time complexity.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        if(mat.size() == 0) {\\n            return mat;\\n        }\\n        int m = mat[0].size(), n = mat.size();\\n\\n        priority_queue<int, vector<int>, std::greater<int>> p;\\n        for(int i=n-2; i>=0; --i) {\\n            int k=i, j=0;\\n            while(k<n && j<m) {\\n                p.push(mat[k++][j++]);\\n            }\\n            k=i, j=0;\\n            while(k<n && j<m) {\\n                mat[k++][j++] = p.top();\\n                p.pop();\\n            }\\n        }\\n        for(int j=1; j<m-1; ++j) {\\n            int k=j, i=0;\\n            while(i<n && k<m) {\\n                p.push(mat[i++][k++]);\\n            }\\n            k=j, i=0;\\n            while(i<n && k<m) {\\n                mat[i++][k++] = p.top();\\n                p.pop();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        if(mat.size() == 0) {\\n            return mat;\\n        }\\n        int m = mat[0].size(), n = mat.size();\\n\\n        priority_queue<int, vector<int>, std::greater<int>> p;\\n        for(int i=n-2; i>=0; --i) {\\n            int k=i, j=0;\\n            while(k<n && j<m) {\\n                p.push(mat[k++][j++]);\\n            }\\n            k=i, j=0;\\n            while(k<n && j<m) {\\n                mat[k++][j++] = p.top();\\n                p.pop();\\n            }\\n        }\\n        for(int j=1; j<m-1; ++j) {\\n            int k=j, i=0;\\n            while(i<n && k<m) {\\n                p.push(mat[i++][k++]);\\n            }\\n            k=j, i=0;\\n            while(i<n && k<m) {\\n                mat[i++][k++] = p.top();\\n                p.pop();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523871,
                "title": "unordered-map-c",
                "content": "*Space O(MN), Time: O(MNLogK) where k is the size of the diagonal*\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n       int M=mat.size();\\n        int n=mat[0].size();\\n        unordered_map<int,priority_queue<int,vector<int>,greater<int>>>m;\\n        for(int i=0;i<M;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                m[j-i].push(mat[i][j]);\\n            }\\n        }\\n        for(int i=0;i<M;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                mat[i][j]=m[j-i].top();\\n                m[j-i].pop();\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```\\n\\n*feel free to ask if having doubt in this*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n       int M=mat.size();\\n        int n=mat[0].size();\\n        unordered_map<int,priority_queue<int,vector<int>,greater<int>>>m;\\n        for(int i=0;i<M;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                m[j-i].push(mat[i][j]);\\n            }\\n        }\\n        for(int i=0;i<M;i++){\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                mat[i][j]=m[j-i].top();\\n                m[j-i].pop();\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487109,
                "title": "easy-java-solution",
                "content": "class Solution {\\n\\n    public int[][] diagonalSort(int[][] mat) {\\n        for(int k = mat.length-1; k>=0; k--)\\n        {\\n            for(int i =0; i<k; i++)\\n            {\\n                for(int j =0; j+1<mat[i].length; j++)\\n                {\\n                    if(mat[i][j]>mat[i+1][j+1])\\n                    {\\n                        int temp = mat[i][j];\\n                        mat[i][j] = mat[i+1][j+1];\\n                        mat[i+1][j+1] = temp;\\n                    }\\n                }\\n            }\\n        }\\n        return mat;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public int[][] diagonalSort(int[][] mat) {\\n        for(int k = mat.length-1; k>=0; k--)\\n        {\\n            for(int i =0; i<k; i++)\\n            {\\n                for(int j =0; j+1<mat[i].length; j++)\\n                {\\n                    if(mat[i][j]>mat[i+1][j+1])\\n                    {\\n                        int temp = mat[i][j];\\n                        mat[i][j] = mat[i+1][j+1];\\n                        mat[i+1][j+1] = temp;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1459834,
                "title": "faster-easy",
                "content": "***Like it? Kindly Upvote***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) \\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        unordered_map<int , vector<int>> u;\\n\\t\\t// Inserting the gaps along with values into map\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                u[i - j].push_back(mat[i][j]);\\n            }\\n        }\\n        // Sort the values \\n        for(int gap = 1 - m ; gap < n ; gap++)\\n        {\\n            sort(u[gap].begin() , u[gap].end());\\n        }\\n        // Inserting values back into the matrix\\n        for(int i = n - 1 ; i >= 0 ; i--)\\n        {\\n            for(int j = m - 1 ; j >= 0 ; j--)\\n            {\\n                mat[i][j] = u[i - j].back();\\n                u[i - j].pop_back();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) \\n    {\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        unordered_map<int , vector<int>> u;\\n\\t\\t// Inserting the gaps along with values into map\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                u[i - j].push_back(mat[i][j]);\\n            }\\n        }\\n        // Sort the values \\n        for(int gap = 1 - m ; gap < n ; gap++)\\n        {\\n            sort(u[gap].begin() , u[gap].end());\\n        }\\n        // Inserting values back into the matrix\\n        for(int i = n - 1 ; i >= 0 ; i--)\\n        {\\n            for(int j = m - 1 ; j >= 0 ; j--)\\n            {\\n                mat[i][j] = u[i - j].back();\\n                u[i - j].pop_back();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1425391,
                "title": "c-easy-solution-using-unordered-map-and-priority-queue",
                "content": "Whenever there is question on diagonal processing of matrix, try to find a pattern between the indices of the elements from matrix, that lie on the same diagonal.\\nNotice that whenever the diagonals are from bottom left to upper right, the sum of i and j in mat[i][j] remains same for elements on one diagonal.\\nSimilarly when diagonals go from top left to bottom right the difference of i and j in mat[i][j] remains same for elements on one diagonal.\\nHere we will use same property, make an unordered_map storing the diagonal number as key and priority queue as value. The diagonal number will be found by (i-j) and priority queue (min heap) to maintain all the elements in the sorted order. \\nOnce the elements are stored in the unordered_map, we again iterate over the matrix and update all values according to priority queue. Notice that as we have min heap, the smallest value will be assigned in mat first and as we process further, rest of the values will be included.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> A;\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                A[i-j].push(mat[i][j]);\\n            }\\n        }\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                mat[i][j] = A[i-j].top();\\n                A[i-j].pop();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```\\nTime complexity: O(M * N * log(min(N, M))) -> in M * N iterations we update the longest diagonal of length min (N, M) \\nSpace complexity: O(M * N)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> A;\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                A[i-j].push(mat[i][j]);\\n            }\\n        }\\n        for(int i=0; i<m; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                mat[i][j] = A[i-j].top();\\n                A[i-j].pop();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395034,
                "title": "c-unordered-map-and-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        unordered_map<int,priority_queue<int, vector<int> ,greater<int>> > mp;\\n        \\n        for(int i=0;i<mat.size();i++)\\n            for(int j=0;j<mat[0].size();j++)\\n                mp[i-j].push(mat[i][j]);\\n          \\n\\t\\t  \\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n                mat[i][j]=mp[i-j].top();\\n                mp[i-j].pop();\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n\\nTC: 0(M*N*Log(M+N))",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        unordered_map<int,priority_queue<int, vector<int> ,greater<int>> > mp;\\n        \\n        for(int i=0;i<mat.size();i++)\\n            for(int j=0;j<mat[0].size();j++)\\n                mp[i-j].push(mat[i][j]);\\n          \\n\\t\\t  \\n        for(int i=0;i<mat.size();i++)\\n        {\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n                mat[i][j]=mp[i-j].top();\\n                mp[i-j].pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1389913,
                "title": "javascript-solution-map-and-sort",
                "content": "```\\nvar diagonalSort = function(mat) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    \\n    const map = new Map();\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            const vector = i - j;\\n            \\n            if (!map.has(vector)) map.set(vector, []);\\n            map.get(vector).push(mat[i][j]);\\n        }\\n    }\\n\\n    for (const [key, nums] of map) {\\n        map.set(key, nums.sort((a, b) => b - a));\\n    }    \\n   \\n\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            const vector = i - j;\\n            \\n            mat[i][j] = map.get(vector).pop();\\n        }\\n    }\\n    \\n    return mat;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nvar diagonalSort = function(mat) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    \\n    const map = new Map();\\n    \\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            const vector = i - j;\\n            \\n            if (!map.has(vector)) map.set(vector, []);\\n            map.get(vector).push(mat[i][j]);\\n        }\\n    }\\n\\n    for (const [key, nums] of map) {\\n        map.set(key, nums.sort((a, b) => b - a));\\n    }    \\n   \\n\\n    for (let i = 0; i < m; i++) {\\n        for (let j = 0; j < n; j++) {\\n            const vector = i - j;\\n            \\n            mat[i][j] = map.get(vector).pop();\\n        }\\n    }\\n    \\n    return mat;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369594,
                "title": "using-priority-queue-and-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        unordered_map<int,priority_queue<int,vector<int>,greater<int>>> mp;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[i].size();j++){\\n                mp[i-j].push(mat[i][j]);\\n            }\\n        }\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[i].size();j++){\\n                mat[i][j] = mp[i-j].top();\\n                mp[i-j].pop();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        unordered_map<int,priority_queue<int,vector<int>,greater<int>>> mp;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[i].size();j++){\\n                mp[i-j].push(mat[i][j]);\\n            }\\n        }\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[i].size();j++){\\n                mat[i][j] = mp[i-j].top();\\n                mp[i-j].pop();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162211,
                "title": "c-easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void diagonal_sort(vector<vector<int>>& mat,int row,int col,int n,int m){\\n        vector<int> v;\\n         int r = row ,c = col;\\n        while(r<n && c<m){\\n            v.push_back(mat[r][c]);\\n            r++;\\n            c++;\\n        }\\n        sort(v.begin(),v.end());\\n         r = row;\\n         c = col;\\n        int idx = 0;\\n        while(r<n && c<m){\\n            mat[r][c] = v[idx];\\n            r++;\\n            c++;\\n            idx++;\\n        }\\n        \\n        \\n    }\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        \\n        int n = mat.size();\\n        int m = mat[0].size();\\n        for(int col=0;col<m;col++){\\n            diagonal_sort(mat,0,col,n,m);\\n        }\\n        for(int row = 1;row<n;row++){\\n           diagonal_sort(mat,row,0,n,m);\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void diagonal_sort(vector<vector<int>>& mat,int row,int col,int n,int m){\\n        vector<int> v;\\n         int r = row ,c = col;\\n        while(r<n && c<m){\\n            v.push_back(mat[r][c]);\\n            r++;\\n            c++;\\n        }\\n        sort(v.begin(),v.end());\\n         r = row;\\n         c = col;\\n        int idx = 0;\\n        while(r<n && c<m){\\n            mat[r][c] = v[idx];\\n            r++;\\n            c++;\\n            idx++;\\n        }\\n        \\n        \\n    }\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        \\n        int n = mat.size();\\n        int m = mat[0].size();\\n        for(int col=0;col<m;col++){\\n            diagonal_sort(mat,0,col,n,m);\\n        }\\n        for(int row = 1;row<n;row++){\\n           diagonal_sort(mat,row,0,n,m);\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1093244,
                "title": "java-1-simple-method-95-runtime",
                "content": "```\\npublic int[][] diagonalSort(int[][] mat) {\\n        int cols = mat.length;\\n        int rows = mat[0].length;\\n\\n        for(int i = 0; i < cols + rows; i++){\\n            int r = i, c = 0;\\n            if(i > rows){\\n                r = 0;\\n                c = i - rows;\\n            }\\n\\n            int size = Math.min(cols - c, rows - r);\\n            int[] arr = new int[size];\\n            for(int x = 0; x < size; x++){\\n                arr[x] = mat[c + x][r + x];\\n            }\\n            Arrays.sort(arr);\\n\\n            for(int x = 0; x < size; x++){\\n                mat[c + x][r + x] = arr[x];\\n            }\\n        }\\n        return mat;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[][] diagonalSort(int[][] mat) {\\n        int cols = mat.length;\\n        int rows = mat[0].length;\\n\\n        for(int i = 0; i < cols + rows; i++){\\n            int r = i, c = 0;\\n            if(i > rows){\\n                r = 0;\\n                c = i - rows;\\n            }\\n\\n            int size = Math.min(cols - c, rows - r);\\n            int[] arr = new int[size];\\n            for(int x = 0; x < size; x++){\\n                arr[x] = mat[c + x][r + x];\\n            }\\n            Arrays.sort(arr);\\n\\n            for(int x = 0; x < size; x++){\\n                mat[c + x][r + x] = arr[x];\\n            }\\n        }\\n        return mat;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1084659,
                "title": "java-solution-easy-solution-o-n-2",
                "content": "```\\n//Storing the values of each diagonal in a temp array list\\n//sort them like a normal array\\n//store the sorted elements back again in the matrix\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        int rn = mat.length;\\n        int cn = mat[0].length;\\n        for(int j=0; j<cn-1; j++){\\n            ArrayList<Integer> temp = new ArrayList<Integer>();\\n            int i=0;\\n            int j_ = j;\\n            while(i<rn && j_<cn){\\n                temp.add(mat[i][j_]);\\n                i++; j_++;\\n            }\\n            Collections.sort(temp);\\n            i=0; j_=j;\\n            int index = 0;\\n            while(i<rn && j_<cn){\\n                mat[i][j_] = temp.get(index);\\n                i++; j_++; index++;\\n            }\\n        }\\n        for(int i=1; i<rn-1; i++){\\n            ArrayList<Integer> temp = new ArrayList<Integer>();\\n            int i_=i;\\n            int j =0;\\n            while(i_<rn && j<cn){\\n                temp.add(mat[i_][j]);\\n                i_++; j++;\\n            }\\n            Collections.sort(temp);\\n            i_=i; j=0;\\n            int index = 0;\\n            while(i_<rn && j<cn){\\n                mat[i_][j] = temp.get(index);\\n                i_++; j++; index++;\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//Storing the values of each diagonal in a temp array list\\n//sort them like a normal array\\n//store the sorted elements back again in the matrix\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        int rn = mat.length;\\n        int cn = mat[0].length;\\n        for(int j=0; j<cn-1; j++){\\n            ArrayList<Integer> temp = new ArrayList<Integer>();\\n            int i=0;\\n            int j_ = j;\\n            while(i<rn && j_<cn){\\n                temp.add(mat[i][j_]);\\n                i++; j_++;\\n            }\\n            Collections.sort(temp);\\n            i=0; j_=j;\\n            int index = 0;\\n            while(i<rn && j_<cn){\\n                mat[i][j_] = temp.get(index);\\n                i++; j_++; index++;\\n            }\\n        }\\n        for(int i=1; i<rn-1; i++){\\n            ArrayList<Integer> temp = new ArrayList<Integer>();\\n            int i_=i;\\n            int j =0;\\n            while(i_<rn && j<cn){\\n                temp.add(mat[i_][j]);\\n                i_++; j++;\\n            }\\n            Collections.sort(temp);\\n            i_=i; j=0;\\n            int index = 0;\\n            while(i_<rn && j<cn){\\n                mat[i_][j] = temp.get(index);\\n                i_++; j++; index++;\\n            }\\n        }\\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056006,
                "title": "java-count-sort-beats-100-1ms-o-m-n",
                "content": "\\n    // O(mat.length*mat[0].length)\\n\\t// Count Sort\\n\\tpublic int[][] diagonalSort(int[][] mat) {\\n\\n\\t\\tint m = mat.length;\\n\\t\\tint n = mat[0].length;\\n\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\tcountAndSort(mat, i, 0, m, n);\\n\\n\\t\\tfor (int j = 1; j < n; j++)\\n\\t\\t\\tcountAndSort(mat, 0, j, m, n);\\n\\n\\t\\treturn mat;\\n\\t}\\n\\n\\t// O(Math.min(mat.length,mat[0].length))\\n\\t// O(diagonal.length)\\n\\tpublic void countAndSort(int[][] mat, int x, int y, int m, int n) {\\n\\n\\t\\tint[] count = new int[101];\\n\\t\\tint i = x, j = y;\\n\\n\\t\\twhile (i < m && j < n) {\\n\\t\\t\\tcount[mat[i][j]]++;\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\n\\t\\ti = x;\\n\\t\\tj = y;\\n\\n\\t\\tfor (int c = 1; c <= 100; c++) {\\n\\t\\t\\twhile (count[c] > 0) {\\n\\t\\t\\t\\tmat[i][j] = c;\\n\\t\\t\\t\\tcount[c]--;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    // O(mat.length*mat[0].length)\\n\\t// Count Sort\\n\\tpublic int[][] diagonalSort(int[][] mat) {\\n\\n\\t\\tint m = mat.length;\\n\\t\\tint n = mat[0].length;\\n\\n\\t\\tfor (int i = 0; i < m; i++)\\n\\t\\t\\tcountAndSort(mat, i, 0, m, n);\\n\\n\\t\\tfor (int j = 1; j < n; j++)\\n\\t\\t\\tcountAndSort(mat, 0, j, m, n);\\n\\n\\t\\treturn mat;\\n\\t}\\n\\n\\t// O(Math.min(mat.length,mat[0].length))\\n\\t// O(diagonal.length)\\n\\tpublic void countAndSort(int[][] mat, int x, int y, int m, int n) {\\n\\n\\t\\tint[] count = new int[101];\\n\\t\\tint i = x, j = y;\\n\\n\\t\\twhile (i < m && j < n) {\\n\\t\\t\\tcount[mat[i][j]]++;\\n\\t\\t\\ti++;\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\n\\t\\ti = x;\\n\\t\\tj = y;\\n\\n\\t\\tfor (int c = 1; c <= 100; c++) {\\n\\t\\t\\twhile (count[c] > 0) {\\n\\t\\t\\t\\tmat[i][j] = c;\\n\\t\\t\\t\\tcount[c]--;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1031671,
                "title": "python-straight-solution",
                "content": "```\\nclass Solution(object):\\n    def diagonalSort(self, mat):\\n        d = dict()\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                if (i - j) not in d:\\n                    d[i-j] = []\\n                d[i-j].append(mat[i][j])\\n        \\n        for key in d:\\n            d[key].sort() \\n        \\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                mat[i][j] = d[i-j].pop(0) #you can try with deque for improving the time complexity\\n        \\n        return mat\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def diagonalSort(self, mat):\\n        d = dict()\\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                if (i - j) not in d:\\n                    d[i-j] = []\\n                d[i-j].append(mat[i][j])\\n        \\n        for key in d:\\n            d[key].sort() \\n        \\n        for i in range(len(mat)):\\n            for j in range(len(mat[0])):\\n                mat[i][j] = d[i-j].pop(0) #you can try with deque for improving the time complexity\\n        \\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031585,
                "title": "beats-97-explained-w-comments-python-3-speed-time-complexity-o-n-log-n",
                "content": "(N in title is the size of the whole matrix, not just length of matrix)\\n\\n```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n\\t\\t#creating dictionary\\n        dic = {}\\n\\t\\t\\n\\t\\t#for-loop through matrix\\n        for x in range(len(mat)):\\n            for y in range(len(mat[0])):\\n\\t\\t\\t\\t#putting numbers in dictionary based on what diagonal they\\'re in\\n                if y - x in dic:\\n                    dic[y - x].append(mat[x][y])\\n                else:\\n                    dic[y - x] = [mat[x][y]]\\n        \\n\\t\\t#creating a dictionary that\\'s the same as above but sorted\\n        sortdic = {}\\n        \\n        for x in dic:\\n            sortdic[x] = sorted(dic[x])\\n        \\n\\t\\t#creating a len(mat)*len(mat[0]) matrix filled with None\\n        ans = [[None for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n        \\n\\t\\t#for-loop through matrix\\n        for x in range(len(mat)):\\n            for y in range(len(mat[0])):\\n\\t\\t\\t\\t#adding variables from the sorted dictionary into our answer, and removing them\\n                ans[x][y] = sortdic[y - x].pop(0)\\n        \\n\\t\\t#returning answer\\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n\\t\\t#creating dictionary\\n        dic = {}\\n\\t\\t\\n\\t\\t#for-loop through matrix\\n        for x in range(len(mat)):\\n            for y in range(len(mat[0])):\\n\\t\\t\\t\\t#putting numbers in dictionary based on what diagonal they\\'re in\\n                if y - x in dic:\\n                    dic[y - x].append(mat[x][y])\\n                else:\\n                    dic[y - x] = [mat[x][y]]\\n        \\n\\t\\t#creating a dictionary that\\'s the same as above but sorted\\n        sortdic = {}\\n        \\n        for x in dic:\\n            sortdic[x] = sorted(dic[x])\\n        \\n\\t\\t#creating a len(mat)*len(mat[0]) matrix filled with None\\n        ans = [[None for _ in range(len(mat[0]))] for _ in range(len(mat))]\\n        \\n\\t\\t#for-loop through matrix\\n        for x in range(len(mat)):\\n            for y in range(len(mat[0])):\\n\\t\\t\\t\\t#adding variables from the sorted dictionary into our answer, and removing them\\n                ans[x][y] = sortdic[y - x].pop(0)\\n        \\n\\t\\t#returning answer\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031425,
                "title": "python-clean-simple",
                "content": "Use `dict` to keep track of each diagonal\\'s values in a list\\nUse `heap` to sort the list on the fly.\\n\\n```python\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        rows, cols = len(mat), len(mat[0])\\n        h = defaultdict(list)\\n        for i, j in product(range(rows), range(cols)):\\n            heappush(h[j-i], mat[i][j])\\n        for i, j in product(range(rows), range(cols)):\\n            mat[i][j] = heappop(h[j-i])\\n        return mat\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def diagonalSort(self, mat: List[List[int]]) -> List[List[int]]:\\n        rows, cols = len(mat), len(mat[0])\\n        h = defaultdict(list)\\n        for i, j in product(range(rows), range(cols)):\\n            heappush(h[j-i], mat[i][j])\\n        for i, j in product(range(rows), range(cols)):\\n            mat[i][j] = heappop(h[j-i])\\n        return mat\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031218,
                "title": "sort-the-matrix-diagonally-c-explained",
                "content": "We add the elements of matrix in a map of \\nkey = difference of row-col for element\\nvalue = vector of all such elements with same row-col\\n\\nthen we sort all these strings in a range based for loop\\nWe replace the sorted values back in the original matrix\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int r = mat.size();\\n        int c = mat[0].size();\\n        map<int,vector<int>> mp;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                mp[i-j].push_back(mat[i][j]);\\n            }\\n        }\\n        \\n        for(auto &p: mp)\\n        {\\n            sort(p.second.begin(), p.second.end(), greater<int>());\\n        }\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                mat[i][j] = mp[i-j].back();\\n                mp[i-j].pop_back();\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int r = mat.size();\\n        int c = mat[0].size();\\n        map<int,vector<int>> mp;\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                mp[i-j].push_back(mat[i][j]);\\n            }\\n        }\\n        \\n        for(auto &p: mp)\\n        {\\n            sort(p.second.begin(), p.second.end(), greater<int>());\\n        }\\n        \\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                mat[i][j] = mp[i-j].back();\\n                mp[i-j].pop_back();\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030747,
                "title": "c-iterator-adapter",
                "content": "While I don\\'t think this could be implemented in an interview without some reference check, it is possible to prototype parts of it or at least mention it verbally.\\nNumber of lines may look long but they are mostly boilerplate for implementing a trivial interface. The main point are the two static methods `begin` and `end` where the first and last rows in a diagonal are defined.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    class diag_iterator\\n    {\\n    public:\\n        using difference_type = ssize_t;\\n        using value_type = int;\\n        using pointer = void;\\n        using reference = int&;\\n        using iterator_category = std::random_access_iterator_tag;\\n        \\n        static diag_iterator begin(vector<vector<int>>& mat, const ssize_t diag)\\n        {\\n            return {mat, diag >= 0 ? diag : 0, diag};\\n        }\\n        \\n        static diag_iterator end(vector<vector<int>>& mat, const ssize_t diag)\\n        {\\n            const auto firstRow = diag >= 0 ? diag : 0;\\n            const auto firstCol = diag >= 0 ? 0 : -diag;\\n            const ssize_t rows = mat.size();\\n            const ssize_t cols = mat.front().size();\\n            const auto steps = min(cols - firstCol, rows - firstRow);\\n            return {mat, firstRow + steps, diag};            \\n        }\\n    \\n        int& operator*() { return mat.get()[row][row - diag]; }\\n        \\n        int operator*() const { return mat.get()[row][row - diag]; }\\n        \\n        diag_iterator& operator++()\\n        {\\n            ++row;\\n            return *this;\\n        }\\n        \\n        diag_iterator& operator--()\\n        {\\n            --row;\\n            return *this;\\n        }\\n        \\n    private:    \\n        reference_wrapper<vector<vector<int>>> mat;\\n        ssize_t row;\\n        ssize_t diag;\\n        \\n        diag_iterator(vector<vector<int>>& mat, const ssize_t row, const ssize_t diag)\\n            : mat{mat}\\n            , row{row}\\n            , diag{diag} {}\\n        \\n        friend bool operator<(const diag_iterator& lhs, const diag_iterator& rhs)\\n        {\\n            return lhs.row < rhs.row;\\n        }\\n        \\n        friend bool operator==(const diag_iterator& lhs, const diag_iterator& rhs)\\n        {\\n            return lhs.row == rhs.row;\\n        }\\n        \\n        friend bool operator!=(const diag_iterator& lhs, const diag_iterator& rhs)\\n        {\\n            return !(lhs == rhs);\\n        }\\n        \\n        friend diag_iterator operator+(const diag_iterator& lhs, const ssize_t rhs)\\n        {\\n            return diag_iterator{lhs.mat, lhs.row + rhs, lhs.diag};\\n        }\\n        \\n        friend diag_iterator operator+(const ssize_t lhs, const diag_iterator& rhs)\\n        {\\n            return diag_iterator{rhs.mat, rhs.row + lhs, rhs.diag};\\n        }\\n        \\n        friend diag_iterator operator-(const diag_iterator& lhs, const ssize_t rhs)\\n        {\\n            return diag_iterator{lhs.mat, lhs.row - rhs, lhs.diag};\\n        }\\n        \\n        friend difference_type operator-(const diag_iterator& lhs, const diag_iterator& rhs)\\n        {\\n            return lhs.row - rhs.row;\\n        }\\n    };\\n    \\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat)\\n    {\\n        for (ssize_t diag = mat.size(); diag != -mat.front().size(); --diag)\\n        {\\n            auto beg = diag_iterator::begin(mat, diag);\\n            auto end = diag_iterator::end(mat, diag);\\n            sort(beg, end);\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    class diag_iterator\\n    {\\n    public:\\n        using difference_type = ssize_t;\\n        using value_type = int;\\n        using pointer = void;\\n        using reference = int&;\\n        using iterator_category = std::random_access_iterator_tag;\\n        \\n        static diag_iterator begin(vector<vector<int>>& mat, const ssize_t diag)\\n        {\\n            return {mat, diag >= 0 ? diag : 0, diag};\\n        }\\n        \\n        static diag_iterator end(vector<vector<int>>& mat, const ssize_t diag)\\n        {\\n            const auto firstRow = diag >= 0 ? diag : 0;\\n            const auto firstCol = diag >= 0 ? 0 : -diag;\\n            const ssize_t rows = mat.size();\\n            const ssize_t cols = mat.front().size();\\n            const auto steps = min(cols - firstCol, rows - firstRow);\\n            return {mat, firstRow + steps, diag};            \\n        }\\n    \\n        int& operator*() { return mat.get()[row][row - diag]; }\\n        \\n        int operator*() const { return mat.get()[row][row - diag]; }\\n        \\n        diag_iterator& operator++()\\n        {\\n            ++row;\\n            return *this;\\n        }\\n        \\n        diag_iterator& operator--()\\n        {\\n            --row;\\n            return *this;\\n        }\\n        \\n    private:    \\n        reference_wrapper<vector<vector<int>>> mat;\\n        ssize_t row;\\n        ssize_t diag;\\n        \\n        diag_iterator(vector<vector<int>>& mat, const ssize_t row, const ssize_t diag)\\n            : mat{mat}\\n            , row{row}\\n            , diag{diag} {}\\n        \\n        friend bool operator<(const diag_iterator& lhs, const diag_iterator& rhs)\\n        {\\n            return lhs.row < rhs.row;\\n        }\\n        \\n        friend bool operator==(const diag_iterator& lhs, const diag_iterator& rhs)\\n        {\\n            return lhs.row == rhs.row;\\n        }\\n        \\n        friend bool operator!=(const diag_iterator& lhs, const diag_iterator& rhs)\\n        {\\n            return !(lhs == rhs);\\n        }\\n        \\n        friend diag_iterator operator+(const diag_iterator& lhs, const ssize_t rhs)\\n        {\\n            return diag_iterator{lhs.mat, lhs.row + rhs, lhs.diag};\\n        }\\n        \\n        friend diag_iterator operator+(const ssize_t lhs, const diag_iterator& rhs)\\n        {\\n            return diag_iterator{rhs.mat, rhs.row + lhs, rhs.diag};\\n        }\\n        \\n        friend diag_iterator operator-(const diag_iterator& lhs, const ssize_t rhs)\\n        {\\n            return diag_iterator{lhs.mat, lhs.row - rhs, lhs.diag};\\n        }\\n        \\n        friend difference_type operator-(const diag_iterator& lhs, const diag_iterator& rhs)\\n        {\\n            return lhs.row - rhs.row;\\n        }\\n    };\\n    \\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat)\\n    {\\n        for (ssize_t diag = mat.size(); diag != -mat.front().size(); --diag)\\n        {\\n            auto beg = diag_iterator::begin(mat, diag);\\n            auto end = diag_iterator::end(mat, diag);\\n            sort(beg, end);\\n        }\\n        \\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030744,
                "title": "js-python-java-c-simple-solution-w-explanation-beats-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nThe easy solution here is to read each diagonal row, then sort it, then write it back again. To read the diagonal line, it can be best to think of the rows as extending out to the left and right.\\n\\n![image](https://assets.leetcode.com/users/images/b9f08eb1-9414-4956-af4e-bd3ef5edcf59_1611396909.7399392.png)\\n\\nFor a matrix (**M**) of height **y** and width **x**, in order to get all the diagonal rows, we would need to extend out the **i** values to the left by **y - 1** (the corner cell counts as both on the **x** and **y** sides). But in this case, we can ignore the first and last diagonal rows, as they only contain one cell each and thus don\\'t need to be sorted. That means that the range of **i** should be **0 - (y - 2) <= i <= x - 1**, or **2 - y <= i <= x - 1**.\\n\\nThen we can just iterate through these diagonals and store the valid cell values in an array (**diag**). After sorting **diag**, we can then iterate back through the diagonal and replace the valid cells with the appropriate sorted value.\\n\\nTo avoid complex logic involving matrix bounds, we can just use a fixed dimension for **diag** along with an index, **k**. In this case, **y** represents **diag**\\'s max length.\\n\\n---\\n\\n***Implementation:***\\n\\nFor Javascript, we can use the faster typed **Uint8Array** for **diag**, as the range of cell values is quite small. We can fill it with **101**\\'s between iterations so the unused portion of the array stays sorted at the end.\\n\\nPython has a much more convenient inline list-building capability that we can take advantage of. It\\'ll be easier to just **pop()** off the elements from **diag** and start with a brand-new **diag** on each iteration.\\n\\nBoth Java and C++ will allow us to save time by only having to sort a partial array.\\n\\n---\\n\\n***Javscript Code:***\\n\\nThe best result for the code below is **76ms / 40.7MB** (beats 100% / 97%).\\n```javascript\\nvar diagonalSort = function(M) {\\n    let y = M.length, x = M[0].length - 1,\\n        diag = new Uint8Array(y), k\\n    for (let i = 2 - y; i < x; i++) {\\n        diag.fill(101), k = 0\\n        for (let j = 0; j < y; j++)\\n            if (i+j >= 0 && i+j <= x)\\n                diag[k++] = M[j][i+j]\\n        diag.sort(), k = 0\\n        for (let j = 0; j < y; j++)\\n            if (i+j >= 0 && i+j <= x)\\n                M[j][i+j] = diag[k++]\\n    }\\n    return M\\n};\\n```\\n\\n---\\n\\n***Python Code:***\\n\\nThe best result for the code below is **60ms / 14.4MB** (beats 100% / 92%).\\n```python\\nclass Solution:\\n    def diagonalSort(self, M: List[List[int]]) -> List[List[int]]:\\n        y, x = len(M), len(M[0])\\n        for i in range(2-y, x-1):\\n            valid = range(max(0, 0-i), min(y, x-i))\\n            diag, k = sorted([M[j][i+j] for j in valid]), 0\\n            for j in valid:\\n                M[j][i+j], k = diag[k], k + 1\\n        return M\\n```\\n\\n---\\n\\n***Java Code:***\\n\\nThe best result for the code below is **2ms / 39.6MB** (beats 96% / 94%).\\n```java\\nclass Solution {\\n    public int[][] diagonalSort(int[][] M) {\\n        int y = M.length, x = M[0].length - 1;\\n        int[] diag = new int[y];\\n        for (int i = 2 - y; i < x; i++) {\\n            int k = 0;\\n            for (int j = 0; j < y; j++)\\n                if (i+j >= 0 && i+j <= x)\\n                    diag[k++] = M[j][i+j];\\n            Arrays.sort(diag, 0, k);\\n            k = 0;\\n            for (int j = 0; j < y; j++)\\n                if (i+j >= 0 && i+j <= x)\\n                    M[j][i+j] = diag[k++];\\n        }\\n        return M;\\n    }\\n}\\n```\\n\\n---\\n\\n***C++ Code:***\\n\\nThe best result for the code below is **4ms / 8.5MB** (beats 100% / 98%).\\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& M) {\\n        int y = M.size(), x = M[0].size() - 1;\\n        vector<int> diag(y);\\n        for (int i = 2 - y; i < x; i++) {\\n            int k = 0;\\n            for (int j = 0; j < y; j++)\\n                if (i+j >= 0 && i+j <= x) {\\n                    diag[k] = M[j][i+j];\\n                    k++;\\n                }\\n            sort(diag.begin(), diag.begin() + k);\\n            k = 0;\\n            for (int j = 0; j < y; j++)\\n                if (i+j >= 0 && i+j <= x) {\\n                    M[j][i+j] = diag[k];\\n                    k++;\\n                }\\n        }\\n        return M;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar diagonalSort = function(M) {\\n    let y = M.length, x = M[0].length - 1,\\n        diag = new Uint8Array(y), k\\n    for (let i = 2 - y; i < x; i++) {\\n        diag.fill(101), k = 0\\n        for (let j = 0; j < y; j++)\\n            if (i+j >= 0 && i+j <= x)\\n                diag[k++] = M[j][i+j]\\n        diag.sort(), k = 0\\n        for (let j = 0; j < y; j++)\\n            if (i+j >= 0 && i+j <= x)\\n                M[j][i+j] = diag[k++]\\n    }\\n    return M\\n};\\n```\n```python\\nclass Solution:\\n    def diagonalSort(self, M: List[List[int]]) -> List[List[int]]:\\n        y, x = len(M), len(M[0])\\n        for i in range(2-y, x-1):\\n            valid = range(max(0, 0-i), min(y, x-i))\\n            diag, k = sorted([M[j][i+j] for j in valid]), 0\\n            for j in valid:\\n                M[j][i+j], k = diag[k], k + 1\\n        return M\\n```\n```java\\nclass Solution {\\n    public int[][] diagonalSort(int[][] M) {\\n        int y = M.length, x = M[0].length - 1;\\n        int[] diag = new int[y];\\n        for (int i = 2 - y; i < x; i++) {\\n            int k = 0;\\n            for (int j = 0; j < y; j++)\\n                if (i+j >= 0 && i+j <= x)\\n                    diag[k++] = M[j][i+j];\\n            Arrays.sort(diag, 0, k);\\n            k = 0;\\n            for (int j = 0; j < y; j++)\\n                if (i+j >= 0 && i+j <= x)\\n                    M[j][i+j] = diag[k++];\\n        }\\n        return M;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& M) {\\n        int y = M.size(), x = M[0].size() - 1;\\n        vector<int> diag(y);\\n        for (int i = 2 - y; i < x; i++) {\\n            int k = 0;\\n            for (int j = 0; j < y; j++)\\n                if (i+j >= 0 && i+j <= x) {\\n                    diag[k] = M[j][i+j];\\n                    k++;\\n                }\\n            sort(diag.begin(), diag.begin() + k);\\n            k = 0;\\n            for (int j = 0; j < y; j++)\\n                if (i+j >= 0 && i+j <= x) {\\n                    M[j][i+j] = diag[k];\\n                    k++;\\n                }\\n        }\\n        return M;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030694,
                "title": "java-quick-sort-inplace",
                "content": "Idea is to have class-wrapper for each diagonal that provide basic list interface i.e. get at index, set at index and list size:\\n\\n```\\n    class DList {\\n        int i, j, N, M, size;\\n        int[][] mat;\\n        DList(int[][] mat, int i, int j) {\\n            this.i = i; this.j = j;  //  diagonal starting point\\n\\t\\t\\tthis.N = mat.length; this.M = mat[0].length;\\n            this.mat = mat;\\n            this.size = Math.min(N-i, M-j); // size is based on starting point position\\n        }\\n        \\n        int get(int idx) { return mat[i+idx][j+idx]; }\\n\\t\\t\\n        int size() { return size; }\\n        \\n        void set(int idx, int val) { mat[i+idx][j+idx] = val;}\\n    }\\n```\\n\\nAfter this we can use arbitrary sort algorithm:\\n\\n```\\n    private void qsort(DList list, int from, int to) {\\n        if (from >= to)\\n            return;\\n        int p = from;\\n        for (int i = from+1; i<=to; i++) {\\n            if (list.get(p)>list.get(i)) {\\n                swap(list, p, p+1);\\n                if (p+1!=i) swap(list, p, i);\\n                p++;\\n            }\\n        }\\n        qsort(list, from, p-1);\\n        qsort(list, p+1, to);\\n    }\\n```\\n\\nFull solution:\\n\\n```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        for (int i = 0; i<mat.length; i++) {\\n            DList list = new DList(mat, i, 0);\\n            qsort(list, 0, list.size()-1);\\n        }\\n        for (int j = 1; j<mat[0].length; j++) {\\n            DList list = new DList(mat, 0, j);\\n            qsort(list, 0, list.size()-1);\\n        }\\n        return mat;\\n    }\\n    \\n    private void qsort(DList list, int from, int to) {\\n        if (from >= to)\\n            return;\\n        int p = from;\\n        for (int i = from+1; i<=to; i++) {\\n            if (list.get(p)>list.get(i)) {\\n                swap(list, p, p+1);\\n                if (p+1!=i) swap(list, p, i);\\n                p++;\\n            }\\n        }\\n        qsort(list, from, p-1);\\n        qsort(list, p+1, to);\\n    }\\n    \\n    private void swap(DList list, int i, int j) {\\n        int tmp = list.get(i);\\n        list.set(i, list.get(j));\\n        list.set(j, tmp);\\n    }\\n    \\n    class DList {\\n        int i, j, N, M, size;\\n        int[][] mat;\\n        DList(int[][] mat, int i, int j) {\\n            this.i = i; this.j = j; this.N = mat.length; this.M = mat[0].length;\\n            this.mat = mat;\\n            this.size = Math.min(N-i, M-j);\\n        }\\n        \\n        int get(int idx) { return mat[i+idx][j+idx]; }\\n        int size() { return size; }\\n        \\n        void set(int idx, int val) { mat[i+idx][j+idx] = val;}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n    class DList {\\n        int i, j, N, M, size;\\n        int[][] mat;\\n        DList(int[][] mat, int i, int j) {\\n            this.i = i; this.j = j;  //  diagonal starting point\\n\\t\\t\\tthis.N = mat.length; this.M = mat[0].length;\\n            this.mat = mat;\\n            this.size = Math.min(N-i, M-j); // size is based on starting point position\\n        }\\n        \\n        int get(int idx) { return mat[i+idx][j+idx]; }\\n\\t\\t\\n        int size() { return size; }\\n        \\n        void set(int idx, int val) { mat[i+idx][j+idx] = val;}\\n    }\\n```\n```\\n    private void qsort(DList list, int from, int to) {\\n        if (from >= to)\\n            return;\\n        int p = from;\\n        for (int i = from+1; i<=to; i++) {\\n            if (list.get(p)>list.get(i)) {\\n                swap(list, p, p+1);\\n                if (p+1!=i) swap(list, p, i);\\n                p++;\\n            }\\n        }\\n        qsort(list, from, p-1);\\n        qsort(list, p+1, to);\\n    }\\n```\n```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        for (int i = 0; i<mat.length; i++) {\\n            DList list = new DList(mat, i, 0);\\n            qsort(list, 0, list.size()-1);\\n        }\\n        for (int j = 1; j<mat[0].length; j++) {\\n            DList list = new DList(mat, 0, j);\\n            qsort(list, 0, list.size()-1);\\n        }\\n        return mat;\\n    }\\n    \\n    private void qsort(DList list, int from, int to) {\\n        if (from >= to)\\n            return;\\n        int p = from;\\n        for (int i = from+1; i<=to; i++) {\\n            if (list.get(p)>list.get(i)) {\\n                swap(list, p, p+1);\\n                if (p+1!=i) swap(list, p, i);\\n                p++;\\n            }\\n        }\\n        qsort(list, from, p-1);\\n        qsort(list, p+1, to);\\n    }\\n    \\n    private void swap(DList list, int i, int j) {\\n        int tmp = list.get(i);\\n        list.set(i, list.get(j));\\n        list.set(j, tmp);\\n    }\\n    \\n    class DList {\\n        int i, j, N, M, size;\\n        int[][] mat;\\n        DList(int[][] mat, int i, int j) {\\n            this.i = i; this.j = j; this.N = mat.length; this.M = mat[0].length;\\n            this.mat = mat;\\n            this.size = Math.min(N-i, M-j);\\n        }\\n        \\n        int get(int idx) { return mat[i+idx][j+idx]; }\\n        int size() { return size; }\\n        \\n        void set(int idx, int val) { mat[i+idx][j+idx] = val;}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030686,
                "title": "c-solution-8ms",
                "content": "```\\n vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int r = mat.size();\\n        int c = mat[0].size();\\n        int x, y;\\n        // moving columnwise\\n        for(int i = 0; i < c; i++) {\\n            vector<int> temp;\\n            x = i;\\n            y = 0;\\n            while(x < c && y < r) {\\n                temp.push_back(mat[y][x]);\\n                x++;\\n                y++;\\n            }\\n            sort(temp.begin(), temp.end());\\n            x = i;\\n            y = 0;\\n            int j = 0;\\n            while(x < c && y < r) {\\n                mat[y][x] = temp[j];\\n                x++;\\n                y++;\\n                j++;\\n            }\\n        }\\n        // moving rowwise\\n        for(int i = 1; i < r; i++) {\\n            vector<int> temp;\\n            x = 0;\\n            y = i;\\n            while(x < c && y < r) {\\n                temp.push_back(mat[y][x]);\\n                x++;\\n                y++;\\n            }\\n            sort(temp.begin(), temp.end());\\n            x = 0;\\n            y = i;\\n            int j = 0;\\n            while(x < c && y < r) {\\n                mat[y][x] = temp[j];\\n                x++;\\n                y++;\\n                j++;\\n            }\\n        }\\n        return mat;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int r = mat.size();\\n        int c = mat[0].size();\\n        int x, y;\\n        // moving columnwise\\n        for(int i = 0; i < c; i++) {\\n            vector<int> temp;\\n            x = i;\\n            y = 0;\\n            while(x < c && y < r) {\\n                temp.push_back(mat[y][x]);\\n                x++;\\n                y++;\\n            }\\n            sort(temp.begin(), temp.end());\\n            x = i;\\n            y = 0;\\n            int j = 0;\\n            while(x < c && y < r) {\\n                mat[y][x] = temp[j];\\n                x++;\\n                y++;\\n                j++;\\n            }\\n        }\\n        // moving rowwise\\n        for(int i = 1; i < r; i++) {\\n            vector<int> temp;\\n            x = 0;\\n            y = i;\\n            while(x < c && y < r) {\\n                temp.push_back(mat[y][x]);\\n                x++;\\n                y++;\\n            }\\n            sort(temp.begin(), temp.end());\\n            x = 0;\\n            y = i;\\n            int j = 0;\\n            while(x < c && y < r) {\\n                mat[y][x] = temp[j];\\n                x++;\\n                y++;\\n                j++;\\n            }\\n        }\\n        return mat;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1030617,
                "title": "c-2-sols-using-maps-priority-queue-using-maps-deque",
                "content": "*Using priority queue*\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        unordered_map<int,priority_queue<int,vector<int>,greater<int>>> diag;\\n        \\n        for(int i=0;i<m;i++) \\n        {\\n            for(int j=0;j<n;j++) \\n            {\\n                diag[i-j].push(mat[i][j]);\\n                //All cells in the same diagonal (i,j) have the same difference so we can get the diagonal of a cell using the difference i-j.\\n            }\\n        }\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                auto &v = diag[i-j];\\n                mat[i][j] = v.top();\\n                v.pop();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```\\n*Using deque*\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        unordered_map<int,deque<int>> diag;\\n        \\n        for(int i=0;i<m;i++) \\n        {\\n            for(int j=0;j<n;j++) \\n            {\\n                diag[i-j].push_back(mat[i][j]);\\n                //All cells in the same diagonal (i,j) have the same difference so we can get the diagonal of a cell using the difference i-j.\\n            }\\n        }\\n        for(auto &[key,val] : diag) \\n            sort(val.begin(),val.end());\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                auto &v = diag[i-j];\\n                mat[i][j] = v.front();\\n                v.pop_front();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        unordered_map<int,priority_queue<int,vector<int>,greater<int>>> diag;\\n        \\n        for(int i=0;i<m;i++) \\n        {\\n            for(int j=0;j<n;j++) \\n            {\\n                diag[i-j].push(mat[i][j]);\\n                //All cells in the same diagonal (i,j) have the same difference so we can get the diagonal of a cell using the difference i-j.\\n            }\\n        }\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                auto &v = diag[i-j];\\n                mat[i][j] = v.top();\\n                v.pop();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        unordered_map<int,deque<int>> diag;\\n        \\n        for(int i=0;i<m;i++) \\n        {\\n            for(int j=0;j<n;j++) \\n            {\\n                diag[i-j].push_back(mat[i][j]);\\n                //All cells in the same diagonal (i,j) have the same difference so we can get the diagonal of a cell using the difference i-j.\\n            }\\n        }\\n        for(auto &[key,val] : diag) \\n            sort(val.begin(),val.end());\\n        \\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                auto &v = diag[i-j];\\n                mat[i][j] = v.front();\\n                v.pop_front();\\n            }\\n        }\\n        return mat;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998905,
                "title": "precise-and-easy-c-based-solution",
                "content": "The first thing to notice here is that these diagonals can be grouped as (row-col).\\n\\nAlgorithm:\\n1. Iterate and store in a map, store: key = (i-j) and value = List of all values in that diagonal\\n2. Sort each diagonal \\n3. Restore the matrix.\\n\\nSince c# doesn\\'t have a priority queue by default, we use a list and sort the list and then when restoring the final answer, we remove the first element from the list;\\n\\nCode:\\n\\n```\\npublic class Solution {\\n    public int[][] DiagonalSort(int[][] mat) {\\n        \\n        var map = new Dictionary<int, List<int>>();\\t\\t// key= i-j and value is all the values in that diagonal;\\n        \\n        for(int i=0; i<mat.Length; i++) {\\t\\t\\t\\t// Just add everything to the map;\\n            for(int j=0; j<mat[0].Length; j++) {\\n                \\n                var key = i-j;\\n                if(!map.ContainsKey(key))       map.Add(key, new List<int>());\\n                map[key].Add(mat[i][j]);\\n            }\\n        }\\n        \\n        foreach(var key in map.Keys)\\t\\t\\t\\t\\t// Since we dont have priority queue in c#, just sort individual rows\\n            map[key].Sort();\\n        \\n        for(int i=0; i<mat.Length; i++) {\\t\\t\\t\\t// Pick the first element from the list and remove that element;\\n            for(int j=0; j<mat[0].Length; j++) {\\n                \\n                var val = map[i-j][0];\\n\\t\\t\\t\\tmat[i][j] = val;\\n                map[i-j].RemoveAt(0);\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[][] DiagonalSort(int[][] mat) {\\n        \\n        var map = new Dictionary<int, List<int>>();\\t\\t// key= i-j and value is all the values in that diagonal;\\n        \\n        for(int i=0; i<mat.Length; i++) {\\t\\t\\t\\t// Just add everything to the map;\\n            for(int j=0; j<mat[0].Length; j++) {\\n                \\n                var key = i-j;\\n                if(!map.ContainsKey(key))       map.Add(key, new List<int>());\\n                map[key].Add(mat[i][j]);\\n            }\\n        }\\n        \\n        foreach(var key in map.Keys)\\t\\t\\t\\t\\t// Since we dont have priority queue in c#, just sort individual rows\\n            map[key].Sort();\\n        \\n        for(int i=0; i<mat.Length; i++) {\\t\\t\\t\\t// Pick the first element from the list and remove that element;\\n            for(int j=0; j<mat[0].Length; j++) {\\n                \\n                var val = map[i-j][0];\\n\\t\\t\\t\\tmat[i][j] = val;\\n                map[i-j].RemoveAt(0);\\n            }\\n        }\\n        \\n        return mat;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952412,
                "title": "straightforward-java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        for (int i = 0; i < mat.length; i++) {\\n            sortHelper(i, 0, mat);\\n        }\\n        for (int j = 0; j < mat[0].length; j++) {\\n            sortHelper(0, j, mat);\\n        }\\n        return mat;\\n    }\\n    \\n    private void sortHelper(int i, int j, int[][] mat) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        int x = i;\\n        int y = j;\\n        while (x < mat.length && y < mat[0].length) {\\n            list.add(mat[x++][y++]);\\n        }\\n        Collections.sort(list);\\n        x = i;\\n        y = j;\\n        int index = 0;\\n        while (x < mat.length && y < mat[0].length) {\\n            mat[x++][y++] = list.get(index++);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[][] diagonalSort(int[][] mat) {\\n        for (int i = 0; i < mat.length; i++) {\\n            sortHelper(i, 0, mat);\\n        }\\n        for (int j = 0; j < mat[0].length; j++) {\\n            sortHelper(0, j, mat);\\n        }\\n        return mat;\\n    }\\n    \\n    private void sortHelper(int i, int j, int[][] mat) {\\n        List<Integer> list = new ArrayList<Integer>();\\n        int x = i;\\n        int y = j;\\n        while (x < mat.length && y < mat[0].length) {\\n            list.add(mat[x++][y++]);\\n        }\\n        Collections.sort(list);\\n        x = i;\\n        y = j;\\n        int index = 0;\\n        while (x < mat.length && y < mat[0].length) {\\n            mat[x++][y++] = list.get(index++);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925973,
                "title": "java-treemap-easy-to-understand",
                "content": "\\tpublic int[][] diagonalSort(int[][] mat) {\\n        TreeMap<Integer, PriorityQueue<Integer>> map = new TreeMap<>();\\n        for(int i = 0; i < mat.length; i++){\\n            for(int j = 0; j < mat[0].length; j++){\\n                map.putIfAbsent(j - i, new PriorityQueue<>());\\n                map.get(j - i).offer(mat[i][j]);\\n            }\\n        }\\n        \\n        int index = 0;\\n        for(int i = 0; i < mat.length; i++){\\n            for(int j = 0; j < mat[0].length; j++){\\n                mat[i][j] = map.get(j - i).poll();    \\n            }\\n        }\\n        return mat;\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int[][] diagonalSort(int[][] mat) {\\n        TreeMap<Integer, PriorityQueue<Integer>> map = new TreeMap<>();\\n        for(int i = 0; i < mat.length; i++){\\n            for(int j = 0; j < mat[0].length; j++){\\n                map.putIfAbsent(j - i, new PriorityQueue<>());\\n                map.get(j - i).offer(mat[i][j]);\\n            }\\n        }\\n        \\n        int index = 0;\\n        for(int i = 0; i < mat.length; i++){\\n            for(int j = 0; j < mat[0].length; j++){\\n                mat[i][j] = map.get(j - i).poll();    \\n            }\\n        }\\n        return mat;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 779209,
                "title": "sort-each-diagonal-one-by-one-c-beats-97-7-faster-in-time",
                "content": "So the approach is simple just take out every diagonal store it into the array and sort that array and again put into the diagonal\\nHere is my code\\n```\\n vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n \\n      //first iterate on first row\\n\\tfor(int i = 0; i < mat[0].size(); i++){\\n\\t\\tvector<int> v;\\n\\t\\tint j = 0,k = i;\\n\\t\\t//now move diagonally and transfer elements into array\\n\\t\\twhile(j < mat.size() && k < mat[0].size()){\\n\\t\\t\\tv.push_back(mat[j++][k++]);\\n\\t\\t}\\n\\t\\tsort(v.begin(),v.end());\\n\\n\\t\\t//now again transfer sorted elements from array to diagonal of matrix\\n\\t\\twhile(j >0 && k >i){\\n\\t\\t\\t\\n\\t\\t\\tmat[--j][--k] = v.back();\\n\\t\\t\\tv.pop_back();\\n\\t\\t}\\n\\t}\\n\\t\\n\\t\\n\\t//now iterate on first column\\n\\tfor(int i = 0; i < mat.size(); i++){\\n\\t\\tvector<int> v;\\n\\t\\tint j = i,k = 0;\\n\\t\\t\\n\\t\\t//now move diagonally and transfer elements into array\\n\\t\\t\\n\\t\\twhile(j < mat.size() && k < mat[0].size()){\\n\\t\\t\\t\\n\\t\\t\\tv.push_back(mat[j++][k++]);\\n\\t\\t}\\n    \\n\\t\\tsort(v.begin(),v.end());\\n\\t\\t//now again transfer sorted elements from array to diagonal of matrix\\n\\t\\twhile(j >i && k >0){\\n\\t\\t\\n\\t\\t\\tmat[--j][--k] = v.back();\\n\\t\\t\\tv.pop_back();\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\treturn mat\\t;\\n}\\n```\\n\\nAdvance thanks for suggestions  and feedback :)",
                "solutionTags": [],
                "code": "```\\n vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\\n \\n      //first iterate on first row\\n\\tfor(int i = 0; i < mat[0].size(); i++){\\n\\t\\tvector<int> v;\\n\\t\\tint j = 0,k = i;\\n\\t\\t//now move diagonally and transfer elements into array\\n\\t\\twhile(j < mat.size() && k < mat[0].size()){\\n\\t\\t\\tv.push_back(mat[j++][k++]);\\n\\t\\t}\\n\\t\\tsort(v.begin(),v.end());\\n\\n\\t\\t//now again transfer sorted elements from array to diagonal of matrix\\n\\t\\twhile(j >0 && k >i){\\n\\t\\t\\t\\n\\t\\t\\tmat[--j][--k] = v.back();\\n\\t\\t\\tv.pop_back();\\n\\t\\t}\\n\\t}\\n\\t\\n\\t\\n\\t//now iterate on first column\\n\\tfor(int i = 0; i < mat.size(); i++){\\n\\t\\tvector<int> v;\\n\\t\\tint j = i,k = 0;\\n\\t\\t\\n\\t\\t//now move diagonally and transfer elements into array\\n\\t\\t\\n\\t\\twhile(j < mat.size() && k < mat[0].size()){\\n\\t\\t\\t\\n\\t\\t\\tv.push_back(mat[j++][k++]);\\n\\t\\t}\\n    \\n\\t\\tsort(v.begin(),v.end());\\n\\t\\t//now again transfer sorted elements from array to diagonal of matrix\\n\\t\\twhile(j >i && k >0){\\n\\t\\t\\n\\t\\t\\tmat[--j][--k] = v.back();\\n\\t\\t\\tv.pop_back();\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\treturn mat\\t;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1740411,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one was very difficult for me :("
                    },
                    {
                        "username": "Msey",
                        "content": "The most difficult part here is not to skip the moment when you need to check with mat.Length and mat[i].Length "
                    },
                    {
                        "username": "keshavkaushikiitr",
                        "content": "can someone please help me in this idea, it is running example but not the judging test cases.\nPS: it is not giving memory limit exeed/TLE but wrong answer.\nclass Solution {\npublic:\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\n        int n,m;\n        n = mat.size();\n        m = mat[0].size();\n        for(int i=n-1;i>=0;i--){\n            vector<int> temp;\n            int k = i;\n            for(int j=0;i<n&&j<m;j++){\n                temp.push_back(mat[i][j]);\n                i++;\n            }\n            sort(temp.begin(), temp.end());\n            i = k;\n            for(int j=0;i<n&&j<m;j++){\n                mat[i][j] = temp[j];\n                i++;\n            }\n            i=k;\n        }\n\n        for(int j=1;j<n;j++){\n            vector<int> temp;\n            int k = j;\n            for(int i = 0;i<n&&j<m;i++,j++){\n                temp.push_back(mat[i][j]);\n            }\n            sort(temp.begin(), temp.end());\n            j = k;\n            for(int i = 0;i<n&&j<m;i++,j++){\n                mat[i][j] = temp[i];\n            }\n            j = k;\n        }\n\n        return mat;\n    }\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "pls use proper formatting so everyone could help you out"
                    },
                    {
                        "username": "bykov",
                        "content": "+1 more in difficulty: annoying "
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Can we solve it using comparator function??\\n"
                    },
                    {
                        "username": "code_rama",
                        "content": "There can be multiple answers to a testcase. For example for [[3,3,1,1],[2,2,1,2],[1,1,1,2]] one of the solutions could be : [[1,1,1,2],[1,2,2,2],[1,1,3,3]]"
                    },
                    {
                        "username": "frowenz",
                        "content": "Then one of the diagonals is 1, 1, 2 which is not increasing (it's non-decreasing). Also the point is that you are supposed to be sorting along the diagonals (i.e. things can only be moved by [+1, -1] or [-1, +1])"
                    }
                ]
            },
            {
                "id": 2011306,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one was very difficult for me :("
                    },
                    {
                        "username": "Msey",
                        "content": "The most difficult part here is not to skip the moment when you need to check with mat.Length and mat[i].Length "
                    },
                    {
                        "username": "keshavkaushikiitr",
                        "content": "can someone please help me in this idea, it is running example but not the judging test cases.\nPS: it is not giving memory limit exeed/TLE but wrong answer.\nclass Solution {\npublic:\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\n        int n,m;\n        n = mat.size();\n        m = mat[0].size();\n        for(int i=n-1;i>=0;i--){\n            vector<int> temp;\n            int k = i;\n            for(int j=0;i<n&&j<m;j++){\n                temp.push_back(mat[i][j]);\n                i++;\n            }\n            sort(temp.begin(), temp.end());\n            i = k;\n            for(int j=0;i<n&&j<m;j++){\n                mat[i][j] = temp[j];\n                i++;\n            }\n            i=k;\n        }\n\n        for(int j=1;j<n;j++){\n            vector<int> temp;\n            int k = j;\n            for(int i = 0;i<n&&j<m;i++,j++){\n                temp.push_back(mat[i][j]);\n            }\n            sort(temp.begin(), temp.end());\n            j = k;\n            for(int i = 0;i<n&&j<m;i++,j++){\n                mat[i][j] = temp[i];\n            }\n            j = k;\n        }\n\n        return mat;\n    }\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "pls use proper formatting so everyone could help you out"
                    },
                    {
                        "username": "bykov",
                        "content": "+1 more in difficulty: annoying "
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Can we solve it using comparator function??\\n"
                    },
                    {
                        "username": "code_rama",
                        "content": "There can be multiple answers to a testcase. For example for [[3,3,1,1],[2,2,1,2],[1,1,1,2]] one of the solutions could be : [[1,1,1,2],[1,2,2,2],[1,1,3,3]]"
                    },
                    {
                        "username": "frowenz",
                        "content": "Then one of the diagonals is 1, 1, 2 which is not increasing (it's non-decreasing). Also the point is that you are supposed to be sorting along the diagonals (i.e. things can only be moved by [+1, -1] or [-1, +1])"
                    }
                ]
            },
            {
                "id": 1833519,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one was very difficult for me :("
                    },
                    {
                        "username": "Msey",
                        "content": "The most difficult part here is not to skip the moment when you need to check with mat.Length and mat[i].Length "
                    },
                    {
                        "username": "keshavkaushikiitr",
                        "content": "can someone please help me in this idea, it is running example but not the judging test cases.\nPS: it is not giving memory limit exeed/TLE but wrong answer.\nclass Solution {\npublic:\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\n        int n,m;\n        n = mat.size();\n        m = mat[0].size();\n        for(int i=n-1;i>=0;i--){\n            vector<int> temp;\n            int k = i;\n            for(int j=0;i<n&&j<m;j++){\n                temp.push_back(mat[i][j]);\n                i++;\n            }\n            sort(temp.begin(), temp.end());\n            i = k;\n            for(int j=0;i<n&&j<m;j++){\n                mat[i][j] = temp[j];\n                i++;\n            }\n            i=k;\n        }\n\n        for(int j=1;j<n;j++){\n            vector<int> temp;\n            int k = j;\n            for(int i = 0;i<n&&j<m;i++,j++){\n                temp.push_back(mat[i][j]);\n            }\n            sort(temp.begin(), temp.end());\n            j = k;\n            for(int i = 0;i<n&&j<m;i++,j++){\n                mat[i][j] = temp[i];\n            }\n            j = k;\n        }\n\n        return mat;\n    }\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "pls use proper formatting so everyone could help you out"
                    },
                    {
                        "username": "bykov",
                        "content": "+1 more in difficulty: annoying "
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Can we solve it using comparator function??\\n"
                    },
                    {
                        "username": "code_rama",
                        "content": "There can be multiple answers to a testcase. For example for [[3,3,1,1],[2,2,1,2],[1,1,1,2]] one of the solutions could be : [[1,1,1,2],[1,2,2,2],[1,1,3,3]]"
                    },
                    {
                        "username": "frowenz",
                        "content": "Then one of the diagonals is 1, 1, 2 which is not increasing (it's non-decreasing). Also the point is that you are supposed to be sorting along the diagonals (i.e. things can only be moved by [+1, -1] or [-1, +1])"
                    }
                ]
            },
            {
                "id": 1750729,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one was very difficult for me :("
                    },
                    {
                        "username": "Msey",
                        "content": "The most difficult part here is not to skip the moment when you need to check with mat.Length and mat[i].Length "
                    },
                    {
                        "username": "keshavkaushikiitr",
                        "content": "can someone please help me in this idea, it is running example but not the judging test cases.\nPS: it is not giving memory limit exeed/TLE but wrong answer.\nclass Solution {\npublic:\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\n        int n,m;\n        n = mat.size();\n        m = mat[0].size();\n        for(int i=n-1;i>=0;i--){\n            vector<int> temp;\n            int k = i;\n            for(int j=0;i<n&&j<m;j++){\n                temp.push_back(mat[i][j]);\n                i++;\n            }\n            sort(temp.begin(), temp.end());\n            i = k;\n            for(int j=0;i<n&&j<m;j++){\n                mat[i][j] = temp[j];\n                i++;\n            }\n            i=k;\n        }\n\n        for(int j=1;j<n;j++){\n            vector<int> temp;\n            int k = j;\n            for(int i = 0;i<n&&j<m;i++,j++){\n                temp.push_back(mat[i][j]);\n            }\n            sort(temp.begin(), temp.end());\n            j = k;\n            for(int i = 0;i<n&&j<m;i++,j++){\n                mat[i][j] = temp[i];\n            }\n            j = k;\n        }\n\n        return mat;\n    }\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "pls use proper formatting so everyone could help you out"
                    },
                    {
                        "username": "bykov",
                        "content": "+1 more in difficulty: annoying "
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Can we solve it using comparator function??\\n"
                    },
                    {
                        "username": "code_rama",
                        "content": "There can be multiple answers to a testcase. For example for [[3,3,1,1],[2,2,1,2],[1,1,1,2]] one of the solutions could be : [[1,1,1,2],[1,2,2,2],[1,1,3,3]]"
                    },
                    {
                        "username": "frowenz",
                        "content": "Then one of the diagonals is 1, 1, 2 which is not increasing (it's non-decreasing). Also the point is that you are supposed to be sorting along the diagonals (i.e. things can only be moved by [+1, -1] or [-1, +1])"
                    }
                ]
            },
            {
                "id": 2068786,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one was very difficult for me :("
                    },
                    {
                        "username": "Msey",
                        "content": "The most difficult part here is not to skip the moment when you need to check with mat.Length and mat[i].Length "
                    },
                    {
                        "username": "keshavkaushikiitr",
                        "content": "can someone please help me in this idea, it is running example but not the judging test cases.\nPS: it is not giving memory limit exeed/TLE but wrong answer.\nclass Solution {\npublic:\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\n        int n,m;\n        n = mat.size();\n        m = mat[0].size();\n        for(int i=n-1;i>=0;i--){\n            vector<int> temp;\n            int k = i;\n            for(int j=0;i<n&&j<m;j++){\n                temp.push_back(mat[i][j]);\n                i++;\n            }\n            sort(temp.begin(), temp.end());\n            i = k;\n            for(int j=0;i<n&&j<m;j++){\n                mat[i][j] = temp[j];\n                i++;\n            }\n            i=k;\n        }\n\n        for(int j=1;j<n;j++){\n            vector<int> temp;\n            int k = j;\n            for(int i = 0;i<n&&j<m;i++,j++){\n                temp.push_back(mat[i][j]);\n            }\n            sort(temp.begin(), temp.end());\n            j = k;\n            for(int i = 0;i<n&&j<m;i++,j++){\n                mat[i][j] = temp[i];\n            }\n            j = k;\n        }\n\n        return mat;\n    }\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "pls use proper formatting so everyone could help you out"
                    },
                    {
                        "username": "bykov",
                        "content": "+1 more in difficulty: annoying "
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Can we solve it using comparator function??\\n"
                    },
                    {
                        "username": "code_rama",
                        "content": "There can be multiple answers to a testcase. For example for [[3,3,1,1],[2,2,1,2],[1,1,1,2]] one of the solutions could be : [[1,1,1,2],[1,2,2,2],[1,1,3,3]]"
                    },
                    {
                        "username": "frowenz",
                        "content": "Then one of the diagonals is 1, 1, 2 which is not increasing (it's non-decreasing). Also the point is that you are supposed to be sorting along the diagonals (i.e. things can only be moved by [+1, -1] or [-1, +1])"
                    }
                ]
            },
            {
                "id": 2032741,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one was very difficult for me :("
                    },
                    {
                        "username": "Msey",
                        "content": "The most difficult part here is not to skip the moment when you need to check with mat.Length and mat[i].Length "
                    },
                    {
                        "username": "keshavkaushikiitr",
                        "content": "can someone please help me in this idea, it is running example but not the judging test cases.\nPS: it is not giving memory limit exeed/TLE but wrong answer.\nclass Solution {\npublic:\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\n        int n,m;\n        n = mat.size();\n        m = mat[0].size();\n        for(int i=n-1;i>=0;i--){\n            vector<int> temp;\n            int k = i;\n            for(int j=0;i<n&&j<m;j++){\n                temp.push_back(mat[i][j]);\n                i++;\n            }\n            sort(temp.begin(), temp.end());\n            i = k;\n            for(int j=0;i<n&&j<m;j++){\n                mat[i][j] = temp[j];\n                i++;\n            }\n            i=k;\n        }\n\n        for(int j=1;j<n;j++){\n            vector<int> temp;\n            int k = j;\n            for(int i = 0;i<n&&j<m;i++,j++){\n                temp.push_back(mat[i][j]);\n            }\n            sort(temp.begin(), temp.end());\n            j = k;\n            for(int i = 0;i<n&&j<m;i++,j++){\n                mat[i][j] = temp[i];\n            }\n            j = k;\n        }\n\n        return mat;\n    }\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "pls use proper formatting so everyone could help you out"
                    },
                    {
                        "username": "bykov",
                        "content": "+1 more in difficulty: annoying "
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Can we solve it using comparator function??\\n"
                    },
                    {
                        "username": "code_rama",
                        "content": "There can be multiple answers to a testcase. For example for [[3,3,1,1],[2,2,1,2],[1,1,1,2]] one of the solutions could be : [[1,1,1,2],[1,2,2,2],[1,1,3,3]]"
                    },
                    {
                        "username": "frowenz",
                        "content": "Then one of the diagonals is 1, 1, 2 which is not increasing (it's non-decreasing). Also the point is that you are supposed to be sorting along the diagonals (i.e. things can only be moved by [+1, -1] or [-1, +1])"
                    }
                ]
            },
            {
                "id": 1935051,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Hint: PriorityQueue"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "This one was very difficult for me :("
                    },
                    {
                        "username": "Msey",
                        "content": "The most difficult part here is not to skip the moment when you need to check with mat.Length and mat[i].Length "
                    },
                    {
                        "username": "keshavkaushikiitr",
                        "content": "can someone please help me in this idea, it is running example but not the judging test cases.\nPS: it is not giving memory limit exeed/TLE but wrong answer.\nclass Solution {\npublic:\n    vector<vector<int>> diagonalSort(vector<vector<int>>& mat) {\n        int n,m;\n        n = mat.size();\n        m = mat[0].size();\n        for(int i=n-1;i>=0;i--){\n            vector<int> temp;\n            int k = i;\n            for(int j=0;i<n&&j<m;j++){\n                temp.push_back(mat[i][j]);\n                i++;\n            }\n            sort(temp.begin(), temp.end());\n            i = k;\n            for(int j=0;i<n&&j<m;j++){\n                mat[i][j] = temp[j];\n                i++;\n            }\n            i=k;\n        }\n\n        for(int j=1;j<n;j++){\n            vector<int> temp;\n            int k = j;\n            for(int i = 0;i<n&&j<m;i++,j++){\n                temp.push_back(mat[i][j]);\n            }\n            sort(temp.begin(), temp.end());\n            j = k;\n            for(int i = 0;i<n&&j<m;i++,j++){\n                mat[i][j] = temp[i];\n            }\n            j = k;\n        }\n\n        return mat;\n    }\n};"
                    },
                    {
                        "username": "Msey",
                        "content": "pls use proper formatting so everyone could help you out"
                    },
                    {
                        "username": "bykov",
                        "content": "+1 more in difficulty: annoying "
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Can we solve it using comparator function??\\n"
                    },
                    {
                        "username": "code_rama",
                        "content": "There can be multiple answers to a testcase. For example for [[3,3,1,1],[2,2,1,2],[1,1,1,2]] one of the solutions could be : [[1,1,1,2],[1,2,2,2],[1,1,3,3]]"
                    },
                    {
                        "username": "frowenz",
                        "content": "Then one of the diagonals is 1, 1, 2 which is not increasing (it's non-decreasing). Also the point is that you are supposed to be sorting along the diagonals (i.e. things can only be moved by [+1, -1] or [-1, +1])"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Followers Count",
        "question_content": "<p>Table: <code>Followers</code></p>\n\n<pre>\n+-------------+------+\n| Column Name | Type |\n+-------------+------+\n| user_id     | int  |\n| follower_id | int  |\n+-------------+------+\n(user_id, follower_id) is the primary key (combination of columns with unique values) for this table.\nThis table contains the IDs of a user and a follower in a social media app where the follower follows the user.</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution that will, for each user, return the number of followers.</p>\n\n<p>Return the result table ordered by <code>user_id</code> in ascending order.</p>\n\n<p>The&nbsp;result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nFollowers table:\n+---------+-------------+\n| user_id | follower_id |\n+---------+-------------+\n| 0       | 1           |\n| 1       | 0           |\n| 2       | 0           |\n| 2       | 1           |\n+---------+-------------+\n<strong>Output:</strong> \n+---------+----------------+\n| user_id | followers_count|\n+---------+----------------+\n| 0       | 1              |\n| 1       | 1              |\n| 2       | 2              |\n+---------+----------------+\n<strong>Explanation:</strong> \nThe followers of 0 are {1}\nThe followers of 1 are {0}\nThe followers of 2 are {0,1}\n</pre>\n",
        "solutions": [
            {
                "id": 1021950,
                "title": "simple-sql-query",
                "content": "```\\nselect\\n    user_id,\\n    count(*) as followers_count\\nfrom\\n    Followers\\ngroup by\\n    user_id\\norder by\\n\\tuser_id\\n```",
                "solutionTags": [],
                "code": "```\\nselect\\n    user_id,\\n    count(*) as followers_count\\nfrom\\n    Followers\\ngroup by\\n    user_id\\norder by\\n\\tuser_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2520706,
                "title": "mysql-beginner-level-easy-to-understand-simple-short-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome.***\\n*====================================================================*\\n\\u2705 **MySQL Code :**\\n```\\nSELECT user_id,COUNT(DISTINCT(follower_id)) AS followers_count\\nFROM followers\\nGROUP BY user_id\\n```\\n**Runtime:** 479 ms\\n**Memory Usage:**  0B\\n________________________________\\n__________________________________\\n\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT user_id,COUNT(DISTINCT(follower_id)) AS followers_count\\nFROM followers\\nGROUP BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1458530,
                "title": "easy-mysql-solution",
                "content": "```\\nselect user_id,\\ncount(distinct(follower_id)) as followers_count\\nfrom\\nfollowers\\ngroup by user_id\\n```",
                "solutionTags": [],
                "code": "```\\nselect user_id,\\ncount(distinct(follower_id)) as followers_count\\nfrom\\nfollowers\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3011798,
                "title": "mysql-solution-query",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT DISTINCT user_id , count(distinct follower_id) AS followers_count\\nFROM followers\\nGROUP BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DISTINCT user_id , count(distinct follower_id) AS followers_count\\nFROM followers\\nGROUP BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3732760,
                "title": "sql-group-by-order-by-easy-to-understand",
                "content": "# Intuition\\nWe simply combine user_ids with group by and sort by user_id\\n\\n![image.png](https://assets.leetcode.com/users/images/fc546e58-d926-45a7-b0c2-5d8abbda382f_1688742804.7133734.png)\\n\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id,count(follower_id) as followers_count from Followers group by user_id order by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id,count(follower_id) as followers_count from Followers group by user_id order by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2120535,
                "title": "using-distinct-and-window-without-using-groupby",
                "content": "```\\nSELECT DISTINCT user_id, COUNT(*) OVER(PARTITION BY user_id ORDER BY user_id) followers_count\\nFROM Followers\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT user_id, COUNT(*) OVER(PARTITION BY user_id ORDER BY user_id) followers_count\\nFROM Followers\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596340,
                "title": "mysql-solution-for-find-followers-count-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe query aims to count the number of followers for each user in a social media app based on the given Followers table.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe SQL query retrieves the user_id and applies the COUNT(follower_id) function to count the number of occurrences of follower_id for each unique user_id. The GROUP BY clause is used to group the results by user_id, ensuring that the count is calculated for each individual user. Finally, the result table is ordered in ascending order based on user_id using the ORDER BY clause.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this query depends on the size of the Followers table and the number of distinct user_id values. The COUNT function and grouping operation require traversing the table and counting the occurrences for each user, resulting in a time complexity of O(n), where n is the number of rows in the table.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this query is determined by the memory required to store the result set. The memory usage is proportional to the number of distinct user_id values in the table. Therefore, the space complexity is O(m), where m is the number of distinct users in the Followers table.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id ASC;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id ASC;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3292571,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id, count(user_id) as followers_count from Followers \\ngroup by user_id order by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id, count(user_id) as followers_count from Followers \\ngroup by user_id order by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2075256,
                "title": "cannot-have-a-simpler-solution-beats-100",
                "content": "```\\nselect user_id, count(follower_id) as followers_count from followers group by(user_id) order by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect user_id, count(follower_id) as followers_count from followers group by(user_id) order by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1022603,
                "title": "easy-to-understand-mysql",
                "content": "Select user_id, count(follower_id) as followers_count\\nFrom Followers\\ngroup by user_id\\norder by user_id;",
                "solutionTags": [],
                "code": "Select user_id, count(follower_id) as followers_count\\nFrom Followers\\ngroup by user_id\\norder by user_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 3865387,
                "title": "100-easy-fast-clean-solution",
                "content": "IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE !\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT user_id, COUNT(*) followers_count FROM Followers \\n\\nGROUP BY user_id ORDER BY user_id\\n```\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/35ecd087-39c7-471a-8038-9aa386ecc544_1691211674.839522.jpeg)\\n",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT DISTINCT user_id, COUNT(*) followers_count FROM Followers \\n\\nGROUP BY user_id ORDER BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3262851,
                "title": "easy-to-understand-sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT DISTINCT user_id,\\nCOUNT(DISTINCT follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DISTINCT user_id,\\nCOUNT(DISTINCT follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3164968,
                "title": "easy-to-understand-oracle-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT user_id, COUNT(DISTINCT follower_id) as followers_count\\nFROM Followers GROUP BY user_id\\nORDER BY user_id ;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT user_id, COUNT(DISTINCT follower_id) as followers_count\\nFROM Followers GROUP BY user_id\\nORDER BY user_id ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2939933,
                "title": "simple-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id,count(follower_id) as followers_count  from Followers\\ngroup by user_id\\norder by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id,count(follower_id) as followers_count  from Followers\\ngroup by user_id\\norder by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2939549,
                "title": "easily-solution-using-count-and-group-by-solution-explained-as-well",
                "content": "First take the distinct user_id , now count the distinct followers . Group the table using user_id.\\n **NO NEED TO ADD UNNECESSARY ORDER BY IT ONLY DECREASE SPEED.**\\n\\nHope you like the solution . Please upvote\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct user_id , count(distinct follower_id) as followers_count from followers\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct user_id , count(distinct follower_id) as followers_count from followers\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2906327,
                "title": "using-count-group-by-order-by",
                "content": "# Query\\n```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(user_id) AS \\'followers_count\\'\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(user_id) AS \\'followers_count\\'\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2567816,
                "title": "mysql-group-by-order-by",
                "content": "SELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id",
                "solutionTags": [],
                "code": "SELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id",
                "codeTag": "Unknown"
            },
            {
                "id": 2286484,
                "title": "mysql-group-by",
                "content": "select user_id, count(distinct follower_id ) as followers_count\\nfrom Followers\\ngroup by user_id;",
                "solutionTags": [],
                "code": "select user_id, count(distinct follower_id ) as followers_count\\nfrom Followers\\ngroup by user_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 2163516,
                "title": "solution-you-don-t-need-to-copy",
                "content": "![image](https://assets.leetcode.com/users/images/9eedf7f8-4a3a-4bb8-a6ae-a0f322d46e05_1655493096.706341.gif)\\n\\n\\n```\\nselect user_id,count(follower_id) \\'followers_count\\'\\nfrom followers group by user_id order by 1;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect user_id,count(follower_id) \\'followers_count\\'\\nfrom followers group by user_id order by 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1970827,
                "title": "mysql-count-and-group-by-solution",
                "content": "```\\nselect user_id,count(follower_id) as followers_count\\nfrom Followers group by user_id order by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect user_id,count(follower_id) as followers_count\\nfrom Followers group by user_id order by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1889791,
                "title": "mysql-ms-sql-oracle-simple-and-clean",
                "content": "**Solution**:\\n```\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1403569,
                "title": "my-500th-solution",
                "content": "**`SELECT user_id,count(user_id) as followers_count FROM Followers GROUP BY user_id ORDER BY user_id `**",
                "solutionTags": [],
                "code": "**`SELECT user_id,count(user_id) as followers_count FROM Followers GROUP BY user_id ORDER BY user_id `**",
                "codeTag": "Unknown"
            },
            {
                "id": 4076342,
                "title": "pandas-sql-easy-find-followers-count",
                "content": "[see the Successfully Accepted Submission](https://leetcode.com/submissions/detail/1056235967/)\\n\\n```\\nimport pandas as pd\\n\\ndef count_followers(followers: pd.DataFrame) -> pd.DataFrame:\\n    #  We need a grouped Series where the \"follower_id\" column is associated with each unique \"user_id\", so first we must group data in the followers DataFrame by the \"user_id\" column and then select the \"follower_id\" column for each group. \\n    grouped_followers = followers.groupby(\\'user_id\\')[\\'follower_id\\']\\n    \\n    # At the same time, we need the count of occurrences for each value within the group. So, in the next step, we count the number of non-null entries within each group.\\n    counted_followers = grouped_followers.count()\\n    \\n    # Then, we convert the index (which represent group labels) into regular columns. \\n    structured_followers = counted_followers.reset_index()\\n    \\n    # After that, we rename the columns to match the desired output\\n    structured_followers.columns = [\\'user_id\\', \\'followers_count\\']\\n    \\n    # Finally, we sort the result table by \\'user_id\\' in ascending order\\n    sorted_followers = structured_followers.sort_values(by=\\'user_id\\', ascending=True)\\n    \\n    return sorted_followers\\n```\\n\\n**SQL**\\n[see the Successfully Accepted Submission](https://leetcode.com/submissions/detail/1061741107/)\\n\\n```\\nSELECT user_id, count(follower_id) as followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id\\n```\\n\\n```\\n-- Select \\'user_id\\' and count of \\'follower_id\\' as \\'followers_count\\'\\nSELECT user_id, count(follower_id) as followers_count\\n\\n-- Retrieve data from the \\'followers\\' table\\nFROM followers\\n\\n-- Group the results by \\'user_id\\' to count the number of followers for each user\\nGROUP BY user_id\\n\\n-- Order the results by \\'user_id\\' in ascending order\\nORDER BY user_id;\\n```\\n\\n![image](https://assets.leetcode.com/users/images/9f4fb141-fff0-4f13-b6e9-22b03c469f89_1695381734.753136.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef count_followers(followers: pd.DataFrame) -> pd.DataFrame:\\n    #  We need a grouped Series where the \"follower_id\" column is associated with each unique \"user_id\", so first we must group data in the followers DataFrame by the \"user_id\" column and then select the \"follower_id\" column for each group. \\n    grouped_followers = followers.groupby(\\'user_id\\')[\\'follower_id\\']\\n    \\n    # At the same time, we need the count of occurrences for each value within the group. So, in the next step, we count the number of non-null entries within each group.\\n    counted_followers = grouped_followers.count()\\n    \\n    # Then, we convert the index (which represent group labels) into regular columns. \\n    structured_followers = counted_followers.reset_index()\\n    \\n    # After that, we rename the columns to match the desired output\\n    structured_followers.columns = [\\'user_id\\', \\'followers_count\\']\\n    \\n    # Finally, we sort the result table by \\'user_id\\' in ascending order\\n    sorted_followers = structured_followers.sort_values(by=\\'user_id\\', ascending=True)\\n    \\n    return sorted_followers\\n```\n```\\nSELECT user_id, count(follower_id) as followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id\\n```\n```\\n-- Select \\'user_id\\' and count of \\'follower_id\\' as \\'followers_count\\'\\nSELECT user_id, count(follower_id) as followers_count\\n\\n-- Retrieve data from the \\'followers\\' table\\nFROM followers\\n\\n-- Group the results by \\'user_id\\' to count the number of followers for each user\\nGROUP BY user_id\\n\\n-- Order the results by \\'user_id\\' in ascending order\\nORDER BY user_id;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4019854,
                "title": "easy-mysql-solution",
                "content": "# **PLEASE UPVOTE MY SOLUTION IG YOU LIKE IT**\\n# **CONNECT WITH ME**\\n# **[https://www.linkedin.com/in/pratay-nandy-9ba57b229/]()**\\n# **[https://www.instagram.com/pratay_nandy/]()**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSQL Query Approach:\\n\\nSelect Statement: Start with the SELECT statement to specify the columns you want in the result. In this case, you want to select the user_id and the count of followers, which is calculated using the COUNT(*) function and aliased as followers_count.\\n\\n\\nSELECT user_id, COUNT(*) AS followers_count\\nFrom Clause: Specify the table from which you want to retrieve data. In this case, it\\'s the \"Followers\" table.\\n\\nFROM Followers\\nGroup By Clause: Use the GROUP BY clause to group the rows by the user_id column. This groups all rows with the same user_id value together.\\n\\n\\nGROUP BY user_id\\nOrder By Clause: To order the result set by user_id, you can use the ORDER BY clause.\\n\\nORDER BY user_id\\nResult: After executing this SQL query, you will get a result set that contains two columns: user_id and followers_count. Each row represents a user, and the followers_count column shows how many followers each user has. The result set will be ordered by user_id.\\n\\nWhen you execute this query, it will return a list of user_id values along with the count of followers for each user, ordered by user_id.\\n# Code\\n```\\nSELECT user_id, COUNT(*) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT user_id, COUNT(*) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3889878,
                "title": "perfect-solution",
                "content": "\\n\\n# Code\\n```\\nSELECT\\n    user_id,\\n    COUNT(follower_id) as followers_count\\nFROM\\n    Followers\\nGROUP BY 1\\nORDER BY 1\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    user_id,\\n    COUNT(follower_id) as followers_count\\nFROM\\n    Followers\\nGROUP BY 1\\nORDER BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3793541,
                "title": "simple-using-order-and-group-by",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(follower_id) AS followers_count FROM followers\\nGroup by user_id\\nORDER BY user_id ASC;\\n```\\n![1qivbn.jpg](https://assets.leetcode.com/users/images/a169dbd7-b34d-4a99-8359-a8a813239d9a_1689869293.2703924.jpeg)",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(follower_id) AS followers_count FROM followers\\nGroup by user_id\\nORDER BY user_id ASC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3776416,
                "title": "find-followers-count-mysql-solution-code",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id, count(distinct follower_id) as followers_count from Followers\\ngroup by user_id \\norder by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id, count(distinct follower_id) as followers_count from Followers\\ngroup by user_id \\norder by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3745582,
                "title": "easy-solution",
                "content": "\\n# Code\\n```\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers \\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers \\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3688542,
                "title": "easy-sql-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(DISTINCT follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\norder by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(DISTINCT follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\norder by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3621178,
                "title": "solution-using-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect user_id , count(user_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id asc , followers_count asc;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect user_id , count(user_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id asc , followers_count asc;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3552498,
                "title": "easy-sql-code",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(user_id) AS followers_count FROM Followers GROUP BY user_id ORDER BY user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(user_id) AS followers_count FROM Followers GROUP BY user_id ORDER BY user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3446257,
                "title": "unique-solution-mysql",
                "content": "# Use distinct\\n```\\nselect distinct user_id,count(follower_id) as followers_count \\nfrom followers \\ngroup by user_id \\norder by user_id\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\nselect distinct user_id,count(follower_id) as followers_count \\nfrom followers \\ngroup by user_id \\norder by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3306836,
                "title": "sql-server-clean-easy",
                "content": "```\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id ASC;\\n\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id ASC;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3265289,
                "title": "simple-mysql-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id,COUNT(DISTINCT(follower_id)) AS followers_count\\nFROM followers\\nGROUP BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id,COUNT(DISTINCT(follower_id)) AS followers_count\\nFROM followers\\nGROUP BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3258544,
                "title": "easy-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\nSELECT DISTINCT user_id,\\nCOUNT(DISTINCT follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT DISTINCT user_id,\\nCOUNT(DISTINCT follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3090205,
                "title": "simple-query-find-followers-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id,count(follower_id) as followers_count from Followers group by user_id order by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id,count(follower_id) as followers_count from Followers group by user_id order by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2905101,
                "title": "extremely-simplified-mysql",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id, count(user_id) \\'followers_count\\' from followers group by user_id order by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id, count(user_id) \\'followers_count\\' from followers group by user_id order by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2746741,
                "title": "mysql-solution-easy-beginner-level",
                "content": "\\tSelect user_id , Count(Distinct follower_id) as followers_count \\n\\tfrom Followers \\n\\tgroup by user_id",
                "solutionTags": [],
                "code": "\\tSelect user_id , Count(Distinct follower_id) as followers_count \\n\\tfrom Followers \\n\\tgroup by user_id",
                "codeTag": "Unknown"
            },
            {
                "id": 2610345,
                "title": "count-group-by-order-by-solution",
                "content": "```\\nSELECT user_id,\\nCOUNT(DISTINCT follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT user_id,\\nCOUNT(DISTINCT follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2608590,
                "title": "sql-easy-solution-using-group-by-order-by-count-clauses",
                "content": "\\tSELECT \\n\\t\\tuser_id,\\n\\t\\tCOUNT(follower_id) AS followers_count\\n\\tFROM Followers \\n\\tGROUP BY user_id \\n\\tORDER BY user_id;\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tSELECT \\n\\t\\tuser_id,\\n\\t\\tCOUNT(follower_id) AS followers_count\\n\\tFROM Followers \\n\\tGROUP BY user_id \\n\\tORDER BY user_id;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2444440,
                "title": "easy-to-understand-mysql-solution",
                "content": "```\\nSELECT fl.user_id,COUNT(DISTINCT fl.follower_id) AS followers_count\\nFROM followers fl\\nGROUP BY fl.user_id\\nORDER BY fl.user_id ASC;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT fl.user_id,COUNT(DISTINCT fl.follower_id) AS followers_count\\nFROM followers fl\\nGROUP BY fl.user_id\\nORDER BY fl.user_id ASC;",
                "codeTag": "Unknown"
            },
            {
                "id": 2417985,
                "title": "mysql-easy-and-simple-code",
                "content": "# Write your MySQL query statement below\\nselect\\n        distinct user_id,\\n        count(*) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;\\n",
                "solutionTags": [],
                "code": "# Write your MySQL query statement below\\nselect\\n        distinct user_id,\\n        count(*) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2394377,
                "title": "simple-group-by-and-order-by-solution-without-using-followers-id",
                "content": "\\n**After reading the question carefully and understanding we can conclude that the number of followers a user has = number of times his/her user id occoured in the user_id column....thats all there is to this question.**\\n\\n`select distinct(user_id) as user_id,count(user_id) as followers_count from Followers group by user_id order by user_id;`",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\n**After reading the question carefully and understanding we can conclude that the number of followers a user has = number of times his/her user id occoured in the user_id column....thats all there is to this question.**\\n\\n`select distinct(user_id) as user_id,count(user_id) as followers_count from Followers group by user_id order by user_id;`",
                "codeTag": "Unknown"
            },
            {
                "id": 2372336,
                "title": "mysql-easy-group-by-count",
                "content": "```\\nSELECT user_id , COUNT(follower_id) as followers_count \\nFROM Followers GROUP BY user_id ORDER BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT user_id , COUNT(follower_id) as followers_count \\nFROM Followers GROUP BY user_id ORDER BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2332859,
                "title": "easy-solution-aggregate-function",
                "content": "\\n```\\nSELECT user_id, count(*) as followers_count \\nFROM Followers GROUP BY user_id ORDER BY user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT user_id, count(*) as followers_count \\nFROM Followers GROUP BY user_id ORDER BY user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2257077,
                "title": "mysql-faster-than-97-34",
                "content": "select user_id, count(distinct follower_id) as followers_count from Followers\\ngroup by user_id\\norder by user_id;",
                "solutionTags": [],
                "code": "select user_id, count(distinct follower_id) as followers_count from Followers\\ngroup by user_id\\norder by user_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 2256118,
                "title": "easy-solution-in-mysql-count-distinct",
                "content": "```\\nselect user_id,\\ncount(distinct follower_id) as followers_count from Followers\\ngroup by user_id\\n\\n```\\n\\n**Please UpVote if it was Helpful :)**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect user_id,\\ncount(distinct follower_id) as followers_count from Followers\\ngroup by user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2245471,
                "title": "oracle",
                "content": "```\\nSELECT user_id, count(user_id) as followers_count FROM followers GROUP BY user_id ORDER BY user_id;",
                "solutionTags": [],
                "code": "```\\nSELECT user_id, count(user_id) as followers_count FROM followers GROUP BY user_id ORDER BY user_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 2239882,
                "title": "mysql-group-by",
                "content": "```\\nselect distinct user_id , count(follower_id) as followers_count from Followers group by user_id order by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct user_id , count(follower_id) as followers_count from Followers group by user_id order by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2222236,
                "title": "sql-easy-fast-solution",
                "content": "```\\nSELECT user_id , COUNT(user_id) AS \\'followers_count\\'\\nFROM Followers \\nGROUP BY user_id\\nORDER BY user_id\\n```\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT user_id , COUNT(user_id) AS \\'followers_count\\'\\nFROM Followers \\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2050598,
                "title": "using-group-by-and-order-by-very-easy-mysql",
                "content": "```\\nSELECT user_id, COUNT(*) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id;\\n```\\n\\n**IF I WAS HELPFUL, PLEASE UPVOTE**",
                "solutionTags": [],
                "code": "```\\nSELECT user_id, COUNT(*) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2001506,
                "title": "mysql-faster-than-95",
                "content": "```\\n\\nSelect user_id, Count(follower_id) as followers_count\\nFrom Followers\\nGroup By 1\\nOrder by user_id\\n```",
                "solutionTags": [],
                "code": "```\\n\\nSelect user_id, Count(follower_id) as followers_count\\nFrom Followers\\nGroup By 1\\nOrder by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1994346,
                "title": "find-followers-count-mysql-easy-solution",
                "content": "select user_id,count(*) as followers_count from Followers group by user_id order by user_id;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select user_id,count(*) as followers_count from Followers group by user_id order by user_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 1980929,
                "title": "simple-group-by-sql-query",
                "content": "```\\nselect user_id, count(distinct follower_id) as followers_count\\nfrom Followers group by user_id order by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect user_id, count(distinct follower_id) as followers_count\\nfrom Followers group by user_id order by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1960957,
                "title": "mysql-easy-implementation",
                "content": "```\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1890221,
                "title": "beginner-friendly-sql",
                "content": "\\t# Write your MySQL query statement below\\n\\tselect user_id, count(*) as followers_count from Followers group by user_id order by user_id;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\t# Write your MySQL query statement below\\n\\tselect user_id, count(*) as followers_count from Followers group by user_id order by user_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 1063946,
                "title": "mysql",
                "content": "```\\nSELECT USER_ID,\\n       COUNT(FOLLOWER_ID) FOLLOWERS_COUNT\\nFROM FOLLOWERS\\nGROUP BY USER_ID\\nORDER BY 1\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT USER_ID,\\n       COUNT(FOLLOWER_ID) FOLLOWERS_COUNT\\nFROM FOLLOWERS\\nGROUP BY USER_ID\\nORDER BY 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1023573,
                "title": "runtime-476-ms-faster-than-100-00-of-mysql-online-submissions",
                "content": "SELECT user_id, COUNT(follower_id) as followers_count FROM Followers\\nGROUP BY user_id\\nORDER BY user_id ASC",
                "solutionTags": [],
                "code": "SELECT user_id, COUNT(follower_id) as followers_count FROM Followers\\nGROUP BY user_id\\nORDER BY user_id ASC",
                "codeTag": "Unknown"
            },
            {
                "id": 4106674,
                "title": "simple-code-for-beginners-easy-approach",
                "content": "\\n# Code\\n```\\nselect user_id,count(follower_id) as followers_count from followers\\ngroup by user_id\\norder by user_id ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect user_id,count(follower_id) as followers_count from followers\\ngroup by user_id\\norder by user_id ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4103510,
                "title": "beats-89-user",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect user_id, count(distinct follower_id) as followers_count from Followers f \\ngroup by user_id\\norder by user_id asc;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect user_id, count(distinct follower_id) as followers_count from Followers f \\ngroup by user_id\\norder by user_id asc;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4103501,
                "title": "easy-ms-sql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect user_id ,count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect user_id ,count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4102303,
                "title": "simple-easy-solution-beats-96-68",
                "content": "## Upvote .. if found easyyyyy... !!!\\n# Approach\\n- The ORDER BY keyword is used to sort the result-set in ascending or descending order.\\n- The GROUP BY statement is often used with aggregate functions (COUNT(), MAX(), MIN(), SUM(), AVG()) to group the result-set by one or more columns.\\n# Complexity\\n- Runtime :: 930ms\\nBeats 96.68% of users with MySQL\\n- Memory :: 0.00MB\\nBeats 100.00% of users with MySQL\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id , count(follower_id) as followers_count from Followers group by user_id order by user_id asc\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id , count(follower_id) as followers_count from Followers group by user_id order by user_id asc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4101538,
                "title": "easy-find-followers-count-group-by-order-by",
                "content": "\\n# Write your MySQL query statement below\\nselect user_id, count(follower_id) \\'followers_count\\' from Followers group by user_id order by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\n# Write your MySQL query statement below\\nselect user_id, count(follower_id) \\'followers_count\\' from Followers group by user_id order by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4101527,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id,count(follower_id) as followers_count from Followers group by user_id order by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id,count(follower_id) as followers_count from Followers group by user_id order by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100929,
                "title": "find-follower-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect user_id, count(distinct(follower_id)) as followers_count from Followers group by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect user_id, count(distinct(follower_id)) as followers_count from Followers group by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4099688,
                "title": "simple-query-that-beats-99-users-with-steps",
                "content": "# Approach\\n1. Select the user_id, count(follower_id)\\n2. This will give you the follower count if you group by user_id\\n3. Then order by user_id\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n# Code\\n```\\nSELECT USER_ID, COUNT(FOLLOWER_ID) AS FOLLOWERS_COUNT\\nFROM FOLLOWERS\\nGROUP BY USER_ID\\nORDER BY USER_ID\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT USER_ID, COUNT(FOLLOWER_ID) AS FOLLOWERS_COUNT\\nFROM FOLLOWERS\\nGROUP BY USER_ID\\nORDER BY USER_ID\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096564,
                "title": "pandas-one-step-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef count_followers(followers: pd.DataFrame) -> pd.DataFrame:\\n    return followers.groupby(\\'user_id\\')[\\'follower_id\\'].nunique().reset_index(name=\\'followers_count\\')\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef count_followers(followers: pd.DataFrame) -> pd.DataFrame:\\n    return followers.groupby(\\'user_id\\')[\\'follower_id\\'].nunique().reset_index(name=\\'followers_count\\')\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4093440,
                "title": "simple-solution-top-80",
                "content": "# Explanation\\nHere we are simply selecting the user id, and the count of follower id\\'s. We group by the user id to get the count of followers per each user. We order by user id to get the id\\'s with the lowest numbers at the top of the list. **Make sure to like if this was useful!!!**\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4091749,
                "title": "sql-simple-solution",
                "content": "# Code\\n\\n```\\nSELECT \\n  user_id,\\n  count(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT \\n  user_id,\\n  count(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090569,
                "title": "sample-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(user_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(user_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4089449,
                "title": "pandas-one-liner",
                "content": "Groupby \\'user_id\\' and get counts. Reset_index and rename columns for submission\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef count_followers(followers: pd.DataFrame) -> pd.DataFrame:\\n    return followers.groupby(\\'user_id\\').count().reset_index().rename(columns={\\'follower_id\\': \\'followers_count\\'})\\n\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef count_followers(followers: pd.DataFrame) -> pd.DataFrame:\\n    return followers.groupby(\\'user_id\\').count().reset_index().rename(columns={\\'follower_id\\': \\'followers_count\\'})\\n\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4087348,
                "title": "easy-solution-group-by-clause",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect\\nuser_id, count(*) as followers_count\\nFrom Followers\\ngroup by user_id\\norder by user_id ASC\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect\\nuser_id, count(*) as followers_count\\nFrom Followers\\ngroup by user_id\\norder by user_id ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081684,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct user_id, count(follower_id) as followers_count from followers group by user_id order by user_id asc;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct user_id, count(follower_id) as followers_count from followers group by user_id order by user_id asc;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078187,
                "title": "best-solution-if-you-are-beginner",
                "content": "# Code\\n```\\nselect user_id, count(follower_id) as followers_count from Followers group by user_id order by user_id ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect user_id, count(follower_id) as followers_count from Followers group by user_id order by user_id ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4075346,
                "title": "group-by-order-by",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect user_id, count(follower_id) as followers_count from followers \\n\\n\\n\\ngroup by user_id order by user_id;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect user_id, count(follower_id) as followers_count from followers \\n\\n\\n\\ngroup by user_id order by user_id;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073876,
                "title": "beats-82-64-of-users-with-mysql",
                "content": "\\n# Code\\n```\\nSELECT user_id, COUNT(DISTINCT follower_id) AS followers_count \\nFROM Followers \\nGROUP BY user_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT user_id, COUNT(DISTINCT follower_id) AS followers_count \\nFROM Followers \\nGROUP BY user_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072638,
                "title": "one-liner-solution-count-group-by-order-by-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id, count(follower_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id asc;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id, count(follower_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id asc;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4071413,
                "title": "count-group-by-order-by",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id, count(follower_id) as followers_count from Followers group by user_id order by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id, count(follower_id) as followers_count from Followers group by user_id order by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061673,
                "title": "sql-basic-count-group-by-order-by",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id, count(follower_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id, count(follower_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061350,
                "title": "mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nBeats 93.26%of users with MySQL\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id,count(follower_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id,count(follower_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059941,
                "title": "find-followers-count-by-12th-student",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT USER_ID , COUNT(FOLLOWER_ID) AS FOLLOWERS_COUNT FROM FOLLOWERS\\nGROUP BY USER_ID\\nORDER BY USER_ID ASC;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT USER_ID , COUNT(FOLLOWER_ID) AS FOLLOWERS_COUNT FROM FOLLOWERS\\nGROUP BY USER_ID\\nORDER BY USER_ID ASC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059049,
                "title": "simply-solution-for-mssql-server",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1st look at the output table.\\nfrom there you will know which cloumn need to display/print from which table.\\n\\nThen i follow the question and solve it.  \\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058918,
                "title": "find-followers-count-easy-sql-server-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\n\\nSELECT user_id, COUNT(user_id)  as followers_count\\nFROM Followers \\ngroup by user_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\n\\nSELECT user_id, COUNT(user_id)  as followers_count\\nFROM Followers \\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058877,
                "title": "1729-find-followers-count-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n## ***Code***\\n```\\n# Write your MySQL query statement below\\nselect distinct user_id ,count(user_id) as followers_count\\n### from followers\\ngroup by user_id\\norder by user_id asc\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct user_id ,count(user_id) as followers_count\\n### from followers\\ngroup by user_id\\norder by user_id asc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057896,
                "title": "simple-sql",
                "content": "# Intuition\\nUsing GROUP BY\\n\\n# Approach\\nSelect user id and count of it (use alias name for output) using followers table using basic  SELECT and use GROUP BY on user id and use ORDER BY for ascending order results\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id,COUNT(*) AS followers_count FROM Followers \\nGROUP BY user_id ORDER by user_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id,COUNT(*) AS followers_count FROM Followers \\nGROUP BY user_id ORDER by user_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055071,
                "title": "beats-99-5-simple-solution",
                "content": "##### Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4053262,
                "title": "very-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id, count(distinct follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id, count(distinct follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052000,
                "title": "mysql-solution-for-find-followers-count-problem",
                "content": "```\\nselect user_id, COUNT(IF(follower_id is not null, 1, 0)) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect user_id, COUNT(IF(follower_id is not null, 1, 0)) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4051581,
                "title": "basic-sql-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id , count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id asc\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id , count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id asc\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048971,
                "title": "easy-sql-beats-97-57-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id, count(follower_id) as followers_count from Followers group by user_id order by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id, count(follower_id) as followers_count from Followers group by user_id order by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047884,
                "title": "find-followers-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id asc;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id asc;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046478,
                "title": "easy-solution-runtime-details-961ms-beats-97-82-of-users-with-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id, count(distinct follower_id) followers_count from followers group by user_id order by user_id asc\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id, count(distinct follower_id) followers_count from followers group by user_id order by user_id asc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039929,
                "title": "single-line-solution",
                "content": "# Code\\n```\\nSelect user_id,\\n       count(follower_id) followers_count\\nfrom followers\\ngroup by user_id\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSelect user_id,\\n       count(follower_id) followers_count\\nfrom followers\\ngroup by user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4036059,
                "title": "my-sql-simple-easiest-approach-beats-98",
                "content": "# Intuition \\uD83D\\uDCA1\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to count the `number of followers` for each user.\\nTo do this, we can use SQL\\'s GROUP BY clause to group the rows by user_id.\\nThen, we can use the COUNT() function to count the number of follower_id entries for each user. Finally, we can order the result by user_id in ascending order.\\n\\n# Solution \\uD83D\\uDCA1\\n<!-- Describe your approach to solving the problem. -->\\n```sql\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id;\\n```\\n> **PLZ. UPVOTE IF YOU FIND IT HELPFUL \\u2B06\\uFE0F**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4032667,
                "title": "1729-mysql-solution",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT USER_ID, COUNT(FOLLOWER_ID) AS FOLLOWERS_COUNT\\nFROM FOLLOWERS\\nGROUP BY USER_ID\\nORDER BY USER_ID ASC\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT USER_ID, COUNT(FOLLOWER_ID) AS FOLLOWERS_COUNT\\nFROM FOLLOWERS\\nGROUP BY USER_ID\\nORDER BY USER_ID ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025566,
                "title": "simple-approach-using-group-by",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect user_id,count(follower_id) as followers_count from followers\\ngroup by user_id\\norder by user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect user_id,count(follower_id) as followers_count from followers\\ngroup by user_id\\norder by user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4010589,
                "title": "ms-sql-server-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4009275,
                "title": "simple-one-line-solution-beginner-friendly",
                "content": "# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect user_id, count(follower_id) as followers_count from followers group by user_id order by user_id\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect user_id, count(follower_id) as followers_count from followers group by user_id order by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008842,
                "title": "simple-group-by-solution",
                "content": "# Code\\n```\\nselect user_id, Count(follower_id) as followers_count from Followers group by user_id order by user_id asc\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nselect user_id, Count(follower_id) as followers_count from Followers group by user_id order by user_id asc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006777,
                "title": "beginner-level-query-group-by-order-by",
                "content": "\\n\\n# Code\\n```\\nselect user_id, count(follower_id) as followers_count\\nfrom Followers \\ngroup by user_id\\norder by user_id\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/f5b2fb8f-c988-4d07-897f-e15ee4a80b6f_1693937351.678686.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect user_id, count(follower_id) as followers_count\\nfrom Followers \\ngroup by user_id\\norder by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005792,
                "title": "easy-sql-solution-for-beginners",
                "content": "# Intuition\\nIn this we need to user group by clause and order by clause in order to sort the user_id \\n\\n# Approach\\nMake sure to use the group by clause and order by clause to get the desired output \\n\\n\\n![pls upvote 1.gif](https://assets.leetcode.com/users/images/3e622938-d51e-42e3-82d7-1186406d89df_1693923412.9700854.gif)\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id ,count(follower_id) as followers_count from followers group by user_id order by user_id  ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id ,count(follower_id) as followers_count from followers group by user_id order by user_id  ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4005105,
                "title": "fast-mysql-solution-with-window-functions",
                "content": "# Intuition\\nActually *group by* works for this problem, but window function makes it work faster.\\n\\n# Approach\\nInstead of grouping followers count by user_id with *group by()* function, I used *over()* construction. Don\\'t forget to fetch *distinct* values to avoid duplicates in the resulting table.\\n\\n# Complexity\\n- Time complexity: 1209ms\\n\\n- Space complexity: 0.00MB\\n\\n# Code\\n```\\nselect distinct\\n    user_id,\\n    count(follower_id) over (partition by user_id)as followers_count\\nfrom Followers\\norder by user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect distinct\\n    user_id,\\n    count(follower_id) over (partition by user_id)as followers_count\\nfrom Followers\\norder by user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4001335,
                "title": "mysql-first-thought-basic-solution",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id,count(follower_id) AS followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id,count(follower_id) AS followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3999326,
                "title": "sql-simple-solution-don-t-forget-group-by",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id, count(user_id) followers_count from Followers group by user_id\\norder by user_id asc\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id, count(user_id) followers_count from Followers group by user_id\\norder by user_id asc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3998026,
                "title": "oracle-group-by-function",
                "content": "\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect user_id,count(user_id) as followers_count \\nfrom Followers\\ngroup by user_id\\norder by user_id ;\\n\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect user_id,count(user_id) as followers_count \\nfrom Followers\\ngroup by user_id\\norder by user_id ;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3997922,
                "title": "simple-way",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT USER_ID,COUNT(FOLLOWER_ID) AS FOLLOWERS_COUNT\\nFROM FOLLOWERS\\nGROUP BY USER_ID\\nORDER BY USER_ID;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT USER_ID,COUNT(FOLLOWER_ID) AS FOLLOWERS_COUNT\\nFROM FOLLOWERS\\nGROUP BY USER_ID\\nORDER BY USER_ID;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3992370,
                "title": "clear-easy-sql-step-by-step-correct-formatting-comprehensive-explanation",
                "content": "# \\u2757 Upvote \\u2B06 if you found this useful \\u2714\\n\\n# \\uD83D\\uDCA1 Intuition (hint)\\n\\nBasic query including COUNT+DISTINCT and GROUP BY.\\n\\n# \\uD83C\\uDFAF Approach (solution)\\n\\nSimply SELECT the *user_id* together with COUNTed DISTINCT *follower_id*.\\nGROUP results BY *user_id*. \\n\\n# \\uD83D\\uDCC8 Complexity\\n\\n- \\u23F1 Time complexity:\\nBeats 75% of solutions with MySQL (at the time of submission)\\n\\n- \\uD83D\\uDCBE Space complexity:\\nBeats 100% of solutions with MySQL (space complexity in case of this problem is constant for all solutions)\\n\\n# \\uD83D\\uDD25 Code\\n\\n```sql\\nSELECT\\n\\xA0 \\xA0 user_id\\n\\xA0 \\xA0 ,COUNT(DISTINCT follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id;\\n```\\n# \\u2757 Upvote \\u2B06 if you found this useful \\u2714",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nSELECT\\n\\xA0 \\xA0 user_id\\n\\xA0 \\xA0 ,COUNT(DISTINCT follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3989768,
                "title": "ms-sql-server-explication",
                "content": "# Approach\\n\\nEasy task, we just need to count the followers for each user_id\\n\\n\\n\\n# Code\\n```\\nSelect user_id, count(follower_id) as followers_count FROM Followers \\nGROUP BY user_id\\nORDER BY user_id ASC\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSelect user_id, count(follower_id) as followers_count FROM Followers \\nGROUP BY user_id\\nORDER BY user_id ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3987269,
                "title": "sql-find-followers-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id, count(*) AS followers_count\\n FROM Followers\\n GROUP BY user_id\\n ORDER BY user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id, count(*) AS followers_count\\n FROM Followers\\n GROUP BY user_id\\n ORDER BY user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982949,
                "title": "sql-simple-solution-count-distinct-group-by",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT\\nDISTINCT user_id,\\nCOUNT(user_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id ASC\\n```\\n",
                "solutionTags": [
                    "MS SQL Server",
                    "Database"
                ],
                "code": "```\\nSELECT\\nDISTINCT user_id,\\nCOUNT(user_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982016,
                "title": "easy-solution-mysql",
                "content": "\\tSELECT user_id ,COUNT(follower_id) as followers_count\\n\\tFROM Followers\\n\\tGROUP BY user_id\\n\\tORDER BY user_id;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tSELECT user_id ,COUNT(follower_id) as followers_count\\n\\tFROM Followers\\n\\tGROUP BY user_id\\n\\tORDER BY user_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 3967415,
                "title": "number-of-followers-for-each-user-mysql",
                "content": "SELECT user_id,COUNT(follower_id) AS followers_count FROM Followers GROUP BY user_id ORDER BY user_id;",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "SELECT user_id,COUNT(follower_id) AS followers_count FROM Followers GROUP BY user_id ORDER BY user_id;",
                "codeTag": "Unknown"
            },
            {
                "id": 3966789,
                "title": "simple-followers-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT \\n    user_id,\\n    COUNT(follower_id) AS followers_count\\n    FROM Followers\\n    GROUP BY user_id\\n    ORDER BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT \\n    user_id,\\n    COUNT(follower_id) AS followers_count\\n    FROM Followers\\n    GROUP BY user_id\\n    ORDER BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3964935,
                "title": "simple-mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id, count(follower_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id, count(follower_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3960579,
                "title": "oracle-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect user_id, count(follower_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect user_id, count(follower_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3960186,
                "title": "easy-simple-straightforward-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. \\n<!-- Describe your approach to solving the problem. -->\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(follower_id) followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(follower_id) followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957000,
                "title": "sql-group-by-order-by",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\n\\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity:\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity:\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\n# Write your MySQL query statement below  \\r\\nSELECT user_id, COUNT(user_id) AS followers_count\\r\\nFROM Followers\\r\\nGROUP BY user_id\\r\\nORDER BY user_id;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\r\\n# Write your MySQL query statement below  \\r\\nSELECT user_id, COUNT(user_id) AS followers_count\\r\\nFROM Followers\\r\\nGROUP BY user_id\\r\\nORDER BY user_id;\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3956934,
                "title": "mysql-group-by-and-order-by",
                "content": "\\n\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id, count(distinct follower_id) followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id, count(distinct follower_id) followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955870,
                "title": "mysql-easy-solution",
                "content": "\\n\\n# Code\\n```\\nSELECT user_id, COUNT(user_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id \\nORDER BY user_id ASC;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT user_id, COUNT(user_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id \\nORDER BY user_id ASC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955803,
                "title": "easiest-sql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct user_id, count(follower_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct user_id, count(follower_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955128,
                "title": "find-followers-count",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id, count(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id, count(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3954087,
                "title": "memory-details-0-00mb-beats-100-00-of-users-with-mysql-bug-in-leetcode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\n    user_id,\\n    COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n    user_id,\\n    COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952993,
                "title": "count-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT user_id, COUNT(user_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT user_id, COUNT(user_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952948,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3952351,
                "title": "easy-to-understand-learn-how-to-write-clean-code",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT\\n    user_id,\\n    COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id ASC;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT\\n    user_id,\\n    COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id ASC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951942,
                "title": "sql-easy-peasy",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id, Count(user_id) as followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id ASC\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id, Count(user_id) as followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951796,
                "title": "easy-sql-solution",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT user_id, count(user_id) as followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT user_id, count(user_id) as followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3951055,
                "title": "sql-basic-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id,count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id asc\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id,count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id asc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3950059,
                "title": "mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947563,
                "title": "simple-my-sql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id, count(follower_id) as followers_count from Followers \\ngroup by user_id order by user_id \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id, count(follower_id) as followers_count from Followers \\ngroup by user_id order by user_id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3944541,
                "title": "best-solution-easy-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id ,\\n       COUNT(follower_id) as followers_count \\nFROM Followers \\nGROUP BY user_id \\nORDER BY user_id ASC ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id ,\\n       COUNT(follower_id) as followers_count \\nFROM Followers \\nGROUP BY user_id \\nORDER BY user_id ASC ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938055,
                "title": "easy-solution-sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect user_id,count(*) as followers_count from Followers\\ngroup by user_id \\norder by user_id asc\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect user_id,count(*) as followers_count from Followers\\ngroup by user_id \\norder by user_id asc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3936019,
                "title": "just-do-step-by-step",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id, count(distinct follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id, count(distinct follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3935250,
                "title": "simple-groupby-solution-using-count",
                "content": "# Code\\n```\\nimport pandas as pd\\n\\ndef count_followers(followers: pd.DataFrame) -> pd.DataFrame:\\n    return followers.groupby(\\'user_id\\')[\\'follower_id\\'].count().reset_index().rename(columns={\\'follower_id\\':\\'followers_count\\'})\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef count_followers(followers: pd.DataFrame) -> pd.DataFrame:\\n    return followers.groupby(\\'user_id\\')[\\'follower_id\\'].count().reset_index().rename(columns={\\'follower_id\\':\\'followers_count\\'})\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3932760,
                "title": "sql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT user_id, count(*) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id ASC\\n```",
                "solutionTags": [
                    "MySQL",
                    "Oracle"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT user_id, count(*) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931820,
                "title": "sql-basic-query-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect user_id ,count(user_id) as followers_count from followers where follower_id!=user_id group by user_id order by user_id; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect user_id ,count(user_id) as followers_count from followers where follower_id!=user_id group by user_id order by user_id; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3930040,
                "title": "simple-sql-solution",
                "content": "\\n# Code\\n```\\nselect user_id,count(*) as followers_count\\nfrom Followers f\\ngroup by f.user_id\\norder by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect user_id,count(*) as followers_count\\nfrom Followers f\\ngroup by f.user_id\\norder by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3923458,
                "title": "solution-to-count-the-number-of-followers-for-a-particular-user",
                "content": "# Intuition\\nWhen the question is seen it an be very well know that user want the ccount of the followers\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nccount the distinct followers for a single user_id\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id,count( distinct follower_id) as followers_count from followers group by user_id order by user_id asc  \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id,count( distinct follower_id) as followers_count from followers group by user_id order by user_id asc  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3922877,
                "title": "best-solution-for-mysql-time-complesity",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT DISTINCT user_id, COUNT(follower_id) AS followers_count FROM Followers\\nGROUP BY user_id \\nORDER BY user_id ASC\\n```\\n# HIT LIKE BUTTON",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT DISTINCT user_id, COUNT(follower_id) AS followers_count FROM Followers\\nGROUP BY user_id \\nORDER BY user_id ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3922115,
                "title": "easy-ans",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id,count(*) as followers_count from followers group by user_id order by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id,count(*) as followers_count from followers group by user_id order by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3913939,
                "title": "simplest-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1771ms\\nBeats 6.72%of users with MySQL\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nBeats 100.00%of users with MySQL\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id, count(distinct follower_id) as followers_count from Followers\\ngroup by user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id, count(distinct follower_id) as followers_count from Followers\\ngroup by user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3904149,
                "title": "explained-the-most-easy-sql-you-can-have",
                "content": "# Intuition\\n**Use user_id and COUNT(follower_id) AS followers_count.**\\nIn this SQL query, we are trying to determine the number of followers for each user. \\n- We use the user_id as the identifier for each user and count the number of associated follower_id entries for each user.\\n\\n\\n# Approach\\nWe use the Followers table to retrieve data about the user-follower relationships.\\n- We apply the GROUP BY clause on the user_id column to group the data by users.\\n- Within each group, we use the aggregate function COUNT(follower_id) to count the number of followers for that user.\\n- The final result is ordered by user_id in ascending order.\\n\\n\\n# Complexity\\n- Time complexity:\\nhe time complexity of this query largely depends on the size of the Followers table and the efficiency of indexing. \\n\\n    In the worst case scenario, without proper indexing, the time complexity could be close to O(n^2), where n is the number of entries in the Followers table. With proper indexing, it could be closer to O(n * log(n)) or better.\\n\\n- Space complexity:\\nThe space complexity is primarily determined by the number of distinct user_id values, so it\\'s generally O(n), where n is the number of unique users in the Followers table.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id ASC;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT user_id, COUNT(follower_id) AS followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id ASC;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3903181,
                "title": "simple-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id , count(distinct(follower_id)) as followers_count\\nfrom Followers\\ngroup by user_id order by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id , count(distinct(follower_id)) as followers_count\\nfrom Followers\\ngroup by user_id order by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3902724,
                "title": "oneline-pandas",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef count_followers(followers: pd.DataFrame) -> pd.DataFrame:\\n    df = followers.groupby(\\'user_id\\').agg(\\n        followers_count = (\\'follower_id\\',\\'count\\')\\n    ).reset_index()\\n    return df\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef count_followers(followers: pd.DataFrame) -> pd.DataFrame:\\n    df = followers.groupby(\\'user_id\\').agg(\\n        followers_count = (\\'follower_id\\',\\'count\\')\\n    ).reset_index()\\n    return df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3900856,
                "title": "asked-in-tesla-very-simple-and-easy-to-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect user_id , count(follower_id) as followers_count from Followers\\ngroup by user_id \\norder by user_id asc ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect user_id , count(follower_id) as followers_count from Followers\\ngroup by user_id \\norder by user_id asc ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3900583,
                "title": "easily-explained-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect distinct(user_id),count( user_id) as followers_count from Followers  group by user_id order by user_id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect distinct(user_id),count( user_id) as followers_count from Followers  group by user_id order by user_id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3898295,
                "title": "count-followers",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect user_id,count(follower_id) as followers_count from Followers group by user_id order by user_id ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect user_id,count(follower_id) as followers_count from Followers group by user_id order by user_id ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3896015,
                "title": "mysql-solution-group-by",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSElECT user_id, COUNT(user_id) as followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSElECT user_id, COUNT(user_id) as followers_count\\nFROM Followers\\nGROUP BY user_id\\nORDER BY user_id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3894291,
                "title": "very-easy",
                "content": "The SQL query you\\'ve provided calculates the count of followers for each user in a table named \"Followers\". \\n\\n```sql\\nSELECT\\n    user_id,\\n    COUNT(follower_id) as followers_count\\nFROM\\n    Followers\\nGROUP BY 1\\nORDER BY 1;\\n```\\n\\n- `SELECT user_id, COUNT(follower_id) as followers_count`: This part of the query selects the `user_id` column and calculates the count of `follower_id` occurrences for each `user_id`. The result of this count is given the alias `followers_count`.\\n\\n- `FROM Followers`: This specifies that the data is being selected from the \"Followers\" table.\\n\\n- `GROUP BY 1`: This groups the data by the first selected column, which is `user_id`. It means that the counts will be calculated separately for each distinct `user_id`.\\n\\n- `ORDER BY 1`: This orders the result set based on the first selected column, which is `user_id`. It ensures that the output rows are arranged in ascending order of `user_id`.\\n",
                "solutionTags": [],
                "code": "```sql\\nSELECT\\n    user_id,\\n    COUNT(follower_id) as followers_count\\nFROM\\n    Followers\\nGROUP BY 1\\nORDER BY 1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3893066,
                "title": "very-easy-using-group-by-clause",
                "content": "# Intuition\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect  user_id,count(*) as followers_count\\n  from Followers \\ngroup by user_id\\norder by user_id asc; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect  user_id,count(*) as followers_count\\n  from Followers \\ngroup by user_id\\norder by user_id asc; \\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1576631,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 1711490,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 2062190,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 2009679,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 1920430,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 1885003,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 1825314,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 1795955,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 1795724,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 1792134,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 1576631,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 1711490,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 2062190,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 2009679,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 1920430,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 1885003,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 1825314,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 1795955,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 1795724,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            },
            {
                "id": 1792134,
                "content": [
                    {
                        "username": "t_Mz",
                        "content": "Please upvote this solution if it helps you :)\\n\\nselect user_id, count(follower_id) as followers_count\\nfrom followers\\ngroup by user_id\\norder by user_id"
                    },
                    {
                        "username": "smcroberts39",
                        "content": "I\\'m not sure what\\'s going on here.  I hit run and I get the correct answer, but then I hit submit and I get a totally different set of data in my output that is incorrect."
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "you need to use order by user_id after group by user_id, it will work."
                    },
                    {
                        "username": "Sohail17",
                        "content": "Because there are different dataset associated with test cases your solution might have failed to passed some test cases"
                    },
                    {
                        "username": "Abantika_Choudhary",
                        "content": "select distinct(user_id),count(user_id) as followers_count\\nfrom followers \\ngroup by user_id\\norder by user_id;"
                    },
                    {
                        "username": "AnEmos82",
                        "content": "https://www.linkedin.com/pulse/leetcode-sql50-%25CE%25BD%25CE%25B9%25CE%25BA%25CF%258C%25CE%25BB%25CE%25B1%25CE%25BF%25CF%2582-%25CE%25BC%25CF%258C%25CF%2583%25CE%25B1%25CE%25BB%25CE%25BF%25CF%2582"
                    },
                    {
                        "username": "leyantaliatang",
                        "content": "SELECT user_id,COUNT(*) AS followers_count\\nFROM followers\\nGROUP BY user_id\\nORDER BY user_id;"
                    },
                    {
                        "username": "lucasschnee",
                        "content": "SELECT user_id, COUNT(DISTINCT(follower_id)) as followers_count\\nFROM Followers\\nGROUP BY user_id"
                    },
                    {
                        "username": "jayramesh0",
                        "content": "How are the followers of user_id=1 0 for this input and output?\\nInput: \\nFollowers table:\\n+---------+-------------+\\n| user_id | follower_id |\\n+---------+-------------+\\n| 0       | 1           |\\n| 1       | 0           |\\n| 2       | 0           |\\n| 2       | 1           |\\n+---------+-------------+\\nOutput: \\n+---------+----------------+\\n| user_id | followers_count|\\n+---------+----------------+\\n| 0       | 1              |\\n| 1       | 1              |\\n| 2       | 2              |\\n+---------+----------------+\\nExplanation: \\nThe followers of 0 are {1}\\nThe followers of 1 are {0}\\nThe followers of 2 are {0,1}"
                    },
                    {
                        "username": "Nishantvohra",
                        "content": "select user_id, count(follower_id) as \\'followers_count\\' from Followers group by user_id order by 1;"
                    },
                    {
                        "username": "duttak",
                        "content": "`SELECT user_id, COUNT(follower_id) as followers_count\\nFROM Followers\\nGROUP BY user_id`;\\n\\nInstead of GROUP BY user_id, I wanted to use DISTINCT user_id.\\n\\nBut, why \\'DISTINCT (user_id)\\' in the SELECT statement won\\'t work here?\\n"
                    },
                    {
                        "username": "swayam04",
                        "content": "The real reason is that while GROUP BY groups the rows first then applies aggregate functions, DISTINCT is applied after all rows are generated. While generating the rows, an aggregate function does not make sense as there are no groups. At least this is what I understand from my knowledge of query execution order."
                    },
                    {
                        "username": "Dsowmya",
                        "content": "Group by need to be used when aggregate functions(count) are used, so group by cannot be replaced with distinct in the query"
                    },
                    {
                        "username": "user2392CP",
                        "content": "select user_id , count(user_id) as followers_count\\nfrom Followers\\ngroup by user_id\\norder by user_id;"
                    }
                ]
            }
        ]
    }
]